#!/usr/bin/env node

!(function(modules) {
  var installedModules = {};

  function __webpack_require__(moduleId) {
    var module = installedModules[moduleId];
    if (module) return module.exports;

    installedModules[moduleId] = module = { i: moduleId, l: false, exports: {} };
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

    module.l = true;
    return module.exports;
  }

  __webpack_require__.m = modules;
  __webpack_require__.c = installedModules;
  __webpack_require__(2);
})([
// 0
function(module) {

module.exports = require("fs");

},
// 1
function(module) {

module.exports = require("path");

},
// 2
function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(3);

var fs = __webpack_require__(0),
  info = __webpack_require__(4),
  path = __webpack_require__(1),
  program = __webpack_require__(5),

  Terser = __webpack_require__(9);
try {
  __webpack_require__(10).install();
} catch (_) {}

const skip_keys = new Set(["cname", "parent_scope", "scope", "uses_eval", "uses_with", "_var_name_cache"]);
var files = {},
  options = { compress: false, mangle: false };
program.version(info.name + " " + info.version);
program.parseArgv = program.parse;
program.parse = void 0;
if (process.argv.includes("ast")) program.helpInformation = describe_ast;
else if (process.argv.includes("options")) program.helpInformation = function() {
  var text = [],
    options = Terser.default_options();
  for (var option in options) {
    text.push("--" + (option === "output" ? "beautify" : option === "sourceMap" ? "source-map" : option) + " options:");
    text.push(format_object(options[option]));
    text.push("");
  }
  return text.join("\n");
};
program.option("-p, --parse <options>", "Specify parser options.", parse_js());
program.option("-c, --compress [options]", "Enable compressor/specify compressor options.", parse_js());
program.option("-m, --mangle [options]", "Mangle names/specify mangler options.", parse_js());
program.option("--mangle-props [options]", "Mangle properties/specify mangler options.", parse_js());
program.option("-b, --beautify [options]", "Beautify output/specify output options.", parse_js());
program.option("-o, --output <file>", "Output file (default STDOUT).");
program.option("--comments [filter]", "Preserve copyright comments in the output.");
program.option("--config-file <file>", "Read minify() options from JSON file.");
program.option("-d, --define <expr>[=value]", "Global definitions.", parse_js("define"));
program.option("--ecma <version>", "Specify ECMAScript release: 5, 2015, 2016 or 2017...");
program.option("-e, --enclose [arg[,...][:value[,...]]]", "Embed output in a big function with configurable arguments and values.");
program.option("--ie8", "Support non-standard Internet Explorer 8.");
program.option("--keep-classnames", "Do not mangle/drop class names.");
program.option("--keep-fnames", "Do not mangle/drop function names. Useful for code relying on Function.prototype.name.");
program.option("--module", "Input is an ES6 module");
program.option("--name-cache <file>", "File to hold mangled name mappings.");
program.option("--rename", "Force symbol expansion.");
program.option("--no-rename", "Disable symbol expansion.");
program.option("--safari10", "Support non-standard Safari 10.");
program.option("--source-map [options]", "Enable source map/specify source map options.", parse_js());
program.option("--timings", "Display operations run time on STDERR.");
program.option("--toplevel", "Compress and/or mangle variables in toplevel scope.");
program.option("--verbose", "Print diagnostic messages.");
program.option("--warn", "Print warning messages.");
program.option("--wrap <name>", "Embed everything as a function with “exports” corresponding to “name” globally.");
program.arguments("[files...]").parseArgv(process.argv);
if (program.configFile) options = JSON.parse(read_file(program.configFile));

program.output || !program.sourceMap || program.sourceMap.url == "inline" || fatal("ERROR: cannot write source map to STDOUT");

["compress", "enclose", "ie8", "mangle", "module", "safari10", "sourceMap", "toplevel", "wrap"].forEach(function(name) {
  if (name in program) options[name] = typeof program[name] == "object"
    ? Object.assign((typeof options[name] == "object" && options[name]) || {}, program[name])
    : program[name];
});
if ("ecma" in program) {
  program.ecma == (program.ecma | 0) || fatal("ERROR: ecma must be an integer");
  const ecma = program.ecma | 0;
  options.ecma = ecma > 5 && ecma < 2015 ? ecma + 2009 : ecma;
}
if (program.beautify) {
  options.output = Object.assign(
    (typeof options.output == "object" && options.output) || {}, typeof program.beautify == "object" ? program.beautify : {}
  );
  "beautify" in options.output || (options.output.beautify = true);
}
if (program.comments) {
  if (typeof options.output != "object") options.output = {};
  options.output.comments = typeof program.comments == "string" ? program.comments != "false" && program.comments : "some";
}
if (program.define) {
  if (typeof options.compress != "object") options.compress = {};
  if (typeof options.compress.global_defs != "object") options.compress.global_defs = {};
  for (var expr in program.define) options.compress.global_defs[expr] = program.define[expr];
}
if (program.keepClassnames) options.keep_classnames = true;

if (program.keepFnames) options.keep_fnames = true;

if (program.mangleProps) {
  if (program.mangleProps.domprops) delete program.mangleProps.domprops;
  else {
    if (typeof program.mangleProps != "object") program.mangleProps = {};
    Array.isArray(program.mangleProps.reserved) || (program.mangleProps.reserved = []);
  }
  if (typeof options.mangle != "object") options.mangle = {};
  options.mangle.properties = program.mangleProps;
}
if (program.nameCache) options.nameCache = JSON.parse(read_file(program.nameCache, "{}"));

if (program.output == "ast") options.output = { ast: true, code: false };

if (program.parse)
  !program.parse.acorn && !program.parse.spidermonkey ? (options.parse = program.parse)
    : program.sourceMap && program.sourceMap.content == "inline" && fatal("ERROR: inline source map only works with built-in parser");

~program.rawArgs.indexOf("--rename") ? (options.rename = true) : program.rename || (options.rename = false);

var convert_path = function(name) {
  return name;
};
if (typeof program.sourceMap == "object" && "base" in program.sourceMap)
  convert_path = (function() {
    var base = program.sourceMap.base;
    delete options.sourceMap.base;
    return function(name) {
      return path.relative(base, name);
    };
  })();

program.verbose ? (options.warnings = "verbose") : program.warn && (options.warnings = true);

let filesList;
if (options.files && options.files.length) {
  filesList = options.files;

  delete options.files;
} else if (program.args.length) filesList = program.args;

if (filesList) {
  simple_glob(filesList).forEach(function(name) {
    files[convert_path(name)] = read_file(name);
  });
  run();
} else {
  var chunks = [];
  process.stdin.setEncoding("utf8");
  process.stdin.on("data", function(chunk) {
    chunks.push(chunk);
  }).on("end", function() {
    files = [chunks.join("")];
    run();
  });
  process.stdin.resume();
}

function convert_ast(fn) {
  return Terser.AST_Node.from_mozilla_ast(Object.keys(files).reduce(fn, null));
}

function run() {
  Terser.AST_Node.warn_function = function(msg) {
    print_error("WARN: " + msg);
  };
  var content = program.sourceMap && program.sourceMap.content;
  if (content && content !== "inline") options.sourceMap.content = read_file(content, content);

  if (program.timings) options.timings = true;
  try {
    if (program.parse)
      if (program.parse.acorn)
        files = convert_ast(function(toplevel, name) {
          return __webpack_require__(13).parse(files[name], {
            ecmaVersion: 2018,
            locations: true,
            program: toplevel,
            sourceFile: name,
            sourceType: options.module || program.parse.module ? "module" : "script"
          });
        });
      else if (program.parse.spidermonkey)
        files = convert_ast(function(toplevel, name) {
          var obj = JSON.parse(files[name]);
          if (!toplevel) return obj;
          toplevel.body = toplevel.body.concat(obj.body);
          return toplevel;
        });
  } catch (ex) {
    fatal(ex);
  }
  var result = Terser.minify(files, options);
  if (result.error) {
    var ex = result.error;
    if (ex.name == "SyntaxError") {
      print_error("Parse error at " + ex.filename + ":" + ex.line + "," + ex.col);
      var col = ex.col,
        lines = files[ex.filename].split(/\r?\n/),
        line = lines[ex.line - 1];
      line || col || (col = (line = lines[ex.line - 2]).length);

      if (line) {
        var limit = 70;
        if (col > limit) {
          line = line.slice(col - limit);
          col = limit;
        }
        print_error(line.slice(0, 80));
        print_error(line.slice(0, col).replace(/\S/g, " ") + "^");
      }
    }
    if (ex.defs) {
      print_error("Supported options:");
      print_error(format_object(ex.defs));
    }
    fatal(ex);
  } else if (program.output == "ast") {
    options.compress || options.mangle || result.ast.figure_out_scope({});

    print(JSON.stringify(result.ast, function(key, value) {
      if (value) switch (key) {
        case "thedef":
          return symdef(value);
        case "enclosed":
          return value.length ? value.map(symdef) : void 0;
        case "variables":
        case "functions":
        case "globals":
          return value.size ? collect_from_map(value, symdef) : void 0;
      }
      if (skip_keys.has(key) || value instanceof Terser.AST_Token || value instanceof Map) return;
      if (value instanceof Terser.AST_Node) {
        var result = { _class: "AST_" + value.TYPE };
        if (value.block_scope) {
          result.variables = value.block_scope.variables;
          result.functions = value.block_scope.functions;
          result.enclosed = value.block_scope.enclosed;
        }
        value.CTOR.PROPS.forEach(function(prop) {
          if (prop !== "block_scope") result[prop] = value[prop];
        });
        return result;
      }
      return value;
    }, 2));
  } else if (program.output == "spidermonkey")
    print(JSON.stringify(Terser.minify(result.code, {
      compress: false,
      mangle: false,
      output: { ast: true, code: false }
    }).ast.to_mozilla_ast(), null, 2));
  else if (program.output) {
    fs.writeFileSync(program.output, result.code);
    options.sourceMap.url !== "inline" && result.map && fs.writeFileSync(program.output + ".map", result.map);
  } else print(result.code);

  program.nameCache && fs.writeFileSync(program.nameCache, JSON.stringify(options.nameCache));

  if (result.timings) for (var phase in result.timings) print_error("- " + phase + ": " + result.timings[phase].toFixed(3) + "s");
}

function fatal(message) {
  if (message instanceof Error) message = message.stack.replace(/^\S*?Error:/, "ERROR:");
  print_error(message);
  process.exit(1);
}

function simple_glob(glob) {
  if (Array.isArray(glob)) return [].concat.apply([], glob.map(simple_glob));

  if (glob && glob.match(/[*?]/)) {
    var dir = path.dirname(glob);
    try {
      var entries = fs.readdirSync(dir);
    } catch (_) {}
    if (entries) {
      var pattern = "^" + path.basename(glob)
        .replace(/[.+^$[\]\\(){}]/g, "\\$&")
        .replace(/\*/g, "[^/\\\\]*")
        .replace(/\?/g, "[^/\\\\]") + "$";
      var mod = process.platform === "win32" ? "i" : "",
        rx = new RegExp(pattern, mod);
      var results = entries.filter(function(name) {
        return rx.test(name);
      }).map(function(name) {
        return path.join(dir, name);
      });
      if (results.length) return results;
    }
  }
  return [glob];
}

function read_file(path, default_value) {
  try {
    return fs.readFileSync(path, "utf8");
  } catch (ex) {
    if ((ex.code == "ENOENT" || ex.code == "ENAMETOOLONG") && default_value != null) return default_value;
    fatal(ex);
  }
}

function parse_js(flag) {
  return function(value, options) {
    options = options || {};
    try {
      Terser.parse(value, { expression: true }).walk(new Terser.TreeWalker(function(node) {
        if (node instanceof Terser.AST_Assign) {
          var name = node.left.print_to_string(),
            value = node.right;
          if (flag) options[name] = value;
          else if (value instanceof Terser.AST_Array) options[name] = value.elements.map(to_string);
          else if (value instanceof Terser.AST_RegExp) {
            value = value.value;
            options[name] = new RegExp(value.source, value.flags);
          } else options[name] = to_string(value);

          return true;
        }
        if (node instanceof Terser.AST_Symbol || node instanceof Terser.AST_PropAccess) {
          name = node.print_to_string();
          options[name] = true;
          return true;
        }
        if (!(node instanceof Terser.AST_Sequence)) throw node;

        function to_string(value) {
          return value instanceof Terser.AST_Constant ? value.getValue() : value.print_to_string({ quote_keys: true });
        }
      }));
    } catch (ex) {
      flag ? fatal("Error parsing arguments for '" + flag + "': " + value) : (options[value] = null);
    }
    return options;
  };
}

function symdef(def) {
  var ret = 1e6 + def.id + " " + def.name;
  if (def.mangled_name) ret += " " + def.mangled_name;
  return ret;
}

function collect_from_map(map, callback) {
  var result = [];
  map.forEach(function(def) {
    result.push(callback(def));
  });
  return result;
}

function format_object(obj) {
  var lines = [],
    padding = "";
  Object.keys(obj).map(function(name) {
    if (padding.length < name.length) padding = Array(name.length + 1).join(" ");
    return [name, JSON.stringify(obj[name])];
  }).forEach(function(tokens) {
    lines.push("  " + tokens[0] + padding.slice(tokens[0].length - 2) + tokens[1]);
  });
  return lines.join("\n");
}

function print_error(msg) {
  process.stderr.write(msg);
  process.stderr.write("\n");
}

function print(txt) {
  process.stdout.write(txt);
  process.stdout.write("\n");
}

function describe_ast() {
  var out = Terser.OutputStream({ beautify: true });
  function doitem(ctor) {
    out.print("AST_" + ctor.TYPE);
    var props = ctor.SELF_PROPS.filter(function(/** string */ prop) {
      return !/^\$/.test(prop);
    });
    if (props.length > 0) {
      out.space();
      out.with_parens(function() {
        props.forEach(function(prop, i) {
          i && out.space();
          out.print(prop);
        });
      });
    }
    if (ctor.documentation) {
      out.space();
      out.print_string(ctor.documentation);
    }
    if (ctor.SUBCLASSES.length > 0) {
      out.space();
      out.with_block(function() {
        ctor.SUBCLASSES.forEach(function(ctor, _i) {
          out.indent();
          doitem(ctor);
          out.newline();
        });
      });
    }
  }
  doitem(Terser.AST_Node);
  return out + "\n";
}

},
// 3
function() {

var exit = process.exit;
process.exit = function() {
  var args = [].slice.call(arguments);
  process.once("uncaughtException", function() {
    !(function callback() {
      process.stdout.bufferSize || process.stderr.bufferSize ? setImmediate(callback) : exit.apply(process, args);
    })();
  });
  throw exit;
};

},
// 4
function(module) {

module.exports = { name: "terser", homepage: "https://terser.org", license: "BSD-2-Clause", version: "4.8.1" };

},
// 5
function(module, exports, __webpack_require__) {

var EventEmitter = __webpack_require__(6).EventEmitter,
  spawn = __webpack_require__(7).spawn,
  path = __webpack_require__(1),
  dirname = path.dirname,
  basename = path.basename,
  fs = __webpack_require__(0);

__webpack_require__(8).inherits(Command, EventEmitter);

exports = module.exports = new Command();

exports.Command = Command;
exports.Option = Option;

function Option(flags, description) {
  this.flags = flags;
  this.required = flags.indexOf('<') >= 0;
  this.optional = flags.indexOf('[') >= 0;
  this.bool = flags.indexOf('-no-') === -1;
  if ((flags = flags.split(/[ ,|]+/)).length > 1 && !/^[[<]/.test(flags[1])) this.short = flags.shift();
  this.long = flags.shift();
  this.description = description || '';
}

Option.prototype.name = function() {
  return this.long.replace('--', '').replace('no-', '');
};

Option.prototype.attributeName = function() {
  return camelcase(this.name());
};

Option.prototype.is = function(arg) {
  return this.short === arg || this.long === arg;
};

function Command(name) {
  this.commands = [];
  this.options = [];
  this._execs = {};
  this._allowUnknownOption = false;
  this._args = [];
  this._name = name || '';
}

Command.prototype.command = function(name, desc, opts) {
  if (typeof desc == 'object' && desc !== null) {
    opts = desc;
    desc = null;
  }
  opts = opts || {};
  var args = name.split(/ +/),
    cmd = new Command(args.shift());

  if (desc) {
    cmd.description(desc);
    this.executables = true;
    this._execs[cmd._name] = true;
    if (opts.isDefault) this.defaultExecutable = cmd._name;
  }
  cmd._noHelp = !!opts.noHelp;
  this.commands.push(cmd);
  cmd.parseExpectedArgs(args);
  cmd.parent = this;

  return desc ? this : cmd;
};

Command.prototype.arguments = function(desc) {
  return this.parseExpectedArgs(desc.split(/ +/));
};

Command.prototype.addImplicitHelpCommand = function() {
  this.command('help [cmd]', 'display help for [cmd]');
};

Command.prototype.parseExpectedArgs = function(args) {
  if (!args.length) return;
  var self = this;
  args.forEach(function(arg) {
    var argDetails = { required: false, name: '', variadic: false };

    switch (arg[0]) {
      case '<':
        argDetails.required = true;
        argDetails.name = arg.slice(1, -1);
        break;
      case '[':
        argDetails.name = arg.slice(1, -1);
        break;
    }

    if (argDetails.name.length > 3 && argDetails.name.slice(-3) === '...') {
      argDetails.variadic = true;
      argDetails.name = argDetails.name.slice(0, -3);
    }
    argDetails.name && self._args.push(argDetails);
  });
  return this;
};

Command.prototype.action = function(fn) {
  var self = this;
  var listener = function(args, unknown) {
    args = args || [];
    unknown = unknown || [];

    var parsed = self.parseOptions(unknown);

    outputHelpIfNecessary(self, parsed.unknown);

    parsed.unknown.length > 0 && self.unknownOption(parsed.unknown[0]);

    if (parsed.args.length) args = parsed.args.concat(args);

    self._args.forEach(function(arg, i) {
      if (arg.required && args[i] == null) self.missingArgument(arg.name);
      else if (arg.variadic) {
        i === self._args.length - 1 || self.variadicArgNotLast(arg.name);

        args[i] = args.splice(i);
      }
    });

    self._args.length ? (args[self._args.length] = self) : args.push(self);

    fn.apply(self, args);
  };
  var parent = this.parent || this,
    name = parent === this ? '*' : this._name;
  parent.on('command:' + name, listener);
  this._alias && parent.on('command:' + this._alias, listener);
  return this;
};

Command.prototype.option = function(flags, description, fn, defaultValue) {
  var self = this,
    option = new Option(flags, description),
    oname = option.name(),
    name = option.attributeName();

  if (typeof fn != 'function')
    if (fn instanceof RegExp) {
      var regex = fn;
      fn = function(val, def) {
        var m = regex.exec(val);
        return m ? m[0] : def;
      };
    } else {
      defaultValue = fn;
      fn = null;
    }

  if (!option.bool || option.optional || option.required) {
    option.bool || (defaultValue = true);
    if (defaultValue !== void 0) {
      self[name] = defaultValue;
      option.defaultValue = defaultValue;
    }
  }

  this.options.push(option);

  this.on('option:' + oname, function(val) {
    if (val !== null && fn) val = fn(val, self[name] === void 0 ? defaultValue : self[name]);

    typeof self[name] == 'boolean' || self[name] === void 0
      ? (self[name] = val == null ? !!option.bool && (defaultValue || true) : val)
      : val === null || (self[name] = val);
  });

  return this;
};

Command.prototype.allowUnknownOption = function(arg) {
  this._allowUnknownOption = arguments.length === 0 || arg;
  return this;
};

Command.prototype.parse = function(argv) {
  this.executables && this.addImplicitHelpCommand();

  this.rawArgs = argv;

  this._name = this._name || basename(argv[1], '.js');

  !this.executables || argv.length > 2 || this.defaultExecutable || argv.push('--help');

  var parsed = this.parseOptions(this.normalize(argv.slice(2))),
    args = (this.args = parsed.args),

    result = this.parseArgs(this.args, parsed.unknown),
    name = result.args[0],

    aliasCommand = null;
  if (name)
    aliasCommand = this.commands.filter(function(command) {
      return command.alias() === name;
    })[0];

  if (this._execs[name] === true) return this.executeSubCommand(argv, args, parsed.unknown);
  if (aliasCommand) {
    args[0] = aliasCommand._name;
    return this.executeSubCommand(argv, args, parsed.unknown);
  }
  if (this.defaultExecutable) {
    args.unshift(this.defaultExecutable);
    return this.executeSubCommand(argv, args, parsed.unknown);
  }

  return result;
};

Command.prototype.executeSubCommand = function(argv, args, unknown) {
  (args = args.concat(unknown)).length || this.help();
  args[0] !== 'help' || args.length !== 1 || this.help();

  if (args[0] === 'help') {
    args[0] = args[1];
    args[1] = '--help';
  }

  var baseDir,
    f = argv[1],
    bin = basename(f, path.extname(f)) + '-' + args[0],

    resolvedLink = fs.realpathSync(f);

  baseDir = dirname(resolvedLink);

  var proc,
    localBin = path.join(baseDir, bin),

    isExplicitJS = false;
  if (exists(localBin + '.js')) {
    bin = localBin + '.js';
    isExplicitJS = true;
  } else if (exists(localBin + '.ts')) {
    bin = localBin + '.ts';
    isExplicitJS = true;
  } else if (exists(localBin)) bin = localBin;

  args = args.slice(1);

  if (process.platform !== 'win32')
    if (isExplicitJS) {
      args.unshift(bin);
      args = (process.execArgv || []).concat(args);

      proc = spawn(process.argv[0], args, { stdio: 'inherit', customFds: [0, 1, 2] });
    } else proc = spawn(bin, args, { stdio: 'inherit', customFds: [0, 1, 2] });
  else {
    args.unshift(bin);
    proc = spawn(process.execPath, args, { stdio: 'inherit' });
  }

  ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'].forEach(function(signal) {
    process.on(signal, function() {
      proc.killed !== false || proc.exitCode !== null || proc.kill(signal);
    });
  });
  proc.on('close', process.exit.bind(process));
  proc.on('error', function(err) {
    err.code === 'ENOENT' ? console.error('error: %s(1) does not exist, try --help', bin)
      : err.code !== 'EACCES' || console.error('error: %s(1) not executable. try chmod or run with root', bin);

    process.exit(1);
  });

  this.runningCommand = proc;
};

Command.prototype.normalize = function(args) {
  var ret = [];

  for (var arg, lastOpt, index, i = 0, len = args.length; i < len; ++i) {
    arg = args[i];
    if (i > 0) lastOpt = this.optionFor(args[i - 1]);

    if (arg === '--') {
      ret = ret.concat(args.slice(i));
      break;
    }
    lastOpt && lastOpt.required
      ? ret.push(arg)
      : arg.length > 1 && arg[0] === '-' && arg[1] !== '-'
      ? arg.slice(1).split('').forEach((c) => ret.push('-' + c))
      : /^--/.test(arg) && ~(index = arg.indexOf('='))
      ? ret.push(arg.slice(0, index), arg.slice(index + 1))
      : ret.push(arg);
  }

  return ret;
};

Command.prototype.parseArgs = function(args, unknown) {
  var name;

  if (args.length) {
    name = args[0];
    this.listeners('command:' + name).length ? this.emit('command:' + args.shift(), args, unknown) : this.emit('command:*', args);
  } else {
    outputHelpIfNecessary(this, unknown);

    unknown.length > 0 && this.unknownOption(unknown[0]);

    this.commands.length !== 0 || this._args.filter((a) => a.required).length !== 0 || this.emit('command:*');
  }

  return this;
};

Command.prototype.optionFor = function(arg) {
  for (var i = 0, len = this.options.length; i < len; ++i) if (this.options[i].is(arg)) return this.options[i];
};

Command.prototype.parseOptions = function(argv) {
  var args = [],
    unknownOptions = [];

  for (var literal, option, arg, len = argv.length, i = 0; i < len; ++i) {
    arg = argv[i];

    if (literal) args.push(arg);
    else if (arg === '--') literal = true;
    else if ((option = this.optionFor(arg)))
      if (option.required) {
        if ((arg = argv[++i]) == null) return this.optionMissingArgument(option);
        this.emit('option:' + option.name(), arg);
      } else if (option.optional) {
        (arg = argv[i + 1]) == null || (arg[0] === '-' && arg !== '-') ? (arg = null) : ++i;

        this.emit('option:' + option.name(), arg);
      } else this.emit('option:' + option.name());
    else if (arg.length > 1 && arg[0] === '-') {
      unknownOptions.push(arg);

      i + 1 < argv.length && argv[i + 1][0] !== '-' && unknownOptions.push(argv[++i]);
    } else args.push(arg);
  }

  return { args: args, unknown: unknownOptions };
};

Command.prototype.opts = function() {
  var result = {};

  for (var len = this.options.length, i = 0; i < len; i++) {
    var key = this.options[i].attributeName();
    result[key] = key === this._versionOptionName ? this._version : this[key];
  }
  return result;
};

Command.prototype.missingArgument = function(name) {
  console.error("error: missing required argument `%s'", name);
  process.exit(1);
};

Command.prototype.optionMissingArgument = function(option, flag) {
  flag
    ? console.error("error: option `%s' argument missing, got `%s'", option.flags, flag)
    : console.error("error: option `%s' argument missing", option.flags);

  process.exit(1);
};

Command.prototype.unknownOption = function(flag) {
  if (this._allowUnknownOption) return;
  console.error("error: unknown option `%s'", flag);
  process.exit(1);
};

Command.prototype.variadicArgNotLast = function(name) {
  console.error("error: variadic arguments must be last `%s'", name);
  process.exit(1);
};

Command.prototype.version = function(str, flags) {
  if (arguments.length === 0) return this._version;
  this._version = str;
  var versionOption = new Option(flags || '-V, --version', 'output the version number');
  this._versionOptionName = versionOption.long.substr(2) || 'version';
  this.options.push(versionOption);
  this.on('option:' + this._versionOptionName, function() {
    process.stdout.write(str + '\n');
    process.exit(0);
  });
  return this;
};

Command.prototype.description = function(str, argsDescription) {
  if (arguments.length === 0) return this._description;
  this._description = str;
  this._argsDescription = argsDescription;
  return this;
};

Command.prototype.alias = function(alias) {
  var command = this;
  if (this.commands.length !== 0) command = this.commands[this.commands.length - 1];

  if (arguments.length === 0) return command._alias;

  if (alias === command._name) throw new Error("Command alias can't be the same as its name");

  command._alias = alias;
  return this;
};

Command.prototype.usage = function(str) {
  var args = this._args.map((arg) => humanReadableArgName(arg)),

    usage = '[options]' + (this.commands.length ? ' [command]' : '') + (this._args.length ? ' ' + args.join(' ') : '');

  if (arguments.length === 0) return this._usage || usage;
  this._usage = str;

  return this;
};

Command.prototype.name = function(str) {
  if (arguments.length === 0) return this._name;
  this._name = str;
  return this;
};

Command.prototype.prepareCommands = function() {
  return this.commands.filter(function(cmd) {
    return !cmd._noHelp;
  }).map(function(cmd) {
    var args = cmd._args.map((arg) => humanReadableArgName(arg)).join(' ');

    return [
      cmd._name + (cmd._alias ? '|' + cmd._alias : '') + (cmd.options.length ? ' [options]' : '') + (args ? ' ' + args : ''),
      cmd._description
    ];
  });
};

Command.prototype.largestCommandLength = function() {
  return this.prepareCommands().reduce(function(max, command) {
    return Math.max(max, command[0].length);
  }, 0);
};

Command.prototype.largestOptionLength = function() {
  var options = [].slice.call(this.options);
  options.push({ flags: '-h, --help' });
  return options.reduce(function(max, option) {
    return Math.max(max, option.flags.length);
  }, 0);
};

Command.prototype.largestArgLength = function() {
  return this._args.reduce(function(max, arg) {
    return Math.max(max, arg.name.length);
  }, 0);
};

Command.prototype.padWidth = function() {
  var width = this.largestOptionLength();
  if (this._argsDescription && this._args.length && this.largestArgLength() > width) width = this.largestArgLength();

  if (this.commands && this.commands.length && this.largestCommandLength() > width) width = this.largestCommandLength();

  return width;
};

Command.prototype.optionHelp = function() {
  var width = this.padWidth();

  return this.options.map(function(option) {
    return pad(option.flags, width) + '  ' + option.description +
      (option.bool && option.defaultValue !== void 0 ? ' (default: ' + JSON.stringify(option.defaultValue) + ')' : '');
  }).concat([pad('-h, --help', width) + '  output usage information'])
    .join('\n');
};

Command.prototype.commandHelp = function() {
  if (!this.commands.length) return '';

  var commands = this.prepareCommands(),
    width = this.padWidth();

  return [
    'Commands:',
    commands.map(function(cmd) {
      var desc = cmd[1] ? '  ' + cmd[1] : '';
      return (desc ? pad(cmd[0], width) : cmd[0]) + desc;
    }).join('\n').replace(/^/gm, '  '),
    ''
  ].join('\n');
};

Command.prototype.helpInformation = function() {
  var desc = [];
  if (this._description) {
    desc = [this._description, ''];

    var argsDescription = this._argsDescription;
    if (argsDescription && this._args.length) {
      var width = this.padWidth();
      desc.push('Arguments:');
      desc.push('');
      this._args.forEach(function(arg) {
        desc.push('  ' + pad(arg.name, width) + '  ' + argsDescription[arg.name]);
      });
      desc.push('');
    }
  }

  var cmdName = this._name;
  if (this._alias) cmdName = cmdName + '|' + this._alias;

  var usage = ['Usage: ' + cmdName + ' ' + this.usage(), ''],

    cmds = [],
    commandHelp = this.commandHelp();
  if (commandHelp) cmds = [commandHelp];

  var options = ['Options:', '' + this.optionHelp().replace(/^/gm, '  '), ''];

  return usage.concat(desc).concat(options).concat(cmds).join('\n');
};

Command.prototype.outputHelp = function(cb) {
  cb || (cb = (passthru) => passthru);

  process.stdout.write(cb(this.helpInformation()));
  this.emit('--help');
};

Command.prototype.help = function(cb) {
  this.outputHelp(cb);
  process.exit();
};

function camelcase(flag) {
  return flag.split('-').reduce(function(str, word) {
    return str + word[0].toUpperCase() + word.slice(1);
  });
}

function pad(str, width) {
  var len = Math.max(0, width - str.length);
  return str + Array(len + 1).join(' ');
}

function outputHelpIfNecessary(cmd, options) {
  options = options || [];
  for (var i = 0; i < options.length; i++)
    if (options[i] === '--help' || options[i] === '-h') {
      cmd.outputHelp();
      process.exit(0);
    }
}

function humanReadableArgName(arg) {
  var nameOutput = arg.name + (arg.variadic === true ? '...' : '');

  return arg.required ? '<' + nameOutput + '>' : '[' + nameOutput + ']';
}

function exists(file) {
  try {
    if (fs.statSync(file).isFile()) return true;
  } catch (e) {
    return false;
  }
}

},
// 6
function(module) {

module.exports = require("events");

},
// 7
function(module) {

module.exports = require("child_process");

},
// 8
function(module) {

module.exports = require("util");

},
// 9
function(module) {

module.exports = require("..");

},
// 10
function(module, exports, __webpack_require__) {

var fs,
  SourceMapConsumer = __webpack_require__(11).SourceMapConsumer,
  path = __webpack_require__(1);

try {
  if (!(fs = __webpack_require__(0)).existsSync || !fs.readFileSync) fs = null;
} catch (_) {}

var bufferFrom = __webpack_require__(12),

  errorFormatterInstalled = false,
  uncaughtShimInstalled = false,
  emptyCacheBetweenOperations = false,

  environment = "auto",
  fileContentsCache = {},
  sourceMapCache = {},

  reSourceMap = /^data:application\/json[^,]+base64,/,

  retrieveFileHandlers = [],
  retrieveMapHandlers = [];

function isInBrowser() {
  return environment === "browser" ||
    (environment !== "node" &&
      typeof window != 'undefined' && typeof XMLHttpRequest == 'function' &&
      !(window.require && window.module && window.process && window.process.type === "renderer"));
}

function hasGlobalProcessEventEmitter() {
  return typeof process == 'object' && process !== null && typeof process.on == 'function';
}

function globalProcessVersion() {
  return typeof process == 'object' && process !== null ? process.version : '';
}

function globalProcessStderr() {
  if (typeof process == 'object' && process !== null) return process.stderr;
}

function globalProcessExit(code) {
  if (typeof process == 'object' && process !== null && typeof process.exit == 'function') return process.exit(code);
}

function handlerExec(list) {
  return function(arg) {
    for (var i = 0; i < list.length; i++) {
      var ret = list[i](arg);
      if (ret) return ret;
    }
    return null;
  };
}

var retrieveFile = handlerExec(retrieveFileHandlers);

retrieveFileHandlers.push(function(path) {
  path = path.trim();
  if (/^file:/.test(path))
    path = path.replace(/file:\/\/\/(\w:)?/, function(protocol, drive) {
      return drive ? '' : '/';
    });

  if (path in fileContentsCache) return fileContentsCache[path];

  var contents = '';
  try {
    if (!fs) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', path, false);
      xhr.send(null);
      if (xhr.readyState === 4 && xhr.status === 200) contents = xhr.responseText;
    } else if (fs.existsSync(path)) contents = fs.readFileSync(path, 'utf8');
  } catch (_) {}

  return (fileContentsCache[path] = contents);
});

function supportRelativeURL(file, url) {
  if (!file) return url;
  var dir = path.dirname(file),
    match = /^\w+:\/\/[^\/]*/.exec(dir),
    protocol = match ? match[0] : '',
    startPath = dir.slice(protocol.length);
  return protocol && /^\/\w:/.test(startPath)
    ? (protocol += '/') + path.resolve(dir.slice(protocol.length), url).replace(/\\/g, '/')
    : protocol + path.resolve(dir.slice(protocol.length), url);
}

function retrieveSourceMapURL(source) {
  var fileData;

  if (isInBrowser())
    try {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', source, false);
      xhr.send(null);
      fileData = xhr.readyState === 4 ? xhr.responseText : null;

      var sourceMapHeader = xhr.getResponseHeader("SourceMap") || xhr.getResponseHeader("X-SourceMap");
      if (sourceMapHeader) return sourceMapHeader;
    } catch (_) {}

  fileData = retrieveFile(source);
  var lastMatch,
    re = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/gm;
  for (var match; (match = re.exec(fileData)); ) lastMatch = match;
  return !lastMatch ? null : lastMatch[1];
}

var retrieveSourceMap = handlerExec(retrieveMapHandlers);
retrieveMapHandlers.push(function(source) {
  var sourceMapData,
    sourceMappingURL = retrieveSourceMapURL(source);
  if (!sourceMappingURL) return null;

  if (reSourceMap.test(sourceMappingURL)) {
    var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);
    sourceMapData = bufferFrom(rawData, "base64").toString();
    sourceMappingURL = source;
  } else {
    sourceMappingURL = supportRelativeURL(source, sourceMappingURL);
    sourceMapData = retrieveFile(sourceMappingURL);
  }

  return !sourceMapData ? null : { url: sourceMappingURL, map: sourceMapData };
});

function mapSourcePosition(position) {
  var sourceMap = sourceMapCache[position.source];
  if (!sourceMap) {
    var urlAndMap = retrieveSourceMap(position.source);
    urlAndMap
      ? (sourceMap = sourceMapCache[position.source] = { url: urlAndMap.url, map: new SourceMapConsumer(urlAndMap.map) }).map
          .sourcesContent &&
        sourceMap.map.sources.forEach(function(source, i) {
          var contents = sourceMap.map.sourcesContent[i];
          if (contents) {
            var url = supportRelativeURL(sourceMap.url, source);
            fileContentsCache[url] = contents;
          }
        })
      : (sourceMap = sourceMapCache[position.source] = { url: null, map: null });
  }

  if (sourceMap && sourceMap.map && typeof sourceMap.map.originalPositionFor == 'function') {
    var originalPosition = sourceMap.map.originalPositionFor(position);

    if (originalPosition.source !== null) {
      originalPosition.source = supportRelativeURL(sourceMap.url, originalPosition.source);
      return originalPosition;
    }
  }

  return position;
}

function mapEvalOrigin(origin) {
  var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
  if (match) {
    var position = mapSourcePosition({ source: match[2], line: +match[3], column: match[4] - 1 });
    return 'eval at ' + match[1] + ' (' + position.source + ':' + position.line + ':' + (position.column + 1) + ')';
  }

  return (match = /^eval at ([^(]+) \((.+)\)$/.exec(origin)) ? 'eval at ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')' : origin;
}

function CallSiteToString() {
  var fileName,
    fileLocation = "";
  if (this.isNative()) fileLocation = "native";
  else {
    if (!(fileName = this.getScriptNameOrSourceURL()) && this.isEval()) {
      fileLocation = this.getEvalOrigin();
      fileLocation += ", ";
    }

    fileLocation += fileName || "<anonymous>";

    var lineNumber = this.getLineNumber();
    if (lineNumber != null) {
      fileLocation += ":" + lineNumber;
      var columnNumber = this.getColumnNumber();
      if (columnNumber) fileLocation += ":" + columnNumber;
    }
  }

  var line = "",
    functionName = this.getFunctionName(),
    addSuffix = true,
    isConstructor = this.isConstructor();
  if (!this.isToplevel() && !isConstructor) {
    var typeName = this.getTypeName();
    if (typeName === "[object Object]") typeName = "null";

    var methodName = this.getMethodName();
    if (functionName) {
      if (typeName && functionName.indexOf(typeName) != 0) line += typeName + ".";

      line += functionName;
      if (methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1)
        line += " [as " + methodName + "]";
    } else line += typeName + "." + (methodName || "<anonymous>");
  } else if (isConstructor) line += "new " + (functionName || "<anonymous>");
  else if (functionName) line += functionName;
  else {
    line += fileLocation;
    addSuffix = false;
  }
  if (addSuffix) line += " (" + fileLocation + ")";

  return line;
}

function cloneCallSite(frame) {
  var object = {};
  Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {
    object[name] = /^(?:is|get)/.test(name) ? () => frame[name].call(frame) : frame[name];
  });
  object.toString = CallSiteToString;
  return object;
}

function wrapCallSite(frame, state) {
  if (state === void 0) state = { nextPosition: null, curPosition: null };

  if (frame.isNative()) {
    state.curPosition = null;
    return frame;
  }

  var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
  if (source) {
    var line = frame.getLineNumber(),
      column = frame.getColumnNumber() - 1,

      headerLength = /^v?(10\.(1[6-9]|[2-9]\d|\d{3,})|1[2-9]|[2-9]\d|\d{3,}|11\.1[1-9])\b/.test(globalProcessVersion()) ? 0 : 62;
    if (line === 1 && column > headerLength && !isInBrowser() && !frame.isEval()) column -= headerLength;

    var position = mapSourcePosition({ source: source, line: line, column: column });
    state.curPosition = position;
    var originalFunctionName = (frame = cloneCallSite(frame)).getFunctionName;
    frame.getFunctionName = function() {
      return state.nextPosition == null ? originalFunctionName() : state.nextPosition.name || originalFunctionName();
    };
    frame.getFileName = () => position.source;
    frame.getLineNumber = () => position.line;
    frame.getColumnNumber = () => position.column + 1;
    frame.getScriptNameOrSourceURL = () => position.source;
    return frame;
  }

  var origin = frame.isEval() && frame.getEvalOrigin();
  if (origin) {
    origin = mapEvalOrigin(origin);
    (frame = cloneCallSite(frame)).getEvalOrigin = () => origin;
    return frame;
  }

  return frame;
}

function prepareStackTrace(error, stack) {
  if (emptyCacheBetweenOperations) {
    fileContentsCache = {};
    sourceMapCache = {};
  }

  var errorString = (error.name || 'Error') + ": " + (error.message || ''),

    state = { nextPosition: null, curPosition: null },
    processedStack = [];
  for (var i = stack.length - 1; i >= 0; i--) {
    processedStack.push('\n    at ' + wrapCallSite(stack[i], state));
    state.nextPosition = state.curPosition;
  }
  state.curPosition = state.nextPosition = null;
  return errorString + processedStack.reverse().join('');
}

function getErrorSource(error) {
  var match = /\n {4}at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
  if (match) {
    var source = match[1],
      line = +match[2],
      column = +match[3],

      contents = fileContentsCache[source];

    if (!contents && fs && fs.existsSync(source))
      try {
        contents = fs.readFileSync(source, 'utf8');
      } catch (er) {
        contents = '';
      }

    if (contents) {
      var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
      if (code) return source + ':' + line + '\n' + code + '\n' + new Array(column).join(' ') + '^';
    }
  }
  return null;
}

function printErrorAndExit(error) {
  var source = getErrorSource(error),

    stderr = globalProcessStderr();
  stderr && stderr._handle && stderr._handle.setBlocking && stderr._handle.setBlocking(true);

  if (source) {
    console.error();
    console.error(source);
  }

  console.error(error.stack);
  globalProcessExit(1);
}

function shimEmitUncaughtException() {
  var origEmit = process.emit;

  process.emit = function(type) {
    if (type === 'uncaughtException') {
      var hasStack = arguments[1] && arguments[1].stack,
        hasListeners = this.listeners(type).length > 0;

      if (hasStack && !hasListeners) return printErrorAndExit(arguments[1]);
    }

    return origEmit.apply(this, arguments);
  };
}

var originalRetrieveFileHandlers = retrieveFileHandlers.slice(0),
  originalRetrieveMapHandlers = retrieveMapHandlers.slice(0);

exports.wrapCallSite = wrapCallSite;
exports.getErrorSource = getErrorSource;
exports.mapSourcePosition = mapSourcePosition;
exports.retrieveSourceMap = retrieveSourceMap;

exports.install = function(options) {
  if ((options = options || {}).environment) {
    environment = options.environment;
    if (["node", "browser", "auto"].indexOf(environment) === -1)
      throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}");
  }

  if (options.retrieveFile) {
    if (options.overrideRetrieveFile) retrieveFileHandlers.length = 0;

    retrieveFileHandlers.unshift(options.retrieveFile);
  }

  if (options.retrieveSourceMap) {
    if (options.overrideRetrieveSourceMap) retrieveMapHandlers.length = 0;

    retrieveMapHandlers.unshift(options.retrieveSourceMap);
  }

  if (options.hookRequire && !isInBrowser()) {
    var Module = require('module'),
      $compile = Module.prototype._compile;

    if (!$compile.__sourceMapSupport) {
      Module.prototype._compile = function(content, filename) {
        fileContentsCache[filename] = content;
        sourceMapCache[filename] = void 0;
        return $compile.call(this, content, filename);
      };

      Module.prototype._compile.__sourceMapSupport = true;
    }
  }

  emptyCacheBetweenOperations ||
    (emptyCacheBetweenOperations = 'emptyCacheBetweenOperations' in options && options.emptyCacheBetweenOperations);

  if (!errorFormatterInstalled) {
    errorFormatterInstalled = true;
    Error.prepareStackTrace = prepareStackTrace;
  }

  if (!uncaughtShimInstalled) {
    var installHandler = !('handleUncaughtExceptions' in options) || options.handleUncaughtExceptions;

    try {
      if (require('worker_threads').isMainThread === false) installHandler = false;
    } catch (_) {}

    if (installHandler && hasGlobalProcessEventEmitter()) {
      uncaughtShimInstalled = true;
      shimEmitUncaughtException();
    }
  }
};

exports.resetRetrieveHandlers = function() {
  retrieveFileHandlers.length = 0;
  retrieveMapHandlers.length = 0;

  retrieveFileHandlers = originalRetrieveFileHandlers.slice(0);
  retrieveMapHandlers = originalRetrieveMapHandlers.slice(0);

  retrieveSourceMap = handlerExec(retrieveMapHandlers);
  retrieveFile = handlerExec(retrieveFileHandlers);
};

},
// 11
function(module) {

module.exports = require("../vendor/source-map");

},
// 12
function(module) {

var toString = Object.prototype.toString;

var isModern =
  typeof Buffer != 'undefined' &&
  typeof Buffer.alloc == 'function' &&
  typeof Buffer.allocUnsafe == 'function' &&
  typeof Buffer.from == 'function';

function isArrayBuffer(input) {
  return toString.call(input).slice(8, -1) === 'ArrayBuffer';
}

function fromArrayBuffer(obj, byteOffset, length) {
  byteOffset >>>= 0;

  var maxLength = obj.byteLength - byteOffset;

  if (maxLength < 0) throw new RangeError("'offset' is out of bounds");

  if (length === void 0) length = maxLength;
  else if ((length >>>= 0) > maxLength) throw new RangeError("'length' is out of bounds");

  return isModern
    ? Buffer.from(obj.slice(byteOffset, byteOffset + length))
    : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
}

function fromString(string, encoding) {
  if (typeof encoding != 'string' || encoding === '') encoding = 'utf8';

  if (!Buffer.isEncoding(encoding)) throw new TypeError('"encoding" must be a valid string encoding');

  return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);
}

function bufferFrom(value, encodingOrOffset, length) {
  if (typeof value == 'number') throw new TypeError('"value" argument must not be a number');

  return isArrayBuffer(value)
    ? fromArrayBuffer(value, encodingOrOffset, length)
    : typeof value == 'string'
    ? fromString(value, encodingOrOffset)
    : isModern ? Buffer.from(value) : new Buffer(value);
}

module.exports = bufferFrom;

},
// 13
function(module) {

module.exports = require("../vendor/acorn");

}
]);
