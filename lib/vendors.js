'use strict';

module.exports = (function(modules) {
  var installedModules = {};

  function __wpreq__(moduleId) {
    var module = installedModules[moduleId];
    if (module) return module.exports;

    installedModules[moduleId] = module = {i: moduleId, l: false, exports: {}};
    modules[moduleId].call(module.exports, module, module.exports, __wpreq__);

    module.l = true;
    return module.exports;
  }

  __wpreq__.m = modules;
  __wpreq__.c = installedModules;
  return __wpreq__(0);
})({
0:
function(module, exports, __wpreq__) {
//
module.exports = {
  __proto__: null,
  get commander() { return __wpreq__('commander') },
  get 'proper-lockfile'() { return __wpreq__('proper-lockfile') },
  get 'loud-rejection'() { return __wpreq__('loud-rejection') },
  get death() { return __wpreq__('death') },
  get semver() { return __wpreq__('semver') },
  get chalk() { return __wpreq__('chalk') },
  get camelcase() { return __wpreq__('camelcase') },
  get inquirer() { return __wpreq__('inquirer') },
  get 'cli-table3'() { return __wpreq__('cli-table3') },
  get 'strip-ansi'() { return __wpreq__('strip-ansi') },
  get read() { return __wpreq__('read') },
  get glob() { return __wpreq__('glob') },
  get micromatch() { return __wpreq__('micromatch') },
  get ssri() { return __wpreq__('ssri') },
  get 'object-path'() { return __wpreq__('object-path') },
  get 'normalize-url'() { return __wpreq__('normalize-url') },
  get ini() { return __wpreq__('ini') },
  get 'tar-fs'() { return __wpreq__('tar-fs') },
  get 'tar-stream'() { return __wpreq__('tar-stream') },
  get uuid() { return __wpreq__('uuid/v4') },
  get 'validate-npm-package-license'() { return __wpreq__('validate-npm-package-license') },
  get 'cmd-shim'() { return __wpreq__('@zkochan/cmd-shim') },
  get 'gunzip-maybe'() { return __wpreq__('gunzip-maybe') },
  get dnscache() { return __wpreq__('dnscache') },
  get 'request-capture-har'() { return __wpreq__('request-capture-har') },
  get 'detect-indent'() { return __wpreq__('detect-indent') },
  get resolve() { return __wpreq__('resolve/lib/sync') },
  get minimatch() { return __wpreq__('minimatch') },
  get 'deep-equal'() { return __wpreq__('deep-equal') },
  get 'node-emoji'() { return __wpreq__('node-emoji') },
  get leven() { return __wpreq__('leven') },
  get puka() { return __wpreq__('puka') },
  get 'npm-logical-tree'() { return __wpreq__('npm-logical-tree') },
  get yn() { return __wpreq__('yn') },
  get bytes() { return __wpreq__('bytes') },
  get 'ci-info'() { return __wpreq__('ci-info') },
  get debug() { return __wpreq__('debug/src/node') },
  get rimraf() { return __wpreq__('rimraf') },
  get mkdirp() { return __wpreq__('mkdirp') },
  get request() { return __wpreq__('request') }
};
Object.defineProperty(module.exports, '__wpreq__', {value: __wpreq__});
//
},
commander:
function(module, exports, __wpreq__) {
//
var EventEmitter = __wpreq__('events').EventEmitter,
  spawn = __wpreq__('child_process').spawn,
  path = __wpreq__('path'),
  dirname = path.dirname,
  basename = path.basename,
  fs = __wpreq__('fs');

__wpreq__('util').inherits(Command, EventEmitter);

exports = module.exports = new Command();

exports.Command = Command;
exports.Option = Option;

function Option(flags, description) {
  this.flags = flags;
  this.required = flags.indexOf('<') >= 0;
  this.optional = flags.indexOf('[') >= 0;
  this.bool = flags.indexOf('-no-') < 0;
  if ((flags = flags.split(/[ ,|]+/)).length > 1 && !/^[[<]/.test(flags[1])) this.short = flags.shift();
  this.long = flags.shift();
  this.description = description || '';
}

Option.prototype.name = function() {
  return this.long.replace('--', '').replace('no-', '');
};

Option.prototype.attributeName = function() {
  return camelcase(this.name());
};

Option.prototype.is = function(arg) {
  return this.short === arg || this.long === arg;
};

function Command(name) {
  this.commands = [];
  this.options = [];
  this._execs = {};
  this._allowUnknownOption = false;
  this._args = [];
  this._name = name || '';
}

Command.prototype.command = function(name, desc, opts) {
  if (typeof desc == 'object' && desc !== null) {
    opts = desc;
    desc = null;
  }
  opts = opts || {};
  var args = name.split(/ +/),
    cmd = new Command(args.shift());

  if (desc) {
    cmd.description(desc);
    this.executables = true;
    this._execs[cmd._name] = true;
    if (opts.isDefault) this.defaultExecutable = cmd._name;
  }
  cmd._noHelp = !!opts.noHelp;
  this.commands.push(cmd);
  cmd.parseExpectedArgs(args);
  cmd.parent = this;

  return desc ? this : cmd;
};

// noinspection JSAnnotator
Command.prototype.arguments = function(desc) {
  return this.parseExpectedArgs(desc.split(/ +/));
};

Command.prototype.addImplicitHelpCommand = function() {
  this.command('help [cmd]', 'display help for [cmd]');
};

Command.prototype.parseExpectedArgs = function(args) {
  if (!args.length) return;
  var self = this;
  args.forEach(function(arg) {
    var argDetails = {required: false, name: '', variadic: false};

    switch (arg[0]) {
      case '<':
        argDetails.required = true;
        argDetails.name = arg.slice(1, -1);
        break;
      case '[':
        argDetails.name = arg.slice(1, -1);
        break;
    }

    if (argDetails.name.length > 3 && argDetails.name.slice(-3) === '...') {
      argDetails.variadic = true;
      argDetails.name = argDetails.name.slice(0, -3);
    }
    argDetails.name && self._args.push(argDetails);
  });
  return this;
};

Command.prototype.action = function(fn) {
  var self = this;
  var listener = function(args, unknown) {
    args = args || [];
    unknown = unknown || [];

    var parsed = self.parseOptions(unknown);

    outputHelpIfNecessary(self, parsed.unknown);

    parsed.unknown.length > 0 && self.unknownOption(parsed.unknown[0]);

    if (parsed.args.length) args = parsed.args.concat(args);

    self._args.forEach(function(arg, i) {
      if (arg.required && args[i] == null) self.missingArgument(arg.name);
      else if (arg.variadic) {
        i < self._args.length - 1 && self.variadicArgNotLast(arg.name);

        args[i] = args.splice(i);
      }
    });

    self._args.length ? (args[self._args.length] = self) : args.push(self);

    fn.apply(self, args);
  };
  var parent = this.parent || this,
    name = parent === this ? '*' : this._name;
  parent.on('command:' + name, listener);
  this._alias && parent.on('command:' + this._alias, listener);
  return this;
};

Command.prototype.option = function(flags, description, fn, defaultValue) {
  var self = this,
    option = new Option(flags, description),
    oname = option.name(),
    name = option.attributeName();

  if (typeof fn != 'function')
    if (fn instanceof RegExp) {
      var regex = fn;
      fn = function(val, def) {
        var m = regex.exec(val);
        return m ? m[0] : def;
      };
    } else {
      defaultValue = fn;
      fn = null;
    }

  if (!option.bool || option.optional || option.required) {
    option.bool || (defaultValue = true);
    if (defaultValue !== void 0) {
      self[name] = defaultValue;
      option.defaultValue = defaultValue;
    }
  }

  this.options.push(option);

  this.on('option:' + oname, function(val) {
    if (val !== null && fn) val = fn(val, self[name] === void 0 ? defaultValue : self[name]);

    if (typeof self[name] == 'boolean' || self[name] === void 0)
      self[name] = val == null ? !!option.bool && (defaultValue || true) : val;
    else if (val !== null) self[name] = val;
  });

  return this;
};

Command.prototype.allowUnknownOption = function(arg) {
  this._allowUnknownOption = arguments.length === 0 || arg;
  return this;
};

Command.prototype.parse = function(argv) {
  this.executables && this.addImplicitHelpCommand();

  this.rawArgs = argv;

  this._name = this._name || basename(argv[1], '.js');

  this.executables && argv.length < 3 && !this.defaultExecutable && argv.push('--help');

  var parsed = this.parseOptions(this.normalize(argv.slice(2))),
    args = (this.args = parsed.args),

    result = this.parseArgs(this.args, parsed.unknown),
    name = result.args[0],

    aliasCommand = null;
  if (name)
    aliasCommand = this.commands.filter(function(command) {
      return command.alias() === name;
    })[0];

  if (this._execs[name] === true) return this.executeSubCommand(argv, args, parsed.unknown);
  if (aliasCommand) {
    args[0] = aliasCommand._name;
    return this.executeSubCommand(argv, args, parsed.unknown);
  }
  if (this.defaultExecutable) {
    args.unshift(this.defaultExecutable);
    return this.executeSubCommand(argv, args, parsed.unknown);
  }

  return result;
};

Command.prototype.executeSubCommand = function(argv, args, unknown) {
  (args = args.concat(unknown)).length || this.help();
  args[0] !== 'help' || args.length !== 1 || this.help();

  if (args[0] === 'help') {
    args[0] = args[1];
    args[1] = '--help';
  }

  var baseDir,
    f = argv[1],
    bin = basename(f, path.extname(f)) + '-' + args[0],

    resolvedLink = fs.realpathSync(f);

  baseDir = dirname(resolvedLink);

  var proc,
    localBin = path.join(baseDir, bin),

    isExplicitJS = false;
  if (exists(localBin + '.js')) {
    bin = localBin + '.js';
    isExplicitJS = true;
  } else if (exists(localBin + '.ts')) {
    bin = localBin + '.ts';
    isExplicitJS = true;
  } else if (exists(localBin)) bin = localBin;

  args = args.slice(1);

  if (process.platform !== 'win32')
    if (isExplicitJS) {
      args.unshift(bin);
      args = (process.execArgv || []).concat(args);

      proc = spawn(process.argv[0], args, {stdio: 'inherit', customFds: [0, 1, 2]});
    } else proc = spawn(bin, args, {stdio: 'inherit', customFds: [0, 1, 2]});
  else {
    args.unshift(bin);
    proc = spawn(process.execPath, args, {stdio: 'inherit'});
  }

  ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'].forEach(function(signal) {
    process.on(signal, function() {
      proc.killed !== false || proc.exitCode !== null || proc.kill(signal);
    });
  });
  proc.on('close', process.exit.bind(process));
  proc.on('error', function(err) {
    err.code === 'ENOENT'
      ? console.error('error: %s(1) does not exist, try --help', bin)
      : err.code !== 'EACCES' || console.error('error: %s(1) not executable. try chmod or run with root', bin);

    process.exit(1);
  });

  this.runningCommand = proc;
};

Command.prototype.normalize = function(args) {
  var ret = [];

  for (var arg, lastOpt, index, i = 0, len = args.length; i < len; ++i) {
    arg = args[i];
    if (i > 0) lastOpt = this.optionFor(args[i - 1]);

    if (arg === '--') {
      ret = ret.concat(args.slice(i));
      break;
    }
    lastOpt && lastOpt.required
      ? ret.push(arg)
      : arg.length > 1 && arg[0] === '-' && arg[1] !== '-'
      ? arg.slice(1).split('').forEach(function(c) {
          ret.push('-' + c);
        })
      : /^--/.test(arg) && ~(index = arg.indexOf('='))
      ? ret.push(arg.slice(0, index), arg.slice(index + 1))
      : ret.push(arg);
  }

  return ret;
};

Command.prototype.parseArgs = function(args, unknown) {
  var name;

  if (args.length) {
    name = args[0];
    this.listeners('command:' + name).length
      ? this.emit('command:' + args.shift(), args, unknown)
      : this.emit('command:*', args);
  } else {
    outputHelpIfNecessary(this, unknown);

    unknown.length > 0 && this.unknownOption(unknown[0]);

    this.commands.length > 0 || this._args.filter(a => a.required).length > 0 || this.emit('command:*');
  }

  return this;
};

Command.prototype.optionFor = function(arg) {
  for (var i = 0, len = this.options.length; i < len; ++i)
    if (this.options[i].is(arg)) return this.options[i];
};

Command.prototype.parseOptions = function(argv) {
  var args = [],
    len = argv.length,

    unknownOptions = [];

  for (var literal, option, arg, i = 0; i < len; ++i) {
    arg = argv[i];

    if (literal) args.push(arg);
    else if (arg === '--') literal = true;
    else if ((option = this.optionFor(arg)))
      if (option.required) {
        if ((arg = argv[++i]) == null) return this.optionMissingArgument(option);
        this.emit('option:' + option.name(), arg);
      } else if (option.optional) {
        (arg = argv[i + 1]) == null || (arg[0] === '-' && arg !== '-') ? (arg = null) : ++i;

        this.emit('option:' + option.name(), arg);
      } else this.emit('option:' + option.name());
    else if (arg.length > 1 && arg[0] === '-') {
      unknownOptions.push(arg);

      i + 1 < argv.length && argv[i + 1][0] !== '-' && unknownOptions.push(argv[++i]);
    } else args.push(arg);
  }

  return {args: args, unknown: unknownOptions};
};

Command.prototype.opts = function() {
  var result = {};

  for (var len = this.options.length, i = 0; i < len; i++) {
    var key = this.options[i].attributeName();
    result[key] = key === this._versionOptionName ? this._version : this[key];
  }
  return result;
};

Command.prototype.missingArgument = function(name) {
  console.error("error: missing required argument `%s'", name);
  process.exit(1);
};

Command.prototype.optionMissingArgument = function(option, flag) {
  flag
    ? console.error("error: option `%s' argument missing, got `%s'", option.flags, flag)
    : console.error("error: option `%s' argument missing", option.flags);

  process.exit(1);
};

Command.prototype.unknownOption = function(flag) {
  if (this._allowUnknownOption) return;
  console.error("error: unknown option `%s'", flag);
  process.exit(1);
};

Command.prototype.variadicArgNotLast = function(name) {
  console.error("error: variadic arguments must be last `%s'", name);
  process.exit(1);
};

Command.prototype.version = function(str, flags) {
  if (arguments.length === 0) return this._version;
  this._version = str;
  var versionOption = new Option(flags || '-V, --version', 'output the version number');
  this._versionOptionName = versionOption.long.substr(2) || 'version';
  this.options.push(versionOption);
  this.on('option:' + this._versionOptionName, function() {
    process.stdout.write(str + '\n');
    process.exit(0);
  });
  return this;
};

Command.prototype.description = function(str, argsDescription) {
  if (arguments.length === 0) return this._description;
  this._description = str;
  this._argsDescription = argsDescription;
  return this;
};

Command.prototype.alias = function(alias) {
  var command = this;
  if (this.commands.length !== 0) command = this.commands[this.commands.length - 1];

  if (arguments.length === 0) return command._alias;

  if (alias === command._name) throw new Error("Command alias can't be the same as its name");

  command._alias = alias;
  return this;
};

Command.prototype.usage = function(str) {
  var args = this._args.map(function(arg) {
    return humanReadableArgName(arg);
  });

  var usage = '[options]' +
    (this.commands.length ? ' [command]' : '') +
    (this._args.length ? ' ' + args.join(' ') : '');

  if (arguments.length === 0) return this._usage || usage;
  this._usage = str;

  return this;
};

Command.prototype.name = function(str) {
  if (arguments.length === 0) return this._name;
  this._name = str;
  return this;
};

Command.prototype.prepareCommands = function() {
  return this.commands.filter(function(cmd) {
    return !cmd._noHelp;
  }).map(function(cmd) {
    var args = cmd._args.map(function(arg) {
      return humanReadableArgName(arg);
    }).join(' ');

    return [
      cmd._name +
        (cmd._alias ? '|' + cmd._alias : '') +
        (cmd.options.length ? ' [options]' : '') +
        (args ? ' ' + args : ''),
      cmd._description
    ];
  });
};

Command.prototype.largestCommandLength = function() {
  return this.prepareCommands().reduce(function(max, command) {
    return Math.max(max, command[0].length);
  }, 0);
};

Command.prototype.largestOptionLength = function() {
  var options = [].slice.call(this.options);
  options.push({flags: '-h, --help'});
  return options.reduce(function(max, option) {
    return Math.max(max, option.flags.length);
  }, 0);
};

Command.prototype.largestArgLength = function() {
  return this._args.reduce(function(max, arg) {
    return Math.max(max, arg.name.length);
  }, 0);
};

Command.prototype.padWidth = function() {
  var width = this.largestOptionLength();
  if (this._argsDescription && this._args.length && this.largestArgLength() > width)
    width = this.largestArgLength();

  if (this.commands && this.commands.length && this.largestCommandLength() > width)
    width = this.largestCommandLength();

  return width;
};

Command.prototype.optionHelp = function() {
  var width = this.padWidth();

  return this.options.map(function(option) {
    return (
      pad(option.flags, width) + '  ' + option.description +
      (option.bool && option.defaultValue !== void 0 ? ' (default: ' + JSON.stringify(option.defaultValue) + ')' : '')
    );
  }).concat([pad('-h, --help', width) + '  output usage information'])
    .join('\n');
};

Command.prototype.commandHelp = function() {
  if (!this.commands.length) return '';

  var commands = this.prepareCommands(),
    width = this.padWidth();

  return [
    'Commands:',
    commands.map(function(cmd) {
      var desc = cmd[1] ? '  ' + cmd[1] : '';
      return (desc ? pad(cmd[0], width) : cmd[0]) + desc;
    }).join('\n').replace(/^/gm, '  '),
    ''
  ].join('\n');
};

Command.prototype.helpInformation = function() {
  var desc = [];
  if (this._description) {
    desc = [this._description, ''];

    var argsDescription = this._argsDescription;
    if (argsDescription && this._args.length) {
      var width = this.padWidth();
      desc.push('Arguments:');
      desc.push('');
      this._args.forEach(function(arg) {
        desc.push('  ' + pad(arg.name, width) + '  ' + argsDescription[arg.name]);
      });
      desc.push('');
    }
  }

  var cmdName = this._name;
  if (this._alias) cmdName = cmdName + '|' + this._alias;

  var usage = ['Usage: ' + cmdName + ' ' + this.usage(), ''],

    cmds = [],
    commandHelp = this.commandHelp();
  if (commandHelp) cmds = [commandHelp];

  var options = ['Options:', '' + this.optionHelp().replace(/^/gm, '  '), ''];

  return usage.concat(desc, options, cmds).join('\n');
};

Command.prototype.outputHelp = function(cb) {
  cb ||
    (cb = function(passthru) {
      return passthru;
    });

  process.stdout.write(cb(this.helpInformation()));
  this.emit('--help');
};

Command.prototype.help = function(cb) {
  this.outputHelp(cb);
  process.exit();
};

function camelcase(flag) {
  return flag.split('-').reduce(function(str, word) {
    return str + word[0].toUpperCase() + word.slice(1);
  });
}

function pad(str, width) {
  var len = Math.max(0, width - str.length);
  return str + Array(len + 1).join(' ');
}

function outputHelpIfNecessary(cmd, options) {
  options = options || [];
  for (var i = 0; i < options.length; i++)
    if (options[i] === '--help' || options[i] === '-h') {
      cmd.outputHelp();
      process.exit(0);
    }
}

function humanReadableArgName(arg) {
  var nameOutput = arg.name + (arg.variadic === true ? '...' : '');

  return arg.required ? '<' + nameOutput + '>' : '[' + nameOutput + ']';
}

function exists(file) {
  try {
    if (fs.statSync(file).isFile()) return true;
  } catch (_e) {
    return false;
  }
}
//
},
events:
function(module) {
//
module.exports = require('events');
//
},
child_process:
function(module) {
//
module.exports = require('child_process');
//
},
path:
function(module) {
//
module.exports = require('path');
//
},
fs:
function(module) {
//
module.exports = require('fs');
//
},
util:
function(module) {
//
module.exports = require('util');
//
},
'proper-lockfile':
function(module, exports, __wpreq__) {
//
const fs = __wpreq__('graceful-fs'),
  path = __wpreq__('path'),
  retry = __wpreq__('retry'),
  syncFs = __wpreq__('proper-lockfile/lib/syncFs'),

  locks = {};

function getLockFile(file) {
  return file + '.lock';
}

function canonicalPath(file, options, callback) {
  if (!options.realpath) return callback(null, path.resolve(file));

  options.fs.realpath(file, callback);
}

function acquireLock(file, options, callback) {
  options.fs.mkdir(getLockFile(file), err => {
    if (!err) return callback();

    if (err.code !== 'EEXIST') return callback(err);

    if (options.stale <= 0)
      return callback(Object.assign(new Error('Lock file is already being hold'), {code: 'ELOCKED', file}));

    options.fs.stat(getLockFile(file), (err, stat) => {
      if (err)
        return err.code === 'ENOENT'
          ? acquireLock(file, Object.assign({}, options, {stale: 0}), callback)
          : callback(err);

      if (!isLockStale(stat, options))
        return callback(Object.assign(new Error('Lock file is already being hold'), {code: 'ELOCKED', file}));

      removeLock(file, options, err => {
        if (err) return callback(err);

        acquireLock(file, Object.assign({}, options, {stale: 0}), callback);
      });
    });
  });
}

function isLockStale(stat, options) {
  return stat.mtime.getTime() < Date.now() - options.stale;
}

function removeLock(file, options, callback) {
  options.fs.rmdir(getLockFile(file), err => {
    if (err && err.code !== 'ENOENT') return callback(err);

    callback();
  });
}

function updateLock(file, options) {
  const lock = locks[file];

  if (lock.updateTimeout) return;

  lock.updateDelay = lock.updateDelay || options.update;
  lock.updateTimeout = setTimeout(() => {
    const mtime = Date.now() / 1000;

    lock.updateTimeout = null;

    options.fs.utimes(getLockFile(file), mtime, mtime, err => {
      if (lock.released) return;

      if (lock.lastUpdate <= Date.now() - options.stale && lock.lastUpdate > Date.now() - options.stale * 2)
        return compromisedLock(file, lock,
          Object.assign(new Error(lock.updateError || 'Unable to update lock within the stale threshold'), {
            code: 'ECOMPROMISED'
          })
        );

      if (err) {
        if (err.code === 'ENOENT') return compromisedLock(file, lock, Object.assign(err, {code: 'ECOMPROMISED'}));

        lock.updateError = err;
        lock.updateDelay = 1000;
        return updateLock(file, options);
      }

      lock.lastUpdate = Date.now();
      lock.updateError = null;
      lock.updateDelay = null;
      updateLock(file, options);
    });
  }, lock.updateDelay);

  lock.updateTimeout.unref && lock.updateTimeout.unref();
}

function compromisedLock(file, lock, err) {
  lock.released = true;
  lock.updateTimeout && clearTimeout(lock.updateTimeout);

  locks[file] !== lock || delete locks[file];

  lock.compromised(err);
}

function lock(file, options, compromised, callback) {
  if (typeof options == 'function') {
    callback = compromised;
    compromised = options;
    options = null;
  }

  if (!callback) {
    callback = compromised;
    compromised = null;
  }

  options = Object.assign({stale: 10000, update: null, realpath: true, retries: 0, fs}, options);

  options.retries = options.retries || 0;
  options.retries = typeof options.retries == 'number' ? {retries: options.retries} : options.retries;
  options.stale = Math.max(options.stale || 0, 2000);
  options.update = options.update == null ? options.stale / 2 : options.update || 0;
  options.update = Math.max(Math.min(options.update, options.stale / 2), 1000);
  compromised = compromised || function(err) { throw err; };

  canonicalPath(file, options, (err, file) => {
    if (err) return callback(err);

    const operation = retry.operation(options.retries);

    operation.attempt(() => {
      acquireLock(file, options, err => {
        if (operation.retry(err)) return;

        if (err) return callback(operation.mainError());

        const lock = (locks[file] = {options, compromised, lastUpdate: Date.now()});

        updateLock(file, options);

        callback(null, releasedCallback => {
          if (lock.released)
            return (
              releasedCallback &&
              releasedCallback(Object.assign(new Error('Lock is already released'), {code: 'ERELEASED'}))
            );

          unlock(file, Object.assign({}, options, {realpath: false}), releasedCallback);
        });
      });
    });
  });
}

function unlock(file, options, callback) {
  if (typeof options == 'function') {
    callback = options;
    options = null;
  }

  options = Object.assign({fs, realpath: true}, options);

  callback = callback || function() {};

  canonicalPath(file, options, (err, file) => {
    if (err) return callback(err);

    const lock = locks[file];

    if (!lock) return callback(Object.assign(new Error('Lock is not acquired/owned by you'), {code: 'ENOTACQUIRED'}));

    lock.updateTimeout && clearTimeout(lock.updateTimeout);
    lock.released = true;
    delete locks[file];

    removeLock(file, options, callback);
  });
}

function lockSync(file, options, compromised) {
  if (typeof options == 'function') {
    compromised = options;
    options = null;
  }

  (options = options || {}).fs = syncFs(options.fs || fs);
  options.retries = options.retries || 0;
  options.retries = typeof options.retries == 'number' ? {retries: options.retries} : options.retries;

  if (options.retries.retries) throw Object.assign(new Error('Cannot use retries with the sync api'), {code: 'ESYNC'});

  let err, release = void 0;

  lock(file, options, compromised, (_err, _release) => {
    err = _err;
    release = _release;
  });

  if (err) throw err;

  return release;
}

function unlockSync(file, options) {
  (options = options || {}).fs = syncFs(options.fs || fs);

  let err;

  unlock(file, options, _err => {
    err = _err;
  });

  if (err) throw err;
}

function check(file, options, callback) {
  if (typeof options == 'function') {
    callback = options;
    options = null;
  }

  options = Object.assign({stale: 10000, realpath: true, fs}, options);

  options.stale = Math.max(options.stale || 0, 2000);

  canonicalPath(file, options, (err, file) => {
    if (err) return callback(err);

    options.fs.stat(getLockFile(file), (err, stat) =>
      err
        ? (err.code === 'ENOENT' ? callback(null, false) : callback(err))
        : options.stale <= 0 ? callback(null, true)
        : callback(null, !isLockStale(stat, options))
    );
  });
}

function checkSync(file, options) {
  (options = options || {}).fs = syncFs(options.fs || fs);

  let err, locked = void 0;

  check(file, options, (_err, _locked) => {
    err = _err;
    locked = _locked;
  });

  if (err) throw err;

  return locked;
}

process.on('exit', () => {
  Object.keys(locks).forEach(file => {
    try {
      locks[file].options.fs.rmdirSync(getLockFile(file));
    } catch (_) {}
  });
});

module.exports = lock;
module.exports.lock = lock;
module.exports.unlock = unlock;
module.exports.lockSync = lockSync;
module.exports.unlockSync = unlockSync;
module.exports.check = check;
module.exports.checkSync = checkSync;
//
},
'graceful-fs':
function(module, exports, __wpreq__) {
//
var fs = __wpreq__('fs'),
  polyfills = __wpreq__('graceful-fs/polyfills'),
  legacy = __wpreq__('graceful-fs/legacy-streams'),
  queue = [],

  util = __wpreq__('util')

function noop() {}

var debug = noop
if (util.debuglog) debug = util.debuglog('gfs4')
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
  debug = function() {
    var m = util.format.apply(util, arguments)
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ')
    console.error(m)
  }

!/\bgfs4\b/i.test(process.env.NODE_DEBUG || '') ||
  process.on('exit', function() {
    debug(queue)
    __wpreq__('assert').equal(queue.length, 0)
  })

module.exports = process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH ? patch(fs) : patch(__wpreq__('graceful-fs/fs'))

module.exports.close = fs.close = (function(fs$close) {
  return function(fd, cb) {
    return fs$close.call(fs, fd, function(err) {
      err || retry()

      typeof cb != 'function' || cb.apply(this, arguments)
    })
  }
})(fs.close)

module.exports.closeSync = fs.closeSync = (function(fs$closeSync) {
  return function(fd) {
    var rval = fs$closeSync.apply(fs, arguments)
    retry()
    return rval
  }
})(fs.closeSync)

function patch(fs) {
  polyfills(fs)
  fs.gracefulify = patch
  fs.FileReadStream = ReadStream;
  fs.FileWriteStream = WriteStream;
  fs.createReadStream = createReadStream
  fs.createWriteStream = createWriteStream
  var fs$readFile = fs.readFile
  fs.readFile = readFile
  function readFile(path, options, cb) {
    if (typeof options == 'function') (cb = options), (options = null)

    return go$readFile(path, options, cb)

    function go$readFile(path, options, cb) {
      return fs$readFile(path, options, function(err) {
        if (!err || (err.code !== 'EMFILE' && err.code !== 'ENFILE')) {
          typeof cb != 'function' || cb.apply(this, arguments)
          retry()
        } else enqueue([go$readFile, [path, options, cb]])
      })
    }
  }

  var fs$writeFile = fs.writeFile
  fs.writeFile = writeFile
  function writeFile(path, data, options, cb) {
    if (typeof options == 'function') (cb = options), (options = null)

    return go$writeFile(path, data, options, cb)

    function go$writeFile(path, data, options, cb) {
      return fs$writeFile(path, data, options, function(err) {
        if (!err || (err.code !== 'EMFILE' && err.code !== 'ENFILE')) {
          typeof cb != 'function' || cb.apply(this, arguments)
          retry()
        } else enqueue([go$writeFile, [path, data, options, cb]])
      })
    }
  }

  var fs$appendFile = fs.appendFile
  if (fs$appendFile) fs.appendFile = appendFile
  function appendFile(path, data, options, cb) {
    if (typeof options == 'function') (cb = options), (options = null)

    return go$appendFile(path, data, options, cb)

    function go$appendFile(path, data, options, cb) {
      return fs$appendFile(path, data, options, function(err) {
        if (!err || (err.code !== 'EMFILE' && err.code !== 'ENFILE')) {
          typeof cb != 'function' || cb.apply(this, arguments)
          retry()
        } else enqueue([go$appendFile, [path, data, options, cb]])
      })
    }
  }

  var fs$readdir = fs.readdir
  fs.readdir = readdir
  function readdir(path, options, cb) {
    var args = [path]
    typeof options != 'function' ? args.push(options) : (cb = options)

    args.push(go$readdir$cb)

    return go$readdir(args)

    function go$readdir$cb(err, files) {
      files && files.sort && files.sort()

      if (!err || (err.code !== 'EMFILE' && err.code !== 'ENFILE')) {
        typeof cb != 'function' || cb.apply(this, arguments)
        retry()
      } else enqueue([go$readdir, [args]])
    }
  }

  function go$readdir(args) {
    return fs$readdir.apply(fs, args)
  }

  if (/^v?0\.8\b/.test(process.version)) {
    var legStreams = legacy(fs)
    ReadStream = legStreams.ReadStream
    WriteStream = legStreams.WriteStream
  }

  var fs$ReadStream = fs.ReadStream
  ReadStream.prototype = Object.create(fs$ReadStream.prototype)
  ReadStream.prototype.open = ReadStream$open

  var fs$WriteStream = fs.WriteStream
  WriteStream.prototype = Object.create(fs$WriteStream.prototype)
  WriteStream.prototype.open = WriteStream$open

  fs.ReadStream = ReadStream
  fs.WriteStream = WriteStream

  function ReadStream(path, options) {
    return this instanceof ReadStream
      ? (fs$ReadStream.apply(this, arguments), this)
      : ReadStream.apply(Object.create(ReadStream.prototype), arguments)
  }

  function ReadStream$open() {
    var that = this
    open(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        that.autoClose && that.destroy()

        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
        that.read()
      }
    })
  }

  function WriteStream(path, options) {
    return this instanceof WriteStream
      ? (fs$WriteStream.apply(this, arguments), this)
      : WriteStream.apply(Object.create(WriteStream.prototype), arguments)
  }

  function WriteStream$open() {
    var that = this
    open(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        that.destroy()
        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
      }
    })
  }

  function createReadStream(path, options) {
    return new ReadStream(path, options)
  }

  function createWriteStream(path, options) {
    return new WriteStream(path, options)
  }

  var fs$open = fs.open
  fs.open = open
  function open(path, flags, mode, cb) {
    if (typeof mode == 'function') (cb = mode), (mode = null)

    return go$open(path, flags, mode, cb)

    function go$open(path, flags, mode, cb) {
      return fs$open(path, flags, mode, function(err, fd) {
        if (!err || (err.code !== 'EMFILE' && err.code !== 'ENFILE')) {
          typeof cb != 'function' || cb.apply(this, arguments)
          retry()
        } else enqueue([go$open, [path, flags, mode, cb]])
      })
    }
  }

  return fs
}

function enqueue(elem) {
  debug('ENQUEUE', elem[0].name, elem[1])
  queue.push(elem)
}

function retry() {
  var elem = queue.shift()
  if (elem) {
    debug('RETRY', elem[0].name, elem[1])
    elem[0].apply(null, elem[1])
  }
}
//
},
'graceful-fs/polyfills':
function(module, exports, __wpreq__) {
//
var fs = __wpreq__('graceful-fs/fs'),
  constants = __wpreq__('constants'),

  origCwd = process.cwd,
  cwd = null,

  platform = process.env.GRACEFUL_FS_PLATFORM || process.platform

process.cwd = function() {
  cwd || (cwd = origCwd.call(process))
  return cwd
}
try {
  process.cwd()
} catch (_er) {}

var chdir = process.chdir
process.chdir = function(d) {
  cwd = null
  chdir.call(process, d)
}

module.exports = patch

function patch(fs) {
  constants.hasOwnProperty('O_SYMLINK') && /^v?0\.(6\.[0-2]|5)\b/.test(process.version) && patchLchmod(fs)

  fs.lutimes || patchLutimes(fs)

  fs.chown = chownFix(fs.chown)
  fs.fchown = chownFix(fs.fchown)
  fs.lchown = chownFix(fs.lchown)

  fs.chmod = chmodFix(fs.chmod)
  fs.fchmod = chmodFix(fs.fchmod)
  fs.lchmod = chmodFix(fs.lchmod)

  fs.chownSync = chownFixSync(fs.chownSync)
  fs.fchownSync = chownFixSync(fs.fchownSync)
  fs.lchownSync = chownFixSync(fs.lchownSync)

  fs.chmodSync = chmodFixSync(fs.chmodSync)
  fs.fchmodSync = chmodFixSync(fs.fchmodSync)
  fs.lchmodSync = chmodFixSync(fs.lchmodSync)

  fs.stat = statFix(fs.stat)
  fs.fstat = statFix(fs.fstat)
  fs.lstat = statFix(fs.lstat)

  fs.statSync = statFixSync(fs.statSync)
  fs.fstatSync = statFixSync(fs.fstatSync)
  fs.lstatSync = statFixSync(fs.lstatSync)

  if (!fs.lchmod) {
    fs.lchmod = function(path, mode, cb) {
      cb && process.nextTick(cb)
    }
    fs.lchmodSync = function() {}
  }
  if (!fs.lchown) {
    fs.lchown = function(path, uid, gid, cb) {
      cb && process.nextTick(cb)
    }
    fs.lchownSync = function() {}
  }

  if (platform === "win32")
    fs.rename = (function(fs$rename) {
      return function(from, to, cb) {
        var start = Date.now(),
          backoff = 0;
        fs$rename(from, to, function CB(er) {
          if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 60000) {
            setTimeout(function() {
              fs.stat(to, function(stater, _st) {
                stater && stater.code === "ENOENT" ? fs$rename(from, to, CB) : cb(er)
              })
            }, backoff)

            if (backoff < 100) backoff += 10;
          } else cb && cb(er)
        })
      }
    })(fs.rename)

  fs.read = (function(fs$read) {
    return function(fd, buffer, offset, length, position, callback_) {
      var callback
      if (callback_ && typeof callback_ == 'function') {
        var eagCounter = 0
        callback = function(er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter++
            return fs$read.call(fs, fd, buffer, offset, length, position, callback)
          }
          callback_.apply(this, arguments)
        }
      }
      return fs$read.call(fs, fd, buffer, offset, length, position, callback)
    }
  })(fs.read)

  fs.readSync = (function(fs$readSync) {
    return function(fd, buffer, offset, length, position) {
      for (var eagCounter = 0; ; )
        try {
          return fs$readSync.call(fs, fd, buffer, offset, length, position)
        } catch (er) {
          if (er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter++
            continue
          }
          throw er
        }
    }
  })(fs.readSync)
}

function patchLchmod(fs) {
  fs.lchmod = function(path, mode, callback) {
    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
      err
        ? callback && callback(err)
        : fs.fchmod(fd, mode, function(err) {
            fs.close(fd, function(err2) {
              callback && callback(err || err2)
            })
          })
    })
  }

  fs.lchmodSync = function(path, mode) {
    var ret,
      fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode),

      threw = true
    try {
      ret = fs.fchmodSync(fd, mode)
      threw = false
    } finally {
      if (threw)
        try {
          fs.closeSync(fd)
        } catch (_er) {}
      else fs.closeSync(fd)
    }
    return ret
  }
}

function patchLutimes(fs) {
  if (constants.hasOwnProperty("O_SYMLINK")) {
    fs.lutimes = function(path, at, mt, cb) {
      fs.open(path, constants.O_SYMLINK, function(er, fd) {
        er
          ? cb && cb(er)
          : fs.futimes(fd, at, mt, function(er) {
              fs.close(fd, function(er2) {
                cb && cb(er || er2)
              })
            })
      })
    }

    fs.lutimesSync = function(path, at, mt) {
      var ret,
        fd = fs.openSync(path, constants.O_SYMLINK),
        threw = true
      try {
        ret = fs.futimesSync(fd, at, mt)
        threw = false
      } finally {
        if (threw)
          try {
            fs.closeSync(fd)
          } catch (_er) {}
        else fs.closeSync(fd)
      }
      return ret
    }
  } else {
    fs.lutimes = function(_a, _b, _c, cb) { cb && process.nextTick(cb) }
    fs.lutimesSync = function() {}
  }
}

function chmodFix(orig) {
  return !orig ? orig : function(target, mode, cb) {
    return orig.call(fs, target, mode, function(er) {
      if (chownErOk(er)) er = null
      cb && cb.apply(this, arguments)
    })
  }
}

function chmodFixSync(orig) {
  return !orig ? orig : function(target, mode) {
    try {
      return orig.call(fs, target, mode)
    } catch (er) {
      if (!chownErOk(er)) throw er
    }
  }
}

function chownFix(orig) {
  return !orig ? orig : function(target, uid, gid, cb) {
    return orig.call(fs, target, uid, gid, function(er) {
      if (chownErOk(er)) er = null
      cb && cb.apply(this, arguments)
    })
  }
}

function chownFixSync(orig) {
  return !orig ? orig : function(target, uid, gid) {
    try {
      return orig.call(fs, target, uid, gid)
    } catch (er) {
      if (!chownErOk(er)) throw er
    }
  }
}

function statFix(orig) {
  return !orig ? orig : function(target, cb) {
    return orig.call(fs, target, function(er, stats) {
      if (!stats) return cb.apply(this, arguments)
      if (stats.uid < 0) stats.uid += 0x100000000
      if (stats.gid < 0) stats.gid += 0x100000000
      cb && cb.apply(this, arguments)
    })
  }
}

function statFixSync(orig) {
  return !orig ? orig : function(target) {
    var stats = orig.call(fs, target)
    if (stats.uid < 0) stats.uid += 0x100000000
    if (stats.gid < 0) stats.gid += 0x100000000
    return stats;
  }
}

function chownErOk(er) {
  return (
    !er ||
    er.code === "ENOSYS" ||
    !((process.getuid && process.getuid() === 0) || (er.code !== "EINVAL" && er.code !== "EPERM"))
  )
}
//
},
'graceful-fs/fs':
function(module, exports, __wpreq__) {
//
var fs = __wpreq__('fs')

module.exports = clone(fs)

function clone(obj) {
  if (obj === null || typeof obj != 'object') return obj

  var copy = obj instanceof Object ? {__proto__: obj.__proto__} : Object.create(null)

  Object.getOwnPropertyNames(obj).forEach(function(key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))
  })

  return copy
}
//
},
constants:
function(module) {
// noinspection NpmUsedModulesInstalled
module.exports = require('constants');
//
},
'graceful-fs/legacy-streams':
function(module, exports, __wpreq__) {
//
var Stream = __wpreq__('stream').Stream

module.exports = legacy

function legacy(fs) {
  return {ReadStream: ReadStream, WriteStream: WriteStream}

  function ReadStream(path, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438;
    this.bufferSize = 65536;

    options = options || {};

    for (var keys = Object.keys(options), index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    this.encoding && this.setEncoding(this.encoding);

    if (this.start !== void 0) {
      if ('number' != typeof this.start) throw TypeError('start must be a Number');

      if (this.end === void 0) this.end = Infinity;
      else if ('number' != typeof this.end) throw TypeError('end must be a Number');

      if (this.start > this.end) throw new Error('start must be <= end');

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function() {
        self._read();
      });
      return;
    }

    fs.open(this.path, this.flags, this.mode, function(err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    })
  }

  function WriteStream(path, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

    Stream.call(this);

    this.path = path;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438;
    this.bytesWritten = 0;

    options = options || {};

    for (var keys = Object.keys(options), index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== void 0) {
      if ('number' != typeof this.start) throw TypeError('start must be a Number');
      if (this.start < 0) throw new Error('start must be >= zero');

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
      this.flush();
    }
  }
}
//
},
stream:
function(module) {
//
module.exports = require('stream');
//
},
assert:
function(module) {
//
module.exports = require('assert');
//
},
retry:
function(module, exports, __wpreq__) {
//
var RetryOperation = __wpreq__('retry/lib/retry_operation');

exports.operation = function(options) {
  var timeouts = exports.timeouts(options);
  return new RetryOperation(timeouts, {forever: options && options.forever, unref: options && options.unref});
};

exports.timeouts = function(options) {
  if (options instanceof Array) return [].concat(options);

  var opts = {
    retries: 10,
    factor: 2,
    minTimeout: 1000,
    maxTimeout: Infinity,
    randomize: false
  };
  for (var key in options) opts[key] = options[key];

  if (opts.minTimeout > opts.maxTimeout) throw new Error('minTimeout is greater than maxTimeout');

  var timeouts = [];
  for (var i = 0; i < opts.retries; i++) timeouts.push(this.createTimeout(i, opts));

  options && options.forever && !timeouts.length && timeouts.push(this.createTimeout(i, opts));

  timeouts.sort(function(a, b) {
    return a - b;
  });

  return timeouts;
};

exports.createTimeout = function(attempt, opts) {
  var random = opts.randomize ? Math.random() + 1 : 1,

    timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));

  return Math.min(timeout, opts.maxTimeout);
};

exports.wrap = function(obj, options, methods) {
  if (options instanceof Array) {
    methods = options;
    options = null;
  }

  if (!methods) {
    methods = [];
    for (var key in obj) typeof obj[key] != 'function' || methods.push(key);
  }

  for (var i = 0; i < methods.length; i++) {
    const method = methods[i],
      original = obj[method];

    obj[method] = function() {
      var op = exports.operation(options),
        args = Array.prototype.slice.call(arguments),
        callback = args.pop();

      args.push(function(err) {
        if (op.retry(err)) return;

        if (err) arguments[0] = op.mainError();

        callback.apply(this, arguments);
      });

      op.attempt(function() {
        original.apply(obj, args);
      });
    };
    obj[method].options = options;
  }
};
//
},
'retry/lib/retry_operation':
function(module) {
//
function RetryOperation(timeouts, options) {
  if (typeof options == 'boolean') options = {forever: options};

  this._timeouts = timeouts;
  this._options = options || {};
  this._fn = null;
  this._errors = [];
  this._attempts = 1;
  this._operationTimeout = null;
  this._operationTimeoutCb = null;
  this._timeout = null;

  if (this._options.forever) this._cachedTimeouts = this._timeouts.slice(0);
}
module.exports = RetryOperation;

RetryOperation.prototype.stop = function() {
  this._timeout && clearTimeout(this._timeout);

  this._timeouts = [];
  this._cachedTimeouts = null;
};

RetryOperation.prototype.retry = function(err) {
  this._timeout && clearTimeout(this._timeout);

  if (!err) return false;

  this._errors.push(err);

  var timeout = this._timeouts.shift();
  if (timeout === void 0) {
    if (!this._cachedTimeouts) return false;

    this._errors.splice(this._errors.length - 1, this._errors.length);
    this._timeouts = this._cachedTimeouts.slice(0);
    timeout = this._timeouts.shift();
  }

  var self = this;
  var timer = setTimeout(function() {
    self._attempts++;

    if (self._operationTimeoutCb) {
      self._timeout = setTimeout(function() {
        self._operationTimeoutCb(self._attempts);
      }, self._operationTimeout);

      self._options.unref && self._timeout.unref();
    }

    self._fn(self._attempts);
  }, timeout);

  this._options.unref && timer.unref();

  return true;
};

RetryOperation.prototype.attempt = function(fn, timeoutOps) {
  this._fn = fn;

  if (timeoutOps) {
    if (timeoutOps.timeout) this._operationTimeout = timeoutOps.timeout;
    if (timeoutOps.cb) this._operationTimeoutCb = timeoutOps.cb;
  }

  var self = this;
  if (this._operationTimeoutCb)
    this._timeout = setTimeout(function() {
      self._operationTimeoutCb();
    }, self._operationTimeout);

  this._fn(this._attempts);
};

RetryOperation.prototype.try = function(fn) {
  console.log('Using RetryOperation.try() is deprecated');
  this.attempt(fn);
};

RetryOperation.prototype.start = function(fn) {
  console.log('Using RetryOperation.start() is deprecated');
  this.attempt(fn);
};

RetryOperation.prototype.start = RetryOperation.prototype.try;

RetryOperation.prototype.errors = function() {
  return this._errors;
};

RetryOperation.prototype.attempts = function() {
  return this._attempts;
};

RetryOperation.prototype.mainError = function() {
  if (this._errors.length === 0) return null;

  var counts = {},
    mainError = null,
    mainErrorCount = 0;

  for (var i = 0; i < this._errors.length; i++) {
    var error = this._errors[i],
      message = error.message,
      count = (counts[message] || 0) + 1;

    counts[message] = count;

    if (count >= mainErrorCount) {
      mainError = error;
      mainErrorCount = count;
    }
  }

  return mainError;
};
//
},
'proper-lockfile/lib/syncFs':
function(module) {
//
function makeSync(fs, name) {
  const fn = fs[name + 'Sync'];

  return function() {
    const args = Array.prototype.slice.call(arguments),
      callback = args.pop();
    let ret;

    try {
      ret = fn.apply(fs, args);
    } catch (err) {
      return callback(err);
    }

    callback(null, ret);
  };
}

function syncFs(fs) {
  const obj = {};

  ['mkdir', 'realpath', 'stat', 'rmdir', 'utimes'].forEach(name => {
    obj[name] = makeSync(fs, name);
  });

  for (const key in fs) obj[key] || (obj[key] = fs[key]);

  return obj;
}

module.exports = syncFs;
//
},
'loud-rejection':
function(module, exports, __wpreq__) {
//
var util = __wpreq__('util'),
  onExit = __wpreq__('signal-exit'),
  currentlyUnhandled = __wpreq__('currently-unhandled'),

  installed = false;

module.exports = function(log) {
  if (installed) return;
  installed = true;

  log = log || console.error;

  var listUnhandled = currentlyUnhandled();

  onExit(function() {
    var unhandledRejections = listUnhandled();

    if (unhandledRejections.length > 0) {
      unhandledRejections.forEach(function(x) {
        var err = x.reason;

        err instanceof Error || (err = new Error('Promise rejected with value: ' + util.inspect(err)));

        log(err.stack);
      });

      process.exitCode = 1;
    }
  });
};
//
},
'signal-exit':
function(module, exports, __wpreq__) {
//
var /** @type {(EventEmitter|*)} */ emitter,
  assert = __wpreq__('assert'),
  signals = __wpreq__('signal-exit/signals'),

  EE = __wpreq__('events')
if (typeof EE != 'function') EE = EE.EventEmitter

/** @var {(NodeJS.Process|*)} process */
if (process.__signal_exit_emitter__) emitter = process.__signal_exit_emitter__
else {
  process.__signal_exit_emitter__ = emitter = new EE()
  emitter.count = 0
  emitter.emitted = {}
}

if (!emitter.infinite) {
  emitter.setMaxListeners(Infinity)
  emitter.infinite = true
}

module.exports = function(cb, opts) {
  assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')

  loaded !== false || load()

  var ev = 'exit'
  if (opts && opts.alwaysLast) ev = 'afterexit'

  var remove = function() {
    emitter.removeListener(ev, cb)
    emitter.listeners('exit').length > 0 || emitter.listeners('afterexit').length > 0 || unload()
  }
  emitter.on(ev, cb)

  return remove
}

module.exports.unload = unload
function unload() {
  if (!loaded) return
  loaded = false

  signals.forEach(function(sig) {
    try {
      process.removeListener(sig, sigListeners[sig])
    } catch (_er) {}
  })
  process.emit = originalProcessEmit
  process.reallyExit = originalProcessReallyExit
  emitter.count -= 1
}

function emit(event, code, signal) {
  if (emitter.emitted[event]) return

  emitter.emitted[event] = true
  emitter.emit(event, code, signal)
}

var sigListeners = {}
signals.forEach(function(sig) {
  sigListeners[sig] = function() {
    if (process.listeners(sig).length === emitter.count) {
      unload()
      emit('exit', null, sig)
      emit('afterexit', null, sig)
      process.kill(process.pid, sig)
    }
  }
})

module.exports.signals = function() {
  return signals
}

module.exports.load = load

var loaded = false

function load() {
  if (loaded) return
  loaded = true

  emitter.count += 1

  signals = signals.filter(function(sig) {
    try {
      process.on(sig, sigListeners[sig])
      return true
    } catch (_er) {
      return false
    }
  })

  process.emit = processEmit
  process.reallyExit = processReallyExit
}

var originalProcessReallyExit = process.reallyExit
function processReallyExit(code) {
  process.exitCode = code || 0
  emit('exit', process.exitCode, null)
  emit('afterexit', process.exitCode, null)
  originalProcessReallyExit.call(process, process.exitCode)
}

var originalProcessEmit = process.emit
function processEmit(ev, arg) {
  if (ev === 'exit') {
    if (arg !== void 0) process.exitCode = arg

    var ret = originalProcessEmit.apply(this, arguments)
    emit('exit', process.exitCode, null)
    emit('afterexit', process.exitCode, null)
    return ret
  }

  return originalProcessEmit.apply(this, arguments)
}
//
},
'signal-exit/signals':
function(module) {
//
module.exports = ['SIGABRT', 'SIGALRM', 'SIGHUP', 'SIGINT', 'SIGTERM']

process.platform === 'win32' ||
  module.exports.push('SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT')

process.platform !== 'linux' || module.exports.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT', 'SIGUNUSED')
//
},
'currently-unhandled':
function(module, exports, __wpreq__) {
//
var core = __wpreq__('currently-unhandled/core');

module.exports = function(p) {
  p = p || process;
  var c = core();

  p.on('unhandledRejection', c.onUnhandledRejection);
  p.on('rejectionHandled', c.onRejectionHandled);

  return c.currentlyUnhandled;
};
//
},
'currently-unhandled/core':
function(module) {
//
var arrayFindIndex = Function.call.bind([].findIndex);

module.exports = function() {
  var unhandledRejections = [];

  function onUnhandledRejection(reason, promise) {
    unhandledRejections.push({reason: reason, promise: promise});
  }

  function onRejectionHandled(promise) {
    var index = arrayFindIndex(unhandledRejections, function(x) {
      return x.promise === promise;
    });

    unhandledRejections.splice(index, 1);
  }

  function currentlyUnhandled() {
    return unhandledRejections.map(function(entry) {
      return {reason: entry.reason, promise: entry.promise};
    });
  }

  return {
    onUnhandledRejection: onUnhandledRejection,
    onRejectionHandled: onRejectionHandled,
    currentlyUnhandled: currentlyUnhandled
  };
};
//
},
death:
function(module) {
//
var defaultConfig = {
  uncaughtException: false,
  SIGINT: true,
  SIGTERM: true,
  SIGQUIT: true
}

var DEBUG = false

function ON_DEATH(callback) {
  var handlers = [];
  Object.keys(defaultConfig).forEach(function(key) {
    var handler = null;
    if (defaultConfig[key]) {
      if (DEBUG) {
        handler = function() {
          var args = Array.prototype.slice.call(arguments, 0)
          args.unshift(key)
          console.log('Trapped ' + key)
          callback.apply(null, args)
        };
        process.on(key, handler)
      } else {
        handler = function() {
          var args = Array.prototype.slice.call(arguments, 0)
          args.unshift(key)
          callback.apply(null, args)
        }
        process.on(key, handler)
      }
      handlers.push([key, handler])
    }
  })
  return function() {
    handlers.forEach(function(args) {
      var key = args[0],
        handler = args[1];
      process.removeListener(key, handler);
    })
  }
}

module.exports = function(arg) {
  if (typeof arg == 'object') {
    if (arg.debug) DEBUG = arg.debug
    if (arg.DEBUG) DEBUG = arg.DEBUG
    delete arg.debug;
    delete arg.DEBUG;

    Object.keys(arg).forEach(function(key) {
      defaultConfig[key] = arg[key]
    })

    DEBUG && console.log('ON_DEATH: debug mode enabled for pid [%d]', process.pid)

    return ON_DEATH
  }
  if (typeof arg == 'function') return ON_DEATH(arg)
}
//
},
semver:
function(module, exports) {
//
exports = module.exports = SemVer;

var debug =
  typeof process == 'object' && process.env && /\bsemver\b/i.test(process.env.NODE_DEBUG)
  ? function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift('SEMVER');
      console.log.apply(console, args);
    }
  : function() {};

exports.SEMVER_SPEC_VERSION = '2.0.0';

var MAX_LENGTH = 256,
  MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991,

  MAX_SAFE_COMPONENT_LENGTH = 16;

var re = (exports.re = []),
  src = (exports.src = []),
  R = 0;

var NUMERICIDENTIFIER = R++;
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
var NUMERICIDENTIFIERLOOSE = R++;
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';

var NONNUMERICIDENTIFIER = R++;
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';

var MAINVERSION = R++;
src[MAINVERSION] =
  '(' + src[NUMERICIDENTIFIER] + ')\\.(' + src[NUMERICIDENTIFIER] + ')\\.(' + src[NUMERICIDENTIFIER] + ')';

var MAINVERSIONLOOSE = R++;
src[MAINVERSIONLOOSE] =
  '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.(' + src[NUMERICIDENTIFIERLOOSE] + ')';

var PRERELEASEIDENTIFIER = R++;
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] + '|' + src[NONNUMERICIDENTIFIER] + ')';

var PRERELEASEIDENTIFIERLOOSE = R++;
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] + '|' + src[NONNUMERICIDENTIFIER] + ')';

var PRERELEASE = R++;
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] + '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';

var PRERELEASELOOSE = R++;
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';

var BUILDIDENTIFIER = R++;
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';

var BUILD = R++;
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] + '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';

var FULL = R++,
  FULLPLAIN = 'v?' + src[MAINVERSION] + src[PRERELEASE] + '?' + src[BUILD] + '?';

src[FULL] = '^' + FULLPLAIN + '$';

var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + '?' + src[BUILD] + '?',

  LOOSE = R++;
src[LOOSE] = '^' + LOOSEPLAIN + '$';

var GTLT = R++;
src[GTLT] = '((?:<|>)?=?)';

var XRANGEIDENTIFIERLOOSE = R++;
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
var XRANGEIDENTIFIER = R++;
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';

var XRANGEPLAIN = R++;
src[XRANGEPLAIN] =
  '[v=\\s]*(' + src[XRANGEIDENTIFIER] +
  ')(?:\\.(' + src[XRANGEIDENTIFIER] +
  ')(?:\\.(' + src[XRANGEIDENTIFIER] +
  ')(?:' + src[PRERELEASE] + ')?' +
  src[BUILD] + '?)?)?';

var XRANGEPLAINLOOSE = R++;
src[XRANGEPLAINLOOSE] =
  '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] +
  ')(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] +
  ')(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] +
  ')(?:' + src[PRERELEASELOOSE] + ')?' +
  src[BUILD] + '?)?)?';

var XRANGE = R++;
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
var XRANGELOOSE = R++;
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';

var COERCE = R++;
src[COERCE] =
  '(?:^|[^\\d])(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH +
  '})(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH +
  '}))?(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH +
  '}))?(?:$|[^\\d])';

var LONETILDE = R++;
src[LONETILDE] = '(?:~>?)';

var TILDETRIM = R++;
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
var tildeTrimReplace = '$1~',

  TILDE = R++;
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
var TILDELOOSE = R++;
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';

var LONECARET = R++;
src[LONECARET] = '(?:\\^)';

var CARETTRIM = R++;
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
var caretTrimReplace = '$1^',

  CARET = R++;
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
var CARETLOOSE = R++;
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';

var COMPARATORLOOSE = R++;
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
var COMPARATOR = R++;
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';

var COMPARATORTRIM = R++;
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] + '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';

re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
var comparatorTrimReplace = '$1$2$3',

  HYPHENRANGE = R++;
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')\\s+-\\s+(' + src[XRANGEPLAIN] + ')\\s*$';

var HYPHENRANGELOOSE = R++;
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')\\s+-\\s+(' + src[XRANGEPLAINLOOSE] + ')\\s*$';

var STAR = R++;
src[STAR] = '(<|>)?=?\\s*\\*';

src.forEach(function(s, i) {
  debug(i, s);
  re[i] || (re[i] = new RegExp(s));
});

exports.parse = parse;
function parse(version, loose) {
  if (version instanceof SemVer) return version;

  if (typeof version != 'string' || version.length > MAX_LENGTH) return null;

  if (!(loose ? re[LOOSE] : re[FULL]).test(version)) return null;

  try {
    return new SemVer(version, loose);
  } catch (_er) {
    return null;
  }
}

exports.valid = valid;
function valid(version, loose) {
  var v = parse(version, loose);
  return v ? v.version : null;
}

exports.clean = clean;
function clean(version, loose) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
  return s ? s.version : null;
}

exports.SemVer = SemVer;

function SemVer(version, loose) {
  if (version instanceof SemVer) {
    if (version.loose === loose) return version;

    version = version.version;
  } else if (typeof version != 'string') throw new TypeError('Invalid Version: ' + version);

  if (version.length > MAX_LENGTH) throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')

  if (!(this instanceof SemVer)) return new SemVer(version, loose);

  debug('SemVer', version, loose);
  this.loose = loose;
  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);

  if (!m) throw new TypeError('Invalid Version: ' + version);

  this.raw = version;

  this.major = +m[1];
  this.minor = +m[2];
  this.patch = +m[3];

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError('Invalid major version')

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError('Invalid minor version')

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError('Invalid patch version')

  if (!m[4]) this.prerelease = [];
  else
    this.prerelease = m[4].split('.').map(function(id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id;
        if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
      }
      return id;
    });

  this.build = m[5] ? m[5].split('.') : [];
  this.format();
}

SemVer.prototype.format = function() {
  this.version = this.major + '.' + this.minor + '.' + this.patch;
  if (this.prerelease.length) this.version += '-' + this.prerelease.join('.');
  return this.version;
};

SemVer.prototype.toString = function() {
  return this.version;
};

SemVer.prototype.compare = function(other) {
  debug('SemVer.compare', this.version, this.loose, other);
  other instanceof SemVer || (other = new SemVer(other, this.loose));

  return this.compareMain(other) || this.comparePre(other);
};

SemVer.prototype.compareMain = function(other) {
  other instanceof SemVer || (other = new SemVer(other, this.loose));

  return (
    compareIdentifiers(this.major, other.major) ||
    compareIdentifiers(this.minor, other.minor) ||
    compareIdentifiers(this.patch, other.patch)
  );
};

SemVer.prototype.comparePre = function(other) {
  other instanceof SemVer || (other = new SemVer(other, this.loose));

  if (this.prerelease.length && !other.prerelease.length) return -1;
  if (!this.prerelease.length && other.prerelease.length) return 1;
  if (!this.prerelease.length && !other.prerelease.length) return 0;

  var i = 0;
  do {
    var a = this.prerelease[i],
      b = other.prerelease[i];
    debug('prerelease compare', i, a, b);
    if (a === void 0 && b === void 0) return 0;
    if (b === void 0) return 1;
    if (a === void 0) return -1;

    if (a !== b) return compareIdentifiers(a, b);
  } while (++i);
};

SemVer.prototype.inc = function(release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor = 0;
      this.major++;
      this.inc('pre', identifier);
      break;
    case 'preminor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor++;
      this.inc('pre', identifier);
      break;
    case 'prepatch':
      this.prerelease.length = 0;
      this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;
    case 'prerelease':
      this.prerelease.length > 0 || this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;

    case 'major':
      (this.minor === 0 && this.patch === 0 && this.prerelease.length > 0) || this.major++;
      this.minor = 0;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'minor':
      (this.patch === 0 && this.prerelease.length > 0) || this.minor++;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'patch':
      this.prerelease.length > 0 || this.patch++;
      this.prerelease = [];
      break;
    case 'pre':
      if (this.prerelease.length === 0) this.prerelease = [0];
      else {
        var i = this.prerelease.length;
        while (--i >= 0)
          if (typeof this.prerelease[i] == 'number') {
            this.prerelease[i]++;
            i = -2;
          }

        i !== -1 || this.prerelease.push(0);
      }
      if (identifier)
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) this.prerelease = [identifier, 0];
        } else this.prerelease = [identifier, 0];

      break;

    default:
      throw new Error('invalid increment argument: ' + release);
  }
  this.format();
  this.raw = this.version;
  return this;
};

exports.inc = inc;
function inc(version, release, loose, identifier) {
  if (typeof loose == 'string') {
    identifier = loose;
    loose = void 0;
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version;
  } catch (_er) {
    return null;
  }
}

exports.diff = diff;
function diff(version1, version2) {
  if (eq(version1, version2)) return null;

  var v1 = parse(version1),
    v2 = parse(version2);
  if (v1.prerelease.length || v2.prerelease.length) {
    for (const key in v1)
      if ((key === 'major' || key === 'minor' || key === 'patch') && v1[key] !== v2[key]) return 'pre' + key;

    return 'prerelease';
  }
  for (var key in v1)
    if ((key === 'major' || key === 'minor' || key === 'patch') && v1[key] !== v2[key]) return key;
}

exports.compareIdentifiers = compareIdentifiers;

var numeric = /^[0-9]+$/;
function compareIdentifiers(a, b) {
  var anum = numeric.test(a),
    bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : a > b ? 1 : 0;
}

exports.rcompareIdentifiers = rcompareIdentifiers;
function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
}

exports.major = major;
function major(a, loose) {
  return new SemVer(a, loose).major;
}

exports.minor = minor;
function minor(a, loose) {
  return new SemVer(a, loose).minor;
}

exports.patch = patch;
function patch(a, loose) {
  return new SemVer(a, loose).patch;
}

exports.compare = compare;
function compare(a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose));
}

exports.compareLoose = compareLoose;
function compareLoose(a, b) {
  return compare(a, b, true);
}

exports.rcompare = rcompare;
function rcompare(a, b, loose) {
  return compare(b, a, loose);
}

exports.sort = sort;
function sort(list, loose) {
  return list.sort(function(a, b) {
    return exports.compare(a, b, loose);
  });
}

exports.rsort = rsort;
function rsort(list, loose) {
  return list.sort(function(a, b) {
    return exports.rcompare(a, b, loose);
  });
}

exports.gt = gt;
function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
}

exports.lt = lt;
function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
}

exports.eq = eq;
function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
}

exports.neq = neq;
function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
}

exports.gte = gte;
function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
}

exports.lte = lte;
function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
}

exports.cmp = cmp;
function cmp(a, op, b, loose) {
  var ret;
  switch (op) {
    case '===':
      if (typeof a == 'object') a = a.version;
      if (typeof b == 'object') b = b.version;
      ret = a === b;
      break;
    case '!==':
      if (typeof a == 'object') a = a.version;
      if (typeof b == 'object') b = b.version;
      ret = a !== b;
      break;
    case '': case '=': case '==': ret = eq(a, b, loose); break;
    case '!=': ret = neq(a, b, loose); break;
    case '>': ret = gt(a, b, loose); break;
    case '>=': ret = gte(a, b, loose); break;
    case '<': ret = lt(a, b, loose); break;
    case '<=': ret = lte(a, b, loose); break;
    default: throw new TypeError('Invalid operator: ' + op);
  }
  return ret;
}

exports.Comparator = Comparator;
function Comparator(comp, loose) {
  if (comp instanceof Comparator) {
    if (comp.loose === loose) return comp;

    comp = comp.value;
  }

  if (!(this instanceof Comparator)) return new Comparator(comp, loose);

  debug('comparator', comp, loose);
  this.loose = loose;
  this.parse(comp);

  this.semver === ANY ? (this.value = '') : (this.value = this.operator + this.semver.version);

  debug('comp', this);
}

var ANY = {};
Comparator.prototype.parse = function(comp) {
  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR],
    m = comp.match(r);

  if (!m) throw new TypeError('Invalid comparator: ' + comp);

  this.operator = m[1];
  if (this.operator === '=') this.operator = '';

  m[2] ? (this.semver = new SemVer(m[2], this.loose)) : (this.semver = ANY);
};

Comparator.prototype.toString = function() {
  return this.value;
};

Comparator.prototype.test = function(version) {
  debug('Comparator.test', version, this.loose);

  if (this.semver === ANY) return true;

  if (typeof version == 'string') version = new SemVer(version, this.loose);

  return cmp(version, this.operator, this.semver, this.loose);
};

Comparator.prototype.intersects = function(comp, loose) {
  if (!(comp instanceof Comparator)) throw new TypeError('a Comparator is required');

  var rangeTmp;

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, loose);
    return satisfies(this.value, rangeTmp, loose);
  }
  if (comp.operator === '') {
    rangeTmp = new Range(this.value, loose);
    return satisfies(comp.semver, rangeTmp, loose);
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>');
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<');
  var sameSemVer = this.semver.version === comp.semver.version;
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=');
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, loose) &&
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<');
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, loose) &&
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>');

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
};

exports.Range = Range;
function Range(range, loose) {
  if (range instanceof Range) return range.loose === loose ? range : new Range(range.raw, loose);

  if (range instanceof Comparator) return new Range(range.value, loose);

  if (!(this instanceof Range)) return new Range(range, loose);

  this.loose = loose;

  this.raw = range;
  this.set = range.split(/\s*\|\|\s*/).map(function(range) {
    return this.parseRange(range.trim());
  }, this).filter(function(c) {
    return c.length;
  });

  if (!this.set.length) throw new TypeError('Invalid SemVer Range: ' + range);

  this.format();
}

Range.prototype.format = function() {
  this.range = this.set.map(function(comps) {
    return comps.join(' ').trim();
  }).join('||').trim();
  return this.range;
};

Range.prototype.toString = function() {
  return this.range;
};

Range.prototype.parseRange = function(range) {
  var loose = this.loose;
  range = range.trim();
  debug('range', range, loose);
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
  range = range.replace(hr, hyphenReplace);
  debug('hyphen replace', range);
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
  debug('comparator trim', range, re[COMPARATORTRIM]);

  range = range.replace(re[TILDETRIM], tildeTrimReplace);
  range = range.replace(re[CARETTRIM], caretTrimReplace);

  range = range.split(/\s+/).join(' ');

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var set = range.split(' ').map(function(comp) {
    return parseComparator(comp, loose);
  }).join(' ').split(/\s+/);
  if (this.loose)
    set = set.filter(function(comp) {
      return !!comp.match(compRe);
    });

  return set.map(function(comp) {
    return new Comparator(comp, loose);
  });
};

Range.prototype.intersects = function(range, loose) {
  if (!(range instanceof Range)) throw new TypeError('a Range is required');

  return this.set.some(function(thisComparators) {
    return thisComparators.every(function(thisComparator) {
      return range.set.some(function(rangeComparators) {
        return rangeComparators.every(function(rangeComparator) {
          return thisComparator.intersects(rangeComparator, loose);
        });
      });
    });
  });
};

exports.toComparators = toComparators;
function toComparators(range, loose) {
  return new Range(range, loose).set.map(function(comp) {
    return comp.map(function(c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
}

function parseComparator(comp, loose) {
  debug('comp', comp);
  comp = replaceCarets(comp, loose);
  debug('caret', comp);
  comp = replaceTildes(comp, loose);
  debug('tildes', comp);
  comp = replaceXRanges(comp, loose);
  debug('xrange', comp);
  comp = replaceStars(comp, loose);
  debug('stars', comp);
  return comp;
}

function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
}

function replaceTildes(comp, loose) {
  return comp.trim().split(/\s+/).map(function(comp) {
    return replaceTilde(comp, loose);
  }).join(' ');
}

function replaceTilde(comp, loose) {
  var r = loose ? re[TILDELOOSE] : re[TILDE];
  return comp.replace(r, function(_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) ret = '';
    else if (isX(m)) ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (isX(p)) ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    else if (pr) {
      debug('replaceTilde pr', pr);
      if (pr.charAt(0) !== '-') pr = '-' + pr;
      ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + (+m + 1) + '.0';
    } else ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';

    debug('tilde return', ret);
    return ret;
  });
}

function replaceCarets(comp, loose) {
  return comp.trim().split(/\s+/).map(function(comp) {
    return replaceCaret(comp, loose);
  }).join(' ');
}

function replaceCaret(comp, loose) {
  debug('caret', comp, loose);
  var r = loose ? re[CARETLOOSE] : re[CARET];
  return comp.replace(r, function(_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) ret = '';
    else if (isX(m)) ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (isX(p))
      ret = M === '0'
        ? '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
        : '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
    else if (pr) {
      debug('replaceCaret pr', pr);
      if (pr.charAt(0) !== '-') pr = '-' + pr;
      ret = M === '0'
        ? m === '0'
          ? '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + m + '.' + (+p + 1)
          : '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + (+m + 1) + '.0'
        : '>=' + M + '.' + m + '.' + p + pr + ' <' + (+M + 1) + '.0.0';
    } else {
      debug('no pr');
      ret = M === '0'
        ? m === '0'
          ? '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1)
          : '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0'
        : '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
    }

    debug('caret return', ret);
    return ret;
  });
}

function replaceXRanges(comp, loose) {
  debug('replaceXRanges', comp, loose);
  return comp.split(/\s+/).map(function(comp) {
    return replaceXRange(comp, loose);
  }).join(' ');
}

function replaceXRange(comp, loose) {
  comp = comp.trim();
  var r = loose ? re[XRANGELOOSE] : re[XRANGE];
  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M),
      xm = xM || isX(m),
      xp = xm || isX(p),
      anyX = xp;

    if (gtlt === '=' && anyX) gtlt = '';

    if (xM) ret = gtlt === '>' || gtlt === '<' ? '<0.0.0' : '*';
    else if (gtlt && anyX) {
      if (xm) m = 0;
      if (xp) p = 0;

      if (gtlt === '>') {
        gtlt = '>=';
        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else if (xp) {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        gtlt = '<';
        xm ? (M = +M + 1) : (m = +m + 1);
      }

      ret = gtlt + M + '.' + m + '.' + p;
    } else if (xm) ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (xp) ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';

    debug('xRange return', ret);

    return ret;
  });
}

function replaceStars(comp, loose) {
  debug('replaceStars', comp, loose);
  return comp.trim().replace(re[STAR], '');
}

function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, _tb) {
  from = isX(fM) ? '' : isX(fm) ? '>=' + fM + '.0.0' : isX(fp) ? '>=' + fM + '.' + fm + '.0' : '>=' + from;

  to = isX(tM)
    ? ''
    : isX(tm)
    ? '<' + (+tM + 1) + '.0.0'
    : isX(tp)
    ? '<' + tM + '.' + (+tm + 1) + '.0'
    : tpr
    ? '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
    : '<=' + to;

  return (from + ' ' + to).trim();
}

Range.prototype.test = function(version) {
  if (!version) return false;

  if (typeof version == 'string') version = new SemVer(version, this.loose);

  for (var i = 0; i < this.set.length; i++) if (testSet(this.set[i], version)) return true;

  return false;
};

function testSet(set, version) {
  for (var i = 0; i < set.length; i++) if (!set[i].test(version)) return false;

  if (!version.prerelease.length) return true;

  for (i = 0; i < set.length; i++) {
    debug(set[i].semver);

    if (set[i].semver !== ANY && set[i].semver.prerelease.length > 0) {
      var allowed = set[i].semver;
      if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch)
        return true;
    }
  }

  return false;
}

exports.satisfies = satisfies;
function satisfies(version, range, loose) {
  try {
    range = new Range(range, loose);
  } catch (_er) {
    return false;
  }
  return range.test(version);
}

exports.maxSatisfying = maxSatisfying;
function maxSatisfying(versions, range, loose) {
  var max = null,
    maxSV = null;
  try {
    var rangeObj = new Range(range, loose);
  } catch (_er) {
    return null;
  }
  versions.forEach(function(v) {
    !rangeObj.test(v) || (max && maxSV.compare(v) !== -1) || (maxSV = new SemVer((max = v), loose));
  })
  return max;
}

exports.minSatisfying = minSatisfying;
function minSatisfying(versions, range, loose) {
  var min = null,
    minSV = null;
  try {
    var rangeObj = new Range(range, loose);
  } catch (_er) {
    return null;
  }
  versions.forEach(function(v) {
    !rangeObj.test(v) || (min && minSV.compare(v) !== 1) || (minSV = new SemVer((min = v), loose));
  })
  return min;
}

exports.validRange = validRange;
function validRange(range, loose) {
  try {
    return new Range(range, loose).range || '*';
  } catch (_er) {
    return null;
  }
}

exports.ltr = ltr;
function ltr(version, range, loose) {
  return outside(version, range, '<', loose);
}

exports.gtr = gtr;
function gtr(version, range, loose) {
  return outside(version, range, '>', loose);
}

exports.outside = outside;
function outside(version, range, hilo, loose) {
  version = new SemVer(version, loose);
  range = new Range(range, loose);

  var gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;
    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }

  if (satisfies(version, range, loose)) return false;

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i],

      high = null,
      low = null;

    comparators.forEach(function(comparator) {
      if (comparator.semver === ANY) comparator = new Comparator('>=0.0.0')

      high = high || comparator;
      low = low || comparator;
      if (gtfn(comparator.semver, high.semver, loose)) high = comparator;
      else if (ltfn(comparator.semver, low.semver, loose)) low = comparator;
    });

    if (high.operator === comp || high.operator === ecomp) return false;

    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) return false;
    if (low.operator === ecomp && ltfn(version, low.semver)) return false;
  }
  return true;
}

exports.prerelease = prerelease;
function prerelease(version, loose) {
  var parsed = parse(version, loose);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
}

exports.intersects = intersects;
function intersects(r1, r2, loose) {
  r1 = new Range(r1, loose)
  r2 = new Range(r2, loose)
  return r1.intersects(r2)
}

exports.coerce = coerce;
function coerce(version) {
  if (version instanceof SemVer) return version;

  if (typeof version != 'string') return null;

  var match = version.match(re[COERCE]);

  return match == null ? null : parse((match[1] || '0') + '.' + (match[2] || '0') + '.' + (match[3] || '0'));
}
//
},
chalk:
function(module, exports, __wpreq__) {
//
const escapeStringRegexp = __wpreq__('escape-string-regexp'),
  ansiStyles = __wpreq__('ansi-styles'),
  stdoutColor = __wpreq__('supports-color').stdout,

  template = __wpreq__('chalk/templates'),

  isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm'),

  levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'],
  skipModels = new Set(['gray']),

  styles = Object.create(null);

function applyOptions(obj, options) {
  options = options || {};

  const scLevel = stdoutColor ? stdoutColor.level : 0;
  obj.level = options.level === void 0 ? scLevel : options.level;
  obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;
}

function Chalk(options) {
  if (!this || !(this instanceof Chalk) || this.template) {
    const chalk = {};
    applyOptions(chalk, options);

    chalk.template = function() {
      const args = [].slice.call(arguments);
      return chalkTag.apply(null, [chalk.template].concat(args));
    };

    Object.setPrototypeOf(chalk, Chalk.prototype);
    Object.setPrototypeOf(chalk.template, chalk);

    chalk.template.constructor = Chalk;

    return chalk.template;
  }

  applyOptions(this, options);
}

if (isSimpleWindowsTerm) ansiStyles.blue.open = '\x1B[94m';

for (const key of Object.keys(ansiStyles)) {
  ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

  styles[key] = {
    get() {
      const codes = ansiStyles[key];
      return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
    }
  };
}

styles.visible = {
  get() {
    return build.call(this, this._styles || [], true, 'visible');
  }
};

ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');
for (const model of Object.keys(ansiStyles.color.ansi)) {
  if (skipModels.has(model)) continue;

  styles[model] = {
    get() {
      const level = this.level;
      return function() {
        const codes = {
          open: ansiStyles.color[levelMapping[level]][model].apply(null, arguments),
          close: ansiStyles.color.close,
          closeRe: ansiStyles.color.closeRe
        };
        return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
      };
    }
  };
}

ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');
for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
  if (skipModels.has(model)) continue;

  styles['bg' + model[0].toUpperCase() + model.slice(1)] = {
    get() {
      const level = this.level;
      return function() {
        const codes = {
          open: ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments),
          close: ansiStyles.bgColor.close,
          closeRe: ansiStyles.bgColor.closeRe
        };
        return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
      };
    }
  };
}

const proto = Object.defineProperties(() => {}, styles);

function build(_styles, _empty, key) {
  const builder = function() {
    return applyStyle.apply(builder, arguments);
  };

  builder._styles = _styles;
  builder._empty = _empty;

  const self = this;

  Object.defineProperty(builder, 'level', {
    enumerable: true,
    get: () => self.level,
    set(level) {
      self.level = level;
    }
  });

  Object.defineProperty(builder, 'enabled', {
    enumerable: true,
    get: () => self.enabled,
    set(enabled) {
      self.enabled = enabled;
    }
  });

  builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey';

  builder.__proto__ = proto;

  return builder;
}

function applyStyle() {
  const args = arguments,
    argsLen = args.length;
  let str = String(arguments[0]);

  if (argsLen === 0) return '';

  if (argsLen > 1) for (let a = 1; a < argsLen; a++) str += ' ' + args[a];

  if (!this.enabled || this.level <= 0 || !str) return this._empty ? '' : str;

  const originalDim = ansiStyles.dim.open;
  if (isSimpleWindowsTerm && this.hasGrey) ansiStyles.dim.open = '';

  for (const code of this._styles.slice().reverse()) {
    str = code.open + str.replace(code.closeRe, code.open) + code.close;

    str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
  }

  ansiStyles.dim.open = originalDim;

  return str;
}

function chalkTag(chalk, strings) {
  if (!Array.isArray(strings)) return [].slice.call(arguments, 1).join(' ');

  const args = [].slice.call(arguments, 2),
    parts = [strings.raw[0]];

  for (let i = 1; i < strings.length; i++) {
    parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'));
    parts.push(String(strings.raw[i]));
  }

  return template(chalk, parts.join(''));
}

Object.defineProperties(Chalk.prototype, styles);

// noinspection JSPotentiallyInvalidConstructorUsage
module.exports = Chalk();
module.exports.supportsColor = stdoutColor;
module.exports.default = module.exports;
//
},
'escape-string-regexp':
function(module) {
//
var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

module.exports = function(str) {
  if (typeof str != 'string') throw new TypeError('Expected a string');

  return str.replace(matchOperatorsRe, '\\$&');
};
//
},
'ansi-styles':
function(module, exports, __wpreq__) {
//
const colorConvert = __wpreq__('color-convert');

const wrapAnsi16 = (fn, offset) => function() {
  return `\x1B[${fn.apply(colorConvert, arguments) + offset}m`;
};

const wrapAnsi256 = (fn, offset) => function() {
  const code = fn.apply(colorConvert, arguments);
  return `\x1B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => function() {
  const rgb = fn.apply(colorConvert, arguments);
  return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

function assembleStyles() {
  const codes = new Map();
  const styles = {
    modifier: {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29]
    },
    color: {
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],

      redBright: [91, 39],
      greenBright: [92, 39],
      yellowBright: [93, 39],
      blueBright: [94, 39],
      magentaBright: [95, 39],
      cyanBright: [96, 39],
      whiteBright: [97, 39]
    },
    bgColor: {
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],

      bgBlackBright: [100, 49],
      bgRedBright: [101, 49],
      bgGreenBright: [102, 49],
      bgYellowBright: [103, 49],
      bgBlueBright: [104, 49],
      bgMagentaBright: [105, 49],
      bgCyanBright: [106, 49],
      bgWhiteBright: [107, 49]
    }
  };

  styles.color.grey = styles.color.gray;

  for (const groupName of Object.keys(styles)) {
    const group = styles[groupName];

    for (const styleName of Object.keys(group)) {
      const style = group[styleName];

      styles[styleName] = {open: `\x1B[${style[0]}m`, close: `\x1B[${style[1]}m`};

      group[styleName] = styles[styleName];

      codes.set(style[0], style[1]);
    }

    Object.defineProperty(styles, groupName, {value: group, enumerable: false});

    Object.defineProperty(styles, 'codes', {value: codes, enumerable: false});
  }

  const ansi2ansi = n => n,
    rgb2rgb = (r, g, b) => [r, g, b];

  styles.color.close = '\x1B[39m';
  styles.bgColor.close = '\x1B[49m';

  styles.color.ansi = {ansi: wrapAnsi16(ansi2ansi, 0)};
  styles.color.ansi256 = {ansi256: wrapAnsi256(ansi2ansi, 0)};
  styles.color.ansi16m = {rgb: wrapAnsi16m(rgb2rgb, 0)};

  styles.bgColor.ansi = {ansi: wrapAnsi16(ansi2ansi, 10)};
  styles.bgColor.ansi256 = {ansi256: wrapAnsi256(ansi2ansi, 10)};
  styles.bgColor.ansi16m = {rgb: wrapAnsi16m(rgb2rgb, 10)};

  for (let key of Object.keys(colorConvert)) {
    if (typeof colorConvert[key] != 'object') continue;

    const suite = colorConvert[key];

    if (key === 'ansi16') key = 'ansi';

    if ('ansi16' in suite) {
      styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
      styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
    }

    if ('ansi256' in suite) {
      styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
      styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
    }

    if ('rgb' in suite) {
      styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
      styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
    }
  }

  return styles;
}

module.exports = assembleStyles();
//
},
'color-convert':
function(module, exports, __wpreq__) {
//
var conversions = __wpreq__('color-convert/conversions'),
  route = __wpreq__('color-convert/route'),

  convert = {};

function wrapRaw(fn) {
  var wrappedFn = function(args) {
    if (args === void 0 || args === null) return args;

    if (arguments.length > 1) args = Array.prototype.slice.call(arguments);

    return fn(args);
  };

  if ('conversion' in fn) wrappedFn.conversion = fn.conversion;

  return wrappedFn;
}

function wrapRounded(fn) {
  var wrappedFn = function(args) {
    if (args === void 0 || args === null) return args;

    if (arguments.length > 1) args = Array.prototype.slice.call(arguments);

    var result = fn(args);

    if (typeof result == 'object')
      for (var len = result.length, i = 0; i < len; i++) result[i] = Math.round(result[i]);

    return result;
  };

  if ('conversion' in fn) wrappedFn.conversion = fn.conversion;

  return wrappedFn;
}

Object.keys(conversions).forEach(function(fromModel) {
  convert[fromModel] = {};

  Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
  Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

  var routes = route(fromModel);

  Object.keys(routes).forEach(function(toModel) {
    var fn = routes[toModel];

    convert[fromModel][toModel] = wrapRounded(fn);
    convert[fromModel][toModel].raw = wrapRaw(fn);
  });
});

module.exports = convert;
//
},
'color-convert/conversions':
function(module, exports, __wpreq__) {
//
var cssKeywords = __wpreq__('color-name'),

  reverseKeywords = {};
for (var key in cssKeywords) if (cssKeywords.hasOwnProperty(key)) reverseKeywords[cssKeywords[key]] = key;

var convert = (module.exports = {
  rgb: {channels: 3, labels: 'rgb'},
  hsl: {channels: 3, labels: 'hsl'},
  hsv: {channels: 3, labels: 'hsv'},
  hwb: {channels: 3, labels: 'hwb'},
  cmyk: {channels: 4, labels: 'cmyk'},
  xyz: {channels: 3, labels: 'xyz'},
  lab: {channels: 3, labels: 'lab'},
  lch: {channels: 3, labels: 'lch'},
  hex: {channels: 1, labels: ['hex']},
  keyword: {channels: 1, labels: ['keyword']},
  ansi16: {channels: 1, labels: ['ansi16']},
  ansi256: {channels: 1, labels: ['ansi256']},
  hcg: {channels: 3, labels: ['h', 'c', 'g']},
  apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
  gray: {channels: 1, labels: ['gray']}
});

for (var model in convert)
  if (convert.hasOwnProperty(model)) {
    if (!('channels' in convert[model])) throw new Error('missing channels property: ' + model);

    if (!('labels' in convert[model])) throw new Error('missing channel labels property: ' + model);

    if (convert[model].labels.length !== convert[model].channels)
      throw new Error('channel and label counts mismatch: ' + model);

    var channels = convert[model].channels,
      labels = convert[model].labels;
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], 'channels', {value: channels});
    Object.defineProperty(convert[model], 'labels', {value: labels});
  }

convert.rgb.hsl = function(rgb) {
  var r = rgb[0] / 255,
    g = rgb[1] / 255,
    b = rgb[2] / 255,
    min = Math.min(r, g, b),
    max = Math.max(r, g, b),
    delta = max - min;
  var h, l;

  if (max === min) h = 0;
  else if (r === max) h = (g - b) / delta;
  else if (g === max) h = 2 + (b - r) / delta;
  else if (b === max) h = 4 + (r - g) / delta;

  if ((h = Math.min(h * 60, 360)) < 0) h += 360;

  l = (min + max) / 2;

  return [h, 100 * (max === min ? 0 : l <= 0.5 ? delta / (max + min) : delta / (2 - max - min)), l * 100];
};

convert.rgb.hsv = function(rgb) {
  var rdif, gdif, bdif, h, s;

  var r = rgb[0] / 255,
    g = rgb[1] / 255,
    b = rgb[2] / 255,
    v = Math.max(r, g, b),
    diff = v - Math.min(r, g, b);
  var diffc = function(c) {
    return (v - c) / 6 / diff + 0.5;
  };

  if (diff === 0) h = s = 0;
  else {
    s = diff / v;
    rdif = diffc(r);
    gdif = diffc(g);
    bdif = diffc(b);

    if (r === v) h = bdif - gdif;
    else if (g === v) h = 1 / 3 + rdif - bdif;
    else if (b === v) h = 2 / 3 + gdif - rdif;

    if (h < 0) h += 1;
    else if (h > 1) h -= 1;
  }

  return [h * 360, s * 100, v * 100];
};

convert.rgb.hwb = function(rgb) {
  var r = rgb[0],
    g = rgb[1],
    b = rgb[2];

  return [
    convert.rgb.hsl(rgb)[0],
    (1 / 255) * Math.min(r, g, b) * 100,
    100 * (1 - (1 / 255) * Math.max(r, g, b))
  ];
};

convert.rgb.cmyk = function(rgb) {
  var r = rgb[0] / 255,
    g = rgb[1] / 255,
    b = rgb[2] / 255,

    k = Math.min(1 - r, 1 - g, 1 - b);

  return [
    ((1 - r - k) / (1 - k) || 0) * 100,
    ((1 - g - k) / (1 - k) || 0) * 100,
    ((1 - b - k) / (1 - k) || 0) * 100,
    k * 100
  ];
};

function comparativeDistance(x, y) {
  return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
}

convert.rgb.keyword = function(rgb) {
  var reversed = reverseKeywords[rgb];
  if (reversed) return reversed;

  var currentClosestKeyword,
    currentClosestDistance = Infinity;

  for (var keyword in cssKeywords)
    if (cssKeywords.hasOwnProperty(keyword)) {
      var distance = comparativeDistance(rgb, cssKeywords[keyword]);

      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }

  return currentClosestKeyword;
};

convert.keyword.rgb = function(keyword) {
  return cssKeywords[keyword];
};

convert.rgb.xyz = function(rgb) {
  var r = rgb[0] / 255,
    g = rgb[1] / 255,
    b = rgb[2] / 255;

  r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
  g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
  b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

  return [
    100 * (r * 0.4124 + g * 0.3576 + b * 0.1805),
    100 * (r * 0.2126 + g * 0.7152 + b * 0.0722),
    100 * (r * 0.0193 + g * 0.1192 + b * 0.9505)
  ];
};

convert.rgb.lab = function(rgb) {
  var xyz = convert.rgb.xyz(rgb),
    x = xyz[0],
    y = xyz[1],
    z = xyz[2];

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;

  return [116 * y - 16, 500 * (x - y), 200 * (y - z)];
};

convert.hsl.rgb = function(hsl) {
  var h = hsl[0] / 360,
    s = hsl[1] / 100,
    l = hsl[2] / 100;
  var t1, t2, t3, rgb, val;

  if (s === 0) return [(val = l * 255), val, val];

  t1 = 2 * l - (t2 = l < 0.5 ? l * (1 + s) : l + s - l * s);

  rgb = [0, 0, 0];
  for (var i = 0; i < 3; i++) {
    (t3 = h + (1 / 3) * -(i - 1)) < 0 && t3++;
    t3 > 1 && t3--;

    val = 6 * t3 < 1 ? t1 + 6 * (t2 - t1) * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1;

    rgb[i] = val * 255;
  }

  return rgb;
};

convert.hsl.hsv = function(hsl) {
  var h = hsl[0],
    s = hsl[1] / 100,
    l = hsl[2] / 100,
    smin = s,
    lmin = Math.max(l, 0.01);

  s *= (l *= 2) <= 1 ? l : 2 - l;
  smin *= lmin <= 1 ? lmin : 2 - lmin;

  return [h, 100 * (l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s)), ((l + s) / 2) * 100];
};

convert.hsv.rgb = function(hsv) {
  var h = hsv[0] / 60,
    s = hsv[1] / 100,
    v = hsv[2] / 100,
    hi = Math.floor(h) % 6,

    f = h - Math.floor(h),
    p = 255 * v * (1 - s),
    q = 255 * v * (1 - s * f),
    t = 255 * v * (1 - s * (1 - f));
  v *= 255;

  switch (hi) {
    case 0:
      return [v, t, p];
    case 1:
      return [q, v, p];
    case 2:
      return [p, v, t];
    case 3:
      return [p, q, v];
    case 4:
      return [t, p, v];
    case 5:
      return [v, p, q];
  }
};

convert.hsv.hsl = function(hsv) {
  var h = hsv[0],
    s = hsv[1] / 100,
    v = hsv[2] / 100,
    vmin = Math.max(v, 0.01);
  var lmin, sl, l;

  l = (2 - s) * v;
  sl = s * vmin;

  return [h, ((sl / ((lmin = (2 - s) * vmin) <= 1 ? lmin : 2 - lmin)) || 0) * 100, 100 * (l / 2)];
};

convert.hwb.rgb = function(hwb) {
  var h = hwb[0] / 360,
    wh = hwb[1] / 100,
    bl = hwb[2] / 100,
    ratio = wh + bl;
  var i, v, f, n, r, g, b;

  if (ratio > 1) {
    wh /= ratio;
    bl /= ratio;
  }

  f = 6 * h - (i = Math.floor(6 * h));

  if ((i & 0x01) != 0) f = 1 - f;

  n = wh + f * ((v = 1 - bl) - wh);

  switch (i) {
    default:
    case 6:
    case 0: r = v; g = n; b = wh; break;
    case 1: r = n; g = v; b = wh; break;
    case 2: r = wh; g = v; b = n; break;
    case 3: r = wh; g = n; b = v; break;
    case 4: r = n; g = wh; b = v; break;
    case 5: r = v; g = wh; b = n; break;
  }

  return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function(cmyk) {
  var c = cmyk[0] / 100,
    m = cmyk[1] / 100,
    y = cmyk[2] / 100,
    k = cmyk[3] / 100;

  return [
    255 * (1 - Math.min(1, c * (1 - k) + k)),
    255 * (1 - Math.min(1, m * (1 - k) + k)),
    255 * (1 - Math.min(1, y * (1 - k) + k))
  ];
};

convert.xyz.rgb = function(xyz) {
  var x = xyz[0] / 100,
    y = xyz[1] / 100,
    z = xyz[2] / 100,

    r = x * 3.2406 + y * -1.5372 + z * -0.4986,
    g = x * -0.9689 + y * 1.8758 + z * 0.0415,
    b = x * 0.0557 + y * -0.204 + z * 1.057;

  r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92;
  g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92;
  b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92;

  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);

  return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function(xyz) {
  var x = xyz[0],
    y = xyz[1],
    z = xyz[2];

  x /= 95.047;
  y /= 100;
  z /= 108.883;

  x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
  y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
  z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;

  return [116 * y - 16, 500 * (x - y), 200 * (y - z)];
};

convert.lab.xyz = function(lab) {
  var y = (lab[0] + 16) / 116,
    x = lab[1] / 500 + y,
    z = y - lab[2] / 200,

    y2 = Math.pow(y, 3),
    x2 = Math.pow(x, 3),
    z2 = Math.pow(z, 3);
  y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
  x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
  z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

  return [x * 95.047, y * 100, z * 108.883];
};

convert.lab.lch = function(lab) {
  var l = lab[0],
    a = lab[1],
    b = lab[2],

    h = (Math.atan2(b, a) * 360) / 2 / Math.PI;

  if (h < 0) h += 360;

  return [l, Math.sqrt(a * a + b * b), h];
};

convert.lch.lab = function(lch) {
  var l = lch[0],
    c = lch[1],

    hr = (lch[2] / 360) * 2 * Math.PI;

  return [l, c * Math.cos(hr), c * Math.sin(hr)];
};

convert.rgb.ansi16 = function(args) {
  var r = args[0],
    g = args[1],
    b = args[2],
    value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];

  if ((value = Math.round(value / 50)) === 0) return 30;

  var ansi = 30 + ((Math.round(b / 255) << 2) | (Math.round(g / 255) << 1) | Math.round(r / 255));

  if (value === 2) ansi += 60;

  return ansi;
};

convert.hsv.ansi16 = function(args) {
  return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function(args) {
  var r = args[0],
    g = args[1],
    b = args[2];

  return r === g && g === b
    ? r < 8
      ? 16
      : r > 248
      ? 231
      : Math.round(((r - 8) / 247) * 24) + 232
    : 16 + 36 * Math.round((r / 255) * 5) + 6 * Math.round((g / 255) * 5) + Math.round((b / 255) * 5);
};

convert.ansi16.rgb = function(args) {
  var color = args % 10;

  if (color === 0 || color === 7) {
    if (args > 50) color += 3.5;

    return [(color = (color / 10.5) * 255), color, color];
  }

  var mult = 0.5 * (1 + ~~(args > 50));

  return [(color & 1) * mult * 255, ((color >> 1) & 1) * mult * 255, ((color >> 2) & 1) * mult * 255];
};

convert.ansi256.rgb = function(args) {
  if (args >= 232) {
    var c = 10 * (args - 232) + 8;
    return [c, c, c];
  }

  args -= 16;

  var rem;
  return [(Math.floor(args / 36) / 5) * 255, (Math.floor((rem = args % 36) / 6) / 5) * 255, ((rem % 6) / 5) * 255];
};

convert.rgb.hex = function(args) {
  var integer =
    ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);

  var string = integer.toString(16).toUpperCase();
  return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function(args) {
  var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
  if (!match) return [0, 0, 0];

  var colorString = match[0];

  if (match[0].length === 3)
    colorString = colorString.split('').map(function(char) {
      return char + char;
    }).join('');

  var integer = parseInt(colorString, 16);

  return [(integer >> 16) & 0xFF, (integer >> 8) & 0xFF, integer & 0xFF];
};

convert.rgb.hcg = function(rgb) {
  var r = rgb[0] / 255,
    g = rgb[1] / 255,
    b = rgb[2] / 255,
    max = Math.max(r, g, b),
    min = Math.min(r, g, b),
    chroma = max - min;

  var hue =
    chroma <= 0 ? 0 : max === r ? ((g - b) / chroma) % 6 : max === g ? 2 + (b - r) / chroma : 4 + (r - g) / chroma + 4;

  hue /= 6;

  return [360 * (hue % 1), chroma * 100, 100 * (chroma < 1 ? min / (1 - chroma) : 0)];
};

convert.hsl.hcg = function(hsl) {
  var s = hsl[1] / 100,
    l = hsl[2] / 100,

    f = 0,
    c = l < 0.5 ? 2.0 * s * l : 2.0 * s * (1.0 - l);

  if (c < 1.0) f = (l - 0.5 * c) / (1.0 - c);

  return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function(hsv) {
  var s = hsv[1] / 100,
    v = hsv[2] / 100,

    c = s * v,
    f = 0;

  if (c < 1.0) f = (v - c) / (1 - c);

  return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function(hcg) {
  var h = hcg[0] / 360,
    c = hcg[1] / 100,
    g = hcg[2] / 100;

  if (c === 0.0) return [g * 255, g * 255, g * 255];

  var pure = [0, 0, 0],
    hi = (h % 1) * 6,
    v = hi % 1,
    w = 1 - v,
    mg; //= 0

  switch (Math.floor(hi)) {
    case 0:
      pure[0] = 1; pure[1] = v; pure[2] = 0; break;
    case 1:
      pure[0] = w; pure[1] = 1; pure[2] = 0; break;
    case 2:
      pure[0] = 0; pure[1] = 1; pure[2] = v; break;
    case 3:
      pure[0] = 0; pure[1] = w; pure[2] = 1; break;
    case 4:
      pure[0] = v; pure[1] = 0; pure[2] = 1; break;
    default:
      pure[0] = 1; pure[1] = 0; pure[2] = w;
  }

  mg = (1.0 - c) * g;

  return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
};

convert.hcg.hsv = function(hcg) {
  var c = hcg[1] / 100,

    v = c + (hcg[2] / 100) * (1.0 - c),
    f = 0;

  if (v > 0.0) f = c / v;

  return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function(hcg) {
  var c = hcg[1] / 100,

    l = (hcg[2] / 100) * (1.0 - c) + 0.5 * c,
    s = 0;

  if (l > 0.0 && l < 0.5) s = c / (2 * l);
  else if (l >= 0.5 && l < 1.0) s = c / (2 * (1 - l));

  return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function(hcg) {
  var c = hcg[1] / 100,
    v = c + (hcg[2] / 100) * (1.0 - c);
  return [hcg[0], 100 * (v - c), 100 * (1 - v)];
};

convert.hwb.hcg = function(hwb) {
  var w = hwb[1] / 100,
    v = 1 - hwb[2] / 100,
    c = v - w,
    g = 0;

  if (c < 1) g = (v - c) / (1 - c);

  return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function(apple) {
  return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function(rgb) {
  return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function(args) {
  return [(args[0] / 100) * 255, (args[0] / 100) * 255, (args[0] / 100) * 255];
};

convert.gray.hsl = convert.gray.hsv = function(args) {
  return [0, 0, args[0]];
};

convert.gray.hwb = function(gray) {
  return [0, 100, gray[0]];
};

convert.gray.cmyk = function(gray) {
  return [0, 0, 0, gray[0]];
};

convert.gray.lab = function(gray) {
  return [gray[0], 0, 0];
};

convert.gray.hex = function(gray) {
  var val = Math.round((gray[0] / 100) * 255) & 0xFF,

    string = ((val << 16) + (val << 8) + val).toString(16).toUpperCase();
  return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function(rgb) {
  return [((rgb[0] + rgb[1] + rgb[2]) / 3 / 255) * 100];
};
//
},
'color-name':
function(module) {
//
module.exports = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
//
},
'color-convert/route':
function(module, exports, __wpreq__) {
//
var conversions = __wpreq__('color-convert/conversions');

function buildGraph() {
  var graph = {};

  for (var models = Object.keys(conversions), len = models.length, i = 0; i < len; i++)
    graph[models[i]] = {distance: -1, parent: null};

  return graph;
}

function deriveBFS(fromModel) {
  var graph = buildGraph(),
    queue = [fromModel];

  graph[fromModel].distance = 0;

  while (queue.length) {
    var current = queue.pop(),
      adjacents = Object.keys(conversions[current]);

    for (var len = adjacents.length, i = 0; i < len; i++) {
      var adjacent = adjacents[i],
        node = graph[adjacent];

      if (node.distance === -1) {
        node.distance = graph[current].distance + 1;
        node.parent = current;
        queue.unshift(adjacent);
      }
    }
  }

  return graph;
}

function link(from, to) {
  return function(args) {
    return to(from(args));
  };
}

function wrapConversion(toModel, graph) {
  var path = [graph[toModel].parent, toModel],
    fn = conversions[graph[toModel].parent][toModel];

  for (var cur = graph[toModel].parent; graph[cur].parent; ) {
    path.unshift(graph[cur].parent);
    fn = link(conversions[graph[cur].parent][cur], fn);
    cur = graph[cur].parent;
  }

  fn.conversion = path;
  return fn;
}

module.exports = function(fromModel) {
  var graph = deriveBFS(fromModel),
    conversion = {};

  for (var models = Object.keys(graph), len = models.length, i = 0; i < len; i++) {
    var toModel = models[i];

    if (graph[toModel].parent !== null) conversion[toModel] = wrapConversion(toModel, graph);
  }

  return conversion;
};
//
},
'supports-color':
function(module, exports, __wpreq__) {
//
const os = __wpreq__('os'),
  hasFlag = __wpreq__('has-flag'),

  env = process.env;

let forceColor;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) forceColor = false;
else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) forceColor = true;

if ('FORCE_COLOR' in env) forceColor = !env.FORCE_COLOR.length || parseInt(env.FORCE_COLOR, 10) !== 0;

function translateLevel(level) {
  return level !== 0 && {level, hasBasic: true, has256: level >= 2, has16m: level >= 3};
}

function supportsColor(stream) {
  if (forceColor === false) return 0;

  if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) return 3;

  if (hasFlag('color=256')) return 2;

  if (stream && !stream.isTTY && forceColor !== true) return 0;

  const min = forceColor ? 1 : 0;

  if (process.platform === 'win32') {
    const osRelease = os.release().split('.');

    return Number(process.versions.node.split('.')[0]) >= 8 &&
      Number(osRelease[0]) >= 10 &&
      Number(osRelease[2]) >= 10586
      ? (Number(osRelease[2]) >= 14931 ? 3 : 2)
      : 1;
  }

  if ('CI' in env)
    return ['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship'
      ? 1
      : min;

  if ('TEAMCITY_VERSION' in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;

  if (env.COLORTERM === 'truecolor') return 3;

  if ('TERM_PROGRAM' in env) {
    const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

    switch (env.TERM_PROGRAM) {
      case 'iTerm.app':
        return version >= 3 ? 3 : 2;
      case 'Apple_Terminal':
        return 2;
    }
  }

  return /-256(color)?$/i.test(env.TERM)
    ? 2
    : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM) || 'COLORTERM' in env
    ? 1
    // : env.TERM === 'dumb' ? min
    : min;
}

function getSupportLevel(stream) {
  return translateLevel(supportsColor(stream));
}

module.exports = {
  supportsColor: getSupportLevel,
  stdout: getSupportLevel(process.stdout),
  stderr: getSupportLevel(process.stderr)
};
//
},
os:
function(module) {
//
module.exports = require('os');
//
},
'has-flag':
function(module) {
//
module.exports = (flag, argv) => {
  argv = argv || process.argv;
  const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--',
    pos = argv.indexOf(prefix + flag),
    terminatorPos = argv.indexOf('--');
  return pos > -1 && (terminatorPos < 0 || pos < terminatorPos);
};
//
},
'chalk/templates':
function(module) {
//
const TEMPLATE_REGEX =
    /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(})|((?:.|[\r\n\f])+?)/gi,
  STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g,
  STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/,
  ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;

const ESCAPES = new Map([
  ['n', '\n'],
  ['r', '\r'],
  ['t', '\t'],
  ['b', '\b'],
  ['f', '\f'],
  ['v', '\v'],
  ['0', '\0'],
  ['\\', '\\'],
  ['e', '\x1B'],
  ['a', '\x07']
]);

function unescape(c) {
  return (c[0] === 'u' && c.length === 5) || (c[0] === 'x' && c.length === 3)
    ? String.fromCharCode(parseInt(c.slice(1), 16))
    : ESCAPES.get(c) || c;
}

function parseArguments(name, args) {
  const results = [],
    chunks = args.trim().split(/\s*,\s*/g);
  let matches;

  for (const chunk of chunks)
    if (!isNaN(chunk)) results.push(Number(chunk));
    else if ((matches = chunk.match(STRING_REGEX)))
      results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => (escape ? unescape(escape) : chr)));
    else throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);

  return results;
}

function parseStyle(style) {
  STYLE_REGEX.lastIndex = 0;

  const results = [];

  for (let matches; (matches = STYLE_REGEX.exec(style)) !== null; ) {
    const name = matches[1];

    if (matches[2]) {
      const args = parseArguments(name, matches[2]);
      results.push([name].concat(args));
    } else results.push([name]);
  }

  return results;
}

function buildStyle(chalk, styles) {
  const enabled = {};

  for (const layer of styles)
    for (const style of layer.styles) enabled[style[0]] = layer.inverse ? null : style.slice(1);

  let current = chalk;
  for (const styleName of Object.keys(enabled))
    if (Array.isArray(enabled[styleName])) {
      if (!(styleName in current)) throw new Error('Unknown Chalk style: ' + styleName);

      current =
        enabled[styleName].length > 0 ? current[styleName].apply(current, enabled[styleName]) : current[styleName];
    }

  return current;
}

module.exports = (chalk, tmp) => {
  const styles = [],
    chunks = [];
  let chunk = [];

  tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
    if (escapeChar) chunk.push(unescape(escapeChar));
    else if (style) {
      const str = chunk.join('');
      chunk = [];
      chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
      styles.push({inverse, styles: parseStyle(style)});
    } else if (close) {
      if (styles.length === 0) throw new Error('Found extraneous } in Chalk template literal');

      chunks.push(buildStyle(chalk, styles)(chunk.join('')));
      chunk = [];
      styles.pop();
    } else chunk.push(chr);
  });

  chunks.push(chunk.join(''));

  if (styles.length > 0) {
    const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
    throw new Error(errMsg);
  }

  return chunks.join('');
};
//
},
camelcase:
function(module) {
//
function preserveCamelCase(str) {
  for (let isLastCharLower = false, isLastCharUpper = false, isLastLastCharUpper = false, i = 0; i < str.length; i++) {
    const c = str[i];

    if (isLastCharLower && /[a-zA-Z]/.test(c) && c.toUpperCase() === c) {
      str = str.substr(0, i) + '-' + str.substr(i);
      isLastCharLower = false;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = true;
      i++;
    } else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(c) && c.toLowerCase() === c) {
      str = str.substr(0, i - 1) + '-' + str.substr(i - 1);
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = false;
      isLastCharLower = true;
    } else {
      isLastCharLower = c.toLowerCase() === c;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = c.toUpperCase() === c;
    }
  }

  return str;
}

module.exports = function(str) {
  str = arguments.length > 1
    ? Array.from(arguments)
        .map(x => x.trim())
        .filter(x => x.length)
        .join('-')
    : str.trim();

  if (str.length === 0) return '';

  if (str.length === 1) return str.toLowerCase();

  if (/^[a-z0-9]+$/.test(str)) return str;

  if (str !== str.toLowerCase()) str = preserveCamelCase(str);

  return str
    .replace(/^[_.\- ]+/, '')
    .toLowerCase()
    .replace(/[_.\- ]+(\w|$)/g, (m, p1) => p1.toUpperCase());
};
//
},
inquirer:
function(module, exports, __wpreq__) {
//
var inquirer = module.exports;

inquirer.prompts = {};

inquirer.Separator = __wpreq__('inquirer/lib/objects/separator');

inquirer.ui = {
  BottomBar: __wpreq__('inquirer/lib/ui/bottom-bar'),
  Prompt: __wpreq__('inquirer/lib/ui/prompt')
};

inquirer.createPromptModule = function(opt) {
  var promptModule = function(questions) {
    var ui = new inquirer.ui.Prompt(promptModule.prompts, opt),
      promise = ui.run(questions);

    promise.ui = ui;

    return promise;
  };
  promptModule.prompts = {};

  promptModule.registerPrompt = function(name, prompt) {
    promptModule.prompts[name] = prompt;
    return this;
  };

  promptModule.restoreDefaultPrompts = function() {
    this.registerPrompt('list', __wpreq__('inquirer/lib/prompts/list'));
    this.registerPrompt('input', __wpreq__('inquirer/lib/prompts/input'));
    this.registerPrompt('number', __wpreq__('inquirer/lib/prompts/number'));
    this.registerPrompt('confirm', __wpreq__('inquirer/lib/prompts/confirm'));
    this.registerPrompt('rawlist', __wpreq__('inquirer/lib/prompts/rawlist'));
    this.registerPrompt('expand', __wpreq__('inquirer/lib/prompts/expand'));
    this.registerPrompt('checkbox', __wpreq__('inquirer/lib/prompts/checkbox'));
    this.registerPrompt('password', __wpreq__('inquirer/lib/prompts/password'));
    this.registerPrompt('editor', __wpreq__('inquirer/lib/prompts/editor'));
  };

  promptModule.restoreDefaultPrompts();

  return promptModule;
};

inquirer.prompt = inquirer.createPromptModule();

inquirer.registerPrompt = function(name, prompt) {
  inquirer.prompt.registerPrompt(name, prompt);
};
inquirer.restoreDefaultPrompts = function() {
  inquirer.prompt.restoreDefaultPrompts();
};
//
},
'inquirer/lib/objects/separator':
function(module, exports, __wpreq__) {
//
var chalk = __wpreq__('chalk'),
  figures = __wpreq__('figures');

class Separator {
  constructor(line) {
    this.type = 'separator';
    this.line = chalk.dim(line || new Array(15).join(figures.line));
  }

  toString() {
    return this.line;
  }
}

Separator.exclude = function(obj) {
  return obj.type !== 'separator';
};

module.exports = Separator;
//
},
figures:
function(module, exports, __wpreq__) {
//
const escapeStringRegexp = __wpreq__('escape-string-regexp'),

  platform = process.platform;

const main = {
  tick: '',
  cross: '',
  star: '',
  square: '',
  squareSmall: '',
  squareSmallFilled: '',
  play: '',
  circle: '',
  circleFilled: '',
  circleDotted: '',
  circleDouble: '',
  circleCircle: '',
  circleCross: '',
  circlePipe: '',
  circleQuestionMark: '?',
  bullet: '',
  dot: '',
  line: '',
  ellipsis: '',
  pointer: '',
  pointerSmall: '',
  info: '',
  warning: '',
  hamburger: '',
  smiley: '',
  mustache: '',
  heart: '',
  arrowUp: '',
  arrowDown: '',
  arrowLeft: '',
  arrowRight: '',
  radioOn: '',
  radioOff: '',
  checkboxOn: '',
  checkboxOff: '',
  checkboxCircleOn: '',
  checkboxCircleOff: '',
  questionMarkPrefix: '?',
  oneHalf: '',
  oneThird: '',
  oneQuarter: '',
  oneFifth: '',
  oneSixth: '',
  oneSeventh: '',
  oneEighth: '',
  oneNinth: '',
  oneTenth: '',
  twoThirds: '',
  twoFifths: '',
  threeQuarters: '',
  threeFifths: '',
  threeEighths: '',
  fourFifths: '',
  fiveSixths: '',
  fiveEighths: '',
  sevenEighths: ''
};

const win = {
  tick: '',
  cross: '',
  star: '*',
  square: '',
  squareSmall: '[ ]',
  squareSmallFilled: '[]',
  play: '',
  circle: '( )',
  circleFilled: '(*)',
  circleDotted: '( )',
  circleDouble: '( )',
  circleCircle: '()',
  circleCross: '()',
  circlePipe: '()',
  circleQuestionMark: '(?)',
  bullet: '*',
  dot: '.',
  line: '',
  ellipsis: '...',
  pointer: '>',
  pointerSmall: '',
  info: 'i',
  warning: '',
  hamburger: '',
  smiley: '',
  mustache: '',
  heart: main.heart,
  arrowUp: main.arrowUp,
  arrowDown: main.arrowDown,
  arrowLeft: main.arrowLeft,
  arrowRight: main.arrowRight,
  radioOn: '(*)',
  radioOff: '( )',
  checkboxOn: '[]',
  checkboxOff: '[ ]',
  checkboxCircleOn: '()',
  checkboxCircleOff: '( )',
  questionMarkPrefix: '',
  oneHalf: '1/2',
  oneThird: '1/3',
  oneQuarter: '1/4',
  oneFifth: '1/5',
  oneSixth: '1/6',
  oneSeventh: '1/7',
  oneEighth: '1/8',
  oneNinth: '1/9',
  oneTenth: '1/10',
  twoThirds: '2/3',
  twoFifths: '2/5',
  threeQuarters: '3/4',
  threeFifths: '3/5',
  threeEighths: '3/8',
  fourFifths: '4/5',
  fiveSixths: '5/6',
  fiveEighths: '5/8',
  sevenEighths: '7/8'
};

if (platform === 'linux') main.questionMarkPrefix = '?';

const figures = platform === 'win32' ? win : main;

const fn = str => {
  if (figures === main) return str;

  Object.keys(main).forEach(key => {
    if (main[key] !== figures[key])
      str = str.replace(new RegExp(escapeStringRegexp(main[key]), 'g'), figures[key]);
  });

  return str;
};

module.exports = Object.assign(fn, figures);
//
},
'inquirer/lib/ui/bottom-bar':
function(module, exports, __wpreq__) {
//
var through = __wpreq__('through'),
  Base = __wpreq__('inquirer/lib/ui/baseUI'),
  rlUtils = __wpreq__('inquirer/lib/utils/readline'),
  _ = __wpreq__('lodash');

class BottomBar extends Base {
  constructor(opt) {
    super((opt = opt || {}));

    this.log = through(this.writeLog.bind(this));
    this.bottomBar = opt.bottomBar || '';
    this.render();
  }

  render() {
    this.write(this.bottomBar);
    return this;
  }

  clean() {
    rlUtils.clearLine(this.rl, this.bottomBar.split('\n').length);
    return this;
  }

  updateBottomBar(bottomBar) {
    rlUtils.clearLine(this.rl, 1);
    this.rl.output.unmute();
    this.clean();
    this.bottomBar = bottomBar;
    this.render();
    this.rl.output.mute();
    return this;
  }

  writeLog(data) {
    this.rl.output.unmute();
    this.clean();
    this.rl.output.write(this.enforceLF(data.toString()));
    this.render();
    this.rl.output.mute();
    return this;
  }

  enforceLF(str) {
    return str.match(/[\r\n]$/) ? str : str + '\n';
  }

  write(message) {
    var msgLines = message.split(/\n/);
    this.height = msgLines.length;

    this.rl.setPrompt(_.last(msgLines));

    this.rl.output.rows !== 0 || this.rl.output.columns !== 0 ||
      rlUtils.left(this.rl, message.length + this.rl.line.length);

    this.rl.output.write(message);
  }
}

module.exports = BottomBar;
//
},
through:
function(module, exports, __wpreq__) {
//
var Stream = __wpreq__('stream')

/*exports =*/ module.exports = through
through.through = through

function through(write, end, opts) {
  write = write || function(data) { this.queue(data) }
  end = end || function() { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false,
    stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

  stream.autoDestroy = !(opts && opts.autoDestroy === false)

  stream.write = function(data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while (buffer.length && !stream.paused) {
      var data = buffer.shift()
      if (null === data) return stream.emit('end')

      stream.emit('data', data)
    }
  }

  stream.queue = stream.push = function(data) {
    if (_ended) return stream
    if (data === null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  stream.on('end', function() {
    stream.readable = false
    stream.writable || !stream.autoDestroy ||
      process.nextTick(function() {
        stream.destroy()
      })
  })

  function _end() {
    stream.writable = false
    end.call(stream)
    stream.readable || !stream.autoDestroy || stream.destroy()
  }

  stream.end = function(data) {
    if (ended) return
    ended = true
    arguments.length && stream.write(data)
    _end()
    return stream
  }

  stream.destroy = function() {
    if (destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit('close')
    return stream
  }

  stream.pause = function() {
    if (stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function() {
    if (stream.paused) {
      stream.paused = false
      stream.emit('resume')
    }
    drain()
    stream.paused || stream.emit('drain')
    return stream
  }
  return stream
}
//
},
'inquirer/lib/ui/baseUI':
function(module, exports, __wpreq__) {
//
var _ = __wpreq__('lodash'),
  MuteStream = __wpreq__('mute-stream'),
  readline = __wpreq__('readline');

class UI {
  constructor(opt) {
    this.rl || (this.rl = readline.createInterface(setupReadlineOptions(opt)));

    this.rl.resume();

    this.onForceClose = this.onForceClose.bind(this);

    process.on('exit', this.onForceClose);

    this.rl.on('SIGINT', this.onForceClose);
  }

  onForceClose() {
    this.close();
    process.kill(process.pid, 'SIGINT');
    console.log('');
  }

  close() {
    this.rl.removeListener('SIGINT', this.onForceClose);
    process.removeListener('exit', this.onForceClose);

    this.rl.output.unmute();

    this.activePrompt && typeof this.activePrompt.close == 'function' && this.activePrompt.close();

    this.rl.output.end();
    this.rl.pause();
    this.rl.close();
  }
}

function setupReadlineOptions(opt) {
  var input = (opt = opt || {}).input || process.stdin,

    ms = new MuteStream();
  ms.pipe(opt.output || process.stdout);

  return _.extend({terminal: true, input: input, output: ms}, _.omit(opt, ['input', 'output']));
}

module.exports = UI;
//
},
lodash:
function(module, exports, __wpreq__) {
//
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global,
  freeSelf = typeof self == 'object' && self && self.Object === Object && self,
  root = freeGlobal || freeSelf || Function('return this')(),

  Symbol = root.Symbol;

var objectProto = Object.prototype,
  hasOwnProperty = objectProto.hasOwnProperty,
  nativeObjectToString = objectProto.toString,

  symToStringTag = Symbol ? Symbol.toStringTag : void 0;

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
    tag = value[symToStringTag];

  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (_) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) isOwn ? (value[symToStringTag] = tag) : delete value[symToStringTag];

  return result;
}

var nativeObjectToString$1 = Object.prototype.toString;

function objectToString(value) {
  return nativeObjectToString$1.call(value);
}

var nullTag = '[object Null]',
  undefinedTag = '[object Undefined]',

  symToStringTag$1 = Symbol ? Symbol.toStringTag : void 0;

function baseGetTag(value) {
  return value == null
    ? (value === void 0 ? undefinedTag : nullTag)
    : symToStringTag$1 && symToStringTag$1 in Object(value)
    ? getRawTag(value)
    : objectToString(value);
}

function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

var asyncTag = '[object AsyncFunction]',
  funcTag = '[object Function]',
  genTag = '[object GeneratorFunction]',
  proxyTag = '[object Proxy]';

function isFunction(value) {
  if (!isObject(value)) return false;

  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

var coreJsData = root['__core-js_shared__'];

var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec((coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
})();

function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

var funcToString = Function.prototype.toString;

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (_) {}
    try {
      return func + '';
    } catch (_) {}
  }
  return '';
}

var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
  reIsHostCtor = /^\[object .+?Constructor]$/,

  funcProto$1 = Function.prototype,
  objectProto$2 = Object.prototype,

  funcToString$1 = funcProto$1.toString,
  hasOwnProperty$1 = objectProto$2.hasOwnProperty;

var reIsNative = RegExp('^' +
  funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\])/g, '$1.*?') + '$'
);

function baseIsNative(value) {
  return !!isObject(value) && !isMasked(value) && (isFunction(value) ? reIsNative : reIsHostCtor).test(toSource(value));
}

function getValue(object, key) {
  return object == null ? void 0 : object[key];
}

function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (_) {}
})();

function baseAssignValue(object, key, value) {
  key == '__proto__' && defineProperty
    ? defineProperty(object, key, {configurable: true, enumerable: true, value: value, writable: true})
    : (object[key] = value);
}

function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

function assignValue(object, key, value) {
  var objValue = object[key];
  (hasOwnProperty$2.call(object, key) && eq(objValue, value) && (value !== void 0 || key in object)) ||
    baseAssignValue(object, key, value);
}

function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  for (var index = -1, length = props.length; ++index < length; ) {
    var key = props[index],

      newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;

    if (newValue === void 0) newValue = source[key];

    isNew ? baseAssignValue(object, key, newValue) : assignValue(object, key, newValue);
  }
  return object;
}

function identity(value) {
  return value;
}

function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

var nativeMax = Math.max;

function overRest(func, start, transform) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

    for (var index = -1; ++index < length; ) array[index] = args[start + index];

    var otherArgs = Array(start + 1);
    for (index = -1; ++index < start; ) otherArgs[index] = args[index];

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

function constant(value) {
  return function() {
    return value;
  };
}

var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    configurable: true,
    enumerable: false,
    value: constant(string),
    writable: true
  });
};

var HOT_COUNT = 800,
  HOT_SPAN = 16,

  nativeNow = Date.now;

function shortOut(func) {
  var count = 0,
    lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
      remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) return arguments[0];
    } else count = 0;

    return func.apply(void 0, arguments);
  };
}

var setToString = shortOut(baseSetToString);

function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

var MAX_SAFE_INTEGER = 9007199254740991;

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

var MAX_SAFE_INTEGER$1 = 9007199254740991,

  reIsUint = /^(?:0|[1-9]\d*)$/;

function isIndex(value, length) {
  var type = typeof value;

  return (
    !!(length = length == null ? MAX_SAFE_INTEGER$1 : length) &&
    (type == 'number' || (type != 'symbol' && reIsUint.test(value))) &&
    value > -1 && value % 1 == 0 && value < length
  );
}

function isIterateeCall(value, index, object) {
  if (!isObject(object)) return false;

  var type = typeof index;
  return (
    !!(type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) &&
    eq(object[index], value)
  );
}

function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
      length = sources.length,
      customizer = length > 1 ? sources[length - 1] : void 0,
      guard = length > 2 ? sources[2] : void 0;

    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : void 0;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      source && assigner(object, source, index, customizer);
    }
    return object;
  });
}

var objectProto$4 = Object.prototype;

function isPrototype(value) {
  var Ctor = value && value.constructor;

  return value === ((typeof Ctor == 'function' && Ctor.prototype) || objectProto$4);
}

function baseTimes(n, iteratee) {
  var result = Array(n);

  for (var index = -1; ++index < n; ) result[index] = iteratee(index);

  return result;
}

function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

var argsTag = '[object Arguments]';

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

var objectProto$5 = Object.prototype,
  hasOwnProperty$3 = objectProto$5.hasOwnProperty,
  propertyIsEnumerable = objectProto$5.propertyIsEnumerable;

var isArguments = baseIsArguments((function() { return arguments; })()) ? baseIsArguments : function(value) {
  return (
    isObjectLike(value) && hasOwnProperty$3.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee')
  );
};

var isArray = Array.isArray;

function stubFalse() {
  return false;
}

var Buffer = root.Buffer,
  isBuffer = (Buffer ? Buffer.isBuffer : void 0) || stubFalse;

var argsTag$1 = '[object Arguments]',
  arrayTag = '[object Array]',
  boolTag = '[object Boolean]',
  dateTag = '[object Date]',
  errorTag = '[object Error]',
  funcTag$1 = '[object Function]',
  mapTag = '[object Map]',
  numberTag = '[object Number]',
  objectTag = '[object Object]',
  regexpTag = '[object RegExp]',
  setTag = '[object Set]',
  stringTag = '[object String]',
  weakMapTag = '[object WeakMap]',

  arrayBufferTag = '[object ArrayBuffer]',
  dataViewTag = '[object DataView]',
  float32Tag = '[object Float32Array]',
  float64Tag = '[object Float64Array]',
  int8Tag = '[object Int8Array]',
  int16Tag = '[object Int16Array]',
  int32Tag = '[object Int32Array]',
  uint8Tag = '[object Uint8Array]',
  uint8ClampedTag = '[object Uint8ClampedArray]',
  uint16Tag = '[object Uint16Array]',
  uint32Tag = '[object Uint32Array]';

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

var freeProcess = freeGlobal.process;

var nodeUtil = (function() {
  try {
    return __wpreq__('util').types || (freeProcess && freeProcess.binding && freeProcess.binding('util'));
  } catch (_) {}
})();

var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray,
  isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

var hasOwnProperty$4 = Object.prototype.hasOwnProperty;

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
    isArg = !isArr && isArguments(value),
    isBuff = !isArr && !isArg && isBuffer(value),
    isType = !isArr && !isArg && !isBuff && isTypedArray(value),
    skipIndexes = isArr || isArg || isBuff || isType,
    result = skipIndexes ? baseTimes(value.length, String) : [],
    length = result.length;

  for (var key in value)
    (!inherited && !hasOwnProperty$4.call(value, key)) ||
      (skipIndexes &&
        (key == 'length' ||
          (isBuff && (key == 'offset' || key == 'parent')) ||
          (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
          isIndex(key, length))) ||
      result.push(key);

  return result;
}

function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

var nativeKeys = overArg(Object.keys, Object),

  hasOwnProperty$5 = Object.prototype.hasOwnProperty;

function baseKeys(object) {
  if (!isPrototype(object)) return nativeKeys(object);

  var result = [];
  for (var key in Object(object)) hasOwnProperty$5.call(object, key) && key != 'constructor' && result.push(key);

  return result;
}

function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

var hasOwnProperty$6 = Object.prototype.hasOwnProperty;

var assign = createAssigner(function(object, source) {
  if (isPrototype(source) || isArrayLike(source)) copyObject(source, keys(source), object);
  else for (var key in source) hasOwnProperty$6.call(source, key) && assignValue(object, key, source[key]);
});

function nativeKeysIn(object) {
  var result = [];
  if (object != null) for (var key in Object(object)) result.push(key);

  return result;
}

var hasOwnProperty$7 = Object.prototype.hasOwnProperty;

function baseKeysIn(object) {
  if (!isObject(object)) return nativeKeysIn(object);

  var isProto = isPrototype(object),
    result = [];

  for (var key in object)
    (key != 'constructor' || (!isProto && hasOwnProperty$7.call(object, key))) && result.push(key);

  return result;
}

function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

var assignIn = createAssigner(function(object, source) {
  copyObject(source, keysIn(source), object);
});

function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

function assocIndexOf(array, key) {
  for (var length = array.length; length--; ) if (eq(array[length][0], key)) return length;

  return -1;
}

var splice = Array.prototype.splice;

function listCacheDelete(key) {
  var data = this.__data__,
    index = assocIndexOf(data, key);

  if (index < 0) return false;

  index == data.length - 1 ? data.pop() : splice.call(data, index, 1);

  --this.size;
  return true;
}

function listCacheGet(key) {
  var data = this.__data__,
    index = assocIndexOf(data, key);

  return index < 0 ? void 0 : data[index][1];
}

function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

function listCacheSet(key, value) {
  var data = this.__data__,
    index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else data[index][1] = value;

  return this;
}

function ListCache(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

ListCache.prototype.clear = listCacheClear;
ListCache.prototype.delete = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

function stackDelete(key) {
  var data = this.__data__,
    result = data.delete(key);

  this.size = data.size;
  return result;
}

function stackGet(key) {
  return this.__data__.get(key);
}

function stackHas(key) {
  return this.__data__.has(key);
}

var Map = getNative(root, 'Map'),
  nativeCreate = getNative(Object, 'create');

function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

var HASH_UNDEFINED = '__lodash_hash_undefined__',

  hasOwnProperty$8 = Object.prototype.hasOwnProperty;

function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty$8.call(data, key) ? data[key] : void 0;
}

var hasOwnProperty$9 = Object.prototype.hasOwnProperty;

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== void 0 : hasOwnProperty$9.call(data, key);
}

var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}

function Hash(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

Hash.prototype.clear = hashClear;
Hash.prototype.delete = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

function mapCacheClear() {
  this.size = 0;
  this.__data__ = {hash: new Hash(), map: new (Map || ListCache)(), string: new Hash()};
}

function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean'
    ? value !== '__proto__'
    : value === null;
}

function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

function mapCacheDelete(key) {
  var result = getMapData(this, key).delete(key);
  this.size -= result ? 1 : 0;
  return result;
}

function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

function mapCacheSet(key, value) {
  var data = getMapData(this, key),
    size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

function MapCache(entries) {
  var index = -1,
    length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

MapCache.prototype.clear = mapCacheClear;
MapCache.prototype.delete = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

var LARGE_ARRAY_SIZE = 200;

function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

function Stack(entries) {
  var data = (this.__data__ = new ListCache(entries));
  this.size = data.size;
}

Stack.prototype.clear = stackClear;
Stack.prototype.delete = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

function arrayEach(array, iteratee) {
  var index = -1,
    length = array == null ? 0 : array.length;

  while (++index < length && iteratee(array[index], index, array) !== false);

  return array;
}

function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

var Buffer$1 = root.Buffer,
  allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;

function cloneBuffer(buffer, isDeep) {
  if (isDeep) return buffer.slice();

  var length = buffer.length,
    result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

function copyArray(source, array) {
  var index = -1,
    length = source.length;

  array || (array = Array(length));
  while (++index < length) array[index] = source[index];

  return array;
}

function arrayFilter(array, predicate) {
  var resIndex = 0,
    result = [];

  for (var index = -1, length = array == null ? 0 : array.length; ++index < length; ) {
    var value = array[index];
    if (predicate(value, index, array)) result[resIndex++] = value;
  }
  return result;
}

function stubArray() {
  return [];
}

var propertyIsEnumerable$1 = Object.prototype.propertyIsEnumerable,
  nativeGetSymbols = Object.getOwnPropertySymbols;

var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) return [];

  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable$1.call(object, symbol);
  });
};

function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

function arrayPush(array, values) {
  for (var index = -1, length = values.length, offset = array.length; ++index < length; )
    array[offset + index] = values[index];

  return array;
}

var getPrototype = overArg(Object.getPrototypeOf, Object);

var getSymbolsIn = !Object.getOwnPropertySymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

var DataView = getNative(root, 'DataView'),
  Promise = getNative(root, 'Promise'),
  Set = getNative(root, 'Set'),
  WeakMap = getNative(root, 'WeakMap');

var mapTag$1 = '[object Map]',
  objectTag$1 = '[object Object]',
  promiseTag = '[object Promise]',
  setTag$1 = '[object Set]',
  weakMapTag$1 = '[object WeakMap]',

  dataViewTag$1 = '[object DataView]',

  dataViewCtorString = toSource(DataView),
  mapCtorString = toSource(Map),
  promiseCtorString = toSource(Promise),
  setCtorString = toSource(Set),
  weakMapCtorString = toSource(WeakMap);

var getTag = baseGetTag;
if (
  (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$1) ||
  (Map && getTag(new Map()) != mapTag$1) ||
  (Promise && getTag(Promise.resolve()) != promiseTag) ||
  (Set && getTag(new Set()) != setTag$1) ||
  (WeakMap && getTag(new WeakMap()) != weakMapTag$1)
)
  getTag = function(value) {
    var result = baseGetTag(value),
      Ctor = result == objectTag$1 ? value.constructor : void 0,
      ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString)
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag$1;
        case mapCtorString: return mapTag$1;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag$1;
        case weakMapCtorString: return weakMapTag$1;
      }

    return result;
  };
var getTag$1 = getTag;

var hasOwnProperty$a = Object.prototype.hasOwnProperty;

function initCloneArray(array) {
  var length = array.length,
    result = new array.constructor(length);

  if (length && typeof array[0] == 'string' && hasOwnProperty$a.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

var Uint8Array = root.Uint8Array;

function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

var reFlags = /\w*$/;

function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

var symbolProto = Symbol ? Symbol.prototype : void 0,
  symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;

function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

var boolTag$1 = '[object Boolean]',
  dateTag$1 = '[object Date]',
  mapTag$2 = '[object Map]',
  numberTag$1 = '[object Number]',
  regexpTag$1 = '[object RegExp]',
  setTag$2 = '[object Set]',
  stringTag$1 = '[object String]',
  symbolTag = '[object Symbol]',

  arrayBufferTag$1 = '[object ArrayBuffer]',
  dataViewTag$2 = '[object DataView]',
  float32Tag$1 = '[object Float32Array]',
  float64Tag$1 = '[object Float64Array]',
  int8Tag$1 = '[object Int8Array]',
  int16Tag$1 = '[object Int16Array]',
  int32Tag$1 = '[object Int32Array]',
  uint8Tag$1 = '[object Uint8Array]',
  uint8ClampedTag$1 = '[object Uint8ClampedArray]',
  uint16Tag$1 = '[object Uint16Array]',
  uint32Tag$1 = '[object Uint32Array]';

function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object);

    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object);

    case dataViewTag$2:
      return cloneDataView(object, isDeep);

    case float32Tag$1: case float64Tag$1:
    case int8Tag$1: case int16Tag$1: case int32Tag$1:
    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
      return cloneTypedArray(object, isDeep);

    case mapTag$2:
      return new Ctor();

    case numberTag$1:
    case stringTag$1:
      return new Ctor(object);

    case regexpTag$1:
      return cloneRegExp(object);

    case setTag$2:
      return new Ctor();

    case symbolTag:
      return cloneSymbol(object);
  }
}

var objectCreate = Object.create;

var baseCreate = (function() {
  /** @constructor */
  function object() {}
  return function(proto) {
    if (!isObject(proto)) return {};
    if (objectCreate) return objectCreate(proto);

    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
})();

function initCloneObject(object) {
  return typeof object.constructor != 'function' || isPrototype(object) ? {} : baseCreate(getPrototype(object));
}

var mapTag$3 = '[object Map]';

function baseIsMap(value) {
  return isObjectLike(value) && getTag$1(value) == mapTag$3;
}

var nodeIsMap = nodeUtil && nodeUtil.isMap,
  isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap,

  setTag$3 = '[object Set]';

function baseIsSet(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$3;
}

var nodeIsSet = nodeUtil && nodeUtil.isSet,
  isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

var CLONE_DEEP_FLAG = 1,
  CLONE_FLAT_FLAG = 2,
  CLONE_SYMBOLS_FLAG = 4,

  argsTag$2 = '[object Arguments]',
  arrayTag$1 = '[object Array]',
  boolTag$2 = '[object Boolean]',
  dateTag$2 = '[object Date]',
  errorTag$1 = '[object Error]',
  funcTag$2 = '[object Function]',
  genTag$1 = '[object GeneratorFunction]',
  mapTag$4 = '[object Map]',
  numberTag$2 = '[object Number]',
  objectTag$2 = '[object Object]',
  regexpTag$2 = '[object RegExp]',
  setTag$4 = '[object Set]',
  stringTag$2 = '[object String]',
  symbolTag$1 = '[object Symbol]',
  weakMapTag$2 = '[object WeakMap]',

  arrayBufferTag$2 = '[object ArrayBuffer]',
  dataViewTag$3 = '[object DataView]',
  float32Tag$2 = '[object Float32Array]',
  float64Tag$2 = '[object Float64Array]',
  int8Tag$2 = '[object Int8Array]',
  int16Tag$2 = '[object Int16Array]',
  int32Tag$2 = '[object Int32Array]',
  uint8Tag$2 = '[object Uint8Array]',
  uint8ClampedTag$2 = '[object Uint8ClampedArray]',
  uint16Tag$2 = '[object Uint16Array]',
  uint32Tag$2 = '[object Uint32Array]';

var cloneableTags = {};
cloneableTags[argsTag$2] = cloneableTags[arrayTag$1] =
cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] =
cloneableTags[boolTag$2] = cloneableTags[dateTag$2] =
cloneableTags[float32Tag$2] = cloneableTags[float64Tag$2] =
cloneableTags[int8Tag$2] = cloneableTags[int16Tag$2] =
cloneableTags[int32Tag$2] = cloneableTags[mapTag$4] =
cloneableTags[numberTag$2] = cloneableTags[objectTag$2] =
cloneableTags[regexpTag$2] = cloneableTags[setTag$4] =
cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] =
cloneableTags[uint8Tag$2] = cloneableTags[uint8ClampedTag$2] =
cloneableTags[uint16Tag$2] = cloneableTags[uint32Tag$2] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag$2] =
cloneableTags[weakMapTag$2] = false;

function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
    isDeep = bitmask & CLONE_DEEP_FLAG,
    isFlat = bitmask & CLONE_FLAT_FLAG,
    isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) result = object ? customizer(value, key, object, stack) : customizer(value);

  if (result !== void 0) return result;
  if (!isObject(value)) return value;

  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) return copyArray(value, result);
  } else {
    var tag = getTag$1(value),
      isFunc = tag == funcTag$2 || tag == genTag$1;

    if (isBuffer(value)) return cloneBuffer(value, isDeep);

    if (tag == objectTag$2 || tag == argsTag$2 || (isFunc && !object)) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep)
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
    } else {
      if (!cloneableTags[tag]) return object ? value : {};

      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) return stacked;

  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });

    return result;
  }

  if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });

    return result;
  }

  var props = isArr ? void 0 : (isFull ? (isFlat ? getAllKeysIn : getAllKeys) : isFlat ? keysIn : keys)(value);

  arrayEach(props || value, function(subValue, key) {
    if (props) subValue = value[(key = subValue)];

    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

var CLONE_SYMBOLS_FLAG$1 = 4;

function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG$1);
}

var objectProto$e = Object.prototype,
  hasOwnProperty$b = objectProto$e.hasOwnProperty;

var defaults = baseRest(function(object, sources) {
  object = Object(object);

  var index = -1,
    length = sources.length,
    guard = length > 2 ? sources[2] : void 0;

  if (guard && isIterateeCall(sources[0], sources[1], guard)) length = 1;

  while (++index < length)
    for (
      var source = sources[index], props = keysIn(source), propsIndex = -1, propsLength = props.length;
      ++propsIndex < propsLength;
    ) {
      var key = props[propsIndex],
        value = object[key];

      if (value === void 0 || (eq(value, objectProto$e[key]) && !hasOwnProperty$b.call(object, key)))
        object[key] = source[key];
    }

  return object;
});

function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    for (var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length; length--; ) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) break;
    }
    return object;
  };
}

var baseFor = createBaseFor();

function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) return collection;
    if (!isArrayLike(collection)) return eachFunc(collection, iteratee);

    var length = collection.length,
      index = fromRight ? length : -1,
      iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length) && iteratee(iterable[index], index, iterable) !== false);

    return collection;
  };
}

var baseEach = createBaseEach(baseForOwn);

function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function(value, index, collection) {
    predicate(value, index, collection) && result.push(value);
  });
  return result;
}

var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED$2);
  return this;
}

function setCacheHas(value) {
  return this.__data__.has(value);
}

function SetCache(values) {
  var index = -1,
    length = values == null ? 0 : values.length;

  this.__data__ = new MapCache();
  while (++index < length) this.add(values[index]);
}

SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

function arraySome(array, predicate) {
  for (var index = -1, length = array == null ? 0 : array.length; ++index < length; )
    if (predicate(array[index], index, array)) return true;

  return false;
}

function cacheHas(cache, key) {
  return cache.has(key);
}

var COMPARE_PARTIAL_FLAG = 1,
  COMPARE_UNORDERED_FLAG = 2;

function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
    arrLength = array.length,
    othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) return false;

  var stacked = stack.get(array);
  if (stacked && stack.get(other)) return stacked == other;

  var index = -1,
    result = true,
    seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;

  stack.set(array, other);
  stack.set(other, array);

  while (++index < arrLength) {
    const arrValue = array[index],
      othValue = other[index];

    if (customizer)
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);

    if (compared !== void 0) {
      if (compared) continue;

      result = false;
      break;
    }
    if (seen) {
      if (
        !arraySome(other, function(othValue, othIndex) {
          if (!cacheHas(seen, othIndex) &&
              (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack)))
            return seen.push(othIndex);
        })
      ) {
        result = false;
        break;
      }
    } else if (arrValue !== othValue && !equalFunc(arrValue, othValue, bitmask, customizer, stack)) {
      result = false;
      break;
    }
  }
  stack.delete(array);
  stack.delete(other);
  return result;
}

function mapToArray(map) {
  var index = -1,
    result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

function setToArray(set) {
  var index = -1,
    result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

var COMPARE_PARTIAL_FLAG$1 = 1,
  COMPARE_UNORDERED_FLAG$1 = 2,

  boolTag$3 = '[object Boolean]',
  dateTag$3 = '[object Date]',
  errorTag$2 = '[object Error]',
  mapTag$5 = '[object Map]',
  numberTag$3 = '[object Number]',
  regexpTag$3 = '[object RegExp]',
  setTag$5 = '[object Set]',
  stringTag$3 = '[object String]',
  symbolTag$2 = '[object Symbol]',

  arrayBufferTag$3 = '[object ArrayBuffer]',
  dataViewTag$4 = '[object DataView]',

  symbolProto$1 = Symbol ? Symbol.prototype : void 0,
  symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;

function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$4:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return false;

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag$3:
      return !(object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other)));

    case boolTag$3:
    case dateTag$3:
    case numberTag$3:
      return eq(+object, +other);

    case errorTag$2:
      return object.name == other.name && object.message == other.message;

    case regexpTag$3:
    case stringTag$3:
      return object == other + '';

    case mapTag$5:
      var convert = mapToArray;

    case setTag$5:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) return false;

      var stacked = stack.get(object);
      if (stacked) return stacked == other;

      bitmask |= COMPARE_UNORDERED_FLAG$1;

      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack.delete(object);
      return result;

    case symbolTag$2:
      if (symbolValueOf$1) return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
  }
  return false;
}

var COMPARE_PARTIAL_FLAG$2 = 1,

  hasOwnProperty$c = Object.prototype.hasOwnProperty;

function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
    objProps = getAllKeys(object),
    objLength = objProps.length;

  if (objLength != getAllKeys(other).length && !isPartial) return false;

  for (var index = objLength; index--; ) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$c.call(other, key))) return false;
  }
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) return stacked == other;

  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    var objValue = object[(key = objProps[index])],
      othValue = other[key];

    if (customizer)
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);

    if (
      !(compared === void 0
        ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack)
        : compared)
    ) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
      othCtor = other.constructor;

    objCtor == othCtor ||
      !('constructor' in object && 'constructor' in other) ||
      (typeof objCtor == 'function' && objCtor instanceof objCtor &&
        typeof othCtor == 'function' && othCtor instanceof othCtor) ||
      (result = false);
  }
  stack.delete(object);
  stack.delete(other);
  return result;
}

var COMPARE_PARTIAL_FLAG$3 = 1,

  argsTag$3 = '[object Arguments]',
  arrayTag$2 = '[object Array]',
  objectTag$3 = '[object Object]',

  hasOwnProperty$d = Object.prototype.hasOwnProperty;

function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
    othIsArr = isArray(other),
    objTag = objIsArr ? arrayTag$2 : getTag$1(object),
    othTag = othIsArr ? arrayTag$2 : getTag$1(other),

    objIsObj = (objTag = objTag == argsTag$3 ? objectTag$3 : objTag) == objectTag$3,
    othIsObj = (othTag = othTag == argsTag$3 ? objectTag$3 : othTag) == objectTag$3,
    isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) return false;

    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object)
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
    var objIsWrapped = objIsObj && hasOwnProperty$d.call(object, '__wrapped__'),
      othIsWrapped = othIsObj && hasOwnProperty$d.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
        othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) return false;

  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

function baseIsEqual(value, other, bitmask, customizer, stack) {
  return value === other ||
    (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))
      ? value !== value && other !== other
      : baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack));
}

var COMPARE_PARTIAL_FLAG$4 = 1,
  COMPARE_UNORDERED_FLAG$2 = 2;

function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
    length = index,
    noCustomizer = !customizer;

  if (object == null) return !length;

  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return false;
  }
  while (++index < length) {
    var key = (data = matchData[index])[0],
      objValue = object[key],
      srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) return false;
    } else {
      var stack = new Stack();
      if (customizer) var result = customizer(objValue, srcValue, key, object, source, stack);

      if (
        !(result === void 0
          ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack)
          : result)
      )
        return false;
    }
  }
  return true;
}

function isStrictComparable(value) {
  return value === value && !isObject(value);
}

function getMatchData(object) {
  var result = keys(object);

  for (var length = result.length; length--; ) {
    var key = result[length],
      value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

function matchesStrictComparable(key, srcValue) {
  return function(object) {
    return object != null && object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}

function baseMatches(source) {
  var matchData = getMatchData(source);
  return matchData.length == 1 && matchData[0][2]
    ? matchesStrictComparable(matchData[0][0], matchData[0][1])
    : function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
}

var symbolTag$3 = '[object Symbol]';

function isSymbol(value) {
  return typeof value == 'symbol' || (isObjectLike(value) && baseGetTag(value) == symbolTag$3);
}

var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)]/,
  reIsPlainProp = /^\w*$/;

function isKey(value, object) {
  if (isArray(value)) return false;

  var type = typeof value;
  return (
    type == 'number' || type == 'symbol' || type == 'boolean' || value == null || !!isSymbol(value) ||
    reIsPlainProp.test(value) || !reIsDeepProp.test(value) || (object != null && value in Object(object))
  );
}

var FUNC_ERROR_TEXT = 'Expected a function';

function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function'))
    throw new TypeError(FUNC_ERROR_TEXT);

  var memoized = function() {
    var args = arguments,
      key = resolver ? resolver.apply(this, args) : args[0],
      cache = memoized.cache;

    if (cache.has(key)) return cache.get(key);

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}

memoize.Cache = MapCache;

var MAX_MEMOIZE_SIZE = 500;

function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    cache.size !== MAX_MEMOIZE_SIZE || cache.clear();
    return key;
  });

  var cache = result.cache;
  return result;
}

var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)]|(?=(?:\.|\[])(?:\.|\[]|$))/g,
  reEscapeChar = /\\(\\)?/g;

var stringToPath = memoizeCapped(function(string) {
  var result = [];
  string.charCodeAt(0) !== 46 || result.push('');

  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});

function arrayMap(array, iteratee) {
  var index = -1,
    length = array == null ? 0 : array.length,
    result = Array(length);

  while (++index < length) result[index] = iteratee(array[index], index, array);

  return result;
}

var INFINITY = 1 / 0,

  symbolProto$2 = Symbol ? Symbol.prototype : void 0,
  symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;

function baseToString(value) {
  if (typeof value == 'string') return value;
  if (isArray(value)) return arrayMap(value, baseToString) + '';
  if (isSymbol(value)) return symbolToString ? symbolToString.call(value) : '';

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

function toString(value) {
  return value == null ? '' : baseToString(value);
}

function castPath(value, object) {
  return isArray(value) ? value : isKey(value, object) ? [value] : stringToPath(toString(value));
}

var INFINITY$1 = 1 / 0;

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) return value;

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
}

function baseGet(object, path) {
  var index = 0,
    length = (path = castPath(path, object)).length;

  while (object != null && index < length) object = object[toKey(path[index++])];

  return index && index == length ? object : void 0;
}

function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet(object, path);
  return result === void 0 ? defaultValue : result;
}

function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

function hasPath(object, path, hasFunc) {
  var index = -1,
    length = (path = castPath(path, object)).length,
    result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) break;

    object = object[key];
  }

  return result || ++index != length
    ? result
    : !!(length = object == null ? 0 : object.length) && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
}

function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

var COMPARE_PARTIAL_FLAG$5 = 1,
  COMPARE_UNORDERED_FLAG$3 = 2;

function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) return matchesStrictComparable(toKey(path), srcValue);

  return function(object) {
    var objValue = get(object, path);
    return objValue === void 0 && objValue === srcValue
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
  };
}

function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}

function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

function baseIteratee(value) {
  return typeof value == 'function'
    ? value
    : value == null
    ? identity
    : typeof value == 'object'
    ? isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value)
    : property(value);
}

function filter(collection, predicate) {
  return (isArray(collection) ? arrayFilter : baseFilter)(collection, baseIteratee(predicate));
}

function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate);
      collection = keys(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;
  };
}

function baseFindIndex(array, predicate, fromIndex, fromRight) {
  for (var length = array.length, index = fromIndex + (fromRight ? 1 : -1); fromRight ? index-- : ++index < length; )
    if (predicate(array[index], index, array)) return index;

  return -1;
}

var NAN = 0 / 0,

  reTrim = /^\s+|\s+$/g,
  reIsBadHex = /^[-+]0x[0-9a-f]+$/i,
  reIsBinary = /^0b[01]+$/i,
  reIsOctal = /^0o[0-7]+$/i,

  freeParseInt = parseInt;

function toNumber(value) {
  if (typeof value == 'number') return value;
  if (isSymbol(value)) return NAN;

  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }
  if (typeof value != 'string') return value === 0 ? value : +value;

  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value)
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : reIsBadHex.test(value) ? NAN : +value;
}

var INFINITY$2 = 1 / 0,
  MAX_INTEGER = 1.7976931348623157e308;

function toFinite(value) {
  return !value
    ? (value === 0 ? value : 0)
    : (value = toNumber(value)) === INFINITY$2 || value === -INFINITY$2
    ? (value < 0 ? -1 : 1) * MAX_INTEGER
    : value === value ? value : 0;
}

function toInteger(value) {
  var result = toFinite(value),
    remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

var nativeMax$1 = Math.max;

function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) return -1;

  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) index = nativeMax$1(length + index, 0);

  return baseFindIndex(array, baseIteratee(predicate), index);
}

var find = createFind(findIndex),

  spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : void 0;

function isFlattenable(value) {
  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}

function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
    length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    depth > 0 && predicate(value)
      ? depth > 1
        ? baseFlatten(value, depth - 1, predicate, isStrict, result)
        : arrayPush(result, value)
      : isStrict || (result[result.length] = value);
  }
  return result;
}

function flatten(array) {
  return array != null && array.length ? baseFlatten(array, 1) : [];
}

var boolTag$4 = '[object Boolean]';

function isBoolean(value) {
  return value === true || value === false || (isObjectLike(value) && baseGetTag(value) == boolTag$4);
}

var numberTag$4 = '[object Number]';

function isNumber(value) {
  return typeof value == 'number' || (isObjectLike(value) && baseGetTag(value) == numberTag$4);
}

var objectTag$4 = '[object Object]',

  funcProto$2 = Function.prototype,
  objectProto$h = Object.prototype,
  funcToString$2 = funcProto$2.toString,
  hasOwnProperty$e = objectProto$h.hasOwnProperty,

  objectCtorString = funcToString$2.call(Object);

function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$4) return false;

  var proto = getPrototype(value);
  if (proto === null) return true;

  var Ctor = hasOwnProperty$e.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
}

var stringTag$4 = '[object String]';

function isString(value) {
  return typeof value == 'string' || (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag$4);
}

function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}

function baseMap(collection, iteratee) {
  var index = -1,
    result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

function map(collection, iteratee) {
  return (isArray(collection) ? arrayMap : baseMap)(collection, baseIteratee(iteratee));
}

function noop() {}

function baseSlice(array, start, end) {
  var index = -1,
    length = array.length;

  if (start < 0) start = -start > length ? 0 : length + start;
  if ((end = end > length ? length : end) < 0) end += length;

  length = start > end ? 0 : (end - start) >>> 0;
  start >>>= 0;

  var result = Array(length);
  while (++index < length) result[index] = array[index + start];
  return result;
}

function parent(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}

function baseUnset(object, path) {
  return (object = parent(object, (path = castPath(path, object)))) == null || delete object[toKey(last(path))];
}

function customOmitClone(value) {
  return isPlainObject(value) ? void 0 : value;
}

function flatRest(func) {
  return setToString(overRest(func, void 0, flatten), func + '');
}

var CLONE_DEEP_FLAG$1 = 1,
  CLONE_FLAT_FLAG$1 = 2,
  CLONE_SYMBOLS_FLAG$2 = 4;

var omit = flatRest(function(object, paths) {
  var result = {};
  if (object == null) return result;

  var isDeep = false;
  paths = arrayMap(paths, function(path) {
    path = castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn(object), result);
  if (isDeep)
    result = baseClone(result, CLONE_DEEP_FLAG$1 | CLONE_FLAT_FLAG$1 | CLONE_SYMBOLS_FLAG$2, customOmitClone);

  for (var length = paths.length; length--; ) baseUnset(result, paths[length]);
  return result;
});

function baseSet(object, path, value, customizer) {
  if (!isObject(object)) return object;

  var index = -1,
    length = (path = castPath(path, object)).length,
    lastIndex = length - 1,
    nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
      newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      if ((newValue = customizer ? customizer(objValue, key, nested) : void 0) === void 0)
        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

function baseSum(array, iteratee) {
  var result = void 0;

  for (var index = -1, length = array.length; ++index < length; ) {
    var current = iteratee(array[index]);
    if (current !== void 0) result = result === void 0 ? current : result + current;
  }
  return result;
}

function sum(array) {
  return array && array.length ? baseSum(array, identity) : 0;
}

function iteratorToArray(iterator) {
  var result = [];

  for (var data; !(data = iterator.next()).done; ) result.push(data.value);

  return result;
}

function asciiToArray(string) {
  return string.split('');
}

var reHasUnicode = RegExp('[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]');

function hasUnicode(string) {
  return reHasUnicode.test(string);
}

var rsAstralRange$1 = '\\ud800-\\udfff',

  rsAstral = '[' + rsAstralRange$1 + ']',
  rsCombo = '[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]',
  rsFitz = '\\ud83c[\\udffb-\\udfff]',
  rsNonAstral = '[^' + rsAstralRange$1 + ']',
  rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
  rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',

  reOptMod = '(?:' + rsCombo + '|' + rsFitz + ')?',
  rsOptVar = '[\\ufe0e\\ufe0f]?',
  rsOptJoin = '(?:\\u200d(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
  rsSeq = rsOptVar + reOptMod + rsOptJoin,
  rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')',

  reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

function stringToArray(string) {
  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
}

function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

var mapTag$6 = '[object Map]',
  setTag$6 = '[object Set]',

  symIterator = Symbol ? Symbol.iterator : void 0;

function toArray(value) {
  if (!value) return [];
  if (isArrayLike(value)) return isString(value) ? stringToArray(value) : copyArray(value);
  if (symIterator && value[symIterator]) return iteratorToArray(value[symIterator]());

  var tag = getTag$1(value);
  return (tag == mapTag$6 ? mapToArray : tag == setTag$6 ? setToArray : values)(value);
}

function baseIsNaN(value) {
  return value !== value;
}

function strictIndexOf(array, value, fromIndex) {
  for (var index = fromIndex - 1, length = array.length; ++index < length; )
    if (array[index] === value) return index;

  return -1;
}

function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
}

function arrayIncludes(array, value) {
  return array != null && !!array.length && baseIndexOf(array, value, 0) > -1;
}

function arrayIncludesWith(array, value, comparator) {
  for (var index = -1, length = array == null ? 0 : array.length; ++index < length; )
    if (comparator(value, array[index])) return true;

  return false;
}

var INFINITY$3 = 1 / 0;

var createSet = !Set || 1 / setToArray(new Set([void 0, -0]))[1] != INFINITY$3 ? noop : function(values) {
  return new Set(values);
};

var LARGE_ARRAY_SIZE$1 = 200;

function baseUniq(array, iteratee, comparator) {
  var index = -1,
    includes = arrayIncludes,
    length = array.length,
    isCommon = true,
    result = [],
    seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE$1) {
    var set = iteratee ? null : createSet(array);
    if (set) return setToArray(set);

    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else seen = iteratee ? [] : result;

  outer: while (++index < length) {
    var value = array[index],
      computed = iteratee ? iteratee(value) : value;

    value = comparator || value !== 0 ? value : 0;
    if (isCommon && computed === computed) {
      for (var seenIndex = seen.length; seenIndex--; ) if (seen[seenIndex] === computed) continue outer;

      iteratee && seen.push(computed);

      result.push(value);
    } else if (!includes(seen, computed, comparator)) {
      seen === result || seen.push(computed);

      result.push(value);
    }
  }
  return result;
}

function uniq(array) {
  return array && array.length ? baseUniq(array) : [];
}

exports.assign = assign;
exports.assignIn = assignIn;
exports.clone = clone;
exports.constant = constant;
exports.defaults = defaults;
exports.eq = eq;
exports.extend = assignIn;
exports.filter = filter;
exports.find = find;
exports.findIndex = findIndex;
exports.flatten = flatten;
exports.get = get;
exports.hasIn = hasIn;
exports.identity = identity;
exports.isArguments = isArguments;
exports.isArray = isArray;
exports.isArrayLike = isArrayLike;
exports.isBoolean = isBoolean;
exports.isBuffer = isBuffer;
exports.isFunction = isFunction;
exports.isLength = isLength;
exports.isMap = isMap;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isObjectLike = isObjectLike;
exports.isPlainObject = isPlainObject;
exports.isSet = isSet;
exports.isString = isString;
exports.isSymbol = isSymbol;
exports.isTypedArray = isTypedArray;
exports.keys = keys;
exports.keysIn = keysIn;
exports.last = last;
exports.map = map;
exports.memoize = memoize;
exports.noop = noop;
exports.omit = omit;
exports.property = property;
exports.set = set;
exports.stubArray = stubArray;
exports.stubFalse = stubFalse;
exports.sum = sum;
exports.toArray = toArray;
exports.toFinite = toFinite;
exports.toInteger = toInteger;
exports.toNumber = toNumber;
exports.toString = toString;
exports.uniq = uniq;
exports.values = values;
//
},
'mute-stream':
function(module, exports, __wpreq__) {
//
var Stream = __wpreq__('stream')

module.exports = MuteStream

function MuteStream(opts) {
  Stream.apply(this)
  opts = opts || {}
  this.writable = this.readable = true
  this.muted = false
  this.on('pipe', this._onpipe)
  this.replace = opts.replace

  this._prompt = opts.prompt || null
  this._hadControl = false
}

MuteStream.prototype = Object.create(Stream.prototype)

Object.defineProperty(MuteStream.prototype, 'constructor', {value: MuteStream, enumerable: false})

MuteStream.prototype.mute = function() {
  this.muted = true
}

MuteStream.prototype.unmute = function() {
  this.muted = false
}

Object.defineProperty(MuteStream.prototype, '_onpipe', {
  value: onPipe,
  enumerable: false,
  writable: true,
  configurable: true
})

function onPipe(src) {
  this._src = src
}

Object.defineProperty(MuteStream.prototype, 'isTTY', {
  get: getIsTTY,
  set: setIsTTY,
  enumerable: true,
  configurable: true
})

function getIsTTY() {
  return this._dest ? this._dest.isTTY : !!this._src && this._src.isTTY
}

function setIsTTY(isTTY) {
  Object.defineProperty(this, 'isTTY', {value: isTTY, enumerable: true, writable: true, configurable: true})
}

Object.defineProperty(MuteStream.prototype, 'rows', {
  get: function() {
    return this._dest ? this._dest.rows : this._src ? this._src.rows : void 0
  },
  enumerable: true,
  configurable: true
})

Object.defineProperty(MuteStream.prototype, 'columns', {
  get: function() {
    return this._dest ? this._dest.columns : this._src ? this._src.columns : void 0
  },
  enumerable: true,
  configurable: true
})

MuteStream.prototype.pipe = function(dest, options) {
  this._dest = dest
  return Stream.prototype.pipe.call(this, dest, options)
}

MuteStream.prototype.pause = function() {
  if (this._src) return this._src.pause()
}

MuteStream.prototype.resume = function() {
  if (this._src) return this._src.resume()
}

MuteStream.prototype.write = function(c) {
  if (this.muted) {
    if (!this.replace) return true
    if (c.match(/^\u001b/)) {
      if (c.indexOf(this._prompt) === 0) {
        c = (c = c.substr(this._prompt.length)).replace(/./g, this.replace);
        c = this._prompt + c;
      }
      this._hadControl = true
      return this.emit('data', c)
    }

    if (this._prompt && this._hadControl && c.indexOf(this._prompt) === 0) {
      this._hadControl = false
      this.emit('data', this._prompt)
      c = c.substr(this._prompt.length)
    }
    c = c.toString().replace(/./g, this.replace)
  }
  this.emit('data', c)
}

MuteStream.prototype.end = function(c) {
  if (this.muted) c = c && this.replace ? c.toString().replace(/./g, this.replace) : null

  c && this.emit('data', c)
  this.emit('end')
}

function proxy(fn) {
  return function() {
    var d = this._dest,
      s = this._src
    d && d[fn] && d[fn].apply(d, arguments)
    s && s[fn] && s[fn].apply(s, arguments)
  }
}

MuteStream.prototype.destroy = proxy('destroy')
MuteStream.prototype.destroySoon = proxy('destroySoon')
MuteStream.prototype.close = proxy('close')
//
},
readline:
function(module) {
//
module.exports = require('readline');
//
},
'inquirer/lib/utils/readline':
function(module, exports, __wpreq__) {
//
var ansiEscapes = __wpreq__('ansi-escapes');

exports.left = function(rl, x) {
  rl.output.write(ansiEscapes.cursorBackward(x));
};

exports.right = function(rl, x) {
  rl.output.write(ansiEscapes.cursorForward(x));
};

exports.up = function(rl, x) {
  rl.output.write(ansiEscapes.cursorUp(x));
};

exports.down = function(rl, x) {
  rl.output.write(ansiEscapes.cursorDown(x));
};

exports.clearLine = function(rl, len) {
  rl.output.write(ansiEscapes.eraseLines(len));
};
//
},
'ansi-escapes':
function(module) {
//
const x = module.exports,
  ESC = '\x1B[',
  OSC = '\x1B]',
  BEL = '\x07',
  SEP = ';',
  isTerminalApp = process.env.TERM_PROGRAM === 'Apple_Terminal';

x.cursorTo = (x, y) => {
  if (typeof x != 'number') throw new TypeError('The `x` argument is required');

  return typeof y != 'number' ? ESC + (x + 1) + 'G' : ESC + (y + 1) + ';' + (x + 1) + 'H';
};

x.cursorMove = (x, y) => {
  if (typeof x != 'number') throw new TypeError('The `x` argument is required');

  let ret = '';

  if (x < 0) ret += ESC + -x + 'D';
  else if (x > 0) ret += ESC + x + 'C';

  if (y < 0) ret += ESC + -y + 'A';
  else if (y > 0) ret += ESC + y + 'B';

  return ret;
};

x.cursorUp = count => ESC + (typeof count == 'number' ? count : 1) + 'A';
x.cursorDown = count => ESC + (typeof count == 'number' ? count : 1) + 'B';
x.cursorForward = count => ESC + (typeof count == 'number' ? count : 1) + 'C';
x.cursorBackward = count => ESC + (typeof count == 'number' ? count : 1) + 'D';

x.cursorLeft = ESC + 'G';
x.cursorSavePosition = ESC + (isTerminalApp ? '7' : 's');
x.cursorRestorePosition = ESC + (isTerminalApp ? '8' : 'u');
x.cursorGetPosition = ESC + '6n';
x.cursorNextLine = ESC + 'E';
x.cursorPrevLine = ESC + 'F';
x.cursorHide = ESC + '?25l';
x.cursorShow = ESC + '?25h';

x.eraseLines = count => {
  let clear = '';

  for (let i = 0; i < count; i++) clear += x.eraseLine + (i < count - 1 ? x.cursorUp() : '');

  if (count) clear += x.cursorLeft;

  return clear;
};

x.eraseEndLine = ESC + 'K';
x.eraseStartLine = ESC + '1K';
x.eraseLine = ESC + '2K';
x.eraseDown = ESC + 'J';
x.eraseUp = ESC + '1J';
x.eraseScreen = ESC + '2J';
x.scrollUp = ESC + 'S';
x.scrollDown = ESC + 'T';

x.clearScreen = '\x1Bc';
x.beep = BEL;

x.link = (text, url) => [OSC, '8', SEP, SEP, url, BEL, text, OSC, '8', SEP, SEP, BEL].join('');

x.image = (buf, opts) => {
  let ret = OSC + '1337;File=inline=1';

  if ((opts = opts || {}).width) ret += ';width=' + opts.width;

  if (opts.height) ret += ';height=' + opts.height;

  if (opts.preserveAspectRatio === false) ret += ';preserveAspectRatio=0';

  return ret + ':' + buf.toString('base64') + BEL;
};

x.iTerm = {};

x.iTerm.setCwd = cwd => OSC + '50;CurrentDir=' + (cwd || process.cwd()) + BEL;
//
},
'inquirer/lib/ui/prompt':
function(module, exports, __wpreq__) {
//
var _ = __wpreq__('lodash'),
  _rxjs = __wpreq__('rxjs'), defer = _rxjs.defer, empty = _rxjs.empty, from = _rxjs.from, of = _rxjs.of,
  _rxjsOp = __wpreq__('rxjs/operators'),
  concatMap = _rxjsOp.concatMap, filter = _rxjsOp.filter, publish = _rxjsOp.publish, reduce = _rxjsOp.reduce,
  runAsync = __wpreq__('run-async'),
  utils = __wpreq__('inquirer/lib/utils/utils'),
  Base = __wpreq__('inquirer/lib/ui/baseUI');

class PromptUI extends Base {
  constructor(prompts, opt) {
    super(opt);
    this.prompts = prompts;
  }

  run(questions) {
    this.answers = {};

    if (_.isPlainObject(questions)) questions = [questions];

    var obs = _.isArray(questions) ? from(questions) : questions;

    this.process = obs.pipe(concatMap(this.processQuestion.bind(this)), publish());

    this.process.connect();

    return this.process
      .pipe(
        reduce((answers, answer) => {
          _.set(this.answers, answer.name, answer.answer);
          return this.answers;
        }, {})
      )
      .toPromise(Promise)
      .then(this.onCompletion.bind(this));
  }

  onCompletion() {
    this.close();

    return this.answers;
  }

  processQuestion(question) {
    question = _.clone(question);
    return defer(() =>
      of(question).pipe(
        concatMap(this.setDefaultType.bind(this)),
        concatMap(this.filterIfRunnable.bind(this)),
        concatMap(() => utils.fetchAsyncQuestionProperty(question, 'message', this.answers)),
        concatMap(() => utils.fetchAsyncQuestionProperty(question, 'default', this.answers)),
        concatMap(() => utils.fetchAsyncQuestionProperty(question, 'choices', this.answers)),
        concatMap(this.fetchAnswer.bind(this))
      )
    );
  }

  fetchAnswer(question) {
    var Prompt = this.prompts[question.type];
    this.activePrompt = new Prompt(question, this.rl, this.answers);
    return defer(() => from(this.activePrompt.run().then(answer => ({name: question.name, answer: answer}))));
  }

  setDefaultType(question) {
    this.prompts[question.type] || (question.type = 'input');

    return defer(() => of(question));
  }

  filterIfRunnable(question) {
    if (question.when === false) return empty();
    if (!_.isFunction(question.when)) return of(question);

    var answers = this.answers;
    return defer(() =>
      from(
        runAsync(question.when)(answers).then(shouldRun => {
          if (shouldRun) return question;
        })
      ).pipe(filter(val => val != null))
    );
  }
}

module.exports = PromptUI;
//
},
rxjs:
function(module, exports) {
//
Object.defineProperty(exports, '__esModule', {value: true});

function isFunction(x) {
  return typeof x == 'function';
}

let _enable_super_gross_mode_that_will_cause_bad_things = false;
const config = {
  Promise: void 0,
  set useDeprecatedSynchronousErrorHandling(value) {
    if (value) {
      const error = new Error();
      console.warn(
        'DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack
      );
    } else _enable_super_gross_mode_that_will_cause_bad_things &&
      console.log('RxJS: Back to a better error behavior. Thank you. <3');

    _enable_super_gross_mode_that_will_cause_bad_things = value;
  },
  get useDeprecatedSynchronousErrorHandling() {
    return _enable_super_gross_mode_that_will_cause_bad_things;
  }
};

function hostReportError(err) {
  setTimeout(() => { throw err; });
}

const empty = {
  closed: true,
  next(value) {},
  error(err) {
    if (config.useDeprecatedSynchronousErrorHandling) throw err;

    hostReportError(err);
  },
  complete() {}
};

const isArray = Array.isArray || (x => x && typeof x.length == 'number');

function isObject(x) {
  return x != null && typeof x == 'object';
}

const errorObject = {e: {}};

let tryCatchTarget;
function tryCatcher() {
  try {
    return tryCatchTarget.apply(this, arguments);
  } catch (e) {
    errorObject.e = e;
    return errorObject;
  }
}
function tryCatch(fn) {
  tryCatchTarget = fn;
  return tryCatcher;
}

function UnsubscriptionErrorImpl(errors) {
  Error.call(this);
  this.message = errors
    ? `${errors.length} errors occurred during unsubscription:
${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\n  ')}`
    : '';
  this.name = 'UnsubscriptionError';
  this.errors = errors;
  return this;
}
UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);
const UnsubscriptionError = UnsubscriptionErrorImpl;

class Subscription {
  constructor(unsubscribe) {
    this.closed = false;
    this._parent = null;
    this._parents = null;
    this._subscriptions = null;
    if (unsubscribe) this._unsubscribe = unsubscribe;
  }
  unsubscribe() {
    let errors,
      hasErrors = false;
    if (this.closed) return;

    let _parent = this._parent, _parents = this._parents,
      _unsubscribe = this._unsubscribe, _subscriptions = this._subscriptions;
    this.closed = true;
    this._parent = null;
    this._parents = null;
    this._subscriptions = null;
    let index = -1,
      len = _parents ? _parents.length : 0;
    while (_parent) {
      _parent.remove(this);
      _parent = (++index < len && _parents[index]) || null;
    }
    if (isFunction(_unsubscribe) && tryCatch(_unsubscribe).call(this) === errorObject) {
      hasErrors = true;
      errors = errors || (errorObject.e instanceof UnsubscriptionError
        ? flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]);
    }
    if (isArray(_subscriptions)) {
      index = -1;
      len = _subscriptions.length;
      while (++index < len) {
        const sub = _subscriptions[index];
        if (isObject(sub) && tryCatch(sub.unsubscribe).call(sub) === errorObject) {
          hasErrors = true;
          errors = errors || [];
          let err = errorObject.e;
          err instanceof UnsubscriptionError
            ? (errors = errors.concat(flattenUnsubscriptionErrors(err.errors)))
            : errors.push(err);
        }
      }
    }
    if (hasErrors) throw new UnsubscriptionError(errors);
  }
  add(teardown) {
    if (!teardown || teardown === Subscription.EMPTY) return Subscription.EMPTY;
    if (teardown === this) return this;

    let subscription = teardown;
    switch (typeof teardown) {
      case 'function':
        subscription = new Subscription(teardown);
      case 'object':
        if (subscription.closed || typeof subscription.unsubscribe != 'function') return subscription;

        if (this.closed) {
          subscription.unsubscribe();
          return subscription;
        }
        if (typeof subscription._addParent != 'function') {
          const tmp = subscription;
          subscription = new Subscription();
          subscription._subscriptions = [tmp];
        }
        break;
      default:
        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
    }
    (this._subscriptions || (this._subscriptions = [])).push(subscription);
    subscription._addParent(this);
    return subscription;
  }
  remove(subscription) {
    const subscriptions = this._subscriptions;
    if (subscriptions) {
      const subscriptionIndex = subscriptions.indexOf(subscription);
      subscriptionIndex < 0 || subscriptions.splice(subscriptionIndex, 1);
    }
  }
  _addParent(parent) {
    let _parent = this._parent, _parents = this._parents;
    !_parent || _parent === parent
      ? (this._parent = parent)
      : _parents
      ? _parents.indexOf(parent) < 0 && _parents.push(parent)
      : (this._parents = [parent]);
  }
}
Subscription.EMPTY = (function(empty) {
  empty.closed = true;
  return empty;
})(new Subscription());
function flattenUnsubscriptionErrors(errors) {
  return errors.reduce((errs, err) => errs.concat(err instanceof UnsubscriptionError ? err.errors : err), []);
}

const rxSubscriber = typeof Symbol == 'function' ? Symbol('rxSubscriber') : '@@rxSubscriber_' + Math.random();

class Subscriber extends Subscription {
  constructor(destinationOrNext, error, complete) {
    super();
    this.syncErrorValue = null;
    this.syncErrorThrown = false;
    this.syncErrorThrowable = false;
    this.isStopped = false;
    this._parentSubscription = null;
    switch (arguments.length) {
      case 0:
        this.destination = empty;
        break;
      case 1:
        if (!destinationOrNext) {
          this.destination = empty;
          break;
        }
        if (typeof destinationOrNext == 'object') {
          if (destinationOrNext instanceof Subscriber) {
            this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
            this.destination = destinationOrNext;
            destinationOrNext.add(this);
          } else {
            this.syncErrorThrowable = true;
            this.destination = new SafeSubscriber(this, destinationOrNext);
          }
          break;
        }
      default:
        this.syncErrorThrowable = true;
        this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
        break;
    }
  }
  [rxSubscriber]() { return this; }
  static create(next, error, complete) {
    const subscriber = new Subscriber(next, error, complete);
    subscriber.syncErrorThrowable = false;
    return subscriber;
  }
  next(value) {
    this.isStopped || this._next(value);
  }
  error(err) {
    if (!this.isStopped) {
      this.isStopped = true;
      this._error(err);
    }
  }
  complete() {
    if (!this.isStopped) {
      this.isStopped = true;
      this._complete();
    }
  }
  unsubscribe() {
    if (this.closed) return;

    this.isStopped = true;
    super.unsubscribe();
  }
  _next(value) {
    this.destination.next(value);
  }
  _error(err) {
    this.destination.error(err);
    this.unsubscribe();
  }
  _complete() {
    this.destination.complete();
    this.unsubscribe();
  }
  _unsubscribeAndRecycle() {
    const _parent = this._parent, _parents = this._parents;
    this._parent = null;
    this._parents = null;
    this.unsubscribe();
    this.closed = false;
    this.isStopped = false;
    this._parent = _parent;
    this._parents = _parents;
    this._parentSubscription = null;
    return this;
  }
}
class SafeSubscriber extends Subscriber {
  constructor(_parentSubscriber, observerOrNext, error, complete) {
    super();
    this._parentSubscriber = _parentSubscriber;
    let next,
      context = this;
    if (isFunction(observerOrNext)) next = observerOrNext;
    else if (observerOrNext) {
      next = observerOrNext.next;
      error = observerOrNext.error;
      complete = observerOrNext.complete;
      if (observerOrNext !== empty) {
        context = Object.create(observerOrNext);
        isFunction(context.unsubscribe) && this.add(context.unsubscribe.bind(context));

        context.unsubscribe = this.unsubscribe.bind(this);
      }
    }
    this._context = context;
    this._next = next;
    this._error = error;
    this._complete = complete;
  }
  next(value) {
    if (!this.isStopped && this._next) {
      const _parentSubscriber = this._parentSubscriber;
      config.useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable
        ? this.__tryOrSetError(_parentSubscriber, this._next, value) && this.unsubscribe()
        : this.__tryOrUnsub(this._next, value);
    }
  }
  error(err) {
    if (!this.isStopped) {
      const _parentSubscriber = this._parentSubscriber,
        useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
      if (this._error)
        if (useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable) {
          this.__tryOrSetError(_parentSubscriber, this._error, err);
          this.unsubscribe();
        } else {
          this.__tryOrUnsub(this._error, err);
          this.unsubscribe();
        }
      else if (_parentSubscriber.syncErrorThrowable) {
        if (useDeprecatedSynchronousErrorHandling) {
          _parentSubscriber.syncErrorValue = err;
          _parentSubscriber.syncErrorThrown = true;
        } else hostReportError(err);

        this.unsubscribe();
      } else {
        this.unsubscribe();
        if (useDeprecatedSynchronousErrorHandling) throw err;

        hostReportError(err);
      }
    }
  }
  complete() {
    if (!this.isStopped) {
      const _parentSubscriber = this._parentSubscriber;
      if (this._complete) {
        const wrappedComplete = () => this._complete.call(this._context);
        if (config.useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable) {
          this.__tryOrSetError(_parentSubscriber, wrappedComplete);
          this.unsubscribe();
        } else {
          this.__tryOrUnsub(wrappedComplete);
          this.unsubscribe();
        }
      } else this.unsubscribe();
    }
  }
  __tryOrUnsub(fn, value) {
    try {
      fn.call(this._context, value);
    } catch (err) {
      this.unsubscribe();
      if (config.useDeprecatedSynchronousErrorHandling) throw err;

      hostReportError(err);
    }
  }
  __tryOrSetError(parent, fn, value) {
    if (!config.useDeprecatedSynchronousErrorHandling) throw new Error('bad call');

    try {
      fn.call(this._context, value);
    } catch (err) {
      if (config.useDeprecatedSynchronousErrorHandling) {
        parent.syncErrorValue = err;
        parent.syncErrorThrown = true;
        return true;
      }

      hostReportError(err);
      return true;
    }
    return false;
  }
  _unsubscribe() {
    const _parentSubscriber = this._parentSubscriber;
    this._context = null;
    this._parentSubscriber = null;
    _parentSubscriber.unsubscribe();
  }
}

function canReportError(observer) {
  while (observer) {
    const closed = observer.closed, destination = observer.destination, isStopped = observer.isStopped;
    if (closed || isStopped) return false;

    observer = destination && destination instanceof Subscriber ? destination : null;
  }
  return true;
}

function toSubscriber(nextOrObserver, error, complete) {
  if (nextOrObserver) {
    if (nextOrObserver instanceof Subscriber) return nextOrObserver;
    if (nextOrObserver[rxSubscriber]) return nextOrObserver[rxSubscriber]();
  }
  return nextOrObserver || error || complete
    ? new Subscriber(nextOrObserver, error, complete)
    : new Subscriber(empty);
}

const observable = (typeof Symbol == 'function' && Symbol.observable) || '@@observable';

function noop() {}

function pipe() {
  var fns = Array.prototype.slice.call(arguments, 0);
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  return !fns
    ? noop
    : fns.length === 1
    ? fns[0]
    : function(input) {
        return fns.reduce((prev, fn) => fn(prev), input);
      };
}

class Observable {
  constructor(subscribe) {
    this._isScalar = false;
    if (subscribe) this._subscribe = subscribe;
  }
  /** @returns {Observable} */
  lift(operator) {
    const observable = new Observable();
    observable.source = this;
    observable.operator = operator;
    return observable;
  }
  subscribe(observerOrNext, error, complete) {
    const operator = this.operator,
      sink = toSubscriber(observerOrNext, error, complete);
    operator
      ? operator.call(sink, this.source)
      : sink.add(
          this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable)
            ? this._subscribe(sink)
            : this._trySubscribe(sink)
        );

    if (config.useDeprecatedSynchronousErrorHandling && sink.syncErrorThrowable) {
      sink.syncErrorThrowable = false;
      if (sink.syncErrorThrown) throw sink.syncErrorValue;
    }
    return sink;
  }
  _trySubscribe(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      if (config.useDeprecatedSynchronousErrorHandling) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
      }
      canReportError(sink) ? sink.error(err) : console.warn(err);
    }
  }
  forEach(next, promiseCtor) {
    return new (getPromiseCtor(promiseCtor))((resolve, reject) => {
      let subscription;
      subscription = this.subscribe(value => {
        try {
          next(value);
        } catch (err) {
          reject(err);
          subscription && subscription.unsubscribe();
        }
      }, reject, resolve);
    });
  }
  _subscribe(subscriber) {
    const source = this.source;
    return source && source.subscribe(subscriber);
  }
  [observable]() {
    return this;
  }
  pipe() {
    var operations = Array.prototype.slice.call(arguments, 0);
    return operations.length === 0 ? this : pipeFromArray(operations)(this);
  }
  toPromise(promiseCtor) {
    return new (getPromiseCtor(promiseCtor))((resolve, reject) => {
      let value;
      this.subscribe(x => (value = x), err => reject(err), () => resolve(value));
    });
  }
}
Observable.create = subscribe => new Observable(subscribe);

function getPromiseCtor(promiseCtor) {
  promiseCtor || (promiseCtor = config.Promise || Promise);

  if (!promiseCtor) throw new Error('no Promise impl found');

  return promiseCtor;
}

function ObjectUnsubscribedErrorImpl() {
  Error.call(this);
  this.message = 'object unsubscribed';
  this.name = 'ObjectUnsubscribedError';
  return this;
}
ObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype);
const ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

class SubjectSubscription extends Subscription {
  constructor(subject, subscriber) {
    super();
    this.subject = subject;
    this.subscriber = subscriber;
    this.closed = false;
  }
  unsubscribe() {
    if (this.closed) return;

    this.closed = true;
    const subject = this.subject,
      observers = subject.observers;
    this.subject = null;
    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) return;

    const subscriberIndex = observers.indexOf(this.subscriber);
    subscriberIndex < 0 || observers.splice(subscriberIndex, 1);
  }
}

class SubjectSubscriber extends Subscriber {
  constructor(destination) {
    super(destination);
    this.destination = destination;
  }
}
class Subject extends Observable {
  constructor() {
    super();
    this.observers = [];
    this.closed = false;
    this.isStopped = false;
    this.hasError = false;
    this.thrownError = null;
  }
  [rxSubscriber]() {
    return new SubjectSubscriber(this);
  }
  lift(operator) {
    const subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  }
  next(value) {
    if (this.closed) throw new ObjectUnsubscribedError();

    if (!this.isStopped) {
      const observers = this.observers,
        len = observers.length,
        copy = observers.slice();
      for (let i = 0; i < len; i++) copy[i].next(value);
    }
  }
  error(err) {
    if (this.closed) throw new ObjectUnsubscribedError();

    this.hasError = true;
    this.thrownError = err;
    this.isStopped = true;
    const observers = this.observers,
      len = observers.length,
      copy = observers.slice();
    for (let i = 0; i < len; i++) copy[i].error(err);

    this.observers.length = 0;
  }
  complete() {
    if (this.closed) throw new ObjectUnsubscribedError();

    this.isStopped = true;
    const observers = this.observers,
      len = observers.length,
      copy = observers.slice();
    for (let i = 0; i < len; i++) copy[i].complete();

    this.observers.length = 0;
  }
  unsubscribe() {
    this.isStopped = true;
    this.closed = true;
    this.observers = null;
  }
  _trySubscribe(subscriber) {
    if (this.closed) throw new ObjectUnsubscribedError();

    return super._trySubscribe(subscriber);
  }
  _subscribe(subscriber) {
    if (this.closed) throw new ObjectUnsubscribedError();

    if (this.hasError) {
      subscriber.error(this.thrownError);
      return Subscription.EMPTY;
    }
    if (this.isStopped) {
      subscriber.complete();
      return Subscription.EMPTY;
    }

    this.observers.push(subscriber);
    return new SubjectSubscription(this, subscriber);
  }
  asObservable() {
    const observable = new Observable();
    observable.source = this;
    return observable;
  }
}
Subject.create = (destination, source) => new AnonymousSubject(destination, source);

class AnonymousSubject extends Subject {
  constructor(destination, source) {
    super();
    this.destination = destination;
    this.source = source;
  }
  next(value) {
    const destination = this.destination;
    destination && destination.next && destination.next(value);
  }
  error(err) {
    const destination = this.destination;
    destination && destination.error && this.destination.error(err);
  }
  complete() {
    const destination = this.destination;
    destination && destination.complete && this.destination.complete();
  }
  _subscribe(subscriber) {
    const source = this.source;
    return source ? this.source.subscribe(subscriber) : Subscription.EMPTY;
  }
}

function isPromise(value) {
  return value && typeof value.subscribe != 'function' && typeof value.then == 'function';
}

const isArrayLike = x => x && typeof x.length == 'number' && typeof x != 'function';

function isInteropObservable(input) {
  return input && typeof input[observable] == 'function';
}

function getSymbolIterator() {
  return typeof Symbol == 'function' && Symbol.iterator ? Symbol.iterator : '@@iterator';
}
const iterator = getSymbolIterator();

function isIterable(input) {
  return input && typeof input[iterator] == 'function';
}

const subscribeToArray = array => subscriber => {
  for (let i = 0, len = array.length; i < len && !subscriber.closed; i++) subscriber.next(array[i]);

  subscriber.closed || subscriber.complete();
};

function fromArray(input, scheduler) {
  if (!scheduler) return new Observable(subscribeToArray(input));

  return new Observable(subscriber => {
    const sub = new Subscription();
    let i = 0;
    sub.add(scheduler.schedule(function() {
      if (i !== input.length) {
        subscriber.next(input[i++]);
        subscriber.closed || sub.add(this.schedule());
      } else subscriber.complete();
    }));
    return sub;
  });
}

const subscribeToPromise = promise => subscriber => {
  promise.then(value => {
    if (!subscriber.closed) {
      subscriber.next(value);
      subscriber.complete();
    }
  }, err => subscriber.error(err))
    .then(null, hostReportError);
  return subscriber;
};

function fromPromise(input, scheduler) {
  if (!scheduler) return new Observable(subscribeToPromise(input));

  return new Observable(subscriber => {
    const sub = new Subscription();
    sub.add(scheduler.schedule(() => input.then(value => {
      sub.add(scheduler.schedule(() => {
        subscriber.next(value);
        sub.add(scheduler.schedule(() => subscriber.complete()));
      }));
    }, err => {
      sub.add(scheduler.schedule(() => subscriber.error(err)));
    })));
    return sub;
  });
}

const subscribeToIterable = iterable => subscriber => {
  const iterator$1 = iterable[iterator]();
  while (1) {
    const item = iterator$1.next();
    if (item.done) {
      subscriber.complete();
      break;
    }
    subscriber.next(item.value);
    if (subscriber.closed) break;
  }
  typeof iterator$1.return != 'function' ||
    subscriber.add(() => {
      iterator$1.return && iterator$1.return();
    });

  return subscriber;
};

function fromIterable(input, scheduler) {
  if (!input) throw new Error('Iterable cannot be null');

  if (!scheduler) return new Observable(subscribeToIterable(input));

  return new Observable(subscriber => {
    const sub = new Subscription();
    let iterator$1;
    sub.add(() => {
      iterator$1 && typeof iterator$1.return == 'function' && iterator$1.return();
    });
    sub.add(scheduler.schedule(() => {
      iterator$1 = input[iterator]();
      sub.add(scheduler.schedule(function() {
        if (subscriber.closed) return;

        let value, done;
        try {
          const result = iterator$1.next();
          value = result.value;
          done = result.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) subscriber.complete();
        else {
          subscriber.next(value);
          this.schedule();
        }
      }));
    }));
    return sub;
  });
}

const subscribeToObservable = obj => subscriber => {
  const obs = obj[observable]();
  if (typeof obs.subscribe != 'function')
    throw new TypeError('Provided object does not correctly implement Symbol.observable');

  return obs.subscribe(subscriber);
};

function fromObservable(input, scheduler) {
  if (!scheduler) return new Observable(subscribeToObservable(input));

  return new Observable(subscriber => {
    const sub = new Subscription();
    sub.add(scheduler.schedule(() => {
      const observable$1 = input[observable]();
      sub.add(observable$1.subscribe({
        next(value) { sub.add(scheduler.schedule(() => subscriber.next(value))); },
        error(err) { sub.add(scheduler.schedule(() => subscriber.error(err))); },
        complete() { sub.add(scheduler.schedule(() => subscriber.complete())); }
      }));
    }));
    return sub;
  });
}

const subscribeTo = result => {
  if (result instanceof Observable)
    return subscriber => {
      if (!result._isScalar) return result.subscribe(subscriber);

      subscriber.next(result.value);
      subscriber.complete();
      return void 0;
    };

  if (result && typeof result[observable] == 'function') return subscribeToObservable(result);
  if (isArrayLike(result)) return subscribeToArray(result);
  if (isPromise(result)) return subscribeToPromise(result);
  if (result && typeof result[iterator] == 'function') return subscribeToIterable(result);

  const value = isObject(result) ? 'an invalid object' : `'${result}'`;
  throw new TypeError(
    `You provided ${value} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`
  );
};

function from(input, scheduler) {
  if (!scheduler) return input instanceof Observable ? input : new Observable(subscribeTo(input));

  if (input != null) {
    if (isInteropObservable(input)) return fromObservable(input, scheduler);
    if (isPromise(input)) return fromPromise(input, scheduler);
    if (isArrayLike(input)) return fromArray(input, scheduler);
    if (isIterable(input) || typeof input == 'string') return fromIterable(input, scheduler);
  }
  throw new TypeError(((input !== null && typeof input) || input) + ' is not observable');
}

const EMPTY = new Observable(subscriber => subscriber.complete());
function empty$1(scheduler) {
  return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
  return new Observable(subscriber => scheduler.schedule(() => subscriber.complete()));
}

function defer(observableFactory) {
  return new Observable(subscriber => {
    let input;
    try {
      input = observableFactory();
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    return (input ? from(input) : empty$1()).subscribe(subscriber);
  });
}

function map(project, thisArg) {
  return function(source) {
    if (typeof project != 'function')
      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');

    return source.lift(new MapOperator(project, thisArg));
  };
}
class MapOperator {
  constructor(project, thisArg) {
    this.project = project;
    this.thisArg = thisArg;
  }
  call(subscriber, source) {
    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
  }
}
class MapSubscriber extends Subscriber {
  constructor(destination, project, thisArg) {
    super(destination);
    this.project = project;
    this.count = 0;
    this.thisArg = thisArg || this;
  }
  _next(value) {
    let result;
    try {
      result = this.project.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  }
}

function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector)
    return fromEvent(target, eventName, options).pipe(
      map(args => (isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args)))
    );

  return new Observable(subscriber => {
    function handler(e) {
      arguments.length > 1 ? subscriber.next(Array.prototype.slice.call(arguments)) : subscriber.next(e);
    }
    setupSubscription(target, eventName, handler, subscriber, options);
  });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
  let unsubscribe;
  if (isEventTarget(sourceObj)) {
    const source = sourceObj;
    sourceObj.addEventListener(eventName, handler, options);
    unsubscribe = () => source.removeEventListener(eventName, handler, options);
  } else if (isJQueryStyleEventEmitter(sourceObj)) {
    const source = sourceObj;
    sourceObj.on(eventName, handler);
    unsubscribe = () => source.off(eventName, handler);
  } else if (isNodeStyleEventEmitter(sourceObj)) {
    const source = sourceObj;
    sourceObj.addListener(eventName, handler);
    unsubscribe = () => source.removeListener(eventName, handler);
  } else if (sourceObj && sourceObj.length)
    for (let i = 0, len = sourceObj.length; i < len; i++)
      setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
  else throw new TypeError('Invalid event target');

  subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.addListener == 'function' && typeof sourceObj.removeListener == 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.on == 'function' && typeof sourceObj.off == 'function';
}
function isEventTarget(sourceObj) {
  return (
    sourceObj && typeof sourceObj.addEventListener == 'function' && typeof sourceObj.removeEventListener == 'function'
  );
}

function isScheduler(value) {
  return value && typeof value.schedule == 'function';
}

function scalar(value) {
  const result = new Observable(subscriber => {
    subscriber.next(value);
    subscriber.complete();
  });
  result._isScalar = true;
  result.value = value;
  return result;
}

function of() {
  var args = Array.prototype.slice.call(arguments, 0);
  let scheduler = args[args.length - 1];
  isScheduler(scheduler) ? args.pop() : (scheduler = void 0);

  switch (args.length) {
    case 0:
      return empty$1(scheduler);
    case 1:
      return scheduler ? fromArray(args, scheduler) : scalar(args[0]);
    default:
      return fromArray(args, scheduler);
  }
}

class InnerSubscriber extends Subscriber {
  constructor(parent, outerValue, outerIndex) {
    super();
    this.parent = parent;
    this.outerValue = outerValue;
    this.outerIndex = outerIndex;
    this.index = 0;
  }
  _next(value) {
    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
  }
  _error(error) {
    this.parent.notifyError(error, this);
    this.unsubscribe();
  }
  _complete() {
    this.parent.notifyComplete(this);
    this.unsubscribe();
  }
}

function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {
  destination !== void 0 || (destination = new InnerSubscriber(outerSubscriber, outerValue, outerIndex));

  if (!destination.closed) return subscribeTo(result)(destination);
}

class OuterSubscriber extends Subscriber {
  notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  }
  notifyError(error, innerSub) {
    this.destination.error(error);
  }
  notifyComplete(innerSub) {
    this.destination.complete();
  }
}

function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) concurrent = Number.POSITIVE_INFINITY;
  if (typeof resultSelector == 'function')
    return source =>
      source.pipe(mergeMap((a, i) => from(project(a, i)).pipe(map((b, ii) => resultSelector(a, b, i, ii))), concurrent));

  if (typeof resultSelector == 'number') concurrent = resultSelector;

  return source => source.lift(new MergeMapOperator(project, concurrent));
}
class MergeMapOperator {
  constructor(project, concurrent) {
    if (concurrent === void 0) concurrent = Number.POSITIVE_INFINITY;
    this.project = project;
    this.concurrent = concurrent;
  }
  call(observer, source) {
    return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
  }
}
class MergeMapSubscriber extends OuterSubscriber {
  constructor(destination, project, concurrent) {
    if (concurrent === void 0) concurrent = Number.POSITIVE_INFINITY;
    super(destination);
    this.project = project;
    this.concurrent = concurrent;
    this.hasCompleted = false;
    this.buffer = [];
    this.active = 0;
    this.index = 0;
  }
  _next(value) {
    this.active < this.concurrent ? this._tryNext(value) : this.buffer.push(value);
  }
  _tryNext(value) {
    let result;
    const index = this.index++;
    try {
      result = this.project(value, index);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.active++;
    this._innerSub(result, value, index);
  }
  _innerSub(ish, value, index) {
    const innerSubscriber = new InnerSubscriber(this, void 0, void 0);
    this.destination.add(innerSubscriber);
    subscribeToResult(this, ish, value, index, innerSubscriber);
  }
  _complete() {
    this.hasCompleted = true;
    this.active !== 0 || this.buffer.length > 0 || this.destination.complete();

    this.unsubscribe();
  }
  notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  }
  notifyComplete(innerSub) {
    const buffer = this.buffer;
    this.remove(innerSub);
    this.active--;
    buffer.length > 0
      ? this._next(buffer.shift())
      : this.active === 0 && this.hasCompleted && this.destination.complete();
  }
}

function concatMap(project, resultSelector) {
  return mergeMap(project, resultSelector, 1);
}

function filter(predicate, thisArg) {
  return function(source) {
    return source.lift(new FilterOperator(predicate, thisArg));
  };
}
class FilterOperator {
  constructor(predicate, thisArg) {
    this.predicate = predicate;
    this.thisArg = thisArg;
  }
  call(subscriber, source) {
    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
  }
}
class FilterSubscriber extends Subscriber {
  constructor(destination, predicate, thisArg) {
    super(destination);
    this.predicate = predicate;
    this.thisArg = thisArg;
    this.count = 0;
  }
  _next(value) {
    let result;
    try {
      result = this.predicate.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    result && this.destination.next(value);
  }
}

function refCount() {
  return function(source) {
    return source.lift(new RefCountOperator(source));
  };
}
class RefCountOperator {
  constructor(connectable) {
    /** @type {ConnectableObservable} */
    this.connectable = connectable;
  }
  call(subscriber, source) {
    const connectable = this.connectable;
    connectable._refCount++;
    const refCounter = new RefCountSubscriber(subscriber, connectable),
      subscription = source.subscribe(refCounter);
    refCounter.closed || (refCounter.connection = connectable.connect());

    return subscription;
  }
}
class RefCountSubscriber extends Subscriber {
  constructor(destination, connectable) {
    super(destination);
    this.connectable = connectable;
  }
  _unsubscribe() {
    const connectable = this.connectable;
    if (!connectable) {
      this.connection = null;
      return;
    }
    this.connectable = null;
    const refCount = connectable._refCount;
    if (refCount <= 0) {
      this.connection = null;
      return;
    }
    connectable._refCount = refCount - 1;
    if (refCount > 1) {
      this.connection = null;
      return;
    }
    const connection = this.connection,
      sharedConnection = connectable._connection;
    this.connection = null;
    !sharedConnection || (connection && sharedConnection !== connection) || sharedConnection.unsubscribe();
  }
}

class ConnectableObservable extends Observable {
  constructor(source, subjectFactory) {
    super();
    this.source = source;
    this.subjectFactory = subjectFactory;
    this._refCount = 0;
    this._isComplete = false;
  }
  _subscribe(subscriber) {
    return this.getSubject().subscribe(subscriber);
  }
  getSubject() {
    const subject = this._subject;
    if (!subject || subject.isStopped) this._subject = this.subjectFactory();

    return this._subject;
  }
  connect() {
    let connection = this._connection;
    if (!connection) {
      this._isComplete = false;
      connection = this._connection = new Subscription();
      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      } else this._connection = connection;
    }
    return connection;
  }
  refCount() {
    return refCount()(this);
  }
}
const connectableProto = ConnectableObservable.prototype;
const connectableObservableDescriptor = {
  operator: {value: null},
  _refCount: {value: 0, writable: true},
  _subject: {value: null, writable: true},
  _connection: {value: null, writable: true},
  _subscribe: {value: connectableProto._subscribe},
  _isComplete: {value: connectableProto._isComplete, writable: true},
  getSubject: {value: connectableProto.getSubject},
  connect: {value: connectableProto.connect},
  refCount: {value: connectableProto.refCount}
};
class ConnectableSubscriber extends SubjectSubscriber {
  constructor(destination, connectable) {
    super(destination);
    this.connectable = connectable;
  }
  _error(err) {
    this._unsubscribe();
    super._error(err);
  }
  _complete() {
    this.connectable._isComplete = true;
    this._unsubscribe();
    super._complete();
  }
  _unsubscribe() {
    const connectable = this.connectable;
    if (connectable) {
      this.connectable = null;
      const connection = connectable._connection;
      connectable._refCount = 0;
      connectable._subject = null;
      connectable._connection = null;
      connection && connection.unsubscribe();
    }
  }
}

function multicast(subjectOrSubjectFactory, selector) {
  return function(source) {
    let subjectFactory =
      typeof subjectOrSubjectFactory == 'function'
      ? subjectOrSubjectFactory
      : function() {
          return subjectOrSubjectFactory;
        };

    if (typeof selector == 'function') return source.lift(new MulticastOperator(subjectFactory, selector));

    const connectable = Object.create(source, connectableObservableDescriptor);
    connectable.source = source;
    connectable.subjectFactory = subjectFactory;
    return connectable;
  };
}
class MulticastOperator {
  constructor(subjectFactory, selector) {
    this.subjectFactory = subjectFactory;
    this.selector = selector;
  }
  call(subscriber, source) {
    const selector = this.selector,
      subject = this.subjectFactory(),
      subscription = selector(subject).subscribe(subscriber);
    subscription.add(source.subscribe(subject));
    return subscription;
  }
}

function publish(selector) {
  return selector ? multicast(() => new Subject(), selector) : multicast(new Subject());
}

function scan(accumulator, seed) {
  let hasSeed = false;
  if (arguments.length >= 2) hasSeed = true;

  return function(source) {
    return source.lift(new ScanOperator(accumulator, seed, hasSeed));
  };
}
class ScanOperator {
  constructor(accumulator, seed, hasSeed) {
    if (hasSeed === void 0) hasSeed = false;
    this.accumulator = accumulator;
    this.seed = seed;
    this.hasSeed = hasSeed;
  }
  call(subscriber, source) {
    return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
  }
}
class ScanSubscriber extends Subscriber {
  constructor(destination, accumulator, _seed, hasSeed) {
    super(destination);
    this.accumulator = accumulator;
    this._seed = _seed;
    this.hasSeed = hasSeed;
    this.index = 0;
  }
  get seed() {
    return this._seed;
  }
  set seed(value) {
    this.hasSeed = true;
    this._seed = value;
  }
  _next(value) {
    if (this.hasSeed) return this._tryNext(value);

    this.seed = value;
    this.destination.next(value);
  }
  _tryNext(value) {
    const index = this.index++;
    let result;
    try {
      result = this.accumulator(this.seed, value, index);
    } catch (err) {
      this.destination.error(err);
    }
    this.seed = result;
    this.destination.next(result);
  }
}

function ArgumentOutOfRangeErrorImpl() {
  Error.call(this);
  this.message = 'argument out of range';
  this.name = 'ArgumentOutOfRangeError';
  return this;
}
ArgumentOutOfRangeErrorImpl.prototype = Object.create(Error.prototype);
const ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;

function takeLast(count) {
  return function(source) {
    return count === 0 ? empty$1() : source.lift(new TakeLastOperator(count));
  };
}
class TakeLastOperator {
  constructor(total) {
    this.total = total;
    if (this.total < 0) throw new ArgumentOutOfRangeError();
  }
  call(subscriber, source) {
    return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
  }
}
class TakeLastSubscriber extends Subscriber {
  constructor(destination, total) {
    super(destination);
    this.total = total;
    this.ring = [];
    this.count = 0;
  }
  _next(value) {
    const ring = this.ring,
      total = this.total,
      count = this.count++;
    ring.length < total ? ring.push(value) : (ring[count % total] = value);
  }
  _complete() {
    const destination = this.destination;
    let count = this.count;
    if (count > 0) {
      const total = this.count >= this.total ? this.total : this.count,
        ring = this.ring;
      for (let i = 0; i < total; i++) {
        const idx = count++ % total;
        destination.next(ring[idx]);
      }
    }
    destination.complete();
  }
}

function defaultIfEmpty(defaultValue) {
  if (defaultValue === void 0) defaultValue = null;
  return source => source.lift(new DefaultIfEmptyOperator(defaultValue));
}
class DefaultIfEmptyOperator {
  constructor(defaultValue) {
    this.defaultValue = defaultValue;
  }
  call(subscriber, source) {
    return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
  }
}
class DefaultIfEmptySubscriber extends Subscriber {
  constructor(destination, defaultValue) {
    super(destination);
    this.defaultValue = defaultValue;
    this.isEmpty = true;
  }
  _next(value) {
    this.isEmpty = false;
    this.destination.next(value);
  }
  _complete() {
    this.isEmpty && this.destination.next(this.defaultValue);

    this.destination.complete();
  }
}

function reduce(accumulator, seed) {
  return arguments.length >= 2
    ? function(source) {
        return pipe(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source);
      }
    : function(source) {
        return pipe(scan((acc, value, index) => accumulator(acc, value, index + 1)), takeLast(1))(source);
      };
}

function shareSubjectFactory() {
  return new Subject();
}
function share() {
  return source => refCount()(multicast(shareSubjectFactory)(source));
}

function take(count) {
  return source => (count === 0 ? empty$1() : source.lift(new TakeOperator(count)));
}
class TakeOperator {
  constructor(total) {
    this.total = total;
    if (this.total < 0) throw new ArgumentOutOfRangeError();
  }
  call(subscriber, source) {
    return source.subscribe(new TakeSubscriber(subscriber, this.total));
  }
}
class TakeSubscriber extends Subscriber {
  constructor(destination, total) {
    super(destination);
    this.total = total;
    this.count = 0;
  }
  _next(value) {
    const total = this.total,
      count = ++this.count;
    if (count <= total) {
      this.destination.next(value);
      if (count === total) {
        this.destination.complete();
        this.unsubscribe();
      }
    }
  }
}

function takeUntil(notifier) {
  return source => source.lift(new TakeUntilOperator(notifier));
}
class TakeUntilOperator {
  constructor(notifier) {
    this.notifier = notifier;
  }
  call(subscriber, source) {
    const takeUntilSubscriber = new TakeUntilSubscriber(subscriber),
      notifierSubscription = subscribeToResult(takeUntilSubscriber, this.notifier);
    if (notifierSubscription && !takeUntilSubscriber.seenValue) {
      takeUntilSubscriber.add(notifierSubscription);
      return source.subscribe(takeUntilSubscriber);
    }
    return takeUntilSubscriber;
  }
}
class TakeUntilSubscriber extends OuterSubscriber {
  constructor(destination) {
    super(destination);
    this.seenValue = false;
  }
  notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.seenValue = true;
    this.complete();
  }
  notifyComplete() {}
}

var index = /*#__PURE__*/ Object.freeze({
  __proto__: null,
  concatMap: concatMap,
  filter: filter,
  map: map,
  flatMap: mergeMap,
  publish: publish,
  reduce: reduce,
  share: share,
  take: take,
  takeUntil: takeUntil
});

exports.EMPTY = EMPTY;
exports.Observable = Observable;
exports.Subject = Subject;
exports.Subscriber = Subscriber;
exports.Subscription = Subscription;
exports.config = config;
exports.defer = defer;
exports.empty = empty$1;
exports.from = from;
exports.fromEvent = fromEvent;
exports.observable = observable;
exports.of = of;
exports.operators = index;
exports.pipe = pipe;
//
},
'rxjs/operators':
function(module, exports, __wpreq__) {
//
module.exports = __wpreq__('rxjs').operators;
//
},
'run-async':
function(module, exports, __wpreq__) {
//
var isPromise = __wpreq__('is-promise');

var runAsync = (module.exports = function(func, cb) {
  cb = cb || function() {};

  return function() {
    var async = false,
      args = arguments;

    var promise = new Promise(function(resolve, reject) {
      var answer = func.apply({
        async: function() {
          async = true;
          return function(err, value) {
            err ? reject(err) : resolve(value);
          };
        }
      }, Array.prototype.slice.call(args));

      async || (isPromise(answer) ? answer.then(resolve, reject) : resolve(answer));
    });

    promise.then(cb.bind(null, null), cb);

    return promise;
  }
});

runAsync.cb = function(func, cb) {
  return runAsync(function() {
    var args = Array.prototype.slice.call(arguments);
    args.length !== func.length - 1 || args.push(this.async());

    return func.apply(this, args);
  }, cb);
};
//
},
'is-promise':
function(module) {
//
module.exports = isPromise;

function isPromise(obj) {
  return !!obj && (typeof obj == 'object' || typeof obj == 'function') && typeof obj.then == 'function';
}
//
},
'inquirer/lib/utils/utils':
function(module, exports, __wpreq__) {
//
var _ = __wpreq__('lodash'),
  _rxjs = __wpreq__('rxjs'), from = _rxjs.from, of = _rxjs.of,
  runAsync = __wpreq__('run-async');

exports.fetchAsyncQuestionProperty = function(question, prop, answers) {
  if (!_.isFunction(question[prop])) return of(question);

  return from(
    runAsync(question[prop])(answers).then(value => {
      question[prop] = value;
      return question;
    })
  );
};
//
},
'inquirer/lib/prompts/list':
function(module, exports, __wpreq__) {
//
var _ = __wpreq__('lodash'),
  chalk = __wpreq__('chalk'),
  figures = __wpreq__('figures'),
  cliCursor = __wpreq__('cli-cursor'),
  runAsync = __wpreq__('run-async'),
  _rxjsOp = __wpreq__('rxjs/operators'),
  flatMap = _rxjsOp.flatMap, map = _rxjsOp.map, take = _rxjsOp.take, takeUntil = _rxjsOp.takeUntil,
  Base = __wpreq__('inquirer/lib/prompts/base'),
  observe = __wpreq__('inquirer/lib/utils/events'),
  Paginator = __wpreq__('inquirer/lib/utils/paginator');

class ListPrompt extends Base {
  constructor(questions, rl, answers) {
    super(questions, rl, answers);

    this.opt.choices || this.throwParamError('choices');

    this.firstRender = true;
    this.selected = 0;

    var def = this.opt.default;

    if (_.isNumber(def) && def >= 0 && def < this.opt.choices.realLength) this.selected = def;
    else if (!_.isNumber(def) && def != null) {
      let index = _.findIndex(this.opt.choices.realChoices, o => o.value === def);
      this.selected = Math.max(index, 0);
    }

    this.opt.default = null;

    this.paginator = new Paginator(this.screen);
  }

  _run(cb) {
    this.done = cb;

    var self = this,

      events = observe(this.rl);
    events.normalizedUpKey.pipe(takeUntil(events.line)).forEach(this.onUpKey.bind(this));
    events.normalizedDownKey.pipe(takeUntil(events.line)).forEach(this.onDownKey.bind(this));
    events.numberKey.pipe(takeUntil(events.line)).forEach(this.onNumberKey.bind(this));
    events.line
      .pipe(
        take(1),
        map(this.getCurrentValue.bind(this)),
        flatMap(value => runAsync(self.opt.filter)(value).catch(err => err))
      )
      .forEach(this.onSubmit.bind(this));

    cliCursor.hide();
    this.render();

    return this;
  }

  render() {
    var message = this.getQuestion();

    if (this.firstRender) message += chalk.dim('(Use arrow keys)');

    if (this.status === 'answered') message += chalk.cyan(this.opt.choices.getChoice(this.selected).short);
    else {
      var choicesStr = listRender(this.opt.choices, this.selected),
        indexPosition = this.opt.choices.indexOf(this.opt.choices.getChoice(this.selected));
      message += '\n' + this.paginator.paginate(choicesStr, indexPosition, this.opt.pageSize);
    }

    this.firstRender = false;

    this.screen.render(message);
  }

  onSubmit(value) {
    this.status = 'answered';

    this.render();

    this.screen.done();
    cliCursor.show();
    this.done(value);
  }

  getCurrentValue() {
    return this.opt.choices.getChoice(this.selected).value;
  }

  onUpKey() {
    var len = this.opt.choices.realLength;
    this.selected = this.selected > 0 ? this.selected - 1 : len - 1;
    this.render();
  }

  onDownKey() {
    var len = this.opt.choices.realLength;
    this.selected = this.selected < len - 1 ? this.selected + 1 : 0;
    this.render();
  }

  onNumberKey(input) {
    if (input <= this.opt.choices.realLength) this.selected = input - 1;

    this.render();
  }
}

function listRender(choices, pointer) {
  var output = '',
    separatorOffset = 0;

  choices.forEach((choice, i) => {
    if (choice.type === 'separator') {
      separatorOffset++;
      output += '  ' + choice + '\n';
    } else if (choice.disabled) {
      separatorOffset++;
      output += '  - ' + choice.name;
      output += ' (' + (_.isString(choice.disabled) ? choice.disabled : 'Disabled') + ')';
      output += '\n';
    } else {
      var isSelected = i - separatorOffset === pointer,
        line = (isSelected ? figures.pointer + ' ' : '  ') + choice.name;
      if (isSelected) line = chalk.cyan(line);

      output += line + ' \n';
    }
  });

  return output.replace(/\n$/, '');
}

module.exports = ListPrompt;
//
},
'cli-cursor':
function(module, exports, __wpreq__) {
//
const restoreCursor = __wpreq__('restore-cursor');

let hidden = false;

exports.show = stream => {
  const s = stream || process.stderr;

  if (!s.isTTY) return;

  hidden = false;
  s.write('\x1b[?25h');
};

exports.hide = stream => {
  const s = stream || process.stderr;

  if (!s.isTTY) return;

  restoreCursor();
  hidden = true;
  s.write('\x1b[?25l');
};

exports.toggle = (force, stream) => {
  if (force !== void 0) hidden = force;

  hidden ? exports.show(stream) : exports.hide(stream);
};
//
},
'restore-cursor':
function(module, exports, __wpreq__) {
//
const onetime = __wpreq__('onetime'),
  signalExit = __wpreq__('signal-exit');

module.exports = onetime(() => {
  signalExit(() => {
    process.stderr.write('\x1b[?25h');
  }, {alwaysLast: true});
});
//
},
onetime:
function(module, exports, __wpreq__) {
//
const mimicFn = __wpreq__('mimic-fn');

module.exports = (fn, opts) => {
  if (opts === true) throw new TypeError('The second argument is now an options object');

  if (typeof fn != 'function') throw new TypeError('Expected a function');

  opts = opts || {};

  let ret,
    called = false;
  const fnName = fn.displayName || fn.name || '<anonymous>';

  const onetime = function() {
    if (called) {
      if (opts.throw === true) throw new Error(`Function \`${fnName}\` can only be called once`);

      return ret;
    }

    called = true;
    ret = fn.apply(this, arguments);
    fn = null;

    return ret;
  };

  mimicFn(onetime, fn);

  return onetime;
};
//
},
'mimic-fn':
function(module) {
//
module.exports = (to, from) => {
  for (const prop of Object.getOwnPropertyNames(from).concat(Object.getOwnPropertySymbols(from)))
    Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));

  return to;
};
//
},
'inquirer/lib/prompts/base':
function(module, exports, __wpreq__) {
//
var _ = __wpreq__('lodash'),
  chalk = __wpreq__('chalk'),
  runAsync = __wpreq__('run-async'),
  _rxjsOp = __wpreq__('rxjs/operators'), filter = _rxjsOp.filter, flatMap = _rxjsOp.flatMap,
  share = _rxjsOp.share, take = _rxjsOp.take, takeUntil = _rxjsOp.takeUntil,
  Choices = __wpreq__('inquirer/lib/objects/choices'),
  ScreenManager = __wpreq__('inquirer/lib/utils/screen-manager');

class Prompt {
  constructor(question, rl, answers) {
    _.assign(this, {answers: answers, status: 'pending'});

    this.opt = _.defaults(_.clone(question), {
      validate: () => true,
      filter: val => val,
      when: () => true,
      suffix: '',
      prefix: chalk.green('?')
    });

    this.opt.name || this.throwParamError('name');

    this.opt.message || (this.opt.message = this.opt.name + ':');

    if (Array.isArray(this.opt.choices)) this.opt.choices = new Choices(this.opt.choices, answers);

    this.rl = rl;
    this.screen = new ScreenManager(this.rl);
  }

  run() {
    return new Promise(resolve => {
      this._run(value => resolve(value));
    });
  }

  _run(cb) {
    cb();
  }

  throwParamError(name) {
    throw new Error('You must provide a `' + name + '` parameter');
  }

  close() {
    this.screen.releaseCursor();
  }

  handleSubmitEvents(submit) {
    var self = this,
      validate = runAsync(this.opt.validate),
      asyncFilter = runAsync(this.opt.filter);
    var validation = submit.pipe(
      flatMap(value =>
        asyncFilter(value, self.answers).then(
          filteredValue =>
            validate(filteredValue, self.answers).then(
              isValid => ({isValid: isValid, value: filteredValue}),
              err => ({isValid: err})
            ),
          err => ({isValid: err})
        )
      ),
      share()
    );

    var success = validation.pipe(
      filter(state => state.isValid === true),
      take(1)
    );

    return {
      success: success,
      error: validation.pipe(
        filter(state => state.isValid !== true),
        takeUntil(success)
      )
    };
  }

  getQuestion() {
    var message = this.opt.prefix + ' ' + chalk.bold(this.opt.message) + this.opt.suffix + chalk.reset(' ');

    if (this.opt.default != null && this.status !== 'answered')
      this.opt.type === 'password'
        ? (message += chalk.italic.dim('[hidden] '))
        : (message += chalk.dim('(' + this.opt.default + ') '));

    return message;
  }
}

module.exports = Prompt;
//
},
'inquirer/lib/objects/choices':
function(module, exports, __wpreq__) {
//
var assert = __wpreq__('assert'),
  _ = __wpreq__('lodash'),
  Separator = __wpreq__('inquirer/lib/objects/separator'),
  Choice = __wpreq__('inquirer/lib/objects/choice');

module.exports = class {
  constructor(choices, answers) {
    this.choices = choices.map(val => {
      if (val.type === 'separator') {
        val instanceof Separator || (val = new Separator(val.line));

        return val;
      }
      return new Choice(val, answers);
    });

    this.realChoices = this.choices.filter(Separator.exclude).filter(item => !item.disabled);

    Object.defineProperty(this, 'length', {
      get() {
        return this.choices.length;
      },
      set(val) {
        this.choices.length = val;
      }
    });

    Object.defineProperty(this, 'realLength', {
      get() {
        return this.realChoices.length;
      },
      set() {
        throw new Error('Cannot set `realLength` of a Choices collection');
      }
    });
  }

  getChoice(selector) {
    assert(_.isNumber(selector));
    return this.realChoices[selector];
  }

  get(selector) {
    assert(_.isNumber(selector));
    return this.choices[selector];
  }

  where(whereClause) {
    return _.filter(this.realChoices, whereClause);
  }

  pluck(propertyName) {
    return _.map(this.realChoices, propertyName);
  }

  indexOf() {
    return this.choices.indexOf.apply(this.choices, arguments);
  }

  forEach() {
    return this.choices.forEach.apply(this.choices, arguments);
  }

  filter() {
    return this.choices.filter.apply(this.choices, arguments);
  }

  find(func) {
    return _.find(this.choices, func);
  }

  push() {
    var objs = _.map(arguments, val => new Choice(val));
    this.choices.push.apply(this.choices, objs);
    this.realChoices = this.choices.filter(Separator.exclude);
    return this.choices;
  }
};
//
},
'inquirer/lib/objects/choice':
function(module, exports, __wpreq__) {
//
var _ = __wpreq__('lodash');

module.exports = class Choice {
  constructor(val, answers) {
    if (val instanceof Choice || val.type === 'separator') return val;

    if (_.isString(val)) {
      this.name = val;
      this.value = val;
      this.short = val;
    } else
      _.extend(this, val, {
        name: val.name || val.value,
        value: 'value' in val ? val.value : val.name,
        short: val.short || val.name || val.value
      });

    _.isFunction(val.disabled) ? (this.disabled = val.disabled(answers)) : (this.disabled = val.disabled);
  }
};
//
},
'inquirer/lib/utils/screen-manager':
function(module, exports, __wpreq__) {
//
var _ = __wpreq__('lodash'),
  util = __wpreq__('inquirer/lib/utils/readline'),
  cliWidth = __wpreq__('cli-width'),
  stripAnsi = __wpreq__('strip-ansi'),
  stringWidth = __wpreq__('string-width');

function height(content) {
  return content.split('\n').length;
}

function lastLine(content) {
  return _.last(content.split('\n'));
}

class ScreenManager {
  constructor(rl) {
    this.height = 0;
    this.extraLinesUnderPrompt = 0;

    this.rl = rl;
  }

  render(content, bottomContent) {
    this.rl.output.unmute();
    this.clean(this.extraLinesUnderPrompt);

    var promptLine = lastLine(content),
      rawPromptLine = stripAnsi(promptLine),

      prompt = rawPromptLine;
    if (this.rl.line.length) prompt = prompt.slice(0, -this.rl.line.length);

    this.rl.setPrompt(prompt);

    var cursorPos = this.rl._getCursorPos(),
      width = this.normalizedCliWidth();

    content = this.forceLineReturn(content, width);
    if (bottomContent) bottomContent = this.forceLineReturn(bottomContent, width);
    if (rawPromptLine.length % width == 0) content += '\n';

    var fullContent = content + (bottomContent ? '\n' + bottomContent : '');
    this.rl.output.write(fullContent);

    var bottomContentHeight =
      Math.floor(rawPromptLine.length / width) - cursorPos.rows + (bottomContent ? height(bottomContent) : 0);
    bottomContentHeight > 0 && util.up(this.rl, bottomContentHeight);

    util.left(this.rl, stringWidth(lastLine(fullContent)));

    cursorPos.cols > 0 && util.right(this.rl, cursorPos.cols);

    this.extraLinesUnderPrompt = bottomContentHeight;
    this.height = height(fullContent);

    this.rl.output.mute();
  }

  clean(extraLines) {
    extraLines > 0 && util.down(this.rl, extraLines);

    util.clearLine(this.rl, this.height);
  }

  done() {
    this.rl.setPrompt('');
    this.rl.output.unmute();
    this.rl.output.write('\n');
  }

  releaseCursor() {
    this.extraLinesUnderPrompt > 0 && util.down(this.rl, this.extraLinesUnderPrompt);
  }

  normalizedCliWidth() {
    return cliWidth({defaultWidth: 80, output: this.rl.output});
  }

  breakLines(lines, width) {
    width = width || this.normalizedCliWidth();
    var regex = new RegExp('(?:(?:\\033[[0-9;]*m)*.?){1,' + width + '}', 'g');
    return lines.map(line => {
      var chunk = line.match(regex);
      chunk.pop();
      return chunk || '';
    });
  }

  forceLineReturn(content, width) {
    width = width || this.normalizedCliWidth();
    return _.flatten(this.breakLines(content.split('\n'), width)).join('\n');
  }
}

module.exports = ScreenManager;
//
},
'cli-width':
function(module, exports, __wpreq__) {
//
/*exports =*/ module.exports = cliWidth;

function normalizeOpts(options) {
  var defaultOpts = {
    defaultWidth: 0,
    output: process.stdout,
    tty: __wpreq__('tty')
  };

  if (!options) return defaultOpts;

  Object.keys(defaultOpts).forEach(function(key) {
    options[key] || (options[key] = defaultOpts[key]);
  });

  return options;
}

function cliWidth(options) {
  var opts = normalizeOpts(options);

  if (opts.output.getWindowSize) return opts.output.getWindowSize()[0] || opts.defaultWidth;

  if (opts.tty.getWindowSize) return opts.tty.getWindowSize()[1] || opts.defaultWidth;

  if (opts.output.columns) return opts.output.columns;

  if (process.env.CLI_WIDTH) {
    var width = parseInt(process.env.CLI_WIDTH, 10);

    if (!isNaN(width) && width !== 0) return width;
  }

  return opts.defaultWidth;
}
//
},
tty:
function(module) {
//
module.exports = require('tty');
//
},
'strip-ansi':
function(module, exports, __wpreq__) {
//
const ansiRegex = __wpreq__('ansi-regex');

module.exports = input => (typeof input == 'string' ? input.replace(ansiRegex(), '') : input);
//
},
'ansi-regex':
function(module) {
//
module.exports = () => {
  const pattern = [
    '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)',
    '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))'
  ].join('|');

  return new RegExp(pattern, 'g');
};
//
},
'string-width':
function(module, exports, __wpreq__) {
//
const stripAnsi = __wpreq__('strip-ansi'),
  isFullwidthCodePoint = __wpreq__('is-fullwidth-code-point');

module.exports = str => {
  if (typeof str != 'string' || str.length === 0) return 0;

  str = stripAnsi(str);

  let width = 0;

  for (let i = 0; i < str.length; i++) {
    const code = str.codePointAt(i);

    if (code <= 0x1F || (code >= 0x7F && code <= 0x9F) || (code >= 0x300 && code <= 0x36F)) continue;

    code > 0xFFFF && i++;

    width += isFullwidthCodePoint(code) ? 2 : 1;
  }

  return width;
};
//
},
'is-fullwidth-code-point':
function(module) {
//
module.exports = x =>
  !Number.isNaN(x) &&
  x >= 0x1100 &&
  (x <= 0x115f ||
    x === 0x2329 ||
    x === 0x232a ||
    (0x2e80 <= x && x <= 0x3247 && x !== 0x303f) ||
    (0x3250 <= x && x <= 0x4dbf) ||
    (0x4e00 <= x && x <= 0xa4c6) ||
    (0xa960 <= x && x <= 0xa97c) ||
    (0xac00 <= x && x <= 0xd7a3) ||
    (0xf900 <= x && x <= 0xfaff) ||
    (0xfe10 <= x && x <= 0xfe19) ||
    (0xfe30 <= x && x <= 0xfe6b) ||
    (0xff01 <= x && x <= 0xff60) ||
    (0xffe0 <= x && x <= 0xffe6) ||
    (0x1b000 <= x && x <= 0x1b001) ||
    (0x1f200 <= x && x <= 0x1f251) ||
    (0x20000 <= x && x <= 0x3fffd));
//
},
'inquirer/lib/utils/events':
function(module, exports, __wpreq__) {
//
var fromEvent = __wpreq__('rxjs').fromEvent,
  _rxjsOp = __wpreq__('rxjs/operators'), filter = _rxjsOp.filter, map = _rxjsOp.map, share = _rxjsOp.share;

function normalizeKeypressEvents(value, key) {
  return {value: value, key: key || {}};
}

module.exports = function(rl) {
  var keypress = fromEvent(rl.input, 'keypress', normalizeKeypressEvents).pipe(
    filter(e => {
      let key = e.key;
      return key.name !== 'enter' && key.name !== 'return';
    })
  );

  return {
    line: fromEvent(rl, 'line'),
    keypress: keypress,

    normalizedUpKey: keypress.pipe(
      filter(e => {
        let key = e.key;
        return key.name === 'up' || key.name === 'k' || (key.name === 'p' && key.ctrl);
      }),
      share()
    ),

    normalizedDownKey: keypress.pipe(
      filter(e => {
        let key = e.key;
        return key.name === 'down' || key.name === 'j' || (key.name === 'n' && key.ctrl);
      }),
      share()
    ),

    numberKey: keypress.pipe(
      filter(e => e.value && '123456789'.indexOf(e.value) >= 0),
      map(e => Number(e.value)),
      share()
    ),

    spaceKey: keypress.pipe(
      filter(e => {
        let key = e.key;
        return key && key.name === 'space';
      }),
      share()
    ),
    aKey: keypress.pipe(
      filter(e => {
        let key = e.key;
        return key && key.name === 'a';
      }),
      share()
    ),
    iKey: keypress.pipe(
      filter(e => {
        let key = e.key;
        return key && key.name === 'i';
      }),
      share()
    )
  };
};
//
},
'inquirer/lib/utils/paginator':
function(module, exports, __wpreq__) {
//
var _ = __wpreq__('lodash'),
  chalk = __wpreq__('chalk');

class Paginator {
  constructor(screen) {
    this.pointer = 0;
    this.lastIndex = 0;
    this.screen = screen;
  }

  paginate(output, active, pageSize) {
    pageSize = pageSize || 7;
    var middleOfList = Math.floor(pageSize / 2),
      lines = output.split('\n');

    if (this.screen) {
      lines = this.screen.breakLines(lines);
      active = _.sum(lines.map(lineParts => lineParts.length).splice(0, active));
      lines = _.flatten(lines);
    }

    if (lines.length <= pageSize) return output;

    if (this.pointer < middleOfList && this.lastIndex < active && active - this.lastIndex < pageSize)
      this.pointer = Math.min(middleOfList, this.pointer + active - this.lastIndex);

    this.lastIndex = active;

    var infinite = _.flatten([lines, lines, lines]),
      topIndex = Math.max(0, active + lines.length - this.pointer);

    return (
      infinite.splice(topIndex, pageSize).join('\n') + '\n' + chalk.dim('(Move up and down to reveal more choices)')
    );
  }
}

module.exports = Paginator;
//
},
'inquirer/lib/prompts/input':
function(module, exports, __wpreq__) {
//
var chalk = __wpreq__('chalk'),
  _rxjsOp = __wpreq__('rxjs/operators'), map = _rxjsOp.map, takeUntil = _rxjsOp.takeUntil,
  Base = __wpreq__('inquirer/lib/prompts/base'),
  observe = __wpreq__('inquirer/lib/utils/events');

class InputPrompt extends Base {
  _run(cb) {
    this.done = cb;

    var events = observe(this.rl),
      submit = events.line.pipe(map(this.filterInput.bind(this))),

      validation = this.handleSubmitEvents(submit);
    validation.success.forEach(this.onEnd.bind(this));
    validation.error.forEach(this.onError.bind(this));

    events.keypress.pipe(takeUntil(validation.success)).forEach(this.onKeypress.bind(this));

    this.render();

    return this;
  }

  render(error) {
    var bottomContent = '',
      appendContent, //= ''
      message = this.getQuestion(),
      transformer = this.opt.transformer,
      isFinal = this.status === 'answered';

    appendContent = isFinal ? this.answer : this.rl.line;

    message += transformer
      ? transformer(appendContent, this.answers, {isFinal})
      : isFinal ? chalk.cyan(appendContent) : appendContent;

    if (error) bottomContent = chalk.red('>> ') + error;

    this.screen.render(message, bottomContent);
  }

  filterInput(input) {
    return input || (this.opt.default == null ? '' : this.opt.default);
  }

  onEnd(state) {
    this.answer = state.value;
    this.status = 'answered';

    this.render();

    this.screen.done();
    this.done(state.value);
  }

  onError(state) {
    this.render(state.isValid);
  }

  onKeypress() {
    if (this.opt.default) this.opt.default = void 0;

    this.render();
  }
}

module.exports = InputPrompt;
//
},
'inquirer/lib/prompts/number':
function(module, exports, __wpreq__) {
//
var Input = __wpreq__('inquirer/lib/prompts/input');

class NumberPrompt extends Input {
  filterInput(input) {
    if (input && typeof input == 'string') {
      let numberMatch = input.trim().match(/(^-?\d+|^\d+\.\d*|^\d*\.\d+)(e\d+)?$/);
      if (numberMatch) return Number(numberMatch[0]);
    }
    return this.opt.default == null ? NaN : this.opt.default;
  }
}

module.exports = NumberPrompt;
//
},
'inquirer/lib/prompts/confirm':
function(module, exports, __wpreq__) {
//
var _ = __wpreq__('lodash'),
  chalk = __wpreq__('chalk'),
  _rxjsOp = __wpreq__('rxjs/operators'), take = _rxjsOp.take, takeUntil = _rxjsOp.takeUntil,
  Base = __wpreq__('inquirer/lib/prompts/base'),
  observe = __wpreq__('inquirer/lib/utils/events');

class ConfirmPrompt extends Base {
  constructor(questions, rl, answers) {
    super(questions, rl, answers);

    var rawDefault = true;

    _.extend(this.opt, {
      filter: function(input) {
        var value = rawDefault;
        if (input != null && input !== '') value = /^y(es)?/i.test(input);

        return value;
      }
    });

    if (_.isBoolean(this.opt.default)) rawDefault = this.opt.default;

    this.opt.default = rawDefault ? 'Y/n' : 'y/N';

    return this;
  }

  _run(cb) {
    this.done = cb;

    var events = observe(this.rl);
    events.keypress.pipe(takeUntil(events.line)).forEach(this.onKeypress.bind(this));

    events.line.pipe(take(1)).forEach(this.onEnd.bind(this));

    this.render();

    return this;
  }

  render(answer) {
    var message = this.getQuestion();

    message += typeof answer == 'boolean' ? chalk.cyan(answer ? 'Yes' : 'No') : this.rl.line;

    this.screen.render(message);

    return this;
  }

  onEnd(input) {
    this.status = 'answered';

    var output = this.opt.filter(input);
    this.render(output);

    this.screen.done();
    this.done(output);
  }

  onKeypress() {
    this.render();
  }
}

module.exports = ConfirmPrompt;
//
},
'inquirer/lib/prompts/rawlist':
function(module, exports, __wpreq__) {
//
var _ = __wpreq__('lodash'),
  chalk = __wpreq__('chalk'),
  _rxjsOp = __wpreq__('rxjs/operators'), map = _rxjsOp.map, takeUntil = _rxjsOp.takeUntil,
  Base = __wpreq__('inquirer/lib/prompts/base'),
  Separator = __wpreq__('inquirer/lib/objects/separator'),
  observe = __wpreq__('inquirer/lib/utils/events'),
  Paginator = __wpreq__('inquirer/lib/utils/paginator');

class RawListPrompt extends Base {
  constructor(questions, rl, answers) {
    super(questions, rl, answers);

    this.opt.choices || this.throwParamError('choices');

    this.opt.validChoices = this.opt.choices.filter(Separator.exclude);

    this.selected = 0;
    this.rawDefault = 0;

    _.extend(this.opt, {
      validate: function(val) {
        return val != null;
      }
    });

    var def = this.opt.default;
    if (_.isNumber(def) && def >= 0 && def < this.opt.choices.realLength) {
      this.selected = def;
      this.rawDefault = def;
    } else if (!_.isNumber(def) && def != null) {
      let index = _.findIndex(this.opt.choices.realChoices, o => o.value === def),
        safeIndex = Math.max(index, 0);
      this.selected = safeIndex;
      this.rawDefault = safeIndex;
    }

    this.opt.default = null;

    this.paginator = new Paginator();
  }

  _run(cb) {
    this.done = cb;

    var events = observe(this.rl),
      submit = events.line.pipe(map(this.getCurrentValue.bind(this))),

      validation = this.handleSubmitEvents(submit);
    validation.success.forEach(this.onEnd.bind(this));
    validation.error.forEach(this.onError.bind(this));

    events.keypress.pipe(takeUntil(validation.success)).forEach(this.onKeypress.bind(this));

    this.render();

    return this;
  }

  render(error) {
    var message = this.getQuestion(),
      bottomContent = '';

    if (this.status === 'answered') message += chalk.cyan(this.answer);
    else {
      var choicesStr = renderChoices(this.opt.choices, this.selected);
      message += this.paginator.paginate(choicesStr, this.selected, this.opt.pageSize);
      message += '\n  Answer: ';
    }

    message += this.rl.line;

    if (error) bottomContent = '\n' + chalk.red('>> ') + error;

    this.screen.render(message, bottomContent);
  }

  getCurrentValue(index) {
    index == null || index === '' ? (index = this.rawDefault) : (index -= 1);

    var choice = this.opt.choices.getChoice(index);
    return choice ? choice.value : null;
  }

  onEnd(state) {
    this.status = 'answered';
    this.answer = state.value;

    this.render();

    this.screen.done();
    this.done(state.value);
  }

  onError() {
    this.render('Please enter a valid index');
  }

  onKeypress() {
    var index = this.rl.line.length ? Number(this.rl.line) - 1 : 0;

    this.opt.choices.getChoice(index) ? (this.selected = index) : (this.selected = void 0);

    this.render();
  }
}

function renderChoices(choices, pointer) {
  var output = '',
    separatorOffset = 0;

  choices.forEach(function(choice, i) {
    output += '\n  ';

    if (choice.type === 'separator') {
      separatorOffset++;
      output += ' ' + choice;
      return;
    }

    var index = i - separatorOffset,
      display = index + 1 + ') ' + choice.name;
    if (index === pointer) display = chalk.cyan(display);

    output += display;
  });

  return output;
}

module.exports = RawListPrompt;
//
},
'inquirer/lib/prompts/expand':
function(module, exports, __wpreq__) {
//
var _ = __wpreq__('lodash'),
  chalk = __wpreq__('chalk'),
  _rxjsOp = __wpreq__('rxjs/operators'), map = _rxjsOp.map, takeUntil = _rxjsOp.takeUntil,
  Base = __wpreq__('inquirer/lib/prompts/base'),
  Separator = __wpreq__('inquirer/lib/objects/separator'),
  observe = __wpreq__('inquirer/lib/utils/events'),
  Paginator = __wpreq__('inquirer/lib/utils/paginator');

class ExpandPrompt extends Base {
  constructor(questions, rl, answers) {
    super(questions, rl, answers);

    this.opt.choices || this.throwParamError('choices');

    this.validateChoices(this.opt.choices);

    this.opt.choices.push({key: 'h', name: 'Help, list all options', value: 'help'});

    this.opt.validate = choice => (choice == null ? 'Please enter a valid command' : choice !== 'help');

    this.opt.default = this.generateChoicesString(this.opt.choices, this.opt.default);

    this.paginator = new Paginator(this.screen);
  }

  _run(cb) {
    this.done = cb;

    var events = observe(this.rl),
      validation = this.handleSubmitEvents(events.line.pipe(map(this.getCurrentValue.bind(this))));
    validation.success.forEach(this.onSubmit.bind(this));
    validation.error.forEach(this.onError.bind(this));
    this.keypressObs = events.keypress.pipe(takeUntil(validation.success)).forEach(this.onKeypress.bind(this));

    this.render();

    return this;
  }

  render(error, hint) {
    var message = this.getQuestion(),
      bottomContent = '';

    if (this.status === 'answered') message += chalk.cyan(this.answer);
    else if (this.status === 'expanded') {
      var choicesStr = renderChoices(this.opt.choices, this.selectedKey);
      message += this.paginator.paginate(choicesStr, this.selectedKey, this.opt.pageSize);
      message += '\n  Answer: ';
    }

    message += this.rl.line;

    if (error) bottomContent = chalk.red('>> ') + error;

    if (hint) bottomContent = chalk.cyan('>> ') + hint;

    this.screen.render(message, bottomContent);
  }

  getCurrentValue(input) {
    input || (input = this.rawDefault);

    var selected = this.opt.choices.where({key: input.toLowerCase().trim()})[0];

    return selected ? selected.value : null;
  }

  getChoices() {
    var output = '';

    this.opt.choices.forEach(choice => {
      output += '\n  ';

      if (choice.type !== 'separator') {
        var choiceStr = choice.key + ') ' + choice.name;
        if (this.selectedKey === choice.key) choiceStr = chalk.cyan(choiceStr);

        output += choiceStr;
      } else output += ' ' + choice;
    });

    return output;
  }

  onError(state) {
    if (state.value === 'help') {
      this.selectedKey = '';
      this.status = 'expanded';
      this.render();
    } else this.render(state.isValid);
  }

  onSubmit(state) {
    this.status = 'answered';
    var choice = this.opt.choices.where({value: state.value})[0];
    this.answer = choice.short || choice.name;

    this.render();
    this.screen.done();
    this.done(state.value);
  }

  onKeypress() {
    this.selectedKey = this.rl.line.toLowerCase();
    var selected = this.opt.choices.where({key: this.selectedKey})[0];
    this.status === 'expanded' ? this.render() : this.render(null, selected ? selected.name : null);
  }

  validateChoices(choices) {
    var formatError,
      errors = [],
      keymap = {};
    choices.filter(Separator.exclude).forEach(choice => {
      (choice.key && choice.key.length === 1) || (formatError = true);
      keymap[choice.key] && errors.push(choice.key);

      keymap[choice.key] = true;
      choice.key = String(choice.key).toLowerCase();
    });

    if (formatError) throw new Error('Format error: `key` param must be a single letter and is required.');
    if (keymap.h) throw new Error('Reserved key error: `key` param cannot be `h` - this value is reserved.');
    if (errors.length)
      throw new Error('Duplicate key error: `key` param must be unique. Duplicates: ' + _.uniq(errors).join(', '));
  }

  generateChoicesString(choices, defaultChoice) {
    var defIndex = choices.realLength - 1;
    if (_.isNumber(defaultChoice) && this.opt.choices.getChoice(defaultChoice)) defIndex = defaultChoice;
    else if (_.isString(defaultChoice)) {
      let index = _.findIndex(choices.realChoices, o => o.value === defaultChoice);
      defIndex = index < 0 ? defIndex : index;
    }
    var defStr = this.opt.choices.pluck('key');
    this.rawDefault = defStr[defIndex];
    defStr[defIndex] = String(defStr[defIndex]).toUpperCase();
    return defStr.join('');
  }
}

function renderChoices(choices, pointer) {
  var output = '';

  choices.forEach(choice => {
    output += '\n  ';

    if (choice.type !== 'separator') {
      var choiceStr = choice.key + ') ' + choice.name;
      if (pointer === choice.key) choiceStr = chalk.cyan(choiceStr);

      output += choiceStr;
    } else output += ' ' + choice;
  });

  return output;
}

module.exports = ExpandPrompt;
//
},
'inquirer/lib/prompts/checkbox':
function(module, exports, __wpreq__) {
//
var _ = __wpreq__('lodash'),
  chalk = __wpreq__('chalk'),
  cliCursor = __wpreq__('cli-cursor'),
  figures = __wpreq__('figures'),
  _rxjsOp = __wpreq__('rxjs/operators'), map = _rxjsOp.map, takeUntil = _rxjsOp.takeUntil,
  Base = __wpreq__('inquirer/lib/prompts/base'),
  observe = __wpreq__('inquirer/lib/utils/events'),
  Paginator = __wpreq__('inquirer/lib/utils/paginator');

class CheckboxPrompt extends Base {
  constructor(questions, rl, answers) {
    super(questions, rl, answers);

    this.opt.choices || this.throwParamError('choices');

    _.isArray(this.opt.default) &&
      this.opt.choices.forEach(function(choice) {
        if (this.opt.default.indexOf(choice.value) >= 0) choice.checked = true;
      }, this);

    this.pointer = 0;
    this.firstRender = true;

    this.opt.default = null;

    this.paginator = new Paginator(this.screen);
  }

  _run(cb) {
    this.done = cb;

    var events = observe(this.rl),

      validation = this.handleSubmitEvents(events.line.pipe(map(this.getCurrentValue.bind(this))));
    validation.success.forEach(this.onEnd.bind(this));
    validation.error.forEach(this.onError.bind(this));

    events.normalizedUpKey.pipe(takeUntil(validation.success)).forEach(this.onUpKey.bind(this));
    events.normalizedDownKey.pipe(takeUntil(validation.success)).forEach(this.onDownKey.bind(this));
    events.numberKey.pipe(takeUntil(validation.success)).forEach(this.onNumberKey.bind(this));
    events.spaceKey.pipe(takeUntil(validation.success)).forEach(this.onSpaceKey.bind(this));
    events.aKey.pipe(takeUntil(validation.success)).forEach(this.onAllKey.bind(this));
    events.iKey.pipe(takeUntil(validation.success)).forEach(this.onInverseKey.bind(this));

    cliCursor.hide();
    this.render();
    this.firstRender = false;

    return this;
  }

  render(error) {
    var message = this.getQuestion(),
      bottomContent = '';

    if (this.firstRender)
      message +=
        '(Press ' +
        chalk.cyan.bold('<space>') +
        ' to select, ' +
        chalk.cyan.bold('<a>') +
        ' to toggle all, ' +
        chalk.cyan.bold('<i>') +
        ' to invert selection)';

    if (this.status === 'answered') message += chalk.cyan(this.selection.join(', '));
    else {
      var choicesStr = renderChoices(this.opt.choices, this.pointer),
        indexPosition = this.opt.choices.indexOf(this.opt.choices.getChoice(this.pointer));
      message += '\n' + this.paginator.paginate(choicesStr, indexPosition, this.opt.pageSize);
    }

    if (error) bottomContent = chalk.red('>> ') + error;

    this.screen.render(message, bottomContent);
  }

  onEnd(state) {
    this.status = 'answered';

    this.render();

    this.screen.done();
    cliCursor.show();
    this.done(state.value);
  }

  onError(state) {
    this.render(state.isValid);
  }

  getCurrentValue() {
    var choices = this.opt.choices.filter(function(choice) {
      return Boolean(choice.checked) && !choice.disabled;
    });

    this.selection = _.map(choices, 'short');
    return _.map(choices, 'value');
  }

  onUpKey() {
    var len = this.opt.choices.realLength;
    this.pointer = this.pointer > 0 ? this.pointer - 1 : len - 1;
    this.render();
  }

  onDownKey() {
    var len = this.opt.choices.realLength;
    this.pointer = this.pointer < len - 1 ? this.pointer + 1 : 0;
    this.render();
  }

  onNumberKey(input) {
    if (input <= this.opt.choices.realLength) {
      this.pointer = input - 1;
      this.toggleChoice(this.pointer);
    }
    this.render();
  }

  onSpaceKey() {
    this.toggleChoice(this.pointer);
    this.render();
  }

  onAllKey() {
    var shouldBeChecked = Boolean(
      this.opt.choices.find(function(choice) {
        return choice.type !== 'separator' && !choice.checked;
      })
    );

    this.opt.choices.forEach(function(choice) {
      if (choice.type !== 'separator') choice.checked = shouldBeChecked;
    });

    this.render();
  }

  onInverseKey() {
    this.opt.choices.forEach(function(choice) {
      if (choice.type !== 'separator') choice.checked = !choice.checked;
    });

    this.render();
  }

  toggleChoice(index) {
    var item = this.opt.choices.getChoice(index);
    if (item !== void 0) this.opt.choices.getChoice(index).checked = !item.checked;
  }
}

function renderChoices(choices, pointer) {
  var output = '',
    separatorOffset = 0;

  choices.forEach(function(choice, i) {
    if (choice.type === 'separator') {
      separatorOffset++;
      output += ' ' + choice + '\n';
      return;
    }

    if (choice.disabled) {
      separatorOffset++;
      output += ' - ' + choice.name;
      output += ' (' + (_.isString(choice.disabled) ? choice.disabled : 'Disabled') + ')';
    } else {
      var line = getCheckbox(choice.checked) + ' ' + choice.name;
      output += i - separatorOffset === pointer ? chalk.cyan(figures.pointer + line) : ' ' + line;
    }

    output += '\n';
  });

  return output.replace(/\n$/, '');
}

function getCheckbox(checked) {
  return checked ? chalk.green(figures.radioOn) : figures.radioOff;
}

module.exports = CheckboxPrompt;
//
},
'inquirer/lib/prompts/password':
function(module, exports, __wpreq__) {
//
var chalk = __wpreq__('chalk'),
  _rxjsOp = __wpreq__('rxjs/operators'), map = _rxjsOp.map, takeUntil = _rxjsOp.takeUntil,
  Base = __wpreq__('inquirer/lib/prompts/base'),
  observe = __wpreq__('inquirer/lib/utils/events');

function mask(input, maskChar) {
  maskChar = typeof maskChar == 'string' ? maskChar : '*';
  return (input = String(input)).length === 0 ? '' : new Array(input.length + 1).join(maskChar);
}

class PasswordPrompt extends Base {
  _run(cb) {
    this.done = cb;

    var events = observe(this.rl),

      submit = events.line.pipe(map(this.filterInput.bind(this))),

      validation = this.handleSubmitEvents(submit);
    validation.success.forEach(this.onEnd.bind(this));
    validation.error.forEach(this.onError.bind(this));

    this.opt.mask && events.keypress.pipe(takeUntil(validation.success)).forEach(this.onKeypress.bind(this));

    this.render();

    return this;
  }

  render(error) {
    var message = this.getQuestion(),
      bottomContent = '';

    this.status === 'answered'
      ? (message += this.opt.mask ? chalk.cyan(mask(this.answer, this.opt.mask)) : chalk.italic.dim('[hidden]'))
      : this.opt.mask
      ? (message += mask(this.rl.line || '', this.opt.mask))
      : (message += chalk.italic.dim('[input is hidden] '));

    if (error) bottomContent = '\n' + chalk.red('>> ') + error;

    this.screen.render(message, bottomContent);
  }

  filterInput(input) {
    return input || (this.opt.default == null ? '' : this.opt.default);
  }

  onEnd(state) {
    this.status = 'answered';
    this.answer = state.value;

    this.render();

    this.screen.done();
    this.done(state.value);
  }

  onError(state) {
    this.render(state.isValid);
  }

  onKeypress() {
    this.render();
  }
}

module.exports = PasswordPrompt;
//
},
'inquirer/lib/prompts/editor':
function(module, exports, __wpreq__) {
//
var chalk = __wpreq__('chalk'),
  editAsync = __wpreq__('external-editor').editAsync,
  Base = __wpreq__('inquirer/lib/prompts/base'),
  observe = __wpreq__('inquirer/lib/utils/events'),
  Subject = __wpreq__('rxjs').Subject;

class EditorPrompt extends Base {
  _run(cb) {
    this.done = cb;

    this.editorResult = new Subject();

    var events = observe(this.rl);
    this.lineSubscription = events.line.subscribe(this.startExternalEditor.bind(this));

    var validation = this.handleSubmitEvents(this.editorResult);
    validation.success.forEach(this.onEnd.bind(this));
    validation.error.forEach(this.onError.bind(this));

    this.currentText = this.opt.default;
    this.opt.default = null;

    this.render();

    return this;
  }

  render(error) {
    var bottomContent = '',
      message = this.getQuestion();

    this.status === 'answered'
      ? (message += chalk.dim('Received'))
      : (message += chalk.dim('Press <enter> to launch your preferred editor.'));

    if (error) bottomContent = chalk.red('>> ') + error;

    this.screen.render(message, bottomContent);
  }

  startExternalEditor() {
    this.rl.pause();
    editAsync(this.currentText, this.endExternalEditor.bind(this));
  }

  endExternalEditor(error, result) {
    this.rl.resume();
    error ? this.editorResult.error(error) : this.editorResult.next(result);
  }

  onEnd(state) {
    this.editorResult.unsubscribe();
    this.lineSubscription.unsubscribe();
    this.answer = state.value;
    this.status = 'answered';
    this.render();
    this.screen.done();
    this.done(this.answer);
  }

  onError(state) {
    this.render(state.isValid);
  }
}

module.exports = EditorPrompt;
//
},
'external-editor':
function(module, exports, __wpreq__) {
//
var extendStatics = function(d, b) {
  return (extendStatics =
    Object.setPrototypeOf ||
    ({__proto__: []} instanceof Array && function(d, b) { d.__proto__ = b; }) ||
    function(d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; }
  )(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
}
Object.defineProperty(exports, "__esModule", {value: true});

var chardet_1 = __wpreq__('chardet'),
  child_process_1 = __wpreq__('child_process'),
  fs_1 = __wpreq__('fs'),
  iconv_lite_1 = __wpreq__('iconv-lite'),
  tmp_1 = __wpreq__('tmp');

var CreateFileError = (function(_super) {
  __extends(CreateFileError, _super);
  function CreateFileError(originalError) {
    var _newTarget = this.constructor,
      _this = _super.call(this, "Failed to create temporary file for editor") || this;
    _this.originalError = originalError;
    var proto = _newTarget.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(_this, proto) : (_this.__proto__ = _newTarget.prototype);

    return _this;
  }
  return CreateFileError;
})(Error);
exports.CreateFileError = CreateFileError;

var LaunchEditorError = (function(_super) {
  __extends(LaunchEditorError, _super);
  function LaunchEditorError(originalError) {
    var _newTarget = this.constructor,
      _this = _super.call(this, "Failed launch editor") || this;
    _this.originalError = originalError;
    var proto = _newTarget.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(_this, proto) : (_this.__proto__ = _newTarget.prototype);

    return _this;
  }
  return LaunchEditorError;
})(Error);
exports.LaunchEditorError = LaunchEditorError;

var ReadFileError = (function(_super) {
  __extends(ReadFileError, _super);
  function ReadFileError(originalError) {
    var _newTarget = this.constructor,
      _this = _super.call(this, "Failed to read temporary file") || this;
    _this.originalError = originalError;
    var proto = _newTarget.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(_this, proto) : (_this.__proto__ = _newTarget.prototype);

    return _this;
  }
  return ReadFileError;
})(Error);
exports.ReadFileError = ReadFileError;

var RemoveFileError = (function(_super) {
  __extends(RemoveFileError, _super);
  function RemoveFileError(originalError) {
    var _newTarget = this.constructor,
      _this = _super.call(this, "Failed to cleanup temporary file") || this;
    _this.originalError = originalError;
    var proto = _newTarget.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(_this, proto) : (_this.__proto__ = _newTarget.prototype);

    return _this;
  }
  return RemoveFileError;
})(Error);
exports.RemoveFileError = RemoveFileError;

function edit(text) {
  if (text === void 0) text = "";
  var editor = new ExternalEditor(text);
  editor.run();
  editor.cleanup();
  return editor.text;
}
exports.edit = edit;

function editAsync(text, callback) {
  if (text === void 0) text = "";
  var editor = new ExternalEditor(text);
  editor.runAsync(function(err, result) {
    if (err) setImmediate(callback, err, null);
    else
      try {
        editor.cleanup();
        setImmediate(callback, null, result);
      } catch (cleanupError) {
        setImmediate(callback, cleanupError, null);
      }
  });
}
exports.editAsync = editAsync;

// noinspection UnnecessaryLocalVariableJS
var ExternalEditor = (function() {
  function ExternalEditor(text) {
    if (text === void 0) text = "";
    this.text = "";
    this.text = text;
    this.determineEditor();
    this.createTemporaryFile();
  }
  ExternalEditor.splitStringBySpace = function(str) {
    var pieces = [],
      currentString = "";
    for (var strIndex = 0; strIndex < str.length; strIndex++) {
      var currentLetter = str[strIndex];
      if (strIndex > 0 && currentLetter === " " && str[strIndex - 1] !== "\\" && currentString.length > 0) {
        pieces.push(currentString);
        currentString = "";
      } else currentString += currentLetter;
    }
    currentString.length > 0 && pieces.push(currentString);

    return pieces;
  };
  Object.defineProperty(ExternalEditor.prototype, "temp_file", {
    get: function() {
      console.log("DEPRECATED: temp_file. Use tempFile moving forward.");
      return this.tempFile;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ExternalEditor.prototype, "last_exit_status", {
    get: function() {
      console.log("DEPRECATED: last_exit_status. Use lastExitStatus moving forward.");
      return this.lastExitStatus;
    },
    enumerable: true,
    configurable: true
  });
  ExternalEditor.prototype.run = function() {
    this.launchEditor();
    this.readTemporaryFile();
    return this.text;
  };
  ExternalEditor.prototype.runAsync = function(callback) {
    var _this = this;
    try {
      this.launchEditorAsync(function() {
        try {
          _this.readTemporaryFile();
          setImmediate(callback, null, _this.text);
        } catch (readError) {
          setImmediate(callback, readError, null);
        }
      });
    } catch (launchError) {
      setImmediate(callback, launchError, null);
    }
  };
  ExternalEditor.prototype.cleanup = function() {
    this.removeTemporaryFile();
  };
  ExternalEditor.prototype.determineEditor = function() {
    var editor = process.env.VISUAL ? process.env.VISUAL
      : process.env.EDITOR ? process.env.EDITOR
      : /^win/.test(process.platform) ? "notepad"
      : "vim";
    var editorOpts = ExternalEditor.splitStringBySpace(editor).map(function(piece) {
      return piece.replace("\\ ", " ");
    });
    var bin = editorOpts.shift();
    this.editor = {args: editorOpts, bin: bin};
  };
  ExternalEditor.prototype.createTemporaryFile = function() {
    try {
      this.tempFile = tmp_1.tmpNameSync({});
      fs_1.writeFileSync(this.tempFile, this.text, {encoding: "utf8"});
    } catch (createFileError) {
      throw new CreateFileError(createFileError);
    }
  };
  ExternalEditor.prototype.readTemporaryFile = function() {
    try {
      var tempFileBuffer = fs_1.readFileSync(this.tempFile);
      if (tempFileBuffer.length === 0) this.text = "";
      else {
        var encoding = chardet_1.detect(tempFileBuffer).toString();
        iconv_lite_1.encodingExists(encoding) || (encoding = "utf8");

        this.text = iconv_lite_1.decode(tempFileBuffer, encoding);
      }
    } catch (readFileError) {
      throw new ReadFileError(readFileError);
    }
  };
  ExternalEditor.prototype.removeTemporaryFile = function() {
    try {
      fs_1.unlinkSync(this.tempFile);
    } catch (removeFileError) {
      throw new RemoveFileError(removeFileError);
    }
  };
  ExternalEditor.prototype.launchEditor = function() {
    try {
      var editorProcess = child_process_1.spawnSync(this.editor.bin, this.editor.args.concat([this.tempFile]), {
        stdio: "inherit"
      });
      this.lastExitStatus = editorProcess.status;
    } catch (launchError) {
      throw new LaunchEditorError(launchError);
    }
  };
  ExternalEditor.prototype.launchEditorAsync = function(callback) {
    var _this = this;
    try {
      child_process_1
        .spawn(this.editor.bin, this.editor.args.concat([this.tempFile]), {stdio: "inherit"})
        .on("exit", function(code) {
          _this.lastExitStatus = code;
          setImmediate(callback);
        });
    } catch (launchError) {
      throw new LaunchEditorError(launchError);
    }
  };
  return ExternalEditor;
})();
exports.ExternalEditor = ExternalEditor;
//
},
chardet:
function(module, exports, __wpreq__) {
//
var fs = __wpreq__('fs'),

  utf8 = __wpreq__('chardet/encoding/utf8'),
  unicode = __wpreq__('chardet/encoding/unicode'),
  mbcs = __wpreq__('chardet/encoding/mbcs'),
  sbcs = __wpreq__('chardet/encoding/sbcs'),
  iso2022 = __wpreq__('chardet/encoding/iso2022'),

  self = this;

var recognisers = [
  new utf8(),
  new unicode.UTF_16BE(),
  new unicode.UTF_16LE(),
  new unicode.UTF_32BE(),
  new unicode.UTF_32LE(),
  new mbcs.sjis(),
  new mbcs.big5(),
  new mbcs.euc_jp(),
  new mbcs.euc_kr(),
  new mbcs.gb_18030(),
  new iso2022.ISO_2022_JP(),
  new iso2022.ISO_2022_KR(),
  new iso2022.ISO_2022_CN(),
  new sbcs.ISO_8859_1(),
  new sbcs.ISO_8859_2(),
  new sbcs.ISO_8859_5(),
  new sbcs.ISO_8859_6(),
  new sbcs.ISO_8859_7(),
  new sbcs.ISO_8859_8(),
  new sbcs.ISO_8859_9(),
  new sbcs.windows_1251(),
  new sbcs.windows_1256(),
  new sbcs.KOI8_R()
];

module.exports.detect = function(buffer, opts) {
  var fByteStats = [];
  for (var i = 0; i < 256; i++) fByteStats[i] = 0;

  for (i = buffer.length - 1; i >= 0; i--) fByteStats[buffer[i] & 0x00ff]++;

  var fC1Bytes = false;
  for (i = 0x80; i <= 0x9F; i += 1)
    if (fByteStats[i] != 0) {
      fC1Bytes = true;
      break;
    }

  var context = {
    fByteStats: fByteStats,
    fC1Bytes: fC1Bytes,
    fRawInput: buffer,
    fRawLength: buffer.length,
    fInputBytes: buffer,
    fInputLen: buffer.length
  };

  var matches = recognisers.map(function(rec) {
    return rec.match(context);
  }).filter(function(match) {
    return !!match;
  }).sort(function(a, b) {
    return b.confidence - a.confidence;
  });

  return opts && opts.returnAllMatches === true ? matches : matches.length > 0 ? matches[0].name : null;
};

module.exports.detectFile = function(filepath, opts, cb) {
  if (typeof opts == 'function') {
    cb = opts;
    opts = void 0;
  }

  var fd;
  var handler = function(err, buffer) {
    fd && fs.closeSync(fd);

    if (err) return cb(err, null);
    cb(null, self.detect(buffer, opts));
  };

  if (opts && opts.sampleSize) {
    fd = fs.openSync(filepath, 'r');
    var sample = Buffer.allocUnsafe(opts.sampleSize);

    fs.read(fd, sample, 0, opts.sampleSize, null, function(err) {
      handler(err, sample);
    });
  } else fs.readFile(filepath, handler);
};

module.exports.detectFileSync = function(filepath, opts) {
  if (opts && opts.sampleSize) {
    var fd = fs.openSync(filepath, 'r'),
      sample = Buffer.allocUnsafe(opts.sampleSize);

    fs.readSync(fd, sample, 0, opts.sampleSize);
    fs.closeSync(fd);
    return self.detect(sample, opts);
  }

  return self.detect(fs.readFileSync(filepath), opts);
};

module.exports.detectAll = function(buffer, opts) {
  if (typeof opts != 'object') opts = {};

  opts.returnAllMatches = true;
  return self.detect(buffer, opts);
}

module.exports.detectFileAll = function(filepath, opts, cb) {
  if (typeof opts == 'function') {
    cb = opts;
    opts = void 0;
  }
  if (typeof opts != 'object') opts = {};

  opts.returnAllMatches = true;
  self.detectFile(filepath, opts, cb);
}

module.exports.detectFileAllSync = function(filepath, opts) {
  if (typeof opts != 'object') opts = {};

  opts.returnAllMatches = true;
  return self.detectFileSync(filepath, opts);
}
//
},
'chardet/encoding/utf8':
function(module, exports, __wpreq__) {
//
var Match = __wpreq__('chardet/match');

module.exports = function() {
  this.name = function() {
    return 'UTF-8';
  };
  this.match = function(det) {
    var confidence,
      hasBOM = false,
      numValid = 0,
      numInvalid = 0,
      input = det.fRawInput,
      trailBytes = 0;

    if (det.fRawLength >= 3 && (input[0] & 0xff) == 0xef && (input[1] & 0xff) == 0xbb && (input[2] & 0xff) == 0xbf)
      hasBOM = true;

    for (var i = 0; i < det.fRawLength; i++) {
      var b = input[i];
      if ((b & 0x80) == 0) continue;

      if ((b & 0x0e0) == 0x0c0) trailBytes = 1;
      else if ((b & 0x0f0) == 0x0e0) trailBytes = 2;
      else if ((b & 0x0f8) == 0xf0) trailBytes = 3;
      else {
        if (++numInvalid > 5) break;
        trailBytes = 0;
      }

      for (; ++i < det.fRawLength; ) {
        if ((input[i] & 0xc0) != 0x080) {
          numInvalid++;
          break;
        }
        if (--trailBytes == 0) {
          numValid++;
          break;
        }
      }
    }

    confidence = 0;
    if (hasBOM && numInvalid == 0) confidence = 100;
    else if (hasBOM && numValid > numInvalid * 10) confidence = 80;
    else if (numValid > 3 && numInvalid == 0) confidence = 100;
    else if (numValid > 0 && numInvalid == 0) confidence = 80;
    else if (numValid == 0 && numInvalid == 0) confidence = 10;
    else if (numValid > numInvalid * 10) confidence = 25;
    else return null

    return new Match(det, this, confidence);
  };
};
//
},
'chardet/match':
function(module) {
//
module.exports = function(det, rec, confidence, name, lang) {
  this.confidence = confidence;
  this.name = name || rec.name(det);
  this.lang = lang;
};
//
},
'chardet/encoding/unicode':
function(module, exports, __wpreq__) {
//
var util = __wpreq__('util'),
  Match = __wpreq__('chardet/match');

module.exports.UTF_16BE = function() {
  this.name = function() {
    return 'UTF-16BE';
  };
  this.match = function(det) {
    var input = det.fRawInput;

    return input.length >= 2 && (input[0] & 0xff) == 0xfe && (input[1] & 0xff) == 0xff
      ? new Match(det, this, 100)
      : null;
  };
};

module.exports.UTF_16LE = function() {
  this.name = function() {
    return 'UTF-16LE';
  };
  this.match = function(det) {
    var input = det.fRawInput;

    return input.length >= 2 && (input[0] & 0xff) == 0xff && (input[1] & 0xff) == 0xfe
      ? input.length >= 4 && input[2] == 0x00 && input[3] == 0x00
        ? null
        : new Match(det, this, 100)
      : null;
  }
};

function UTF_32() {}
UTF_32.prototype.match = function(det) {
  var input = det.fRawInput,
    limit = (det.fRawLength / 4) * 4,
    numValid = 0,
    numInvalid = 0,
    hasBOM = false,
    confidence = 0;

  if (limit == 0) return null;

  if (this.getChar(input, 0) == 0x0000FEFF) hasBOM = true;

  for (var i = 0; i < limit; i += 4) {
    var ch = this.getChar(input, i);

    ch < 0 || ch >= 0x10FFFF || (ch >= 0xD800 && ch <= 0xDFFF) ? (numInvalid += 1) : (numValid += 1);
  }

  if (hasBOM && numInvalid == 0) confidence = 100;
  else if (hasBOM && numValid > numInvalid * 10) confidence = 80;
  else if (numValid > 3 && numInvalid == 0) confidence = 100;
  else if (numValid > 0 && numInvalid == 0) confidence = 80;
  else if (numValid > numInvalid * 10) confidence = 25;

  return confidence == 0 ? null : new Match(det, this, confidence);
};

module.exports.UTF_32BE = function() {
  this.name = function() {
    return 'UTF-32BE';
  };
  this.getChar = function(input, index) {
    return (
      ((input[index + 0] & 0xff) << 24) | ((input[index + 1] & 0xff) << 16) |
      ((input[index + 2] & 0xff) << 8) | (input[index + 3] & 0xff)
    );
  };
};
util.inherits(module.exports.UTF_32BE, UTF_32);

module.exports.UTF_32LE = function() {
  this.name = function() {
    return 'UTF-32LE';
  };
  this.getChar = function(input, index) {
    return (
      ((input[index + 3] & 0xff) << 24) | ((input[index + 2] & 0xff) << 16) |
      ((input[index + 1] & 0xff) << 8) | (input[index + 0] & 0xff)
    );
  };
};
util.inherits(module.exports.UTF_32LE, UTF_32);
//
},
'chardet/encoding/mbcs':
function(module, exports, __wpreq__) {
//
var util = __wpreq__('util'),
  Match = __wpreq__('chardet/match');

function binarySearch(arr, searchValue) {
  function find(arr, searchValue, left, right) {
    if (right < left) return -1;

    var mid = Math.floor((left + right) >>> 1);
    return searchValue > arr[mid]
      ? find(arr, searchValue, mid + 1, right)
      : searchValue < arr[mid]
      ? find(arr, searchValue, left, mid - 1)
      : mid;
  }

  return find(arr, searchValue, 0, arr.length - 1);
}

function IteratedChar() {
  this.charValue = 0;
  this.index = 0;
  this.nextIndex = 0;
  this.error = false;
  this.done = false;

  this.reset = function() {
    this.charValue = 0;
    this.index = -1;
    this.nextIndex = 0;
    this.error = false;
    this.done = false;
  };

  this.nextByte = function(det) {
    if (this.nextIndex >= det.fRawLength) {
      this.done = true;
      return -1;
    }
    return det.fRawInput[this.nextIndex++] & 0x00ff;
  };
}

/** @class */
function mbcs() {}

mbcs.prototype.match = function(det) {
  var singleByteCharCount = 0,
    doubleByteCharCount = 0,
    commonCharCount = 0,
    badCharCount = 0,
    totalCharCount = 0,
    confidence = 0,

    iter = new IteratedChar();

  detectBlock: {
    for (iter.reset(); this.nextChar(iter, det); ) {
      totalCharCount++;
      if (iter.error) badCharCount++;
      else {
        var cv = iter.charValue & 0xFFFFFFFF;

        if (cv <= 0xff) singleByteCharCount++;
        else {
          doubleByteCharCount++;
          this.commonChars != null && binarySearch(this.commonChars, cv) >= 0 && commonCharCount++;
        }
      }
      if (badCharCount >= 2 && badCharCount * 5 >= doubleByteCharCount) break detectBlock;
    }

    if (doubleByteCharCount <= 10 && badCharCount == 0)
      confidence = doubleByteCharCount == 0 && totalCharCount < 10 ? 0 : 10;
    else if (doubleByteCharCount < 20 * badCharCount) confidence = 0;
    else if (this.commonChars == null) {
      if ((confidence = 30 + doubleByteCharCount - 20 * badCharCount) > 100) confidence = 100;
    } else {
      var scaleFactor = 90.0 / Math.log(parseFloat(doubleByteCharCount) / 4);
      confidence = Math.floor(Math.log(commonCharCount + 1) * scaleFactor + 10);
      confidence = Math.min(confidence, 100);
    }
  }

  return confidence == 0 ? null : new Match(det, this, confidence);
};

mbcs.prototype.nextChar = function(iter, det) {};

module.exports.sjis = function() {
  this.name = function() {
    return 'Shift-JIS';
  };
  this.language = function() {
    return 'ja';
  };

  this.commonChars = [
    0x8140, 0x8141, 0x8142, 0x8145, 0x815b, 0x8169, 0x816a, 0x8175, 0x8176, 0x82a0, 0x82a2, 0x82a4, 0x82a9, 0x82aa,
    0x82ab, 0x82ad, 0x82af, 0x82b1, 0x82b3, 0x82b5, 0x82b7, 0x82bd, 0x82be, 0x82c1, 0x82c4, 0x82c5, 0x82c6, 0x82c8,
    0x82c9, 0x82cc, 0x82cd, 0x82dc, 0x82e0, 0x82e7, 0x82e8, 0x82e9, 0x82ea, 0x82f0, 0x82f1, 0x8341, 0x8343, 0x834e,
    0x834f, 0x8358, 0x835e, 0x8362, 0x8367, 0x8375, 0x8376, 0x8389, 0x838a, 0x838b, 0x838d, 0x8393, 0x8e96, 0x93fa,
    0x95aa
  ];

  this.nextChar = function(iter, det) {
    iter.index = iter.nextIndex;
    iter.error = false;

    var firstByte;
    if ((firstByte = iter.charValue = iter.nextByte(det)) < 0) return false;

    if (firstByte <= 0x7f || (firstByte > 0xa0 && firstByte <= 0xdf)) return true;

    var secondByte = iter.nextByte(det);
    if (secondByte < 0) return false;

    iter.charValue = (firstByte << 8) | secondByte;
    (secondByte >= 0x40 && secondByte <= 0x7f) || (secondByte >= 0x80 && secondByte <= 0xff) || (iter.error = true);

    return true;
  };
};
util.inherits(module.exports.sjis, mbcs);

module.exports.big5 = function() {
  this.name = function() {
    return 'Big5';
  };
  this.language = function() {
    return 'zh';
  };
  this.commonChars = [
    0xa140, 0xa141, 0xa142, 0xa143, 0xa147, 0xa149, 0xa175, 0xa176, 0xa440, 0xa446, 0xa447, 0xa448, 0xa451, 0xa454,
    0xa457, 0xa464, 0xa46a, 0xa46c, 0xa477, 0xa4a3, 0xa4a4, 0xa4a7, 0xa4c1, 0xa4ce, 0xa4d1, 0xa4df, 0xa4e8, 0xa4fd,
    0xa540, 0xa548, 0xa558, 0xa569, 0xa5cd, 0xa5e7, 0xa657, 0xa661, 0xa662, 0xa668, 0xa670, 0xa6a8, 0xa6b3, 0xa6b9,
    0xa6d3, 0xa6db, 0xa6e6, 0xa6f2, 0xa740, 0xa751, 0xa759, 0xa7da, 0xa8a3, 0xa8a5, 0xa8ad, 0xa8d1, 0xa8d3, 0xa8e4,
    0xa8fc, 0xa9c0, 0xa9d2, 0xa9f3, 0xaa6b, 0xaaba, 0xaabe, 0xaacc, 0xaafc, 0xac47, 0xac4f, 0xacb0, 0xacd2, 0xad59,
    0xaec9, 0xafe0, 0xb0ea, 0xb16f, 0xb2b3, 0xb2c4, 0xb36f, 0xb44c, 0xb44e, 0xb54c, 0xb5a5, 0xb5bd, 0xb5d0, 0xb5d8,
    0xb671, 0xb7ed, 0xb867, 0xb944, 0xbad8, 0xbb44, 0xbba1, 0xbdd1, 0xc2c4, 0xc3b9, 0xc440, 0xc45f
  ];
  this.nextChar = function(iter, det) {
    iter.index = iter.nextIndex;
    iter.error = false;

    var firstByte = (iter.charValue = iter.nextByte(det));
    if (firstByte < 0) return false;

    if (firstByte <= 0x7f || firstByte == 0xff) return true;

    var secondByte = iter.nextByte(det);
    if (secondByte < 0) return false;

    iter.charValue = (iter.charValue << 8) | secondByte;
    if (secondByte < 0x40 || secondByte == 0x7f || secondByte == 0xff) iter.error = true;

    return true;
  };
};
util.inherits(module.exports.big5, mbcs);

function eucNextChar(iter, det) {
  iter.index = iter.nextIndex;
  iter.error = false;
  var firstByte, //= 0
    secondByte = 0,
    thirdByte = 0;
  //buildChar:
  if ((firstByte = iter.charValue = iter.nextByte(det)) < 0) iter.done = true;
  else if (firstByte > 0x8d) {
    secondByte = iter.nextByte(det);
    iter.charValue = (iter.charValue << 8) | secondByte;
    if (firstByte >= 0xA1 && firstByte <= 0xfe) {
      if (secondByte < 0xa1) iter.error = true;
    } else if (firstByte == 0x8e) {
      if (secondByte < 0xa1) iter.error = true;
    } else if (firstByte == 0x8f) {
      thirdByte = iter.nextByte(det);
      iter.charValue = (iter.charValue << 8) | thirdByte;
      if (thirdByte < 0xa1) iter.error = true;
    }
  }

  return iter.done == 0;
}

module.exports.euc_jp = function() {
  this.name = function() {
    return 'EUC-JP';
  };
  this.language = function() {
    return 'ja';
  };

  this.commonChars = [
    0xa1a1, 0xa1a2, 0xa1a3, 0xa1a6, 0xa1bc, 0xa1ca, 0xa1cb, 0xa1d6, 0xa1d7, 0xa4a2, 0xa4a4, 0xa4a6, 0xa4a8, 0xa4aa,
    0xa4ab, 0xa4ac, 0xa4ad, 0xa4af, 0xa4b1, 0xa4b3, 0xa4b5, 0xa4b7, 0xa4b9, 0xa4bb, 0xa4bd, 0xa4bf, 0xa4c0, 0xa4c1,
    0xa4c3, 0xa4c4, 0xa4c6, 0xa4c7, 0xa4c8, 0xa4c9, 0xa4ca, 0xa4cb, 0xa4ce, 0xa4cf, 0xa4d0, 0xa4de, 0xa4df, 0xa4e1,
    0xa4e2, 0xa4e4, 0xa4e8, 0xa4e9, 0xa4ea, 0xa4eb, 0xa4ec, 0xa4ef, 0xa4f2, 0xa4f3, 0xa5a2, 0xa5a3, 0xa5a4, 0xa5a6,
    0xa5a7, 0xa5aa, 0xa5ad, 0xa5af, 0xa5b0, 0xa5b3, 0xa5b5, 0xa5b7, 0xa5b8, 0xa5b9, 0xa5bf, 0xa5c3, 0xa5c6, 0xa5c7,
    0xa5c8, 0xa5c9, 0xa5cb, 0xa5d0, 0xa5d5, 0xa5d6, 0xa5d7, 0xa5de, 0xa5e0, 0xa5e1, 0xa5e5, 0xa5e9, 0xa5ea, 0xa5eb,
    0xa5ec, 0xa5ed, 0xa5f3, 0xb8a9, 0xb9d4, 0xbaee, 0xbbc8, 0xbef0, 0xbfb7, 0xc4ea, 0xc6fc, 0xc7bd, 0xcab8, 0xcaf3,
    0xcbdc, 0xcdd1
  ];

  this.nextChar = eucNextChar;
};
util.inherits(module.exports.euc_jp, mbcs);

module.exports.euc_kr = function() {
  this.name = function() {
    return 'EUC-KR';
  };
  this.language = function() {
    return 'ko';
  };

  this.commonChars = [
    0xb0a1, 0xb0b3, 0xb0c5, 0xb0cd, 0xb0d4, 0xb0e6, 0xb0ed, 0xb0f8, 0xb0fa, 0xb0fc, 0xb1b8, 0xb1b9, 0xb1c7, 0xb1d7,
    0xb1e2, 0xb3aa, 0xb3bb, 0xb4c2, 0xb4cf, 0xb4d9, 0xb4eb, 0xb5a5, 0xb5b5, 0xb5bf, 0xb5c7, 0xb5e9, 0xb6f3, 0xb7af,
    0xb7c2, 0xb7ce, 0xb8a6, 0xb8ae, 0xb8b6, 0xb8b8, 0xb8bb, 0xb8e9, 0xb9ab, 0xb9ae, 0xb9cc, 0xb9ce, 0xb9fd, 0xbab8,
    0xbace, 0xbad0, 0xbaf1, 0xbbe7, 0xbbf3, 0xbbfd, 0xbcad, 0xbcba, 0xbcd2, 0xbcf6, 0xbdba, 0xbdc0, 0xbdc3, 0xbdc5,
    0xbec6, 0xbec8, 0xbedf, 0xbeee, 0xbef8, 0xbefa, 0xbfa1, 0xbfa9, 0xbfc0, 0xbfe4, 0xbfeb, 0xbfec, 0xbff8, 0xc0a7,
    0xc0af, 0xc0b8, 0xc0ba, 0xc0bb, 0xc0bd, 0xc0c7, 0xc0cc, 0xc0ce, 0xc0cf, 0xc0d6, 0xc0da, 0xc0e5, 0xc0fb, 0xc0fc,
    0xc1a4, 0xc1a6, 0xc1b6, 0xc1d6, 0xc1df, 0xc1f6, 0xc1f8, 0xc4a1, 0xc5cd, 0xc6ae, 0xc7cf, 0xc7d1, 0xc7d2, 0xc7d8,
    0xc7e5, 0xc8ad
  ];

  this.nextChar = eucNextChar;
};
util.inherits(module.exports.euc_kr, mbcs);

module.exports.gb_18030 = function() {
  this.name = function() {
    return 'GB18030';
  };
  this.language = function() {
    return 'zh';
  };

  this.nextChar = function(iter, det) {
    iter.index = iter.nextIndex;
    iter.error = false;
    var firstByte, //= 0
      secondByte = 0,
      thirdByte = 0,
      fourthByte = 0;
    buildChar: if ((firstByte = iter.charValue = iter.nextByte(det)) < 0) iter.done = true;
    else if (firstByte > 0x80) {
      secondByte = iter.nextByte(det);
      iter.charValue = (iter.charValue << 8) | secondByte;
      if (firstByte >= 0x81 && firstByte <= 0xFE) {
        if ((secondByte >= 0x40 && secondByte <= 0x7E) || (secondByte >= 80 && secondByte <= 0xFE)) break buildChar;

        if (
          secondByte >= 0x30 && secondByte <= 0x39 &&
          (thirdByte = iter.nextByte(det)) >= 0x81 && thirdByte <= 0xFE &&
          (fourthByte = iter.nextByte(det)) >= 0x30 && fourthByte <= 0x39
        ) {
          iter.charValue = (iter.charValue << 16) | (thirdByte << 8) | fourthByte;
          break buildChar;
        }
        iter.error = true;
      }
    }
    return iter.done == 0;
  };

  this.commonChars = [
    0xa1a1, 0xa1a2, 0xa1a3, 0xa1a4, 0xa1b0, 0xa1b1, 0xa1f1, 0xa1f3, 0xa3a1, 0xa3ac, 0xa3ba, 0xb1a8, 0xb1b8, 0xb1be,
    0xb2bb, 0xb3c9, 0xb3f6, 0xb4f3, 0xb5bd, 0xb5c4, 0xb5e3, 0xb6af, 0xb6d4, 0xb6e0, 0xb7a2, 0xb7a8, 0xb7bd, 0xb7d6,
    0xb7dd, 0xb8b4, 0xb8df, 0xb8f6, 0xb9ab, 0xb9c9, 0xb9d8, 0xb9fa, 0xb9fd, 0xbacd, 0xbba7, 0xbbd6, 0xbbe1, 0xbbfa,
    0xbcbc, 0xbcdb, 0xbcfe, 0xbdcc, 0xbecd, 0xbedd, 0xbfb4, 0xbfc6, 0xbfc9, 0xc0b4, 0xc0ed, 0xc1cb, 0xc2db, 0xc3c7,
    0xc4dc, 0xc4ea, 0xc5cc, 0xc6f7, 0xc7f8, 0xc8ab, 0xc8cb, 0xc8d5, 0xc8e7, 0xc9cf, 0xc9fa, 0xcab1, 0xcab5, 0xcac7,
    0xcad0, 0xcad6, 0xcaf5, 0xcafd, 0xccec, 0xcdf8, 0xceaa, 0xcec4, 0xced2, 0xcee5, 0xcfb5, 0xcfc2, 0xcfd6, 0xd0c2,
    0xd0c5, 0xd0d0, 0xd0d4, 0xd1a7, 0xd2aa, 0xd2b2, 0xd2b5, 0xd2bb, 0xd2d4, 0xd3c3, 0xd3d0, 0xd3fd, 0xd4c2, 0xd4da,
    0xd5e2, 0xd6d0
  ];
};
util.inherits(module.exports.gb_18030, mbcs);
//
},
'chardet/encoding/sbcs':
function(module, exports, __wpreq__) {
//
var util = __wpreq__('util'),
  Match = __wpreq__('chardet/match');

function NGramParser(theNgramList, theByteMap) {
  var N_GRAM_MASK = 0xFFFFFF;

  this.byteIndex = 0;
  this.ngram = 0;

  this.ngramList = theNgramList;
  this.byteMap = theByteMap;

  this.ngramCount = 0;
  this.hitCount = 0;

  this.spaceChar = void 0;

  this.search = function(table, value) {
    var index = 0;

    if (table[index + 32] <= value) index += 32;
    if (table[index + 16] <= value) index += 16;
    if (table[index + 8] <= value) index += 8;
    if (table[index + 4] <= value) index += 4;
    if (table[index + 2] <= value) index += 2;
    if (table[index + 1] <= value) index += 1;
    if (table[index] > value) index -= 1;

    return index < 0 || table[index] != value ? -1 : index;
  };

  this.lookup = function(thisNgram) {
    this.ngramCount += 1;
    if (this.search(this.ngramList, thisNgram) >= 0) this.hitCount += 1;
  };

  this.addByte = function(b) {
    this.ngram = ((this.ngram << 8) + (b & 0xFF)) & N_GRAM_MASK;
    this.lookup(this.ngram);
  }

  this.nextByte = function(det) {
    return this.byteIndex >= det.fInputLen ? -1 : det.fInputBytes[this.byteIndex++] & 0xFF;
  }

  this.parse = function(det, spaceCh) {
    var ignoreSpace = false;
    this.spaceChar = spaceCh;

    for (var b; (b = this.nextByte(det)) >= 0; ) {
      var mb = this.byteMap[b];

      if (mb != 0) {
        (mb == this.spaceChar && ignoreSpace) || this.addByte(mb);

        ignoreSpace = mb == this.spaceChar;
      }
    }

    this.addByte(this.spaceChar);

    var rawPercent = this.hitCount / this.ngramCount;

    return rawPercent > 0.33 ? 98 : Math.floor(rawPercent * 300.0);
  };
}

function NGramsPlusLang(la, ng) {
  this.fLang = la;
  this.fNGrams = ng;
}

/** @class */
function sbcs() {}
sbcs.prototype.spaceChar = 0x20;
sbcs.prototype.ngrams = function() {};
sbcs.prototype.byteMap = function() {};
sbcs.prototype.match = function(det) {
  var ngrams = this.ngrams();

  if (!(Array.isArray(ngrams) && ngrams[0] instanceof NGramsPlusLang))
    return (confidence = new NGramParser(ngrams, this.byteMap()).parse(det, this.spaceChar)) <= 0
      ? null
      : new Match(det, this, confidence);

  var bestConfidenceSoFar = -1,
    lang = null;

  for (var i = ngrams.length - 1; i >= 0; i--) {
    var ngl = ngrams[i],

      confidence = new NGramParser(ngl.fNGrams, this.byteMap()).parse(det, this.spaceChar);
    if (confidence > bestConfidenceSoFar) {
      bestConfidenceSoFar = confidence;
      lang = ngl.fLang;
    }
  }

  var name = this.name(det);
  return bestConfidenceSoFar <= 0 ? null : new Match(det, this, bestConfidenceSoFar, name, lang);
};

module.exports.ISO_8859_1 = function() {
  this.byteMap = function() {
    return [
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B,
      0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
      0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xAA,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20, 0x20, 0x20, 0xBA, 0x20, 0x20, 0x20,
      0x20, 0x20, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0,
      0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3,
      0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6,
      0x20, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
    ];
  };

  this.ngrams = function() {
    return [
      new NGramsPlusLang('da', [
        0x206166, 0x206174, 0x206465, 0x20656E, 0x206572, 0x20666F, 0x206861, 0x206920, 0x206D65, 0x206F67, 0x2070E5,
        0x207369, 0x207374, 0x207469, 0x207669, 0x616620, 0x616E20, 0x616E64, 0x617220, 0x617420, 0x646520, 0x64656E,
        0x646572, 0x646574, 0x652073, 0x656420, 0x656465, 0x656E20, 0x656E64, 0x657220, 0x657265, 0x657320, 0x657420,
        0x666F72, 0x676520, 0x67656E, 0x676572, 0x696765, 0x696C20, 0x696E67, 0x6B6520, 0x6B6B65, 0x6C6572, 0x6C6967,
        0x6C6C65, 0x6D6564, 0x6E6465, 0x6E6520, 0x6E6720, 0x6E6765, 0x6F6720, 0x6F6D20, 0x6F7220, 0x70E520, 0x722064,
        0x722065, 0x722073, 0x726520, 0x737465, 0x742073, 0x746520, 0x746572, 0x74696C, 0x766572
      ]),
      new NGramsPlusLang('de', [
        0x20616E, 0x206175, 0x206265, 0x206461, 0x206465, 0x206469, 0x206569, 0x206765, 0x206861, 0x20696E, 0x206D69,
        0x207363, 0x207365, 0x20756E, 0x207665, 0x20766F, 0x207765, 0x207A75, 0x626572, 0x636820, 0x636865, 0x636874,
        0x646173, 0x64656E, 0x646572, 0x646965, 0x652064, 0x652073, 0x65696E, 0x656974, 0x656E20, 0x657220, 0x657320,
        0x67656E, 0x68656E, 0x687420, 0x696368, 0x696520, 0x696E20, 0x696E65, 0x697420, 0x6C6963, 0x6C6C65, 0x6E2061,
        0x6E2064, 0x6E2073, 0x6E6420, 0x6E6465, 0x6E6520, 0x6E6720, 0x6E6765, 0x6E7465, 0x722064, 0x726465, 0x726569,
        0x736368, 0x737465, 0x742064, 0x746520, 0x74656E, 0x746572, 0x756E64, 0x756E67, 0x766572
      ]),
      new NGramsPlusLang('en', [
        0x206120, 0x20616E, 0x206265, 0x20636F, 0x20666F, 0x206861, 0x206865, 0x20696E, 0x206D61, 0x206F66, 0x207072,
        0x207265, 0x207361, 0x207374, 0x207468, 0x20746F, 0x207768, 0x616964, 0x616C20, 0x616E20, 0x616E64, 0x617320,
        0x617420, 0x617465, 0x617469, 0x642061, 0x642074, 0x652061, 0x652073, 0x652074, 0x656420, 0x656E74, 0x657220,
        0x657320, 0x666F72, 0x686174, 0x686520, 0x686572, 0x696420, 0x696E20, 0x696E67, 0x696F6E, 0x697320, 0x6E2061,
        0x6E2074, 0x6E6420, 0x6E6720, 0x6E7420, 0x6F6620, 0x6F6E20, 0x6F7220, 0x726520, 0x727320, 0x732061, 0x732074,
        0x736169, 0x737420, 0x742074, 0x746572, 0x746861, 0x746865, 0x74696F, 0x746F20, 0x747320
      ]),
      new NGramsPlusLang('es', [
        0x206120, 0x206361, 0x20636F, 0x206465, 0x20656C, 0x20656E, 0x206573, 0x20696E, 0x206C61, 0x206C6F, 0x207061,
        0x20706F, 0x207072, 0x207175, 0x207265, 0x207365, 0x20756E, 0x207920, 0x612063, 0x612064, 0x612065, 0x61206C,
        0x612070, 0x616369, 0x61646F, 0x616C20, 0x617220, 0x617320, 0x6369F3, 0x636F6E, 0x646520, 0x64656C, 0x646F20,
        0x652064, 0x652065, 0x65206C, 0x656C20, 0x656E20, 0x656E74, 0x657320, 0x657374, 0x69656E, 0x69F36E, 0x6C6120,
        0x6C6F73, 0x6E2065, 0x6E7465, 0x6F2064, 0x6F2065, 0x6F6E20, 0x6F7220, 0x6F7320, 0x706172, 0x717565, 0x726120,
        0x726573, 0x732064, 0x732065, 0x732070, 0x736520, 0x746520, 0x746F20, 0x756520, 0xF36E20
      ]),
      new NGramsPlusLang('fr', [
        0x206175, 0x20636F, 0x206461, 0x206465, 0x206475, 0x20656E, 0x206574, 0x206C61, 0x206C65, 0x207061, 0x20706F,
        0x207072, 0x207175, 0x207365, 0x20736F, 0x20756E, 0x20E020, 0x616E74, 0x617469, 0x636520, 0x636F6E, 0x646520,
        0x646573, 0x647520, 0x652061, 0x652063, 0x652064, 0x652065, 0x65206C, 0x652070, 0x652073, 0x656E20, 0x656E74,
        0x657220, 0x657320, 0x657420, 0x657572, 0x696F6E, 0x697320, 0x697420, 0x6C6120, 0x6C6520, 0x6C6573, 0x6D656E,
        0x6E2064, 0x6E6520, 0x6E7320, 0x6E7420, 0x6F6E20, 0x6F6E74, 0x6F7572, 0x717565, 0x72206C, 0x726520, 0x732061,
        0x732064, 0x732065, 0x73206C, 0x732070, 0x742064, 0x746520, 0x74696F, 0x756520, 0x757220
      ]),
      new NGramsPlusLang('it', [
        0x20616C, 0x206368, 0x20636F, 0x206465, 0x206469, 0x206520, 0x20696C, 0x20696E, 0x206C61, 0x207065, 0x207072,
        0x20756E, 0x612063, 0x612064, 0x612070, 0x612073, 0x61746F, 0x636865, 0x636F6E, 0x64656C, 0x646920, 0x652061,
        0x652063, 0x652064, 0x652069, 0x65206C, 0x652070, 0x652073, 0x656C20, 0x656C6C, 0x656E74, 0x657220, 0x686520,
        0x692061, 0x692063, 0x692064, 0x692073, 0x696120, 0x696C20, 0x696E20, 0x696F6E, 0x6C6120, 0x6C6520, 0x6C6920,
        0x6C6C61, 0x6E6520, 0x6E6920, 0x6E6F20, 0x6E7465, 0x6F2061, 0x6F2064, 0x6F2069, 0x6F2073, 0x6F6E20, 0x6F6E65,
        0x706572, 0x726120, 0x726520, 0x736920, 0x746120, 0x746520, 0x746920, 0x746F20, 0x7A696F
      ]),
      new NGramsPlusLang('nl', [
        0x20616C, 0x206265, 0x206461, 0x206465, 0x206469, 0x206565, 0x20656E, 0x206765, 0x206865, 0x20696E, 0x206D61,
        0x206D65, 0x206F70, 0x207465, 0x207661, 0x207665, 0x20766F, 0x207765, 0x207A69, 0x61616E, 0x616172, 0x616E20,
        0x616E64, 0x617220, 0x617420, 0x636874, 0x646520, 0x64656E, 0x646572, 0x652062, 0x652076, 0x65656E, 0x656572,
        0x656E20, 0x657220, 0x657273, 0x657420, 0x67656E, 0x686574, 0x696520, 0x696E20, 0x696E67, 0x697320, 0x6E2062,
        0x6E2064, 0x6E2065, 0x6E2068, 0x6E206F, 0x6E2076, 0x6E6465, 0x6E6720, 0x6F6E64, 0x6F6F72, 0x6F7020, 0x6F7220,
        0x736368, 0x737465, 0x742064, 0x746520, 0x74656E, 0x746572, 0x76616E, 0x766572, 0x766F6F
      ]),
      new NGramsPlusLang('no', [
        0x206174, 0x206176, 0x206465, 0x20656E, 0x206572, 0x20666F, 0x206861, 0x206920, 0x206D65, 0x206F67, 0x2070E5,
        0x207365, 0x20736B, 0x20736F, 0x207374, 0x207469, 0x207669, 0x20E520, 0x616E64, 0x617220, 0x617420, 0x646520,
        0x64656E, 0x646574, 0x652073, 0x656420, 0x656E20, 0x656E65, 0x657220, 0x657265, 0x657420, 0x657474, 0x666F72,
        0x67656E, 0x696B6B, 0x696C20, 0x696E67, 0x6B6520, 0x6B6B65, 0x6C6520, 0x6C6C65, 0x6D6564, 0x6D656E, 0x6E2073,
        0x6E6520, 0x6E6720, 0x6E6765, 0x6E6E65, 0x6F6720, 0x6F6D20, 0x6F7220, 0x70E520, 0x722073, 0x726520, 0x736F6D,
        0x737465, 0x742073, 0x746520, 0x74656E, 0x746572, 0x74696C, 0x747420, 0x747465, 0x766572
      ]),
      new NGramsPlusLang('pt', [
        0x206120, 0x20636F, 0x206461, 0x206465, 0x20646F, 0x206520, 0x206573, 0x206D61, 0x206E6F, 0x206F20, 0x207061,
        0x20706F, 0x207072, 0x207175, 0x207265, 0x207365, 0x20756D, 0x612061, 0x612063, 0x612064, 0x612070, 0x616465,
        0x61646F, 0x616C20, 0x617220, 0x617261, 0x617320, 0x636F6D, 0x636F6E, 0x646120, 0x646520, 0x646F20, 0x646F73,
        0x652061, 0x652064, 0x656D20, 0x656E74, 0x657320, 0x657374, 0x696120, 0x696361, 0x6D656E, 0x6E7465, 0x6E746F,
        0x6F2061, 0x6F2063, 0x6F2064, 0x6F2065, 0x6F2070, 0x6F7320, 0x706172, 0x717565, 0x726120, 0x726573, 0x732061,
        0x732064, 0x732065, 0x732070, 0x737461, 0x746520, 0x746F20, 0x756520, 0xE36F20, 0xE7E36F
      ]),
      new NGramsPlusLang('sv', [
        0x206174, 0x206176, 0x206465, 0x20656E, 0x2066F6, 0x206861, 0x206920, 0x20696E, 0x206B6F, 0x206D65, 0x206F63,
        0x2070E5, 0x20736B, 0x20736F, 0x207374, 0x207469, 0x207661, 0x207669, 0x20E472, 0x616465, 0x616E20, 0x616E64,
        0x617220, 0x617474, 0x636820, 0x646520, 0x64656E, 0x646572, 0x646574, 0x656420, 0x656E20, 0x657220, 0x657420,
        0x66F672, 0x67656E, 0x696C6C, 0x696E67, 0x6B6120, 0x6C6C20, 0x6D6564, 0x6E2073, 0x6E6120, 0x6E6465, 0x6E6720,
        0x6E6765, 0x6E696E, 0x6F6368, 0x6F6D20, 0x6F6E20, 0x70E520, 0x722061, 0x722073, 0x726120, 0x736B61, 0x736F6D,
        0x742073, 0x746120, 0x746520, 0x746572, 0x74696C, 0x747420, 0x766172, 0xE47220, 0xF67220
      ])
    ];
  };

  this.name = function(det) {
    return det && det.fC1Bytes ? 'windows-1252' : 'ISO-8859-1';
  };
};
util.inherits(module.exports.ISO_8859_1, sbcs);

module.exports.ISO_8859_2 = function() {
  this.byteMap = function() {
    return [
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B,
      0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
      0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xB1, 0x20, 0xB3, 0x20, 0xB5, 0xB6, 0x20, 0x20, 0xB9, 0xBA,
      0xBB, 0xBC, 0x20, 0xBE, 0xBF, 0x20, 0xB1, 0x20, 0xB3, 0x20, 0xB5, 0xB6, 0xB7, 0x20, 0xB9, 0xBA, 0xBB, 0xBC, 0x20,
      0xBE, 0xBF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0,
      0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3,
      0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6,
      0x20, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x20
    ];
  }

  this.ngrams = function() {
    return [
      new NGramsPlusLang('cs', [
        0x206120, 0x206279, 0x20646F, 0x206A65, 0x206E61, 0x206E65, 0x206F20, 0x206F64, 0x20706F, 0x207072, 0x2070F8,
        0x20726F, 0x207365, 0x20736F, 0x207374, 0x20746F, 0x207620, 0x207679, 0x207A61, 0x612070, 0x636520, 0x636820,
        0x652070, 0x652073, 0x652076, 0x656D20, 0x656EED, 0x686F20, 0x686F64, 0x697374, 0x6A6520, 0x6B7465, 0x6C6520,
        0x6C6920, 0x6E6120, 0x6EE920, 0x6EEC20, 0x6EED20, 0x6F2070, 0x6F646E, 0x6F6A69, 0x6F7374, 0x6F7520, 0x6F7661,
        0x706F64, 0x706F6A, 0x70726F, 0x70F865, 0x736520, 0x736F75, 0x737461, 0x737469, 0x73746E, 0x746572, 0x746EED,
        0x746F20, 0x752070, 0xBE6520, 0xE16EED, 0xE9686F, 0xED2070, 0xED2073, 0xED6D20, 0xF86564
      ]),
      new NGramsPlusLang('hu', [
        0x206120, 0x20617A, 0x206265, 0x206567, 0x20656C, 0x206665, 0x206861, 0x20686F, 0x206973, 0x206B65, 0x206B69,
        0x206BF6, 0x206C65, 0x206D61, 0x206D65, 0x206D69, 0x206E65, 0x20737A, 0x207465, 0x20E973, 0x612061, 0x61206B,
        0x61206D, 0x612073, 0x616B20, 0x616E20, 0x617A20, 0x62616E, 0x62656E, 0x656779, 0x656B20, 0x656C20, 0x656C65,
        0x656D20, 0x656E20, 0x657265, 0x657420, 0x657465, 0x657474, 0x677920, 0x686F67, 0x696E74, 0x697320, 0x6B2061,
        0x6BF67A, 0x6D6567, 0x6D696E, 0x6E2061, 0x6E616B, 0x6E656B, 0x6E656D, 0x6E7420, 0x6F6779, 0x732061, 0x737A65,
        0x737A74, 0x737AE1, 0x73E967, 0x742061, 0x747420, 0x74E173, 0x7A6572, 0xE16E20, 0xE97320
      ]),
      new NGramsPlusLang('pl', [
        0x20637A, 0x20646F, 0x206920, 0x206A65, 0x206B6F, 0x206D61, 0x206D69, 0x206E61, 0x206E69, 0x206F64, 0x20706F,
        0x207072, 0x207369, 0x207720, 0x207769, 0x207779, 0x207A20, 0x207A61, 0x612070, 0x612077, 0x616E69, 0x636820,
        0x637A65, 0x637A79, 0x646F20, 0x647A69, 0x652070, 0x652073, 0x652077, 0x65207A, 0x65676F, 0x656A20, 0x656D20,
        0x656E69, 0x676F20, 0x696120, 0x696520, 0x69656A, 0x6B6120, 0x6B6920, 0x6B6965, 0x6D6965, 0x6E6120, 0x6E6961,
        0x6E6965, 0x6F2070, 0x6F7761, 0x6F7769, 0x706F6C, 0x707261, 0x70726F, 0x70727A, 0x727A65, 0x727A79, 0x7369EA,
        0x736B69, 0x737461, 0x776965, 0x796368, 0x796D20, 0x7A6520, 0x7A6965, 0x7A7920, 0xF37720
      ]),
      new NGramsPlusLang('ro', [
        0x206120, 0x206163, 0x206361, 0x206365, 0x20636F, 0x206375, 0x206465, 0x206469, 0x206C61, 0x206D61, 0x207065,
        0x207072, 0x207365, 0x2073E3, 0x20756E, 0x20BA69, 0x20EE6E, 0x612063, 0x612064, 0x617265, 0x617420, 0x617465,
        0x617520, 0x636172, 0x636F6E, 0x637520, 0x63E320, 0x646520, 0x652061, 0x652063, 0x652064, 0x652070, 0x652073,
        0x656120, 0x656920, 0x656C65, 0x656E74, 0x657374, 0x692061, 0x692063, 0x692064, 0x692070, 0x696520, 0x696920,
        0x696E20, 0x6C6120, 0x6C6520, 0x6C6F72, 0x6C7569, 0x6E6520, 0x6E7472, 0x6F7220, 0x70656E, 0x726520, 0x726561,
        0x727520, 0x73E320, 0x746520, 0x747275, 0x74E320, 0x756920, 0x756C20, 0xBA6920, 0xEE6E20
      ])
    ];
  };

  this.name = function(det) {
    return det && det.fC1Bytes ? 'windows-1250' : 'ISO-8859-2';
  };
};
util.inherits(module.exports.ISO_8859_2, sbcs);

module.exports.ISO_8859_5 = function() {
  this.byteMap = function() {
    return [
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B,
      0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
      0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA,
      0xFB, 0xFC, 0x20, 0xFE, 0xFF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD,
      0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xD0,
      0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3,
      0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0x20, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6,
      0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0x20, 0xFE, 0xFF
    ];
  };

  this.ngrams = function() {
    return [
      0x20D220, 0x20D2DE, 0x20D4DE, 0x20D7D0, 0x20D820, 0x20DAD0, 0x20DADE, 0x20DDD0, 0x20DDD5, 0x20DED1, 0x20DFDE,
      0x20DFE0, 0x20E0D0, 0x20E1DE, 0x20E1E2, 0x20E2DE, 0x20E7E2, 0x20EDE2, 0xD0DDD8, 0xD0E2EC, 0xD3DE20, 0xD5DBEC,
      0xD5DDD8, 0xD5E1E2, 0xD5E220, 0xD820DF, 0xD8D520, 0xD8D820, 0xD8EF20, 0xDBD5DD, 0xDBD820, 0xDBECDD, 0xDDD020,
      0xDDD520, 0xDDD8D5, 0xDDD8EF, 0xDDDE20, 0xDDDED2, 0xDE20D2, 0xDE20DF, 0xDE20E1, 0xDED220, 0xDED2D0, 0xDED3DE,
      0xDED920, 0xDEDBEC, 0xDEDC20, 0xDEE1E2, 0xDFDEDB, 0xDFE0D5, 0xDFE0D8, 0xDFE0DE, 0xE0D0D2, 0xE0D5D4, 0xE1E2D0,
      0xE1E2D2, 0xE1E2D8, 0xE1EF20, 0xE2D5DB, 0xE2DE20, 0xE2DEE0, 0xE2EC20, 0xE7E2DE, 0xEBE520
    ];
  };

  this.name = function(det) {
    return 'ISO-8859-5';
  };

  this.language = function() {
    return 'ru';
  };
};
util.inherits(module.exports.ISO_8859_5, sbcs);

module.exports.ISO_8859_6 = function() {
  this.byteMap = function() {
    return [
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B,
      0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
      0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0,
      0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0x20, 0x20, 0x20, 0x20, 0x20, 0xE0, 0xE1, 0xE2, 0xE3,
      0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
    ];
  };

  this.ngrams = function() {
    return [
      0x20C7E4, 0x20C7E6, 0x20C8C7, 0x20D9E4, 0x20E1EA, 0x20E4E4, 0x20E5E6, 0x20E8C7, 0xC720C7, 0xC7C120, 0xC7CA20,
      0xC7D120, 0xC7E420, 0xC7E4C3, 0xC7E4C7, 0xC7E4C8, 0xC7E4CA, 0xC7E4CC, 0xC7E4CD, 0xC7E4CF, 0xC7E4D3, 0xC7E4D9,
      0xC7E4E2, 0xC7E4E5, 0xC7E4E8, 0xC7E4EA, 0xC7E520, 0xC7E620, 0xC7E6CA, 0xC820C7, 0xC920C7, 0xC920E1, 0xC920E4,
      0xC920E5, 0xC920E8, 0xCA20C7, 0xCF20C7, 0xCFC920, 0xD120C7, 0xD1C920, 0xD320C7, 0xD920C7, 0xD9E4E9, 0xE1EA20,
      0xE420C7, 0xE4C920, 0xE4E920, 0xE4EA20, 0xE520C7, 0xE5C720, 0xE5C920, 0xE5E620, 0xE620C7, 0xE720C7, 0xE7C720,
      0xE8C7E4, 0xE8E620, 0xE920C7, 0xEA20C7, 0xEA20E5, 0xEA20E8, 0xEAC920, 0xEAD120, 0xEAE620
    ];
  };

  this.name = function(det) {
    return 'ISO-8859-6';
  };

  this.language = function() {
    return 'ar';
  };
};
util.inherits(module.exports.ISO_8859_6, sbcs);

module.exports.ISO_8859_7 = function() {
  this.byteMap = function() {
    return [
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B,
      0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
      0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xA1, 0xA2, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDC, 0x20, 0xDD, 0xDE, 0xDF, 0x20, 0xFC, 0x20,
      0xFD, 0xFE, 0xC0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0,
      0xF1, 0x20, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3,
      0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6,
      0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x20
    ];
  };

  this.ngrams = function() {
    return [
      0x20E1ED, 0x20E1F0, 0x20E3E9, 0x20E4E9, 0x20E5F0, 0x20E720, 0x20EAE1, 0x20ECE5, 0x20EDE1, 0x20EF20, 0x20F0E1,
      0x20F0EF, 0x20F0F1, 0x20F3F4, 0x20F3F5, 0x20F4E7, 0x20F4EF, 0xDFE120, 0xE120E1, 0xE120F4, 0xE1E920, 0xE1ED20,
      0xE1F0FC, 0xE1F220, 0xE3E9E1, 0xE5E920, 0xE5F220, 0xE720F4, 0xE7ED20, 0xE7F220, 0xE920F4, 0xE9E120, 0xE9EADE,
      0xE9F220, 0xEAE1E9, 0xEAE1F4, 0xECE520, 0xED20E1, 0xED20E5, 0xED20F0, 0xEDE120, 0xEFF220, 0xEFF520, 0xF0EFF5,
      0xF0F1EF, 0xF0FC20, 0xF220E1, 0xF220E5, 0xF220EA, 0xF220F0, 0xF220F4, 0xF3E520, 0xF3E720, 0xF3F4EF, 0xF4E120,
      0xF4E1E9, 0xF4E7ED, 0xF4E7F2, 0xF4E9EA, 0xF4EF20, 0xF4EFF5, 0xF4F9ED, 0xF9ED20, 0xFEED20
    ];
  };

  this.name = function(det) {
    return det && det.fC1Bytes ? 'windows-1253' : 'ISO-8859-7';
  };

  this.language = function() {
    return 'el';
  };
};
util.inherits(module.exports.ISO_8859_7, sbcs);

module.exports.ISO_8859_8 = function() {
  this.byteMap = function() {
    return [
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B,
      0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
      0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xE0, 0xE1, 0xE2, 0xE3,
      0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6,
      0xF7, 0xF8, 0xF9, 0xFA, 0x20, 0x20, 0x20, 0x20, 0x20
    ];
  };

  this.ngrams = function() {
    return [
      new NGramsPlusLang('he', [
        0x20E0E5, 0x20E0E7, 0x20E0E9, 0x20E0FA, 0x20E1E9, 0x20E1EE, 0x20E4E0, 0x20E4E5, 0x20E4E9, 0x20E4EE, 0x20E4F2,
        0x20E4F9, 0x20E4FA, 0x20ECE0, 0x20ECE4, 0x20EEE0, 0x20F2EC, 0x20F9EC, 0xE0FA20, 0xE420E0, 0xE420E1, 0xE420E4,
        0xE420EC, 0xE420EE, 0xE420F9, 0xE4E5E0, 0xE5E020, 0xE5ED20, 0xE5EF20, 0xE5F820, 0xE5FA20, 0xE920E4, 0xE9E420,
        0xE9E5FA, 0xE9E9ED, 0xE9ED20, 0xE9EF20, 0xE9F820, 0xE9FA20, 0xEC20E0, 0xEC20E4, 0xECE020, 0xECE420, 0xED20E0,
        0xED20E1, 0xED20E4, 0xED20EC, 0xED20EE, 0xED20F9, 0xEEE420, 0xEF20E4, 0xF0E420, 0xF0E920, 0xF0E9ED, 0xF2EC20,
        0xF820E4, 0xF8E9ED, 0xF9EC20, 0xFA20E0, 0xFA20E1, 0xFA20E4, 0xFA20EC, 0xFA20EE, 0xFA20F9
      ]),
      new NGramsPlusLang('he', [
        0x20E0E5, 0x20E0EC, 0x20E4E9, 0x20E4EC, 0x20E4EE, 0x20E4F0, 0x20E9F0, 0x20ECF2, 0x20ECF9, 0x20EDE5, 0x20EDE9,
        0x20EFE5, 0x20EFE9, 0x20F8E5, 0x20F8E9, 0x20FAE0, 0x20FAE5, 0x20FAE9, 0xE020E4, 0xE020EC, 0xE020ED, 0xE020FA,
        0xE0E420, 0xE0E5E4, 0xE0EC20, 0xE0EE20, 0xE120E4, 0xE120ED, 0xE120FA, 0xE420E4, 0xE420E9, 0xE420EC, 0xE420ED,
        0xE420EF, 0xE420F8, 0xE420FA, 0xE4EC20, 0xE5E020, 0xE5E420, 0xE7E020, 0xE9E020, 0xE9E120, 0xE9E420, 0xEC20E4,
        0xEC20ED, 0xEC20FA, 0xECF220, 0xECF920, 0xEDE9E9, 0xEDE9F0, 0xEDE9F8, 0xEE20E4, 0xEE20ED, 0xEE20FA, 0xEEE120,
        0xEEE420, 0xF2E420, 0xF920E4, 0xF920ED, 0xF920FA, 0xF9E420, 0xFAE020, 0xFAE420, 0xFAE5E9
      ])
    ];
  };

  this.name = function(det) {
    return det && det.fC1Bytes ? 'windows-1255' : 'ISO-8859-8';
  };

  this.language = function() {
    return 'he';
  };
};
util.inherits(module.exports.ISO_8859_8, sbcs);

module.exports.ISO_8859_9 = function() {
  this.byteMap = function() {
    return [
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B,
      0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
      0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xAA,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20, 0x20, 0x20, 0xBA, 0x20, 0x20, 0x20,
      0x20, 0x20, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0,
      0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0x69, 0xFE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3,
      0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6,
      0x20, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
    ];
  };

  this.ngrams = function() {
    return [
      0x206261, 0x206269, 0x206275, 0x206461, 0x206465, 0x206765, 0x206861, 0x20696C, 0x206B61, 0x206B6F, 0x206D61,
      0x206F6C, 0x207361, 0x207461, 0x207665, 0x207961, 0x612062, 0x616B20, 0x616C61, 0x616D61, 0x616E20, 0x616EFD,
      0x617220, 0x617261, 0x6172FD, 0x6173FD, 0x617961, 0x626972, 0x646120, 0x646520, 0x646920, 0x652062, 0x65206B,
      0x656469, 0x656E20, 0x657220, 0x657269, 0x657369, 0x696C65, 0x696E20, 0x696E69, 0x697220, 0x6C616E, 0x6C6172,
      0x6C6520, 0x6C6572, 0x6E2061, 0x6E2062, 0x6E206B, 0x6E6461, 0x6E6465, 0x6E6520, 0x6E6920, 0x6E696E, 0x6EFD20,
      0x72696E, 0x72FD6E, 0x766520, 0x796120, 0x796F72, 0xFD6E20, 0xFD6E64, 0xFD6EFD, 0xFDF0FD
    ];
  };

  this.name = function(det) {
    return det && det.fC1Bytes ? 'windows-1254' : 'ISO-8859-9';
  };

  this.language = function() {
    return 'tr';
  };
};
util.inherits(module.exports.ISO_8859_9, sbcs);

module.exports.windows_1251 = function() {
  this.byteMap = function() {
    return [
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B,
      0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
      0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x90, 0x83, 0x20, 0x83, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x9A, 0x20, 0x9C, 0x9D, 0x9E, 0x9F, 0x90, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x9A, 0x20, 0x9C, 0x9D, 0x9E, 0x9F, 0x20, 0xA2, 0xA2, 0xBC, 0x20, 0xB4, 0x20, 0x20, 0xB8, 0x20, 0xBA,
      0x20, 0x20, 0x20, 0x20, 0xBF, 0x20, 0x20, 0xB3, 0xB3, 0xB4, 0xB5, 0x20, 0x20, 0xB8, 0x20, 0xBA, 0x20, 0xBC, 0xBE,
      0xBE, 0xBF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0,
      0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF, 0xE0, 0xE1, 0xE2, 0xE3,
      0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6,
      0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
    ];
  };

  this.ngrams = function() {
    return [
      0x20E220, 0x20E2EE, 0x20E4EE, 0x20E7E0, 0x20E820, 0x20EAE0, 0x20EAEE, 0x20EDE0, 0x20EDE5, 0x20EEE1, 0x20EFEE,
      0x20EFF0, 0x20F0E0, 0x20F1EE, 0x20F1F2, 0x20F2EE, 0x20F7F2, 0x20FDF2, 0xE0EDE8, 0xE0F2FC, 0xE3EE20, 0xE5EBFC,
      0xE5EDE8, 0xE5F1F2, 0xE5F220, 0xE820EF, 0xE8E520, 0xE8E820, 0xE8FF20, 0xEBE5ED, 0xEBE820, 0xEBFCED, 0xEDE020,
      0xEDE520, 0xEDE8E5, 0xEDE8FF, 0xEDEE20, 0xEDEEE2, 0xEE20E2, 0xEE20EF, 0xEE20F1, 0xEEE220, 0xEEE2E0, 0xEEE3EE,
      0xEEE920, 0xEEEBFC, 0xEEEC20, 0xEEF1F2, 0xEFEEEB, 0xEFF0E5, 0xEFF0E8, 0xEFF0EE, 0xF0E0E2, 0xF0E5E4, 0xF1F2E0,
      0xF1F2E2, 0xF1F2E8, 0xF1FF20, 0xF2E5EB, 0xF2EE20, 0xF2EEF0, 0xF2FC20, 0xF7F2EE, 0xFBF520
    ];
  };

  this.name = function(det) {
    return 'windows-1251';
  };

  this.language = function() {
    return 'ru';
  };
};
util.inherits(module.exports.windows_1251, sbcs);

module.exports.windows_1256 = function() {
  this.byteMap = function() {
    return [
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B,
      0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
      0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x81, 0x20, 0x83, 0x20,
      0x20, 0x20, 0x20, 0x88, 0x20, 0x8A, 0x20, 0x9C, 0x8D, 0x8E, 0x8F, 0x90, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x98, 0x20, 0x9A, 0x20, 0x9C, 0x20, 0x20, 0x9F, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xAA,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0,
      0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0x20, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3,
      0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0x20, 0x20, 0x20, 0x20, 0xF4, 0x20, 0x20,
      0x20, 0x20, 0xF9, 0x20, 0xFB, 0xFC, 0x20, 0x20, 0xFF
    ];
  };

  this.ngrams = function() {
    return [
      0x20C7E1, 0x20C7E4, 0x20C8C7, 0x20DAE1, 0x20DDED, 0x20E1E1, 0x20E3E4, 0x20E6C7, 0xC720C7, 0xC7C120, 0xC7CA20,
      0xC7D120, 0xC7E120, 0xC7E1C3, 0xC7E1C7, 0xC7E1C8, 0xC7E1CA, 0xC7E1CC, 0xC7E1CD, 0xC7E1CF, 0xC7E1D3, 0xC7E1DA,
      0xC7E1DE, 0xC7E1E3, 0xC7E1E6, 0xC7E1ED, 0xC7E320, 0xC7E420, 0xC7E4CA, 0xC820C7, 0xC920C7, 0xC920DD, 0xC920E1,
      0xC920E3, 0xC920E6, 0xCA20C7, 0xCF20C7, 0xCFC920, 0xD120C7, 0xD1C920, 0xD320C7, 0xDA20C7, 0xDAE1EC, 0xDDED20,
      0xE120C7, 0xE1C920, 0xE1EC20, 0xE1ED20, 0xE320C7, 0xE3C720, 0xE3C920, 0xE3E420, 0xE420C7, 0xE520C7, 0xE5C720,
      0xE6C7E1, 0xE6E420, 0xEC20C7, 0xED20C7, 0xED20E3, 0xED20E6, 0xEDC920, 0xEDD120, 0xEDE420
    ];
  };

  this.name = function(det) {
    return 'windows-1256';
  };

  this.language = function() {
    return 'ar';
  };
};
util.inherits(module.exports.windows_1256, sbcs);

module.exports.KOI8_R = function() {
  this.byteMap = function() {
    return [
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B,
      0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
      0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xA3, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xA3, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
      0x20, 0x20, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0,
      0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xC0, 0xC1, 0xC2, 0xC3,
      0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,
      0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF
    ];
  };

  this.ngrams = function() {
    return [
      0x20C4CF, 0x20C920, 0x20CBC1, 0x20CBCF, 0x20CEC1, 0x20CEC5, 0x20CFC2, 0x20D0CF, 0x20D0D2, 0x20D2C1, 0x20D3CF,
      0x20D3D4, 0x20D4CF, 0x20D720, 0x20D7CF, 0x20DAC1, 0x20DCD4, 0x20DED4, 0xC1CEC9, 0xC1D4D8, 0xC5CCD8, 0xC5CEC9,
      0xC5D3D4, 0xC5D420, 0xC7CF20, 0xC920D0, 0xC9C520, 0xC9C920, 0xC9D120, 0xCCC5CE, 0xCCC920, 0xCCD8CE, 0xCEC120,
      0xCEC520, 0xCEC9C5, 0xCEC9D1, 0xCECF20, 0xCECFD7, 0xCF20D0, 0xCF20D3, 0xCF20D7, 0xCFC7CF, 0xCFCA20, 0xCFCCD8,
      0xCFCD20, 0xCFD3D4, 0xCFD720, 0xCFD7C1, 0xD0CFCC, 0xD0D2C5, 0xD0D2C9, 0xD0D2CF, 0xD2C1D7, 0xD2C5C4, 0xD3D120,
      0xD3D4C1, 0xD3D4C9, 0xD3D4D7, 0xD4C5CC, 0xD4CF20, 0xD4CFD2, 0xD4D820, 0xD9C820, 0xDED4CF
    ];
  };

  this.name = function(det) {
    return 'KOI8-R';
  };

  this.language = function() {
    return 'ru';
  };
};
util.inherits(module.exports.KOI8_R, sbcs);
//
},
'chardet/encoding/iso2022':
function(module, exports, __wpreq__) {
//
var util = __wpreq__('util'),
  Match = __wpreq__('chardet/match');

function ISO_2022() {}

ISO_2022.prototype.match = function(det) {
  var i, j,
    escN,
    quality,
    hits = 0,
    misses = 0,
    shifts = 0,

    text = det.fInputBytes,
    textLen = det.fInputLen;

  scanInput: for (i = 0; i < textLen; i++) {
    if (text[i] == 0x1b) {
      checkEscapes: for (escN = 0; escN < this.escapeSequences.length; escN++) {
        var seq = this.escapeSequences[escN];

        if (textLen - i < seq.length) continue;

        for (j = 1; j < seq.length; j++) if (seq[j] != text[i + j]) continue checkEscapes;

        hits++;
        i += seq.length - 1;
        continue scanInput;
      }

      misses++;
    }

    (text[i] != 0x0e && text[i] != 0x0f) || shifts++;
  }

  if (hits == 0) return null;

  quality = (100 * hits - 100 * misses) / (hits + misses);

  if (hits + shifts < 5) quality -= 10 * (5 - (hits + shifts));

  return quality <= 0 ? null : new Match(det, this, quality);
};

module.exports.ISO_2022_JP = function() {
  this.name = function() {
    return 'ISO-2022-JP';
  };
  this.escapeSequences = [
    [0x1b, 0x24, 0x28, 0x43],
    [0x1b, 0x24, 0x28, 0x44],
    [0x1b, 0x24, 0x40],
    [0x1b, 0x24, 0x41],
    [0x1b, 0x24, 0x42],
    [0x1b, 0x26, 0x40],
    [0x1b, 0x28, 0x42],
    [0x1b, 0x28, 0x48],
    [0x1b, 0x28, 0x49],
    [0x1b, 0x28, 0x4a],
    [0x1b, 0x2e, 0x41],
    [0x1b, 0x2e, 0x46]
  ];
};
util.inherits(module.exports.ISO_2022_JP, ISO_2022);

module.exports.ISO_2022_KR = function() {
  this.name = function() {
    return 'ISO-2022-KR';
  };
  this.escapeSequences = [[0x1b, 0x24, 0x29, 0x43]];
};
util.inherits(module.exports.ISO_2022_KR, ISO_2022);

module.exports.ISO_2022_CN = function() {
  this.name = function() {
    return 'ISO-2022-CN';
  };
  this.escapeSequences = [
    [0x1b, 0x24, 0x29, 0x41],
    [0x1b, 0x24, 0x29, 0x47],
    [0x1b, 0x24, 0x2A, 0x48],
    [0x1b, 0x24, 0x29, 0x45],
    [0x1b, 0x24, 0x2B, 0x49],
    [0x1b, 0x24, 0x2B, 0x4A],
    [0x1b, 0x24, 0x2B, 0x4B],
    [0x1b, 0x24, 0x2B, 0x4C],
    [0x1b, 0x24, 0x2B, 0x4D],
    [0x1b, 0x4e],
    [0x1b, 0x4f]
  ];
};
util.inherits(module.exports.ISO_2022_CN, ISO_2022);
//
},
'iconv-lite':
function(module, exports, __wpreq__) {
//
var Buffer = __wpreq__('safer-buffer').Buffer,

  bomHandling = __wpreq__('iconv-lite/lib/bom-handling'),
  iconv = module.exports;

iconv.encodings = null;

iconv.defaultCharUnicode = '';
iconv.defaultCharSingleByte = '?';

iconv.encode = function(str, encoding, options) {
  str = "" + (str || "");

  var encoder = iconv.getEncoder(encoding, options),

    res = encoder.write(str),
    trail = encoder.end();

  return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
}

iconv.decode = function(buf, encoding, options) {
  if (typeof buf == 'string') {
    if (!iconv.skipDecodeWarning) {
      console.error(
        'Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding'
      );
      iconv.skipDecodeWarning = true;
    }

    buf = Buffer.from("" + (buf || ""), "binary");
  }

  var decoder = iconv.getDecoder(encoding, options),

    res = decoder.write(buf),
    trail = decoder.end();

  return trail ? res + trail : res;
}

iconv.encodingExists = function(enc) {
  try {
    iconv.getCodec(enc);
    return true;
  } catch (_e) {
    return false;
  }
}

iconv.toEncoding = iconv.encode;
iconv.fromEncoding = iconv.decode;

iconv._codecDataCache = {};
iconv.getCodec = function(encoding) {
  iconv.encodings || (iconv.encodings = __wpreq__('iconv-lite/encodings'));

  for (var enc = iconv._canonicalizeEncoding(encoding), codecOptions = {}; ; ) {
    var codec = iconv._codecDataCache[enc];
    if (codec) return codec;

    var codecDef = iconv.encodings[enc];

    switch (typeof codecDef) {
      case "string":
        enc = codecDef;
        break;

      case "object":
        for (var key in codecDef) codecOptions[key] = codecDef[key];

        codecOptions.encodingName || (codecOptions.encodingName = enc);

        enc = codecDef.type;
        break;

      case "function":
        codecOptions.encodingName || (codecOptions.encodingName = enc);

        codec = new codecDef(codecOptions, iconv);

        iconv._codecDataCache[codecOptions.encodingName] = codec;
        return codec;

      default:
        throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
    }
  }
}

iconv._canonicalizeEncoding = function(encoding) {
  return ('' + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
}

iconv.getEncoder = function(encoding, options) {
  var codec = iconv.getCodec(encoding),
    encoder = new codec.encoder(options, codec);

  if (codec.bomAware && options && options.addBOM) encoder = new bomHandling.PrependBOM(encoder, options);

  return encoder;
}

iconv.getDecoder = function(encoding, options) {
  var codec = iconv.getCodec(encoding),
    decoder = new codec.decoder(options, codec);

  !codec.bomAware || (options && options.stripBOM === false) ||
    (decoder = new bomHandling.StripBOM(decoder, options));

  return decoder;
}

var nodeVer = typeof process != 'undefined' && process.versions && process.versions.node;
if (nodeVer) {
  var nodeVerArr = nodeVer.split(".").map(Number);
  if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) __wpreq__('iconv-lite/lib/streams')(iconv);

  __wpreq__('iconv-lite/lib/extend-node')(iconv);
}
//
},
'safer-buffer':
function(module, exports, __wpreq__) {
//
var buffer = __wpreq__('buffer'),
  Buffer = buffer.Buffer,

  safer = {}

for (var key in buffer)
  if (buffer.hasOwnProperty(key) && key !== 'SlowBuffer' && key !== 'Buffer') safer[key] = buffer[key]

var Safer = (safer.Buffer = {})
for (key in Buffer)
  if (Buffer.hasOwnProperty(key) && key !== 'allocUnsafe' && key !== 'allocUnsafeSlow') Safer[key] = Buffer[key]

safer.Buffer.prototype = Buffer.prototype

if (!Safer.from || Safer.from === Uint8Array.from)
  Safer.from = function(value, encodingOrOffset, length) {
    if (typeof value == 'number')
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)

    if (value && value.length === void 0)
      throw new TypeError(
        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value
      )

    return Buffer(value, encodingOrOffset, length)
  }

Safer.alloc ||
  (Safer.alloc = function(size, fill, encoding) {
    if (typeof size != 'number')
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)

    if (size < 0 || size >= 2 * (1 << 30))
      throw new RangeError('The value "' + size + '" is invalid for option "size"')

    var buf = Buffer(size)
    !fill || fill.length === 0 ? buf.fill(0) : typeof encoding == 'string' ? buf.fill(fill, encoding) : buf.fill(fill)

    return buf
  })

if (!safer.kStringMaxLength)
  try {
    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength
  } catch (_) {}

if (!safer.constants) {
  safer.constants = {MAX_LENGTH: safer.kMaxLength}
  if (safer.kStringMaxLength) safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength
}

module.exports = safer
//
},
buffer:
function(module) {
//
module.exports = require('buffer');
//
},
'iconv-lite/lib/bom-handling':
function(module, exports) {
//
var BOMChar = '\uFEFF';

exports.PrependBOM = PrependBOMWrapper
function PrependBOMWrapper(encoder, options) {
  this.encoder = encoder;
  this.addBOM = true;
}

PrependBOMWrapper.prototype.write = function(str) {
  if (this.addBOM) {
    str = BOMChar + str;
    this.addBOM = false;
  }

  return this.encoder.write(str);
}

PrependBOMWrapper.prototype.end = function() {
  return this.encoder.end();
}

exports.StripBOM = StripBOMWrapper;
function StripBOMWrapper(decoder, options) {
  this.decoder = decoder;
  this.pass = false;
  this.options = options || {};
}

StripBOMWrapper.prototype.write = function(buf) {
  var res = this.decoder.write(buf);
  if (this.pass || !res) return res;

  if (res[0] === BOMChar) {
    res = res.slice(1);
    typeof this.options.stripBOM != 'function' || this.options.stripBOM();
  }

  this.pass = true;
  return res;
}

StripBOMWrapper.prototype.end = function() {
  return this.decoder.end();
}
//
},
'iconv-lite/encodings':
function(module, exports, __wpreq__) {
//
var modules = [
  __wpreq__('iconv-lite/encodings/internal'),
  __wpreq__('iconv-lite/encodings/utf16'),
  __wpreq__('iconv-lite/encodings/utf7'),
  __wpreq__('iconv-lite/encodings/sbcs-codec'),
  __wpreq__('iconv-lite/encodings/sbcs-data'),
  __wpreq__('iconv-lite/encodings/sbcs-data-generated'),
  __wpreq__('iconv-lite/encodings/dbcs-codec'),
  __wpreq__('iconv-lite/encodings/dbcs-data')
];

for (var i = 0; i < modules.length; i++) {
  var mod = modules[i];
  for (var enc in mod) if (Object.prototype.hasOwnProperty.call(mod, enc)) exports[enc] = mod[enc];
}
//
},
'iconv-lite/encodings/internal':
function(module, exports, __wpreq__) {
//
var Buffer = __wpreq__('safer-buffer').Buffer;

module.exports = {
  utf8: {type: "_internal", bomAware: true},
  cesu8: {type: "_internal", bomAware: true},
  unicode11utf8: "utf8",

  ucs2: {type: "_internal", bomAware: true},
  utf16le: "ucs2",

  binary: {type: "_internal"},
  base64: {type: "_internal"},
  hex: {type: "_internal"},

  _internal: InternalCodec
};

function InternalCodec(codecOptions, iconv) {
  this.enc = codecOptions.encodingName;
  this.bomAware = codecOptions.bomAware;

  if (this.enc === "base64") this.encoder = InternalEncoderBase64;
  else if (this.enc === "cesu8") {
    this.enc = "utf8";
    this.encoder = InternalEncoderCesu8;

    if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== '') {
      this.decoder = InternalDecoderCesu8;
      this.defaultCharUnicode = iconv.defaultCharUnicode;
    }
  }
}

InternalCodec.prototype.encoder = InternalEncoder;
InternalCodec.prototype.decoder = InternalDecoder;

var StringDecoder = __wpreq__('string_decoder').StringDecoder;

StringDecoder.prototype.end || (StringDecoder.prototype.end = function() {});

function InternalDecoder(options, codec) {
  StringDecoder.call(this, codec.enc);
}

InternalDecoder.prototype = StringDecoder.prototype;

function InternalEncoder(options, codec) {
  this.enc = codec.enc;
}

InternalEncoder.prototype.write = function(str) {
  return Buffer.from(str, this.enc);
}

InternalEncoder.prototype.end = function() {}

function InternalEncoderBase64(options, codec) {
  this.prevStr = '';
}

InternalEncoderBase64.prototype.write = function(str) {
  var completeQuads = (str = this.prevStr + str).length - (str.length % 4);
  this.prevStr = str.slice(completeQuads);
  str = str.slice(0, completeQuads);

  return Buffer.from(str, "base64");
}

InternalEncoderBase64.prototype.end = function() {
  return Buffer.from(this.prevStr, "base64");
}

function InternalEncoderCesu8(options, codec) {}

InternalEncoderCesu8.prototype.write = function(str) {
  var buf = Buffer.alloc(str.length * 3), bufIdx = 0;
  for (var i = 0; i < str.length; i++) {
    var charCode = str.charCodeAt(i);
    if (charCode < 0x80) buf[bufIdx++] = charCode;
    else if (charCode < 0x800) {
      buf[bufIdx++] = 0xC0 + (charCode >>> 6);
      buf[bufIdx++] = 0x80 + (charCode & 0x3f);
    } else {
      buf[bufIdx++] = 0xE0 + (charCode >>> 12);
      buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);
      buf[bufIdx++] = 0x80 + (charCode & 0x3f);
    }
  }
  return buf.slice(0, bufIdx);
}

InternalEncoderCesu8.prototype.end = function() {}

function InternalDecoderCesu8(options, codec) {
  this.acc = 0;
  this.contBytes = 0;
  this.accBytes = 0;
  this.defaultCharUnicode = codec.defaultCharUnicode;
}

InternalDecoderCesu8.prototype.write = function(buf) {
  var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes,
    res = '';
  for (var i = 0; i < buf.length; i++) {
    var curByte = buf[i];
    if ((curByte & 0xC0) != 0x80) {
      if (contBytes > 0) {
        res += this.defaultCharUnicode;
        contBytes = 0;
      }

      if (curByte < 0x80) res += String.fromCharCode(curByte);
      else if (curByte < 0xE0) {
        acc = curByte & 0x1F;
        contBytes = 1;
        accBytes = 1;
      } else if (curByte < 0xF0) {
        acc = curByte & 0x0F;
        contBytes = 2;
        accBytes = 1;
      } else res += this.defaultCharUnicode;
    } else if (contBytes > 0) {
      acc = (acc << 6) | (curByte & 0x3f);
      accBytes++;
      if (--contBytes == 0)
        res += (accBytes === 2 && acc < 0x80 && acc > 0) || (accBytes === 3 && acc < 0x800)
          ? this.defaultCharUnicode
          : String.fromCharCode(acc);
    } else res += this.defaultCharUnicode;
  }
  this.acc = acc;
  this.contBytes = contBytes;
  this.accBytes = accBytes;
  return res;
}

InternalDecoderCesu8.prototype.end = function() {
  var res = 0;
  if (this.contBytes > 0) res += this.defaultCharUnicode;
  return res;
}
//
},
string_decoder:
function(module, exports, __wpreq__) {
//
module.exports = /^v?(8|9|\d\d+)\b/.test(process.version) ? require('string_decoder') : __wpreq__('string_decoder/');
//
},
'iconv-lite/encodings/utf16':
function(module, exports, __wpreq__) {
//
var Buffer = __wpreq__('safer-buffer').Buffer;

exports.utf16be = Utf16BECodec;
function Utf16BECodec() {}

Utf16BECodec.prototype.encoder = Utf16BEEncoder;
Utf16BECodec.prototype.decoder = Utf16BEDecoder;
Utf16BECodec.prototype.bomAware = true;

function Utf16BEEncoder() {}

Utf16BEEncoder.prototype.write = function(str) {
  var buf = Buffer.from(str, 'ucs2');
  for (var i = 0; i < buf.length; i += 2) {
    var tmp = buf[i];
    buf[i] = buf[i + 1];
    buf[i + 1] = tmp;
  }
  return buf;
}

Utf16BEEncoder.prototype.end = function() {}

function Utf16BEDecoder() {
  this.overflowByte = -1;
}

Utf16BEDecoder.prototype.write = function(buf) {
  if (buf.length == 0) return '';

  var buf2 = Buffer.alloc(buf.length + 1),
    i = 0, j = 0;

  if (this.overflowByte !== -1) {
    buf2[0] = buf[0];
    buf2[1] = this.overflowByte;
    i = 1;
    j = 2;
  }

  for (; i < buf.length - 1; i += 2, j += 2) {
    buf2[j] = buf[i + 1];
    buf2[j + 1] = buf[i];
  }

  this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;

  return buf2.slice(0, j).toString('ucs2');
}

Utf16BEDecoder.prototype.end = function() {}

exports.utf16 = Utf16Codec;
function Utf16Codec(codecOptions, iconv) {
  this.iconv = iconv;
}

Utf16Codec.prototype.encoder = Utf16Encoder;
Utf16Codec.prototype.decoder = Utf16Decoder;

function Utf16Encoder(options, codec) {
  if ((options = options || {}).addBOM === void 0) options.addBOM = true;
  this.encoder = codec.iconv.getEncoder('utf-16le', options);
}

Utf16Encoder.prototype.write = function(str) {
  return this.encoder.write(str);
}

Utf16Encoder.prototype.end = function() {
  return this.encoder.end();
}

function Utf16Decoder(options, codec) {
  this.decoder = null;
  this.initialBytes = [];
  this.initialBytesLen = 0;

  this.options = options || {};
  this.iconv = codec.iconv;
}

Utf16Decoder.prototype.write = function(buf) {
  if (!this.decoder) {
    this.initialBytes.push(buf);
    this.initialBytesLen += buf.length;

    if (this.initialBytesLen < 16) return '';

    var encoding = detectEncoding((buf = Buffer.concat(this.initialBytes)), this.options.defaultEncoding);
    this.decoder = this.iconv.getDecoder(encoding, this.options);
    this.initialBytes.length = this.initialBytesLen = 0;
  }

  return this.decoder.write(buf);
}

Utf16Decoder.prototype.end = function() {
  if (!this.decoder) {
    var buf = Buffer.concat(this.initialBytes),
      encoding = detectEncoding(buf, this.options.defaultEncoding);
    this.decoder = this.iconv.getDecoder(encoding, this.options);

    var res = this.decoder.write(buf),
      trail = this.decoder.end();

    return trail ? res + trail : res;
  }
  return this.decoder.end();
}

function detectEncoding(buf, defaultEncoding) {
  var enc = defaultEncoding || 'utf-16le';

  if (buf.length >= 2)
    if (buf[0] == 0xFE && buf[1] == 0xFF) enc = 'utf-16be';
    else if (buf[0] == 0xFF && buf[1] == 0xFE) enc = 'utf-16le';
    else {
      var asciiCharsLE = 0, asciiCharsBE = 0;

      for (var _len = Math.min(buf.length - (buf.length % 2), 64), i = 0; i < _len; i += 2) {
        buf[i] !== 0 || buf[i + 1] === 0 || asciiCharsBE++;
        buf[i] === 0 || buf[i + 1] !== 0 || asciiCharsLE++;
      }

      if (asciiCharsBE > asciiCharsLE) enc = 'utf-16be';
      else if (asciiCharsBE < asciiCharsLE) enc = 'utf-16le';
    }

  return enc;
}
//
},
'iconv-lite/encodings/utf7':
function(module, exports, __wpreq__) {
//
var Buffer = __wpreq__('safer-buffer').Buffer;

exports.utf7 = Utf7Codec;
exports.unicode11utf7 = 'utf7';
function Utf7Codec(codecOptions, iconv) {
  this.iconv = iconv;
}

Utf7Codec.prototype.encoder = Utf7Encoder;
Utf7Codec.prototype.decoder = Utf7Decoder;
Utf7Codec.prototype.bomAware = true;

var nonDirectChars = /[^A-Za-z0-9'(),-.\/:? \n\r\t]+/g;

function Utf7Encoder(options, codec) {
  this.iconv = codec.iconv;
}

Utf7Encoder.prototype.write = function(str) {
  return Buffer.from(
    str.replace(nonDirectChars, function(chunk) {
      return (
        "+" + (chunk === '+' ? '' : this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) + "-"
      );
    }.bind(this))
  );
}

Utf7Encoder.prototype.end = function() {}

function Utf7Decoder(options, codec) {
  this.iconv = codec.iconv;
  this.inBase64 = false;
  this.base64Accum = '';
}

var base64Regex = /[A-Za-z0-9\/+]/,
  base64Chars = [];
for (var i = 0; i < 256; i++) base64Chars[i] = base64Regex.test(String.fromCharCode(i));

var plusChar = '+'.charCodeAt(0),
  minusChar = '-'.charCodeAt(0),
  andChar = '&'.charCodeAt(0);

Utf7Decoder.prototype.write = function(buf) {
  var res = "", lastI = 0,
    inBase64 = this.inBase64,
    base64Accum = this.base64Accum;

  for (var i = 0; i < buf.length; i++)
    if (!inBase64) {
      if (buf[i] == plusChar) {
        res += this.iconv.decode(buf.slice(lastI, i), "ascii");
        lastI = i + 1;
        inBase64 = true;
      }
    } else if (!base64Chars[buf[i]]) {
      if (i == lastI && buf[i] == minusChar) res += "+";
      else {
        var b64str = base64Accum + buf.slice(lastI, i).toString();
        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
      }

      buf[i] == minusChar || i--;

      lastI = i + 1;
      inBase64 = false;
      base64Accum = '';
    }

  if (inBase64) {
    var canBeDecoded = (b64str = base64Accum + buf.slice(lastI).toString()).length - (b64str.length % 8);
    base64Accum = b64str.slice(canBeDecoded);
    b64str = b64str.slice(0, canBeDecoded);

    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
  } else res += this.iconv.decode(buf.slice(lastI), "ascii");

  this.inBase64 = inBase64;
  this.base64Accum = base64Accum;

  return res;
}

Utf7Decoder.prototype.end = function() {
  var res = "";
  if (this.inBase64 && this.base64Accum.length > 0)
    res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

  this.inBase64 = false;
  this.base64Accum = '';
  return res;
}

exports.utf7imap = Utf7IMAPCodec;
function Utf7IMAPCodec(codecOptions, iconv) {
  this.iconv = iconv;
}

Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
Utf7IMAPCodec.prototype.bomAware = true;

function Utf7IMAPEncoder(options, codec) {
  this.iconv = codec.iconv;
  this.inBase64 = false;
  this.base64Accum = Buffer.alloc(6);
  this.base64AccumIdx = 0;
}

Utf7IMAPEncoder.prototype.write = function(str) {
  var inBase64 = this.inBase64,
    base64Accum = this.base64Accum,
    base64AccumIdx = this.base64AccumIdx,
    buf = Buffer.alloc(str.length * 5 + 10), bufIdx = 0;

  for (var i = 0; i < str.length; i++) {
    var uChar = str.charCodeAt(i);
    if (0x20 <= uChar && uChar <= 0x7E) {
      if (inBase64) {
        if (base64AccumIdx > 0) {
          bufIdx += buf.write(
            base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''),
            bufIdx
          );
          base64AccumIdx = 0;
        }

        buf[bufIdx++] = minusChar;
        inBase64 = false;
      }

      if (!inBase64) {
        buf[bufIdx++] = uChar;

        if (uChar === andChar) buf[bufIdx++] = minusChar;
      }
    } else {
      if (!inBase64) {
        buf[bufIdx++] = andChar;
        inBase64 = true;
      }
      if (inBase64) {
        base64Accum[base64AccumIdx++] = uChar >> 8;
        base64Accum[base64AccumIdx++] = uChar & 0xFF;

        if (base64AccumIdx == base64Accum.length) {
          bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
          base64AccumIdx = 0;
        }
      }
    }
  }

  this.inBase64 = inBase64;
  this.base64AccumIdx = base64AccumIdx;

  return buf.slice(0, bufIdx);
}

Utf7IMAPEncoder.prototype.end = function() {
  var buf = Buffer.alloc(10), bufIdx = 0;
  if (this.inBase64) {
    if (this.base64AccumIdx > 0) {
      bufIdx += buf.write(
        this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''),
        bufIdx
      );
      this.base64AccumIdx = 0;
    }

    buf[bufIdx++] = minusChar;
    this.inBase64 = false;
  }

  return buf.slice(0, bufIdx);
}

function Utf7IMAPDecoder(options, codec) {
  this.iconv = codec.iconv;
  this.inBase64 = false;
  this.base64Accum = '';
}

var base64IMAPChars = base64Chars.slice();
base64IMAPChars[','.charCodeAt(0)] = true;

Utf7IMAPDecoder.prototype.write = function(buf) {
  var res = "", lastI = 0,
    inBase64 = this.inBase64,
    base64Accum = this.base64Accum;

  for (var i = 0; i < buf.length; i++)
    if (!inBase64) {
      if (buf[i] == andChar) {
        res += this.iconv.decode(buf.slice(lastI, i), "ascii");
        lastI = i + 1;
        inBase64 = true;
      }
    } else if (!base64IMAPChars[buf[i]]) {
      if (i == lastI && buf[i] == minusChar) res += "&";
      else {
        var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
      }

      buf[i] == minusChar || i--;

      lastI = i + 1;
      inBase64 = false;
      base64Accum = '';
    }

  if (inBase64) {
    var canBeDecoded =
      (b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/')).length - (b64str.length % 8);

    base64Accum = b64str.slice(canBeDecoded);
    b64str = b64str.slice(0, canBeDecoded);

    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
  } else res += this.iconv.decode(buf.slice(lastI), "ascii");

  this.inBase64 = inBase64;
  this.base64Accum = base64Accum;

  return res;
}

Utf7IMAPDecoder.prototype.end = function() {
  var res = "";
  if (this.inBase64 && this.base64Accum.length > 0)
    res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

  this.inBase64 = false;
  this.base64Accum = '';
  return res;
}
//
},
'iconv-lite/encodings/sbcs-codec':
function(module, exports, __wpreq__) {
//
var Buffer = __wpreq__('safer-buffer').Buffer;

exports._sbcs = SBCSCodec;
function SBCSCodec(codecOptions, iconv) {
  if (!codecOptions) throw new Error("SBCS codec is called without the data.")

  if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))
    throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");

  if (codecOptions.chars.length === 128) {
    var asciiString = "";
    for (var i = 0; i < 128; i++) asciiString += String.fromCharCode(i);
    codecOptions.chars = asciiString + codecOptions.chars;
  }

  this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');

  var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));

  for (i = 0; i < codecOptions.chars.length; i++) encodeBuf[codecOptions.chars.charCodeAt(i)] = i;

  this.encodeBuf = encodeBuf;
}

SBCSCodec.prototype.encoder = SBCSEncoder;
SBCSCodec.prototype.decoder = SBCSDecoder;

function SBCSEncoder(options, codec) {
  this.encodeBuf = codec.encodeBuf;
}

SBCSEncoder.prototype.write = function(str) {
  var buf = Buffer.alloc(str.length);
  for (var i = 0; i < str.length; i++) buf[i] = this.encodeBuf[str.charCodeAt(i)];

  return buf;
}

SBCSEncoder.prototype.end = function() {}

function SBCSDecoder(options, codec) {
  this.decodeBuf = codec.decodeBuf;
}

SBCSDecoder.prototype.write = function(buf) {
  var decodeBuf = this.decodeBuf,
    newBuf = Buffer.alloc(buf.length * 2);
  for (var idx1 = 0, idx2 = 0, i = 0; i < buf.length; i++) {
    idx1 = buf[i] * 2;
    newBuf[(idx2 = i * 2)] = decodeBuf[idx1];
    newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
  }
  return newBuf.toString('ucs2');
}

SBCSDecoder.prototype.end = function() {}
//
},
'iconv-lite/encodings/sbcs-data':
function(module) {
// noinspection SpellCheckingInspection
module.exports = {
  10029: "maccenteuro",
  maccenteuro: {
    type: "_sbcs",
    chars: ""
  },

  808: "cp808",
  ibm808: "cp808",
  cp808: {
    type: "_sbcs",
    chars: ""
  },

  mik: {
    type: "_sbcs",
    chars: ""
  },

  ascii8bit: "ascii",
  usascii: "ascii",
  ansix34: "ascii",
  ansix341968: "ascii",
  ansix341986: "ascii",
  csascii: "ascii",
  cp367: "ascii",
  ibm367: "ascii",
  isoir6: "ascii",
  iso646us: "ascii",
  iso646irv: "ascii",
  us: "ascii",

  latin1: "iso88591",
  latin2: "iso88592",
  latin3: "iso88593",
  latin4: "iso88594",
  latin5: "iso88599",
  latin6: "iso885910",
  latin7: "iso885913",
  latin8: "iso885914",
  latin9: "iso885915",
  latin10: "iso885916",

  csisolatin1: "iso88591",
  csisolatin2: "iso88592",
  csisolatin3: "iso88593",
  csisolatin4: "iso88594",
  csisolatincyrillic: "iso88595",
  csisolatinarabic: "iso88596",
  csisolatingreek: "iso88597",
  csisolatinhebrew: "iso88598",
  csisolatin5: "iso88599",
  csisolatin6: "iso885910",

  l1: "iso88591",
  l2: "iso88592",
  l3: "iso88593",
  l4: "iso88594",
  l5: "iso88599",
  l6: "iso885910",
  l7: "iso885913",
  l8: "iso885914",
  l9: "iso885915",
  l10: "iso885916",

  isoir14: "iso646jp",
  isoir57: "iso646cn",
  isoir100: "iso88591",
  isoir101: "iso88592",
  isoir109: "iso88593",
  isoir110: "iso88594",
  isoir144: "iso88595",
  isoir127: "iso88596",
  isoir126: "iso88597",
  isoir138: "iso88598",
  isoir148: "iso88599",
  isoir157: "iso885910",
  isoir166: "tis620",
  isoir179: "iso885913",
  isoir199: "iso885914",
  isoir203: "iso885915",
  isoir226: "iso885916",

  cp819: "iso88591",
  ibm819: "iso88591",

  cyrillic: "iso88595",

  arabic: "iso88596",
  arabic8: "iso88596",
  ecma114: "iso88596",
  asmo708: "iso88596",

  greek: "iso88597",
  greek8: "iso88597",
  ecma118: "iso88597",
  elot928: "iso88597",

  hebrew: "iso88598",
  hebrew8: "iso88598",

  turkish: "iso88599",
  turkish8: "iso88599",

  thai: "iso885911",
  thai8: "iso885911",

  celtic: "iso885914",
  celtic8: "iso885914",
  isoceltic: "iso885914",

  tis6200: "tis620",
  tis62025291: "tis620",
  tis62025330: "tis620",

  10000: "macroman",
  10006: "macgreek",
  10007: "maccyrillic",
  10079: "maciceland",
  10081: "macturkish",

  cspc8codepage437: "cp437",
  cspc775baltic: "cp775",
  cspc850multilingual: "cp850",
  cspcp852: "cp852",
  cspc862latinhebrew: "cp862",
  cpgr: "cp869",

  msee: "cp1250",
  mscyrl: "cp1251",
  msansi: "cp1252",
  msgreek: "cp1253",
  msturk: "cp1254",
  mshebr: "cp1255",
  msarab: "cp1256",
  winbaltrim: "cp1257",

  cp20866: "koi8r",
  20866: "koi8r",
  ibm878: "koi8r",
  cskoi8r: "koi8r",

  cp21866: "koi8u",
  21866: "koi8u",
  ibm1168: "koi8u",

  strk10482002: "rk1048",

  tcvn5712: "tcvn",
  tcvn57121: "tcvn",

  gb198880: "iso646cn",
  cn: "iso646cn",

  csiso14jisc6220ro: "iso646jp",
  jisc62201969ro: "iso646jp",
  jp: "iso646jp",

  cshproman8: "hproman8",
  r8: "hproman8",
  roman8: "hproman8",
  xroman8: "hproman8",
  ibm1051: "hproman8",

  mac: "macintosh",
  csmacintosh: "macintosh"
};
//
},
'iconv-lite/encodings/sbcs-data-generated':
function(module) {
// noinspection SpellCheckingInspection
module.exports = {
  437: "cp437",
  737: "cp737",
  775: "cp775",
  850: "cp850",
  852: "cp852",
  855: "cp855",
  856: "cp856",
  857: "cp857",
  858: "cp858",
  860: "cp860",
  861: "cp861",
  862: "cp862",
  863: "cp863",
  864: "cp864",
  865: "cp865",
  866: "cp866",
  869: "cp869",
  874: "windows874",
  922: "cp922",
  1046: "cp1046",
  1124: "cp1124",
  1125: "cp1125",
  1129: "cp1129",
  1133: "cp1133",
  1161: "cp1161",
  1162: "cp1162",
  1163: "cp1163",
  1250: "windows1250",
  1251: "windows1251",
  1252: "windows1252",
  1253: "windows1253",
  1254: "windows1254",
  1255: "windows1255",
  1256: "windows1256",
  1257: "windows1257",
  1258: "windows1258",
  28591: "iso88591",
  28592: "iso88592",
  28593: "iso88593",
  28594: "iso88594",
  28595: "iso88595",
  28596: "iso88596",
  28597: "iso88597",
  28598: "iso88598",
  28599: "iso88599",
  28600: "iso885910",
  28601: "iso885911",
  28603: "iso885913",
  28604: "iso885914",
  28605: "iso885915",
  28606: "iso885916",
  windows874: {
    type: "_sbcs",
    chars: ""
  },
  win874: "windows874",
  cp874: "windows874",
  windows1250: {
    type: "_sbcs",
    chars: ""
  },
  win1250: "windows1250",
  cp1250: "windows1250",
  windows1251: {
    type: "_sbcs",
    chars: ""
  },
  win1251: "windows1251",
  cp1251: "windows1251",
  windows1252: {
    type: "_sbcs",
    chars: ""
  },
  win1252: "windows1252",
  cp1252: "windows1252",
  windows1253: {
    type: "_sbcs",
    chars: ""
  },
  win1253: "windows1253",
  cp1253: "windows1253",
  windows1254: {
    type: "_sbcs",
    chars: ""
  },
  win1254: "windows1254",
  cp1254: "windows1254",
  windows1255: {
    type: "_sbcs",
    chars: ""
  },
  win1255: "windows1255",
  cp1255: "windows1255",
  windows1256: {
    type: "_sbcs",
    chars: ""
  },
  win1256: "windows1256",
  cp1256: "windows1256",
  windows1257: {
    type: "_sbcs",
    chars: ""
  },
  win1257: "windows1257",
  cp1257: "windows1257",
  windows1258: {
    type: "_sbcs",
    chars: ""
  },
  win1258: "windows1258",
  cp1258: "windows1258",
  iso88591: {
    type: "_sbcs",
    chars: ""
  },
  cp28591: "iso88591",
  iso88592: {
    type: "_sbcs",
    chars: ""
  },
  cp28592: "iso88592",
  iso88593: {
    type: "_sbcs",
    chars: ""
  },
  cp28593: "iso88593",
  iso88594: {
    type: "_sbcs",
    chars: ""
  },
  cp28594: "iso88594",
  iso88595: {
    type: "_sbcs",
    chars: ""
  },
  cp28595: "iso88595",
  iso88596: {
    type: "_sbcs",
    chars: ""
  },
  cp28596: "iso88596",
  iso88597: {
    type: "_sbcs",
    chars: ""
  },
  cp28597: "iso88597",
  iso88598: {
    type: "_sbcs",
    chars: ""
  },
  cp28598: "iso88598",
  iso88599: {
    type: "_sbcs",
    chars: ""
  },
  cp28599: "iso88599",
  iso885910: {
    type: "_sbcs",
    chars: ""
  },
  cp28600: "iso885910",
  iso885911: {
    type: "_sbcs",
    chars: ""
  },
  cp28601: "iso885911",
  iso885913: {
    type: "_sbcs",
    chars: ""
  },
  cp28603: "iso885913",
  iso885914: {
    type: "_sbcs",
    chars: ""
  },
  cp28604: "iso885914",
  iso885915: {
    type: "_sbcs",
    chars: ""
  },
  cp28605: "iso885915",
  iso885916: {
    type: "_sbcs",
    chars: ""
  },
  cp28606: "iso885916",
  cp437: {
    type: "_sbcs",
    chars: ""
  },
  ibm437: "cp437",
  csibm437: "cp437",
  cp737: {
    type: "_sbcs",
    chars: ""
  },
  ibm737: "cp737",
  csibm737: "cp737",
  cp775: {
    type: "_sbcs",
    chars: ""
  },
  ibm775: "cp775",
  csibm775: "cp775",
  cp850: {
    type: "_sbcs",
    chars: ""
  },
  ibm850: "cp850",
  csibm850: "cp850",
  cp852: {
    type: "_sbcs",
    chars: ""
  },
  ibm852: "cp852",
  csibm852: "cp852",
  cp855: {
    type: "_sbcs",
    chars: ""
  },
  ibm855: "cp855",
  csibm855: "cp855",
  cp856: {
    type: "_sbcs",
    chars: ""
  },
  ibm856: "cp856",
  csibm856: "cp856",
  cp857: {
    type: "_sbcs",
    chars: ""
  },
  ibm857: "cp857",
  csibm857: "cp857",
  cp858: {
    type: "_sbcs",
    chars: ""
  },
  ibm858: "cp858",
  csibm858: "cp858",
  cp860: {
    type: "_sbcs",
    chars: ""
  },
  ibm860: "cp860",
  csibm860: "cp860",
  cp861: {
    type: "_sbcs",
    chars: ""
  },
  ibm861: "cp861",
  csibm861: "cp861",
  cp862: {
    type: "_sbcs",
    chars: ""
  },
  ibm862: "cp862",
  csibm862: "cp862",
  cp863: {
    type: "_sbcs",
    chars: ""
  },
  ibm863: "cp863",
  csibm863: "cp863",
  cp864: {
    type: "_sbcs",
    chars: "\0\x01\x02\x03\x04\x05\x06\x07\b\t\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  ibm864: "cp864",
  csibm864: "cp864",
  cp865: {
    type: "_sbcs",
    chars: ""
  },
  ibm865: "cp865",
  csibm865: "cp865",
  cp866: {
    type: "_sbcs",
    chars: ""
  },
  ibm866: "cp866",
  csibm866: "cp866",
  cp869: {
    type: "_sbcs",
    chars: ""
  },
  ibm869: "cp869",
  csibm869: "cp869",
  cp922: {
    type: "_sbcs",
    chars: ""
  },
  ibm922: "cp922",
  csibm922: "cp922",
  cp1046: {
    type: "_sbcs",
    chars: ""
  },
  ibm1046: "cp1046",
  csibm1046: "cp1046",
  cp1124: {
    type: "_sbcs",
    chars: ""
  },
  ibm1124: "cp1124",
  csibm1124: "cp1124",
  cp1125: {
    type: "_sbcs",
    chars: ""
  },
  ibm1125: "cp1125",
  csibm1125: "cp1125",
  cp1129: {
    type: "_sbcs",
    chars: ""
  },
  ibm1129: "cp1129",
  csibm1129: "cp1129",
  cp1133: {
    type: "_sbcs",
    chars: ""
  },
  ibm1133: "cp1133",
  csibm1133: "cp1133",
  cp1161: {
    type: "_sbcs",
    chars: ""
  },
  ibm1161: "cp1161",
  csibm1161: "cp1161",
  cp1162: {
    type: "_sbcs",
    chars: ""
  },
  ibm1162: "cp1162",
  csibm1162: "cp1162",
  cp1163: {
    type: "_sbcs",
    chars: ""
  },
  ibm1163: "cp1163",
  csibm1163: "cp1163",
  maccroatian: {
    type: "_sbcs",
    chars: ""
  },
  maccyrillic: {
    type: "_sbcs",
    chars: ""
  },
  macgreek: {
    type: "_sbcs",
    chars: ""
  },
  maciceland: {
    type: "_sbcs",
    chars: ""
  },
  macroman: {
    type: "_sbcs",
    chars: ""
  },
  macromania: {
    type: "_sbcs",
    chars: ""
  },
  macthai: {
    type: "_sbcs",
    chars: "\ufeff"
  },
  macturkish: {
    type: "_sbcs",
    chars: ""
  },
  macukraine: {
    type: "_sbcs",
    chars: ""
  },
  koi8r: {
    type: "_sbcs",
    chars: ""
  },
  koi8u: {
    type: "_sbcs",
    chars: ""
  },
  koi8ru: {
    type: "_sbcs",
    chars: ""
  },
  koi8t: {
    type: "_sbcs",
    chars: ""
  },
  armscii8: {
    type: "_sbcs",
    chars: ")(.,-"
  },
  rk1048: {
    type: "_sbcs",
    chars: ""
  },
  tcvn: {
    type: "_sbcs",
    chars: "\0\x03\x07\b\t\n\v\f\r\x0e\x0f\x10\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  georgianacademy: {
    type: "_sbcs",
    chars: ""
  },
  georgianps: {
    type: "_sbcs",
    chars: ""
  },
  pt154: {
    type: "_sbcs",
    chars: ""
  },
  viscii: {
    type: "_sbcs",
    chars: "\0\x01\x03\x04\x07\b\t\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x15\x16\x17\x18\x1a\x1b\x1c\x1d\x1f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  iso646cn: {
    type: "_sbcs",
    chars: "\0\x01\x02\x03\x04\x05\x06\x07\b\t\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
  },
  iso646jp: {
    type: "_sbcs",
    chars: "\0\x01\x02\x03\x04\x05\x06\x07\b\t\n\v\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
  },
  hproman8: {
    type: "_sbcs",
    chars: ""
  },
  macintosh: {
    type: "_sbcs",
    chars: ""
  },
  ascii: {
    type: "_sbcs",
    chars: ""
  },
  tis620: {
    type: "_sbcs",
    chars: ""
  }
}
//
},
'iconv-lite/encodings/dbcs-codec':
function(module, exports, __wpreq__) {
//
var Buffer = __wpreq__('safer-buffer').Buffer;

exports._dbcs = DBCSCodec;

var UNASSIGNED = -1,
  GB18030_CODE = -2,
  SEQ_START = -10,
  NODE_START = -1000,
  UNASSIGNED_NODE = new Array(0x100),
  DEF_CHAR = -1;

for (var i = 0; i < 0x100; i++) UNASSIGNED_NODE[i] = UNASSIGNED;

function DBCSCodec(codecOptions, iconv) {
  this.encodingName = codecOptions.encodingName;
  if (!codecOptions) throw new Error("DBCS codec is called without the data.")
  if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");

  var mappingTable = codecOptions.table();

  this.decodeTables = [];
  this.decodeTables[0] = UNASSIGNED_NODE.slice(0);

  this.decodeTableSeq = [];

  for (var i = 0; i < mappingTable.length; i++) this._addDecodeChunk(mappingTable[i]);

  this.defaultCharUnicode = iconv.defaultCharUnicode;

  this.encodeTable = [];
  this.encodeTableSeq = [];

  var skipEncodeChars = {};
  if (codecOptions.encodeSkipVals)
    for (i = 0; i < codecOptions.encodeSkipVals.length; i++) {
      var val = codecOptions.encodeSkipVals[i];
      if (typeof val == 'number') skipEncodeChars[val] = true;
      else for (var j = val.from; j <= val.to; j++) skipEncodeChars[j] = true;
    }

  this._fillEncodeTable(0, 0, skipEncodeChars);

  if (codecOptions.encodeAdd)
    for (var uChar in codecOptions.encodeAdd)
      Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar) &&
        this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);

  this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
  if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
  if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);

  if (typeof codecOptions.gb18030 == 'function') {
    this.gb18030 = codecOptions.gb18030();

    var thirdByteNodeIdx = this.decodeTables.length,
      thirdByteNode = (this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0)),

      fourthByteNodeIdx = this.decodeTables.length,
      fourthByteNode = (this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0));

    for (i = 0x81; i <= 0xFE; i++) {
      var secondByteNodeIdx = NODE_START - this.decodeTables[0][i],
        secondByteNode = this.decodeTables[secondByteNodeIdx];
      for (j = 0x30; j <= 0x39; j++) secondByteNode[j] = NODE_START - thirdByteNodeIdx;
    }
    for (i = 0x81; i <= 0xFE; i++) thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
    for (i = 0x30; i <= 0x39; i++) fourthByteNode[i] = GB18030_CODE
  }
}

DBCSCodec.prototype.encoder = DBCSEncoder;
DBCSCodec.prototype.decoder = DBCSDecoder;

DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
  var bytes = [];
  for (; addr > 0; addr >>= 8) bytes.push(addr & 0xFF);
  bytes.length != 0 || bytes.push(0);

  var node = this.decodeTables[0];
  for (var i = bytes.length - 1; i > 0; i--) {
    var val = node[bytes[i]];

    if (val == UNASSIGNED) {
      node[bytes[i]] = NODE_START - this.decodeTables.length;
      this.decodeTables.push((node = UNASSIGNED_NODE.slice(0)));
    } else if (val <= NODE_START) node = this.decodeTables[NODE_START - val];
    else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
  }
  return node;
}

DBCSCodec.prototype._addDecodeChunk = function(chunk) {
  var curAddr = parseInt(chunk[0], 16),

    writeTable = this._getDecodeTrieNode(curAddr);
  curAddr &= 0xFF;

  for (var k = 1; k < chunk.length; k++) {
    var part = chunk[k];
    if (typeof part == "string")
      for (var l = 0; l < part.length; ) {
        var code = part.charCodeAt(l++);
        if (0xD800 <= code && code < 0xDC00) {
          var codeTrail = part.charCodeAt(l++);
          if (0xDC00 > codeTrail || codeTrail >= 0xE000)
            throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);

          writeTable[curAddr++] = 0x10000 + 0x400 * (code - 0xD800) + (codeTrail - 0xDC00);
        } else if (0x0FF0 < code && code <= 0x0FFF) {
          var seq = [];
          for (var len = 0xFFF - code + 2, m = 0; m < len; m++) seq.push(part.charCodeAt(l++));

          writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
          this.decodeTableSeq.push(seq);
        } else writeTable[curAddr++] = code;
      }
    else if (typeof part == "number") {
      var charCode = writeTable[curAddr - 1] + 1;
      for (l = 0; l < part; l++) writeTable[curAddr++] = charCode++;
    } else
      throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
  }
  if (curAddr > 0xFF)
    throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
}

DBCSCodec.prototype._getEncodeBucket = function(uCode) {
  var high = uCode >> 8;
  if (this.encodeTable[high] === void 0) this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
  return this.encodeTable[high];
}

DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
  var bucket = this._getEncodeBucket(uCode),
    low = uCode & 0xFF;
  if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
  else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
}

DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
  var node,
    uCode = seq[0],
    bucket = this._getEncodeBucket(uCode),
    low = uCode & 0xFF;

  if (bucket[low] <= SEQ_START) node = this.encodeTableSeq[SEQ_START - bucket[low]];
  else {
    node = {};
    if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
    bucket[low] = SEQ_START - this.encodeTableSeq.length;
    this.encodeTableSeq.push(node);
  }

  for (var j = 1; j < seq.length - 1; j++) {
    var oldVal = node[uCode];
    if (typeof oldVal == 'object') node = oldVal;
    else {
      node = node[uCode] = {}
      if (oldVal !== void 0) node[DEF_CHAR] = oldVal
    }
  }

  uCode = seq[seq.length - 1];
  node[uCode] = dbcsCode;
}

DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
  for (var node = this.decodeTables[nodeIdx], i = 0; i < 0x100; i++) {
    var uCode = node[i],
      mbCode = prefix + i;
    if (skipEncodeChars[mbCode]) continue;

    uCode >= 0
      ? this._setEncodeChar(uCode, mbCode)
      : uCode <= NODE_START
      ? this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars)
      : uCode <= SEQ_START && this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
  }
}

function DBCSEncoder(options, codec) {
  this.leadSurrogate = -1;
  this.seqObj = void 0;

  this.encodeTable = codec.encodeTable;
  this.encodeTableSeq = codec.encodeTableSeq;
  this.defaultCharSingleByte = codec.defCharSB;
  this.gb18030 = codec.gb18030;
}

DBCSEncoder.prototype.write = function(str) {
  var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
    leadSurrogate = this.leadSurrogate,
    seqObj = this.seqObj,
    j = 0;

  for (var nextChar = -1, i = 0; ; ) {
    if (nextChar === -1) {
      if (i == str.length) break;
      var uCode = str.charCodeAt(i++);
    } else {
      uCode = nextChar;
      nextChar = -1;
    }

    if (0xD800 <= uCode && uCode < 0xE000)
      if (uCode < 0xDC00) {
        if (leadSurrogate === -1) {
          leadSurrogate = uCode;
          continue;
        }

        leadSurrogate = uCode;
        uCode = UNASSIGNED;
      } else if (leadSurrogate !== -1) {
        uCode = 0x10000 + 0x400 * (leadSurrogate - 0xD800) + (uCode - 0xDC00);
        leadSurrogate = -1;
      } else uCode = UNASSIGNED;
    else if (leadSurrogate !== -1) {
      nextChar = uCode;
      uCode = UNASSIGNED;
      leadSurrogate = -1;
    }

    var dbcsCode = UNASSIGNED;
    if (seqObj !== void 0 && uCode != UNASSIGNED) {
      var resCode = seqObj[uCode];
      if (typeof resCode == 'object') {
        seqObj = resCode;
        continue;
      }
      if (typeof resCode == 'number') dbcsCode = resCode;
      else if (resCode == null && (resCode = seqObj[DEF_CHAR]) !== void 0) {
        dbcsCode = resCode;
        nextChar = uCode;
      } // else {}
      seqObj = void 0;
    } else if (uCode >= 0) {
      var subtable = this.encodeTable[uCode >> 8];
      if (subtable !== void 0) dbcsCode = subtable[uCode & 0xFF];

      if (dbcsCode <= SEQ_START) {
        seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
        continue;
      }

      if (dbcsCode == UNASSIGNED && this.gb18030) {
        var idx = findIdx(this.gb18030.uChars, uCode);
        if (idx != -1) {
          dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);
          dbcsCode %= 12600;
          newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);
          dbcsCode %= 1260;
          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);
          dbcsCode %= 10;
          newBuf[j++] = 0x30 + dbcsCode;
          continue;
        }
      }
    }

    if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;

    if (dbcsCode < 0x100) newBuf[j++] = dbcsCode;
    else if (dbcsCode < 0x10000) {
      newBuf[j++] = dbcsCode >> 8;
      newBuf[j++] = dbcsCode & 0xFF;
    } else {
      newBuf[j++] = dbcsCode >> 16;
      newBuf[j++] = (dbcsCode >> 8) & 0xFF;
      newBuf[j++] = dbcsCode & 0xFF;
    }
  }

  this.seqObj = seqObj;
  this.leadSurrogate = leadSurrogate;
  return newBuf.slice(0, j);
}

DBCSEncoder.prototype.end = function() {
  if (this.leadSurrogate === -1 && this.seqObj === void 0) return;

  var newBuf = Buffer.alloc(10), j = 0;

  if (this.seqObj) {
    var dbcsCode = this.seqObj[DEF_CHAR];
    if (dbcsCode !== void 0)
      if (dbcsCode < 0x100) newBuf[j++] = dbcsCode;
      else {
        newBuf[j++] = dbcsCode >> 8;
        newBuf[j++] = dbcsCode & 0xFF;
      }
    // else {}

    this.seqObj = void 0;
  }

  if (this.leadSurrogate !== -1) {
    newBuf[j++] = this.defaultCharSingleByte;
    this.leadSurrogate = -1;
  }

  return newBuf.slice(0, j);
}

DBCSEncoder.prototype.findIdx = findIdx;

function DBCSDecoder(options, codec) {
  this.nodeIdx = 0;
  this.prevBuf = Buffer.alloc(0);

  this.decodeTables = codec.decodeTables;
  this.decodeTableSeq = codec.decodeTableSeq;
  this.defaultCharUnicode = codec.defaultCharUnicode;
  this.gb18030 = codec.gb18030;
}

DBCSDecoder.prototype.write = function(buf) {
  var newBuf = Buffer.alloc(buf.length * 2),
    nodeIdx = this.nodeIdx,
    prevBuf = this.prevBuf,
    prevBufOffset = this.prevBuf.length,
    seqStart = -this.prevBuf.length;

  if (prevBufOffset > 0) prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);

  for (var i = 0, j = 0; i < buf.length; i++) {
    var curByte = i >= 0 ? buf[i] : prevBuf[i + prevBufOffset],

      uCode = this.decodeTables[nodeIdx][curByte];

    if (uCode >= 0);
    else if (uCode === UNASSIGNED) {
      i = seqStart;
      uCode = this.defaultCharUnicode.charCodeAt(0);
    } else if (uCode === GB18030_CODE) {
      var curSeq =
          seqStart >= 0 ? buf.slice(seqStart, i + 1) : prevBuf.slice(seqStart + prevBufOffset, i + 1 + prevBufOffset),
        ptr = 12600 * (curSeq[0] - 0x81) + 1260 * (curSeq[1] - 0x30) + 10 * (curSeq[2] - 0x81) + (curSeq[3] - 0x30),
        idx = findIdx(this.gb18030.gbChars, ptr);
      uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
    } else if (uCode <= NODE_START) {
      nodeIdx = NODE_START - uCode;
      continue;
    } else if (uCode <= SEQ_START) {
      var seq = this.decodeTableSeq[SEQ_START - uCode];
      for (var k = 0; k < seq.length - 1; k++) {
        uCode = seq[k];
        newBuf[j++] = uCode & 0xFF;
        newBuf[j++] = uCode >> 8;
      }
      uCode = seq[seq.length - 1];
    } else
      throw new Error(
        "iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte
      );

    if (uCode > 0xFFFF) {
      uCode -= 0x10000;
      var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
      newBuf[j++] = uCodeLead & 0xFF;
      newBuf[j++] = uCodeLead >> 8;

      uCode = 0xDC00 + (uCode % 0x400);
    }
    newBuf[j++] = uCode & 0xFF;
    newBuf[j++] = uCode >> 8;

    nodeIdx = 0;
    seqStart = i + 1;
  }

  this.nodeIdx = nodeIdx;
  this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
  return newBuf.slice(0, j).toString('ucs2');
}

DBCSDecoder.prototype.end = function() {
  var ret = '';

  while (this.prevBuf.length > 0) {
    ret += this.defaultCharUnicode;
    var buf = this.prevBuf.slice(1);

    this.prevBuf = Buffer.alloc(0);
    this.nodeIdx = 0;
    if (buf.length > 0) ret += this.write(buf);
  }

  this.nodeIdx = 0;
  return ret;
}

function findIdx(table, val) {
  if (table[0] > val) return -1;

  var l = 0;
  for (var r = table.length; l < r - 1; ) {
    var mid = l + Math.floor((r - l + 1) / 2);
    table[mid] <= val ? (l = mid) : (r = mid);
  }
  return l;
}
//
},
'iconv-lite/encodings/dbcs-data':
function(module, exports, __wpreq__) {
// noinspection SpellCheckingInspection
module.exports = {
  shiftjis: {
    type: '_dbcs',
    table: function() { return __wpreq__('iconv-lite/encodings/tables/shiftjis.json') },
    encodeAdd: {'\xa5': 0x5C, '\u203E': 0x7E},
    encodeSkipVals: [{from: 0xED40, to: 0xF940}]
  },
  csshiftjis: 'shiftjis',
  mskanji: 'shiftjis',
  sjis: 'shiftjis',
  windows31j: 'shiftjis',
  ms31j: 'shiftjis',
  xsjis: 'shiftjis',
  windows932: 'shiftjis',
  ms932: 'shiftjis',
  932: 'shiftjis',
  cp932: 'shiftjis',

  eucjp: {
    type: '_dbcs',
    table: function() { return __wpreq__('iconv-lite/encodings/tables/eucjp.json') },
    encodeAdd: {'\xa5': 0x5C, '\u203E': 0x7E}
  },

  gb2312: 'cp936',
  gb231280: 'cp936',
  gb23121980: 'cp936',
  csgb2312: 'cp936',
  csiso58gb231280: 'cp936',
  euccn: 'cp936',

  windows936: 'cp936',
  ms936: 'cp936',
  936: 'cp936',
  cp936: {
    type: '_dbcs',
    table: function() { return __wpreq__('iconv-lite/encodings/tables/cp936.json') }
  },

  gbk: {
    type: '_dbcs',
    table: function() {
      return __wpreq__('iconv-lite/encodings/tables/cp936.json').concat(__wpreq__('iconv-lite/encodings/tables/gbk-added.json'))
    }
  },
  xgbk: 'gbk',
  isoir58: 'gbk',

  gb18030: {
    type: '_dbcs',
    table: function() {
      return __wpreq__('iconv-lite/encodings/tables/cp936.json').concat(__wpreq__('iconv-lite/encodings/tables/gbk-added.json'))
    },
    gb18030: function() { return __wpreq__('iconv-lite/encodings/tables/gb18030-ranges.json') },
    encodeSkipVals: [0x80],
    encodeAdd: {'\u20ac': 0xA2E3}
  },

  chinese: 'gb18030',

  windows949: 'cp949',
  ms949: 'cp949',
  949: 'cp949',
  cp949: {
    type: '_dbcs',
    table: function() { return __wpreq__('iconv-lite/encodings/tables/cp949.json') }
  },

  cseuckr: 'cp949',
  csksc56011987: 'cp949',
  euckr: 'cp949',
  isoir149: 'cp949',
  korean: 'cp949',
  ksc56011987: 'cp949',
  ksc56011989: 'cp949',
  ksc5601: 'cp949',

  windows950: 'cp950',
  ms950: 'cp950',
  950: 'cp950',
  cp950: {
    type: '_dbcs',
    table: function() { return __wpreq__('iconv-lite/encodings/tables/cp950.json') }
  },

  big5: 'big5hkscs',
  big5hkscs: {
    type: '_dbcs',
    table: function() {
      return __wpreq__('iconv-lite/encodings/tables/cp950.json').concat(__wpreq__('iconv-lite/encodings/tables/big5-added.json'))
    },
    encodeSkipVals: [0xa2cc]
  },

  cnbig5: 'big5hkscs',
  csbig5: 'big5hkscs',
  xxbig5: 'big5hkscs'
};
//
},
'iconv-lite/encodings/tables/shiftjis.json':
function(module) {
//
module.exports = JSON.parse(
  '[["0","\\u0000",128],["a1","",62],["8140","",9,""],["8180",""],["81b8",""],["81c8",""],["81da",""],["81f0",""],["81fc",""],["824f","",9],["8260","",25],["8281","",25],["829f","",82],["8340","",62],["8380","",22],["839f","",16,"",6],["83bf","",16,"",6],["8440","",5,"",25],["8470","",5,"",7],["8480","",17],["849f",""],["8740","",19,"",9],["875f",""],["877e",""],["8780","",4,""],["889f",""],["8940",""],["8980",""],["8a40",""],["8a80",""],["8b40",""],["8b80",""],["8c40",""],["8c80",""],["8d40",""],["8d80",""],["8e40",""],["8e80",""],["8f40",""],["8f80",""],["9040",""],["9080",""],["9140",""],["9180",""],["9240",""],["9280",""],["9340",""],["9380",""],["9440",""],["9480",""],["9540",""],["9580",""],["9640",""],["9680",""],["9740",""],["9780",""],["9840",""],\
["989f",""],["9940",""],["9980",""],["9a40",""],["9a80",""],["9b40",""],["9b80",""],["9c40",""],["9c80",""],["9d40",""],["9d80",""],["9e40",""],["9e80",""],["9f40",""],["9f80",""],["e040",""],["e080",""],["e140",""],["e180",""],["e240",""],["e280",""],["e340",""],["e380",""],["e440",""],["e480",""],["e540",""],["e580",""],["e640",""],["e680",""],["e740",""],["e780",""],["e840",""],["e880",""],["e940",""],["e980",""],["ea40",""],["ea80",""],["ed40",""],\
["ed80",""],["ee40",""],["ee80",""],["eeef","",9,""],["f040","",62],["f080","",124],["f140","",62],["f180","",124],["f240","",62],["f280","",124],["f340","",62],["f380","",124],["f440","",62],["f480","",124],["f540","",62],["f580","",124],["f640","",62],["f680","",124],["f740","",62],["f780","",124],["f840","",62],["f880","",124],["f940",""],["fa40","",9,"",9,""],["fa80",""],["fb40",""],["fb80",""],["fc40",""]]'
);
//
},
'iconv-lite/encodings/tables/eucjp.json':
function(module) {
// noinspection SpellCheckingInspection
module.exports = JSON.parse(
  '[["0","\\u0000",127],["8ea1","",62],["a1a1","",9,""],["a2a1",""],["a2ba",""],["a2ca",""],["a2dc",""],["a2f2",""],["a2fe",""],["a3b0","",9],["a3c1","",25],["a3e1","",25],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a7a1","",5,"",25],["a7d1","",5,"",25],["a8a1",""],["ada1","",19,"",9],["adc0",""],["addf","",4,""],["b0a1",""],["b1a1",""],["b2a1",""],["b3a1",""],["b4a1",""],["b5a1",""],["b6a1",""],["b7a1",""],["b8a1",""],["b9a1",""],["baa1",""],["bba1",""],["bca1",""],["bda1",""],["bea1",""],["bfa1",""],["c0a1",""],["c1a1",""],["c2a1",""],["c3a1",""],["c4a1",""],["c5a1",""],["c6a1",""],["c7a1",""],["c8a1",""],["c9a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],\
["d0a1",""],["d1a1",""],["d2a1",""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f9a1",""],\
["faa1",""],["fba1",""],["fca1",""],["fcf1","",9,""],["8fa2af",""],["8fa2c2",""],["8fa2eb",""],["8fa6e1",""],["8fa6e7",""],["8fa6e9",""],["8fa6ec",""],["8fa6f1",""],["8fa7c2","",10,""],["8fa7f2","",10,""],["8fa9a1",""],["8fa9a4",""],["8fa9a6",""],["8fa9a8",""],["8fa9ab",""],["8fa9af",""],["8fa9c1",""],["8faaa1",""],["8faaba",""],["8faba1",""],["8fabbd",""],["8fabc5",""],["8fb0a1",""],["8fb1a1",""],["8fb2a1","",4,""],["8fb3a1",""],["8fb4a1",""],["8fb5a1",""],["8fb6a1","",5,"",4,""],["8fb7a1","",4,""],["8fb8a1",""],["8fb9a1",""],["8fbaa1","",4,""],["8fbba1",""],["8fbca1","",4,""],["8fbda1","",4,""],["8fbea1","",4,""],["8fbfa1",""],["8fc0a1",""],["8fc1a1",""],["8fc2a1",""],["8fc3a1","",4,""],["8fc4a1",""],["8fc5a1",""],["8fc6a1",""],["8fc7a1",""],["8fc8a1",""],["8fc9a1","",4,"",4,""],["8fcaa1",""],["8fcba1",""],\
["8fcca1","",9,""],["8fcda1","",5,""],["8fcea1","",6,""],["8fcfa1",""],["8fd0a1",""],["8fd1a1",""],["8fd2a1","",5],["8fd3a1",""],["8fd4a1","",4,""],["8fd5a1",""],["8fd6a1",""],["8fd7a1",""],["8fd8a1",""],["8fd9a1","",4,"",6,""],["8fdaa1","",4,""],["8fdba1","",6,""],["8fdca1","",4,""],["8fdda1","",4,""],["8fdea1","",4,""],["8fdfa1",""],["8fe0a1",""],["8fe1a1","",4,""],["8fe2a1",""],["8fe3a1","",5,"",4,""],["8fe4a1","",4,""],["8fe5a1","",4,""],["8fe6a1",""],["8fe7a1",""],["8fe8a1","",4,""],["8fe9a1","",4],["8feaa1","",4,""],["8feba1","",4,""],["8feca1",""],["8feda1","",4,"",4,""]]'
);
//
},
'iconv-lite/encodings/tables/cp936.json':
function(module) {
//
module.exports = JSON.parse(
  '[["0","\\u0000",127,""],["8140","",5,"",9,"",6,""],["8180","",6,"",4,"",4,"",5,""],["8240","",4,"",8,"",4,"",11],["8280","",10,"",4,"",7,"",5,"",8,"",20,"",4,"",6,""],["8340","",17,"",5,"",10,"",4,"",9,""],["8380","",5,"",13,"",28,"",4,"",4,"",5],["8440","",5,"",5,""],["8480","",9,"",4,"",6,"",6,"",9,"",5,"",10,"",7,""],["8540","",9,""],["8580","",4,"",6,"",4,"",4,"",7,""],["8640","",4,"",5,"",4,"",5,""],["8680","",4,"",4,"",5,"",6,"",8,"",4,"",4,"",4,""],["8740","",7,"",11,"",4,"",4],["8780","",7,"",6,"",14,"",10,"",6,"",12,"",8,"",5,"",6],["8840","",9,"",4,"",4,""],["8880","",4,"",6,"",8,"",6,"",7,"",4,"",4,"",7],["8940","",5,"",6,"",4,"",5,"",4,"",16,""],["8980","",4,"",4,"",7,"",17,"",10,"",13,"",5,"",7,"",4,""],["8a40","",4,"",12,""],["8a80","",5,"",6,"",4,"",11,"",6,"",4,"",4,"",9,"",5],["8b40","",8,"",17,"",6,"",13,""],["8b80","",4,"",4,"",5,"",4,"",4,"",22,"",11,"",25,"",7,"",6],["8c40","",7,""],["8c80","",8,"",4,"",6,"",6,"",6,"",4,"",4,"",4],["8d40","",5,"",5,"",5,"",6,"",9,"",4],["8d80","",5,"",4,"",4,"",4,"",7,"",7,"",10,"",10,"",12,"",21,""],["8e40","",21,"",12,"",6,"",12,""],["8e80","",4,"",7,"",4,"",4,"",5,"",6,"",4,"",14,"",4,"",4,"",6],["8f40","",5,"",11,"",8,""],["8f80","",6,"",14,"",5,"",5,"",4,""],["9040","",4,"",4,"",6,""],["9080","",7,"",4,"",4,"",4,"",4,"",18,"",6],["9140","",6,"",6,"",18,"",4,""],["9180","",6,"",8,"",9,"",5,"",4,"",4,"",16,"",13,"",8,"",5,"",4,""],["9240","",6,"",5,""],["9280","",5,"",7,"",6,""],["9340","",6,"",4,"",4,"",5,""],["9380","",5,"",4,"",6,"",4,"",7,"",9,"",6,"",8,"",4,"",6,""],["9440","",24,"",7,"",7,"",4,"",8],["9480","",4,"",4,"",14,"",7,"",7,""],["9540","",4,"",4,"",6,""],\
["9580","",4,"",4,"",8,"",4,"",4,"",25,"",7,"",5,""],["9640","",5,"",4,""],["9680","",7,"",9,"",7,"",4,"",6,"",6,"",5],["9740","",7,"",8,"",7,"",9,""],["9780","",6,"",5,"",4,"",9,"",4,"",11,"",7,"",16,""],["9840","",4,"",5,"",9,""],["9880","",7,"",5,"",11,"",9,"",9,"",11,"",5,"",5,"",6,"",4,"",7,"",6,""],["9940","",4,"",10,"",6,"",8,"",4,"",7,"",5],["9980","",114,"",6],["9a40","",11,"",7,"",13,""],["9a80","",4,"",7,"",7,"",6,"",4,"",4,"",7,"",6,"",4,"",4,""],["9b40","",4,""],["9b80","",5,"",4,"",4,"",5,""],["9c40","",7,""],["9c80","",7,"",7,"",10,"",14,"",4,"",6,"",5],["9d40","",7,"",4,"",9,"",6,""],["9d80","",9,"",5,"",6,"",12,"",4,"",10,"",5,"",5,"",6,"",10,""],["9e40","",7,"",32,"",7,"",6,"",6],["9e80","",9,"",17,"",13,"",11,"",12,"",12,""],["9f40","",6,"",10,"",4,"",10,"",7,""],["9f80","",13,"",12,"",4,"",4,"",5,"",4,"",4,"",6,"",5,"",8,"",9,"",4],["a040","",9,"",5,"",9,"",11,"",19],["a080","",9,"",6,"",4,"",11,"",11,"",6,""],["a1a1","",7,""],["a2a1","",9],["a2b1","",19,"",19,"",9],["a2e5","",9],["a2f1","",11],["a3a1","",88,""],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a6e0",""],["a6ee",""],["a6f4",""],["a7a1","",5,"",25],["a7d1","",5,"",25],["a840","",35,"",6],["a880","",7,""],["a8a1",""],["a8bd",""],["a8c0",""],["a8c5","",36],["a940","",8,""],["a959",""],["a95c",""],["a960","",9,"",8],["a980","",4,""],["a996",""],["a9a4","",75],["aa40","",5,"",5,"",8],["aa80","",7,"",10,""],["ab40","",11,"",4,"",5,"",4],["ab80","",6,"",4],["ac40","",10,"",8,"",5,"",4,"",11],["ac80","",6,"",12,"",4,""],["ad40","",10,"",7,"",15,"",12],["ad80","",9,"",8,"",6,""],["ae40","",6,"",7,"",4,""],["ae80","",7,"",6,"",4,""],["af40","",4,""],["af80",""],["b040","",6,"",5,"",4,"",6,"",7,""],["b080","",7,"",8,"",9,""],["b140","",4,"",7,"",10,""],["b180","",4,"",7,"",7,""],["b240","",11,"",5,"",11,"",4],\
["b280","",12,"",8,"",4,""],["b340","",5,""],["b380","",11,"",7,"",6,""],["b440","",7,"",9],["b480","",4,"",5,"",6,""],["b540","",5,"",9,"",4,"",14,"",4,"",8,""],["b580","",6,"",4,""],["b640","",6,"",11,"",10,"",4,"",5,""],["b680","",6,"",4,""],["b740","",14,"",5,"",9,"",4,"",16],["b780","",6,""],["b840","",4,"",10,"",10,"",9,"",5,""],["b880","",4,""],["b940","",5,"",10,"",6,""],["b980","",7,""],["ba40","",4,"",4,"",7,"",5,""],["ba80","",4,"",5,"",12,"",5,""],["bb40","",9,"",36,"",5,"",9],["bb80","",6,"",4,""],["bc40","",6,"",6,"",5,"",7,"",13,"",5],["bc80","",14,"",6,""],["bd40","",54,"",7],["bd80","",32,""],["be40","",12,"",6,"",42],["be80","",32,""],["bf40","",62],["bf80","",4,"",4,"",21,""],["c040","",35,"",23,""],["c080","",6,"",9,""],["c140","",4,"",7,"",4,"",4,"",6,""],["c180","",4,"",4,"",5,""],["c240","",6,"",5,""],["c280","",13,"",5,"",11,""],["c340","",5,"",4,"",6,""],["c380","",12,"",4,""],["c440","",5,"",4,"",4,"",5,"",4,""],["c480","",7,"",5,"",6,""],["c540","",14,"",4,"",5,"",4,"",5,""],["c580","",7,"",7,""],["c640",""],["c680","",4,"",9,""],\
["c740","",4,"",4,"",6,"",6,"",6,""],["c780",""],["c840","",4,"",5,"",5,"",7,"",5,"",7,""],["c880","",6,"",4,"",4,""],["c940","",4,"",7,"",12,""],["c980","",4,"",4,"",10,""],["ca40","",8,"",8,"",9,"",4,"",10],["ca80","",4,"",8,""],["cb40","",6,"",10,"",6,"",5,"",6,"",6,"",4,""],["cb80","",5,"",6,"",14,""],["cc40","",4,"",10,"",15,"",13,""],["cc80","",11,"",4,"",7,""],["cd40","",6,"",6,"",4,"",5,"",4,"",4,""],["cd80",""],["ce40","",6,"",5,"",7,""],["ce80","",4,"",6,"",4,""],["cf40","",4,"",4,"",6,"",9],["cf80","",5,"",7,"",4,""],["d040","",13,"",5,"",5,"",5,"",6,""],["d080","",4,"",4,"",5,""],["d140","",4,"",4,"",6,"",5],["d180","",4,"",4,"",4,""],["d240","",8,"",24,"",5,"",19,""],["d280","",26,""],["d340","",30,"",6],["d380","",4,"",5,"",21,""],["d440","",31,"",8,"",21],["d480","",25,"",6,""],["d540","",7,"",7,"",46],["d580","",32,""],["d640","",34,"",27],["d680","",30,""],["d740","",31,"",4,"",25],["d780","",24,""],["d840","",8,"",7,"",5,"",6,"",6,"",6,""],["d880","",6,"",20,""],["d940","",62],["d980","",32,""],["da40","",14,"",8,"",4,"",9,""],["da80","",12,""],["db40","",6,"",7,"",4,""],["db80","",4,"",5,"",11,""],["dc40","",4,"",6,"",6,"",11,"",6,"",7],\
["dc80","",10,"",21,""],["dd40","",62],["dd80","",32,""],["de40","",32,""],["de80","",4,""],["df40","",5,"",4,"",4,"",5,"",4,"",6,""],["df80","",4,""],["e040","",19,""],["e080","",10,"",6,"",8,""],["e140","",4,"",6,"",5,"",5,""],["e180","",10,"",9,"",8,""],["e240","",62],["e280","",32,"",5,""],["e340","",45,"",16],["e380","",7,"",24,""],["e440","",5,"",24,"",31],["e480","",32,""],["e540","",51,"",10],["e580","",31,""],["e640","",34,"",27],["e680","",29,""],["e740","",7,"",54],["e780","",32,"",6,"",4,""],["e840","",14,"",43,""],["e880","",20,""],["e940","",7,"",42],["e980","",32,""],["ea40","",27,"",6,""],["ea80","",4,"",12,""],["eb40","",9,"",7,"",9,"",6,""],["eb80","",4,""],["ec40","",8,"",4,"",18,"",7],["ec80","",4,"",7,"",4,"",4,""],["ed40","",6,"",46],["ed80","",4,"",23,""],["ee40","",62],["ee80","",32,"",4,"",6,""],["ef40","",5,"",37,"",4],["ef80","",30,"",4,"",8,""],["f040","",4,"",28,"",26],["f080","",9,"",12,"",4,"",6,""],["f140","",10,"",47],["f180","",32,""],["f240","",62],["f280","",32,""],["f340","",17,"",6,"",4,""],["f380","",8,"",6,""],["f440","",5,"",10,"",10,"",7,"",5],\
["f480","",32,""],["f540","",62],["f580","",32,""],["f640","",62],["f680","",32,"",5,"",5,"",4,"",7,""],["f740","",62],["f780","",4,"",4,""],["f840","",62],["f880","",32],["f940","",62],["f980","",32],["fa40","",62],["fa80","",32],["fb40","",27,"",9,""],["fb80","",5,"",8,"",5,""],["fc40","",8,"",4,"",8,"",6],["fc80","",4,"",5,"",8,""],["fd40","",4,"",4,"",10,"",38],["fd80","",5,"",11,"",4,""],["fe40",""]]'
);
//
},
'iconv-lite/encodings/tables/gbk-added.json':
function(module) {
//
module.exports = JSON.parse(
  '[["a140","",62],["a180","",32],["a240","",62],["a280","",32],["a2ab","",5],["a2e3",""],["a2ef",""],["a2fd",""],["a340","",62],["a380","",31,""],["a440","",62],["a480","",32],["a4f4","",10],["a540","",62],["a580","",32],["a5f7","",7],["a640","",62],["a680","",32],["a6b9","",7],["a6d9","",6],["a6ec",""],["a6f3",""],["a6f6","",8],["a740","",62],["a780","",32],["a7c2","",14],["a7f2","",12],["a896","",10],["a8bc",""],["a8bf",""],["a8c1",""],["a8ea","",20],["a958",""],["a95b",""],["a95d",""],["a989","",11],["a997","",12],["a9f0","",14],["aaa1","",93],["aba1","",93],["aca1","",93],["ada1","",93],["aea1","",93],["afa1","",93],["d7fa","",4],["f8a1","",93],["f9a1","",93],["faa1","",93],["fba1","",93],["fca1","",93],["fda1","",93],["fe50",""],["fe80","",6,"",93]]'
);
//
},
'iconv-lite/encodings/tables/gb18030-ranges.json':
function(module) {
//
module.exports = JSON.parse(
  '{"uChars":[128,165,169,178,184,216,226,235,238,244,248,251,253,258,276,284,300,325,329,334,364,463,465,467,469,471,473,475,477,506,594,610,712,716,730,930,938,962,970,1026,1104,1106,8209,8215,8218,8222,8231,8241,8244,8246,8252,8365,8452,8454,8458,8471,8482,8556,8570,8596,8602,8713,8720,8722,8726,8731,8737,8740,8742,8748,8751,8760,8766,8777,8781,8787,8802,8808,8816,8854,8858,8870,8896,8979,9322,9372,9548,9588,9616,9622,9634,9652,9662,9672,9676,9680,9702,9735,9738,9793,9795,11906,11909,11913,11917,11928,11944,11947,11951,11956,11960,11964,11979,12284,12292,12312,12319,12330,12351,12436,12447,12535,12543,12586,12842,12850,12964,13200,13215,13218,13253,13263,13267,13270,13384,13428,13727,13839,13851,14617,14703,14801,14816,14964,15183,15471,15585,16471,16736,17208,17325,17330,17374,17623,17997,18018,18212,18218,18301,18318,18760,18811,18814,18820,18823,18844,18848,18872,19576,19620,19738,19887,40870,59244,59336,59367,59413,59417,59423,59431,59437,59443,59452,59460,59478,59493,63789,63866,63894,63976,63986,64016,64018,64021,64025,64034,64037,64042,65074,65093,65107,65112,65127,65132,65375,65510,65536],"gbChars":[0,36,38,45,50,81,89,95,96,100,103,104,105,109,126,133,148,172,175,179,208,306,307,308,309,310,311,312,313,341,428,443,544,545,558,741,742,749,750,805,819,820,7922,7924,7925,7927,7934,7943,7944,7945,7950,8062,8148,8149,8152,8164,8174,8236,8240,8262,8264,8374,8380,8381,8384,8388,8390,8392,8393,8394,8396,8401,8406,8416,8419,8424,8437,8439,8445,8482,8485,8496,8521,8603,8936,8946,9046,9050,9063,9066,9076,9092,9100,9108,9111,9113,9131,9162,9164,9218,9219,11329,11331,11334,11336,11346,11361,11363,11366,11370,11372,11375,11389,11682,11686,11687,11692,11694,11714,11716,11723,11725,11730,11736,11982,11989,12102,12336,12348,12350,12384,12393,12395,12397,12510,12553,12851,12962,12973,13738,13823,13919,13933,14080,14298,14585,14698,15583,15847,16318,16434,16438,16481,16729,17102,17122,17315,17320,17402,17418,17859,17909,17911,17915,17916,17936,17939,17961,18664,18703,18814,18962,19043,33469,33470,33471,33484,33485,33490,33497,33501,33505,33513,33520,33536,33550,37845,37921,37948,38029,38038,38064,38065,38066,38069,38075,38076,38078,39108,39109,39113,39114,39115,39116,39265,39394,189000]}'
);
//
},
'iconv-lite/encodings/tables/cp949.json':
function(module) {
//
module.exports = JSON.parse(
  '[["0","\\u0000",127],["8141","",4,"",6,""],["8161","",9,"",5,""],["8181","",18,"",4,"",6,"",5,"",6,"",7,"",7,"",4,"",4,""],["8241","",7,"",5],["8261","",6,"",5,""],["8281","",7,"",7,"",4,"",10,"",5,"",17,"",7,"",6,"",7,"",18],["8341","",5,"",5,"",7],["8361","",18,""],["8381","",4,"",6,"",5,"",5,"",46,"",6,"",5,"",8],["8441","",5,"",8],["8461","",18],["8481","",7,"",6,"",5,"",10,"",5,"",18,"",5,"",6,"",5,"",26,""],["8541","",5,"",4,"",6,"",4],["8561","",5,"",5,"",6,""],["8581","",6,"",6,"",9,"",26,"",29,"",6,"",5,""],["8641","",6,"",5,""],["8661","",6,"",10],["8681","",22,"",4,"",6,"",5,"",6,"",22,"",4,""],["8741","",9,"",15],["8761","",18,""],["8781","",5,"",7,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",4],["8841","",4,"",5,"",6,"",4],["8861","",4,""],["8881","",15,"",4,"",6,"",5,"",54,""],["8941","",6,"",5,""],["8961","",10,"",5,""],["8981","",21,"",18,"",18,"",6,"",6,"",7,"",15],["8a41","",10,"",6,""],["8a61","",4,"",18,""],["8a81","",4,"",19,"",5,"",7,"",5,"",6,"",5,"",4,"",5,"",26,""],["8b41","",5,"",4,"",6,""],["8b61","",6,"",8],["8b81","",52,"",4,"",6,"",5,"",18,"",18],["8c41","",15,"",4],["8c61","",6,"",5,"",6,"",5],["8c81","",12,"",26,"",50,"",5,"",16],["8d41","",16,"",8],["8d61","",17,""],["8d81","",4,"",33,"",6,"",7,"",6,"",9,"",6,"",5,"",6,""],["8e41","",6,"",5,"",8],["8e61","",4,"",19],["8e81","",13,"",6,"",4,"",6,"",5,"",6,"",5,"",11,"",7,"",6,"",5,"",7],["8f41","",7,"",17],["8f61","",7,"",6,"",4],["8f81","",5,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",5],["9041","",6,"",5,""],["9061","",5,"",15],["9081","",12,"",6,"",5,"",4,"",6,"",4,"",5,"",11,"",33,""],["9141","",6,"",5],["9161","",9,"",5],["9181","",20,"",4,"",5,"",14,"",33,"",7,"",5,"",6],["9241","",7,"",4,""],["9261","",7,"",7,"",4],["9281","",21,"",18,"",6,"",7,"",6,"",35,""],["9341","",4,""],["9361","",6,"",8],["9381","",37,"",4,"",4,"",6,"",5,"",7,"",22,""],["9441","",5,"",5,"",8],["9461","",5,"",6,"",12],["9481","",5,"",6,"",6,"",9,"",22,"",4,"",6,"",10,"",6,"",24],["9541","",11,"",5,""],["9561","",6,"",5,""],["9581","",6,"",35,"",4,"",4,"",4,"",6,"",5,"",13,"",14],["9641","",23,""],["9661","",6,"",5,"",8],["9681","",10,"",5,"",13,"",33,"",6,"",44],["9741","",16,"",8],["9761","",17,"",7],["9781","",11,"",5,"",6,"",89,""],["9841","",16,"",5,""],["9861","",6,"",15],["9881","",21,"",6,"",5,"",4,"",6,"",5,"",6,"",5,"",6,"",5,""],["9941","",6,"",5,""],["9961","",6,"",5,""],["9981","",8,"",5,"",4,"",11,"",5,"",6,"",6,"",6,"",7,"",6,"",5,""],["9a41","",16],["9a61","",6,"",6,""],\
["9a81","",4,"",6,"",5,"",5,"",6,"",5,"",5,"",33,"",5,"",6,""],["9b41","",6,"",8],["9b61","",17,"",7],["9b81","",25,"",4,"",5,"",50,"",22,""],["9c41","",4,"",5,"",5],["9c61","",8,"",6,"",9],["9c81","",8,"",6,"",6,"",9,"",26,"",6,"",5,"",18,"",6,"",12],["9d41","",13,"",8],["9d61","",25],["9d81","",8,"",5,"",9,"",6,"",10,"",6,"",5,"",6,"",5,""],["9e41","",7,"",9,""],["9e61","",4,"",6,""],["9e81","",6,"",6,"",6,"",5,"",10,"",5,"",6,"",5,"",6,""],["9f41","",5,"",4,"",5,""],["9f61","",6,"",5,""],["9f81","",4,"",5,"",6,"",5,"",6,"",4,"",6,"",7,"",4,"",4,""],["a041","",5,"",6,""],["a061","",5,"",13],["a081","",4,"",4,"",4,"",6,"",5,"",6,"",5,"",26,"",4,"",5,"",7,""],["a141","",18,""],["a161","",6,"",5,""],["a181","",14,"",5,"",4,"",9,""],["a241","",5,"",18],["a261","",6,"",18],["a281","",7,"",6,"",7,""],["a341","",6,"",10,""],["a361","",6,"",16],["a381","",16,"",4,"",58,"",32,""],["a441","",5,""],["a461","",5,"",12],["a481","",28,"",93],["a541","",4,"",6,"",5,""],["a561","",17,"",5,""],["a581","",16,"",14,"",9],["a5b0","",9],["a5c1","",16,"",6],["a5e1","",16,"",6],["a641","",19,""],["a661","",5,"",5,"",6],["a681","",6,"",18,"",7],["a741","",4,"",6,"",7],["a761","",22,""],["a781","",6,"",5,"",7,"",9,"",9,"",4,"",5,"",4,""],["a841","",10,"",14],["a861","",18,"",6],["a881","",19,"",11,""],["a8a6",""],["a8a8",""],["a8b1","",27,"",25,"",14,""],["a941","",14,"",10],["a961","",18],["a981","",14,"",6,"",27,"",25,"",14,""],["aa41","",6,"",4,""],["aa61","",4,"",5,"",6,""],["aa81","",29,"",82],["ab41","",6,"",5,""],["ab61","",6,"",5,"",5],["ab81","",8,"",6,"",12,"",85],["ac41","",5,"",6,""],["ac61","",11,"",4],["ac81","",28,"",5,"",25],["acd1","",5,"",25],["ad41","",6,"",5,"",7],["ad61","",6,"",10,""],["ad81","",5,"",18,""],["ae41","",5,"",16],["ae61","",5,"",6,"",4],["ae81","",6,"",5,""],["af41","",19],["af61","",13,"",5,""],["af81","",5,"",6,"",5,""],["b041","",5,"",5,"",12],["b061","",5,"",19],["b081","",13,"",6,"",5,"",7,"",4,""],["b141","",6,"",5,""],["b161","",6,"",5,"",11],["b181","",14,"",6,""],["b241","",6,"",5,""],["b261","",18,"",5,""],["b281","",5,"",18,"",6,""],["b341","",19,""],["b361","",5,"",5,"",5],["b381","",5,"",5,"",19,"",4,""],["b441","",5,"",6,"",5],["b461","",6,"",10,""],\
["b481","",6,"",18,"",4,"",4,""],["b541","",14,"",5],["b561","",5,"",5,"",4],["b581","",6,"",5,"",11,""],["b641","",7,"",17],["b661","",15,""],["b681","",5,"",6,"",5,""],["b741","",13,"",6,""],["b761","",20,""],["b781","",6,"",14,""],["b841","",7,"",17],["b861","",8,"",13],["b881","",5,"",24,"",4,""],["b941","",6,"",5,""],["b961","",14,"",6,""],["b981","",22,"",4,"",4,""],["ba41","",5,"",6,""],["ba61","",5,"",4,"",5],["ba81","",6,"",9,""],["bb41","",4,"",5,"",4,""],["bb61","",6,"",5,""],["bb81","",31,""],["bc41","",17,""],["bc61","",5,"",6,""],["bc81","",4,"",6,"",5,"",5,"",4,""],["bd41","",7,"",7,""],["bd61","",5,"",13],["bd81","",5,"",25,""],["be41","",7,"",14],["be61","",7,"",7,""],["be81","",4,"",4,"",5,"",8,"",6,""],["bf41","",10,"",14],["bf61","",18,""],["bf81","",5,"",7,"",6,"",5,""],["c041","",5,"",6,"",5],["c061","",25],["c081","",6,"",5,"",7,""],["c141","",5,"",6,""],["c161","",19,""],["c181","",31,""],["c241","",4,"",5,""],["c261","",4,"",5,"",6,""],["c281","",5,"",7,"",9,""],["c341","",4],["c361","",4,"",5,"",11],["c381","",5,"",7,"",5,""],["c441","",7,"",7,""],["c461","",5,"",4],["c481","",5,"",11,""],["c541","",6,"",5,""],["c561","",6,"",5,"",4],["c581","",6,"",5,""],["c641","",6,"",5],["c6a1",""],["c7a1",""],["c8a1",""],["caa1",""],["cba1",""],\
["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1","",5,"",4,""],["d2a1","",4,"",5,"",10,"",7,"",5,""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],\
["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f5a1",""],["f6a1",""],["f7a1",""],["f8a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fda1",""]]'
);
//
},
'iconv-lite/encodings/tables/cp950.json':
function(module) {
//
module.exports = JSON.parse(
  '[["0","\\u0000",127],["a140",""],["a1a1","",4,""],["a240","",7,""],["a2a1","",9,"",9,"",8,"",25,"",21],["a340","",16,"",6,"",16,"",6,"",10],["a3a1","",25,""],["a3e1",""],["a440",""],["a4a1",""],["a540",""],["a5a1",""],["a640",""],["a6a1",""],["a740",""],["a7a1",""],["a840",""],["a8a1",""],["a940",""],["a9a1",""],["aa40",""],["aaa1",""],["ab40",""],["aba1",""],["ac40",""],["aca1",""],["ad40",""],["ada1",""],["ae40",""],["aea1",""],["af40",""],["afa1",""],["b040",""],["b0a1",""],["b140",""],["b1a1",""],["b240",""],["b2a1",""],["b340",""],["b3a1",""],["b440",""],["b4a1",""],["b540",""],["b5a1",""],["b640",""],["b6a1",""],["b740",""],\
["b7a1",""],["b840",""],["b8a1",""],["b940",""],["b9a1",""],["ba40",""],["baa1",""],["bb40",""],["bba1",""],["bc40",""],["bca1",""],["bd40",""],["bda1",""],["be40",""],["bea1",""],["bf40",""],["bfa1",""],["c040",""],["c0a1",""],["c140",""],["c1a1",""],["c240",""],["c2a1",""],["c340",""],["c3a1",""],["c440",""],["c4a1",""],["c540",""],["c5a1",""],["c640",""],["c940",""],["c9a1",""],["ca40",""],["caa1",""],["cb40",""],["cba1",""],["cc40",""],["cca1",""],["cd40",""],["cda1",""],["ce40",""],["cea1",""],["cf40",""],["cfa1",""],\
["d040",""],["d0a1",""],["d140",""],["d1a1",""],["d240",""],["d2a1",""],["d340",""],["d3a1",""],["d440",""],["d4a1",""],["d540",""],["d5a1",""],["d640",""],["d6a1",""],["d740",""],["d7a1",""],["d840",""],["d8a1",""],["d940",""],["d9a1",""],["da40",""],["daa1",""],["db40",""],["dba1",""],["dc40",""],["dca1",""],["dd40",""],["dda1",""],["de40",""],["dea1",""],["df40",""],["dfa1",""],["e040",""],["e0a1",""],["e140",""],["e1a1",""],["e240",""],["e2a1",""],["e340",""],["e3a1",""],["e440",""],["e4a1",""],["e540",""],["e5a1",""],\
["e640",""],["e6a1",""],["e740",""],["e7a1",""],["e840",""],["e8a1",""],["e940",""],["e9a1",""],["ea40",""],["eaa1",""],["eb40",""],["eba1",""],["ec40",""],["eca1",""],["ed40",""],["eda1",""],["ee40",""],["eea1",""],["ef40",""],["efa1",""],["f040",""],["f0a1",""],["f140",""],["f1a1",""],["f240",""],["f2a1",""],["f340",""],["f3a1",""],["f440",""],["f4a1",""],["f540",""],["f5a1",""],["f640",""],["f6a1",""],["f740",""],["f7a1",""],["f840",""],["f8a1",""],["f940",""],["f9a1",""]]'
);
//
},
'iconv-lite/encodings/tables/big5-added.json':
function(module) {
//
module.exports = JSON.parse(
  '[["8740",""],["8767",""],["87a1",""],["8840","",4,""],["88a1",""],["8940",""],["8943",""],["8946",""],["894c",""],["89a1",""],["89ab",""],["89b0",""],["89b5",""],["89c1",""],["89c5",""],["8a40",""],["8a43",""],["8a64",""],["8a76",""],["8aa1",""],["8aac",""],["8ab2",""],["8abb",""],["8ac9",""],["8ace",""],["8adf",""],["8af6",""],["8b40",""],["8b55",""],["8ba1",""],["8bde",""],["8c40",""],["8ca1",""],["8ca7",""],["8cc9",""],["8cce",""],["8ce6",""],["8d40",""],["8d42",""],["8da1",""],["8e40",""],["8ea1",""],["8f40",""],["8fa1",""],["9040",""],["90a1",""],["9140",""],["91a1",""],["9240",""],["92a1",""],["9340",""],["93a1",""],["9440",""],["94a1",""],["9540",""],["95a1",""],["9640",""],["96a1",""],\
["9740",""],["97a1",""],["9840",""],["98a1",""],["9940",""],["99a1",""],["9a40",""],["9aa1",""],["9b40",""],["9b62",""],["9ba1",""],["9c40",""],["9ca1",""],["9d40",""],["9da1",""],["9e40",""],["9ea1",""],["9ead",""],["9ec5",""],["9ef5",""],["9f40",""],["9f4f",""],["9fa1",""],["9fae",""],["9fb2",""],["9fc1",""],["9fc9",""],["9fdb",""],["9fe7",""],["9feb",""],["9ff0",""],["a040",""],["a055",""],["a058",""],["a05b",""],["a063",""],["a073",""],["a0a1",""],["a0a6",""],["a0ae",""],["a0b0",""],["a0d4",""],["a0e2",""],["a3c0","",31,""],["c6a1","",9,"",9,"",9,"",23],["c740","",58,""],["c7a1","",81,"",5,"",4],["c840","",26,"",25,""],["c8a1",""],["c8cd",""],["c8f5",""],["f9fe",""],["fa40",""],["faa1",""],["fb40",""],["fba1",""],["fc40",""],["fca1",""],["fd40",""],["fda1",""],["fe40",""],\
["fea1",""]]'
);
//
},
'iconv-lite/lib/streams':
function(module, exports, __wpreq__) {
//
var Buffer = __wpreq__('buffer').Buffer,
  Transform = __wpreq__('stream').Transform;

module.exports = function(iconv) {
  iconv.encodeStream = function(encoding, options) {
    return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
  }

  iconv.decodeStream = function(encoding, options) {
    return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
  }

  iconv.supportsStreams = true;

  iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
  iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
  iconv._collect = IconvLiteDecoderStream.prototype.collect;
};

function IconvLiteEncoderStream(conv, options) {
  this.conv = conv;
  (options = options || {}).decodeStrings = false;
  Transform.call(this, options);
}

IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
  constructor: {value: IconvLiteEncoderStream}
});

IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
  if (typeof chunk != 'string') return done(new Error("Iconv encoding stream needs strings as its input."));
  try {
    var res = this.conv.write(chunk);
    res && res.length && this.push(res);
    done();
  } catch (e) {
    done(e);
  }
}

IconvLiteEncoderStream.prototype._flush = function(done) {
  try {
    var res = this.conv.end();
    res && res.length && this.push(res);
    done();
  } catch (e) {
    done(e);
  }
}

IconvLiteEncoderStream.prototype.collect = function(cb) {
  var chunks = [];
  this.on('error', cb);
  this.on('data', function(chunk) { chunks.push(chunk); });
  this.on('end', function() {
    cb(null, Buffer.concat(chunks));
  });
  return this;
}

function IconvLiteDecoderStream(conv, options) {
  this.conv = conv;
  (options = options || {}).encoding = this.encoding = 'utf8';
  Transform.call(this, options);
}

IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
  constructor: {value: IconvLiteDecoderStream}
});

IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
  if (!Buffer.isBuffer(chunk)) return done(new Error("Iconv decoding stream needs buffers as its input."));
  try {
    var res = this.conv.write(chunk);
    res && res.length && this.push(res, this.encoding);
    done();
  } catch (e) {
    done(e);
  }
}

IconvLiteDecoderStream.prototype._flush = function(done) {
  try {
    var res = this.conv.end();
    res && res.length && this.push(res, this.encoding);
    done();
  } catch (e) {
    done(e);
  }
}

IconvLiteDecoderStream.prototype.collect = function(cb) {
  var res = '';
  this.on('error', cb);
  this.on('data', function(chunk) { res += chunk; });
  this.on('end', function() {
    cb(null, res);
  });
  return this;
}
//
},
'iconv-lite/lib/extend-node':
function(module, exports, __wpreq__) {
//
var Buffer = __wpreq__('buffer').Buffer;

module.exports = function(iconv) {
  var original = void 0;

  iconv.supportsNodeEncodingsExtension = !(Buffer.from || new Buffer(0) instanceof Uint8Array);

  iconv.extendNodeEncodings = function() {
    if (original) return;
    original = {};

    if (!iconv.supportsNodeEncodingsExtension) {
      console.error(
        "ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node"
      );
      console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
      return;
    }

    var nodeNativeEncodings = {
      hex: true, utf8: true, 'utf-8': true, ascii: true, binary: true,
      base64: true, ucs2: true, 'ucs-2': true, utf16le: true, 'utf-16le': true
    };

    Buffer.isNativeEncoding = function(enc) {
      return enc && nodeNativeEncodings[enc.toLowerCase()];
    }

    var SlowBuffer = __wpreq__('buffer').SlowBuffer;

    original.SlowBufferToString = SlowBuffer.prototype.toString;
    SlowBuffer.prototype.toString = function(encoding, start, end) {
      encoding = String(encoding || 'utf8').toLowerCase();

      if (Buffer.isNativeEncoding(encoding)) return original.SlowBufferToString.call(this, encoding, start, end);

      if (start === void 0) start = 0;
      if (end === void 0) end = this.length;
      return iconv.decode(this.slice(start, end), encoding);
    }

    original.SlowBufferWrite = SlowBuffer.prototype.write;
    SlowBuffer.prototype.write = function(string, offset, length, encoding) {
      if (isFinite(offset)) {
        if (!isFinite(length)) {
          encoding = length;
          length = void 0;
        }
      } else {
        var swap = encoding;
        encoding = offset;
        offset = length;
        length = swap;
      }

      offset = +offset || 0;
      var remaining = this.length - offset;
      if (!length) length = remaining;
      else if ((length = +length) > remaining) length = remaining;

      encoding = String(encoding || 'utf8').toLowerCase();

      if (Buffer.isNativeEncoding(encoding))
        return original.SlowBufferWrite.call(this, string, offset, length, encoding);

      if (string.length > 0 && (length < 0 || offset < 0))
        throw new RangeError('attempt to write beyond buffer bounds');

      var buf = iconv.encode(string, encoding);
      if (buf.length < length) length = buf.length;
      buf.copy(this, offset, 0, length);
      return length;
    }

    original.BufferIsEncoding = Buffer.isEncoding;
    Buffer.isEncoding = function(encoding) {
      return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
    }

    original.BufferByteLength = Buffer.byteLength;
    Buffer.byteLength = SlowBuffer.byteLength = function(str, encoding) {
      encoding = String(encoding || 'utf8').toLowerCase();

      return Buffer.isNativeEncoding(encoding)
        ? original.BufferByteLength.call(this, str, encoding)
        : iconv.encode(str, encoding).length;
    }

    original.BufferToString = Buffer.prototype.toString;
    Buffer.prototype.toString = function(encoding, start, end) {
      encoding = String(encoding || 'utf8').toLowerCase();

      if (Buffer.isNativeEncoding(encoding)) return original.BufferToString.call(this, encoding, start, end);

      if (start === void 0) start = 0;
      if (end === void 0) end = this.length;
      return iconv.decode(this.slice(start, end), encoding);
    }

    original.BufferWrite = Buffer.prototype.write;
    Buffer.prototype.write = function(string, offset, length, encoding) {
      var _offset = offset, _length = length, _encoding = encoding;
      if (isFinite(offset)) {
        if (!isFinite(length)) {
          encoding = length;
          length = void 0;
        }
      } else {
        var swap = encoding;
        encoding = offset;
        offset = length;
        length = swap;
      }

      encoding = String(encoding || 'utf8').toLowerCase();

      if (Buffer.isNativeEncoding(encoding))
        return original.BufferWrite.call(this, string, _offset, _length, _encoding);

      offset = +offset || 0;
      var remaining = this.length - offset;
      if (!length) length = remaining;
      else if ((length = +length) > remaining) length = remaining;

      if (string.length > 0 && (length < 0 || offset < 0))
        throw new RangeError('attempt to write beyond buffer bounds');

      var buf = iconv.encode(string, encoding);
      if (buf.length < length) length = buf.length;
      buf.copy(this, offset, 0, length);
      return length;
    }

    if (iconv.supportsStreams) {
      var Readable = __wpreq__('stream').Readable;

      original.ReadableSetEncoding = Readable.prototype.setEncoding;
      Readable.prototype.setEncoding = function(enc, options) {
        this._readableState.decoder = iconv.getDecoder(enc, options);
        this._readableState.encoding = enc;
      }

      Readable.prototype.collect = iconv._collect;
    }
  }

  iconv.undoExtendNodeEncodings = function() {
    if (!iconv.supportsNodeEncodingsExtension) return;
    if (!original)
      throw new Error(
        "require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called."
      )

    delete Buffer.isNativeEncoding;

    var SlowBuffer = __wpreq__('buffer').SlowBuffer;

    SlowBuffer.prototype.toString = original.SlowBufferToString;
    SlowBuffer.prototype.write = original.SlowBufferWrite;

    Buffer.isEncoding = original.BufferIsEncoding;
    Buffer.byteLength = original.BufferByteLength;
    Buffer.prototype.toString = original.BufferToString;
    Buffer.prototype.write = original.BufferWrite;

    if (iconv.supportsStreams) {
      var Readable = __wpreq__('stream').Readable;

      Readable.prototype.setEncoding = original.ReadableSetEncoding;
      delete Readable.prototype.collect;
    }

    original = void 0;
  }
}
//
},
tmp:
function(module, exports, __wpreq__) {
// noinspection JSMismatchedCollectionQueryUpdate
const fs = __wpreq__('fs'),
  path = __wpreq__('path'),
  crypto = __wpreq__('crypto'),
  osTmpDir = __wpreq__('os-tmpdir'),
  _c = process.binding('constants'),

  tmpDir = osTmpDir(),

  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
  TEMPLATE_PATTERN = /XXXXXX/,
  DEFAULT_TRIES = 3,

  _removeObjects = [];

var _gracefulCleanup = false,
  _uncaughtException = false;

function _randomChars(howMany) {
  var value = [],
    rnd = null;

  try {
    rnd = crypto.randomBytes(howMany);
  } catch (_e) {
    rnd = crypto.pseudoRandomBytes(howMany);
  }

  for (var i = 0; i < howMany; i++) value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);

  return value.join('');
}

function _isUndefined(obj) {
  return obj === void 0;
}

function _parseArguments(options, callback) {
  return typeof options == 'function'
    ? [callback || {}, options]
    : _isUndefined(options)
    ? [{}, callback]
    : [options, callback];
}

function _generateTmpName(opts) {
  if (opts.name) return path.join(opts.dir || tmpDir, opts.name);

  if (opts.template) return opts.template.replace(TEMPLATE_PATTERN, _randomChars(6));

  const name = [opts.prefix || 'tmp-', process.pid, _randomChars(12), opts.postfix || ''].join('');

  return path.join(opts.dir || tmpDir, name);
}

function tmpName(options, callback) {
  var args = _parseArguments(options, callback),
    opts = args[0],
    cb = args[1],
    tries = opts.name ? 1 : opts.tries || DEFAULT_TRIES;

  if (isNaN(tries) || tries < 0) return cb(new Error('Invalid tries'));

  if (opts.template && !opts.template.match(TEMPLATE_PATTERN)) return cb(new Error('Invalid template provided'));

  !(function _getUniqueName() {
    const name = _generateTmpName(opts);

    fs.stat(name, function(err) {
      if (!err)
        return tries-- > 0
          ? _getUniqueName()
          : cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));

      cb(null, name);
    });
  })();
}

function tmpNameSync(options) {
  var opts = _parseArguments(options)[0],
    tries = opts.name ? 1 : opts.tries || DEFAULT_TRIES;

  if (isNaN(tries) || tries < 0) throw new Error('Invalid tries');

  if (opts.template && !opts.template.match(TEMPLATE_PATTERN)) throw new Error('Invalid template provided');

  do {
    const name = _generateTmpName(opts);
    try {
      fs.statSync(name);
    } catch (_e) {
      return name;
    }
  } while (tries-- > 0);

  throw new Error('Could not get a unique tmp filename, max tries reached');
}

function _garbageCollector() {
  if (_uncaughtException && !_gracefulCleanup) return;

  while (_removeObjects.length)
    try {
      _removeObjects[0].call(null);
    } catch (_) {}
}

function setGracefulCleanup() {
  _gracefulCleanup = true;
}

const version = process.versions.node.split('.').map(function(value) {
  return parseInt(value, 10);
});

version[0] === 0 && (version[1] < 9 || (version[1] === 9 && version[2] < 5)) &&
  process.addListener('uncaughtException', function(err) {
    _uncaughtException = true;
    _garbageCollector();

    throw err;
  });

process.addListener('exit', function(code) {
  if (code) _uncaughtException = true;
  _garbageCollector();
});

module.exports.tmpdir = tmpDir;

module.exports.tmpName = tmpName;
module.exports.tmpNameSync = tmpNameSync;

module.exports.setGracefulCleanup = setGracefulCleanup;
//
},
crypto:
function(module) {
//
module.exports = require('crypto');
//
},
'os-tmpdir':
function(module) {
//
module.exports = require('os').tmpdir;
//
},
'cli-table3':
function(module, exports, __wpreq__) {
//
const utils = __wpreq__('cli-table3/src/utils'),
  tableLayout = __wpreq__('cli-table3/src/layout-manager');

class Table extends Array {
  constructor(options) {
    super();

    this.options = utils.mergeOptions(options);
  }

  toString() {
    let array = this,
      headersPresent = this.options.head && this.options.head.length;
    if (headersPresent) {
      array = [this.options.head];
      this.length && array.push.apply(array, this);
    } else this.options.style.head = [];

    let cells = tableLayout.makeTableLayout(array);

    cells.forEach(function(row) {
      row.forEach(function(cell) {
        cell.mergeTableOptions(this.options, cells);
      }, this);
    }, this);

    tableLayout.computeWidths(this.options.colWidths, cells);
    tableLayout.computeHeights(this.options.rowHeights, cells);

    cells.forEach(function(row) {
      row.forEach(function(cell) {
        cell.init(this.options);
      }, this);
    }, this);

    let result = [];

    for (let rowIndex = 0; rowIndex < cells.length; rowIndex++) {
      let row = cells[rowIndex],
        heightOfRow = this.options.rowHeights[rowIndex];

      if (rowIndex === 0 || !this.options.style.compact || (rowIndex == 1 && headersPresent))
        doDraw(row, 'top', result);

      for (let lineNum = 0; lineNum < heightOfRow; lineNum++) doDraw(row, lineNum, result);

      rowIndex + 1 != cells.length || doDraw(row, 'bottom', result);
    }

    return result.join('\n');
  }

  get width() {
    return this.toString().split('\n')[0].length;
  }
}

function doDraw(row, lineNum, result) {
  let line = [];
  row.forEach(function(cell) {
    line.push(cell.draw(lineNum));
  });
  let str = line.join('');
  str.length && result.push(str);
}

module.exports = Table;
//
},
'cli-table3/src/utils':
function(module, exports, __wpreq__) {
//
const objectAssign = Object.assign,
  stringWidth = __wpreq__('string-width');

function codeRegex(capture) {
  return capture ? /\u001b\[((?:\d*;){0,5}\d*)m/g : /\u001b\[(?:\d*;){0,5}\d*m/g;
}

function strlen(str) {
  let code = codeRegex();
  return ('' + str).replace(code, '')
    .split('\n')
    .reduce(function(memo, s) {
      return Math.max(stringWidth(s), memo);
    }, 0);
}

function repeat(str, times) {
  return Array(times + 1).join(str);
}

function pad(str, len, pad, dir) {
  let length = strlen(str);
  if (len + 1 >= length) {
    let padlen = len - length;
    switch (dir) {
      case 'right':
        str = repeat(pad, padlen) + str;
        break;

      case 'center':
        let right = Math.ceil(padlen / 2);
        str = repeat(pad, padlen - right) + str + repeat(pad, right);
        break;

      default:
        str += repeat(pad, padlen);
        break;
    }
  }
  return str;
}

let codeCache = {};

function addToCodeCache(name, on, off) {
  on = '\x1b[' + on + 'm';
  off = '\x1b[' + off + 'm';
  codeCache[on] = {set: name, to: true};
  codeCache[off] = {set: name, to: false};
  codeCache[name] = {on: on, off: off};
}

addToCodeCache('bold', 1, 22);
addToCodeCache('italics', 3, 23);
addToCodeCache('underline', 4, 24);
addToCodeCache('inverse', 7, 27);
addToCodeCache('strikethrough', 9, 29);

function updateState(state, controlChars) {
  let controlCode = controlChars[1] ? parseInt(controlChars[1].split(';')[0]) : 0;
  if ((controlCode >= 30 && controlCode <= 39) || (controlCode >= 90 && controlCode <= 97)) {
    state.lastForegroundAdded = controlChars[0];
    return;
  }
  if ((controlCode >= 40 && controlCode <= 49) || (controlCode >= 100 && controlCode <= 107)) {
    state.lastBackgroundAdded = controlChars[0];
    return;
  }
  if (controlCode === 0) {
    for (let i in state) state.hasOwnProperty(i) && delete state[i];
    return;
  }
  let info = codeCache[controlChars[0]];
  if (info) state[info.set] = info.to;
}

function readState(line) {
  let state = {};
  for (let code = codeRegex(true), controlChars = code.exec(line); controlChars !== null; ) {
    updateState(state, controlChars);
    controlChars = code.exec(line);
  }
  return state;
}

function unwindState(state, ret) {
  let lastBackgroundAdded = state.lastBackgroundAdded,
    lastForegroundAdded = state.lastForegroundAdded;

  delete state.lastBackgroundAdded;
  delete state.lastForegroundAdded;

  Object.keys(state).forEach(function(key) {
    if (state[key]) ret += codeCache[key].off;
  });

  if (lastBackgroundAdded && lastBackgroundAdded != '\x1b[49m') ret += '\x1b[49m';
  if (lastForegroundAdded && lastForegroundAdded != '\x1b[39m') ret += '\x1b[39m';

  return ret;
}

function rewindState(state, ret) {
  let lastBackgroundAdded = state.lastBackgroundAdded,
    lastForegroundAdded = state.lastForegroundAdded;

  delete state.lastBackgroundAdded;
  delete state.lastForegroundAdded;

  Object.keys(state).forEach(function(key) {
    if (state[key]) ret = codeCache[key].on + ret;
  });

  if (lastBackgroundAdded && lastBackgroundAdded != '\x1b[49m') ret = lastBackgroundAdded + ret;
  if (lastForegroundAdded && lastForegroundAdded != '\x1b[39m') ret = lastForegroundAdded + ret;

  return ret;
}

function truncateWidth(str, desiredLength) {
  if (str.length === strlen(str)) return str.substr(0, desiredLength);

  while (strlen(str) > desiredLength) str = str.slice(0, -1);

  return str;
}

function truncateWidthWithAnsi(str, desiredLength) {
  let code = codeRegex(true),
    split = str.split(codeRegex()),
    splitIndex = 0,
    ret = '',
    state = {};

  for (let myArray, retLen = 0; retLen < desiredLength; ) {
    myArray = code.exec(str);
    let toAdd = split[splitIndex];
    splitIndex++;
    if (retLen + strlen(toAdd) > desiredLength) toAdd = truncateWidth(toAdd, desiredLength - retLen);

    ret += toAdd;
    retLen += strlen(toAdd);

    if (retLen < desiredLength) {
      if (!myArray) break;

      ret += myArray[0];
      updateState(state, myArray);
    }
  }

  return unwindState(state, ret);
}

function truncate(str, desiredLength, truncateChar) {
  truncateChar = truncateChar || '';

  return strlen(str) <= desiredLength
    ? str
    : truncateWidthWithAnsi(str, (desiredLength -= strlen(truncateChar))) + truncateChar;
}

function defaultOptions() {
  return {
    chars: {
      top: '',
      'top-mid': '',
      'top-left': '',
      'top-right': '',
      bottom: '',
      'bottom-mid': '',
      'bottom-left': '',
      'bottom-right': '',
      left: '',
      'left-mid': '',
      mid: '',
      'mid-mid': '',
      right: '',
      'right-mid': '',
      middle: ''
    },
    truncate: '',
    colWidths: [],
    rowHeights: [],
    colAligns: [],
    rowAligns: [],
    style: {
      'padding-left': 1,
      'padding-right': 1,
      head: ['red'],
      border: ['grey'],
      compact: false
    },
    head: []
  };
}

function mergeOptions(options, defaults) {
  options = options || {};
  defaults = defaults || defaultOptions();
  let ret = objectAssign({}, defaults, options);
  ret.chars = objectAssign({}, defaults.chars, options.chars);
  ret.style = objectAssign({}, defaults.style, options.style);
  return ret;
}

function wordWrap(maxLength, input) {
  let lines = [],
    split = input.split(/(\s+)/g),
    line = [],
    lineLength = 0;
  for (let whitespace, i = 0; i < split.length; i += 2) {
    let word = split[i],
      newLength = lineLength + strlen(word);
    if (lineLength > 0 && whitespace) newLength += whitespace.length;

    if (newLength > maxLength) {
      lineLength === 0 || lines.push(line.join(''));

      line = [word];
      lineLength = strlen(word);
    } else {
      line.push(whitespace || '', word);
      lineLength = newLength;
    }
    whitespace = split[i + 1];
  }
  lineLength && lines.push(line.join(''));

  return lines;
}

function multiLineWordWrap(maxLength, input) {
  let output = [];
  input = input.split('\n');
  for (let i = 0; i < input.length; i++) output.push.apply(output, wordWrap(maxLength, input[i]));

  return output;
}

function colorizeLines(input) {
  let output = [];
  for (let state = {}, i = 0; i < input.length; i++) {
    let line = rewindState(state, input[i]);
    state = readState(line);
    let temp = objectAssign({}, state);
    output.push(unwindState(temp, line));
  }
  return output;
}

module.exports = {
  strlen: strlen,
  repeat: repeat,
  pad: pad,
  truncate: truncate,
  mergeOptions: mergeOptions,
  wordWrap: multiLineWordWrap,
  colorizeLines: colorizeLines
};
//
},
'cli-table3/src/layout-manager':
function(module, exports, __wpreq__) {
//
const objectAssign = Object.assign,
  Cell = __wpreq__('cli-table3/src/cell'),
  ColSpanCell = Cell.ColSpanCell, RowSpanCell = Cell.RowSpanCell;

!(function() {
  function layoutTable(table) {
    table.forEach(function(row, rowIndex) {
      row.forEach(function(cell, columnIndex) {
        cell.y = rowIndex;
        cell.x = columnIndex;
        for (let y = rowIndex; y >= 0; y--)
          for (let row2 = table[y], xMax = y === rowIndex ? columnIndex : row2.length, x = 0; x < xMax; x++)
            for (let cell2 = row2[x]; cellsConflict(cell, cell2); ) cell.x++;
      });
    });
  }

  function maxWidth(table) {
    let mw = 0;
    table.forEach(function(row) {
      row.forEach(function(cell) {
        mw = Math.max(mw, cell.x + (cell.colSpan || 1));
      });
    });
    return mw;
  }

  function maxHeight(table) {
    return table.length;
  }

  function cellsConflict(cell1, cell2) {
    let yMin1 = cell1.y,
      yMax1 = cell1.y - 1 + (cell1.rowSpan || 1),
      yMin2 = cell2.y,
      yConflict = !(yMin1 > cell2.y - 1 + (cell2.rowSpan || 1) || yMin2 > yMax1),

      xMin1 = cell1.x,
      xMax1 = cell1.x - 1 + (cell1.colSpan || 1),
      xMin2 = cell2.x,
      xMax2 = cell2.x - 1 + (cell2.colSpan || 1);

    return yConflict && !(xMin1 > xMax2 || xMin2 > xMax1);
  }

  function conflictExists(rows, x, y) {
    for (let i_max = Math.min(rows.length - 1, y), cell = {x: x, y: y}, i = 0; i <= i_max; i++)
      for (let row = rows[i], j = 0; j < row.length; j++) if (cellsConflict(cell, row[j])) return true;

    return false;
  }

  function allBlank(rows, y, xMin, xMax) {
    for (let x = xMin; x < xMax; x++) if (conflictExists(rows, x, y)) return false;

    return true;
  }

  function addRowSpanCells(table) {
    table.forEach(function(row, rowIndex) {
      row.forEach(function(cell) {
        for (let i = 1; i < cell.rowSpan; i++) {
          let rowSpanCell = new RowSpanCell(cell);
          rowSpanCell.x = cell.x;
          rowSpanCell.y = cell.y + i;
          rowSpanCell.colSpan = cell.colSpan;
          insertCell(rowSpanCell, table[rowIndex + i]);
        }
      });
    });
  }

  function addColSpanCells(cellRows) {
    for (let rowIndex = cellRows.length - 1; rowIndex >= 0; rowIndex--)
      for (let cellColumns = cellRows[rowIndex], columnIndex = 0; columnIndex < cellColumns.length; columnIndex++)
        for (let cell = cellColumns[columnIndex], k = 1; k < cell.colSpan; k++) {
          let colSpanCell = new ColSpanCell();
          colSpanCell.x = cell.x + k;
          colSpanCell.y = cell.y;
          cellColumns.splice(columnIndex + 1, 0, colSpanCell);
        }
  }

  function insertCell(cell, row) {
    let x = 0;
    while (x < row.length && row[x].x < cell.x) x++;

    row.splice(x, 0, cell);
  }

  function fillInTable(table) {
    for (let h_max = maxHeight(table), w_max = maxWidth(table), y = 0; y < h_max; y++)
      for (let x = 0; x < w_max; x++) {
        if (conflictExists(table, x, y)) continue;

        let opts = {x: x, y: y, colSpan: 1, rowSpan: 1};
        x++;
        while (x < w_max && !conflictExists(table, x, y)) {
          opts.colSpan++;
          x++;
        }
        for (let y2 = y + 1; y2 < h_max && allBlank(table, y2, opts.x, opts.x + opts.colSpan); ) {
          opts.rowSpan++;
          y2++;
        }

        let cell = new Cell(opts);
        cell.x = opts.x;
        cell.y = opts.y;
        insertCell(cell, table[y]);
      }
  }

  function generateCells(rows) {
    return rows.map(function(row) {
      if (!Array.isArray(row)) {
        let key = Object.keys(row)[0];
        row = row[key];
        Array.isArray(row) ? (row = row.slice()).unshift(key) : (row = [key, row]);
      }
      return row.map(function(cell) {
        return new Cell(cell);
      });
    });
  }

  function makeTableLayout(rows) {
    let cellRows = generateCells(rows);
    layoutTable(cellRows);
    fillInTable(cellRows);
    addRowSpanCells(cellRows);
    addColSpanCells(cellRows);
    return cellRows;
  }

  module.exports = {
    makeTableLayout: makeTableLayout,
    layoutTable: layoutTable,
    addRowSpanCells: addRowSpanCells,
    maxWidth: maxWidth,
    fillInTable: fillInTable,
    computeWidths: makeComputeWidths('colSpan', 'desiredWidth', 'x', 1),
    computeHeights: makeComputeWidths('rowSpan', 'desiredHeight', 'y', 1)
  };
})();

function makeComputeWidths(colSpan, desiredWidth, x, forcedMin) {
  return function(vals, table) {
    let result = [],
      spanners = [];
    table.forEach(function(row) {
      row.forEach(function(cell) {
        (cell[colSpan] || 1) > 1
          ? spanners.push(cell)
          : (result[cell[x]] = Math.max(result[cell[x]] || 0, cell[desiredWidth] || 0, forcedMin));
      });
    });

    vals.forEach(function(val, index) {
      if (typeof val == 'number') result[index] = val;
    });

    for (let k = spanners.length - 1; k >= 0; k--) {
      let cell = spanners[k],
        span = cell[colSpan],
        col = cell[x],
        existingWidth = result[col],
        editableCols = typeof vals[col] == 'number' ? 0 : 1;
      for (let i = 1; i < span; i++) {
        existingWidth += 1 + result[col + i];
        typeof vals[col + i] == 'number' || editableCols++;
      }
      if (cell[desiredWidth] > existingWidth)
        for (let i = 0; editableCols > 0 && cell[desiredWidth] > existingWidth; ) {
          if (typeof vals[col + i] != 'number') {
            let dif = Math.round((cell[desiredWidth] - existingWidth) / editableCols);
            existingWidth += dif;
            result[col + i] += dif;
            editableCols--;
          }
          i++;
        }
    }

    objectAssign(vals, result);
    for (let j = 0; j < vals.length; j++) vals[j] = Math.max(forcedMin, vals[j] || 0);
  };
}
//
},
'cli-table3/src/cell':
function(module, exports, __wpreq__) {
//
const utils = __wpreq__('cli-table3/src/utils');

class Cell {
  constructor(options) {
    this.setOptions(options);

    this.x = null;
    this.y = null;
  }

  setOptions(options) {
    if (['boolean', 'number', 'string'].indexOf(typeof options) > -1) options = {content: '' + options};
    options = options || {};
    this.options = options;
    let content = options.content;
    if (['boolean', 'number', 'string'].indexOf(typeof content) > -1) this.content = String(content);
    else if (!content) this.content = '';
    else throw new Error('Content needs to be a primitive, got: ' + typeof content);

    this.colSpan = options.colSpan || 1;
    this.rowSpan = options.rowSpan || 1;
  }

  mergeTableOptions(tableOptions, cells) {
    this.cells = cells;

    let optionsChars = this.options.chars || {},
      tableChars = tableOptions.chars,
      chars = (this.chars = {});
    CHAR_NAMES.forEach(function(name) {
      setOption(optionsChars, tableChars, name, chars);
    });

    this.truncate = this.options.truncate || tableOptions.truncate;

    let style = (this.options.style = this.options.style || {}),
      tableStyle = tableOptions.style;
    setOption(style, tableStyle, 'padding-left', this);
    setOption(style, tableStyle, 'padding-right', this);
    this.head = style.head || tableStyle.head;
    this.border = style.border || tableStyle.border;

    let fixedWidth = tableOptions.colWidths[this.x];
    if (tableOptions.wordWrap && fixedWidth) {
      fixedWidth -= this.paddingLeft + this.paddingRight;
      if (this.colSpan)
        for (let i = 1; i < this.colSpan; ) {
          fixedWidth += tableOptions.colWidths[this.x + i];
          i++;
        }

      this.lines = utils.colorizeLines(utils.wordWrap(fixedWidth, this.content));
    } else this.lines = utils.colorizeLines(this.content.split('\n'));

    this.desiredWidth = utils.strlen(this.content) + this.paddingLeft + this.paddingRight;
    this.desiredHeight = this.lines.length;
  }

  init(tableOptions) {
    let x = this.x,
      y = this.y;
    this.widths = tableOptions.colWidths.slice(x, x + this.colSpan);
    this.heights = tableOptions.rowHeights.slice(y, y + this.rowSpan);
    this.width = this.widths.reduce(sumPlusOne, -1);
    this.height = this.heights.reduce(sumPlusOne, -1);

    this.hAlign = this.options.hAlign || tableOptions.colAligns[x];
    this.vAlign = this.options.vAlign || tableOptions.rowAligns[y];

    this.drawRight = x + this.colSpan == tableOptions.colWidths.length;
  }

  draw(lineNum, spanningCell) {
    if (lineNum == 'top') return this.drawTop(this.drawRight);
    if (lineNum == 'bottom') return this.drawBottom(this.drawRight);
    let padTop,
      padLen = Math.max(this.height - this.lines.length, 0);
    switch (this.vAlign) {
      case 'center':
        padTop = Math.ceil(padLen / 2);
        break;
      case 'bottom':
        padTop = padLen;
        break;
      default:
        padTop = 0;
    }
    if (lineNum < padTop || lineNum >= padTop + this.lines.length)
      return this.drawEmpty(this.drawRight, spanningCell);

    let forceTruncation = this.lines.length > this.height && lineNum + 1 >= this.height;
    return this.drawLine(lineNum - padTop, this.drawRight, forceTruncation, spanningCell);
  }

  drawTop(drawRight) {
    let content = [];
    if (this.cells)
      this.widths.forEach(function(width, index) {
        content.push(this._topLeftChar(index));
        content.push(utils.repeat(this.chars[this.y == 0 ? 'top' : 'mid'], width));
      }, this);
    else {
      content.push(this._topLeftChar(0));
      content.push(utils.repeat(this.chars[this.y == 0 ? 'top' : 'mid'], this.width));
    }
    drawRight && content.push(this.chars[this.y == 0 ? 'topRight' : 'rightMid']);

    return this.wrapWithStyleColors('border', content.join(''));
  }

  _topLeftChar(offset) {
    let leftChar,
      x = this.x + offset;
    if (this.y == 0) leftChar = x == 0 ? 'topLeft' : offset == 0 ? 'topMid' : 'top';
    else if (x == 0) leftChar = 'leftMid';
    else {
      leftChar = offset == 0 ? 'midMid' : 'bottomMid';
      if (this.cells) {
        if (this.cells[this.y - 1][x] instanceof Cell.ColSpanCell) leftChar = offset == 0 ? 'topMid' : 'mid';

        if (offset == 0) {
          let i = 1;
          while (this.cells[this.y][x - i] instanceof Cell.ColSpanCell) i++;

          if (this.cells[this.y][x - i] instanceof Cell.RowSpanCell) leftChar = 'leftMid';
        }
      }
    }
    return this.chars[leftChar];
  }

  wrapWithStyleColors(styleProperty, content) {
    if (!this[styleProperty] || !this[styleProperty].length) return content;

    try {
      let colors = __wpreq__('colors');
      for (let i = this[styleProperty].length - 1; i >= 0; i--) colors = colors[this[styleProperty][i]];

      return colors(content);
    } catch (_e) {
      return content;
    }
  }

  drawLine(lineNum, drawRight, forceTruncationSymbol, spanningCell) {
    let left = this.chars[this.x == 0 ? 'left' : 'middle'];
    if (this.x && spanningCell && this.cells) {
      let cellLeft = this.cells[this.y + spanningCell][this.x - 1];
      while (cellLeft instanceof ColSpanCell) cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];

      cellLeft instanceof RowSpanCell || (left = this.chars.rightMid);
    }
    let leftPadding = utils.repeat(' ', this.paddingLeft),
      right = drawRight ? this.chars.right : '',
      rightPadding = utils.repeat(' ', this.paddingRight),
      line = this.lines[lineNum],
      len = this.width - (this.paddingLeft + this.paddingRight);
    if (forceTruncationSymbol) line += this.truncate || '';
    let content = utils.truncate(line, len, this.truncate);
    content = utils.pad(content, len, ' ', this.hAlign);
    content = leftPadding + content + rightPadding;
    return this.stylizeLine(left, content, right);
  }

  stylizeLine(left, content, right) {
    left = this.wrapWithStyleColors('border', left);
    right = this.wrapWithStyleColors('border', right);
    if (this.y === 0) content = this.wrapWithStyleColors('head', content);

    return left + content + right;
  }

  drawBottom(drawRight) {
    let left = this.chars[this.x == 0 ? 'bottomLeft' : 'bottomMid'],
      content = utils.repeat(this.chars.bottom, this.width),
      right = drawRight ? this.chars.bottomRight : '';
    return this.wrapWithStyleColors('border', left + content + right);
  }

  drawEmpty(drawRight, spanningCell) {
    let left = this.chars[this.x == 0 ? 'left' : 'middle'];
    if (this.x && spanningCell && this.cells) {
      let cellLeft = this.cells[this.y + spanningCell][this.x - 1];
      while (cellLeft instanceof ColSpanCell) cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];

      cellLeft instanceof RowSpanCell || (left = this.chars.rightMid);
    }
    let right = drawRight ? this.chars.right : '',
      content = utils.repeat(' ', this.width);
    return this.stylizeLine(left, content, right);
  }
}

class ColSpanCell {
  constructor() {}

  draw() {
    return '';
  }

  init() {}

  mergeTableOptions() {}
}

class RowSpanCell {
  constructor(originalCell) {
    this.originalCell = originalCell;
  }

  init(tableOptions) {
    let y = this.y,
      originalY = this.originalCell.y;
    this.cellOffset = y - originalY;
    this.offset = findDimension(tableOptions.rowHeights, originalY, this.cellOffset);
  }

  draw(lineNum) {
    return lineNum == 'top'
      ? this.originalCell.draw(this.offset, this.cellOffset)
      : lineNum == 'bottom'
      ? this.originalCell.draw('bottom')
      : this.originalCell.draw(this.offset + 1 + lineNum);
  }

  mergeTableOptions() {}
}

function setOption(objA, objB, nameB, targetObj) {
  let nameA = nameB.split('-');
  if (nameA.length > 1) {
    nameA[1] = nameA[1].charAt(0).toUpperCase() + nameA[1].substr(1);
    nameA = nameA.join('');
    targetObj[nameA] = objA[nameA] || objA[nameB] || objB[nameA] || objB[nameB];
  } else targetObj[nameB] = objA[nameB] || objB[nameB];
}

function findDimension(dimensionTable, startingIndex, span) {
  let ret = dimensionTable[startingIndex];
  for (let i = 1; i < span; i++) ret += 1 + dimensionTable[startingIndex + i];

  return ret;
}

function sumPlusOne(a, b) {
  return a + b + 1;
}

let CHAR_NAMES = [
  'top',
  'top-mid',
  'top-left',
  'top-right',
  'bottom',
  'bottom-mid',
  'bottom-left',
  'bottom-right',
  'left',
  'left-mid',
  'mid',
  'mid-mid',
  'right',
  'right-mid',
  'middle'
];
module.exports = Cell;
module.exports.ColSpanCell = ColSpanCell;
module.exports.RowSpanCell = RowSpanCell;
//
},
colors:
function(module, exports, __wpreq__) {
//
var colors = {};
module.exports = colors;

colors.themes = {};

var util = __wpreq__('util'),
  ansiStyles = (colors.styles = __wpreq__('colors/lib/styles')),
  defineProps = Object.defineProperties,
  newLineRegex = new RegExp(/[\r\n]+/g);

colors.supportsColor = __wpreq__('colors/lib/system/supports-colors').supportsColor;

if (colors.enabled === void 0) colors.enabled = colors.supportsColor() !== false;

colors.enable = function() {
  colors.enabled = true;
};

colors.disable = function() {
  colors.enabled = false;
};

colors.stripColors = colors.strip = function(str) {
  return ('' + str).replace(/\x1B\[\d+m/g, '');
};

colors.stylize = function(str, style) {
  return colors.enabled ? ansiStyles[style].open + str + ansiStyles[style].close : str + '';
};

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
var escapeStringRegexp = function(str) {
  if (typeof str != 'string') throw new TypeError('Expected a string');

  return str.replace(matchOperatorsRe, '\\$&');
};

function build(_styles) {
  var builder = function builder() {
    return applyStyle.apply(builder, arguments);
  };
  builder._styles = _styles;
  builder.__proto__ = proto;
  return builder;
}

var styles = (function() {
  var ret = {};
  ansiStyles.grey = ansiStyles.gray;
  Object.keys(ansiStyles).forEach(function(key) {
    ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
    ret[key] = {
      get: function() {
        return build(this._styles.concat(key));
      }
    };
  });
  return ret;
})();

var proto = defineProps(function() /*colors*/ {}, styles);

function applyStyle() {
  var str = Array.prototype.slice.call(arguments)
    .map(function(arg) {
      return arg != null && arg.constructor === String ? arg : util.inspect(arg);
    })
    .join(' ');

  if (!colors.enabled || !str) return str;

  for (var newLinesPresent = str.indexOf('\n') > -1, nestedStyles = this._styles, i = nestedStyles.length; i--; ) {
    const code = ansiStyles[nestedStyles[i]];
    str = code.open + str.replace(code.closeRe, code.open) + code.close;
    if (newLinesPresent)
      str = str.replace(newLineRegex, function(match) {
        return code.close + match + code.open;
      });
  }

  return str;
}

colors.setTheme = function(theme) {
  if (typeof theme == 'string') {
    console.log(
      "colors.setTheme now only accepts an object, not a string.\
  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.\
  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require('../themes/generic-logging.js'));"
    );
    return;
  }
  for (var style in theme)
    !(function(style) {
      colors[style] = function(str) {
        if (typeof theme[style] == 'object') {
          var out = str;
          for (var i in theme[style]) out = colors[theme[style][i]](out);

          return out;
        }
        return colors[theme[style]](str);
      };
    })(style);
};

function init() {
  var ret = {};
  Object.keys(styles).forEach(function(name) {
    ret[name] = {
      get: function() {
        return build([name]);
      }
    };
  });
  return ret;
}

var sequencer = function(map, str) {
  var exploded = str.split('');
  return (exploded = exploded.map(map)).join(''); // TODO
};

colors.trap = __wpreq__('colors/lib/custom/trap');
colors.zalgo = __wpreq__('colors/lib/custom/zalgo');

colors.maps = {};
colors.maps.america = __wpreq__('colors/lib/maps/america')(colors);
colors.maps.zebra = __wpreq__('colors/lib/maps/zebra')(colors);
colors.maps.rainbow = __wpreq__('colors/lib/maps/rainbow')(colors);
colors.maps.random = __wpreq__('colors/lib/maps/random')(colors);

for (var map in colors.maps)
  !(function(map) {
    colors[map] = function(str) {
      return sequencer(colors.maps[map], str);
    };
  })(map);

defineProps(colors, init());
//
},
'colors/lib/styles':
function(module) {
//
var styles = {};
module.exports = styles;

var codes = {
  reset: [0, 0],

  bold: [1, 22],
  dim: [2, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],

  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  grey: [90, 39],

  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],

  blackBG: [40, 49],
  redBG: [41, 49],
  greenBG: [42, 49],
  yellowBG: [43, 49],
  blueBG: [44, 49],
  magentaBG: [45, 49],
  cyanBG: [46, 49],
  whiteBG: [47, 49]
};

Object.keys(codes).forEach(function(key) {
  var val = codes[key],
    style = (styles[key] = []);
  style.open = '\x1b[' + val[0] + 'm';
  style.close = '\x1b[' + val[1] + 'm';
});
//
},
'colors/lib/system/supports-colors':
function(module, exports, __wpreq__) {
//
var os = __wpreq__('os'),
  hasFlag = __wpreq__('colors/lib/system/has-flag'),

  env = process.env,

  forceColor = void 0;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) forceColor = false;
else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) forceColor = true;

if ('FORCE_COLOR' in env) forceColor = !env.FORCE_COLOR.length || parseInt(env.FORCE_COLOR, 10) !== 0;

function translateLevel(level) {
  return level !== 0 && {level: level, hasBasic: true, has256: level >= 2, has16m: level >= 3};
}

function supportsColor(stream) {
  if (forceColor === false) return 0;

  if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) return 3;

  if (hasFlag('color=256')) return 2;

  if (stream && !stream.isTTY && forceColor !== true) return 0;

  var min = forceColor ? 1 : 0;

  if (process.platform === 'win32') {
    var osRelease = os.release().split('.');
    return Number(process.versions.node.split('.')[0]) >= 8 &&
      Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586
      ? (Number(osRelease[2]) >= 14931 ? 3 : 2)
      : 1;
  }

  if ('CI' in env)
    return ['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(function(sign) {
      return sign in env;
    }) || env.CI_NAME === 'codeship'
      ? 1
      : min;

  if ('TEAMCITY_VERSION' in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;

  if ('TERM_PROGRAM' in env) {
    var version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

    switch (env.TERM_PROGRAM) {
      case 'iTerm.app':
        return version >= 3 ? 3 : 2;
      case 'Hyper':
        return 3;
      case 'Apple_Terminal':
        return 2;
    }
  }

  return /-256(color)?$/i.test(env.TERM)
    ? 2
    : /^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM) || 'COLORTERM' in env
    ? 1
    // : env.TERM === 'dumb' ? min
    : min;
}

function getSupportLevel(stream) {
  return translateLevel(supportsColor(stream));
}

module.exports = {
  supportsColor: getSupportLevel,
  stdout: getSupportLevel(process.stdout),
  stderr: getSupportLevel(process.stderr)
};
//
},
'colors/lib/system/has-flag':
function(module) {
//
module.exports = function(flag, argv) {
  var terminatorPos = (argv = argv || process.argv).indexOf('--'),
    prefix = /^-{1,2}/.test(flag) ? '' : '--',
    pos = argv.indexOf(prefix + flag);

  return pos > -1 && (terminatorPos < 0 || pos < terminatorPos);
};
//
},
'colors/lib/custom/trap':
function(module) {
//
module.exports = function(text, options) {
  var result = '';
  text = (text = text || 'Run the trap, drop the bass').split('');
  var trap = {
    a: ['@', '', '', '', '', '', ''],
    b: ['', '', '', '', '', ''],
    c: ['', '', ''],
    d: ['', '', '', '', '', ''],
    e: ['', '', '', '', '', '', '', ''],
    f: [''],
    g: [''],
    h: ['', '', '', '', '', ''],
    i: [''],
    j: [''],
    k: ['', '', '', ''],
    l: [''],
    m: ['', '', '', '', '', ''],
    n: ['', '', '', '', '', ''],
    o: ['', '', '', '', '', '', '', '', ''],
    p: ['', ''],
    q: [''],
    r: ['', '', '', '', '', ''],
    s: ['', '', '', ''],
    t: ['', '', ''],
    u: ['', ''],
    v: [''],
    w: ['', '', '', ''],
    x: ['', '', '', ''],
    y: ['', '', ''],
    z: ['', '']
  };
  text.forEach(function(c) {
    c = c.toLowerCase();
    var chars = trap[c] || [' '],
      rand = Math.floor(Math.random() * chars.length);
    trap[c] !== void 0 ? (result += trap[c][rand]) : (result += c);
  });
  return result;
};
//
},
'colors/lib/custom/zalgo':
function(module) {
//
module.exports = function(text, options) {
  text = text || '   he is here   ';
  var soul = {
    up: [
      '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
      '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
      '', '', '', '', '', '', '', '', '', ''
    ],
    down: [
      '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
      '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''
    ],
    mid: [
      '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ' '
    ]
  };
  var all = [].concat(soul.up, soul.down, soul.mid);

  function randomNumber(range) {
    return Math.floor(Math.random() * range);
  }

  function isChar(character) {
    var bool = false;
    all.filter(function(i) {
      bool = i === character;
    });
    return bool;
  }

  function heComes(text, options) {
    var counts,
      l,
      result = '';
    (options = options || {}).up = options.up === void 0 || options.up;
    options.mid = options.mid === void 0 || options.mid;
    options.down = options.down === void 0 || options.down;
    options.size = options.size !== void 0 ? options.size : 'maxi';
    text = text.split('');
    for (l in text) {
      if (isChar(l)) continue;

      result += text[l];
      counts = {up: 0, down: 0, mid: 0};
      switch (options.size) {
      case 'mini':
        counts.up = randomNumber(8);
        counts.mid = randomNumber(2);
        counts.down = randomNumber(8);
        break;
      case 'maxi':
        counts.up = randomNumber(16) + 3;
        counts.mid = randomNumber(4) + 1;
        counts.down = randomNumber(64) + 3;
        break;
      default:
        counts.up = randomNumber(8) + 1;
        counts.mid = randomNumber(6) / 2;
        counts.down = randomNumber(8) + 1;
        break;
      }

      var arr = ['up', 'mid', 'down'];
      for (var d in arr)
        for (var index = arr[d], i = 0; i <= counts[index]; i++)
          if (options[index]) result += soul[index][randomNumber(soul[index].length)];
    }
    return result;
  }
  return heComes(text, options);
};
//
},
'colors/lib/maps/america':
function(module) {
//
module.exports = function(colors) {
  return function(letter, i, exploded) {
    if (letter === ' ') return letter;
    switch (i % 3) {
      case 0: return colors.red(letter);
      case 1: return colors.white(letter);
      case 2: return colors.blue(letter);
    }
  };
};
//
},
'colors/lib/maps/zebra':
function(module) {
//
module.exports = function(colors) {
  return function(letter, i, exploded) {
    return i % 2 == 0 ? letter : colors.inverse(letter);
  };
};
//
},
'colors/lib/maps/rainbow':
function(module) {
//
module.exports = function(colors) {
  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta'];
  return function(letter, i, exploded) {
    return letter === ' ' ? letter : colors[rainbowColors[i++ % rainbowColors.length]](letter);
  };
};
//
},
'colors/lib/maps/random':
function(module) {
//
module.exports = function(colors) {
  var available = ['underline', 'inverse', 'grey', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta'];
  return function(letter, i, exploded) {
    return letter === ' ' ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
  };
};
//
},
read:
function(module, exports, __wpreq__) {
//
module.exports = read

var readline = __wpreq__('readline'),
  Mute = __wpreq__('mute-stream')

function read(opts, cb) {
  if (opts.num) throw new Error('read() no longer accepts a char number limit')

  if (opts.default !== void 0 && typeof opts.default != 'string' && typeof opts.default != 'number')
    throw new Error('default value must be string or number')

  var input = opts.input || process.stdin,
    output = opts.output || process.stdout,
    prompt = (opts.prompt || '').trim() + ' ',
    silent = opts.silent,
    editDef = false,
    timeout = opts.timeout,

    def = opts.default || ''
  if (def) silent ? (prompt += '(<default hidden>) ') : opts.edit ? (editDef = true) : (prompt += '(' + def + ') ')

  var terminal = !(!opts.terminal && !output.isTTY),

    m = new Mute({replace: opts.replace, prompt: prompt})
  m.pipe(output, {end: false})
  var rlOpts = {input: input, output: (output = m), terminal: terminal}

  var rl = process.version.match(/^v?0\.6\b/)
    ? readline.createInterface(rlOpts.input, rlOpts.output)
    : readline.createInterface(rlOpts)

  output.unmute()
  rl.setPrompt(prompt)
  rl.prompt()
  if (silent) output.mute()
  else if (editDef) {
    rl.line = def
    rl.cursor = def.length
    rl._refreshLine()
  }

  var timer,
    called = false
  rl.on('line', onLine)
  rl.on('error', onError)

  rl.on('SIGINT', function() {
    rl.close()
    onError(new Error('canceled'))
  })

  if (timeout)
    timer = setTimeout(function() {
      onError(new Error('timed out'))
    }, timeout)

  function done() {
    called = true
    rl.close()

    if (process.version.match(/^v?0\.6\b/)) {
      rl.input.removeAllListeners('data')
      rl.input.removeAllListeners('keypress')
      rl.input.pause()
    }

    clearTimeout(timer)
    output.mute()
    output.end()
  }

  function onError(er) {
    if (called) return
    done()
    return cb(er)
  }

  function onLine(line) {
    if (called) return
    if (silent && terminal) {
      output.unmute()
      output.write('\r\n')
    }
    done()
    line = line.replace(/\r?\n$/, '')
    var isDefault = !(!editDef || line !== def)
    if (def && !line) {
      isDefault = true
      line = def
    }
    cb(null, line, isDefault)
  }
}
//
},
glob:
function(module, exports, __wpreq__) {
//
module.exports = glob

var fs = __wpreq__('fs'),
  rp = __wpreq__('fs.realpath'),
  minimatch = __wpreq__('minimatch'),
  inherits = __wpreq__('inherits'),
  EE = __wpreq__('events').EventEmitter,
  path = __wpreq__('path'),
  assert = __wpreq__('assert'),
  isAbsolute = __wpreq__('path-is-absolute'),
  globSync = __wpreq__('glob/sync'),
  common = __wpreq__('glob/common'),
  setopts = common.setopts,
  ownProp = common.ownProp,
  inflight = __wpreq__('inflight'),
  childrenIgnored = common.childrenIgnored,
  isIgnored = common.isIgnored,

  once = __wpreq__('once')

function glob(pattern, options, cb) {
  if (typeof options == 'function') (cb = options), (options = {})
  options || (options = {})

  if (options.sync) {
    if (cb) throw new TypeError('callback provided to sync glob')
    return globSync(pattern, options)
  }

  return new Glob(pattern, options, cb)
}

glob.sync = globSync
var GlobSync = (glob.GlobSync = globSync.GlobSync)

glob.glob = glob

function extend(origin, add) {
  if (add === null || typeof add != 'object') return origin

  for (var keys = Object.keys(add), i = keys.length; i--; ) origin[keys[i]] = add[keys[i]]

  return origin
}

glob.hasMagic = function(pattern, options_) {
  var options = extend({}, options_)
  options.noprocess = true

  var set = new Glob(pattern, options).minimatch.set

  if (!pattern) return false

  if (set.length > 1) return true

  for (var j = 0; j < set[0].length; j++) if (typeof set[0][j] != 'string') return true

  return false
}

glob.Glob = Glob
inherits(Glob, EE)
function Glob(pattern, options, cb) {
  if (typeof options == 'function') {
    cb = options
    options = null
  }

  if (options && options.sync) {
    if (cb) throw new TypeError('callback provided to sync glob')
    return new GlobSync(pattern, options)
  }

  if (!(this instanceof Glob)) return new Glob(pattern, options, cb)

  setopts(this, pattern, options)
  this._didRealPath = false

  var n = this.minimatch.set.length

  this.matches = new Array(n)

  if (typeof cb == 'function') {
    cb = once(cb)
    this.on('error', cb)
    this.on('end', function(matches) {
      cb(null, matches)
    })
  }

  var self = this
  this._processing = 0

  this._emitQueue = []
  this._processQueue = []
  this.paused = false

  if (this.noprocess) return this

  if (n === 0) return done()

  var sync = true
  for (var i = 0; i < n; i++) this._process(this.minimatch.set[i], i, false, done)

  sync = false

  function done() {
    --self._processing
    if (self._processing <= 0)
      sync
        ? process.nextTick(function() {
            self._finish()
          })
        : self._finish()
  }
}

Glob.prototype._finish = function() {
  assert(this instanceof Glob)
  if (this.aborted) return

  if (this.realpath && !this._didRealpath) return this._realpath()

  common.finish(this)
  this.emit('end', this.found)
}

Glob.prototype._realpath = function() {
  if (this._didRealpath) return

  this._didRealpath = true

  var n = this.matches.length
  if (n === 0) return this._finish()

  var self = this
  for (var i = 0; i < this.matches.length; i++) this._realpathSet(i, next)

  function next() {
    --n != 0 || self._finish()
  }
}

Glob.prototype._realpathSet = function(index, cb) {
  var matchset = this.matches[index]
  if (!matchset) return cb()

  var found = Object.keys(matchset),
    self = this,
    n = found.length

  if (n === 0) return cb()

  var set = (this.matches[index] = Object.create(null))
  found.forEach(function(p, i) {
    p = self._makeAbs(p)
    rp.realpath(p, self.realpathCache, function(er, real) {
      !er ? (set[real] = true) : er.syscall === 'stat' ? (set[p] = true) : self.emit('error', er)

      if (--n == 0) {
        self.matches[index] = set
        cb()
      }
    })
  })
}

Glob.prototype._mark = function(p) {
  return common.mark(this, p)
}

Glob.prototype._makeAbs = function(f) {
  return common.makeAbs(this, f)
}

Glob.prototype.abort = function() {
  this.aborted = true
  this.emit('abort')
}

Glob.prototype.pause = function() {
  if (!this.paused) {
    this.paused = true
    this.emit('pause')
  }
}

Glob.prototype.resume = function() {
  if (!this.paused) return

  this.emit('resume')
  this.paused = false
  if (this._emitQueue.length) {
    var eq = this._emitQueue.slice(0)
    this._emitQueue.length = 0
    for (var i = 0; i < eq.length; i++) {
      var e = eq[i]
      this._emitMatch(e[0], e[1])
    }
  }
  if (this._processQueue.length) {
    var pq = this._processQueue.slice(0)
    this._processQueue.length = 0
    for (i = 0; i < pq.length; i++) {
      var p = pq[i]
      this._processing--
      this._process(p[0], p[1], p[2], p[3])
    }
  }
}

Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
  assert(this instanceof Glob)
  assert(typeof cb == 'function')

  if (this.aborted) return

  this._processing++
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb])
    return
  }

  var prefix,
    n = 0
  while (typeof pattern[n] == 'string') n++

  switch (n) {
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb)
      return

    case 0:
      prefix = null
      break

    default:
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var read,
    remain = pattern.slice(n)

  if (prefix === null) read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    (prefix && isAbsolute(prefix)) || (prefix = '/' + prefix)
    read = prefix
  } else read = prefix

  var abs = this._makeAbs(read)

  if (childrenIgnored(this, read)) return cb()

  remain[0] === minimatch.GLOBSTAR
    ? this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
    : this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
}

Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function(er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}

Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  if (!entries) return cb()

  var pn = remain[0],
    negate = !!this.minimatch.negate,
    rawGlob = pn._glob,
    dotOk = this.dot || rawGlob.charAt(0) === '.',

    matchedEntries = []
  for (var i = 0; i < entries.length; i++)
    ((e = entries[i]).charAt(0) !== '.' || dotOk) &&
      (negate && !prefix ? !e.match(pn) : e.match(pn)) &&
      matchedEntries.push(e)

  var len = matchedEntries.length
  if (len === 0) return cb()

  if (remain.length === 1 && !this.mark && !this.stat) {
    this.matches[index] || (this.matches[index] = Object.create(null))

    for (i = 0; i < len; i++) {
      var e = matchedEntries[i]
      if (prefix) e = prefix !== '/' ? prefix + '/' + e : prefix + e

      e.charAt(0) !== '/' || this.nomount || (e = path.join(this.root, e))

      this._emitMatch(index, e)
    }
    return cb()
  }

  remain.shift()
  for (i = 0; i < len; i++) {
    e = matchedEntries[i]
    if (prefix) e = prefix !== '/' ? prefix + '/' + e : prefix + e

    this._process([e].concat(remain), index, inGlobStar, cb)
  }
  cb()
}

Glob.prototype._emitMatch = function(index, e) {
  if (this.aborted || isIgnored(this, e)) return

  if (this.paused) {
    this._emitQueue.push([index, e])
    return
  }

  var abs = isAbsolute(e) ? e : this._makeAbs(e)

  if (this.mark) e = this._mark(e)

  if (this.absolute) e = abs

  if (this.matches[index][e]) return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c)) return
  }

  this.matches[index][e] = true

  var st = this.statCache[abs]
  st && this.emit('stat', e, st)

  this.emit('match', e)
}

Glob.prototype._readdirInGlobStar = function(abs, cb) {
  if (this.aborted) return

  if (this.follow) return this._readdir(abs, false, cb)

  var self = this,
    lstatcb = inflight('lstat\0' + abs, lstatcb_)

  lstatcb && fs.lstat(abs, lstatcb)

  function lstatcb_(er, lstat) {
    if (er && er.code === 'ENOENT') return cb()

    var isSym = lstat && lstat.isSymbolicLink()
    self.symlinks[abs] = isSym

    if (!isSym && lstat && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE'
      cb()
    } else self._readdir(abs, false, cb)
  }
}

Glob.prototype._readdir = function(abs, inGlobStar, cb) {
  if (this.aborted || !(cb = inflight('readdir\0' + abs + '\0' + inGlobStar, cb))) return

  if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs, cb)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE') return cb()

    if (Array.isArray(c)) return cb(null, c)
  }

  fs.readdir(abs, readdirCb(this, abs, cb))
}

function readdirCb(self, abs, cb) {
  return function(er, entries) {
    er ? self._readdirError(abs, er, cb) : self._readdirEntries(abs, entries, cb)
  }
}

Glob.prototype._readdirEntries = function(abs, entries, cb) {
  if (this.aborted) return

  if (!this.mark && !this.stat)
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i]
      e = abs === '/' ? abs + e : abs + '/' + e
      this.cache[e] = true
    }

  this.cache[abs] = entries
  return cb(null, entries)
}

Glob.prototype._readdirError = function(f, er, cb) {
  if (this.aborted) return

  switch (er.code) {
    case 'ENOTSUP':
    case 'ENOTDIR':
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        this.emit('error', error)
        this.abort()
      }
      break

    case 'ENOENT':
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default:
      this.cache[this._makeAbs(f)] = false
      if (this.strict) {
        this.emit('error', er)
        this.abort()
      }
      this.silent || console.error('glob error', er)
      break
  }

  return cb()
}

Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function(er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}

Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  if (!entries) return cb()

  var remainWithoutGlobStar = remain.slice(1),
    gspref = prefix ? [prefix] : [],
    noGlobStar = gspref.concat(remainWithoutGlobStar)

  this._process(noGlobStar, index, false, cb)

  var isSym = this.symlinks[abs],
    len = entries.length

  if (isSym && inGlobStar) return cb()

  for (var i = 0; i < len; i++) {
    if (entries[i].charAt(0) === '.' && !this.dot) continue

    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true, cb)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true, cb)
  }

  cb()
}

Glob.prototype._processSimple = function(prefix, index, cb) {
  var self = this
  this._stat(prefix, function(er, exists) {
    self._processSimple2(prefix, index, er, exists, cb)
  })
}
Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
  this.matches[index] || (this.matches[index] = Object.create(null))

  if (!exists) return cb()

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') prefix = path.join(this.root, prefix)
    else {
      prefix = path.resolve(this.root, prefix)
      if (trail) prefix += '/'
    }
  }

  if (process.platform === 'win32') prefix = prefix.replace(/\\/g, '/')

  this._emitMatch(index, prefix)
  cb()
}

Glob.prototype._stat = function(f, cb) {
  var abs = this._makeAbs(f),
    needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength) return cb()

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c)) c = 'DIR'

    if (!needDir || c === 'DIR') return cb(null, c)

    if (needDir && c === 'FILE') return cb()
  }

  var stat = this.statCache[abs]
  if (stat !== void 0) {
    if (stat === false) return cb(null, stat)

    var type = stat.isDirectory() ? 'DIR' : 'FILE'
    return needDir && type === 'FILE' ? cb() : cb(null, type, stat)
  }

  var self = this,
    statcb = inflight('stat\0' + abs, lstatcb_)
  statcb && fs.lstat(abs, statcb)

  function lstatcb_(er, lstat) {
    if (lstat && lstat.isSymbolicLink())
      return fs.stat(abs, function(er, stat) {
        er ? self._stat2(f, abs, null, lstat, cb) : self._stat2(f, abs, er, stat, cb)
      })

    self._stat2(f, abs, er, lstat, cb)
  }
}

Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
    this.statCache[abs] = false
    return cb()
  }

  var needDir = f.slice(-1) === '/'
  this.statCache[abs] = stat

  if (abs.slice(-1) === '/' && stat && !stat.isDirectory()) return cb(null, false, stat)

  var c = true
  if (stat) c = stat.isDirectory() ? 'DIR' : 'FILE'
  this.cache[abs] = this.cache[abs] || c

  return needDir && c === 'FILE' ? cb() : cb(null, c, stat)
}
//
},
'fs.realpath':
function(module, exports, __wpreq__) {
//
module.exports = realpath
realpath.realpath = realpath
realpath.sync = realpathSync
realpath.realpathSync = realpathSync
realpath.monkeypatch = monkeypatch
realpath.unmonkeypatch = unmonkeypatch

var fs = __wpreq__('fs'),
  origRealpath = fs.realpath,
  origRealpathSync = fs.realpathSync,

  version = process.version,
  ok = /^v?[0-5]\./.test(version),
  old = __wpreq__('fs.realpath/old')

function newError(er) {
  return er && er.syscall === 'realpath' && (er.code === 'ELOOP' || er.code === 'ENOMEM' || er.code === 'ENAMETOOLONG')
}

function realpath(p, cache, cb) {
  if (ok) return origRealpath(p, cache, cb)

  if (typeof cache == 'function') {
    cb = cache
    cache = null
  }
  origRealpath(p, cache, function(er, result) {
    newError(er) ? old.realpath(p, cache, cb) : cb(er, result)
  })
}

function realpathSync(p, cache) {
  if (ok) return origRealpathSync(p, cache)

  try {
    return origRealpathSync(p, cache)
  } catch (er) {
    if (newError(er)) return old.realpathSync(p, cache)

    throw er
  }
}

function monkeypatch() {
  fs.realpath = realpath
  fs.realpathSync = realpathSync
}

function unmonkeypatch() {
  fs.realpath = origRealpath
  fs.realpathSync = origRealpathSync
}
//
},
'fs.realpath/old':
function(module, exports, __wpreq__) {
//
var pathModule = __wpreq__('path'),
  isWindows = process.platform === 'win32',
  fs = __wpreq__('fs'),

  DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);

function rethrow() {
  var callback;
  if (DEBUG) {
    var backtrace = new Error();
    callback = debugCallback;
  } else callback = missingCallback;

  return callback;

  function debugCallback(err) {
    if (err) {
      backtrace.message = err.message;
      missingCallback((err = backtrace));
    }
  }

  function missingCallback(err) {
    if (err) {
      if (process.throwDeprecation) throw err;
      if (!process.noDeprecation) {
        var msg = 'fs: missing callback ' + (err.stack || err.message);
        process.traceDeprecation ? console.trace(msg) : console.error(msg);
      }
    }
  }
}

function maybeCallback(cb) {
  return typeof cb == 'function' ? cb : rethrow();
}

//= pathModule.normalize;

var nextPartRe = isWindows ? /(.*?)(?:[\/\\]+|$)/g : /(.*?)(?:[\/]+|$)/g;

var splitRootRe = isWindows ? /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/ : /^[\/]*/;

exports.realpathSync = function(p, cache) {
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) return cache[p];

  var original = p,
    seenLinks = {},
    knownHard = {};

  var pos, current, base, previous;

  start();

  function start() {
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    if (isWindows && !knownHard[base]) {
      fs.lstatSync(base);
      knownHard[base] = true;
    }
  }

  while (pos < p.length) {
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    if (knownHard[base] || (cache && cache[base] === base)) continue;

    var resolvedLink;
    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) resolvedLink = cache[base];
    else {
      var stat = fs.lstatSync(base);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        continue;
      }

      var linkTarget = null;
      if (!isWindows) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) linkTarget = seenLinks[id];
      }
      if (linkTarget === null) {
        fs.statSync(base);
        linkTarget = fs.readlinkSync(base);
      }
      resolvedLink = pathModule.resolve(previous, linkTarget);
      if (cache) cache[base] = resolvedLink;
      isWindows || (seenLinks[id] = linkTarget);
    }

    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache[original] = p;

  return p;
};

exports.realpath = function(p, cache, cb) {
  if (typeof cb != 'function') {
    cb = maybeCallback(cache);
    cache = null;
  }

  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p))
    return process.nextTick(cb.bind(null, null, cache[p]));

  var original = p,
    seenLinks = {},
    knownHard = {};

  var pos, current, base, previous;

  start();

  function start() {
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    isWindows && !knownHard[base]
      ? fs.lstat(base, function(err) {
          if (err) return cb(err);
          knownHard[base] = true;
          LOOP();
        })
      : process.nextTick(LOOP);
  }

  function LOOP() {
    if (pos >= p.length) {
      if (cache) cache[original] = p;
      return cb(null, p);
    }

    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    return knownHard[base] || (cache && cache[base] === base)
      ? process.nextTick(LOOP)
      : cache && Object.prototype.hasOwnProperty.call(cache, base)
      ? gotResolvedLink(cache[base])
      : fs.lstat(base, gotStat);
  }

  function gotStat(err, stat) {
    if (err) return cb(err);

    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      if (cache) cache[base] = base;
      return process.nextTick(LOOP);
    }

    if (!isWindows) {
      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
      if (seenLinks.hasOwnProperty(id)) return gotTarget(null, seenLinks[id], base);
    }
    fs.stat(base, function(err) {
      if (err) return cb(err);

      fs.readlink(base, function(err, target) {
        isWindows || (seenLinks[id] = target);
        gotTarget(err, target);
      });
    });
  }

  function gotTarget(err, target, base) {
    if (err) return cb(err);

    var resolvedLink = pathModule.resolve(previous, target);
    if (cache) cache[base] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }

  function gotResolvedLink(resolvedLink) {
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
};
//
},
minimatch:
function(module, exports, __wpreq__) {
//
module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = {sep: '/'}
try {
  path = __wpreq__('path')
} catch (_er) {}

var GLOBSTAR = (minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}),
  expand = __wpreq__('brace-expansion')

var plTypes = {
  '!': {open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': {open: '(?:', close: ')?'},
  '+': {open: '(?:', close: ')+'},
  '*': {open: '(?:', close: ')*'},
  '@': {open: '(?:', close: ')'}
}

var qmark = '[^/]',
  star = qmark + '*?',

  twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?',
  twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?',

  reSpecials = charSet('().*{}+?[]^$\\!')

function charSet(s) {
  return s.split('').reduce(function(set, c) {
    set[c] = true
    return set
  }, {})
}

var slashSplit = /\/+/

minimatch.filter = filter
function filter(pattern, options) {
  options = options || {}
  return function(p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext(a, b) {
  a = a || {}
  b = b || {}
  var t = {}
  Object.keys(b).forEach(function(k) {
    t[k] = b[k]
  })
  Object.keys(a).forEach(function(k) {
    t[k] = a[k]
  })
  return t
}

minimatch.defaults = function(def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch

  var m = function(p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  }

  m.Minimatch = function(pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function(def) {
  return def && Object.keys(def).length ? minimatch.defaults(def).Minimatch : Minimatch
}

function minimatch(p, pattern, options) {
  if (typeof pattern != 'string') throw new TypeError('glob pattern string required')

  options || (options = {})

  return (
    !(!options.nocomment && pattern.charAt(0) === '#') &&
    (pattern.trim() === '' ? p === '' : new Minimatch(pattern, options).match(p))
  )
}

function Minimatch(pattern, options) {
  if (!(this instanceof Minimatch)) return new Minimatch(pattern, options)

  if (typeof pattern != 'string') throw new TypeError('glob pattern string required')

  options || (options = {})
  pattern = pattern.trim()

  if (path.sep !== '/') pattern = pattern.split(path.sep).join('/')

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  this.make()
}

Minimatch.prototype.debug = function() {}

Minimatch.prototype.make = make
function make() {
  if (this._made) return

  var pattern = this.pattern,
    options = this.options

  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  this.parseNegate()

  var set = (this.globSet = this.braceExpand())

  if (options.debug) this.debug = console.error

  this.debug(this.pattern, set)

  set = this.globParts = set.map(function(s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  set = set.map(function(s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  set = set.filter(function(s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate() {
  var pattern = this.pattern,
    negate = false,
    negateOffset = 0

  if (this.options.nonegate) return

  for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

minimatch.braceExpand = function(pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand(pattern, options) {
  options || (options = this instanceof Minimatch ? this.options : {})

  if ((pattern = pattern === void 0 ? this.pattern : pattern) === void 0) throw new TypeError('undefined pattern')

  return options.nobrace || !pattern.match(/{.*}/) ? [pattern] : expand(pattern)
}

Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse(pattern, isSub) {
  if (pattern.length > 65536) throw new TypeError('pattern is too long')

  var options = this.options

  if (!options.noglobstar && pattern === '**') return GLOBSTAR
  if (pattern === '') return ''

  var stateChar,
    re = '',
    hasMagic = !!options.nocase,
    escaping = false,
    patternListStack = [],
    negativeLists = [],
    inClass = false,
    reClassStart = -1,
    classStart = -1,
    patternStart = pattern.charAt(0) === '.' ? '' : options.dot ? '(?!(?:^|\\/)\\.{1,2}(?:$|\\/))' : '(?!\\.)',
    self = this

  function clearStateChar() {
    if (stateChar) {
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
          break
        case '?':
          re += qmark
          hasMagic = true
          break
        default:
          re += '\\' + stateChar
          break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var c, i = 0, len = pattern.length; i < len && (c = pattern.charAt(i)); i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      case '/':
        return false

      case '\\':
        clearStateChar()
        escaping = true
        continue

      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        options.noext && clearStateChar()
        continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
        continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        re += pl.close
        pl.type !== '!' || negativeLists.push(pl)

        pl.reEnd = re.length
        continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
        continue

      case '[':
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
        continue

      case ']':
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        if (inClass) {
          var cs = pattern.substring(classStart + 1, i)
          try {
            RegExp('[' + cs + ']')
          } catch (_er) {
            var sp = this.parse(cs, SUBPARSE)
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
            hasMagic = hasMagic || sp[1]
            inClass = false
            continue
          }
        }

        hasMagic = true
        inClass = false
        re += c
        continue

      default:
        clearStateChar()

        escaping ? (escaping = false) : !reSpecials[c] || (c === '^' && inClass) || (re += '\\')

        re += c
    }
  }

  if (inClass) {
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
      $2 || ($2 = '\\')

      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  clearStateChar()
  if (escaping) re += '\\\\'

  var addPatternStart = false
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(': addPatternStart = true
  }

  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n],

      nlBefore = re.slice(0, nl.reStart),
      nlFirst = re.slice(nl.reStart, nl.reEnd - 8),
      nlLast = re.slice(nl.reEnd - 8, nl.reEnd),
      nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    var openParensBefore = nlBefore.split('(').length - 1,
      cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')

    var dollar = ''
    if ((nlAfter = cleanAfter) === '' && isSub !== SUBPARSE) dollar = '$'

    re = nlBefore + nlFirst + nlAfter + dollar + nlLast
  }

  if (re !== '' && hasMagic) re = '(?=.)' + re

  if (addPatternStart) re = patternStart + re

  if (isSub === SUBPARSE) return [re, hasMagic]

  if (!hasMagic) return globUnescape(pattern)

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (_er) {
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function(pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe() {
  if (this.regexp || this.regexp === false) return this.regexp

  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options,

    twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot,
    flags = options.nocase ? 'i' : ''

  var re = set.map(function(pattern) {
    return pattern.map(function(p) {
      return p === GLOBSTAR ? twoStar : typeof p == 'string' ? regExpEscape(p) : p._src
    }).join('\\/')
  }).join('|')

  re = '^(?:' + re + ')$'

  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (_ex) {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function(list, pattern, options) {
  var mm = new Minimatch(pattern, (options = options || {}))
  list = list.filter(function(f) {
    return mm.match(f)
  })
  !mm.options.nonull || list.length || list.push(pattern)

  return list
}

Minimatch.prototype.match = match
function match(f, partial) {
  this.debug('match', f, this.pattern)
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  if (path.sep !== '/') f = f.split(path.sep).join('/')

  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  var set = this.set
  this.debug(this.pattern, 'set', set)

  var filename, i
  for (i = f.length - 1; i >= 0 && !(filename = f[i]); i--);

  for (i = 0; i < set.length; i++) {
    var pattern = set[i],
      file = f
    if (options.matchBase && pattern.length === 1) file = [filename]

    if (this.matchOne(file, pattern, partial)) return !!options.flipNegate || !this.negate
  }

  return !options.flipNegate && this.negate
}

Minimatch.prototype.matchOne = function(file, pattern, partial) {
  var options = this.options

  this.debug('matchOne', {this: this, file: file, pattern: pattern})

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
    this.debug('matchOne loop')
    var hit,
      p = pattern[pi],
      f = file[fi]

    this.debug(pattern, p, f)

    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      var fr = fi,
        pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        for (; fi < fl; fi++)
          if (file[fi] === '.' || file[fi] === '..' || (!options.dot && file[fi].charAt(0) === '.')) return false

        return true
      }

      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          return true
        }
        if (swallowee === '.' || swallowee === '..' || (!options.dot && swallowee.charAt(0) === '.')) {
          this.debug('dot detected!', file, fr, pattern, pr)
          break
        }

        this.debug('globstar swallow a segment, and continue')
        fr++
      }

      if (partial) {
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    if (typeof p == 'string') {
      hit = options.nocase ? f.toLowerCase() === p.toLowerCase() : f === p

      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  if (fi === fl && pi === pl) return true
  if (fi === fl) return partial
  if (pi === pl) return fi === fl - 1 && file[fi] === ''

  throw new Error('wtf?')
}

function globUnescape(s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape(s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}
//
},
'brace-expansion':
function(module, exports, __wpreq__) {
//
var concatMap = __wpreq__('concat-map'),
  balanced = __wpreq__('balanced-match');

module.exports = expandTop;

var escSlash = '\0SLASH' + Math.random() + '\0',
  escOpen = '\0OPEN' + Math.random() + '\0',
  escClose = '\0CLOSE' + Math.random() + '\0',
  escComma = '\0COMMA' + Math.random() + '\0',
  escPeriod = '\0PERIOD' + Math.random() + '\0';

function numeric(str) {
  return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str
    .split('\\\\').join(escSlash)
    .split('\\{').join(escOpen)
    .split('\\}').join(escClose)
    .split('\\,').join(escComma)
    .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str
    .split(escSlash).join('\\')
    .split(escOpen).join('{')
    .split(escClose).join('}')
    .split(escComma).join(',')
    .split(escPeriod).join('.');
}

function parseCommaParts(str) {
  if (!str) return [''];

  var parts = [],
    m = balanced('{', '}', str);

  if (!m) return str.split(',');

  var pre = m.pre,
    body = m.body,
    post = m.post,
    p = pre.split(',');

  p[p.length - 1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length - 1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str) return [];

  if (str.substr(0, 2) === '{}') str = '\\{\\}' + str.substr(2);

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [],

    m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var n,
    isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body),
    isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body),
    isSequence = isNumericSequence || isAlphaSequence,
    isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions)
    return m.post.match(/,.*}/) ? expand((str = m.pre + '{' + m.body + escClose + m.post)) : [str];

  if (isSequence) n = m.body.split(/\.\./);
  else if ((n = parseCommaParts(m.body)).length === 1 && (n = expand(n[0], false).map(embrace)).length === 1)
    return (post = m.post.length ? expand(m.post, false) : ['']).map(function(p) {
      return m.pre + n[0] + p;
    });

  var N,
    pre = m.pre,
    post = m.post.length ? expand(m.post, false) : [''];

  if (isSequence) {
    var x = numeric(n[0]),
      y = numeric(n[1]),
      width = Math.max(n[0].length, n[1].length),
      incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1,
      test = lte;
    if (y < x) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        if ((c = String.fromCharCode(i)) === '\\') c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            c = i < 0 ? '-' + z + c.slice(1) : z + c;
          }
        }
      }
      N.push(c);
    }
  } else
    N = concatMap(n, function(el) { return expand(el, false) });

  for (var j = 0; j < N.length; j++)
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion) expansions.push(expansion);
    }

  return expansions;
}
//
},
'concat-map':
function(module) {
//
module.exports = function(xs, fn) {
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    var x = fn(xs[i], i);
    isArray(x) ? res.push.apply(res, x) : res.push(x);
  }
  return res;
};

var isArray = Array.isArray || function(xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};
//
},
'balanced-match':
function(module) {
//
module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a),
    bi = str.indexOf(b, ai + 1),
    i = ai;

  if (ai >= 0 && bi > 0) {
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) result = [begs.pop(), bi];
      else {
        if ((beg = begs.pop()) < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) result = [left, right];
  }

  return result;
}
//
},
inherits:
function(module) {
//
module.exports = require('util').inherits;
//
},
'path-is-absolute':
function(module) {
//
function posix(path) {
  return path.charAt(0) === '/';
}

function win32(path) {
  var result = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/.exec(path),
    device = result[1] || '',
    isUnc = Boolean(device && device.charAt(1) !== ':');

  return Boolean(result[2] || isUnc);
}

module.exports = process.platform === 'win32' ? win32 : posix;
module.exports.posix = posix;
module.exports.win32 = win32;
//
},
'glob/sync':
function(module, exports, __wpreq__) {
//
module.exports = globSync
globSync.GlobSync = GlobSync

var fs = __wpreq__('fs'),
  rp = __wpreq__('fs.realpath'),
  minimatch = __wpreq__('minimatch'),
  path = __wpreq__('path'),
  assert = __wpreq__('assert'),
  isAbsolute = __wpreq__('path-is-absolute'),
  common = __wpreq__('glob/common'),
  setopts = common.setopts,
  ownProp = common.ownProp,
  childrenIgnored = common.childrenIgnored,
  isIgnored = common.isIgnored

function globSync(pattern, options) {
  if (typeof options == 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167')

  return new GlobSync(pattern, options).found
}

function GlobSync(pattern, options) {
  if (!pattern) throw new Error('must provide pattern')

  if (typeof options == 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167')

  if (!(this instanceof GlobSync)) return new GlobSync(pattern, options)

  setopts(this, pattern, options)

  if (this.noprocess) return this

  var n = this.minimatch.set.length
  this.matches = new Array(n)
  for (var i = 0; i < n; i++) this._process(this.minimatch.set[i], i, false)

  this._finish()
}

GlobSync.prototype._finish = function() {
  assert(this instanceof GlobSync)
  if (this.realpath) {
    var self = this
    this.matches.forEach(function(matchset, index) {
      var set = (self.matches[index] = Object.create(null))
      for (var p in matchset)
        try {
          p = self._makeAbs(p)
          set[rp.realpathSync(p, self.realpathCache)] = true
        } catch (er) {
          if (er.syscall !== 'stat') throw er

          set[self._makeAbs(p)] = true
        }
    })
  }
  common.finish(this)
}

GlobSync.prototype._process = function(pattern, index, inGlobStar) {
  assert(this instanceof GlobSync)

  var prefix,
    n = 0
  while (typeof pattern[n] == 'string') n++

  switch (n) {
    case pattern.length:
      this._processSimple(pattern.join('/'), index)
      return

    case 0:
      prefix = null
      break

    default:
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var read,
    remain = pattern.slice(n)

  if (prefix === null) read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    (prefix && isAbsolute(prefix)) || (prefix = '/' + prefix)
    read = prefix
  } else read = prefix

  var abs = this._makeAbs(read)

  if (childrenIgnored(this, read)) return

  remain[0] === minimatch.GLOBSTAR
    ? this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
    : this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
}

GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar)

  if (!entries) return

  var pn = remain[0],
    negate = !!this.minimatch.negate,
    rawGlob = pn._glob,
    dotOk = this.dot || rawGlob.charAt(0) === '.',

    matchedEntries = []
  for (var i = 0; i < entries.length; i++)
    ((e = entries[i]).charAt(0) !== '.' || dotOk) &&
      (negate && !prefix ? !e.match(pn) : e.match(pn)) &&
      matchedEntries.push(e)

  var len = matchedEntries.length
  if (len === 0) return

  if (remain.length === 1 && !this.mark && !this.stat) {
    this.matches[index] || (this.matches[index] = Object.create(null))

    for (i = 0; i < len; i++) {
      e = matchedEntries[i]
      if (prefix) e = prefix.slice(-1) !== '/' ? prefix + '/' + e : prefix + e

      e.charAt(0) !== '/' || this.nomount || (e = path.join(this.root, e))

      this._emitMatch(index, e)
    }
    return
  }

  remain.shift()
  for (i = 0; i < len; i++) {
    var e = matchedEntries[i],
      newPattern = prefix ? [prefix, e] : [e]
    this._process(newPattern.concat(remain), index, inGlobStar)
  }
}

GlobSync.prototype._emitMatch = function(index, e) {
  if (isIgnored(this, e)) return

  var abs = this._makeAbs(e)

  if (this.mark) e = this._mark(e)

  if (this.absolute) e = abs

  if (this.matches[index][e]) return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c)) return
  }

  this.matches[index][e] = true

  this.stat && this._stat(e)
}

GlobSync.prototype._readdirInGlobStar = function(abs) {
  if (this.follow) return this._readdir(abs, false)

  var entries, lstat
  try {
    lstat = fs.lstatSync(abs)
  } catch (er) {
    if (er.code === 'ENOENT') return null
  }

  var isSym = lstat && lstat.isSymbolicLink()
  this.symlinks[abs] = isSym

  isSym || !lstat || lstat.isDirectory() ? (entries = this._readdir(abs, false)) : (this.cache[abs] = 'FILE')

  return entries
}

GlobSync.prototype._readdir = function(abs, inGlobStar) {
  if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE') return null

    if (Array.isArray(c)) return c
  }

  try {
    return this._readdirEntries(abs, fs.readdirSync(abs))
  } catch (er) {
    this._readdirError(abs, er)
    return null
  }
}

GlobSync.prototype._readdirEntries = function(abs, entries) {
  if (!this.mark && !this.stat)
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i]
      e = abs === '/' ? abs + e : abs + '/' + e
      this.cache[e] = true
    }

  this.cache[abs] = entries

  return entries
}

GlobSync.prototype._readdirError = function(f, er) {
  switch (er.code) {
    case 'ENOTSUP':
    case 'ENOTDIR':
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        throw error
      }
      break

    case 'ENOENT':
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default:
      this.cache[this._makeAbs(f)] = false
      if (this.strict) throw er
      this.silent || console.error('glob error', er)
      break
  }
}

GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar)

  if (!entries) return

  var remainWithoutGlobStar = remain.slice(1),
    gspref = prefix ? [prefix] : [],
    noGlobStar = gspref.concat(remainWithoutGlobStar)

  this._process(noGlobStar, index, false)

  var len = entries.length

  if (this.symlinks[abs] && inGlobStar) return

  for (var i = 0; i < len; i++) {
    if (entries[i].charAt(0) === '.' && !this.dot) continue

    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true)
  }
}

GlobSync.prototype._processSimple = function(prefix, index) {
  var exists = this._stat(prefix)

  this.matches[index] || (this.matches[index] = Object.create(null))

  if (!exists) return

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') prefix = path.join(this.root, prefix)
    else {
      prefix = path.resolve(this.root, prefix)
      if (trail) prefix += '/'
    }
  }

  if (process.platform === 'win32') prefix = prefix.replace(/\\/g, '/')

  this._emitMatch(index, prefix)
}

GlobSync.prototype._stat = function(f) {
  var abs = this._makeAbs(f),
    needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength) return false

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c)) c = 'DIR'

    if (!needDir || c === 'DIR') return c

    if (needDir && c === 'FILE') return false
  }

  var stat = this.statCache[abs]
  if (!stat) {
    var lstat
    try {
      lstat = fs.lstatSync(abs)
    } catch (er) {
      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
        this.statCache[abs] = false
        return false
      }
    }

    if (lstat && lstat.isSymbolicLink())
      try {
        stat = fs.statSync(abs)
      } catch (_er) {
        stat = lstat
      }
    else stat = lstat
  }

  this.statCache[abs] = stat

  c = true
  if (stat) c = stat.isDirectory() ? 'DIR' : 'FILE'

  this.cache[abs] = this.cache[abs] || c

  return (!needDir || c !== 'FILE') && c
}

GlobSync.prototype._mark = function(p) {
  return common.mark(this, p)
}

GlobSync.prototype._makeAbs = function(f) {
  return common.makeAbs(this, f)
}
//
},
'glob/common':
function(module, exports, __wpreq__) {
//
exports.alphasort = alphasort
exports.alphasorti = alphasorti
exports.setopts = setopts
exports.ownProp = ownProp
exports.makeAbs = makeAbs
exports.finish = finish
exports.mark = mark
exports.isIgnored = isIgnored
exports.childrenIgnored = childrenIgnored

function ownProp(obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field)
}

var path = __wpreq__('path'),
  minimatch = __wpreq__('minimatch'),
  isAbsolute = __wpreq__('path-is-absolute'),
  Minimatch = minimatch.Minimatch

function alphasorti(a, b) {
  return a.toLowerCase().localeCompare(b.toLowerCase())
}

function alphasort(a, b) {
  return a.localeCompare(b)
}

function setupIgnores(self, options) {
  self.ignore = options.ignore || []

  Array.isArray(self.ignore) || (self.ignore = [self.ignore])

  if (self.ignore.length) self.ignore = self.ignore.map(ignoreMap)
}

function ignoreMap(pattern) {
  var gmatcher = null
  if (pattern.slice(-3) === '/**') {
    var gpattern = pattern.replace(/(\/\*\*)+$/, '')
    gmatcher = new Minimatch(gpattern, {dot: true})
  }

  return {matcher: new Minimatch(pattern, {dot: true}), gmatcher: gmatcher}
}

function setopts(self, pattern, options) {
  options || (options = {})

  if (options.matchBase && pattern.indexOf("/") < 0) {
    if (options.noglobstar) throw new Error("base matching requires globstar")

    pattern = "**/" + pattern
  }

  self.silent = !!options.silent
  self.pattern = pattern
  self.strict = options.strict !== false
  self.realpath = !!options.realpath
  self.realpathCache = options.realpathCache || Object.create(null)
  self.follow = !!options.follow
  self.dot = !!options.dot
  self.mark = !!options.mark
  self.nodir = !!options.nodir
  if (self.nodir) self.mark = true
  self.sync = !!options.sync
  self.nounique = !!options.nounique
  self.nonull = !!options.nonull
  self.nosort = !!options.nosort
  self.nocase = !!options.nocase
  self.stat = !!options.stat
  self.noprocess = !!options.noprocess
  self.absolute = !!options.absolute

  self.maxLength = options.maxLength || Infinity
  self.cache = options.cache || Object.create(null)
  self.statCache = options.statCache || Object.create(null)
  self.symlinks = options.symlinks || Object.create(null)

  setupIgnores(self, options)

  self.changedCwd = false
  var cwd = process.cwd()
  if (ownProp(options, "cwd")) {
    self.cwd = path.resolve(options.cwd)
    self.changedCwd = self.cwd !== cwd
  } else self.cwd = cwd

  self.root = options.root || path.resolve(self.cwd, "/")
  self.root = path.resolve(self.root)
  if (process.platform === "win32") self.root = self.root.replace(/\\/g, "/")

  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)
  if (process.platform === "win32") self.cwdAbs = self.cwdAbs.replace(/\\/g, "/")
  self.nomount = !!options.nomount

  options.nonegate = true
  options.nocomment = true

  self.minimatch = new Minimatch(pattern, options)
  self.options = self.minimatch.options
}

function finish(self) {
  var nou = self.nounique,
    all = nou ? [] : Object.create(null)

  for (var i = 0, l = self.matches.length; i < l; i++) {
    var matches = self.matches[i]
    if (matches && Object.keys(matches).length > 0) {
      var m = Object.keys(matches)
      nou
        ? all.push.apply(all, m)
        : m.forEach(function(m) {
            all[m] = true
          })
    } else if (self.nonull) {
      var literal = self.minimatch.globSet[i]
      nou ? all.push(literal) : (all[literal] = true)
    }
  }

  nou || (all = Object.keys(all))

  self.nosort || (all = all.sort(self.nocase ? alphasorti : alphasort))

  if (self.mark) {
    for (i = 0; i < all.length; i++) all[i] = self._mark(all[i])

    if (self.nodir)
      all = all.filter(function(e) {
        var notDir = !/\/$/.test(e),
          c = self.cache[e] || self.cache[makeAbs(self, e)]
        if (notDir && c) notDir = c !== 'DIR' && !Array.isArray(c)
        return notDir
      })
  }

  if (self.ignore.length)
    all = all.filter(function(m) {
      return !isIgnored(self, m)
    })

  self.found = all
}

function mark(self, p) {
  var abs = makeAbs(self, p),
    c = self.cache[abs],
    m = p
  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c),
      slash = p.slice(-1) === '/'

    if (isDir && !slash) m += '/'
    else if (!isDir && slash) m = m.slice(0, -1)

    if (m !== p) {
      var mabs = makeAbs(self, m)
      self.statCache[mabs] = self.statCache[abs]
      self.cache[mabs] = self.cache[abs]
    }
  }

  return m
}

function makeAbs(self, f) {
  var abs = // f
    f.charAt(0) === '/'
      ? path.join(self.root, f)
      : isAbsolute(f) || f === ''
      ? f
      : self.changedCwd
      ? path.resolve(self.cwd, f)
      : path.resolve(f)

  if (process.platform === 'win32') abs = abs.replace(/\\/g, '/')

  return abs
}

function isIgnored(self, path) {
  return (
    !!self.ignore.length &&
    self.ignore.some(function(item) {
      return item.matcher.match(path) || !(!item.gmatcher || !item.gmatcher.match(path))
    })
  )
}

function childrenIgnored(self, path) {
  return (
    !!self.ignore.length &&
    self.ignore.some(function(item) {
      return !(!item.gmatcher || !item.gmatcher.match(path))
    })
  )
}
//
},
inflight:
function(module, exports, __wpreq__) {
//
var wrappy = __wpreq__('wrappy'),
  reqs = Object.create(null),
  once = __wpreq__('once')

module.exports = wrappy(inflight)

function inflight(key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb)
    return null
  }

  reqs[key] = [cb]
  return makeres(key)
}

function makeres(key) {
  return once(function RES() {
    var cbs = reqs[key],
      len = cbs.length,
      args = slice(arguments)

    try {
      for (var i = 0; i < len; i++) cbs[i].apply(null, args)
    } finally {
      if (cbs.length > len) {
        cbs.splice(0, len)
        process.nextTick(function() {
          RES.apply(null, args)
        })
      } else delete reqs[key]
    }
  })
}

function slice(args) {
  var length = args.length,
    array = new Array(length)

  for (var i = 0; i < length; i++) array[i] = args[i]
  return array
}
//
},
wrappy:
function(module) {
//
module.exports = wrappy
function wrappy(fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn != 'function') throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function(k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) args[i] = arguments[i]

    var ret = fn.apply(this, args),
      cb = args[args.length - 1]
    typeof ret != 'function' || ret === cb ||
      Object.keys(cb).forEach(function(k) {
        ret[k] = cb[k]
      })

    return ret
  }
}
//
},
once:
function(module, exports, __wpreq__) {
//
var wrappy = __wpreq__('wrappy')
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function() {
  Object.defineProperty(Function.prototype, 'once', {
    value: function() {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function() {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once(fn) {
  var f = function() {
    if (f.called) return f.value
    f.called = true
    return (f.value = fn.apply(this, arguments))
  }
  f.called = false
  return f
}

function onceStrict(fn) {
  var f = function() {
    if (f.called) throw new Error(f.onceError)
    f.called = true
    return (f.value = fn.apply(this, arguments))
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}
//
},
micromatch:
function(module, exports, __wpreq__) {
//
var expand = __wpreq__('micromatch/lib/expand'),
  utils = __wpreq__('micromatch/lib/utils');

function micromatch(files, patterns, opts) {
  if (!files || !patterns) return [];

  if ((opts = opts || {}).cache === void 0) opts.cache = true;

  if (!Array.isArray(patterns)) return match(files, patterns, opts);

  var omit = [], keep = [];

  for (var len = patterns.length, i = 0; len--; ) {
    var glob = patterns[i++];
    typeof glob == 'string' && glob.charCodeAt(0) === 33
      ? omit.push.apply(omit, match(files, glob.slice(1), opts))
      : keep.push.apply(keep, match(files, glob, opts));
  }
  return utils.diff(keep, omit);
}

function match(files, pattern, opts) {
  if (typeof files != 'string' && !Array.isArray(files)) throw new Error(msg('match', 'files', 'a string or array'));

  files = utils.arrayify(files);

  var negate = (opts = opts || {}).negate || false,
    orig = pattern;

  if (typeof pattern == 'string') {
    if ((negate = pattern.charAt(0) === '!')) pattern = pattern.slice(1);

    if (opts.nonegate === true) negate = false;
  }

  var res = [];

  for (var _isMatch = matcher(pattern, opts), len = files.length, i = 0; i < len; ) {
    var file = files[i++],
      fp = utils.unixify(file, opts);

    _isMatch(fp) && res.push(fp);
  }

  if (res.length === 0) {
    if (opts.failglob === true) throw new Error('micromatch.match() found no matches for: "' + orig + '".');

    if (opts.nonull || opts.nullglob) res.push(utils.unescapeGlob(orig));
  }

  if (negate) res = utils.diff(files, res);

  if (opts.ignore && opts.ignore.length) {
    pattern = opts.ignore;
    opts = utils.omit(opts, ['ignore']);
    res = utils.diff(res, micromatch(res, pattern, opts));
  }

  return opts.nodupes ? utils.unique(res) : res;
}

function filter(patterns, opts) {
  if (!Array.isArray(patterns) && typeof patterns != 'string')
    throw new TypeError(msg('filter', 'patterns', 'a string or array'));

  var len = (patterns = utils.arrayify(patterns)).length,
    patternMatchers = Array(len);
  for (var i = 0; i < len; ) patternMatchers[i] = matcher(patterns[i++], opts);

  return function(fp) {
    if (fp == null) return [];
    var len = patternMatchers.length, i = 0,
      res = true;

    fp = utils.unixify(fp, opts);
    while (i < len)
      if (!(0, patternMatchers[i++])(fp)) {
        res = false;
        break;
      }

    return res;
  };
}

function isMatch(fp, pattern, opts) {
  if (typeof fp != 'string') throw new TypeError(msg('isMatch', 'filepath', 'a string'));

  fp = utils.unixify(fp, opts);
  return typeof pattern == 'object' && utils.toStr(pattern) === '[object Object]'
    ? matcher(fp, pattern)
    : matcher(pattern, opts)(fp);
}

function contains(fp, pattern, opts) {
  if (typeof fp != 'string') throw new TypeError(msg('contains', 'pattern', 'a string'));

  (opts = opts || {}).contains = pattern !== '';
  fp = utils.unixify(fp, opts);

  return opts.contains && !utils.isGlob(pattern) ? fp.indexOf(pattern) > -1 : matcher(pattern, opts)(fp);
}

function any(fp, patterns, opts) {
  if (!Array.isArray(patterns) && typeof patterns != 'string')
    throw new TypeError(msg('any', 'patterns', 'a string or array'));

  var len = (patterns = utils.arrayify(patterns)).length;

  fp = utils.unixify(fp, opts);
  while (len--) if (matcher(patterns[len], opts)(fp)) return true;

  return false;
}

function matchKeys(obj, glob, options) {
  if (obj == null || typeof obj != 'object') throw new TypeError(msg('matchKeys', 'first argument', 'an object'));

  var fn = matcher(glob, options),
    res = {};

  for (var key in obj) if (obj.hasOwnProperty(key) && fn(key)) res[key] = obj[key];

  return res;
}

function matcher(pattern, opts) {
  if (typeof pattern == 'function') return pattern;
  if (pattern instanceof RegExp)
    return function(fp) {
      return pattern.test(fp);
    };

  if (typeof pattern != 'string') throw new TypeError(msg('matcher', 'pattern', 'a string, regex, or function'));

  pattern = utils.unixify(pattern, opts);

  if (!utils.isGlob(pattern)) return utils.matchPath(pattern, opts);
  var re = makeRe(pattern, opts);

  return opts && opts.matchBase
    ? utils.hasFilename(re, opts)
    : function(fp) {
        fp = utils.unixify(fp, opts);
        return re.test(fp);
      };
}

function toRegex(glob, options) {
  var opts = Object.create(options || {}),
    flags = opts.flags || '';
  if (opts.nocase && flags.indexOf('i') < 0) flags += 'i';

  var parsed = expand(glob, opts);

  opts.negated = opts.negated || parsed.negated;
  opts.negate = opts.negated;
  glob = wrapGlob(parsed.pattern, opts);

  try {
    return new RegExp(glob, flags);
  } catch (err) {
    err.reason = 'micromatch invalid regex: (' + glob + ')';
    if (opts.strict) throw new SyntaxError(err);
  }

  // noinspection RegExpUnexpectedAnchor
  return /$^/;
}

function wrapGlob(glob, opts) {
  var prefix = opts && !opts.contains ? '^' : '';
  glob = '(?:' + glob + ')' + (opts && !opts.contains ? '$' : '');
  return opts && opts.negate ? prefix + '(?!^' + glob + ').*$' : prefix + glob;
}

function makeRe(glob, opts) {
  if (typeof glob != 'string') throw new Error(msg('makeRe', 'glob', 'a string'));

  return utils.cache(toRegex, glob, opts);
}

function msg(method, what, type) {
  return 'micromatch.' + method + '(): ' + what + ' should be ' + type + '.';
}

micromatch.any = any;
micromatch.braces = micromatch.braceExpand = utils.braces;
micromatch.contains = contains;
micromatch.expand = expand;
micromatch.filter = filter;
micromatch.isMatch = isMatch;
micromatch.makeRe = makeRe;
micromatch.match = match;
micromatch.matcher = matcher;
micromatch.matchKeys = matchKeys;

module.exports = micromatch;
//
},
'micromatch/lib/expand':
function(module, exports, __wpreq__) {
//
var utils = __wpreq__('micromatch/lib/utils'),
  Glob = __wpreq__('micromatch/lib/glob');

module.exports = expand;

function expand(pattern, options) {
  if (typeof pattern != 'string') throw new TypeError('micromatch.expand(): argument should be a string.');

  var glob = new Glob(pattern, options || {}),
    opts = glob.options;

  if (!utils.isGlob(pattern)) {
    glob.pattern = glob.pattern.replace(/([\/.])/g, '\\$1');
    return glob;
  }

  glob.pattern = glob.pattern.replace(/(\+)(?!\()/g, '\\$1');
  glob.pattern = glob.pattern.split('$').join('\\$');

  if (typeof opts.braces != 'boolean' && typeof opts.nobraces != 'boolean') opts.braces = true;

  if (glob.pattern === '.*') return {pattern: '\\.' + star, tokens: tok, options: opts};

  if (glob.pattern === '*') return {pattern: oneStar(opts.dot), tokens: tok, options: opts};

  glob.parse();
  var tok = glob.tokens;
  tok.is.negated = opts.negated;

  if ((opts.dotfiles === true || tok.is.dotfile) && opts.dot !== false) {
    opts.dotfiles = true;
    opts.dot = true;
  }

  if ((opts.dotdirs === true || tok.is.dotdir) && opts.dot !== false) {
    opts.dotdirs = true;
    opts.dot = true;
  }

  if (/[{,]\./.test(glob.pattern)) {
    opts.makeRe = false;
    opts.dot = true;
  }

  if (opts.nonegate !== true) opts.negated = glob.negated;

  if (glob.pattern.charAt(0) === '.' && glob.pattern.charAt(1) !== '/') glob.pattern = '\\' + glob.pattern;

  glob.track('before braces');
  tok.is.braces && glob.braces();
  glob.track('after braces');

  glob.track('before extglob');
  tok.is.extglob && glob.extglob();
  glob.track('after extglob');

  glob.track('before brackets');
  tok.is.brackets && glob.brackets();
  glob.track('after brackets');

  glob._replace('[!', '[^');
  glob._replace('(?', '(%~');
  glob._replace(/\[]/, '\\[\\]');
  glob._replace('/[', '/' + (opts.dot ? dotfiles : nodot) + '[', true);
  glob._replace('/?', '/' + (opts.dot ? dotfiles : nodot) + '[^/]', true);
  glob._replace('/.', '/(?=.)\\.', true);

  glob._replace(/^(\w):([\\\/]+?)/gi, '(?=.)$1:$2', true);

  if (glob.pattern.indexOf('[^') > -1) glob.pattern = negateSlash(glob.pattern);

  if (opts.globstar !== false && glob.pattern === '**') glob.pattern = globstar(opts.dot);
  else {
    glob.pattern = balance(glob.pattern, '[', ']');
    glob.escape(glob.pattern);

    if (tok.is.globstar) {
      glob.pattern = collapse(glob.pattern, '/**');
      glob.pattern = collapse(glob.pattern, '**/');
      glob._replace('/**/', '(?:/' + globstar(opts.dot) + '/|/)', true);
      glob._replace(/\*{2,}/g, '**');

      glob._replace(/(\w+)\*(?!\/)/g, '$1[^/]*?', true);
      glob._replace(/\*\*\/\*(\w)/g, globstar(opts.dot) + '\\/' + (opts.dot ? dotfiles : nodot) + '[^/]*?$1', true);

      opts.dot === true || glob._replace(/\*\*\/(.)/g, '(?:**\\/|)$1');

      if (tok.path.dirname !== '' || /,\*\*|\*\*,/.test(glob.orig)) glob._replace('**', globstar(opts.dot), true);
    }

    glob._replace(/\/\*$/, '\\/' + oneStar(opts.dot), true);
    glob._replace(/(?!\/)\*$/, star, true);
    glob._replace(/([^\/]+)\*/, '$1' + oneStar(true), true);
    glob._replace('*', oneStar(opts.dot), true);
    glob._replace('?.', '?\\.', true);
    glob._replace('?:', '?:', true);

    glob._replace(/\?+/g, function(match) {
      var len = match.length;
      return len === 1 ? qmark : qmark + '{' + len + '}';
    });

    glob._replace(/\.([*\w]+)/g, '\\.$1');
    glob._replace(/\[\^[\\\/]+]/g, qmark);
    glob._replace(/\/+/g, '\\/');
    glob._replace(/\\{2,}/g, '\\');
  }

  glob.unescape(glob.pattern);
  glob._replace('__UNESC_STAR__', '*');

  glob._replace('?.', '?\\.');

  glob._replace('[^\\/]', qmark);

  if (glob.pattern.length > 1 && /^[\[?*]/.test(glob.pattern))
    glob.pattern = (opts.dot ? dotfiles : nodot) + glob.pattern;

  return glob;
}

function collapse(str, ch) {
  var res = str.split(ch),
    isFirst = res[0] === '',
    isLast = res[res.length - 1] === '';
  res = res.filter(Boolean);
  isFirst && res.unshift('');
  isLast && res.push('');
  return res.join(ch);
}

function negateSlash(str) {
  return str.replace(/\[\^([^\]]*?)]/g, function(match, inner) {
    if (inner.indexOf('/') < 0) inner = '\\/' + inner;

    return '[^' + inner + ']';
  });
}

function balance(str, a, b) {
  var aarr = str.split(a);

  return aarr.join('').length !== str.split(b).join('').length
    ? (str = aarr.join('\\' + a)).split(b).join('\\' + b)
    : str;
}

var qmark = '[^/]',
  star = qmark + '*?',
  nodot = '(?!\\.)(?=.)',
  dotfileGlob = '(?:\\/|^)\\.{1,2}($|\\/)',
  dotfiles = '(?!' + dotfileGlob + ')(?=.)',
  twoStarDot = '(?:(?!' + dotfileGlob + ').)*?';

function oneStar(dotfile) {
  return dotfile ? '(?!' + dotfileGlob + ')(?=.)' + star : nodot + star;
}

function globstar(dotfile) {
  return dotfile ? twoStarDot : '(?:(?!(?:\\/|^)\\.).)*?';
}
//
},
'micromatch/lib/utils':
function(module, exports, __wpreq__) {
//
var win32 = process && process.platform === 'win32',
  path = __wpreq__('path'),
  fileRe = __wpreq__('filename-regex'),
  utils = module.exports;

utils.diff = __wpreq__('arr-diff');
utils.unique = __wpreq__('array-unique');
utils.braces = __wpreq__('braces');
utils.brackets = __wpreq__('expand-brackets');
utils.extglob = __wpreq__('extglob');
utils.isExtglob = __wpreq__('is-extglob');
utils.isGlob = __wpreq__('is-glob');
utils.toStr = Function.call.bind(Object.prototype.toString);
utils.normalize = __wpreq__('normalize-path');
utils.omit = __wpreq__('object.omit');
utils.parseGlob = __wpreq__('parse-glob');
utils.cache = __wpreq__('regex-cache');

utils.filename = function(fp) {
  var seg = fp.match(fileRe());
  return seg && seg[0];
};

utils.isPath = function(pattern, opts) {
  opts = opts || {};
  return function(fp) {
    var unixified = utils.unixify(fp, opts);
    return opts.nocase ? pattern.toLowerCase() === unixified.toLowerCase() : pattern === unixified;
  };
};

utils.hasPath = function(pattern, opts) {
  return function(fp) {
    return utils.unixify(pattern, opts).indexOf(fp) > -1;
  };
};

utils.matchPath = function(pattern, opts) {
  return opts && opts.contains ? utils.hasPath(pattern, opts) : utils.isPath(pattern, opts);
};

utils.hasFilename = function(re) {
  return function(fp) {
    var name = utils.filename(fp);
    return name && re.test(name);
  };
};

utils.arrayify = function(val) {
  return Array.isArray(val) ? val : [val];
};

utils.unixify = function(fp, opts) {
  return opts && opts.unixify === false
    ? fp
    : (opts && opts.unixify === true) || win32 || path.sep === '\\'
    ? utils.normalize(fp, false)
    : opts && opts.unescape === true
    ? (fp ? fp.toString().replace(/\\(\w)/g, '$1') : '')
    : fp;
};

utils.escapePath = function(fp) {
  return fp.replace(/[\\.]/g, '\\$&');
};

utils.unescapeGlob = function(fp) {
  return fp.replace(/[\\"']/g, '');
};

utils.escapeRe = function(str) {
  return str.replace(/[-[\\$*+?.#^\s{}(|)\]]/g, '\\$&');
};

module.exports = utils;
//
},
'filename-regex':
function(module) {
//
module.exports = function() {
  return /([^\\\/]+)$/;
};
//
},
'arr-diff':
function(module, exports, __wpreq__) {
//
var flatten = __wpreq__('arr-flatten'),
  slice = [].slice;

function diff(arr, arrays) {
  var argsLen = arguments.length,
    len = arr.length, i = -1,
    res = [];

  if (argsLen === 1) return arr;

  if (argsLen > 2) arrays = flatten(slice.call(arguments, 1));

  while (++i < len) ~arrays.indexOf(arr[i]) || res.push(arr[i]);

  return res;
}

module.exports = diff;
//
},
'arr-flatten':
function(module) {
//
module.exports = function(arr) {
  return flat(arr, []);
};

function flat(arr, res) {
  for (var cur, i = 0, len = arr.length; i < len; i++) {
    cur = arr[i];
    Array.isArray(cur) ? flat(cur, res) : res.push(cur);
  }
  return res;
}
//
},
'array-unique':
function(module) {
//
module.exports = function(arr) {
  if (!Array.isArray(arr)) throw new TypeError('array-unique expects an array.');

  for (var len = arr.length, i = -1; i++ < len; )
    for (var j = i + 1; j < arr.length; ++j) arr[i] !== arr[j] || arr.splice(j--, 1);

  return arr;
};
//
},
braces:
function(module, exports, __wpreq__) {
//
var expand = __wpreq__('expand-range'),
  repeat = __wpreq__('repeat-element'),
  tokens = __wpreq__('preserve');

module.exports = function(str, options) {
  if (typeof str != 'string') throw new Error('braces expects a string');

  return braces(str, options);
};

function braces(str, arr, options) {
  if (str === '') return [];

  if (!Array.isArray(arr)) {
    options = arr;
    arr = [];
  }

  var opts = options || {};
  arr = arr || [];

  if (opts.nodupes === void 0) opts.nodupes = true;

  var es6,
    fn = opts.fn;

  if (typeof opts == 'function') {
    fn = opts;
    opts = {};
  }

  patternRe instanceof RegExp || (patternRe = patternRegex());

  switch ((str.match(patternRe) || [])[0]) {
    case '\\,':
      return escapeCommas(str, arr, opts);
    case '\\.':
      return escapeDots(str, arr, opts);
    case '/.':
      return escapePaths(str, arr, opts);
    case ' ':
      return splitWhitespace(str);
    case '{,}':
      return exponential(str, opts, braces);
    case '{}':
      return emptyBraces(str, arr, opts);
    case '\\{':
    case '\\}':
      return escapeBraces(str, arr, opts);
    case '${':
      if (!/{[^{]+{/.test(str)) return arr.concat(str);

      es6 = true;
      str = tokens.before(str, es6Regex());
  }

  braceRe instanceof RegExp || (braceRe = braceRegex());

  var match = braceRe.exec(str);
  if (match == null) return [str];

  var outer = match[1],
    inner = match[2];
  if (inner === '') return [str];

  var segs, segsLength;

  if (inner.indexOf('..') > -1) segsLength = (segs = expand(inner, opts, fn) || inner.split(',')).length;
  else {
    if (inner[0] === '"' || inner[0] === "'") return arr.concat(str.split(/['"]/).join(''));

    segs = inner.split(',');
    if (opts.makeRe) return braces(str.replace(outer, wrap(segs, '|')), opts);

    if ((segsLength = segs.length) === 1 && opts.bash) segs[0] = wrap(segs[0], '\\');
  }

  for (var val, len = segs.length, i = 0; len--; ) {
    var path = segs[i++];

    if (/(\.[^.\/])/.test(path)) return segsLength > 1 ? segs : [str];

    val = splice(str, outer, path);

    if (/{[^{}]+?}/.test(val)) arr = braces(val, arr, opts);
    else if (val !== '') {
      if (opts.nodupes && arr.indexOf(val) > -1) continue;
      arr.push(es6 ? tokens.after(val) : val);
    }
  }

  return opts.strict ? filter(arr, filterEmpty) : arr;
}

function exponential(str, options, fn) {
  if (typeof options == 'function') {
    fn = options;
    options = null;
  }

  var res,
    opts = options || {},
    esc = '__ESC_EXP__',
    exp = 0,

    parts = str.split('{,}');
  if (opts.nodupes) return fn(parts.join(''), opts);

  exp = parts.length - 1;
  res = fn(parts.join(esc), opts);
  var arr = [];

  for (var len = res.length, i = 0; len--; ) {
    var ele = res[i++];

    if (ele.indexOf(esc) < 0) arr.push(ele);
    else if ((ele = ele.split('__ESC_EXP__').join('')) && opts.nodupes !== false) arr.push(ele);
    else {
      var num = Math.pow(2, exp);
      arr.push.apply(arr, repeat(ele, num));
    }
  }
  return arr;
}

function wrap(val, ch) {
  return ch === '|'
    ? '(' + val.join(ch) + ')'
    : ch === ','
    ? '{' + val.join(ch) + '}'
    : ch === '-'
    ? '[' + val.join(ch) + ']'
    : ch === '\\'
    ? '\\{' + val + '\\}'
    : void 0;
}

function emptyBraces(str, arr, opts) {
  return braces(str.split('{}').join('\\{\\}'), arr, opts);
}

function filterEmpty(ele) {
  return !!ele && ele !== '\\';
}

function splitWhitespace(str) {
  var res = [];

  for (var segs = str.split(' '), len = segs.length, i = 0; len--; ) res.push.apply(res, braces(segs[i++]));

  return res;
}

function escapeBraces(str, arr, opts) {
  if (!/{[^{]+{/.test(str)) return arr.concat(str.split('\\').join(''));

  str = (str = str.split('\\{').join('__LT_BRACE__')).split('\\}').join('__RT_BRACE__');
  return map(braces(str, arr, opts), function(ele) {
    return (ele = ele.split('__LT_BRACE__').join('{')).split('__RT_BRACE__').join('}');
  });
}

function escapeDots(str, arr, opts) {
  return /[^\\]\..+\\\./.test(str)
    ? map(braces((str = str.split('\\.').join('__ESC_DOT__')), arr, opts), function(ele) {
        return ele.split('__ESC_DOT__').join('.');
      })
    : arr.concat(str.split('\\').join(''));
}

function escapePaths(str, arr, opts) {
  return map(braces((str = str.split('/.').join('__ESC_PATH__')), arr, opts), function(ele) {
    return ele.split('__ESC_PATH__').join('/.');
  });
}

function escapeCommas(str, arr, opts) {
  return /\w,/.test(str)
    ? map(braces((str = str.split('\\,').join('__ESC_COMMA__')), arr, opts), function(ele) {
        return ele.split('__ESC_COMMA__').join(',');
      })
    : arr.concat(str.split('\\').join(''));
}

function patternRegex() {
  return /\${|( (?=[{,}])|(?=[{,}]) )|{}|{,}|\\,(?=.*[{}])|\/\.(?=.*[{}])|\\\.(?={)|\\{|\\}/;
}

function braceRegex() {
  return /.*(\\?{([^}]+)})/;
}

function es6Regex() {
  return /\${([^}]+)}/;
}

var braceRe, patternRe;

function splice(str, token, replacement) {
  var i = str.indexOf(token);
  return str.substr(0, i) + replacement + str.substr(i + token.length);
}

function map(arr, fn) {
  if (arr == null) return [];

  var len = arr.length,
    res = new Array(len);

  for (var i = -1; ++i < len; ) res[i] = fn(arr[i], i, arr);

  return res;
}

function filter(arr, cb) {
  if (arr == null) return [];
  if (typeof cb != 'function') throw new TypeError('braces: filter expects a callback function.');

  var len = arr.length,
    res = arr.slice();

  for (var i = 0; len--; ) cb(arr[len], i++) || res.splice(len, 1);

  return res;
}
//
},
'expand-range':
function(module, exports, __wpreq__) {
//
var fill = __wpreq__('fill-range');

module.exports = function(str, options, fn) {
  if (typeof str != 'string') throw new TypeError('expand-range expects a string.');

  if (typeof options == 'function') {
    fn = options;
    options = {};
  }

  if (typeof options == 'boolean') (options = {}).makeRe = true;

  var opts = options || {},
    args = str.split('..'),
    len = args.length;
  if (len > 3) return str;

  if (len === 1) return args;

  if (typeof fn == 'boolean' && fn === true) opts.makeRe = true;

  args.push(opts);
  return fill.apply(null, args.concat(fn));
};
//
},
'fill-range':
function(module, exports, __wpreq__) {
//
var isObject = __wpreq__('isobject'),
  isNumber = __wpreq__('is-number'),
  randomize = __wpreq__('randomatic'),
  repeatStr = Function.call.bind(String.prototype.repeat),
  repeat = __wpreq__('repeat-element');

module.exports = fillRange;

function fillRange(a, b, step, options, fn) {
  if (a == null || b == null) throw new Error('fill-range expects the first and second args to be strings.');

  if (typeof step == 'function') {
    fn = step; options = {}; step = null;
  }

  if (typeof options == 'function') {
    fn = options; options = {};
  }

  if (isObject(step)) {
    options = step; step = '';
  }

  var expand, regex = false, sep = '',
    opts = options || {};

  if (opts.silent === void 0) opts.silent = true;

  step = step || opts.step;

  var origA = a, origB = b;

  b = b.toString() === '-0' ? 0 : b;

  if (opts.optimize || opts.makeRe) {
    step = step ? (step += '~') : step;
    expand = true;
    regex = true;
    sep = '~';
  }

  if (typeof step == 'string') {
    var match = stepRe().exec(step);

    if (match) {
      var i = match.index,
        m = match[0];

      if (m === '+') return repeat(a, b);
      if (m === '?') return [randomize(a, b)];
      if (m === '>') {
        step = step.substr(0, i) + step.substr(i + 1);
        expand = true;
      } else if (m === '|') {
        step = step.substr(0, i) + step.substr(i + 1);
        expand = true;
        regex = true;
        sep = m;
      } else if (m === '~') {
        step = step.substr(0, i) + step.substr(i + 1);
        expand = true;
        regex = true;
        sep = m;
      }
    } else if (!isNumber(step)) {
      if (!opts.silent) throw new TypeError('fill-range: invalid step.');

      return null;
    }
  }

  if (/[.&*()[\]^%$#@!]/.test(a) || /[.&*()[\]^%$#@!]/.test(b)) {
    if (!opts.silent) throw new RangeError('fill-range: invalid range arguments.');

    return null;
  }

  if (!noAlphaNum(a) || !noAlphaNum(b) || hasBoth(a) || hasBoth(b)) {
    if (!opts.silent) throw new RangeError('fill-range: invalid range arguments.');

    return null;
  }

  var isNumA = isNumber(zeros(a)),
    isNumB = isNumber(zeros(b));

  if ((!isNumA && isNumB) || (isNumA && !isNumB)) {
    if (!opts.silent) throw new TypeError('fill-range: first range argument is incompatible with second.');

    return null;
  }

  var isNum = isNumA,
    num = formatStep(step);

  if (isNum) {
    a = +a; b = +b;
  } else {
    a = a.charCodeAt(0);
    b = b.charCodeAt(0);
  }

  var isDescending = a > b;

  if (a < 0 || b < 0) {
    expand = false;
    regex = false;
  }

  var res, pad,
    padding = isPadded(origA, origB),
    arr = [],
    ii = 0;

  if (regex && shouldExpand(a, b, num, isNum, padding, opts)) {
    if (sep === '|' || sep === '~') sep = detectSeparator(a, b, num, isNum, isDescending);

    return wrap([origA, origB], sep, opts);
  }

  while (isDescending ? a >= b : a <= b) {
    if (padding && isNum) pad = padding(a);

    (res =
      typeof fn == 'function'
      ? fn.call(null, a, isNum, pad, ii++)
      : isNum
      ? formatPadding(a, pad)
      : regex && isInvalidChar(a)
      ? null
      : String.fromCharCode(a)) === null || arr.push(res);

    isDescending ? (a -= num) : (a += num);
  }

  if ((regex || expand) && !opts.noexpand) {
    if (sep === '|' || sep === '~') sep = detectSeparator(a, b, num, isNum, isDescending);

    return arr.length === 1 || a < 0 || b < 0 ? arr : wrap(arr, sep, opts);
  }

  return arr;
}

function wrap(arr, sep, opts) {
  if (sep === '~') sep = '-';
  var str = arr.join(sep),
    pre = opts && opts.regexPrefix;

  if (sep === '|') str = '(' + (str = pre ? pre + str : str) + ')';

  if (sep === '-') str = '[' + (str = pre && pre === '^' ? pre + str : str) + ']';

  return [str];
}

function isCharClass(a, b, step, isNum, isDescending) {
  return !isDescending && (isNum ? a <= 9 && b <= 9 : a < b && step === 1);
}

function shouldExpand(a, b, num, isNum, padding, opts) {
  return (!isNum || !(a > 9 || b > 9)) && !padding && num === 1 && a < b;
}

function detectSeparator(a, b, step, isNum, isDescending) {
  return isCharClass(a, b, step, isNum, isDescending) ? '~' : '|';
}

function formatStep(step) {
  return Math.abs(step >> 0) || 1;
}

function formatPadding(ch, pad) {
  var res = pad ? pad + ch : ch;
  if (pad && ch.toString().charAt(0) === '-') res = '-' + pad + ch.toString().substr(1);

  return res.toString();
}

function isInvalidChar(str) {
  var ch = toStr(str);
  return ch === '\\' || ch === '[' || ch === ']' || ch === '^' || ch === '(' || ch === ')' || ch === '`';
}

function toStr(ch) {
  return String.fromCharCode(ch);
}

function stepRe() {
  return /[?>|+~]/g;
}

function noAlphaNum(val) {
  return /[a-z0-9]/i.test(val);
}

function hasBoth(val) {
  return /[a-z][0-9]|[0-9][a-z]/i.test(val);
}

function zeros(val) {
  return /^-*0+$/.test(val.toString()) ? '0' : val;
}

function hasZeros(val) {
  return /[^.]\.|^-*0+[0-9]/.test(val);
}

function isPadded(origA, origB) {
  if (hasZeros(origA) || hasZeros(origB)) {
    var alen = length(origA),
      blen = length(origB),

      len = alen >= blen ? alen : blen;

    return function(a) {
      return repeatStr('0', len - length(a));
    };
  }
  return false;
}

function length(val) {
  return val.toString().length;
}
//
},
isobject:
function(module, exports, __wpreq__) {
//
var isArray = __wpreq__('isarray');

module.exports = function(val) {
  return val != null && typeof val == 'object' && isArray(val) === false;
};
//
},
isarray:
function(module) {
//
var toString = {}.toString;

module.exports = Array.isArray || function(arr) {
  return toString.call(arr) == '[object Array]';
};
//
},
'is-number':
function(module) {
//
module.exports = function(num) {
  var type = typeof num;

  if (type === 'string' || num instanceof String) {
    if (!num.trim()) return false;
  } else if (type !== 'number' && !(num instanceof Number)) return false;

  return num - num + 1 >= 0;
};
//
},
randomatic:
function(module, exports, __wpreq__) {
//
var isNumber = __wpreq__('is-number'),
  mathRandom = __wpreq__('math-random');

module.exports = randomatic;
module.exports.isCrypto = !!mathRandom.cryptographic;

var type = {
  lower: 'abcdefghijklmnopqrstuvwxyz',
  upper: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
  number: '0123456789',
  special: "~!@#$%^&()_+-={}[];',."
};

type.all = type.lower + type.upper + type.number + type.special;

function randomatic(pattern, length, options) {
  if (pattern === void 0) throw new Error('randomatic expects a string or number.');

  var custom = false;
  if (arguments.length === 1)
    if (typeof pattern == 'string') length = pattern.length;
    else if (isNumber(pattern)) {
      options = {};
      length = pattern;
      pattern = '*';
    }

  if (length != null && typeof length == 'object' && length.hasOwnProperty('chars')) {
    length = (pattern = (options = length).chars).length;
    custom = true;
  }

  var opts = options || {},
    mask = '',
    res = '';

  if (pattern.indexOf('?') > -1) mask += opts.chars;
  if (pattern.indexOf('a') > -1) mask += type.lower;
  if (pattern.indexOf('A') > -1) mask += type.upper;
  if (pattern.indexOf('0') > -1) mask += type.number;
  if (pattern.indexOf('!') > -1) mask += type.special;
  if (pattern.indexOf('*') > -1) mask += type.all;
  if (custom) mask += pattern;

  while (length--) res += mask.charAt(parseInt(mathRandom() * mask.length, 10));

  return res;
}
//
},
'math-random':
function(module, exports, __wpreq__) {
//
var crypto = __wpreq__('crypto'),
  max = Math.pow(2, 32)

module.exports = random
module.exports.cryptographic = true

function random() {
  var buf = crypto.randomBytes(4).toString('hex')

  return parseInt(buf, 16) / max
}
//
},
'repeat-element':
function(module) {
//
module.exports = function(ele, num) {
  var arr = new Array(num);

  for (var i = 0; i < num; i++) arr[i] = ele;

  return arr;
};
//
},
preserve:
function(module, exports) {
//
exports.before = function(str, re) {
  return str.replace(re, function(match) {
    var id = randomize();
    cache[id] = match;
    return '__ID' + id + '__';
  });
};

exports.after = function(str) {
  return str.replace(/__ID(.{5})__/g, function(_, id) {
    return cache[id];
  });
};

function randomize() {
  return Math.random().toString().slice(2, 7);
}

var cache = {};
//
},
'expand-brackets':
function(module, exports, __wpreq__) {
//
var isPosixBracket = __wpreq__('is-posix-bracket');

var POSIX = {
  alnum: 'a-zA-Z0-9',
  alpha: 'a-zA-Z',
  blank: ' \\t',
  cntrl: '\\x00-\\x1F\\x7F',
  digit: '0-9',
  graph: '\\x21-\\x7E',
  lower: 'a-z',
  print: '\\x20-\\x7E',
  punct: '-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  space: ' \\t\\r\\n\\v\\f',
  upper: 'A-Z',
  word: 'A-Za-z0-9_',
  xdigit: 'A-Fa-f0-9'
};

module.exports = brackets;

function brackets(str) {
  if (!isPosixBracket(str)) return str;

  var negated = false;
  if (str.indexOf('[^') > -1) {
    negated = true;
    str = str.split('[^').join('[');
  }
  if (str.indexOf('[!') > -1) {
    negated = true;
    str = str.split('[!').join('[');
  }

  var a = str.split('['),
    b = str.split(']'),
    imbalanced = a.length !== b.length,

    end = '', beg = '',
    res = [];

  for (var parts = str.split(/(?::]\[:|\[?\[:|:]]?)/), len = parts.length, i = 0; len--; ) {
    var inner = parts[i++];
    if (inner === '^[!' || inner === '[!') {
      inner = '';
      negated = true;
    }

    var prefix = negated ? '^' : '',
      ch = POSIX[inner];

    if (ch) res.push('[' + prefix + ch + ']');
    else if (inner)
      /^\[?\w-\w]?$/.test(inner)
        ? i === parts.length
          ? res.push('[' + prefix + inner)
          : i === 1
          ? res.push(prefix + inner + ']')
          : res.push(prefix + inner)
        : i === 1
        ? (beg += inner)
        : i === parts.length
        ? (end += inner)
        : res.push('[' + prefix + inner + ']');
  }

  var result = res.join('|'),
    rlen = res.length || 1;
  if (rlen > 1) {
    result = '(?:' + result + ')';
    rlen = 1;
  }
  if (beg) {
    rlen++;
    if (beg.charAt(0) === '[') imbalanced ? (beg = '\\[' + beg.slice(1)) : (beg += ']');

    result = beg + result;
  }
  if (end) {
    rlen++;
    if (end.slice(-1) === ']') end = imbalanced ? end.slice(0, end.length - 1) + '\\]' : '[' + end;

    result += end;
  }

  if (rlen > 1)
    (result = result.split('][').join(']|[')).indexOf('|') < 0 || /\(\?/.test(result) ||
      (result = '(?:' + result + ')');

  return result.replace(/\[+=|=]+/g, '\\b');
}

brackets.makeRe = function(pattern) {
  try {
    return new RegExp(brackets(pattern));
  } catch (_err) {}
};

brackets.isMatch = function(str, pattern) {
  try {
    return brackets.makeRe(pattern).test(str);
  } catch (_err) {
    return false;
  }
};

brackets.match = function(arr, pattern) {
  var len = arr.length,
    res = arr.slice();

  for (var i = 0, re = brackets.makeRe(pattern); i < len; ) {
    var ele = arr[i++];
    re.test(ele) && res.splice(i, 1);
  }
  return res;
};
//
},
'is-posix-bracket':
function(module) {
//
module.exports = function(str) {
  return typeof str == 'string' && /\[([:.=+])(?:[^\[\]]|)+\1]/.test(str);
};
//
},
extglob:
function(module) {
//
var re, cache = {};

module.exports = extglob;

function extglob(str, opts) {
  opts = opts || {};
  var o = {}, i = 0;

  str = (str = str.replace(/!\(([^\w*()])/g, '$1!(')).replace(/([*\/])\.!\([*]\)/g, function(m, ch) {
    return escape(ch === '/' ? '\\/[^.]+' : '[^.]+');
  });

  var key = str + String(!!opts.regex) + String(!!opts.contains) + String(!!opts.escape);

  if (cache.hasOwnProperty(key)) return cache[key];

  re instanceof RegExp || (re = regex());

  opts.negate = false;

  for (var m; (m = re.exec(str)); ) {
    var prefix = m[1],
      inner = m[3];
    if (prefix === '!') opts.negate = true;

    var id = '__EXTGLOB_' + i++ + '__';
    o[id] = wrap(inner, prefix, opts.escape);
    str = str.split(m[0]).join(id);
  }

  for (var keys = Object.keys(o), len = keys.length; len--; ) {
    var prop = keys[len];
    str = str.split(prop).join(o[prop]);
  }

  var result = opts.regex ? toRegex(str, opts.contains, opts.negate) : str;

  result = result.split('.').join('\\.');

  return (cache[key] = result);
}

function wrap(inner, prefix, esc) {
  if (esc) inner = escape(inner);

  switch (prefix) {
    case '!':
      return '(?!' + inner + ')[^/]' + (esc ? '%%%~' : '*?');
    case '@':
      return '(?:' + inner + ')';
    case '+':
      return '(?:' + inner + ')+';
    case '*':
      return '(?:' + inner + ')' + (esc ? '%%' : '*');
    case '?':
      return '(?:' + inner + '|)';
    default:
      return inner;
  }
}

function escape(str) {
  return (str = str.split('*').join('[^/]%%%~')).split('.').join('\\.');
}

function regex() {
  return /(\\?[@?!+*$]\\?)(\(([^()]*?)\))/;
}

function negate(str) {
  return '(?!^' + str + ').*$';
}

function toRegex(pattern, contains, isNegated) {
  var prefix = contains ? '^' : '';
  pattern = '(?:' + pattern + ')' + (contains ? '$' : '');
  if (isNegated) pattern = prefix + negate(pattern);

  return new RegExp(prefix + pattern);
}
//
},
'is-extglob':
function(module) {
//
module.exports = function(str) {
  return typeof str == 'string' && /[@?!+*]\(/.test(str);
};
//
},
'is-glob':
function(module, exports, __wpreq__) {
//
var isExtglob = __wpreq__('is-extglob');

module.exports = function(str) {
  return typeof str == 'string' && (/[*!?{}(|)[\]]/.test(str) || isExtglob(str));
};
//
},
'normalize-path':
function(module, exports, __wpreq__) {
//
var removeTrailingSeparator = __wpreq__('remove-trailing-separator');

module.exports = function(str, stripTrailing) {
  if (typeof str != 'string') throw new TypeError('expected a string');

  str = str.replace(/[\\\/]+/g, '/');
  if (stripTrailing !== false) str = removeTrailingSeparator(str);

  return str;
};
//
},
'remove-trailing-separator':
function(module) {
//
var isWin = process.platform === 'win32';

module.exports = function(str) {
  var i = str.length - 1;
  if (i < 2) return str;

  while (isSeparator(str, i)) i--;

  return str.substr(0, i + 1);
};

function isSeparator(str, i) {
  var char = str[i];
  return i > 0 && (char === '/' || (isWin && char === '\\'));
}
//
},
'object.omit':
function(module, exports, __wpreq__) {
//
var isObject = __wpreq__('is-extendable'),
  forOwn = __wpreq__('for-own');

module.exports = function(obj, keys) {
  if (!isObject(obj)) return {};

  keys = Array.prototype.concat.apply([], [].slice.call(arguments, 1));
  var fn,
    last = keys[keys.length - 1],
    res = {};

  if (typeof last == 'function') fn = keys.pop();

  var isFunction = typeof fn == 'function';
  if (!keys.length && !isFunction) return obj;

  forOwn(obj, function(value, key) {
    if (keys.indexOf(key) < 0)
      if (!isFunction) res[key] = value;
      else if (fn(value, key, obj)) res[key] = value;
  });
  return res;
};
//
},
'is-extendable':
function(module) {
//
module.exports = function(val) {
  return val !== void 0 && val !== null && (typeof val == 'object' || typeof val == 'function');
};
//
},
'for-own':
function(module, exports, __wpreq__) {
//
var forIn = __wpreq__('for-in'),
  hasOwn = Object.prototype.hasOwnProperty;

module.exports = function(obj, fn, thisArg) {
  forIn(obj, function(val, key) {
    if (hasOwn.call(obj, key)) return fn.call(thisArg, obj[key], key, obj);
  });
};
//
},
'for-in':
function(module) {
//
module.exports = function(obj, fn, thisArg) {
  for (var key in obj) if (fn.call(thisArg, obj[key], key, obj) === false) break;
};
//
},
'parse-glob':
function(module, exports, __wpreq__) {
//
var isGlob = __wpreq__('is-glob'),
  findBase = __wpreq__('glob-base'),
  extglob = __wpreq__('is-extglob'),
  dotfile = __wpreq__('is-dotfile'),

  cache = (module.exports.cache = {});

module.exports = function(glob) {
  if (cache.hasOwnProperty(glob)) return cache[glob];

  var tok = {};
  tok.orig = glob;
  tok.is = {};

  glob = escape(glob);

  var parsed = findBase(glob);
  tok.is.glob = parsed.isGlob;

  tok.glob = parsed.glob;
  tok.base = parsed.base;
  var segs = /([^\/]*)$/.exec(glob);

  tok.path = {};
  tok.path.dirname = '';
  tok.path.basename = segs[1] || '';
  tok.path.dirname = glob.split(tok.path.basename).join('') || '';
  var basename = (tok.path.basename || '').split('.') || '';
  tok.path.filename = basename[0] || '';
  tok.path.extname = basename.slice(1).join('.') || '';
  tok.path.ext = '';

  if (isGlob(tok.path.dirname) && !tok.path.basename) {
    /\/$/.test(tok.glob) || (tok.path.basename = tok.glob);

    tok.path.dirname = tok.base;
  }

  if (glob.indexOf('/') < 0 && !tok.is.globstar) {
    tok.path.dirname = '';
    tok.path.basename = tok.orig;
  }

  var dot = tok.path.basename.indexOf('.');
  if (dot > -1) {
    tok.path.filename = tok.path.basename.slice(0, dot);
    tok.path.extname = tok.path.basename.slice(dot);
  }

  if (tok.path.extname.charAt(0) === '.') {
    var exts = tok.path.extname.split('.');
    tok.path.ext = exts[exts.length - 1];
  }

  tok.glob = unescape(tok.glob);
  tok.path.dirname = unescape(tok.path.dirname);
  tok.path.basename = unescape(tok.path.basename);
  tok.path.filename = unescape(tok.path.filename);
  tok.path.extname = unescape(tok.path.extname);

  var is = glob && tok.is.glob;
  tok.is.negated = glob && glob.charAt(0) === '!';
  tok.is.extglob = glob && extglob(glob);
  tok.is.braces = has(is, glob, '{');
  tok.is.brackets = has(is, glob, '[:');
  tok.is.globstar = has(is, glob, '**');
  tok.is.dotfile = dotfile(tok.path.basename) || dotfile(tok.path.filename);
  tok.is.dotdir = dotdir(tok.path.dirname);
  return (cache[glob] = tok);
}

function dotdir(base) {
  return base.indexOf('/.') > -1 || (base.charAt(0) === '.' && base.charAt(1) !== '/');
}

function has(is, glob, ch) {
  return is && glob.indexOf(ch) > -1;
}

function escape(str) {
  var re = /{([^{}]*?)}|\(([^()]*?)\)|\[([^\[\]]*?)]/g;
  return str.replace(re, function(outer, braces, parens, brackets) {
    var inner = braces || parens || brackets;
    return inner ? outer.split(inner).join(esc(inner)) : outer;
  });
}

function esc(str) {
  return (str = str.split('/').join('__SLASH__')).split('.').join('__DOT__');
}

function unescape(str) {
  return (str = str.split('__SLASH__').join('/')).split('__DOT__').join('.');
}
//
},
'glob-base':
function(module, exports, __wpreq__) {
//
var path = __wpreq__('path'),
  parent = __wpreq__('glob-parent'),
  isGlob = __wpreq__('is-glob');

module.exports = function(pattern) {
  if (typeof pattern != 'string') throw new TypeError('glob-base expects a string.');

  var res = {};
  res.base = parent(pattern);
  res.isGlob = isGlob(pattern);

  if (res.base !== '.') {
    res.glob = pattern.substr(res.base.length);
    if (res.glob.charAt(0) === '/') res.glob = res.glob.substr(1);
  } else res.glob = pattern;

  if (!res.isGlob) {
    res.base = dirname(pattern);
    res.glob = res.base !== '.' ? pattern.substr(res.base.length) : pattern;
  }

  if (res.glob.substr(0, 2) === './') res.glob = res.glob.substr(2);
  if (res.glob.charAt(0) === '/') res.glob = res.glob.substr(1);

  return res;
};

function dirname(glob) {
  return glob.slice(-1) === '/' ? glob : path.dirname(glob);
}
//
},
'glob-parent':
function(module, exports, __wpreq__) {
//
var path = __wpreq__('path'),
  isglob = __wpreq__('is-glob');

module.exports = function(str) {
  str += 'a';
  do {
    str = path.dirname(str);
  } while (isglob(str));
  return str;
};
//
},
'is-dotfile':
function(module) {
//
module.exports = function(str) {
  if (str.charCodeAt(0) === 46 && str.indexOf('/', 1) < 0) return true;

  var slash = str.lastIndexOf('/');
  return slash > -1 && str.charCodeAt(slash + 1) === 46;
};
//
},
'regex-cache':
function(module, exports, __wpreq__) {
//
var equal = __wpreq__('is-equal-shallow'),
  basic = {},
  cache = {};

module.exports = regexCache;

function regexCache(fn, str, opts) {
  var regex, cached, key = '_default_';

  if (!str && !opts) return typeof fn != 'function' ? fn : basic[key] || (basic[key] = fn(str));

  if (typeof str == 'string') {
    if (!opts) return basic[str] || (basic[str] = fn(str));

    key = str;
  } else opts = str;

  if ((cached = cache[key]) && equal(cached.opts, opts)) return cached.regex;

  memo(key, opts, (regex = fn(str, opts)));
  return regex;
}

function memo(key, opts, regex) {
  cache[key] = {regex: regex, opts: opts};
}

module.exports.cache = cache;
module.exports.basic = basic;
//
},
'is-equal-shallow':
function(module, exports, __wpreq__) {
//
var isPrimitive = __wpreq__('is-primitive');

module.exports = function(a, b) {
  if (!a && !b) return true;
  if ((!a && b) || (a && !b)) return false;

  var numKeysA = 0, numKeysB = 0;
  for (var key in b) {
    numKeysB++;
    if (!isPrimitive(b[key]) || !a.hasOwnProperty(key) || a[key] !== b[key]) return false;
  }
  for (key in a) numKeysA++;

  return numKeysA === numKeysB;
};
//
},
'is-primitive':
function(module) {
//
module.exports = function(value) {
  return value == null || (typeof value != 'function' && typeof value != 'object');
};
//
},
'micromatch/lib/glob':
function(module, exports, __wpreq__) {
//
var chars = __wpreq__('micromatch/lib/chars'),
  utils = __wpreq__('micromatch/lib/utils');

var Glob = (module.exports = function Glob(pattern, options) {
  if (!(this instanceof Glob)) return new Glob(pattern, options);

  this.options = options || {};
  this.pattern = pattern;
  this.history = [];
  this.tokens = {};
  this.init(pattern);
});

Glob.prototype.init = function(pattern) {
  this.orig = pattern;
  this.negated = this.isNegated();
  this.options.track = this.options.track || false;
  this.options.makeRe = true;
};

Glob.prototype.track = function(msg) {
  this.options.track && this.history.push({msg: msg, pattern: this.pattern});
};

Glob.prototype.isNegated = function() {
  if (this.pattern.charCodeAt(0) === 33) {
    this.pattern = this.pattern.slice(1);
    return true;
  }
  return false;
};

Glob.prototype.braces = function() {
  if (this.options.nobraces !== true && this.options.nobrace !== true) {
    var a = this.pattern.match(/[{(\[]/g),
      b = this.pattern.match(/[})\]]/g);

    if (a && b && a.length !== b.length) this.options.makeRe = false;

    var expanded = utils.braces(this.pattern, this.options);
    this.pattern = expanded.join('|');
  }
};

Glob.prototype.brackets = function() {
  if (this.options.nobrackets !== true) this.pattern = utils.brackets(this.pattern);
};

Glob.prototype.extglob = function() {
  if (this.options.noextglob !== true && utils.isExtglob(this.pattern))
    this.pattern = utils.extglob(this.pattern, {escape: true});
};

Glob.prototype.parse = function(pattern) {
  this.tokens = utils.parseGlob(pattern || this.pattern, true);
  return this.tokens;
};

Glob.prototype._replace = function(a, b, escape) {
  this.track('before (find): "' + a + '" (replace with): "' + b + '"');
  if (escape) b = esc(b);
  this.pattern = a && b && typeof a == 'string' ? this.pattern.split(a).join(b) : this.pattern.replace(a, b);

  this.track('after');
};

Glob.prototype.escape = function(str) {
  this.track('before escape: ');
  var re = /["\\](['"]?[^"'\\]['"]?)/g;

  this.pattern = str.replace(re, function($0, $1) {
    var o = chars.ESC;
    return (o && o[$1]) || (/[a-z]/i.test($0) ? $0.split('\\').join('') : $0);
  });

  this.track('after escape: ');
};

Glob.prototype.unescape = function(str) {
  var re = /__([A-Z]+)_([A-Z]+)__/g;
  this.pattern = str.replace(re, function($0, $1) {
    return chars[$1][$0];
  });
  this.pattern = unesc(this.pattern);
};

function esc(str) {
  return (str = str.split('?').join('%~')).split('*').join('%%');
}

function unesc(str) {
  return (str = str.split('%~').join('?')).split('%%').join('*');
}
//
},
'micromatch/lib/chars':
function(module) {
//
var unesc, temp, chars = {};

function reverse(object, prepender) {
  return Object.keys(object).reduce(function(reversed, key) {
    reversed[object[key]] = prepender ? prepender + key : key;
    return reversed;
  }, {});
}

chars.escapeRegex = {
  '?': /\?/g,
  '@': /@/g,
  '!': /!/g,
  '+': /\+/g,
  '*': /\*/g,
  '(': /\(/g,
  ')': /\)/g,
  '[': /\[/g,
  ']': /]/g
};

chars.ESC = {
  '?': '__UNESC_QMRK__',
  '@': '__UNESC_AMPE__',
  '!': '__UNESC_EXCL__',
  '+': '__UNESC_PLUS__',
  '*': '__UNESC_STAR__',
  ',': '__UNESC_COMMA__',
  '(': '__UNESC_LTPAREN__',
  ')': '__UNESC_RTPAREN__',
  '[': '__UNESC_LTBRACK__',
  ']': '__UNESC_RTBRACK__'
};

chars.UNESC = unesc || (unesc = reverse(chars.ESC, '\\'));

chars.ESC_TEMP = {
  '?': '__TEMP_QMRK__',
  '@': '__TEMP_AMPE__',
  '!': '__TEMP_EXCL__',
  '*': '__TEMP_STAR__',
  '+': '__TEMP_PLUS__',
  ',': '__TEMP_COMMA__',
  '(': '__TEMP_LTPAREN__',
  ')': '__TEMP_RTPAREN__',
  '[': '__TEMP_LTBRACK__',
  ']': '__TEMP_RTBRACK__'
};

chars.TEMP = temp || (temp = reverse(chars.ESC_TEMP));

module.exports = chars;
//
},
ssri:
function(module, exports, __wpreq__) {
//
const Buffer = __wpreq__('buffer').Buffer,

  crypto = __wpreq__('crypto'),
  Transform = __wpreq__('stream').Transform,

  SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512'],

  BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i,
  SRI_REGEX = /^([^-]+)-([^?]+)([?\S*]*)$/,
  STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/=]{44,88})(\?[\x21-\x7E]*)*$/,
  VCHAR_REGEX = /^[\x21-\x7E]+$/

class Hash {
  get isHash() { return true }
  constructor(hash, opts) {
    const strict = !(!opts || !opts.strict)
    this.source = hash.trim()
    const match = this.source.match(strict ? STRICT_SRI_REGEX : SRI_REGEX)
    if (!match) return
    if (strict && SPEC_ALGORITHMS.indexOf(match[1]) < 0) return
    this.algorithm = match[1]
    this.digest = match[2]

    const rawOpts = match[3]
    this.options = rawOpts ? rawOpts.slice(1).split('?') : []
  }
  hexDigest() {
    return this.digest && (Buffer.from || Buffer)(this.digest, 'base64').toString('hex')
  }
  toJSON() {
    return this.toString()
  }
  toString(opts) {
    if (opts && opts.strict && !(
      SPEC_ALGORITHMS.indexOf(this.algorithm) >= 0 &&
      this.digest.match(BASE64_REGEX) &&
      (this.options || []).every(opt => opt.match(VCHAR_REGEX))
    ))
      return ''

    const options = this.options && this.options.length ? '?' + this.options.join('?') : ''
    return `${this.algorithm}-${this.digest}${options}`
  }
}

class Integrity {
  get isIntegrity() { return true }
  toJSON() {
    return this.toString()
  }
  toString(opts) {
    let sep = (opts = opts || {}).sep || ' '
    if (opts.strict) sep = sep.replace(/\S+/g, ' ')

    return Object.keys(this)
      .map(k => this[k].map(hash => Hash.prototype.toString.call(hash, opts)).filter(x => x.length).join(sep))
      .filter(x => x.length)
      .join(sep)
  }
  concat(integrity, opts) {
    const other = typeof integrity == 'string' ? integrity : stringify(integrity, opts)
    return parse(`${this.toString(opts)} ${other}`, opts)
  }
  hexDigest() {
    return parse(this, {single: true}).hexDigest()
  }
  match(integrity, opts) {
    const other = parse(integrity, opts),
      algo = other.pickAlgorithm(opts)
    return (
      this[algo] &&
      other[algo] &&
      this[algo].find(hash => other[algo].find(otherhash => hash.digest === otherhash.digest))
    ) || false
  }
  pickAlgorithm(opts) {
    const pickAlgorithm = (opts && opts.pickAlgorithm) || getPrioritizedHash,
      keys = Object.keys(this)
    if (!keys.length) throw new Error('No algorithms available for ' + JSON.stringify(this.toString()))

    return keys.reduce((acc, algo) => pickAlgorithm(acc, algo) || acc)
  }
}

module.exports.parse = parse
function parse(sri, opts) {
  opts = opts || {}
  if (typeof sri == 'string') return _parse(sri, opts)
  if (sri.algorithm && sri.digest) {
    const fullSri = new Integrity()
    fullSri[sri.algorithm] = [sri]
    return _parse(stringify(fullSri, opts), opts)
  }
  return _parse(stringify(sri, opts), opts)
}

function _parse(integrity, opts) {
  if (opts.single) return new Hash(integrity, opts)

  return integrity.trim().split(/\s+/).reduce((acc, string) => {
    const hash = new Hash(string, opts)
    if (hash.algorithm && hash.digest) {
      const algo = hash.algorithm
      acc[algo] || (acc[algo] = [])
      acc[algo].push(hash)
    }
    return acc
  }, new Integrity())
}

module.exports.stringify = stringify
function stringify(obj, opts) {
  return obj.algorithm && obj.digest
    ? Hash.prototype.toString.call(obj, opts)
    : typeof obj == 'string'
    ? stringify(parse(obj, opts), opts)
    : Integrity.prototype.toString.call(obj, opts)
}

module.exports.fromHex = fromHex
function fromHex(hexDigest, algorithm, opts) {
  const optString = opts && opts.options && opts.options.length ? '?' + opts.options.join('?') : ''
  return parse(`${algorithm}-${(Buffer.from || Buffer)(hexDigest, 'hex').toString('base64')}${optString}`, opts)
}

module.exports.fromData = fromData
function fromData(data, opts) {
  const algorithms = (opts = opts || {}).algorithms || ['sha512'],
    optString = opts.options && opts.options.length ? '?' + opts.options.join('?') : ''
  return algorithms.reduce((acc, algo) => {
    const digest = crypto.createHash(algo).update(data).digest('base64'),
      hash = new Hash(`${algo}-${digest}${optString}`, opts)
    if (hash.algorithm && hash.digest) {
      const algo = hash.algorithm
      acc[algo] || (acc[algo] = [])
      acc[algo].push(hash)
    }
    return acc
  }, new Integrity())
}

module.exports.integrityStream = integrityStream
function integrityStream(opts) {
  const sri = (opts = opts || {}).integrity && parse(opts.integrity, opts),
    goodSri = sri && Object.keys(sri).length,
    algorithm = goodSri && sri.pickAlgorithm(opts),
    digests = goodSri && sri[algorithm],
    algorithms = Array.from(new Set((opts.algorithms || ['sha512']).concat(algorithm ? [algorithm] : []))),
    hashes = algorithms.map(crypto.createHash)
  let streamSize = 0
  const stream = new Transform({
    transform(chunk, enc, cb) {
      streamSize += chunk.length
      hashes.forEach(h => h.update(chunk, enc))
      cb(null, chunk, enc)
    }
  }).on('end', () => {
    const optString = opts.options && opts.options.length ? '?' + opts.options.join('?') : '',
      newSri = parse(hashes.map((h, i) => `${algorithms[i]}-${h.digest('base64')}${optString}`).join(' '), opts),
      match = goodSri && newSri.match(sri, opts)
    if (typeof opts.size == 'number' && streamSize !== opts.size) {
      const err = new Error(`stream size mismatch when checking ${sri}.\n  Wanted: ${opts.size}\n  Found: ${streamSize}`)
      err.code = 'EBADSIZE'
      err.found = streamSize
      err.expected = opts.size
      err.sri = sri
      stream.emit('error', err)
    } else if (opts.integrity && !match) {
      const err = new Error(
        `${sri} integrity checksum failed when using ${algorithm}: wanted ${digests} but got ${newSri}. (${streamSize} bytes)`
      )
      err.code = 'EINTEGRITY'
      err.found = newSri
      err.expected = digests
      err.algorithm = algorithm
      err.sri = sri
      stream.emit('error', err)
    } else {
      stream.emit('size', streamSize)
      stream.emit('integrity', newSri)
      match && stream.emit('verified', match)
    }
  })
  return stream
}

const NODE_HASHES = new Set(crypto.getHashes())

const DEFAULT_PRIORITY = [
  'md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512',
  'sha3',
  'sha3-256', 'sha3-384', 'sha3-512',
  'sha3_256', 'sha3_384', 'sha3_512'
].filter(algo => NODE_HASHES.has(algo))

function getPrioritizedHash(algo1, algo2) {
  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase())
    ? algo1
    : algo2
}
//
},
'object-path':
function(module) {
//
var toStr = Object.prototype.toString;
function hasOwnProperty(obj, prop) {
  return obj != null && Object.prototype.hasOwnProperty.call(obj, prop)
}

function isEmpty(value) {
  if (!value) return true;

  if (isArray(value) && value.length === 0) return true;
  if (typeof value != 'string') {
    for (var i in value) if (hasOwnProperty(value, i)) return false;

    return true;
  }
  return false;
}

function toString(type) {
  return toStr.call(type);
}

function isObject(obj) {
  return typeof obj == 'object' && toString(obj) === "[object Object]";
}

var isArray = Array.isArray || function(obj) {
  return toStr.call(obj) === '[object Array]';
}

function isBoolean(obj) {
  return typeof obj == 'boolean' || toString(obj) === '[object Boolean]';
}

function getKey(key) {
  var intKey = parseInt(key);
  return intKey.toString() === key ? intKey : key;
}

function factory(options) {
  options = options || {};

  var objectPath = function(obj) {
    return Object.keys(objectPath).reduce(function(proxy, prop) {
      if (prop === 'create') return proxy;

      if (typeof objectPath[prop] == 'function') proxy[prop] = objectPath[prop].bind(objectPath, obj);

      return proxy;
    }, {});
  };

  function hasShallowProperty(obj, prop) {
    return options.includeInheritedProps || (typeof prop == 'number' && Array.isArray(obj)) || hasOwnProperty(obj, prop)
  }

  function getShallowProperty(obj, prop) {
    if (hasShallowProperty(obj, prop)) return obj[prop];
  }

  function set(obj, path, value, doNotReplace) {
    if (typeof path == 'number') path = [path];

    if (!path || path.length === 0) return obj;
    if (typeof path == 'string') return set(obj, path.split('.').map(getKey), value, doNotReplace);

    var currentPath = path[0],
      currentValue = getShallowProperty(obj, currentPath);
    if (path.length === 1) {
      (currentValue !== void 0 && doNotReplace) || (obj[currentPath] = value);

      return currentValue;
    }

    if (currentValue === void 0) typeof path[1] == 'number' ? (obj[currentPath] = []) : (obj[currentPath] = {});

    return set(obj[currentPath], path.slice(1), value, doNotReplace);
  }

  objectPath.has = function(obj, path) {
    if (typeof path == 'number') path = [path];
    else if (typeof path == 'string') path = path.split('.');

    if (!path || path.length === 0) return !!obj;

    for (var i = 0; i < path.length; i++) {
      var j = getKey(path[i]);

      if (!(
        (typeof j == 'number' && isArray(obj) && j < obj.length) ||
        (options.includeInheritedProps ? j in Object(obj) : hasOwnProperty(obj, j))
      ))
        return false;

      obj = obj[j];
    }

    return true;
  };

  objectPath.ensureExists = function(obj, path, value) {
    return set(obj, path, value, true);
  };

  objectPath.set = function(obj, path, value, doNotReplace) {
    return set(obj, path, value, doNotReplace);
  };

  objectPath.insert = function(obj, path, value, at) {
    var arr = objectPath.get(obj, path);
    at = ~~at;
    if (!isArray(arr)) {
      arr = [];
      objectPath.set(obj, path, arr);
    }
    arr.splice(at, 0, value);
  };

  objectPath.empty = function(obj, path) {
    var value, i;
    if (isEmpty(path) || obj == null || !(value = objectPath.get(obj, path))) return void 0;

    if (typeof value == 'string') return objectPath.set(obj, path, '');
    if (isBoolean(value)) return objectPath.set(obj, path, false);
    if (typeof value == 'number') return objectPath.set(obj, path, 0);
    if (isArray(value)) value.length = 0;
    else if (isObject(value)) for (i in value) hasShallowProperty(value, i) && delete value[i];
    else return objectPath.set(obj, path, null);
  };

  objectPath.push = function(obj, path) {
    var arr = objectPath.get(obj, path);
    if (!isArray(arr)) {
      arr = [];
      objectPath.set(obj, path, arr);
    }

    arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));
  };

  objectPath.coalesce = function(obj, paths, defaultValue) {
    for (var value, i = 0, len = paths.length; i < len; i++)
      if ((value = objectPath.get(obj, paths[i])) !== void 0) return value;

    return defaultValue;
  };

  objectPath.get = function(obj, path, defaultValue) {
    if (typeof path == 'number') path = [path];

    if (!path || path.length === 0) return obj;
    if (obj == null) return defaultValue;
    if (typeof path == 'string') return objectPath.get(obj, path.split('.'), defaultValue);

    var currentPath = getKey(path[0]),
      nextObj = getShallowProperty(obj, currentPath)

    return nextObj === void 0
      ? defaultValue
      : path.length === 1
      ? nextObj
      : objectPath.get(obj[currentPath], path.slice(1), defaultValue);
  };

  objectPath.del = function(obj, path) {
    if (typeof path == 'number') path = [path];

    if (obj == null) return obj;

    if (isEmpty(path)) return obj;
    if (typeof path == 'string') return objectPath.del(obj, path.split('.'));

    var currentPath = getKey(path[0]);
    if (!hasShallowProperty(obj, currentPath)) return obj;

    if (path.length !== 1) return objectPath.del(obj[currentPath], path.slice(1));

    isArray(obj) ? obj.splice(currentPath, 1) : delete obj[currentPath];

    return obj;
  }

  return objectPath;
}

var mod = factory();
mod.create = factory;
mod.withInheritedProps = factory({includeInheritedProps: true})
module.exports = mod;
//
},
'normalize-url':
function(module, exports, __wpreq__) {
//
const url = __wpreq__('url'),
  punycode = __wpreq__('punycode'),
  queryString = __wpreq__('query-string'),
  prependHttp = __wpreq__('prepend-http'),
  sortKeys = __wpreq__('sort-keys'),

  DEFAULT_PORTS = {'http:': 80, 'https:': 443, 'ftp:': 21};

const slashedProtocol = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
};

function testParameter(name, filters) {
  return filters.some(filter => (filter instanceof RegExp ? filter.test(name) : filter === name));
}

module.exports = (str, opts) => {
  opts = Object.assign({
    normalizeProtocol: true,
    normalizeHttps: false,
    stripFragment: true,
    stripWWW: true,
    removeQueryParameters: [/^utm_\w+/i],
    removeTrailingSlash: true,
    removeDirectoryIndex: false,
    sortQueryParameters: true
  }, opts);

  if (typeof str != 'string') throw new TypeError('Expected a string');

  const hasRelativeProtocol = str.startsWith('//');

  str = prependHttp(str.trim()).replace(/^\/\//, 'http://');

  const urlObj = url.parse(str);

  if (opts.normalizeHttps && urlObj.protocol === 'https:') urlObj.protocol = 'http:';

  if (!urlObj.hostname && !urlObj.pathname) throw new Error('Invalid URL');

  delete urlObj.host;
  delete urlObj.query;

  opts.stripFragment && delete urlObj.hash;

  const port = DEFAULT_PORTS[urlObj.protocol];
  Number(urlObj.port) !== port || delete urlObj.port;

  if (urlObj.pathname) urlObj.pathname = urlObj.pathname.replace(/\/{2,}/g, '/');

  if (urlObj.pathname) urlObj.pathname = decodeURI(urlObj.pathname);

  if (opts.removeDirectoryIndex === true) opts.removeDirectoryIndex = [/^index\.[a-z]+$/];

  if (Array.isArray(opts.removeDirectoryIndex) && opts.removeDirectoryIndex.length > 0) {
    let pathComponents = urlObj.pathname.split('/');

    if (testParameter(pathComponents[pathComponents.length - 1], opts.removeDirectoryIndex)) {
      pathComponents = pathComponents.slice(0, pathComponents.length - 1);
      urlObj.pathname = pathComponents.slice(1).join('/') + '/';
    }
  }

  if (slashedProtocol[urlObj.protocol]) {
    const domain = urlObj.protocol + '//' + urlObj.hostname,
      relative = url.resolve(domain, urlObj.pathname);
    urlObj.pathname = relative.replace(domain, '');
  }

  if (urlObj.hostname) {
    urlObj.hostname = punycode.toUnicode(urlObj.hostname).toLowerCase();

    urlObj.hostname = urlObj.hostname.replace(/\.$/, '');

    if (opts.stripWWW) urlObj.hostname = urlObj.hostname.replace(/^www\./, '');
  }

  urlObj.search !== '?' || delete urlObj.search;

  const queryParameters = queryString.parse(urlObj.search);

  if (Array.isArray(opts.removeQueryParameters))
    for (const key in queryParameters) testParameter(key, opts.removeQueryParameters) && delete queryParameters[key];

  if (opts.sortQueryParameters) urlObj.search = queryString.stringify(sortKeys(queryParameters));

  if (urlObj.search !== null) urlObj.search = decodeURIComponent(urlObj.search);

  str = url.format(urlObj);

  if (opts.removeTrailingSlash || urlObj.pathname === '/') str = str.replace(/\/$/, '');

  if (hasRelativeProtocol && !opts.normalizeProtocol) str = str.replace(/^http:\/\//, '//');

  return str;
};
//
},
url:
function(module) {
//
module.exports = require('url');
//
},
punycode:
function(module) {
//
module.exports = require('punycode');
//
},
'query-string':
function(module, exports, __wpreq__) {
//
var strictUriEncode = __wpreq__('strict-uri-encode'),
  objectAssign = Object.assign,
  decodeComponent = __wpreq__('decode-uri-component');

function encoderForArrayFormat(opts) {
  switch (opts.arrayFormat) {
    case 'index':
      return function(key, value, index) {
        return value === null
          ? [encode(key, opts), '[', index, ']'].join('')
          : [encode(key, opts), '[', encode(index, opts), ']=', encode(value, opts)].join('');
      };

    case 'bracket':
      return function(key, value) {
        return value === null ? encode(key, opts) : [encode(key, opts), '[]=', encode(value, opts)].join('');
      };

    default:
      return function(key, value) {
        return value === null ? encode(key, opts) : [encode(key, opts), '=', encode(value, opts)].join('');
      };
  }
}

function parserForArrayFormat(opts) {
  var result;

  switch (opts.arrayFormat) {
    case 'index':
      return function(key, value, accumulator) {
        result = /\[(\d*)]$/.exec(key);

        key = key.replace(/\[\d*]$/, '');

        if (result) {
          if (accumulator[key] === void 0) accumulator[key] = {};

          accumulator[key][result[1]] = value;
        } else accumulator[key] = value;
      };

    case 'bracket':
      return function(key, value, accumulator) {
        result = /(\[])$/.exec(key);
        key = key.replace(/\[]$/, '');

        !result
          ? (accumulator[key] = value)
          : accumulator[key] === void 0
          ? (accumulator[key] = [value])
          : (accumulator[key] = [].concat(accumulator[key], value));
      };

    default:
      return function(key, value, accumulator) {
        accumulator[key] === void 0
          ? (accumulator[key] = value)
          : (accumulator[key] = [].concat(accumulator[key], value));
      };
  }
}

function encode(value, opts) {
  return opts.encode ? (opts.strict ? strictUriEncode(value) : encodeURIComponent(value)) : value;
}

function keysSorter(input) {
  return Array.isArray(input)
    ? input.sort()
    : typeof input == 'object'
    ? keysSorter(Object.keys(input)).sort(function(a, b) {
        return Number(a) - Number(b);
      }).map(function(key) {
        return input[key];
      })
    : input;
}

function extract(str) {
  var queryStart = str.indexOf('?');
  return queryStart < 0 ? '' : str.slice(queryStart + 1);
}

function parse(str, opts) {
  var formatter = parserForArrayFormat((opts = objectAssign({arrayFormat: 'none'}, opts))),

    ret = Object.create(null);

  if (typeof str != 'string') return ret;

  if (!(str = str.trim().replace(/^[?#&]/, ''))) return ret;

  str.split('&').forEach(function(param) {
    var parts = param.replace(/\+/g, ' ').split('='),
      key = parts.shift(),
      val = parts.length > 0 ? parts.join('=') : void 0;

    val = val === void 0 ? null : decodeComponent(val);

    formatter(decodeComponent(key), val, ret);
  });

  return Object.keys(ret).sort().reduce(function(result, key) {
    var val = ret[key];
    Boolean(val) && typeof val == 'object' && !Array.isArray(val)
      ? (result[key] = keysSorter(val))
      : (result[key] = val);

    return result;
  }, Object.create(null));
}

exports.extract = extract;
exports.parse = parse;

exports.stringify = function(obj, opts) {
  opts = objectAssign({
    encode: true,
    strict: true,
    arrayFormat: 'none'
  }, opts);

  if (opts.sort === false) opts.sort = function() {};

  var formatter = encoderForArrayFormat(opts);

  return obj ? Object.keys(obj).sort(opts.sort).map(function(key) {
    var val = obj[key];

    if (val === void 0) return '';

    if (val === null) return encode(key, opts);

    if (Array.isArray(val)) {
      var result = [];

      val.slice().forEach(function(val2) {
        val2 === void 0 || result.push(formatter(key, val2, result.length));
      });

      return result.join('&');
    }

    return encode(key, opts) + '=' + encode(val, opts);
  }).filter(function(x) {
    return x.length > 0;
  }).join('&') : '';
};

exports.parseUrl = function(str, opts) {
  return {url: str.split('?')[0] || '', query: parse(extract(str), opts)};
};
//
},
'strict-uri-encode':
function(module) {
//
module.exports = function(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
};
//
},
'decode-uri-component':
function(module) {
//
var token = '%[a-f0-9]{2}',
  singleMatcher = new RegExp(token, 'gi'),
  multiMatcher = new RegExp('(' + token + ')+', 'gi');

function decodeComponents(components, split) {
  try {
    return decodeURIComponent(components.join(''));
  } catch (_err) {}

  if (components.length === 1) return components;

  split = split || 1;

  var left = components.slice(0, split),
    right = components.slice(split);

  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}

function decode(input) {
  try {
    return decodeURIComponent(input);
  } catch (_err) {
    for (var tokens = input.match(singleMatcher), i = 1; i < tokens.length; i++)
      tokens = (input = decodeComponents(tokens, i).join('')).match(singleMatcher);

    return input;
  }
}

function customDecodeURIComponent(input) {
  var replaceMap = {'%FE%FF': '', '%FF%FE': ''};

  for (var match = multiMatcher.exec(input); match; ) {
    try {
      replaceMap[match[0]] = decodeURIComponent(match[0]);
    } catch (_err) {
      var result = decode(match[0]);

      if (result !== match[0]) replaceMap[match[0]] = result;
    }

    match = multiMatcher.exec(input);
  }

  replaceMap['%C2'] = '';

  for (var entries = Object.keys(replaceMap), i = 0; i < entries.length; i++) {
    var key = entries[i];
    input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
  }

  return input;
}

module.exports = function(encodedURI) {
  if (typeof encodedURI != 'string')
    throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');

  try {
    encodedURI = encodedURI.replace(/\+/g, ' ');

    return decodeURIComponent(encodedURI);
  } catch (_err) {
    return customDecodeURIComponent(encodedURI);
  }
};
//
},
'prepend-http':
function(module) {
//
module.exports = (url, opts) => {
  if (typeof url != 'string') throw new TypeError('Expected `url` to be of type `string`, got `' + typeof url + '`');

  url = url.trim();
  opts = Object.assign({https: false}, opts);

  return /^\.*\/|^(?!localhost)\w+:/.test(url)
    ? url
    : url.replace(/^(?!(?:\w+:)?\/\/)/, opts.https ? 'https://' : 'http://');
};
//
},
'sort-keys':
function(module, exports, __wpreq__) {
//
const isPlainObj = __wpreq__('is-plain-obj');

module.exports = (obj, opts) => {
  if (!isPlainObj(obj)) throw new TypeError('Expected a plain object');

  if (typeof (opts = opts || {}) == 'function')
    throw new TypeError('Specify the compare function as an option instead');

  const deep = opts.deep,
    seenInput = [],
    seenOutput = [];

  const sortKeys = x => {
    const seenIndex = seenInput.indexOf(x);

    if (seenIndex > -1) return seenOutput[seenIndex];

    const ret = {},
      keys = Object.keys(x).sort(opts.compare);

    seenInput.push(x);
    seenOutput.push(ret);

    for (let i = 0; i < keys.length; i++) {
      const key = keys[i],
        val = x[key];

      if (deep && Array.isArray(val)) {
        const retArr = [];

        for (let j = 0; j < val.length; j++) retArr[j] = isPlainObj(val[j]) ? sortKeys(val[j]) : val[j];

        ret[key] = retArr;
      } else ret[key] = deep && isPlainObj(val) ? sortKeys(val) : val;
    }

    return ret;
  };

  return sortKeys(obj);
};
//
},
'is-plain-obj':
function(module) {
//
var toString = Object.prototype.toString;

module.exports = function(x) {
  var prototype;
  return (
    toString.call(x) === '[object Object]' &&
    ((prototype = Object.getPrototypeOf(x)) === null || prototype === Object.getPrototypeOf({}))
  );
};
//
},
ini:
function(module, exports) {
//
exports.parse = exports.decode = decode

exports.stringify = exports.encode = encode

exports.safe = safe
exports.unsafe = unsafe

var eol = typeof process != 'undefined' && process.platform === 'win32' ? '\r\n' : '\n'

function encode(obj, opt) {
  var children = [],
    out = ''

  typeof opt == 'string'
    ? (opt = {section: opt, whitespace: false})
    : ((opt = opt || {}).whitespace = opt.whitespace === true)

  var separator = opt.whitespace ? ' = ' : '='

  Object.keys(obj).forEach(function(k, _, __) {
    var val = obj[k]
    val && Array.isArray(val)
      ? val.forEach(function(item) {
          out += safe(k + '[]') + separator + safe(item) + '\n'
        })
      : val && typeof val == 'object'
      ? children.push(k)
      : (out += safe(k) + separator + safe(val) + eol)
  })

  if (opt.section && out.length) out = '[' + safe(opt.section) + ']' + eol + out

  children.forEach(function(k, _, __) {
    var nk = dotSplit(k).join('\\.'),
      section = (opt.section ? opt.section + '.' : '') + nk,
      child = encode(obj[k], {section: section, whitespace: opt.whitespace})
    if (out.length && child.length) out += eol

    out += child
  })

  return out
}

function dotSplit(str) {
  return str.replace(/\1/g, '\x02LITERAL\\1LITERAL\x02')
    .replace(/\\\./g, '\x01')
    .split(/\./).map(function(part) {
      return part.replace(/\1/g, '\\.').replace(/\2LITERAL\\1LITERAL\2/g, '\x01')
    })
}

function decode(str) {
  var out = {},
    p = out,
    section = null,
    re = /^\[([^\]]*)]$|^([^=]+)(=(.*))?$/i

  str.split(/[\r\n]+/g).forEach(function(line, _, __) {
    if (!line || line.match(/^\s*[;#]/)) return
    var match = line.match(re)
    if (!match) return
    if (match[1] !== void 0) {
      section = unsafe(match[1])
      p = out[section] = out[section] || {}
      return
    }
    var key = unsafe(match[2]),
      value = !match[3] || unsafe(match[4])
    switch (value) {
      case 'true':
      case 'false':
      case 'null': value = JSON.parse(value)
    }

    if (key.length > 2 && key.slice(-2) === '[]') {
      key = key.substring(0, key.length - 2)
      p[key] ? Array.isArray(p[key]) || (p[key] = [p[key]]) : (p[key] = [])
    }

    Array.isArray(p[key]) ? p[key].push(value) : (p[key] = value)
  })

  Object.keys(out).filter(function(k, _, __) {
    if (!out[k] || typeof out[k] != 'object' || Array.isArray(out[k])) return false

    var parts = dotSplit(k),
      p = out,
      l = parts.pop(),
      nl = l.replace(/\\\./g, '.')
    parts.forEach(function(part, _, __) {
      if (!p[part] || typeof p[part] != 'object') p[part] = {}
      p = p[part]
    })
    if (p === out && nl === l) return false

    p[nl] = out[k]
    return true
  }).forEach(function(del, _, __) {
    delete out[del]
  })

  return out
}

function isQuoted(val) {
  return (val.charAt(0) === '"' && val.slice(-1) === '"') || (val.charAt(0) === "'" && val.slice(-1) === "'")
}

function safe(val) {
  return typeof val != 'string' ||
    val.match(/[=\r\n]/) ||
    val.match(/^\[/) ||
    (val.length > 1 && isQuoted(val)) ||
    val !== val.trim()
    ? JSON.stringify(val)
    : val.replace(/;/g, '\\;').replace(/#/g, '\\#')
}

function unsafe(val, doUnesc) {
  if (isQuoted((val = (val || '').trim()))) {
    if (val.charAt(0) === "'") val = val.substr(1, val.length - 2)

    try {
      val = JSON.parse(val)
    } catch (_) {}
    return val
  }

  var esc = false,
    unesc = ''
  for (var i = 0, l = val.length; i < l; i++) {
    var c = val.charAt(i)
    if (esc) {
      '\\;#'.indexOf(c) > -1 ? (unesc += c) : (unesc += '\\' + c)

      esc = false
    } else if (';#'.indexOf(c) > -1) break
    else c === '\\' ? (esc = true) : (unesc += c)
  }
  if (esc) unesc += '\\'

  return unesc.trim()
}
//
},
'tar-fs':
function(module, exports, __wpreq__) {
//
var chownr = __wpreq__('chownr'),
  tar = __wpreq__('tar-stream'),
  pump = __wpreq__('pump'),
  mkdirp = __wpreq__('mkdirp'),
  fs = __wpreq__('fs'),
  path = __wpreq__('path'),

  win32 = __wpreq__('os').platform() === 'win32',

  noop = function() {}

var echo = function(name) {
  return name
}

var normalize = !win32 ? echo : function(name) {
  return name.replace(/\\/g, '/').replace(/[:?<>|]/g, '_')
}

var statAll = function(fs, stat, cwd, ignore, entries, sort) {
  var queue = entries || ['.']

  return function(callback) {
    if (!queue.length) return callback()
    var next = queue.shift(),
      nextAbs = path.join(cwd, next)

    stat(nextAbs, function(err, stat) {
      if (err) return callback(err)

      if (!stat.isDirectory()) return callback(null, next, stat)

      fs.readdir(nextAbs, function(err, files) {
        if (err) return callback(err)

        sort && files.sort()
        for (var i = 0; i < files.length; i++)
          ignore(path.join(cwd, next, files[i])) || queue.push(path.join(next, files[i]))

        callback(null, next, stat)
      })
    })
  }
}

var strip = function(map, level) {
  return function(header) {
    header.name = header.name.split('/').slice(level).join('/')

    var linkname = header.linkname
    if (linkname && (header.type === 'link' || path.isAbsolute(linkname)))
      header.linkname = linkname.split('/').slice(level).join('/')

    return map(header)
  }
}

exports.pack = function(cwd, opts) {
  cwd || (cwd = '.')
  opts || (opts = {})

  var xfs = opts.fs || fs,
    ignore = opts.ignore || opts.filter || noop,
    map = opts.map || noop,
    mapStream = opts.mapStream || echo,
    statNext = statAll(xfs, opts.dereference ? xfs.stat : xfs.lstat, cwd, ignore, opts.entries, opts.sort),
    strict = opts.strict !== false,
    umask = typeof opts.umask == 'number' ? ~opts.umask : ~processUmask(),
    dmode = typeof opts.dmode == 'number' ? opts.dmode : 0,
    fmode = typeof opts.fmode == 'number' ? opts.fmode : 0,
    pack = opts.pack || tar.pack(),
    finish = opts.finish || noop

  if (opts.strip) map = strip(map, opts.strip)

  if (opts.readable) {
    dmode |= parseInt(555, 8)
    fmode |= parseInt(444, 8)
  }
  if (opts.writable) {
    dmode |= parseInt(333, 8)
    fmode |= parseInt(222, 8)
  }

  var onsymlink = function(filename, header) {
    xfs.readlink(path.join(cwd, filename), function(err, linkname) {
      if (err) return pack.destroy(err)
      header.linkname = normalize(linkname)
      pack.entry(header, onnextentry)
    })
  }

  var onstat = function(err, filename, stat) {
    if (err) return pack.destroy(err)
    if (!filename) {
      opts.finalize === false || pack.finalize()
      return finish(pack)
    }

    if (stat.isSocket()) return onnextentry()

    var header = {
      name: normalize(filename),
      mode: (stat.mode | (stat.isDirectory() ? dmode : fmode)) & umask,
      mtime: stat.mtime,
      size: stat.size,
      type: 'file',
      uid: stat.uid,
      gid: stat.gid
    }

    if (stat.isDirectory()) {
      header.size = 0
      header.type = 'directory'
      header = map(header) || header
      return pack.entry(header, onnextentry)
    }

    if (stat.isSymbolicLink()) {
      header.size = 0
      header.type = 'symlink'
      header = map(header) || header
      return onsymlink(filename, header)
    }

    header = map(header) || header

    if (!stat.isFile()) return strict ? pack.destroy(new Error('unsupported type for ' + filename)) : onnextentry()

    var entry = pack.entry(header, onnextentry)
    if (!entry) return

    var rs = mapStream(xfs.createReadStream(path.join(cwd, filename)), header)

    rs.on('error', function(err) {
      entry.destroy(err)
    })

    pump(rs, entry)
  }

  var onnextentry = function(err) {
    if (err) return pack.destroy(err)
    statNext(onstat)
  }

  onnextentry()

  return pack
}

var head = function(list) {
  return list.length ? list[list.length - 1] : null
}

var processGetuid = function() {
  return process.getuid ? process.getuid() : -1
}

var processUmask = function() {
  return process.umask ? process.umask() : 0
}

exports.extract = function(cwd, opts) {
  cwd || (cwd = '.')
  opts || (opts = {})

  var xfs = opts.fs || fs,
    ignore = opts.ignore || opts.filter || noop,
    map = opts.map || noop,
    mapStream = opts.mapStream || echo,
    own = opts.chown !== false && !win32 && processGetuid() === 0,
    extract = opts.extract || tar.extract(),
    stack = [],
    now = new Date(),
    umask = typeof opts.umask == 'number' ? ~opts.umask : ~processUmask(),
    dmode = typeof opts.dmode == 'number' ? opts.dmode : 0,
    fmode = typeof opts.fmode == 'number' ? opts.fmode : 0,
    strict = opts.strict !== false

  if (opts.strip) map = strip(map, opts.strip)

  if (opts.readable) {
    dmode |= parseInt(555, 8)
    fmode |= parseInt(444, 8)
  }
  if (opts.writable) {
    dmode |= parseInt(333, 8)
    fmode |= parseInt(222, 8)
  }

  var utimesParent = function(name, cb) {
    var top
    while ((top = head(stack)) && name.slice(0, top[0].length) !== top[0]) stack.pop()
    if (!top) return cb()
    xfs.utimes(top[0], now, top[1], cb)
  }

  var utimes = function(name, header, cb) {
    if (opts.utimes === false) return cb()

    if (header.type === 'directory') return xfs.utimes(name, now, header.mtime, cb)
    if (header.type === 'symlink') return utimesParent(name, cb)

    xfs.utimes(name, now, header.mtime, function(err) {
      if (err) return cb(err)
      utimesParent(name, cb)
    })
  }

  var chperm = function(name, header, cb) {
    var link = header.type === 'symlink',
      chmod = link ? xfs.lchmod : xfs.chmod,
      chown = link ? xfs.lchown : xfs.chown

    if (!chmod) return cb()

    var mode = (header.mode | (header.type === 'directory' ? dmode : fmode)) & umask
    chmod(name, mode, function(err) {
      if (err) return cb(err)
      if (!own || !chown) return cb()
      chown(name, header.uid, header.gid, cb)
    })
  }

  extract.on('entry', function(header, stream, next) {
    (header = map(header) || header).name = normalize(header.name)
    var name = path.join(cwd, path.join('/', header.name))

    if (ignore(name, header)) {
      stream.resume()
      return next()
    }

    var stat = function(err) {
      if (err) return next(err)
      utimes(name, header, function(err) {
        if (err) return next(err)
        if (win32) return next()
        chperm(name, header, next)
      })
    }

    var onsymlink = function() {
      if (win32) return next()
      xfs.unlink(name, function() {
        xfs.symlink(header.linkname, name, stat)
      })
    }

    var onlink = function() {
      if (win32) return next()
      xfs.unlink(name, function() {
        var srcpath = path.join(cwd, path.join('/', header.linkname))

        xfs.link(srcpath, name, function(err) {
          if (err && err.code === 'EPERM' && opts.hardlinkAsFilesFallback) {
            stream = xfs.createReadStream(srcpath)
            return onfile()
          }

          stat(err)
        })
      })
    }

    var onfile = function() {
      var ws = xfs.createWriteStream(name),
        rs = mapStream(stream, header)

      ws.on('error', function(err) {
        rs.destroy(err)
      })

      pump(rs, ws, function(err) {
        if (err) return next(err)
        ws.on('close', stat)
      })
    }

    if (header.type === 'directory') {
      stack.push([name, header.mtime])
      return mkdirfix(name, {fs: xfs, own: own, uid: header.uid, gid: header.gid}, stat)
    }

    var dir = path.dirname(name)

    validate(xfs, dir, path.join(cwd, '.'), function(err, valid) {
      if (err) return next(err)
      if (!valid) return next(new Error(dir + ' is not a valid path'))

      mkdirfix(dir, {fs: xfs, own: own, uid: header.uid, gid: header.gid}, function(err) {
        if (err) return next(err)

        switch (header.type) {
          case 'file': return onfile()
          case 'link': return onlink()
          case 'symlink': return onsymlink()
        }

        if (strict) return next(new Error('unsupported type for ' + name + ' (' + header.type + ')'))

        stream.resume()
        next()
      })
    })
  })

  opts.finish && extract.on('finish', opts.finish)

  return extract
}

function validate(fs, name, root, cb) {
  if (name === root) return cb(null, true)
  fs.lstat(name, function(err, st) {
    if (err && err.code !== 'ENOENT') return cb(err)
    if (err || st.isDirectory()) return validate(fs, path.join(name, '..'), root, cb)
    cb(null, false)
  })
}

function mkdirfix(name, opts, cb) {
  mkdirp(name, {fs: opts.fs}, function(err, made) {
    !err && made && opts.own ? chownr(made, opts.uid, opts.gid, cb) : cb(err)
  })
}
//
},
chownr:
function(module, exports, __wpreq__) {
//
module.exports = chownr
chownr.sync = chownrSync

var fs = __wpreq__('fs'),
  path = __wpreq__('path')

function chownr(p, uid, gid, cb) {
  fs.readdir(p, function(er, children) {
    if (er && er.code !== "ENOTDIR") return cb(er)
    if (er || !children.length) return fs.chown(p, uid, gid, cb)

    var len = children.length,
      errState = null
    children.forEach(function(child) {
      var pathChild = path.resolve(p, child);
      fs.lstat(pathChild, function(er, stats) {
        if (er) return cb(er)
        stats.isSymbolicLink() ? then() : chownr(pathChild, uid, gid, then)
      })
    })
    function then(er) {
      if (!errState) return er ? cb((errState = er)) : --len == 0 ? fs.chown(p, uid, gid, cb) : void 0
    }
  })
}

function chownrSync(p, uid, gid) {
  var children
  try {
    children = fs.readdirSync(p)
  } catch (er) {
    if (er && er.code === "ENOTDIR") return fs.chownSync(p, uid, gid)
    throw er
  }
  if (!children.length) return fs.chownSync(p, uid, gid)

  children.forEach(function(child) {
    var pathChild = path.resolve(p, child)
    fs.lstatSync(pathChild).isSymbolicLink() || chownrSync(pathChild, uid, gid)
  })
  return fs.chownSync(p, uid, gid)
}
//
},
'tar-stream':
function(module, exports, __wpreq__) {
//
exports.extract = __wpreq__('tar-stream/extract')
exports.pack = __wpreq__('tar-stream/pack')
//
},
'tar-stream/extract':
function(module, exports, __wpreq__) {
//
var util = __wpreq__('util'),
  bl = __wpreq__('bl'),
  xtend = __wpreq__('xtend'),
  headers = __wpreq__('tar-stream/headers'),

  Writable = __wpreq__('readable-stream').Writable,
  PassThrough = __wpreq__('readable-stream').PassThrough,

  noop = function() {}

var overflow = function(size) {
  return (size &= 511) && 512 - size
}

var emptyStream = function(self, offset) {
  var s = new Source(self, offset)
  s.end()
  return s
}

var mixinPax = function(header, pax) {
  if (pax.path) header.name = pax.path
  if (pax.linkpath) header.linkname = pax.linkpath
  if (pax.size) header.size = parseInt(pax.size, 10)
  header.pax = pax
  return header
}

var Source = function(self, offset) {
  this._parent = self
  this.offset = offset
  PassThrough.call(this)
}

util.inherits(Source, PassThrough)

Source.prototype.destroy = function(err) {
  this._parent.destroy(err)
}

var Extract = function(opts) {
  if (!(this instanceof Extract)) return new Extract(opts)
  Writable.call(this, opts)

  opts = opts || {}

  this._offset = 0
  this._buffer = bl()
  this._missing = 0
  this._partial = false
  this._onparse = noop
  this._header = null
  this._stream = null
  this._overflow = null
  this._cb = null
  this._locked = false
  this._destroyed = false
  this._pax = null
  this._paxGlobal = null
  this._gnuLongPath = null
  this._gnuLongLinkPath = null

  var self = this,
    b = self._buffer

  var oncontinue = function() {
    self._continue()
  }

  var onunlock = function(err) {
    self._locked = false
    if (err) return self.destroy(err)
    self._stream || oncontinue()
  }

  var onstreamend = function() {
    self._stream = null
    var drain = overflow(self._header.size)
    drain ? self._parse(drain, ondrain) : self._parse(512, onheader)
    self._locked || oncontinue()
  }

  var ondrain = function() {
    self._buffer.consume(overflow(self._header.size))
    self._parse(512, onheader)
    oncontinue()
  }

  var onpaxglobalheader = function() {
    var size = self._header.size
    self._paxGlobal = headers.decodePax(b.slice(0, size))
    b.consume(size)
    onstreamend()
  }

  var onpaxheader = function() {
    var size = self._header.size
    self._pax = headers.decodePax(b.slice(0, size))
    if (self._paxGlobal) self._pax = xtend(self._paxGlobal, self._pax)
    b.consume(size)
    onstreamend()
  }

  var ongnulongpath = function() {
    var size = self._header.size
    self._gnuLongPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding)
    b.consume(size)
    onstreamend()
  }

  var ongnulonglinkpath = function() {
    var size = self._header.size
    self._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding)
    b.consume(size)
    onstreamend()
  }

  var onheader = function() {
    var header,
      offset = self._offset
    try {
      header = self._header = headers.decode(b.slice(0, 512), opts.filenameEncoding)
    } catch (err) {
      self.emit('error', err)
    }
    b.consume(512)

    if (!header) {
      self._parse(512, onheader)
      oncontinue()
      return
    }
    if (header.type === 'gnu-long-path') {
      self._parse(header.size, ongnulongpath)
      oncontinue()
      return
    }
    if (header.type === 'gnu-long-link-path') {
      self._parse(header.size, ongnulonglinkpath)
      oncontinue()
      return
    }
    if (header.type === 'pax-global-header') {
      self._parse(header.size, onpaxglobalheader)
      oncontinue()
      return
    }
    if (header.type === 'pax-header') {
      self._parse(header.size, onpaxheader)
      oncontinue()
      return
    }

    if (self._gnuLongPath) {
      header.name = self._gnuLongPath
      self._gnuLongPath = null
    }

    if (self._gnuLongLinkPath) {
      header.linkname = self._gnuLongLinkPath
      self._gnuLongLinkPath = null
    }

    if (self._pax) {
      self._header = header = mixinPax(header, self._pax)
      self._pax = null
    }

    self._locked = true

    if (!header.size || header.type === 'directory') {
      self._parse(512, onheader)
      self.emit('entry', header, emptyStream(self, offset), onunlock)
      return
    }

    self._stream = new Source(self, offset)

    self.emit('entry', header, self._stream, onunlock)
    self._parse(header.size, onstreamend)
    oncontinue()
  }

  this._onheader = onheader
  this._parse(512, onheader)
}

util.inherits(Extract, Writable)

Extract.prototype.destroy = function(err) {
  if (this._destroyed) return
  this._destroyed = true

  err && this.emit('error', err)
  this.emit('close')
  this._stream && this._stream.emit('close')
}

Extract.prototype._parse = function(size, onparse) {
  if (this._destroyed) return
  this._offset += size
  this._missing = size
  if (onparse === this._onheader) this._partial = false
  this._onparse = onparse
}

Extract.prototype._continue = function() {
  if (this._destroyed) return
  var cb = this._cb
  this._cb = noop
  this._overflow ? this._write(this._overflow, void 0, cb) : cb()
}

Extract.prototype._write = function(data, enc, cb) {
  if (this._destroyed) return

  var s = this._stream,
    b = this._buffer,
    missing = this._missing
  if (data.length) this._partial = true

  if (data.length < missing) {
    this._missing -= data.length
    this._overflow = null
    if (s) return s.write(data, cb)
    b.append(data)
    return cb()
  }

  this._cb = cb
  this._missing = 0

  var overflow = null
  if (data.length > missing) {
    overflow = data.slice(missing)
    data = data.slice(0, missing)
  }

  s ? s.end(data) : b.append(data)

  this._overflow = overflow
  this._onparse()
}

Extract.prototype._final = function(cb) {
  if (this._partial) return this.destroy(new Error('Unexpected end of data'))
  cb()
}

module.exports = Extract
//
},
bl:
function(module, exports, __wpreq__) {
//
var DuplexStream = __wpreq__('readable-stream/duplex'),
  util = __wpreq__('util'),
  Buffer = __wpreq__('safe-buffer').Buffer

function BufferList(callback) {
  if (!(this instanceof BufferList)) return new BufferList(callback)

  this._bufs = []
  this.length = 0

  if (typeof callback == 'function') {
    this._callback = callback

    var piper = function(err) {
      if (this._callback) {
        this._callback(err)
        this._callback = null
      }
    }.bind(this)

    this.on('pipe', function(src) {
      src.on('error', piper)
    })
    this.on('unpipe', function(src) {
      src.removeListener('error', piper)
    })
  } else this.append(callback)

  DuplexStream.call(this)
}

util.inherits(BufferList, DuplexStream)

BufferList.prototype._offset = function(offset) {
  if (offset === 0) return [0, 0]
  for (var _t, tot = 0, i = 0; i < this._bufs.length; i++) {
    if (offset < (_t = tot + this._bufs[i].length) || i == this._bufs.length - 1) return [i, offset - tot]
    tot = _t
  }
}

BufferList.prototype.append = function(buf) {
  var i = 0

  if (Buffer.isBuffer(buf)) this._appendBuffer(buf);
  else if (Array.isArray(buf)) for (; i < buf.length; i++) this.append(buf[i])
  else if (buf instanceof BufferList) for (; i < buf._bufs.length; i++) this.append(buf._bufs[i])
  else if (buf != null) {
    if (typeof buf == 'number') buf = buf.toString()

    this._appendBuffer(Buffer.from(buf));
  }

  return this
}

BufferList.prototype._appendBuffer = function(buf) {
  this._bufs.push(buf)
  this.length += buf.length
}

BufferList.prototype._write = function(buf, encoding, callback) {
  this._appendBuffer(buf)

  typeof callback != 'function' || callback()
}

BufferList.prototype._read = function(size) {
  if (!this.length) return this.push(null)

  size = Math.min(size, this.length)
  this.push(this.slice(0, size))
  this.consume(size)
}

BufferList.prototype.end = function(chunk) {
  DuplexStream.prototype.end.call(this, chunk)

  if (this._callback) {
    this._callback(null, this.slice())
    this._callback = null
  }
}

BufferList.prototype.get = function(index) {
  return this.slice(index, index + 1)[0]
}

BufferList.prototype.slice = function(start, end) {
  if (typeof start == 'number' && start < 0) start += this.length
  if (typeof end == 'number' && end < 0) end += this.length
  return this.copy(null, 0, start, end)
}

BufferList.prototype.copy = function(dst, dstStart, srcStart, srcEnd) {
  if (typeof srcStart != 'number' || srcStart < 0) srcStart = 0
  if (typeof srcEnd != 'number' || srcEnd > this.length) srcEnd = this.length
  if (srcStart >= this.length) return dst || Buffer.alloc(0)
  if (srcEnd <= 0) return dst || Buffer.alloc(0)

  var l,
    i,
    copy = !!dst,
    off = this._offset(srcStart),
    len = srcEnd - srcStart,
    bytes = len,
    bufoff = (copy && dstStart) || 0,
    start = off[1]

  if (srcStart === 0 && srcEnd == this.length) {
    if (!copy) return this._bufs.length === 1 ? this._bufs[0] : Buffer.concat(this._bufs, this.length)

    for (i = 0; i < this._bufs.length; i++) {
      this._bufs[i].copy(dst, bufoff)
      bufoff += this._bufs[i].length
    }

    return dst
  }

  if (bytes <= this._bufs[off[0]].length - start)
    return copy
      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
      : this._bufs[off[0]].slice(start, start + bytes)

  copy || (dst = Buffer.allocUnsafe(len))

  for (i = off[0]; i < this._bufs.length; i++) {
    if (bytes <= (l = this._bufs[i].length - start)) {
      this._bufs[i].copy(dst, bufoff, start, start + bytes)
      break
    }
    this._bufs[i].copy(dst, bufoff, start)

    bufoff += l
    bytes -= l

    if (start) start = 0
  }

  return dst
}

BufferList.prototype.shallowSlice = function(start, end) {
  start = start || 0
  end = end || this.length

  if (start < 0) start += this.length
  if (end < 0) end += this.length

  var startOffset = this._offset(start),
    endOffset = this._offset(end),
    buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1)

  endOffset[1] == 0
    ? buffers.pop()
    : (buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]))

  if (startOffset[1] != 0) buffers[0] = buffers[0].slice(startOffset[1])

  return new BufferList(buffers)
}

BufferList.prototype.toString = function(encoding, start, end) {
  return this.slice(start, end).toString(encoding)
}

BufferList.prototype.consume = function(bytes) {
  while (this._bufs.length) {
    if (bytes < this._bufs[0].length) {
      this._bufs[0] = this._bufs[0].slice(bytes)
      this.length -= bytes
      break
    }

    bytes -= this._bufs[0].length
    this.length -= this._bufs[0].length
    this._bufs.shift()
  }
  return this
}

BufferList.prototype.duplicate = function() {
  var copy = new BufferList()

  for (var i = 0; i < this._bufs.length; i++) copy.append(this._bufs[i])

  return copy
}

BufferList.prototype.destroy = function() {
  this._bufs.length = 0
  this.length = 0
  this.push(null)
}

!(function() {
  var methods = {
    readDoubleBE: 8,
    readDoubleLE: 8,
    readFloatBE: 4,
    readFloatLE: 4,
    readInt32BE: 4,
    readInt32LE: 4,
    readUInt32BE: 4,
    readUInt32LE: 4,
    readInt16BE: 2,
    readInt16LE: 2,
    readUInt16BE: 2,
    readUInt16LE: 2,
    readInt8: 1,
    readUInt8: 1
  }

  for (var m in methods)
    !(function(m) {
      BufferList.prototype[m] = function(offset) {
        return this.slice(offset, offset + methods[m])[m](0)
      }
    })(m)
})()

module.exports = BufferList
//
},
'readable-stream/duplex':
function(module, exports, __wpreq__) {
//
module.exports = __wpreq__('readable-stream').Duplex
//
},
'readable-stream':
function(module, exports, __wpreq__) {
//
var Stream = __wpreq__('stream');
if (process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream;
  exports = module.exports = Stream.Readable;
  exports.Readable = Stream.Readable;
  exports.Writable = Stream.Writable;
  exports.Duplex = Stream.Duplex;
  exports.Transform = Stream.Transform;
  exports.PassThrough = Stream.PassThrough;
  exports.Stream = Stream;
} else {
  exports = module.exports = __wpreq__('readable-stream/lib/_stream_readable');
  exports.Stream = Stream || exports;
  exports.Readable = exports;
  exports.Writable = __wpreq__('readable-stream/lib/_stream_writable');
  exports.Duplex = __wpreq__('readable-stream/lib/_stream_duplex');
  exports.Transform = __wpreq__('readable-stream/lib/_stream_transform');
  exports.PassThrough = __wpreq__('readable-stream/lib/_stream_passthrough');
}
//
},
'readable-stream/lib/_stream_readable':
function(module, exports, __wpreq__) {
//
var pna = process;

module.exports = Readable;

var Duplex,
  isArray = __wpreq__('isarray');

Readable.ReadableState = ReadableState;

var EElistenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};

var Stream = __wpreq__('stream'),

  Buffer = __wpreq__('safe-buffer').Buffer,
  OurUint8Array = global.Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var util = __wpreq__('util'),

  debug = util && util.debuglog ? util.debuglog('stream') : function() {};

var StringDecoder,
  BufferList = __wpreq__('readable-stream/lib/internal/streams/BufferList'),
  destroyImpl = __wpreq__('readable-stream/lib/internal/streams/destroy');

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  if (typeof emitter.prependListener == 'function') return emitter.prependListener(event, fn);

  emitter._events && emitter._events[event]
    ? isArray(emitter._events[event])
      ? emitter._events[event].unshift(fn)
      : (emitter._events[event] = [fn, emitter._events[event]])
    : emitter.on(event, fn);
}

function ReadableState(options, stream) {
  options = options || {};

  var isDuplex = stream instanceof (Duplex = Duplex || __wpreq__('readable-stream/lib/_stream_duplex'));

  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  var hwm = options.highWaterMark,
    readableHwm = options.readableHighWaterMark,
    defaultHwm = this.objectMode ? 16 : 16384;

  this.highWaterMark =
    hwm || hwm === 0 ? hwm : isDuplex && (readableHwm || readableHwm === 0) ? readableHwm : defaultHwm;

  this.highWaterMark = Math.floor(this.highWaterMark);

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  this.sync = true;

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  this.destroyed = false;

  this.defaultEncoding = options.defaultEncoding || 'utf8';

  this.awaitDrain = 0;

  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    StringDecoder || (StringDecoder = __wpreq__('string_decoder').StringDecoder);
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __wpreq__('readable-stream/lib/_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  this.readable = true;

  if (options) {
    if (typeof options.read == 'function') this._read = options.read;

    if (typeof options.destroy == 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function() {
    return this._readableState !== void 0 && this._readableState.destroyed;
  },
  set: function(value) {
    if (this._readableState) this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function(err, cb) {
  this.push(null);
  cb(err);
};

Readable.prototype.push = function(chunk, encoding) {
  var skipChunkCheck,
    state = this._readableState;

  if (state.objectMode) skipChunkCheck = true;
  else if (typeof chunk == 'string') {
    if ((encoding = encoding || state.defaultEncoding) !== state.encoding) {
      chunk = Buffer.from(chunk, encoding);
      encoding = '';
    }
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

Readable.prototype.unshift = function(chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    skipChunkCheck || (er = chunkInvalid(state, chunk));
    if (er) stream.emit('error', er);
    else if (state.objectMode || (chunk && chunk.length > 0)) {
      typeof chunk == 'string' || state.objectMode || Object.getPrototypeOf(chunk) === Buffer.prototype ||
        (chunk = _uint8ArrayToBuffer(chunk));

      if (addToFront)
        state.endEmitted
          ? stream.emit('error', new Error('stream.unshift() after end event'))
          : addChunk(stream, state, chunk, true);
      else if (state.ended) stream.emit('error', new Error('stream.push() after EOF'));
      else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          state.objectMode || chunk.length > 0 ? addChunk(stream, state, chunk, false) : maybeReadMore(stream, state);
        } else addChunk(stream, state, chunk, false);
      }
    } else addToFront || (state.reading = false);
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    state.length += state.objectMode ? 1 : chunk.length;
    addToFront ? state.buffer.unshift(chunk) : state.buffer.push(chunk);

    state.needReadable && emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  _isUint8Array(chunk) || typeof chunk == 'string' || chunk === void 0 || state.objectMode ||
    (er = new TypeError('Invalid non-string/buffer chunk'));

  return er;
}

function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function() {
  return this._readableState.flowing === false;
};

Readable.prototype.setEncoding = function(enc) {
  StringDecoder || (StringDecoder = __wpreq__('string_decoder').StringDecoder);
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) n = MAX_HWM;
  else {
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (n <= 0 || (state.length === 0 && state.ended)) return 0;
  if (state.objectMode) return 1;
  if (n !== n) return state.flowing && state.length ? state.buffer.head.data.length : state.length;

  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

Readable.prototype.read = function(n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState,
    nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    state.length === 0 && state.ended ? endReadable(this) : emitReadable(this);
    return null;
  }

  if ((n = howMuchToRead(n, state)) === 0 && state.ended) {
    state.length !== 0 || endReadable(this);
    return null;
  }

  var doRead = state.needReadable;
  debug('need readable', doRead);

  if (state.length === 0 || state.length - n < state.highWaterMark)
    debug('length less than watermark', (doRead = true));

  if (state.ended || state.reading) debug('reading or ended', (doRead = false));
  else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    if (state.length === 0) state.needReadable = true;
    this._read(state.highWaterMark);
    state.sync = false;
    state.reading || (n = howMuchToRead(nOrig, state));
  }

  var ret = n > 0 ? fromList(n, state) : null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else state.length -= n;

  if (state.length === 0) {
    state.ended || (state.needReadable = true);

    nOrig !== n && state.ended && endReadable(this);
  }

  ret === null || this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  emitReadable(stream);
}

function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    state.sync ? pna.nextTick(emitReadable_, stream) : emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) break;
    len = state.length;
  }
  state.readingMore = false;
}

Readable.prototype._read = function(n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this,
    state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var endFn =
    (pipeOpts && pipeOpts.end === false) || dest === process.stdout || dest === process.stderr ? unpipe : onend;

  state.endEmitted ? pna.nextTick(endFn) : src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src && unpipeInfo && unpipeInfo.hasUnpiped === false) {
      unpipeInfo.hasUnpiped = true;
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    !state.awaitDrain || (dest._writableState && !dest._writableState.needDrain) || ondrain();
  }

  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    if (false === dest.write(chunk) && !increasedAwaitDrain) {
      if (
        ((state.pipesCount === 1 && state.pipes === dest) || (state.pipesCount > 1 && indexOf(state.pipes, dest) > -1)) &&
        !cleanedUp
      ) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    EElistenerCount(dest, 'error') !== 0 || dest.emit('error', er);
  }

  prependListener(dest, 'error', onerror);

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  dest.emit('pipe', src);

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    state.awaitDrain && state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function(dest) {
  var state = this._readableState,
    unpipeInfo = {hasUnpiped: false};

  if (state.pipesCount === 0) return this;

  if (state.pipesCount === 1) {
    if (dest && dest !== state.pipes) return this;

    dest || (dest = state.pipes);

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    dest && dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  if (!dest) {
    var dests = state.pipes,
      len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {hasUnpiped: false});
    return this;
  }

  var index = indexOf(state.pipes, dest);
  if (index < 0) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') this._readableState.flowing === false || this.resume();
  else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      state.reading ? state.length && emitReadable(this) : pna.nextTick(nReadingNextTick, this);
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  !state.flowing || state.reading || stream.read(0);
}

Readable.prototype.pause = function() {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null);
}

Readable.prototype.wrap = function(stream) {
  var _this = this,

    state = this._readableState,
    paused = false;

  stream.on('end', function() {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      chunk && chunk.length && _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function(chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    if (
      (!state.objectMode || (chunk !== null && chunk !== void 0)) &&
      (state.objectMode || (chunk && chunk.length)) &&
      !_this.push(chunk)
    ) {
      paused = true;
      stream.pause();
    }
  });

  for (var i in stream)
    if (this[i] === void 0 && typeof stream[i] == 'function')
      this[i] = (function(method) {
        return function() {
          return stream[method].apply(stream, arguments);
        };
      })(i);

  for (var n = 0; n < kProxyEvents.length; n++) stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));

  this._read = function(n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  enumerable: false,
  get: function() {
    return this._readableState.highWaterMark;
  }
});

Readable._fromList = fromList;

function fromList(n, state) {
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();
  else if (!n || n >= state.length) {
    ret = state.decoder ? state.buffer.join('')
      : state.buffer.length === 1 ? state.buffer.head.data
      : state.buffer.concat(state.length);
    state.buffer.clear();
  } else ret = fromListPartial(n, state.buffer, state.decoder);

  return ret;
}

function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else ret =
    n === list.head.data.length ? list.shift() : hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);

  return ret;
}

function copyFromBufferString(n, list) {
  var p = list.head,
    c = 1,
    ret = p.data;
  n -= ret.length;
  while ((p = p.next)) {
    var str = p.data,
      nb = n > str.length ? str.length : n;
    nb === str.length ? (ret += str) : (ret += str.slice(0, n));
    if ((n -= nb) == 0) {
      if (nb === str.length) {
        ++c;
        p.next ? (list.head = p.next) : (list.head = list.tail = null);
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n),
    p = list.head,
    c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while ((p = p.next)) {
    var buf = p.data,
      nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    if ((n -= nb) == 0) {
      if (nb === buf.length) {
        ++c;
        p.next ? (list.head = p.next) : (list.head = list.tail = null);
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) if (xs[i] === x) return i;

  return -1;
}
//
},
'safe-buffer':
function(module, exports, __wpreq__) {
//
var buffer = __wpreq__('buffer'),
  Buffer = buffer.Buffer

function copyProps(src, dst) {
  for (var key in src) dst[key] = src[key]
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) module.exports = buffer
else {
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function(arg, encodingOrOffset, length) {
  if (typeof arg == 'number') throw new TypeError('Argument must not be a number')

  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function(size, fill, encoding) {
  if (typeof size != 'number') throw new TypeError('Argument must be a number')

  var buf = Buffer(size)
  fill === void 0 ? buf.fill(0) : typeof encoding == 'string' ? buf.fill(fill, encoding) : buf.fill(fill)

  return buf
}

SafeBuffer.allocUnsafe = function(size) {
  if (typeof size != 'number') throw new TypeError('Argument must be a number')

  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function(size) {
  if (typeof size != 'number') throw new TypeError('Argument must be a number')

  return buffer.SlowBuffer(size)
}
//
},
'readable-stream/lib/internal/streams/BufferList':
function(module, exports, __wpreq__) {
//
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}

var Buffer = __wpreq__('safe-buffer').Buffer,
  util = __wpreq__('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = (function() {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function(v) {
    var entry = {data: v, next: null};
    this.length > 0 ? (this.tail.next = entry) : (this.head = entry);
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function(v) {
    var entry = {data: v, next: this.head};
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function() {
    if (this.length === 0) return;
    var ret = this.head.data;
    this.length === 1 ? (this.head = this.tail = null) : (this.head = this.head.next);
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function(s) {
    if (this.length === 0) return '';
    var p = this.head,
      ret = '' + p.data;
    while ((p = p.next)) ret += s + p.data;
    return ret;
  };

  BufferList.prototype.concat = function(n) {
    if (this.length === 0) return Buffer.alloc(0);
    var ret = Buffer.allocUnsafe(n >>> 0);
    for (var p = this.head, i = 0; p; ) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
})();

if (util && util.inspect && util.inspect.custom)
  module.exports.prototype[util.inspect.custom] = function() {
    var obj = util.inspect({length: this.length});
    return this.constructor.name + ' ' + obj;
  };
//
},
'readable-stream/lib/internal/streams/destroy':
function(module) {
//
var pna = process;

function destroy(err, cb) {
  var _this = this,

    readableDestroyed = this._readableState && this._readableState.destroyed,
    writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) cb(err);
    else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      if (this._writableState) this._writableState.errorEmitted = true;
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  if (this._readableState) this._readableState.destroyed = true;

  if (this._writableState) this._writableState.destroyed = true;

  this._destroy(err || null, function(err) {
    if (cb) cb(err);
    else if (err && (!_this._writableState || !_this._writableState.errorEmitted)) {
      if (_this._writableState) _this._writableState.errorEmitted = true;

      pna.nextTick(emitErrorNT, _this, err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
//
},
'readable-stream/lib/_stream_duplex':
function(module, exports, __wpreq__) {
//
var pna = process,

  objectKeys = Object.keys;

module.exports = Duplex;

var util = __wpreq__('util'),

  Readable = __wpreq__('readable-stream/lib/_stream_readable'),
  Writable = __wpreq__('readable-stream/lib/_stream_writable');

util.inherits(Duplex, Readable);

for (var keys = objectKeys(Writable.prototype), v = 0; v < keys.length; v++) {
  var method = keys[v];
  Duplex.prototype[method] || (Duplex.prototype[method] = Writable.prototype[method]);
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = !options || options.allowHalfOpen !== false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  enumerable: false,
  get: function() {
    return this._writableState.highWaterMark;
  }
});

function onend() {
  this.allowHalfOpen || this._writableState.ended || pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function() {
    return (
      this._readableState !== void 0 && this._writableState !== void 0 &&
      this._readableState.destroyed && this._writableState.destroyed
    );
  },
  set: function(value) {
    if (this._readableState === void 0 || this._writableState === void 0) return;

    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function(err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
//
},
'readable-stream/lib/_stream_writable':
function(module, exports, __wpreq__) {
//
var pna = process;

module.exports = Writable;

function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function() {
    onCorkedFinish(_this, state);
  };
}

var Duplex,
  asyncWrite = !process.browser && /^v?0\.(10|9)\b/.test(process.version) ? setImmediate : pna.nextTick;

Writable.WritableState = WritableState;

var util = __wpreq__('util'),

  Stream = __wpreq__('stream'),

  Buffer = __wpreq__('safe-buffer').Buffer,
  OurUint8Array = global.Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = __wpreq__('readable-stream/lib/internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __wpreq__('readable-stream/lib/_stream_duplex');

  options = options || {};

  var isDuplex = stream instanceof Duplex;

  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  var hwm = options.highWaterMark,
    writableHwm = options.writableHighWaterMark,
    defaultHwm = this.objectMode ? 16 : 16384;

  this.highWaterMark =
    hwm || hwm === 0 ? hwm : isDuplex && (writableHwm || writableHwm === 0) ? writableHwm : defaultHwm;

  this.highWaterMark = Math.floor(this.highWaterMark);

  this.finalCalled = false;

  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;

  this.destroyed = false;

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  this.defaultEncoding = options.defaultEncoding || 'utf8';

  this.length = 0;

  this.writing = false;

  this.corked = 0;

  this.sync = true;

  this.bufferProcessing = false;

  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  this.writecb = null;

  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  this.pendingcb = 0;

  this.prefinished = false;

  this.errorEmitted = false;

  this.bufferedRequestCount = 0;

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function() {
  var out = [];
  for (var current = this.bufferedRequest; current; ) {
    out.push(current);
    current = current.next;
  }
  return out;
};

!(function() {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: util.deprecate(function() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer instead.', 'DEP0003')
    });
  } catch (_) {}
})();

var realHasInstance;
if (typeof Symbol == 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function(object) {
      return (
        !!realHasInstance.call(this, object) ||
        (this === Writable && object && object._writableState instanceof WritableState)
      );
    }
  });
} else
  realHasInstance = function(object) {
    return object instanceof this;
  };

function Writable(options) {
  Duplex = Duplex || __wpreq__('readable-stream/lib/_stream_duplex');

  if (!(realHasInstance.call(Writable, this) || this instanceof Duplex)) return new Writable(options);

  this._writableState = new WritableState(options, this);

  this.writable = true;

  if (options) {
    if (typeof options.write == 'function') this._write = options.write;

    if (typeof options.writev == 'function') this._writev = options.writev;

    if (typeof options.destroy == 'function') this._destroy = options.destroy;

    if (typeof options.final == 'function') this._final = options.final;
  }

  Stream.call(this);
}

Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

function validChunk(stream, state, chunk, cb) {
  var valid = true,
    er = false;

  chunk === null
    ? (er = new TypeError('May not write null values to stream'))
    : typeof chunk == 'string' || chunk === void 0 || state.objectMode ||
      (er = new TypeError('Invalid non-string/buffer chunk'));

  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState,
    ret = false,
    isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) chunk = _uint8ArrayToBuffer(chunk);

  if (typeof encoding == 'function') {
    cb = encoding;
    encoding = null;
  }

  isBuf ? (encoding = 'buffer') : encoding || (encoding = state.defaultEncoding);

  if (typeof cb != 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);
  else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function() {
  this._writableState.corked++;
};

Writable.prototype.uncork = function() {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    state.writing || state.corked || state.bufferProcessing || !state.bufferedRequest || clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function(encoding) {
  if (typeof encoding == 'string') encoding = encoding.toLowerCase();
  if (
    ['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf(
      (encoding + '').toLowerCase()
    ) < 0
  )
    throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  state.objectMode || state.decodeStrings === false || typeof chunk != 'string' ||
    (chunk = Buffer.from(chunk, encoding));

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  enumerable: false,
  get: function() {
    return this._writableState.highWaterMark;
  }
});

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  ret || (state.needDrain = true);

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {chunk: chunk, encoding: encoding, isBuf: isBuf, callback: cb, next: null};
    last ? (last.next = state.lastBufferedRequest) : (state.bufferedRequest = state.lastBufferedRequest);

    state.bufferedRequestCount += 1;
  } else doWrite(stream, state, false, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  writev ? stream._writev(chunk, state.onwrite) : stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    pna.nextTick(cb, er);
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState,
    sync = state.sync,
    cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);
  else {
    var finished = needFinish(state);

    finished || state.corked || state.bufferProcessing || !state.bufferedRequest || clearBuffer(stream, state);

    sync ? asyncWrite(afterWrite, stream, state, finished, cb) : afterWrite(stream, state, finished, cb);
  }
}

function afterWrite(stream, state, finished, cb) {
  finished || onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    var l = state.bufferedRequestCount,
      buffer = new Array(l),
      holder = state.corkedRequestsFree;
    holder.entry = entry;

    var allBuffers = true;
    for (var count = 0; entry; ) {
      buffer[count] = entry;
      entry.isBuf || (allBuffers = false);
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else state.corkedRequestsFree = new CorkedRequest(state);

    state.bufferedRequestCount = 0;
  } else {
    while (entry) {
      var chunk = entry.chunk,
        encoding = entry.encoding,
        cb = entry.callback;

      doWrite(stream, state, false, state.objectMode ? 1 : chunk.length, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      if (state.writing) break;
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk == 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding == 'function') {
    cb = encoding;
    encoding = null;
  }

  chunk === null || chunk === void 0 || this.write(chunk, encoding);

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  state.ending || endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function(err) {
    state.pendingcb--;
    err && stream.emit('error', err);

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (state.prefinished || state.finalCalled) return;

  if (typeof stream._final == 'function') {
    state.pendingcb++;
    state.finalCalled = true;
    pna.nextTick(callFinal, stream, state);
  } else {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) state.finished ? pna.nextTick(cb) : stream.once('finish', cb);

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function() {
    return this._writableState !== void 0 && this._writableState.destroyed;
  },
  set: function(value) {
    if (this._writableState) this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function(err, cb) {
  this.end();
  cb(err);
};
//
},
'util-deprecate':
function(module, exports, __wpreq__) {
//
module.exports = __wpreq__('util').deprecate;
//
},
'string_decoder/':
function(module, exports, __wpreq__) {
//
var Buffer = __wpreq__('safe-buffer').Buffer;

var isEncoding = Buffer.isEncoding || function(encoding) {
  switch (!(encoding = '' + encoding) || encoding.toLowerCase()) {
    case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64':
    case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  for (var retried; ; )
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return;
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
}

function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc != 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc)))
    throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function(buf) {
  if (buf.length === 0) return '';
  var r, i;
  if (this.lastNeed) {
    if ((r = this.fillLast(buf)) === void 0) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else i = 0;

  return i < buf.length ? (r ? r + this.text(buf, i) : this.text(buf, i)) : r || '';
};

StringDecoder.prototype.end = utf8End;

StringDecoder.prototype.text = utf8Text;

StringDecoder.prototype.fillLast = function(buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

function utf8CheckByte(byte) {
  return byte <= 0x7F ? 0
    : byte >> 5 == 0x06 ? 2
    : byte >> 4 == 0x0E ? 3
    : byte >> 3 == 0x1E ? 4
    : byte >> 6 == 0x02 ? -1 : -2;
}

function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  if ((nb = utf8CheckByte(buf[j])) >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  if ((nb = utf8CheckByte(buf[j])) >= 0) {
    if (nb > 0) nb === 2 ? (nb = 0) : (self.lastNeed = nb - 3);

    return nb;
  }
  return 0;
}

function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) != 0x80) {
    self.lastNeed = 0;
    return '';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) != 0x80) {
      self.lastNeed = 1;
      return '';
    }
    if (self.lastNeed > 2 && buf.length > 2 && (buf[2] & 0xC0) != 0x80) {
      self.lastNeed = 2;
      return '';
    }
  }
}

function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed,
    r = utf8CheckExtraBytes(this, buf, p);
  if (r !== void 0) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  return this.lastNeed ? r + '' : r;
}

function utf16Text(buf, i) {
  if ((buf.length - i) % 2 == 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) this.lastChar[0] = buf[buf.length - 1];
  else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  return this.lastNeed ? r + this.lastChar.toString('base64', 0, 3 - this.lastNeed) : r;
}

function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
//
},
'readable-stream/lib/_stream_transform':
function(module, exports, __wpreq__) {
//
module.exports = Transform;

var Duplex = __wpreq__('readable-stream/lib/_stream_duplex');

__wpreq__('util').inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) return this.emit('error', new Error('write callback called multiple times'));

  ts.writechunk = null;
  ts.writecb = null;

  data == null || this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  this._readableState.needReadable = true;

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform == 'function') this._transform = options.transform;

    if (typeof options.flush == 'function') this._flush = options.flush;
  }

  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  typeof this._flush == 'function'
    ? this._flush(function(er, data) {
        done(_this, er, data);
      })
    : done(this, null, null);
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else ts.needTransform = true;
};

Transform.prototype._destroy = function(err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function(err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  data == null || stream.push(data);

  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
//
},
'readable-stream/lib/_stream_passthrough':
function(module, exports, __wpreq__) {
//
module.exports = PassThrough;

var Transform = __wpreq__('readable-stream/lib/_stream_transform');

__wpreq__('util').inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
//
},
xtend:
function(module) {
//
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
  var target = {}

  for (var i = 0; i < arguments.length; i++) {
    var source = arguments[i]

    for (var key in source) if (hasOwnProperty.call(source, key)) target[key] = source[key]
  }

  return target
}
//
},
'tar-stream/headers':
function(module, exports, __wpreq__) {
//
var toBuffer = __wpreq__('to-buffer'),
  alloc = __wpreq__('buffer-alloc'),

  ZEROS = '0000000000000000000',
  SEVENS = '7777777777777777777',
  ZERO_OFFSET = '0'.charCodeAt(0),
  USTAR = 'ustar\x0000',
  MASK = parseInt('7777', 8)

var clamp = function(index, len, defaultValue) {
  return typeof index != 'number'
    ? defaultValue
    : (index = ~~index) >= len
    ? len
    : index >= 0 || (index += len) >= 0
    ? index
    : 0
}

var toType = function(flag) {
  switch (flag) {
    case 0:
      return 'file'
    case 1:
      return 'link'
    case 2:
      return 'symlink'
    case 3:
      return 'character-device'
    case 4:
      return 'block-device'
    case 5:
      return 'directory'
    case 6:
      return 'fifo'
    case 7:
      return 'contiguous-file'
    case 72:
      return 'pax-header'
    case 55:
      return 'pax-global-header'
    case 27:
      return 'gnu-long-link-path'
    case 28:
    case 30:
      return 'gnu-long-path'
  }

  return null
}

var toTypeflag = function(flag) {
  switch (flag) {
    case 'file':
      return 0
    case 'link':
      return 1
    case 'symlink':
      return 2
    case 'character-device':
      return 3
    case 'block-device':
      return 4
    case 'directory':
      return 5
    case 'fifo':
      return 6
    case 'contiguous-file':
      return 7
    case 'pax-header':
      return 72
  }

  return 0
}

var indexOf = function(block, num, offset, end) {
  for (; offset < end; offset++) if (block[offset] === num) return offset

  return end
}

var cksum = function(block) {
  var sum = 256
  for (var i = 0; i < 148; i++) sum += block[i]
  for (var j = 156; j < 512; j++) sum += block[j]
  return sum
}

var encodeOct = function(val, n) {
  return (val = val.toString(8)).length > n ? SEVENS.slice(0, n) + ' ' : ZEROS.slice(0, n - val.length) + val + ' '
}

function parse256(buf) {
  var positive
  if (buf[0] === 0x80) positive = true
  else if (buf[0] === 0xFF) positive = false
  else return null

  var tuple = []
  for (var zero = false, i = buf.length - 1; i > 0; i--) {
    var byte = buf[i]
    if (positive) tuple.push(byte)
    else if (zero && byte === 0) tuple.push(0)
    else if (zero) {
      zero = false
      tuple.push(0x100 - byte)
    } else tuple.push(0xFF - byte)
  }

  var sum = 0,
    l = tuple.length
  for (i = 0; i < l; i++) sum += tuple[i] * Math.pow(256, i)

  return positive ? sum : -1 * sum
}

var decodeOct = function(val, offset, length) {
  if ((val = val.slice(offset, offset + length))[(offset = 0)] & 0x80) return parse256(val)

  while (offset < val.length && val[offset] === 32) offset++
  var end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length)
  while (offset < end && val[offset] === 0) offset++
  return end === offset ? 0 : parseInt(val.slice(offset, end).toString(), 8)
}

var decodeStr = function(val, offset, length, encoding) {
  return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding)
}

var addLength = function(str) {
  var len = Buffer.byteLength(str),
    digits = Math.floor(Math.log(len) / Math.log(10)) + 1
  len + digits >= Math.pow(10, digits) && digits++

  return len + digits + str
}

exports.decodeLongPath = function(buf, encoding) {
  return decodeStr(buf, 0, buf.length, encoding)
}

exports.encodePax = function(opts) {
  var result = ''
  if (opts.name) result += addLength(' path=' + opts.name + '\n')
  if (opts.linkname) result += addLength(' linkpath=' + opts.linkname + '\n')
  var pax = opts.pax
  if (pax) for (var key in pax) result += addLength(' ' + key + '=' + pax[key] + '\n')

  return toBuffer(result)
}

exports.decodePax = function(buf) {
  var result = {}

  while (buf.length) {
    var i = 0
    while (i < buf.length && buf[i] !== 32) i++
    var len = parseInt(buf.slice(0, i).toString(), 10)
    if (!len) return result

    var b = buf.slice(i + 1, len - 1).toString(),
      keyIndex = b.indexOf('=')
    if (keyIndex < 0) return result
    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1)

    buf = buf.slice(len)
  }

  return result
}

exports.encode = function(opts) {
  var buf = alloc(512),
    name = opts.name,
    prefix = ''

  if (opts.typeflag === 5 && name[name.length - 1] !== '/') name += '/'
  if (Buffer.byteLength(name) !== name.length) return null

  while (Buffer.byteLength(name) > 100) {
    var i = name.indexOf('/')
    if (i < 0) return null
    prefix += prefix ? '/' + name.slice(0, i) : name.slice(0, i)
    name = name.slice(i + 1)
  }

  if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155) return null
  if (opts.linkname && Buffer.byteLength(opts.linkname) > 100) return null

  buf.write(name)
  buf.write(encodeOct(opts.mode & MASK, 6), 100)
  buf.write(encodeOct(opts.uid, 6), 108)
  buf.write(encodeOct(opts.gid, 6), 116)
  buf.write(encodeOct(opts.size, 11), 124)
  buf.write(encodeOct((opts.mtime.getTime() / 1000) | 0, 11), 136)

  buf[156] = ZERO_OFFSET + toTypeflag(opts.type)

  opts.linkname && buf.write(opts.linkname, 157)

  buf.write(USTAR, 257)
  opts.uname && buf.write(opts.uname, 265)
  opts.gname && buf.write(opts.gname, 297)
  buf.write(encodeOct(opts.devmajor || 0, 6), 329)
  buf.write(encodeOct(opts.devminor || 0, 6), 337)

  prefix && buf.write(prefix, 345)

  buf.write(encodeOct(cksum(buf), 6), 148)

  return buf
}

exports.decode = function(buf, filenameEncoding) {
  var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET,

    name = decodeStr(buf, 0, 100, filenameEncoding),
    mode = decodeOct(buf, 100, 8),
    uid = decodeOct(buf, 108, 8),
    gid = decodeOct(buf, 116, 8),
    size = decodeOct(buf, 124, 12),
    mtime = decodeOct(buf, 136, 12),
    type = toType(typeflag),
    linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding),
    uname = decodeStr(buf, 265, 32),
    gname = decodeStr(buf, 297, 32),
    devmajor = decodeOct(buf, 329, 8),
    devminor = decodeOct(buf, 337, 8)

  if (buf[345]) name = decodeStr(buf, 345, 155, filenameEncoding) + '/' + name

  if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5

  var c = cksum(buf)

  if (c === 256) return null

  if (c !== decodeOct(buf, 148, 8))
    throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?')

  return {
    name: name,
    mode: mode,
    uid: uid,
    gid: gid,
    size: size,
    mtime: new Date(1000 * mtime),
    type: type,
    linkname: linkname,
    uname: uname,
    gname: gname,
    devmajor: devmajor,
    devminor: devminor
  }
}
//
},
'to-buffer':
function(module) {
//
module.exports = toBuffer

// noinspection JSIncompatibleTypesComparison
var makeBuffer = Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from : bufferFrom

function bufferFrom(buf, enc) {
  return new Buffer(buf, enc)
}

function toBuffer(buf, enc) {
  if (Buffer.isBuffer(buf)) return buf
  if (typeof buf == 'string') return makeBuffer(buf, enc)
  if (Array.isArray(buf)) return makeBuffer(buf)
  throw new Error('Input should be a buffer or a string')
}
//
},
'buffer-alloc':
function(module, exports, __wpreq__) {
//
var bufferFill = __wpreq__('buffer-fill'),
  allocUnsafe = __wpreq__('buffer-alloc-unsafe')

module.exports = function(size, fill, encoding) {
  if (typeof size != 'number') throw new TypeError('"size" argument must be a number')

  if (size < 0) throw new RangeError('"size" argument must not be negative')

  if (Buffer.alloc) return Buffer.alloc(size, fill, encoding)

  var buffer = allocUnsafe(size)

  if (size === 0) return buffer

  if (fill === void 0) return bufferFill(buffer, 0)

  if (typeof encoding != 'string') encoding = void 0

  return bufferFill(buffer, fill, encoding)
}
//
},
'buffer-fill':
function(module) {
//
var hasFullSupport = (function() {
  try {
    if (!Buffer.isEncoding('latin1')) return false

    var buf = Buffer.alloc ? Buffer.alloc(4) : new Buffer(4)

    buf.fill('ab', 'ucs2')

    return buf.toString('hex') === '61006200'
  } catch (_) {
    return false
  }
})()

function isSingleByte(val) {
  return val.length === 1 && val.charCodeAt(0) < 256
}

function fillWithNumber(buffer, val, start, end) {
  if (start < 0 || end > buffer.length) throw new RangeError('Out of range index')

  start >>>= 0;
  (end = end === void 0 ? buffer.length : end >>> 0) > start && buffer.fill(val, start, end)

  return buffer
}

function fillWithBuffer(buffer, val, start, end) {
  if (start < 0 || end > buffer.length) throw new RangeError('Out of range index')

  if (end <= start) return buffer

  start >>>= 0
  end = end === void 0 ? buffer.length : end >>> 0

  var pos = start
  for (var len = val.length; pos <= end - len; ) {
    val.copy(buffer, pos)
    pos += len
  }

  pos === end || val.copy(buffer, pos, 0, end - pos)

  return buffer
}

function fill(buffer, val, start, end, encoding) {
  if (hasFullSupport) return buffer.fill(val, start, end, encoding)

  if (typeof val == 'number') return fillWithNumber(buffer, val, start, end)

  if (typeof val == 'string') {
    if (typeof start == 'string') {
      encoding = start
      start = 0
      end = buffer.length
    } else if (typeof end == 'string') {
      encoding = end
      end = buffer.length
    }

    if (encoding !== void 0 && typeof encoding != 'string') throw new TypeError('encoding must be a string')

    if (encoding === 'latin1') encoding = 'binary'

    if (typeof encoding == 'string' && !Buffer.isEncoding(encoding))
      throw new TypeError('Unknown encoding: ' + encoding)

    if (val === '') return fillWithNumber(buffer, 0, start, end)

    if (isSingleByte(val)) return fillWithNumber(buffer, val.charCodeAt(0), start, end)

    val = new Buffer(val, encoding)
  }

  return Buffer.isBuffer(val) ? fillWithBuffer(buffer, val, start, end) : fillWithNumber(buffer, 0, start, end)
}

module.exports = fill
//
},
'buffer-alloc-unsafe':
function(module) {
//
function allocUnsafe(size) {
  if (typeof size != 'number') throw new TypeError('"size" argument must be a number')

  if (size < 0) throw new RangeError('"size" argument must not be negative')

  return Buffer.allocUnsafe ? Buffer.allocUnsafe(size) : new Buffer(size)
}

module.exports = allocUnsafe
//
},
'tar-stream/pack':
function(module, exports, __wpreq__) {
//
var constants = __wpreq__('fs-constants'),
  eos = __wpreq__('end-of-stream'),
  util = __wpreq__('util'),
  alloc = __wpreq__('buffer-alloc'),
  toBuffer = __wpreq__('to-buffer'),

  Readable = __wpreq__('readable-stream').Readable,
  Writable = __wpreq__('readable-stream').Writable,
  StringDecoder = __wpreq__('string_decoder').StringDecoder,

  headers = __wpreq__('tar-stream/headers'),

  DMODE = parseInt('755', 8),
  FMODE = parseInt('644', 8),

  END_OF_TAR = alloc(1024),

  noop = function() {}

var overflow = function(self, size) {
  (size &= 511) && self.push(END_OF_TAR.slice(0, 512 - size))
}

function modeToType(mode) {
  switch (mode & constants.S_IFMT) {
    case constants.S_IFBLK: return 'block-device'
    case constants.S_IFCHR: return 'character-device'
    case constants.S_IFDIR: return 'directory'
    case constants.S_IFIFO: return 'fifo'
    case constants.S_IFLNK: return 'symlink'
  }

  return 'file'
}

var Sink = function(to) {
  Writable.call(this)
  this.written = 0
  this._to = to
  this._destroyed = false
}

util.inherits(Sink, Writable)

Sink.prototype._write = function(data, enc, cb) {
  this.written += data.length
  if (this._to.push(data)) return cb()
  this._to._drain = cb
}

Sink.prototype.destroy = function() {
  if (this._destroyed) return
  this._destroyed = true
  this.emit('close')
}

var LinkSink = function() {
  Writable.call(this)
  this.linkname = ''
  this._decoder = new StringDecoder('utf-8')
  this._destroyed = false
}

util.inherits(LinkSink, Writable)

LinkSink.prototype._write = function(data, enc, cb) {
  this.linkname += this._decoder.write(data)
  cb()
}

LinkSink.prototype.destroy = function() {
  if (this._destroyed) return
  this._destroyed = true
  this.emit('close')
}

var Void = function() {
  Writable.call(this)
  this._destroyed = false
}

util.inherits(Void, Writable)

Void.prototype._write = function(data, enc, cb) {
  cb(new Error('No body allowed for this entry'))
}

Void.prototype.destroy = function() {
  if (this._destroyed) return
  this._destroyed = true
  this.emit('close')
}

var Pack = function(opts) {
  if (!(this instanceof Pack)) return new Pack(opts)
  Readable.call(this, opts)

  this._drain = noop
  this._finalized = false
  this._finalizing = false
  this._destroyed = false
  this._stream = null
}

util.inherits(Pack, Readable)

Pack.prototype.entry = function(header, buffer, callback) {
  if (this._stream) throw new Error('already piping an entry')
  if (this._finalized || this._destroyed) return

  if (typeof buffer == 'function') {
    callback = buffer
    buffer = null
  }

  callback || (callback = noop)

  var self = this

  if (!header.size || header.type === 'symlink') header.size = 0
  header.type || (header.type = modeToType(header.mode))
  header.mode || (header.mode = header.type === 'directory' ? DMODE : FMODE)
  header.uid || (header.uid = 0)
  header.gid || (header.gid = 0)
  header.mtime || (header.mtime = new Date())

  if (typeof buffer == 'string') buffer = toBuffer(buffer)
  if (Buffer.isBuffer(buffer)) {
    // noinspection JSObjectNullOrUndefined
    header.size = buffer.length
    this._encode(header)
    this.push(buffer)
    overflow(self, header.size)
    process.nextTick(callback)
    return new Void()
  }

  if (header.type === 'symlink' && !header.linkname) {
    var linkSink = new LinkSink()
    eos(linkSink, function(err) {
      if (err) {
        self.destroy()
        return callback(err)
      }

      header.linkname = linkSink.linkname
      self._encode(header)
      callback()
    })

    return linkSink
  }

  this._encode(header)

  if (header.type !== 'file' && header.type !== 'contiguous-file') {
    process.nextTick(callback)
    return new Void()
  }

  var sink = new Sink(this)

  this._stream = sink

  eos(sink, function(err) {
    self._stream = null

    if (err) {
      self.destroy()
      return callback(err)
    }

    if (sink.written !== header.size) {
      self.destroy()
      return callback(new Error('size mismatch'))
    }

    overflow(self, header.size)
    self._finalizing && self.finalize()
    callback()
  })

  return sink
}

Pack.prototype.finalize = function() {
  if (this._stream) this._finalizing = true
  else if (!this._finalized) {
    this._finalized = true
    this.push(END_OF_TAR)
    this.push(null)
  }
}

Pack.prototype.destroy = function(err) {
  if (this._destroyed) return
  this._destroyed = true

  err && this.emit('error', err)
  this.emit('close')
  this._stream && this._stream.destroy && this._stream.destroy()
}

Pack.prototype._encode = function(header) {
  if (!header.pax) {
    var buf = headers.encode(header)
    if (buf) {
      this.push(buf)
      return
    }
  }
  this._encodePax(header)
}

Pack.prototype._encodePax = function(header) {
  var paxHeader = headers.encodePax({name: header.name, linkname: header.linkname, pax: header.pax})

  var newHeader = {
    name: 'PaxHeader',
    mode: header.mode,
    uid: header.uid,
    gid: header.gid,
    size: paxHeader.length,
    mtime: header.mtime,
    type: 'pax-header',
    linkname: header.linkname && 'PaxHeader',
    uname: header.uname,
    gname: header.gname,
    devmajor: header.devmajor,
    devminor: header.devminor
  }

  this.push(headers.encode(newHeader))
  this.push(paxHeader)
  overflow(this, paxHeader.length)

  newHeader.size = header.size
  newHeader.type = header.type
  this.push(headers.encode(newHeader))
}

Pack.prototype._read = function(n) {
  var drain = this._drain
  this._drain = noop
  drain()
}

module.exports = Pack
//
},
'fs-constants':
function(module, exports, __wpreq__) {
//
module.exports = __wpreq__('fs').constants || __wpreq__('constants')
//
},
'end-of-stream':
function(module, exports, __wpreq__) {
//
var once = __wpreq__('once'),

  noop = function() {};

var isRequest = function(stream) {
  return stream.setHeader && typeof stream.abort == 'function';
};

var isChildProcess = function(stream) {
  return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
  if (typeof opts == 'function') return eos(stream, null, opts);
  opts || (opts = {});

  callback = once(callback || noop);

  var ws = stream._writableState,
    rs = stream._readableState,
    readable = opts.readable || (opts.readable !== false && stream.readable),
    writable = opts.writable || (opts.writable !== false && stream.writable);

  var onlegacyfinish = function() {
    stream.writable || onfinish();
  };

  var onfinish = function() {
    writable = false;
    readable || callback.call(stream);
  };

  var onend = function() {
    readable = false;
    writable || callback.call(stream);
  };

  var onexit = function(exitCode) {
    callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
  };

  var onerror = function(err) {
    callback.call(stream, err);
  };

  var onclose = function() {
    return (!readable || (rs && rs.ended)) && (!writable || (ws && ws.ended))
      ? void 0
      : callback.call(stream, new Error('premature close'));
  };

  var onrequest = function() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    stream.req ? onrequest() : stream.on('request', onrequest);
  } else if (writable && !ws) {
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  isChildProcess(stream) && stream.on('exit', onexit);

  stream.on('end', onend);
  stream.on('finish', onfinish);
  opts.error === false || stream.on('error', onerror);
  stream.on('close', onclose);

  return function() {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    stream.req && stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('exit', onexit);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
};

module.exports = eos;
//
},
pump:
function(module, exports, __wpreq__) {
//
var once = __wpreq__('once'),
  eos = __wpreq__('end-of-stream'),
  fs = __wpreq__('fs'),

  noop = function() {},
  ancient = /^v?\.0/.test(process.version)

var isFn = function(fn) {
  return typeof fn == 'function'
}

var isFS = function(stream) {
  return (
    !!ancient &&
    !!fs &&
    (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)
  )
}

var isRequest = function(stream) {
  return stream.setHeader && isFn(stream.abort)
}

var destroyer = function(stream, reading, writing, callback) {
  callback = once(callback)

  var closed = false
  stream.on('close', function() {
    closed = true
  })

  eos(stream, {readable: reading, writable: writing}, function(err) {
    if (err) return callback(err)
    closed = true
    callback()
  })

  var destroyed = false
  return function(err) {
    if (closed || destroyed) return
    destroyed = true

    if (isFS(stream)) return stream.close(noop)
    if (isRequest(stream)) return stream.abort()

    if (isFn(stream.destroy)) return stream.destroy()

    callback(err || new Error('stream was destroyed'))
  }
}

var call = function(fn) {
  fn()
}

var pipe = function(from, to) {
  return from.pipe(to)
}

function pump() {
  var streams = Array.prototype.slice.call(arguments),
    callback = (isFn(streams[streams.length - 1] || noop) && streams.pop()) || noop

  if (Array.isArray(streams[0])) streams = streams[0]
  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

  var error
  var destroys = streams.map(function(stream, i) {
    var reading = i < streams.length - 1
    return destroyer(stream, reading, i > 0, function(err) {
      error || (error = err)
      err && destroys.forEach(call)
      if (reading) return
      destroys.forEach(call)
      callback(error)
    })
  })

  streams.reduce(pipe)
}

module.exports = pump
//
},
mkdirp:
function(module, exports, __wpreq__) {
//
var path = __wpreq__('path'),
  fs = __wpreq__('fs'),
  _0777 = parseInt('0777', 8);

module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

function mkdirP(p, opts, f, made) {
  if (typeof opts == 'function') {
    f = opts;
    opts = {};
  } else (opts && typeof opts == 'object') || (opts = {mode: opts});

  var mode = opts.mode,
    xfs = opts.fs || fs;

  if (mode === void 0) mode = _0777
  made || (made = null);

  var cb = f || function() {};
  p = path.resolve(p);

  xfs.mkdir(p, mode, function(er) {
    if (!er) return cb(null, (made = made || p));

    switch (er.code) {
      case 'ENOENT':
        if (path.dirname(p) === p) return cb(er);
        mkdirP(path.dirname(p), opts, function(er, made) {
          er ? cb(er, made) : mkdirP(p, opts, cb, made);
        });
        break;

      default:
        xfs.stat(p, function(er2, stat) {
          er2 || !stat.isDirectory() ? cb(er, made) : cb(null, made);
        });
        break;
    }
  });
}

mkdirP.sync = function sync(p, opts, made) {
  (opts && typeof opts == 'object') || (opts = {mode: opts});

  var mode = opts.mode,
    xfs = opts.fs || fs;

  if (mode === void 0) mode = _0777
  made || (made = null);

  p = path.resolve(p);

  try {
    xfs.mkdirSync(p, mode);
    made = made || p;
  } catch (err0) {
    switch (err0.code) {
      case 'ENOENT':
        made = sync(path.dirname(p), opts, made);
        sync(p, opts, made);
        break;

      default:
        var stat;
        try {
          stat = xfs.statSync(p);
        } catch (_err1) {
          throw err0;
        }
        if (!stat.isDirectory()) throw err0;
        break;
    }
  }

  return made;
};
//
},
'uuid/v4':
function(module, exports, __wpreq__) {
//
var rng = __wpreq__('uuid/lib/rng'),
  bytesToUuid = __wpreq__('uuid/lib/bytesToUuid');

function v4(options, buf, offset) {
  var i = (buf && offset) || 0;

  if (typeof options == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }

  var rnds = (options = options || {}).random || (options.rng || rng)();

  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  if (buf) for (var ii = 0; ii < 16; ++ii) buf[i + ii] = rnds[ii];

  return buf || bytesToUuid(rnds);
}

module.exports = v4.v4 = v4;
//
},
'uuid/lib/rng':
function(module, exports, __wpreq__) {
//
var crypto = __wpreq__('crypto');

module.exports = function() {
  return crypto.randomBytes(16);
};
//
},
'uuid/lib/bytesToUuid':
function(module) {
//
var byteToHex = [];
for (var i = 0; i < 256; ++i) byteToHex[i] = (i + 0x100).toString(16).substr(1);

function bytesToUuid(buf, offset) {
  var i = offset || 0,
    bth = byteToHex;
  return [
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ].join('');
}

module.exports = bytesToUuid;
//
},
'validate-npm-package-license':
function(module, exports, __wpreq__) {
//
var parse = __wpreq__('spdx-expression-parse'),
  correct = __wpreq__('spdx-correct'),

  genericWarning =
    'license should be a valid SPDX license expression (without "LicenseRef"), "UNLICENSED", or "SEE LICENSE IN <filename>"',

  fileReferenceRE = /^SEE LICEN[CS]E IN (.+)$/;

function startsWith(prefix, string) {
  return string.slice(0, prefix.length) === prefix;
}

function usesLicenseRef(ast) {
  if (ast.hasOwnProperty('license')) {
    var license = ast.license;
    return startsWith('LicenseRef', license) || startsWith('DocumentRef', license);
  }

  return usesLicenseRef(ast.left) || usesLicenseRef(ast.right);
}

module.exports = function(argument) {
  var ast;

  try {
    ast = parse(argument);
  } catch (_e) {
    var match
    if (argument === 'UNLICENSED' || argument === 'UNLICENCED')
      return {validForOldPackages: true, validForNewPackages: true, unlicensed: true};
    if ((match = fileReferenceRE.exec(argument)))
      return {validForOldPackages: true, validForNewPackages: true, inFile: match[1]};

    var result = {validForOldPackages: false, validForNewPackages: false, warnings: [genericWarning]};
    if (argument.trim().length > 0) {
      var corrected = correct(argument);
      corrected && result.warnings.push('license is similar to the valid expression "' + corrected + '"');
    }
    return result;
  }

  return usesLicenseRef(ast)
    ? {validForNewPackages: false, validForOldPackages: false, spdx: true, warnings: [genericWarning]}
    : {validForNewPackages: true, validForOldPackages: true, spdx: true};
};
//
},
'spdx-expression-parse':
function(module, exports, __wpreq__) {
//
var scan = __wpreq__('spdx-expression-parse/scan'),
  parse = __wpreq__('spdx-expression-parse/parse')

module.exports = function(source) {
  return parse(scan(source))
}
//
},
'spdx-expression-parse/scan':
function(module, exports, __wpreq__) {
//
var licenses = [].concat(__wpreq__('spdx-license-ids'), __wpreq__('spdx-license-ids/deprecated.json')),
  exceptions = __wpreq__('spdx-exceptions')

module.exports = function(source) {
  var index = 0

  function hasMore() {
    return index < source.length
  }

  function read(value) {
    if (value instanceof RegExp) {
      var match = source.slice(index).match(value)
      if (match) {
        index += match[0].length
        return match[0]
      }
    } else if (source.indexOf(value, index) === index) {
      index += value.length
      return value
    }
  }

  function skipWhitespace() {
    read(/[ ]*/)
  }

  function operator() {
    var string,
      possibilities = ['WITH', 'AND', 'OR', '(', ')', ':', '+']
    for (var i = 0; i < possibilities.length && !(string = read(possibilities[i])); i++);

    if (string === '+' && index > 1 && source[index - 2] === ' ') throw new Error('Space before `+`')

    return string && {type: 'OPERATOR', string: string}
  }

  function idstring() {
    return read(/[A-Za-z0-9-.]+/)
  }

  function expectIdstring() {
    var string = idstring()
    if (!string) throw new Error('Expected idstring at offset ' + index)

    return string
  }

  function documentRef() {
    if (read('DocumentRef-')) return {type: 'DOCUMENTREF', string: expectIdstring()}
  }

  function licenseRef() {
    if (read('LicenseRef-')) return {type: 'LICENSEREF', string: expectIdstring()}
  }

  function identifier() {
    var begin = index,
      string = idstring()

    if (licenses.indexOf(string) > -1) return {type: 'LICENSE', string: string}
    if (exceptions.indexOf(string) > -1) return {type: 'EXCEPTION', string: string}

    index = begin
  }

  function parseToken() {
    return operator() || documentRef() || licenseRef() || identifier()
  }

  var tokens = []
  while (hasMore()) {
    skipWhitespace()
    if (!hasMore()) break

    var token = parseToken()
    if (!token) throw new Error('Unexpected `' + source[index] + '` at offset ' + index)

    tokens.push(token)
  }
  return tokens
}
//
},
'spdx-license-ids':
function(module) {
// noinspection SpellCheckingInspection
module.exports = JSON.parse(
  '["0BSD","AAL","Abstyles","Adobe-2006","Adobe-Glyph","ADSL","AFL-1.1","AFL-1.2","AFL-2.0","AFL-2.1","AFL-3.0","Afmparse","AGPL-1.0","AGPL-3.0-only","AGPL-3.0-or-later","Aladdin","AMDPLPA","AML","AMPAS","ANTLR-PD","Apache-1.0","Apache-1.1","Apache-2.0","APAFML","APL-1.0","APSL-1.0","APSL-1.1","APSL-1.2","APSL-2.0","Artistic-1.0-cl8","Artistic-1.0-Perl","Artistic-1.0","Artistic-2.0","Bahyph","Barr","Beerware","BitTorrent-1.0","BitTorrent-1.1","Borceux","BSD-1-Clause","BSD-2-Clause-FreeBSD","BSD-2-Clause-NetBSD","BSD-2-Clause-Patent","BSD-2-Clause","BSD-3-Clause-Attribution","BSD-3-Clause-Clear","BSD-3-Clause-LBNL","BSD-3-Clause-No-Nuclear-License-2014","BSD-3-Clause-No-Nuclear-License","BSD-3-Clause-No-Nuclear-Warranty","BSD-3-Clause","BSD-4-Clause-UC","BSD-4-Clause","BSD-Protection","BSD-Source-Code","BSL-1.0","bzip2-1.0.5","bzip2-1.0.6","Caldera","CATOSL-1.1","CC-BY-1.0","CC-BY-2.0","CC-BY-2.5","CC-BY-3.0","CC-BY-4.0","CC-BY-NC-1.0","CC-BY-NC-2.0","CC-BY-NC-2.5","CC-BY-NC-3.0","CC-BY-NC-4.0","CC-BY-NC-ND-1.0","CC-BY-NC-ND-2.0","CC-BY-NC-ND-2.5","CC-BY-NC-ND-3.0","CC-BY-NC-ND-4.0","CC-BY-NC-SA-1.0","CC-BY-NC-SA-2.0","CC-BY-NC-SA-2.5","CC-BY-NC-SA-3.0","CC-BY-NC-SA-4.0","CC-BY-ND-1.0","CC-BY-ND-2.0","CC-BY-ND-2.5","CC-BY-ND-3.0","CC-BY-ND-4.0","CC-BY-SA-1.0","CC-BY-SA-2.0","CC-BY-SA-2.5","CC-BY-SA-3.0","CC-BY-SA-4.0","CC0-1.0","CDDL-1.0","CDDL-1.1","CDLA-Permissive-1.0","CDLA-Sharing-1.0","CECILL-1.0","CECILL-1.1","CECILL-2.0","CECILL-2.1","CECILL-B","CECILL-C","ClArtistic","CNRI-Jython","CNRI-Python-GPL-Compatible","CNRI-Python","Condor-1.1","CPAL-1.0","CPL-1.0","CPOL-1.02","Crossword","CrystalStacker","CUA-OPL-1.0","Cube","curl","D-FSL-1.0","diffmark","DOC","Dotseqn","DSDP","dvipdfm","ECL-1.0","ECL-2.0","EFL-1.0","EFL-2.0","eGenix","Entessa","EPL-1.0","EPL-2.0","ErlPL-1.1","EUDatagrid","EUPL-1.0","EUPL-1.1","EUPL-1.2","Eurosym","Fair","Frameworx-1.0","FreeImage","FSFAP","FSFUL","FSFULLR","FTL","GFDL-1.1-only","GFDL-1.1-or-later","GFDL-1.2-only","GFDL-1.2-or-later","GFDL-1.3-only","GFDL-1.3-or-later","Giftware","GL2PS","Glide","Glulxe","gnuplot","GPL-1.0-only","GPL-1.0-or-later","GPL-2.0-only","GPL-2.0-or-later","GPL-3.0-only","GPL-3.0-or-later","gSOAP-1.3b","HaskellReport","HPND","IBM-pibs","ICU","IJG","ImageMagick","iMatix","Imlib2","Info-ZIP","Intel-ACPI","Intel","Interbase-1.0","IPA","IPL-1.0","ISC","JasPer-2.0","JSON","LAL-1.2","LAL-1.3","Latex2e","Leptonica","LGPL-2.0-only","LGPL-2.0-or-later","LGPL-2.1-only","LGPL-2.1-or-later","LGPL-3.0-only","LGPL-3.0-or-later","LGPLLR","Libpng","libtiff","LiLiQ-P-1.1","LiLiQ-R-1.1","LiLiQ-Rplus-1.1","LPL-1.0","LPL-1.02","LPPL-1.0","LPPL-1.1","LPPL-1.2","LPPL-1.3a","LPPL-1.3c","MakeIndex","MirOS","MIT-advertising","MIT-CMU","MIT-enna","MIT-feh","MIT","MITNFA","Motosoto","mpich2","MPL-1.0","MPL-1.1","MPL-2.0-no-copyleft-exception","MPL-2.0","MS-PL","MS-RL","MTLL","Multics","Mup","NASA-1.3","Naumen","NBPL-1.0","NCSA","Net-SNMP","NetCDF","Newsletr","NGPL","NLOD-1.0","NLPL","Nokia","NOSL","Noweb","NPL-1.0","NPL-1.1","NPOSL-3.0","NRL","NTP","OCCT-PL","OCLC-2.0","ODbL-1.0","OFL-1.0","OFL-1.1","OGTSL","OLDAP-1.1","OLDAP-1.2","OLDAP-1.3","OLDAP-1.4","OLDAP-2.0.1","OLDAP-2.0","OLDAP-2.1","OLDAP-2.2.1","OLDAP-2.2.2","OLDAP-2.2","OLDAP-2.3","OLDAP-2.4","OLDAP-2.5","OLDAP-2.6","OLDAP-2.7","OLDAP-2.8","OML","OpenSSL","OPL-1.0","OSET-PL-2.1","OSL-1.0","OSL-1.1","OSL-2.0","OSL-2.1","OSL-3.0","PDDL-1.0","PHP-3.0","PHP-3.01","Plexus","PostgreSQL","psfrag","psutils","Python-2.0","Qhull","QPL-1.0","Rdisc","RHeCos-1.1","RPL-1.1","RPL-1.5","RPSL-1.0","RSA-MD","RSCPL","Ruby","SAX-PD","Saxpath","SCEA","Sendmail","SGI-B-1.0","SGI-B-1.1","SGI-B-2.0","SimPL-2.0","SISSL-1.2","SISSL","Sleepycat","SMLNJ","SMPPL","SNIA","Spencer-86","Spencer-94","Spencer-99","SPL-1.0","SugarCRM-1.1.3","SWL","TCL","TCP-wrappers","TMate","TORQUE-1.1","TOSL","Unicode-DFS-2015","Unicode-DFS-2016","Unicode-TOU","Unlicense","UPL-1.0","Vim","VOSTROM","VSL-1.0","W3C-19980720","W3C-20150513","W3C","Watcom-1.0","Wsuipa","WTFPL","X11",\
"Xerox","XFree86-1.1","xinetd","Xnet","xpp","XSkat","YPL-1.0","YPL-1.1","Zed","Zend-2.0","Zimbra-1.3","Zimbra-1.4","zlib-acknowledgement","Zlib","ZPL-1.1","ZPL-2.0","ZPL-2.1"]'
);
//
},
'spdx-license-ids/deprecated.json':
function(module) {
//
module.exports = JSON.parse(
  '["AGPL-3.0","eCos-2.0","GFDL-1.1","GFDL-1.2","GFDL-1.3","GPL-1.0","GPL-2.0-with-autoconf-exception","GPL-2.0-with-bison-exception","GPL-2.0-with-classpath-exception","GPL-2.0-with-font-exception","GPL-2.0-with-GCC-exception","GPL-2.0","GPL-3.0-with-autoconf-exception","GPL-3.0-with-GCC-exception","GPL-3.0","LGPL-2.0","LGPL-2.1","LGPL-3.0","Nunit","StandardML-NJ","wxWindows"]'
);
//
},
'spdx-exceptions':
function(module) {
//
module.exports = JSON.parse(
  '["389-exception","Autoconf-exception-2.0","Autoconf-exception-3.0","Bison-exception-2.2","Bootloader-exception","CLISP-exception-2.0","Classpath-exception-2.0","DigiRule-FOSS-exception","FLTK-exception","Fawkes-Runtime-exception","Font-exception-2.0","GCC-exception-2.0","GCC-exception-3.1","LZMA-exception","Libtool-exception","Linux-syscall-note","Nokia-Qt-exception-1.1","OCCT-exception-1.0","Qwt-exception-1.0","WxWindows-exception-3.1","eCos-exception-2.0","freertos-exception-2.0","gnu-javamail-exception","i2p-gpl-java-exception","mif-exception","openvpn-openssl-exception","u-boot-exception-2.0"]'
);
//
},
'spdx-expression-parse/parse':
function(module) {
//
module.exports = function(tokens) {
  var index = 0

  function hasMore() {
    return index < tokens.length
  }

  function token() {
    return hasMore() ? tokens[index] : null
  }

  function next() {
    if (!hasMore()) throw new Error()
    index++
  }

  function parseOperator(operator) {
    var t = token()
    if (t && t.type === 'OPERATOR' && operator === t.string) {
      next()
      return t.string
    }
  }

  function parseWith() {
    if (parseOperator('WITH')) {
      var t = token()
      if (t && t.type === 'EXCEPTION') {
        next()
        return t.string
      }
      throw new Error('Expected exception after `WITH`')
    }
  }

  function parseLicenseRef() {
    var begin = index,
      string = '',
      t = token()
    if (t.type === 'DOCUMENTREF') {
      next()
      string += 'DocumentRef-' + t.string + ':'
      if (!parseOperator(':')) throw new Error('Expected `:` after `DocumentRef-...`')
    }
    if ((t = token()).type === 'LICENSEREF') {
      next()
      return {license: (string += 'LicenseRef-' + t.string)}
    }
    index = begin
  }

  function parseLicense() {
    var t = token()
    if (t && t.type === 'LICENSE') {
      next()
      var node = {license: t.string}
      if (parseOperator('+')) node.plus = true

      var exception = parseWith()
      if (exception) node.exception = exception

      return node
    }
  }

  function parseParenthesizedExpression() {
    if (!parseOperator('(')) return

    var expr = parseExpression()

    if (!parseOperator(')')) throw new Error('Expected `)`')

    return expr
  }

  function parseAtom() {
    return parseParenthesizedExpression() || parseLicenseRef() || parseLicense()
  }

  function makeBinaryOpParser(operator, nextParser) {
    return function parseBinaryOp() {
      var left = nextParser()
      if (!left) return

      if (!parseOperator(operator)) return left

      var right = parseBinaryOp()
      if (!right) throw new Error('Expected expression')

      return {left: left, conjunction: operator.toLowerCase(), right: right}
    }
  }

  var parseAnd = makeBinaryOpParser('AND', parseAtom),
    parseExpression = makeBinaryOpParser('OR', parseAnd),

    node = parseExpression()
  if (!node || hasMore()) throw new Error('Syntax error')

  return node
}
//
},
'spdx-correct':
function(module, exports, __wpreq__) {
//
var parse = __wpreq__('spdx-expression-parse'),
  spdxLicenseIds = __wpreq__('spdx-license-ids')

function valid(string) {
  try {
    parse(string)
    return true
  } catch (_error) {
    return false
  }
}

var transpositions = [
  ['APGL', 'AGPL'],
  ['Gpl', 'GPL'],
  ['GLP', 'GPL'],
  ['APL', 'Apache'],
  ['ISD', 'ISC'],
  ['GLP', 'GPL'],
  ['IST', 'ISC'],
  ['Claude', 'Clause'],
  [' or later', '+'],
  [' International', ''],
  ['GNU', 'GPL'],
  ['GUN', 'GPL'],
  ['+', ''],
  ['GNU GPL', 'GPL'],
  ['GNU/GPL', 'GPL'],
  ['GNU GLP', 'GPL'],
  ['GNU General Public License', 'GPL'],
  ['Gnu public license', 'GPL'],
  ['GNU Public License', 'GPL'],
  ['GNU GENERAL PUBLIC LICENSE', 'GPL'],
  ['MTI', 'MIT'],
  ['Mozilla Public License', 'MPL'],
  ['WTH', 'WTF'],
  ['-License', '']
]

var TRANSPOSED = 0,
  CORRECT = 1

var transforms = [
  function(argument) {
    return argument.toUpperCase()
  },
  function(argument) {
    return argument.trim()
  },
  function(argument) {
    return argument.replace(/\./g, '')
  },
  function(argument) {
    return argument.replace(/\s+/g, '')
  },
  function(argument) {
    return argument.replace(/\s+/g, '-')
  },
  function(argument) {
    return argument.replace('v', '-')
  },
  function(argument) {
    return argument.replace(/,?\s*(\d)/, '-$1')
  },
  function(argument) {
    return argument.replace(/,?\s*(\d)/, '-$1.0')
  },
  function(argument) {
    return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, '-$2')
  },
  function(argument) {
    return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, '-$2.0')
  },
  function(argument) {
    return argument[0].toUpperCase() + argument.slice(1)
  },
  function(argument) {
    return argument.replace('/', '-')
  },
  function(argument) {
    return argument.replace(/\s*V\s*(\d)/, '-$1').replace(/(\d)$/, '$1.0')
  },
  function(argument) {
    return argument.indexOf('3.0') > -1 ? argument + '-or-later' : argument + '-only'
  },
  function(argument) {
    return argument + 'only'
  },
  function(argument) {
    return argument.replace(/(\d)$/, '-$1.0')
  },
  function(argument) {
    return argument.replace(/[- ]?(\d)$/, '-$1-Clause')
  },
  function(argument) {
    return argument.replace(/[- ]clause[- ](\d)/, '-$1-Clause')
  },
  function(argument) {
    return 'CC-' + argument
  },
  function(argument) {
    return 'CC-' + argument + '-4.0'
  },
  function(argument) {
    return argument
      .replace('Attribution', 'BY')
      .replace('NonCommercial', 'NC')
      .replace('NoDerivatives', 'ND')
      .replace(/ (\d)/, '-$1')
      .replace(/ ?International/, '')
  },
  function(argument) {
    return (
      'CC-' +
      argument
        .replace('Attribution', 'BY')
        .replace('NonCommercial', 'NC')
        .replace('NoDerivatives', 'ND')
        .replace(/ (\d)/, '-$1')
        .replace(/ ?International/, '') +
      '-4.0'
    )
  }
]

var licensesWithVersions = spdxLicenseIds
  .map(function(id) {
    var match = /^(.*)-\d+\.\d+$/.exec(id)
    return match ? [match[0], match[1]] : [id, null]
  })
  .reduce(function(objectMap, item) {
    var key = item[1]
    objectMap[key] = objectMap[key] || []
    objectMap[key].push(item[0])
    return objectMap
  }, {})

var licensesWithOneVersion = Object.keys(licensesWithVersions)
  .map(function(key) {
    return [key, licensesWithVersions[key]]
  })
  .filter(function(item) {
    return item[1].length === 1 && item[0] !== null && item[0] !== 'APL'
  })
  .map(function(item) {
    return [item[0], item[1][0]]
  })

licensesWithVersions = void 0

// noinspection SpellCheckingInspection
var lastResorts = [
  ['UNLI', 'Unlicense'],
  ['WTF', 'WTFPL'],
  ['2 CLAUSE', 'BSD-2-Clause'],
  ['2-CLAUSE', 'BSD-2-Clause'],
  ['3 CLAUSE', 'BSD-3-Clause'],
  ['3-CLAUSE', 'BSD-3-Clause'],
  ['AFFERO', 'AGPL-3.0-or-later'],
  ['AGPL', 'AGPL-3.0-or-later'],
  ['APACHE', 'Apache-2.0'],
  ['ARTISTIC', 'Artistic-2.0'],
  ['Affero', 'AGPL-3.0-or-later'],
  ['BEER', 'Beerware'],
  ['BOOST', 'BSL-1.0'],
  ['BSD', 'BSD-2-Clause'],
  ['CDDL', 'CDDL-1.1'],
  ['ECLIPSE', 'EPL-1.0'],
  ['FUCK', 'WTFPL'],
  ['GNU', 'GPL-3.0-or-later'],
  ['LGPL', 'LGPL-3.0-or-later'],
  ['GPLV1', 'GPL-1.0-only'],
  ['GPLV2', 'GPL-2.0-only'],
  ['GPL', 'GPL-3.0-or-later'],
  ['MIT +NO-FALSE-ATTRIBS', 'MITNFA'],
  ['MIT', 'MIT'],
  ['MPL', 'MPL-2.0'],
  ['X11', 'X11'],
  ['ZLIB', 'Zlib']
].concat(licensesWithOneVersion)

var SUBSTRING = 0,
  IDENTIFIER = 1

var validTransformation = function(identifier) {
  for (var i = 0; i < transforms.length; i++) {
    var transformed = transforms[i](identifier).trim()
    if (transformed !== identifier && valid(transformed)) return transformed
  }
  return null
}

var validLastResort = function(identifier) {
  for (var upperCased = identifier.toUpperCase(), i = 0; i < lastResorts.length; i++) {
    var lastResort = lastResorts[i]
    if (upperCased.indexOf(lastResort[SUBSTRING]) > -1) return lastResort[IDENTIFIER]
  }
  return null
}

var anyCorrection = function(identifier, check) {
  for (var i = 0; i < transpositions.length; i++) {
    var transposition = transpositions[i],
      transposed = transposition[TRANSPOSED]
    if (identifier.indexOf(transposed) > -1) {
      var checked = check(identifier.replace(transposed, transposition[CORRECT]))
      if (checked !== null) return checked
    }
  }
  return null
}

module.exports = function(identifier) {
  if (typeof identifier != 'string' || identifier.trim().length === 0)
    throw Error('Invalid argument. Expected non-empty string.')

  if (valid((identifier = identifier.replace(/\+$/, '').trim()))) return upgradeGPLs(identifier)

  var transformed = validTransformation(identifier)

  return transformed !== null ||
    (transformed = anyCorrection(identifier, function(argument) {
      return valid(argument) ? argument : validTransformation(argument)
    })) !== null ||
    (transformed = validLastResort(identifier)) !== null ||
    (transformed = anyCorrection(identifier, validLastResort)) !== null
    ? upgradeGPLs(transformed)
    : null
}

function upgradeGPLs(value) {
  return ['GPL-1.0', 'LGPL-1.0', 'AGPL-1.0', 'GPL-2.0', 'LGPL-2.0', 'AGPL-2.0', 'LGPL-2.1'].indexOf(value) > -1
    ? value + '-only'
    : ['GPL-3.0', 'LGPL-3.0', 'AGPL-3.0'].indexOf(value) > -1
    ? value + '-or-later'
    : value
}
//
},
'@zkochan/cmd-shim':
function(module, exports, __wpreq__) {
//
module.exports = cmdShim
cmdShim.ifExists = cmdShimIfExists

const fs = __wpreq__('mz/fs'),

  mkdir = __wpreq__('mkdirp-promise'),
  path = __wpreq__('path'),
  isWindows = __wpreq__('is-windows'),
  shebangExpr = /^#!\s*(?:\/usr\/bin\/env)?\s*([^ \t]+)(.*)$/,
  DEFAULT_OPTIONS = {createPwshFile: true, createCmdFile: isWindows()}

function cmdShimIfExists(src, to, opts) {
  opts = Object.assign({}, DEFAULT_OPTIONS, opts)
  return fs.stat(src)
    .then(() => cmdShim(src, to, opts))
    .catch(() => {})
}

function rm(path) {
  return fs.unlink(path).catch(() => {})
}

function cmdShim(src, to, opts) {
  opts = Object.assign({}, DEFAULT_OPTIONS, opts)
  return fs.stat(src).then(() => cmdShim_(src, to, opts))
}

function cmdShim_(src, to, opts) {
  return Promise.all([rm(to), rm(to + '.ps1'), opts.createCmdFile && rm(to + '.cmd')]).then(() =>
    writeShim(src, to, opts)
  )
}

function writeShim(src, to, opts) {
  const defaultArgs = (opts = Object.assign({}, DEFAULT_OPTIONS, opts)).preserveSymlinks ? '--preserve-symlinks' : ''
  return mkdir(path.dirname(to)).then(() =>
    fs.readFile(src, 'utf8')
      .then(data => {
        const shebang = data.trim().split(/\r*\n/)[0].match(shebangExpr)
        if (!shebang) return writeShim_(src, to, Object.assign({}, opts, {args: defaultArgs}))
        const prog = shebang[1],
          args = (shebang[2] && ((defaultArgs && shebang[2] + ' ' + defaultArgs) || shebang[2])) || defaultArgs
        return writeShim_(src, to, Object.assign({}, opts, {prog, args}))
      })
      .catch(() => writeShim_(src, to, Object.assign({}, opts, {args: defaultArgs})))
  )
}

function writeShim_(src, to, opts) {
  opts = Object.assign({}, DEFAULT_OPTIONS, opts)
  let longProg,
    shLongProg,
    pwshLongProg,
    shTarget = path.relative(path.dirname(to), src),
    target = shTarget.split('/').join('\\'),
    prog = opts.prog,
    shProg = prog && prog.split('\\').join('/'),
    pwshProg = shProg && `"${shProg}$exe"`
  shTarget = shTarget.split('\\').join('/')
  let cmd,
    args = opts.args || '',
    _normalized = normalizePathEnvVar(opts.nodePath), nodePath = _normalized.win32, shNodePath = _normalized.posix
  if (!prog) {
    prog = `"%~dp0\\${target}"`
    shProg = `"$basedir/${shTarget}"`
    pwshProg = shProg
    args = ''
    target = ''
    shTarget = ''
  } else {
    longProg = `"%~dp0\\${prog}.exe"`
    shLongProg = '"$basedir/' + prog + '"'
    pwshLongProg = `"$basedir/${prog}$exe"`
    target = `"%~dp0\\${target}"`
    shTarget = `"$basedir/${shTarget}"`
  }

  if (opts.createCmdFile) {
    cmd = nodePath ? `@SET NODE_PATH=${nodePath}\r\n` : ''
    cmd += longProg
      ? '@IF EXIST ' + longProg + ' (\r\n  ' +
        longProg + ' ' + args + ' ' + target +
        ' %*\r\n) ELSE (\r\n  @SETLOCAL\r\n  @SET PATHEXT=%PATHEXT:;.JS;=;%\r\n  ' +
        prog + ' ' + args + ' ' + target + ' %*\r\n)'
      : `@${prog} ${args} ${target} %*\r\n`
  }

  let sh = '#!/bin/sh\n'
  sh +=
    'basedir=$(dirname "$(echo "$0" | sed -e \'s,\\\\,/,g\')")\n\ncase `uname` in\n    *CYGWIN*) basedir=`cygpath -w "$basedir"`;;\nesac\n\n'
  const env = opts.nodePath ? `NODE_PATH="${shNodePath}" ` : ''

  sh = shLongProg
    ? sh +
      'if [ -x ' + shLongProg + ' ]; then\n  ' +
      env + shLongProg + ' ' + args + ' ' + shTarget +
      ' "$@"\n  ret=$?\nelse \n  ' +
      env + shProg + ' ' + args + ' ' + shTarget +
      ' "$@"\n  ret=$?\nfi\nexit $ret\n'
    : sh + env + shProg + ' ' + args + ' ' + shTarget + ' "$@"\nexit $?\n'

  let pwsh =
    '#!/usr/bin/env pwsh\n$basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent\n\n$exe=""\n' +
    (opts.nodePath ? `$env_node_path=$env:NODE_PATH\n$env:NODE_PATH="${nodePath}"\n` : '') +
    'if ($PSVersionTable.PSVersion -lt "6.0" -or $IsWindows) {\n  # Fix case when both the Windows and Linux builds of Node\n  # are installed in the same directory\n  $exe=".exe"\n}'
  if (opts.nodePath) pwsh = pwsh + ` else {\n  $env:NODE_PATH="${shNodePath}"\n}`

  pwsh += '\n'
  pwsh = shLongProg
    ? pwsh +
      `$ret=0\nif (Test-Path ${pwshLongProg}) {\n` +
      `  & ${pwshLongProg} ${args} ${shTarget} $args\n  $ret=$LASTEXITCODE\n} else {\n` +
      `  & ${pwshProg} ${args} ${shTarget} $args\n  $ret=$LASTEXITCODE\n}\n` +
      (opts.nodePath ? '$env:NODE_PATH=$env_node_path\n' : '') +
      'exit $ret\n'
    : pwsh +
      `& ${pwshProg} ${args} ${shTarget} $args\n` +
      (opts.nodePath ? '$env:NODE_PATH=$env_node_path\n' : '') +
      'exit $LASTEXITCODE\n'

  return Promise.all([
    opts.createCmdFile && fs.writeFile(to + '.cmd', cmd, 'utf8'),
    opts.createPwshFile && fs.writeFile(to + '.ps1', pwsh, 'utf8'),
    fs.writeFile(to, sh, 'utf8')
  ]).then(() => chmodShim(to, opts))
}

function chmodShim(to, opts) {
  let createCmdFile = opts.createCmdFile, createPwshFile = opts.createPwshFile
  return Promise.all([
    fs.chmod(to, 0o755),
    createPwshFile && fs.chmod(to + '.ps1', 0o755),
    createCmdFile && fs.chmod(to + '.cmd', 0o755)
  ])
}

function normalizePathEnvVar(nodePath) {
  if (!nodePath) return {win32: nodePath, posix: nodePath}

  let split = typeof nodePath == 'string' ? nodePath.split(path.delimiter) : Array.from(nodePath),
    result = {}
  for (let i = 0; i < split.length; i++) {
    const win32 = split[i].split('/').join('\\')
    const posix = isWindows()
      ? split[i].split('\\').join('/').replace(/^([^:\\/]*):/, (_, $1) => '/mnt/' + $1.toLowerCase())
      : split[i]

    result.win32 = result.win32 ? `${result.win32};${win32}` : win32
    result.posix = result.posix ? `${result.posix}:${posix}` : posix

    result[i] = {win32, posix}
  }
  return result
}
//
},
'mz/fs':
function(module, exports, __wpreq__) {
//
var fs
try {
  fs = __wpreq__('graceful-fs')
} catch (_err) {
  fs = __wpreq__('fs')
}

var api = [
  'appendFile',
  'chmod',
  'chown',
  'close',
  'fchmod',
  'fchown',
  'fdatasync',
  'fstat',
  'fsync',
  'ftruncate',
  'futimes',
  'lchown',
  'link',
  'lstat',
  'mkdir',
  'open',
  'read',
  'readFile',
  'readdir',
  'readlink',
  'realpath',
  'rename',
  'rmdir',
  'stat',
  'symlink',
  'truncate',
  'unlink',
  'utimes',
  'write',
  'writeFile'
]

typeof fs.access != 'function' || api.push('access')
typeof fs.copyFile != 'function' || api.push('copyFile')
typeof fs.mkdtemp != 'function' || api.push('mkdtemp')

__wpreq__('thenify-all').withCallback(fs, exports, api)

exports.exists = function(filename, callback) {
  if (typeof callback == 'function')
    return fs.stat(filename, function(err) {
      callback(null, !err);
    })

  return new Promise(function(resolve) {
    fs.stat(filename, function(err) {
      resolve(!err)
    })
  })
}
//
},
'thenify-all':
function(module, exports, __wpreq__) {
//
var thenify = __wpreq__('thenify')

module.exports = thenifyAll
thenifyAll.withCallback = withCallback
thenifyAll.thenify = thenify

function thenifyAll(source, destination, methods) {
  return promisifyAll(source, destination, methods, thenify)
}

function withCallback(source, destination, methods) {
  return promisifyAll(source, destination, methods, thenify.withCallback)
}

function promisifyAll(source, destination, methods, promisify) {
  if (!destination) {
    destination = {};
    methods = Object.keys(source)
  }

  if (Array.isArray(destination)) {
    methods = destination
    destination = {}
  }

  methods || (methods = Object.keys(source))

  if (typeof source == 'function') destination = promisify(source)

  methods.forEach(function(name) {
    if (typeof source[name] == 'function') destination[name] = promisify(source[name])
  })

  Object.keys(source).forEach(function(name) {
    deprecated(source, name) || destination[name] || (destination[name] = source[name])
  })

  return destination
}

function deprecated(source, name) {
  var desc = Object.getOwnPropertyDescriptor(source, name)
  return !(!desc || !desc.get) && desc.get.name === 'deprecated'
}
//
},
thenify:
function(module, exports, __wpreq__) {
//
var assert = __wpreq__('assert')

module.exports = thenify

function thenify(fn, options) {
  assert(typeof fn == 'function')
  return createWrapper(fn, options)
}

thenify.withCallback = function(fn, options) {
  assert(typeof fn == 'function');
  (options = options || {}).withCallback = true
  return createWrapper(fn, options)
}

function createCallback(resolve, reject, multiArgs) {
  if (multiArgs === void 0) multiArgs = true
  return function(err, value) {
    if (err) return reject(err)
    var length = arguments.length

    if (length <= 2 || !multiArgs) return resolve(value)

    if (Array.isArray(multiArgs)) {
      for (var values = {}, i = 1; i < length; i++) values[multiArgs[i - 1]] = arguments[i]
      return resolve(values)
    }

    for (values = new Array(length - 1), i = 1; i < length; ++i) values[i - 1] = arguments[i]
    resolve(values)
  }
}

function createWrapper(fn, options) {
  options = options || {}
  var name = fn.name;
  name = (name || '').replace(/\s|bound(?!$)/g, '')
  var newFn = function() {
    var self = this,
      len = arguments.length
    if (options.withCallback && typeof arguments[len - 1] == 'function') return fn.apply(self, arguments)

    var args = new Array(len + 1)
    for (var i = 0; i < len; ++i) args[i] = arguments[i]

    return new Promise(function(resolve, reject) {
      args[len] = createCallback(resolve, reject, options.multiArgs)
      fn.apply(self, args)
    })
  }
  Object.defineProperty(newFn, 'name', {value: name})
  return newFn
}
//
},
'mkdirp-promise':
function(module, exports, __wpreq__) {
//
const mkdirp = __wpreq__('mkdirp')

module.exports = function(dir, opts) {
  return new Promise((resolve, reject) => {
    mkdirp(dir, opts, (err, made) => (err == null ? resolve(made) : reject(err)))
  })
}
//
},
'is-windows':
function(module) {
//
module.exports = function() {
  return process && (process.platform === 'win32' || /^(msys|cygwin)$/.test(process.env.OSTYPE));
};
//
},
'gunzip-maybe':
function(module, exports, __wpreq__) {
//
var zlib = __wpreq__('zlib'),
  peek = __wpreq__('peek-stream'),
  through = __wpreq__('through2'),
  pumpify = __wpreq__('pumpify'),
  isGzip = __wpreq__('is-gzip'),
  isDeflate = __wpreq__('is-deflate')

var isCompressed = function(data) {
  return isGzip(data) ? 1 : isDeflate(data) ? 2 : 0
}

var gunzip = function(maxRecursion) {
  if (maxRecursion === void 0) maxRecursion = 3

  return peek({newline: false, maxBuffer: 10}, function(data, swap) {
    if (maxRecursion < 0) return swap(new Error('Maximum recursion reached'))
    switch (isCompressed(data)) {
      case 1:
        swap(null, pumpify(zlib.createGunzip(), gunzip(maxRecursion - 1)))
        break
      case 2:
        swap(null, pumpify(zlib.createInflate(), gunzip(maxRecursion - 1)))
        break
      default:
        swap(null, through())
    }
  })
}

module.exports = gunzip
//
},
zlib:
function(module) {
//
module.exports = require('zlib');
//
},
'peek-stream':
function(module, exports, __wpreq__) {
//
var duplexify = __wpreq__('duplexify'),
  through = __wpreq__('through2'),
  bufferFrom = __wpreq__('buffer-from')

var isObject = function(data) {
  return !Buffer.isBuffer(data) && typeof data != 'string'
}

var peek = function(opts, onpeek) {
  if (typeof opts == 'number') opts = {maxBuffer: opts}
  if (typeof opts == 'function') return peek(null, opts)
  opts || (opts = {})

  var maxBuffer = typeof opts.maxBuffer == 'number' ? opts.maxBuffer : 65535,
    strict = opts.strict,
    newline = opts.newline !== false,

    buffer = [],
    bufferSize = 0,
    dup = duplexify.obj()

  var peeker = through.obj({highWaterMark: 1}, function(data, enc, cb) {
    if (isObject(data)) return ready(data, null, cb)
    Buffer.isBuffer(data) || (data = bufferFrom(data))

    if (newline) {
      var nl = Array.prototype.indexOf.call(data, 10)
      nl > 0 && data[nl - 1] === 13 && nl--

      if (nl > -1) {
        buffer.push(data.slice(0, nl))
        return ready(Buffer.concat(buffer), data.slice(nl), cb)
      }
    }

    buffer.push(data)

    if ((bufferSize += data.length) < maxBuffer) return cb()
    if (strict) return cb(new Error('No newline found'))
    ready(Buffer.concat(buffer), null, cb)
  })

  var onpreend = function() {
    if (strict) return dup.destroy(new Error('No newline found'))
    dup.cork()
    ready(Buffer.concat(buffer), null, function(err) {
      if (err) return dup.destroy(err)
      dup.uncork()
    })
  }

  var ready = function(data, overflow, cb) {
    dup.removeListener('preend', onpreend)
    onpeek(data, function(err, parser) {
      if (err) return cb(err)

      dup.setWritable(parser)
      dup.setReadable(parser)

      data && parser.write(data)
      overflow && parser.write(overflow)

      overflow = buffer = peeker = null
      cb()
    })
  }

  dup.on('preend', onpreend)
  dup.setWritable(peeker)

  return dup
}

module.exports = peek
//
},
duplexify:
function(module, exports, __wpreq__) {
// noinspection JSIncompatibleTypesComparison
var stream = __wpreq__('readable-stream'),
  eos = __wpreq__('end-of-stream'),
  inherits = __wpreq__('inherits'),
  shift = __wpreq__('stream-shift'),

  SIGNAL_FLUSH = Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from([0]) : new Buffer([0])

var onuncork = function(self, fn) {
  self._corked ? self.once('uncork', fn) : fn()
}

var autoDestroy = function(self, err) {
  self._autoDestroy && self.destroy(err)
}

var destroyer = function(self, end) {
  return function(err) {
    err ? autoDestroy(self, err.message === 'premature close' ? null : err) : !end || self._ended || self.end()
  }
}

var end = function(ws, fn) {
  if (!ws) return fn()
  if (ws._writableState && ws._writableState.finished) return fn()
  if (ws._writableState) return ws.end(fn)
  ws.end()
  fn()
}

var toStreams2 = function(rs) {
  return new stream.Readable({objectMode: true, highWaterMark: 16}).wrap(rs)
}

var Duplexify = function(writable, readable, opts) {
  if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts)
  stream.Duplex.call(this, opts)

  this._writable = null
  this._readable = null
  this._readable2 = null

  this._autoDestroy = !opts || opts.autoDestroy !== false
  this._forwardDestroy = !opts || opts.destroy !== false
  this._forwardEnd = !opts || opts.end !== false
  this._corked = 1
  this._ondrain = null
  this._drained = false
  this._forwarding = false
  this._unwrite = null
  this._unread = null
  this._ended = false

  this.destroyed = false

  writable && this.setWritable(writable)
  readable && this.setReadable(readable)
}

inherits(Duplexify, stream.Duplex)

Duplexify.obj = function(writable, readable, opts) {
  opts || (opts = {})
  opts.objectMode = true
  opts.highWaterMark = 16
  return new Duplexify(writable, readable, opts)
}

Duplexify.prototype.cork = function() {
  ++this._corked != 1 || this.emit('cork')
}

Duplexify.prototype.uncork = function() {
  this._corked && --this._corked == 0 && this.emit('uncork')
}

Duplexify.prototype.setWritable = function(writable) {
  this._unwrite && this._unwrite()

  if (this.destroyed) {
    writable && writable.destroy && writable.destroy()
    return
  }

  if (writable === null || writable === false) {
    this.end()
    return
  }

  var self = this,
    unend = eos(writable, {writable: true, readable: false}, destroyer(this, this._forwardEnd))

  var ondrain = function() {
    var ondrain = self._ondrain
    self._ondrain = null
    ondrain && ondrain()
  }

  var clear = function() {
    self._writable.removeListener('drain', ondrain)
    unend()
  }

  this._unwrite && process.nextTick(ondrain)

  this._writable = writable
  this._writable.on('drain', ondrain)
  this._unwrite = clear

  this.uncork()
}

Duplexify.prototype.setReadable = function(readable) {
  this._unread && this._unread()

  if (this.destroyed) {
    readable && readable.destroy && readable.destroy()
    return
  }

  if (readable === null || readable === false) {
    this.push(null)
    this.resume()
    return
  }

  var self = this,
    unend = eos(readable, {writable: false, readable: true}, destroyer(this))

  var onreadable = function() {
    self._forward()
  }

  var onend = function() {
    self.push(null)
  }

  var clear = function() {
    self._readable2.removeListener('readable', onreadable)
    self._readable2.removeListener('end', onend)
    unend()
  }

  this._drained = true
  this._readable = readable
  this._readable2 = readable._readableState ? readable : toStreams2(readable)
  this._readable2.on('readable', onreadable)
  this._readable2.on('end', onend)
  this._unread = clear

  this._forward()
}

Duplexify.prototype._read = function() {
  this._drained = true
  this._forward()
}

Duplexify.prototype._forward = function() {
  if (this._forwarding || !this._readable2 || !this._drained) return
  this._forwarding = true

  for (var data; this._drained && (data = shift(this._readable2)) !== null; )
    this.destroyed || (this._drained = this.push(data))

  this._forwarding = false
}

Duplexify.prototype.destroy = function(err) {
  if (this.destroyed) return
  this.destroyed = true

  var self = this
  process.nextTick(function() {
    self._destroy(err)
  })
}

Duplexify.prototype._destroy = function(err) {
  if (err) {
    var ondrain = this._ondrain
    this._ondrain = null
    ondrain ? ondrain(err) : this.emit('error', err)
  }

  if (this._forwardDestroy) {
    this._readable && this._readable.destroy && this._readable.destroy()
    this._writable && this._writable.destroy && this._writable.destroy()
  }

  this.emit('close')
}

Duplexify.prototype._write = function(data, enc, cb) {
  if (this.destroyed) return cb()
  if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb))
  if (data === SIGNAL_FLUSH) return this._finish(cb)
  if (!this._writable) return cb()

  this._writable.write(data) === false ? (this._ondrain = cb) : cb()
}

Duplexify.prototype._finish = function(cb) {
  var self = this
  this.emit('preend')
  onuncork(this, function() {
    end(self._forwardEnd && self._writable, function() {
      if (self._writableState.prefinished === false) self._writableState.prefinished = true
      self.emit('prefinish')
      onuncork(self, cb)
    })
  })
}

Duplexify.prototype.end = function(data, enc, cb) {
  if (typeof data == 'function') return this.end(null, null, data)
  if (typeof enc == 'function') return this.end(data, null, enc)
  this._ended = true
  data && this.write(data)
  this._writableState.ending || this.write(SIGNAL_FLUSH)
  return stream.Writable.prototype.end.call(this, cb)
}

module.exports = Duplexify
//
},
'stream-shift':
function(module) {
//
module.exports = shift

function shift(stream) {
  var rs = stream._readableState
  return !rs ? null : rs.objectMode ? stream.read() : stream.read(getStateLength(rs))
}

function getStateLength(state) {
  return state.buffer.length
    ? state.buffer.head
      ? state.buffer.head.data.length
      : state.buffer[0].length
    : state.length
}
//
},
through2:
function(module, exports, __wpreq__) {
//
var Transform = __wpreq__('readable-stream').Transform,
  inherits = __wpreq__('util').inherits,
  xtend = __wpreq__('xtend')

function DestroyableTransform(opts) {
  Transform.call(this, opts)
  this._destroyed = false
}

inherits(DestroyableTransform, Transform)

DestroyableTransform.prototype.destroy = function(err) {
  if (this._destroyed) return
  this._destroyed = true

  var self = this
  process.nextTick(function() {
    err && self.emit('error', err)
    self.emit('close')
  })
}

function noop(chunk, enc, callback) {
  callback(null, chunk)
}

function through2(construct) {
  return function(options, transform, flush) {
    if (typeof options == 'function') {
      flush = transform
      transform = options
      options = {}
    }

    if (typeof transform != 'function') transform = noop

    if (typeof flush != 'function') flush = null

    return construct(options, transform, flush)
  }
}

module.exports = through2(function(options, transform, flush) {
  var t2 = new DestroyableTransform(options)

  t2._transform = transform

  if (flush) t2._flush = flush

  return t2
})

module.exports.ctor = through2(function(options, transform, flush) {
  function Through2(override) {
    if (!(this instanceof Through2)) return new Through2(override)

    this.options = xtend(options, override)

    DestroyableTransform.call(this, this.options)
  }

  inherits(Through2, DestroyableTransform)

  Through2.prototype._transform = transform

  if (flush) Through2.prototype._flush = flush

  return Through2
})

module.exports.obj = through2(function(options, transform, flush) {
  var t2 = new DestroyableTransform(xtend({objectMode: true, highWaterMark: 16}, options))

  t2._transform = transform

  if (flush) t2._flush = flush

  return t2
})
//
},
'buffer-from':
function(module) {
//
var toString = Object.prototype.toString,

  isModern =
    typeof Buffer.alloc == 'function' && typeof Buffer.allocUnsafe == 'function' && typeof Buffer.from == 'function'

function isArrayBuffer(input) {
  return toString.call(input).slice(8, -1) === 'ArrayBuffer'
}

function fromArrayBuffer(obj, byteOffset, length) {
  byteOffset >>>= 0

  var maxLength = obj.byteLength - byteOffset

  if (maxLength < 0) throw new RangeError("'offset' is out of bounds")

  if (length === void 0) length = maxLength
  else if ((length >>>= 0) > maxLength) throw new RangeError("'length' is out of bounds")

  return isModern
    ? Buffer.from(obj.slice(byteOffset, byteOffset + length))
    : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)))
}

function fromString(string, encoding) {
  if (typeof encoding != 'string' || encoding === '') encoding = 'utf8'

  if (!Buffer.isEncoding(encoding)) throw new TypeError('"encoding" must be a valid string encoding')

  return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding)
}

function bufferFrom(value, encodingOrOffset, length) {
  if (typeof value == 'number') throw new TypeError('"value" argument must not be a number')

  return isArrayBuffer(value)
    ? fromArrayBuffer(value, encodingOrOffset, length)
    : typeof value == 'string'
    ? fromString(value, encodingOrOffset)
    : isModern
    ? Buffer.from(value)
    : new Buffer(value)
}

module.exports = bufferFrom
//
},
pumpify:
function(module, exports, __wpreq__) {
//
var pump = __wpreq__('pump'),
  inherits = __wpreq__('inherits'),
  Duplexify = __wpreq__('duplexify')

var toArray = function(args) {
  return !args.length ? [] : Array.isArray(args[0]) ? args[0] : Array.prototype.slice.call(args)
}

var define = function(opts) {
  var Pumpify = function() {
    var streams = toArray(arguments)
    if (!(this instanceof Pumpify)) return new Pumpify(streams)
    Duplexify.call(this, null, null, opts)
    streams.length && this.setPipeline(streams)
  }

  inherits(Pumpify, Duplexify)

  Pumpify.prototype.setPipeline = function() {
    var streams = toArray(arguments),
      self = this,
      ended = false,
      w = streams[0],
      r = streams[streams.length - 1]

    r = r.readable ? r : null
    w = w.writable ? w : null

    var onclose = function() {
      streams[0].emit('error', new Error('stream was destroyed'))
    }

    this.on('close', onclose)
    this.on('prefinish', function() {
      ended || self.cork()
    })

    pump(streams, function(err) {
      self.removeListener('close', onclose)
      if (err) return self.destroy(err.message === 'premature close' ? null : err)
      ended = true
      if (self._autoDestroy === false) self._autoDestroy = true
      self.uncork()
    })

    if (this.destroyed) return onclose()
    this.setWritable(w)
    this.setReadable(r)
  }

  return Pumpify
}

module.exports = define({autoDestroy: false, destroy: false})
module.exports.obj = define({autoDestroy: false, destroy: false, objectMode: true, highWaterMark: 16})
module.exports.ctor = define
//
},
'is-gzip':
function(module) {
//
module.exports = function(buf) {
  return !(!buf || buf.length < 3) && buf[0] === 31 && buf[1] === 139 && buf[2] === 8;
};
//
},
'is-deflate':
function(module) {
//
module.exports = function(buf) {
  return !(!buf || buf.length < 2 || buf[0] !== 0x78 || (buf[1] !== 1 && buf[1] !== 0x9c && buf[1] !== 0xda))
}
//
},
dnscache:
function(module, exports, __wpreq__) {
//
var CacheObject = __wpreq__('dnscache/lib/cache'),
  deepCopy = __wpreq__('lodash.clone'),
  dns = __wpreq__('dns');

var EnhanceDns = function(conf) {
  (conf = conf || {}).ttl = parseInt(conf.ttl, 10) || 300;
  conf.cachesize = parseInt(conf.cachesize, 10);

  if (isNaN(conf.cachesize)) conf.cachesize = 1000;
  if (!conf.enable || conf.cachesize <= 0 || dns.internalCache) return dns;

  var backup_object = {
    lookup: dns.lookup,
    resolve: dns.resolve,
    resolve4: dns.resolve4,
    resolve6: dns.resolve6,
    resolveMx: dns.resolveMx,
    resolveTxt: dns.resolveTxt,
    resolveSrv: dns.resolveSrv,
    resolveNs: dns.resolveNs,
    resolveCname: dns.resolveCname,
    reverse: dns.reverse
  };
  var cache = conf.cache ? new conf.cache(conf) : new CacheObject(conf);

  dns.internalCache = cache;

  dns.lookup = function(domain, options, callback) {
    var family = 0,
      hints = 0,
      all = false;
    if (arguments.length === 2) {
      callback = options;
      options = family;
    } else if (typeof options == 'object') {
      if (options.family && (family = +options.family) != 4 && family !== 6) {
        callback(new Error('invalid argument: `family` must be 4 or 6'));
        return;
      }
      if (options.hints) hints = +options.hints;

      all = options.all === true;
    } else if (options && (family = +options) != 4 && family !== 6) {
      callback(new Error('invalid argument: `family` must be 4 or 6'));
      return;
    }

    cache.get('lookup_' + domain + '_' + family + '_' + hints + '_' + all, function(error, record) {
      if (record)
        return Array.isArray(record) ? callback(error, record) : callback(error, record.address, record.family);

      try {
        backup_object.lookup(domain, options, function(err, address, family_r) {
          if (err) return callback(err);

          var value = Array.isArray(address) ? address : {address: address, family: family_r};

          cache.set('lookup_' + domain + '_' + family + '_' + hints + '_' + all, value, function() {
            callback(err, address, family_r);
          });
        });
      } catch (err) {
        callback(err);
      }
    });
  };

  dns.resolve = function(domain, type, callback) {
    var type_new, callback_new;

    if (typeof type == 'string') {
      type_new = type;
      callback_new = callback;
    } else {
      type_new = "A";
      callback_new = type;
    }

    cache.get('resolve_' + domain + '_' + type_new, function(error, record) {
      if (record) return callback_new(error, deepCopy(record), true);

      try {
        backup_object.resolve(domain, type_new, function(err, addresses) {
          if (err) return callback_new(err);

          cache.set('resolve_' + domain + '_' + type_new, addresses, function() {
            callback_new(err, deepCopy(addresses), false);
          });
        });
      } catch (err) {
        callback_new(err);
      }
    });
  };

  dns.resolve4 = function(domain, callback) {
    cache.get('resolve4_' + domain, function(error, record) {
      if (record) return callback(error, deepCopy(record));

      try {
        backup_object.resolve4(domain, function(err, addresses) {
          if (err) return callback(err);

          cache.set('resolve4_' + domain, addresses, function() {
            callback(err, deepCopy(addresses));
          });
        });
      } catch (err) {
        callback(err);
      }
    });
  };

  dns.resolve6 = function(domain, callback) {
    cache.get('resolve6_' + domain, function(error, record) {
      if (record) return callback(error, deepCopy(record));

      try {
        backup_object.resolve6(domain, function(err, addresses) {
          if (err) return callback(err);

          cache.set('resolve6_' + domain, addresses, function() {
            callback(err, deepCopy(addresses));
          });
        });
      } catch (err) {
        callback(err);
      }
    });
  };

  dns.resolveMx = function(domain, callback) {
    cache.get('resolveMx_' + domain, function(error, record) {
      if (record) return callback(error, deepCopy(record));

      try {
        backup_object.resolveMx(domain, function(err, addresses) {
          if (err) return callback(err);

          cache.set('resolveMx_' + domain, addresses, function() {
            callback(err, deepCopy(addresses));
          });
        });
      } catch (err) {
        callback(err);
      }
    });
  };

  dns.resolveTxt = function(domain, callback) {
    cache.get('resolveTxt_' + domain, function(error, record) {
      if (record) return callback(error, deepCopy(record));

      try {
        backup_object.resolveTxt(domain, function(err, addresses) {
          if (err) return callback(err);

          cache.set('resolveTxt_' + domain, addresses, function() {
            callback(err, deepCopy(addresses));
          });
        });
      } catch (err) {
        callback(err);
      }
    });
  };

  dns.resolveSrv = function(domain, callback) {
    cache.get('resolveSrv_' + domain, function(error, record) {
      if (record) return callback(error, deepCopy(record));

      try {
        backup_object.resolveSrv(domain, function(err, addresses) {
          if (err) return callback(err);

          cache.set('resolveSrv_' + domain, addresses, function() {
            callback(err, deepCopy(addresses));
          });
        });
      } catch (err) {
        callback(err);
      }
    });
  };

  dns.resolveNs = function(domain, callback) {
    cache.get('resolveNs_' + domain, function(error, record) {
      if (record) return callback(error, deepCopy(record));

      try {
        backup_object.resolveNs(domain, function(err, addresses) {
          if (err) return callback(err);

          cache.set('resolveNs_' + domain, addresses, function() {
            callback(err, deepCopy(addresses));
          });
        });
      } catch (err) {
        callback(err);
      }
    });
  };

  dns.resolveCname = function(domain, callback) {
    cache.get('resolveCname_' + domain, function(error, record) {
      if (record) return callback(error, deepCopy(record));

      try {
        backup_object.resolveCname(domain, function(err, addresses) {
          if (err) return callback(err);

          cache.set('resolveCname_' + domain, addresses, function() {
            callback(err, deepCopy(addresses));
          });
        });
      } catch (err) {
        callback(err);
      }
    });
  };

  dns.reverse = function(ip, callback) {
    cache.get('reverse_' + ip, function(error, record) {
      if (record) return callback(error, deepCopy(record));

      try {
        backup_object.reverse(ip, function(err, addresses) {
          if (err) return callback(err);

          cache.set('reverse_' + ip, addresses, function() {
            callback(err, deepCopy(addresses));
          });
        });
      } catch (err) {
        callback(err);
      }
    });
  };
  return dns;
};

module.exports = function(conf) {
  return new EnhanceDns(conf);
};
//
},
'dnscache/lib/cache':
function(module, exports, __wpreq__) {
//
function CacheObject(conf) {
  (conf = conf || {}).ttl = parseInt(conf.ttl, 10) || 300;
  conf.cachesize = parseInt(conf.cachesize, 10) || 1000;

  this.ttl = conf.ttl * 1000;
  this.max = conf.cachesize;

  this.count = 0;
  this.data = {};
  var next = __wpreq__('asap');

  this.set = function(key, value, callback) {
    var self = this;
    next(function() {
      if (self.data[key]) {
        if (self.data[key].newer) {
          if (self.data[key].older) {
            self.data[key].newer.older = self.data[key].older;
            self.data[key].older.newer = self.data[key].newer;
          } else {
            self.tail = self.data[key].newer;
            delete self.tail.older;
          }

          self.data[key].older = self.head;
          self.head.newer = self.data[key];
          delete self.data[key].newer;
          self.head = self.data[key];
        }

        self.head.val = value;
        self.head.hit = 0;
        self.head.ts = Date.now();
      } else {
        self.data[key] = {key: key, val: value, hit: 0, ts: Date.now()};

        if (!self.head) {
          self.head = self.data[key];
          self.tail = self.data[key];
        } else {
          self.head.newer = self.data[key];
          self.data[key].older = self.head;
          self.head = self.data[key];
        }

        if (self.count >= self.max) {
          var temp = self.tail;
          self.tail = self.tail.newer;
          delete self.tail.next;
          delete self.data[temp.key];
        } else self.count = self.count + 1;
      }
      callback && callback(null, value);
    });
  };

  this.get = function(key, callback) {
    var self = this;
    if (!callback) throw 'cache.get callback is required.';

    next(function() {
      if (!self.data[key]) return callback(null, void 0);

      var value;
      if (conf.ttl !== 0 && Date.now() - self.data[key].ts >= self.ttl) {
        if (self.data[key].newer)
          if (self.data[key].older) {
            self.data[key].newer.older = self.data[key].older;
            self.data[key].older.newer = self.data[key].newer;
          } else {
            self.tail = self.data[key].newer;
            delete self.tail.older;
          }
        else if (self.data[key].older) {
          self.head = self.data[key].older;
          delete self.head.newer;
        } else {
          delete self.head;
          delete self.tail;
        }

        delete self.data[key];
        self.count = self.count - 1;
      } else {
        self.data[key].hit = self.data[key].hit + 1;
        value = self.data[key].val;
      }
      callback(null, value);
    });
  };
}

module.exports = CacheObject;
//
},
asap:
function(module, exports, __wpreq__) {
//
var rawAsap = __wpreq__('asap/raw'),
  freeTasks = [];

module.exports = asap;
function asap(task) {
  var rawTask = freeTasks.length ? freeTasks.pop() : new RawTask();

  rawTask.task = task;
  rawTask.domain = process.domain;
  rawAsap(rawTask);
}

function RawTask() {
  this.task = null;
  this.domain = null;
}

RawTask.prototype.call = function() {
  this.domain && this.domain.enter();

  var threw = true;
  try {
    this.task.call();
    threw = false;
    this.domain && this.domain.exit();
  } finally {
    threw && rawAsap.requestFlush();

    this.task = null;
    this.domain = null;
    freeTasks.push(this);
  }
};
//
},
'asap/raw':
function(module, exports, __wpreq__) {
//
var domain,
  hasSetImmediate = typeof setImmediate == "function";

module.exports = rawAsap;
function rawAsap(task) {
  if (!queue.length) {
    requestFlush();
    flushing = true;
  }
  queue[queue.length] = task;
}

var queue = [],
  flushing = false,
  index = 0,
  capacity = 1024;

function flush() {
  while (index < queue.length) {
    var currentIndex = index;
    index += 1;
    queue[currentIndex].call();
    if (index > capacity) {
      for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++)
        queue[scan] = queue[scan + index];

      queue.length -= index;
      index = 0;
    }
  }
  queue.length = 0;
  index = 0;
  flushing = false;
}

rawAsap.requestFlush = requestFlush;
function requestFlush() {
  var parentDomain = process.domain;
  if (parentDomain) {
    domain || (domain = __wpreq__('domain'));

    domain.active = process.domain = null;
  }

  flushing && hasSetImmediate ? setImmediate(flush) : process.nextTick(flush);

  if (parentDomain) domain.active = process.domain = parentDomain;
}
//
},
domain:
function(module) {
//
module.exports = require('domain');
//
},
'lodash.clone':
function(module, exports, __wpreq__) {
//
module.exports = __wpreq__('lodash').clone;
//
},
dns:
function(module) {
//
module.exports = require('dns');
//
},
'request-capture-har':
function(module, exports, __wpreq__) {
//
var fs = __wpreq__('fs'),
  pkg = __wpreq__('request-capture-har/package.json');

function buildHarHeaders(headers) {
  return headers ? Object.keys(headers).map(function(key) {
    return {name: key, value: headers[key].toString()};
  }) : [];
}

function appendPostData(entry, request) {
  if (request.body) entry.request.postData = {mimeType: 'application/octet-stream', text: request.body};
}

function toMs(num) {
  return Math.round(num * 1000) / 1000;
}

function HarWrapper(requestModule) {
  this.requestModule = requestModule;
  this.clear();
}

HarWrapper.prototype.request = function(options) {
  Object.assign(options, {time: true});
  var self = this;
  return this.requestModule(options, function(err, incomingMessage, response) {
    err || self.entries.push(self.buildHarEntry(incomingMessage));

    typeof options.callback != 'function' || options.callback.apply(null, arguments);
  });
};

HarWrapper.prototype.clear = function() {
  this.entries = [];
  this.earliestTime = new Date(2099, 1, 1);
};

HarWrapper.prototype.saveHar = function(fileName) {
  var httpArchive = {
    log: {
      version: '1.2',
      creator: {name: 'request-capture-har', version: pkg.version},
      pages: [{
        startedDateTime: new Date(this.earliestTime).toISOString(),
        id: 'request-capture-har',
        title: 'request-capture-har',
        pageTimings: {}
      }],
      entries: this.entries
    }
  };
  fs.writeFileSync(fileName, JSON.stringify(httpArchive, null, 2));
};

HarWrapper.prototype.buildTimings = function(entry, response) {
  var startTs = response.request.startTime,
    endTs = startTs + response.elapsedTime,
    totalTime = endTs - startTs;

  if (new Date(startTs) < this.earliestTime) this.earliestTime = new Date(startTs);

  entry.startedDateTime = new Date(startTs).toISOString();
  entry.time = totalTime;

  if (response.timingPhases) {
    entry.timings = {
      blocked: toMs(response.timingPhases.wait),
      dns: toMs(response.timingPhases.dns),
      connect: toMs(response.timingPhases.tcp),
      send: 0,
      wait: toMs(response.timingPhases.firstByte),
      receive: toMs(response.timingPhases.download)
    };
    return;
  }

  var responseStartTs = response.request.response.responseStartTime,

    waitingTime = responseStartTs - startTs,
    receiveTime = endTs - responseStartTs;
  entry.timings = {send: 0, wait: waitingTime, receive: receiveTime};
};

HarWrapper.prototype.buildHarEntry = function(response) {
  var entry = {
    request: {
      method: response.request.method,
      url: response.request.uri.href,
      httpVersion: 'HTTP/' + response.httpVersion,
      cookies: [],
      headers: buildHarHeaders(response.request.headers),
      queryString: [],
      headersSize: -1,
      bodySize: -1
    },
    response: {
      status: response.statusCode,
      statusText: response.statusMessage,
      httpVersion: 'HTTP/' + response.httpVersion,
      cookies: [],
      headers: buildHarHeaders(response.headers),
      _transferSize: response.body.length,
      content: {size: response.body.length, mimeType: response.headers['content-type']},
      redirectURL: '',
      headersSize: -1,
      bodySize: -1
    },
    cache: {}
  };
  this.buildTimings(entry, response);
  appendPostData(entry, response.request);
  return entry;
};

module.exports = HarWrapper;
//
},
'request-capture-har/package.json':
function(module) {
//
module.exports = {
  name: 'request-capture-har',
  version: '1.2.2',
  description: 'Wrapper for request module that saves all traffic as a HAR file, useful for auto mocking a client'
};
//
},
'detect-indent':
function(module) {
//
const INDENT_RE = /^(?:( )+|\t+)/;

function getMostUsed(indents) {
  let result = 0,
    maxUsed = 0,
    maxWeight = 0;

  for (const entry of indents) {
    const key = entry[0],
      val = entry[1],

      u = val[0],
      w = val[1];

    if (u > maxUsed || (u === maxUsed && w > maxWeight)) {
      maxUsed = u;
      maxWeight = w;
      result = Number(key);
    }
  }

  return result;
}

module.exports = str => {
  if (typeof str != 'string') throw new TypeError('Expected a string');

  let tabs = 0,
    spaces = 0,

    prev = 0;

  const indents = new Map();

  let current, isIndent;

  for (const line of str.split(/\n/g)) {
    if (!line) continue;

    let indent;
    const matches = line.match(INDENT_RE);

    if (matches) {
      indent = matches[0].length;

      matches[1] ? spaces++ : tabs++;
    } else indent = 0;

    const diff = indent - prev;
    prev = indent;

    if (diff) {
      isIndent = diff > 0;

      current = indents.get(isIndent ? diff : -diff);

      if (current) current[0]++;
      else {
        current = [1, 0];
        indents.set(diff, current);
      }
    } else if (current) current[1] += Number(isIndent);
  }

  const amount = getMostUsed(indents);

  let type, indent;
  if (!amount) {
    type = null;
    indent = '';
  } else if (spaces >= tabs) {
    type = 'space';
    indent = ' '.repeat(amount);
  } else {
    type = 'tab';
    indent = '\t'.repeat(amount);
  }

  return {amount, type, indent};
};
//
},
'resolve/lib/sync':
function(module, exports, __wpreq__) {
//
var core = __wpreq__('resolve/lib/core'),
  fs = __wpreq__('fs'),
  path = __wpreq__('path'),
  caller = __wpreq__('resolve/lib/caller'),
  nodeModulesPaths = __wpreq__('resolve/lib/node-modules-paths');

var defaultIsFile = function(file) {
  try {
    var stat = fs.statSync(file);
  } catch (e) {
    if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
    throw e;
  }
  return stat.isFile() || stat.isFIFO();
};

module.exports = function(x, options) {
  if (typeof x != 'string') throw new TypeError('Path must be a string.');

  var opts = options || {},
    isFile = opts.isFile || defaultIsFile,
    readFileSync = opts.readFileSync || fs.readFileSync,

    extensions = opts.extensions || ['.js'],
    basedir = opts.basedir || path.dirname(caller()),
    parent = opts.filename || basedir;

  opts.paths = opts.paths || [];

  if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
    var res = path.resolve(basedir, x);
    if (x === '..' || x.slice(-1) === '/') res += '/';
    var m = loadAsFileSync(res) || loadAsDirectorySync(res);
    if (m) return m;
  } else {
    var n = loadNodeModulesSync(x, basedir);
    if (n) return n;
  }

  if (core[x]) return x;

  var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
  err.code = 'MODULE_NOT_FOUND';
  throw err;

  function loadAsFileSync(x) {
    var pkg = loadpkg(path.dirname(x));

    if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
      var rfile = path.relative(pkg.dir, x),
        r = opts.pathFilter(pkg.pkg, x, rfile);
      if (r) x = path.resolve(pkg.dir, r);
    }

    if (isFile(x)) return x;

    for (var i = 0; i < extensions.length; i++) {
      var file = x + extensions[i];
      if (isFile(file)) return file;
    }
  }

  function loadpkg(dir) {
    if (
      dir === '' || dir === '/' ||
      (process.platform === 'win32' && /^\w:[/\\]*$/.test(dir)) ||
      /[/\\]node_modules[/\\]*$/.test(dir)
    )
      return;

    var pkgfile = path.join(dir, 'package.json');

    if (!isFile(pkgfile)) return loadpkg(path.dirname(dir));

    var body = readFileSync(pkgfile);

    try {
      var pkg = JSON.parse(body);
    } catch (_jsonErr) {}

    if (pkg && opts.packageFilter) pkg = opts.packageFilter(pkg, dir);

    return {pkg: pkg, dir: dir};
  }

  function loadAsDirectorySync(x) {
    var pkgfile = path.join(x, '/package.json');
    if (isFile(pkgfile))
      try {
        var body = readFileSync(pkgfile, 'UTF8'),
          pkg = JSON.parse(body);

        if (opts.packageFilter) pkg = opts.packageFilter(pkg, x);

        if (pkg.main) {
          if (pkg.main === '.' || pkg.main === './') pkg.main = 'index';

          var m = loadAsFileSync(path.resolve(x, pkg.main));
          if (m) return m;
          var n = loadAsDirectorySync(path.resolve(x, pkg.main));
          if (n) return n;
        }
      } catch (_) {}

    return loadAsFileSync(path.join(x, '/index'));
  }

  function loadNodeModulesSync(x, start) {
    for (var dirs = nodeModulesPaths(start, opts), i = 0; i < dirs.length; i++) {
      var dir = dirs[i],
        m = loadAsFileSync(path.join(dir, '/', x));
      if (m) return m;
      var n = loadAsDirectorySync(path.join(dir, '/', x));
      if (n) return n;
    }
  }
};
module.exports.core = core;
module.exports.sync = module.exports;
//
},
'resolve/lib/core':
function(module, exports, __wpreq__) {
//
var current = (process.versions && process.versions.node && process.versions.node.split('.')) || [];

function specifierIncluded(specifier) {
  var parts = specifier.split(' '),
    op = parts.length > 1 ? parts[0] : '=';

  for (var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.'), i = 0; i < 3; ++i) {
    var cur = Number(current[i] || 0),
      ver = Number(versionParts[i] || 0);

    if (cur !== ver) return op === '<' ? cur < ver : op === '>=' && cur >= ver;
  }
  return op === '>=';
}

function matchesRange(range) {
  var specifiers = range.split(/ ?&& ?/);
  if (specifiers.length === 0) return false;
  for (var i = 0; i < specifiers.length; ++i) if (!specifierIncluded(specifiers[i])) return false;

  return true;
}

function versionIncluded(specifierValue) {
  if (typeof specifierValue == 'boolean') return specifierValue;
  if (specifierValue && typeof specifierValue == 'object') {
    for (var i = 0; i < specifierValue.length; ++i) if (matchesRange(specifierValue[i])) return true;

    return false;
  }
  return matchesRange(specifierValue);
}

var data = __wpreq__('resolve/lib/core.json'),

  core = {};
for (var mod in data) if (Object.prototype.hasOwnProperty.call(data, mod)) core[mod] = versionIncluded(data[mod]);

module.exports = core;
//
},
'resolve/lib/core.json':
function(module) {
//
module.exports = JSON.parse(
  '{"assert":true,"async_hooks":">= 8","buffer_ieee754":"< 0.9.7","buffer":true,"child_process":true,"cluster":true,"console":true,"constants":true,"crypto":true,"_debugger":"< 8","dgram":true,"dns":true,"domain":true,"events":true,"freelist":"< 6","fs":true,"_debug_agent":">= 1 && < 8","diagnostics_channel":[">= 14.17 && < 15",">= 15.1"],"fs/promises":[">= 10 && < 10.1",">= 14"],"_http_agent":">= 0.11.1","_http_client":">= 0.11.1","_http_common":">= 0.11.1","_http_incoming":">= 0.11.1","_http_outgoing":">= 0.11.1","_http_server":">= 0.11.1","http":true,"http2":">= 8.8","https":true,"inspector":">= 8.0.0","_linklist":"< 8","module":true,"net":true,"node-inspect/lib/_inspect":">= 7.6 && < 12","node-inspect/lib/internal/inspect_client":">= 7.6 && < 12","node-inspect/lib/internal/inspect_repl":">= 7.6 && < 12","os":true,"path":true,"perf_hooks":">= 8.5","process":">= 1","punycode":true,"querystring":true,"readline":true,"repl":true,"smalloc":">= 0.11.5 && < 3","_stream_duplex":">= 0.9.4","_stream_transform":">= 0.9.4","_stream_wrap":">= 1.4.1","_stream_passthrough":">= 0.9.4","_stream_readable":">= 0.9.4","_stream_writable":">= 0.9.4","stream":true,"string_decoder":true,"sys":true,"timers":true,"_tls_common":">= 0.11.13","_tls_legacy":">= 0.11.3 && < 10","_tls_wrap":">= 0.11.3","tls":true,"trace_events":">= 10","tty":true,"url":true,"util":true,"v8/tools/arguments":">= 10 && < 12","v8/tools/codemap":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/consarray":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/csvparser":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/logreader":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/profile_view":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/splaytree":[">= 4.4 && < 5",">= 5.2 && < 12"],"worker_threads":">= 11.7","v8":">= 1","vm":true,"zlib":true}'
);
//
},
'resolve/lib/caller':
function(module) {
//
module.exports = function() {
  var origPrepareStackTrace = Error.prepareStackTrace;
  Error.prepareStackTrace = function(_, stack) { return stack; };
  var stack = new Error().stack;
  Error.prepareStackTrace = origPrepareStackTrace;
  return stack[2].getFileName();
};
//
},
'resolve/lib/node-modules-paths':
function(module, exports, __wpreq__) {
//
var path = __wpreq__('path'),
  fs = __wpreq__('fs'),
  parse = path.parse || __wpreq__('path-parse');

module.exports = function(start, opts) {
  var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ['node_modules'],

    absoluteStart = path.resolve(start);

  if (opts && opts.preserveSymlinks === false)
    try {
      absoluteStart = fs.realpathSync(absoluteStart);
    } catch (err) {
      if (err.code !== 'ENOENT') throw err;
    }

  var prefix = '/';
  if (/^([A-Za-z]:)/.test(absoluteStart)) prefix = '';
  else if (/^\\\\/.test(absoluteStart)) prefix = '\\\\';

  var paths = [absoluteStart];
  for (var parsed = parse(absoluteStart); parsed.dir !== paths[paths.length - 1]; ) {
    paths.push(parsed.dir);
    parsed = parse(parsed.dir);
  }

  var dirs = paths.reduce(function(dirs, aPath) {
    return dirs.concat(modules.map(function(moduleDir) {
      return path.join(prefix, aPath, moduleDir);
    }));
  }, []);

  return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
};
//
},
'path-parse':
function(module) {
//
module.exports = require('path').parse;
//
},
'deep-equal':
function(module, exports, __wpreq__) {
//
var pSlice = Array.prototype.slice,
  objectKeys = __wpreq__('deep-equal/lib/keys'),
  isArguments = __wpreq__('deep-equal/lib/is_arguments');

var deepEqual = (module.exports = function(actual, expected, opts) {
  opts || (opts = {});
  return actual === expected ||
    (actual instanceof Date && expected instanceof Date
      ? actual.getTime() === expected.getTime()
      : !actual || !expected || (typeof actual != 'object' && typeof expected != 'object')
      ? (opts.strict ? actual === expected : actual == expected)
      : objEquiv(actual, expected, opts));
})

function isUndefinedOrNull(value) {
  return value === null || value === void 0;
}

function isBuffer(x) {
  return !(
    !x || typeof x != 'object' || typeof x.length != 'number' ||
    typeof x.copy != 'function' || typeof x.slice != 'function' ||
    (x.length > 0 && typeof x[0] != 'number')
  );
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b) || a.prototype !== b.prototype) return false;
  if (isArguments(a)) {
    if (!isArguments(b)) return false;

    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b) || a.length !== b.length) return false;

    for (i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;

    return true;
  }
  try {
    var ka = objectKeys(a),
      kb = objectKeys(b);
  } catch (_e) {
    return false;
  }
  if (ka.length != kb.length) return false;
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) if (ka[i] != kb[i]) return false;

  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a == typeof b;
}
//
},
'deep-equal/lib/keys':
function(module) {
//
(module.exports = typeof Object.keys == 'function' ? Object.keys : shim).shim = shim;

function shim(obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
//
},
'deep-equal/lib/is_arguments':
function(module, exports) {
//
var supportsArgumentsClass = (function() {
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

exports.unsupported = unsupported;
function unsupported(object) {
  return (
    object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee')
  ) || false;
}
//
},
'node-emoji':
function(module, exports, __wpreq__) {
//
var toArray = __wpreq__('lodash.toarray'),
  emojiByName = __wpreq__('node-emoji/lib/emoji.json'),

  emojiNameRegex = /:([a-zA-Z0-9_\-+]+):/g,
  trimSpaceRegex = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

function stripColons(str) {
  var colonIndex = str.indexOf(':');
  return colonIndex > -1
    ? colonIndex === str.length - 1
      ? stripColons((str = str.substring(0, colonIndex)))
      : stripColons((str = str.substr(colonIndex + 1)))
    : str;
}

function wrapColons(str) {
  return typeof str == 'string' && str.length > 0 ? ':' + str + ':' : str;
}

function ensureColons(str) {
  return typeof str == 'string' && str[0] !== ':' ? wrapColons(str) : str;
}

var NON_SPACING_MARK = String.fromCharCode(65039),
  nonSpacingRegex = new RegExp(NON_SPACING_MARK, 'g')

function stripNSB(code) {
  return code.replace(nonSpacingRegex, '');
}

var emojiByCode = Object.keys(emojiByName).reduce(function(h, k) {
  h[stripNSB(emojiByName[k])] = k;
  return h;
}, {});

var Emoji = {emoji: emojiByName};

Emoji._get = function(emoji) {
  return emojiByName.hasOwnProperty(emoji) ? emojiByName[emoji] : ensureColons(emoji);
};

Emoji.get = function(emoji) {
  emoji = stripColons(emoji);

  return Emoji._get(emoji);
};

Emoji.find = function(nameOrCode) {
  return Emoji.findByName(nameOrCode) || Emoji.findByCode(nameOrCode);
};

Emoji.findByName = function(name) {
  var stripped = stripColons(name),
    emoji = emojiByName[stripped];

  return emoji ? {emoji: emoji, key: stripped} : void 0;
};

Emoji.findByCode = function(code) {
  var stripped = stripNSB(code),
    name = emojiByCode[stripped];

  return name ? {emoji: emojiByName[name], key: name} : void 0;
};

Emoji.hasEmoji = function(nameOrCode) {
  return Emoji.hasEmojiByName(nameOrCode) || Emoji.hasEmojiByCode(nameOrCode);
};

Emoji.hasEmojiByName = function(name) {
  var result = Emoji.findByName(name);
  return !!result && result.key === stripColons(name);
};

Emoji.hasEmojiByCode = function(code) {
  var result = Emoji.findByCode(code);
  return !!result && stripNSB(result.emoji) === stripNSB(code);
};

Emoji.which = function(emoji_code, includeColons) {
  var code = stripNSB(emoji_code),
    word = emojiByCode[code];

  return includeColons ? wrapColons(word) : word;
};

Emoji.emojify = function(str, on_missing, format) {
  if (!str) return '';

  return str
    .split(emojiNameRegex)
    .map(function(s, i) {
      if (i % 2 == 0) return s;
      var emoji = Emoji._get(s),
        isMissing = emoji.indexOf(':') > -1;

      return isMissing && typeof on_missing == 'function'
        ? on_missing(s)
        : isMissing || typeof format != 'function'
        ? emoji
        : format(emoji, s);
    })
    .join('');
};

Emoji.random = function() {
  var emojiKeys = Object.keys(emojiByName),
    key = emojiKeys[Math.floor(Math.random() * emojiKeys.length)];
  return {key: key, emoji: Emoji._get(key)};
}

Emoji.search = function(str) {
  var emojiKeys = Object.keys(emojiByName),
    matcher = stripColons(str)
  return emojiKeys
    .filter(function(key) {
      return key.toString().indexOf(matcher) === 0;
    })
    .map(function(key) {
      return {key: key, emoji: Emoji._get(key)};
    });
}

Emoji.unemojify = function(str) {
  if (!str) return '';

  return toArray(str).map(function(word) {
    return Emoji.which(word, true) || word;
  }).join('');
};

Emoji.replace = function(str, replacement, cleanSpaces) {
  if (!str) return '';

  var replace = typeof replacement == 'function' ? replacement : function() { return replacement; };
  var words = toArray(str);

  var replaced = words.map(function(word, idx) {
    var emoji = Emoji.findByCode(word);

    if (emoji && cleanSpaces && words[idx + 1] === ' ') words[idx + 1] = '';

    return emoji ? replace(emoji) : word;
  }).join('');

  return cleanSpaces ? replaced.replace(trimSpaceRegex, '') : replaced;
};

Emoji.strip = function(str) {
  return Emoji.replace(str, '', true);
};

module.exports = Emoji;
//
},
'lodash.toarray':
function(module, exports, __wpreq__) {
//
module.exports = __wpreq__('lodash').toArray;
//
},
'node-emoji/lib/emoji.json':
function(module) {
// noinspection SpellCheckingInspection
module.exports = JSON.parse(
  '{"100":"","1234":"","interrobang":"","tm":"","information_source":"","left_right_arrow":"","arrow_up_down":"","arrow_upper_left":"","arrow_upper_right":"","arrow_lower_right":"","arrow_lower_left":"","keyboard":"","sunny":"","cloud":"","umbrella":"","showman":"","comet":"","ballot_box_with_check":"","coffee":"","shamrock":"","skull_and_crossbones":"","radioactive_sign":"","biohazard_sign":"","orthodox_cross":"","wheel_of_dharma":"","white_frowning_face":"","aries":"","taurus":"","sagittarius":"","capricorn":"","aquarius":"","pisces":"","spades":"","clubs":"","hearts":"","diamonds":"","hotsprings":"","hammer_and_pick":"","anchor":"","crossed_swords":"","scales":"","alembic":"","gear":"","scissors":"","white_check_mark":"","airplane":"","email":"","envelope":"","black_nib":"","heavy_check_mark":"","heavy_multiplication_x":"","star_of_david":"","sparkles":"","eight_spoked_asterisk":"","eight_pointed_black_star":"","snowflake":"","sparkle":"","question":"","grey_question":"","grey_exclamation":"","exclamation":"","heavy_exclamation_mark":"","heavy_heart_exclamation_mark_ornament":"","heart":"","heavy_plus_sign":"","heavy_minus_sign":"","heavy_division_sign":"","arrow_heading_up":"","arrow_heading_down":"","wavy_dash":"","congratulations":"","secret":"","copyright":"","registered":"","bangbang":"","leftwards_arrow_with_hook":"","arrow_right_hook":"","watch":"","hourglass":"","fast_forward":"","rewind":"","arrow_double_up":"","arrow_double_down":"","black_right_pointing_double_triangle_with_vertical_bar":"","black_left_pointing_double_triangle_with_vertical_bar":"","black_right_pointing_triangle_with_double_vertical_bar":"","alarm_clock":"","stopwatch":"","timer_clock":"","hourglass_flowing_sand":"","double_vertical_bar":"","black_square_for_stop":"","black_circle_for_record":"","m":"","black_small_square":"","white_small_square":"","arrow_forward":"","arrow_backward":"","white_medium_square":"","black_medium_square":"","white_medium_small_square":"","black_medium_small_square":"","phone":"","telephone":"","point_up":"","star_and_crescent":"","peace_symbol":"","yin_yang":"","relaxed":"","gemini":"","cancer":"","leo":"","virgo":"","libra":"","scorpius":"","recycle":"","wheelchair":"","atom_symbol":"","fleur_de_lis":"","warning":"","zap":"","white_circle":"","black_circle":"","coffin":"","funeral_urn":"","soccer":"","baseball":"","snowman":"","partly_sunny":"","thunder_cloud_and_rain":"","ophiuchus":"","pick":"","helmet_with_white_cross":"","chains":"","no_entry":"","shinto_shrine":"","church":"","mountain":"","umbrella_on_ground":"","fountain":"","golf":"","ferry":"","boat":"","sailboat":"","skier":"","ice_skate":"","person_with_ball":"","tent":"","fuelpump":"","fist":"","hand":"","raised_hand":"","v":"","writing_hand":"","pencil2":"","latin_cross":"","x":"","negative_squared_cross_mark":"","arrow_right":"","curly_loop":"","loop":"","arrow_left":"","arrow_up":"","arrow_down":"","black_large_square":"","white_large_square":"","star":"","o":"","part_alternation_mark":"","mahjong":"","black_joker":"","a":"","b":"","o2":"","parking":"","ab":"","cl":"","cool":"","free":"","id":"","new":"","ng":"","ok":"","sos":"","up":"","vs":"","koko":"","sa":"","u7121":"","u6307":"","u7981":"","u7a7a":"","u5408":"","u6e80":"","u6709":"","u6708":"","u7533":"","u5272":"","u55b6":"","ideograph_advantage":"","accept":"","cyclone":"","foggy":"","closed_umbrella":"","night_with_stars":"","sunrise_over_mountains":"","sunrise":"","city_sunset":"","city_sunrise":"","rainbow":"","bridge_at_night":"","ocean":"","volcano":"","milky_way":"","earth_africa":"","earth_americas":"",\
"earth_asia":"","globe_with_meridians":"","new_moon":"","waxing_crescent_moon":"","first_quarter_moon":"","moon":"","waxing_gibbous_moon":"","full_moon":"","waning_gibbous_moon":"","last_quarter_moon":"","waning_crescent_moon":"","crescent_moon":"","new_moon_with_face":"","first_quarter_moon_with_face":"","last_quarter_moon_with_face":"","full_moon_with_face":"","sun_with_face":"","star2":"","stars":"","thermometer":"","mostly_sunny":"","sun_small_cloud":"","barely_sunny":"","sun_behind_cloud":"","partly_sunny_rain":"","sun_behind_rain_cloud":"","rain_cloud":"","snow_cloud":"","lightning":"","lightning_cloud":"","tornado":"","tornado_cloud":"","fog":"","wind_blowing_face":"","hotdog":"","taco":"","burrito":"","chestnut":"","seedling":"","evergreen_tree":"","deciduous_tree":"","palm_tree":"","cactus":"","hot_pepper":"","tulip":"","cherry_blossom":"","rose":"","hibiscus":"","sunflower":"","blossom":"","corn":"","ear_of_rice":"","herb":"","four_leaf_clover":"","maple_leaf":"","fallen_leaf":"","leaves":"","mushroom":"","tomato":"","eggplant":"","grapes":"","melon":"","watermelon":"","tangerine":"","lemon":"","banana":"","pineapple":"","apple":"","green_apple":"","pear":"","peach":"","cherries":"","strawberry":"","hamburger":"","pizza":"","meat_on_bone":"","poultry_leg":"","rice_cracker":"","rice_ball":"","rice":"","curry":"","ramen":"","spaghetti":"","bread":"","fries":"","sweet_potato":"","dango":"","oden":"","sushi":"","fried_shrimp":"","fish_cake":"","icecream":"","shaved_ice":"","ice_cream":"","doughnut":"","cookie":"","chocolate_bar":"","candy":"","lollipop":"","custard":"","honey_pot":"","cake":"","bento":"","stew":"","egg":"","fork_and_knife":"","tea":"","sake":"","wine_glass":"","cocktail":"","tropical_drink":"","beer":"","beers":"","baby_bottle":"","knife_fork_plate":"","champagne":"","popcorn":"","ribbon":"","gift":"","birthday":"","jack_o_lantern":"","christmas_tree":"","santa":"","fireworks":"","sparkler":"","balloon":"","tada":"","confetti_ball":"","tanabata_tree":"","crossed_flags":"","bamboo":"","dolls":"","flags":"","wind_chime":"","rice_scene":"","school_satchel":"","mortar_board":"","medal":"","reminder_ribbon":"","studio_microphone":"","level_slider":"","control_knobs":"","film_frames":"","admission_tickets":"","carousel_horse":"","ferris_wheel":"","roller_coaster":"","fishing_pole_and_fish":"","microphone":"","movie_camera":"","cinema":"","headphones":"","art":"","tophat":"","circus_tent":"","ticket":"","clapper":"","performing_arts":"","video_game":"","dart":"","slot_machine":"","8ball":"","game_die":"","bowling":"","flower_playing_cards":"","musical_note":"","notes":"","saxophone":"","guitar":"","musical_keyboard":"","trumpet":"","violin":"","musical_score":"","running_shirt_with_sash":"","tennis":"","ski":"","basketball":"","checkered_flag":"","snowboarder":"","runner":"","running":"","surfer":"","sports_medal":"","trophy":"","horse_racing":"","football":"","rugby_football":"","swimmer":"","weight_lifter":"","golfer":"","racing_motorcycle":"","racing_car":"","cricket_bat_and_ball":"","volleyball":"","field_hockey_stick_and_ball":"","ice_hockey_stick_and_puck":"","table_tennis_paddle_and_ball":"","snow_capped_mountain":"","camping":"","beach_with_umbrella":"","building_construction":"","house_buildings":"","cityscape":"","derelict_house_building":"","classical_building":"","desert":"","desert_island":"","national_park":"","stadium":"","house":"","house_with_garden":"","office":"","post_office":"","european_post_office":"","hospital":"","bank":"","atm":"","hotel":"",\
"love_hotel":"","convenience_store":"","school":"","department_store":"","factory":"","izakaya_lantern":"","lantern":"","japanese_castle":"","european_castle":"","waving_white_flag":"","waving_black_flag":"","rosette":"","label":"","badminton_racquet_and_shuttlecock":"","bow_and_arrow":"","amphora":"","skin-tone-2":"","skin-tone-3":"","skin-tone-4":"","skin-tone-5":"","skin-tone-6":"","rat":"","mouse2":"","ox":"","water_buffalo":"","cow2":"","tiger2":"","leopard":"","rabbit2":"","cat2":"","dragon":"","crocodile":"","whale2":"","snail":"","snake":"","racehorse":"","ram":"","goat":"","sheep":"","monkey":"","rooster":"","chicken":"","dog2":"","pig2":"","boar":"","elephant":"","octopus":"","shell":"","bug":"","ant":"","bee":"","honeybee":"","beetle":"","fish":"","tropical_fish":"","blowfish":"","turtle":"","hatching_chick":"","baby_chick":"","hatched_chick":"","bird":"","penguin":"","koala":"","poodle":"","dromedary_camel":"","camel":"","dolphin":"","flipper":"","mouse":"","cow":"","tiger":"","rabbit":"","cat":"","dragon_face":"","whale":"","horse":"","monkey_face":"","dog":"","pig":"","frog":"","hamster":"","wolf":"","bear":"","panda_face":"","pig_nose":"","feet":"","paw_prints":"","chipmunk":"","eyes":"","eye":"","ear":"","nose":"","lips":"","tongue":"","point_up_2":"","point_down":"","point_left":"","point_right":"","facepunch":"","punch":"","wave":"","ok_hand":"","+1":"","thumbsup":"","-1":"","thumbsdown":"","clap":"","open_hands":"","crown":"","womans_hat":"","eyeglasses":"","necktie":"","shirt":"","tshirt":"","jeans":"","dress":"","kimono":"","bikini":"","womans_clothes":"","purse":"","handbag":"","pouch":"","mans_shoe":"","shoe":"","athletic_shoe":"","high_heel":"","sandal":"","boot":"","footprints":"","bust_in_silhouette":"","busts_in_silhouette":"","boy":"","girl":"","man":"","woman":"","family":"","man-woman-boy":"","couple":"","man_and_woman_holding_hands":"","two_men_holding_hands":"","two_women_holding_hands":"","cop":"","dancers":"","bride_with_veil":"","person_with_blond_hair":"","man_with_gua_pi_mao":"","man_with_turban":"","older_man":"","older_woman":"","baby":"","construction_worker":"","princess":"","japanese_ogre":"","japanese_goblin":"","ghost":"","angel":"","alien":"","space_invader":"","imp":"","skull":"","information_desk_person":"","guardsman":"","dancer":"","lipstick":"","nail_care":"","massage":"","haircut":"","barber":"","syringe":"","pill":"","kiss":"","love_letter":"","ring":"","gem":"","couplekiss":"","bouquet":"","couple_with_heart":"","wedding":"","heartbeat":"","broken_heart":"","two_hearts":"","sparkling_heart":"","heartpulse":"","cupid":"","blue_heart":"","green_heart":"","yellow_heart":"","purple_heart":"","gift_heart":"","revolving_hearts":"","heart_decoration":"","diamond_shape_with_a_dot_inside":"","bulb":"","anger":"","bomb":"","zzz":"","boom":"","collision":"","sweat_drops":"","droplet":"","dash":"","hankey":"","poop":"","shit":"","muscle":"","dizzy":"","speech_balloon":"","thought_balloon":"","white_flower":"","moneybag":"","currency_exchange":"","heavy_dollar_sign":"","credit_card":"","yen":"","dollar":"","euro":"","pound":"","money_with_wings":"","chart":"","seat":"","computer":"","briefcase":"","minidisc":"","floppy_disk":"","cd":"","dvd":"","file_folder":"","open_file_folder":"","page_with_curl":"","page_facing_up":"","date":"","calendar":"","card_index":"","chart_with_upwards_trend":"","chart_with_downwards_trend":"","bar_chart":"","clipboard":"","pushpin":"","round_pushpin":"","paperclip":"",\
"straight_ruler":"","triangular_ruler":"","bookmark_tabs":"","ledger":"","notebook":"","notebook_with_decorative_cover":"","closed_book":"","book":"","open_book":"","green_book":"","blue_book":"","orange_book":"","books":"","name_badge":"","scroll":"","memo":"","pencil":"","telephone_receiver":"","pager":"","fax":"","satellite":"","loudspeaker":"","mega":"","outbox_tray":"","inbox_tray":"","package":"","e-mail":"","incoming_envelope":"","envelope_with_arrow":"","mailbox_closed":"","mailbox":"","mailbox_with_mail":"","mailbox_with_no_mail":"","postbox":"","postal_horn":"","newspaper":"","iphone":"","calling":"","vibration_mode":"","mobile_phone_off":"","no_mobile_phones":"","signal_strength":"","camera":"","camera_with_flash":"","video_camera":"","tv":"","radio":"","vhs":"","film_projector":"","prayer_beads":"","twisted_rightwards_arrows":"","repeat":"","repeat_one":"","arrows_clockwise":"","arrows_counterclockwise":"","low_brightness":"","high_brightness":"","mute":"","speaker":"","sound":"","loud_sound":"","battery":"","electric_plug":"","mag":"","mag_right":"","lock_with_ink_pen":"","closed_lock_with_key":"","key":"","lock":"","unlock":"","bell":"","no_bell":"","bookmark":"","link":"","radio_button":"","back":"","end":"","on":"","soon":"","top":"","underage":"","keycap_ten":"","capital_abcd":"","abcd":"","symbols":"","abc":"","fire":"","flashlight":"","wrench":"","hammer":"","nut_and_bolt":"","hocho":"","knife":"","gun":"","microscope":"","telescope":"","crystal_ball":"","six_pointed_star":"","beginner":"","trident":"","black_square_button":"","white_square_button":"","red_circle":"","large_blue_circle":"","large_orange_diamond":"","large_blue_diamond":"","small_orange_diamond":"","small_blue_diamond":"","small_red_triangle":"","small_red_triangle_down":"","arrow_up_small":"","arrow_down_small":"","om_symbol":"","dove_of_peace":"","kaaba":"","mosque":"","synagogue":"","menorah_with_nine_branches":"","clock1":"","clock2":"","clock3":"","clock4":"","clock5":"","clock6":"","clock7":"","clock8":"","clock9":"","clock10":"","clock11":"","clock12":"","clock130":"","clock230":"","clock330":"","clock430":"","clock530":"","clock630":"","clock730":"","clock830":"","clock930":"","clock1030":"","clock1130":"","clock1230":"","candle":"","mantelpiece_clock":"","hole":"","man_in_business_suit_levitating":"","sleuth_or_spy":"","dark_sunglasses":"","spider":"","spider_web":"","joystick":"","linked_paperclips":"","lower_left_ballpoint_pen":"","lower_left_fountain_pen":"","lower_left_paintbrush":"","lower_left_crayon":"","raised_hand_with_fingers_splayed":"","middle_finger":"","reversed_hand_with_middle_finger_extended":"","spock-hand":"","desktop_computer":"","printer":"","three_button_mouse":"","trackball":"","frame_with_picture":"","card_index_dividers":"","card_file_box":"","file_cabinet":"","wastebasket":"","spiral_note_pad":"","spiral_calendar_pad":"","compression":"","old_key":"","rolled_up_newspaper":"","dagger_knife":"","speaking_head_in_silhouette":"","left_speech_bubble":"","right_anger_bubble":"","ballot_box_with_ballot":"","world_map":"","mount_fuji":"","tokyo_tower":"","statue_of_liberty":"","japan":"","moyai":"","grinning":"","grin":"","joy":"","smiley":"","smile":"","sweat_smile":"","laughing":"","satisfied":"","innocent":"","smiling_imp":"","wink":"","blush":"","yum":"","relieved":"","heart_eyes":"","sunglasses":"","smirk":"","neutral_face":"","expressionless":"","unamused":"","sweat":"","pensive":"","confused":"","confounded":"","kissing":"","kissing_heart":"","kissing_smiling_eyes":"",\
"kissing_closed_eyes":"","stuck_out_tongue":"","stuck_out_tongue_winking_eye":"","stuck_out_tongue_closed_eyes":"","disappointed":"","worried":"","angry":"","rage":"","cry":"","persevere":"","triumph":"","disappointed_relieved":"","frowning":"","anguished":"","fearful":"","weary":"","sleepy":"","tired_face":"","grimacing":"","sob":"","open_mouth":"","hushed":"","cold_sweat":"","scream":"","astonished":"","flushed":"","sleeping":"","dizzy_face":"","no_mouth":"","mask":"","smile_cat":"","joy_cat":"","smiley_cat":"","heart_eyes_cat":"","smirk_cat":"","kissing_cat":"","pouting_cat":"","crying_cat_face":"","scream_cat":"","slightly_frowning_face":"","slightly_smiling_face":"","upside_down_face":"","face_with_rolling_eyes":"","no_good":"","ok_woman":"","bow":"","see_no_evil":"","hear_no_evil":"","speak_no_evil":"","raising_hand":"","raised_hands":"","person_frowning":"","person_with_pouting_face":"","pray":"","rocket":"","helicopter":"","steam_locomotive":"","railway_car":"","bullettrain_side":"","bullettrain_front":"","train2":"","metro":"","light_rail":"","station":"","tram":"","train":"","bus":"","oncoming_bus":"","trolleybus":"","busstop":"","minibus":"","ambulance":"","fire_engine":"","police_car":"","oncoming_police_car":"","taxi":"","oncoming_taxi":"","car":"","red_car":"","oncoming_automobile":"","blue_car":"","truck":"","articulated_lorry":"","tractor":"","monorail":"","mountain_railway":"","suspension_railway":"","mountain_cableway":"","aerial_tramway":"","ship":"","rowboat":"","speedboat":"","traffic_light":"","vertical_traffic_light":"","construction":"","rotating_light":"","triangular_flag_on_post":"","door":"","no_entry_sign":"","smoking":"","no_smoking":"","put_litter_in_its_place":"","do_not_litter":"","potable_water":"","non-potable_water":"","bike":"","no_bicycles":"","bicyclist":"","mountain_bicyclist":"","walking":"","no_pedestrians":"","children_crossing":"","mens":"","womens":"","restroom":"","baby_symbol":"","toilet":"","wc":"","shower":"","bath":"","bathtub":"","passport_control":"","customs":"","baggage_claim":"","left_luggage":"","couch_and_lamp":"","sleeping_accommodation":"","shopping_bags":"","bellhop_bell":"","bed":"","place_of_worship":"","hammer_and_wrench":"","shield":"","oil_drum":"","motorway":"","railway_track":"","motor_boat":"","small_airplane":"","airplane_departure":"","airplane_arriving":"","passenger_ship":"","zipper_mouth_face":"","money_mouth_face":"","face_with_thermometer":"","nerd_face":"","thinking_face":"","face_with_head_bandage":"","robot_face":"","hugging_face":"","the_horns":"","sign_of_the_horns":"","crab":"","lion_face":"","scorpion":"","turkey":"","unicorn_face":"","cheese_wedge":"","hash":"#","keycap_star":"*","zero":"0","one":"1","two":"2","three":"3","four":"4","five":"5","six":"6","seven":"7","eight":"8","nine":"9","flag-ac":"","flag-ad":"","flag-ae":"","flag-af":"","flag-ag":"","flag-ai":"","flag-al":"","flag-am":"","flag-ao":"","flag-aq":"","flag-ar":"","flag-as":"","flag-at":"","flag-au":"","flag-aw":"","flag-ax":"","flag-az":"","flag-ba":"","flag-bb":"","flag-bd":"","flag-be":"","flag-bf":"","flag-bg":"","flag-bh":"","flag-bi":"","flag-bj":"","flag-bl":"","flag-bm":"","flag-bn":"","flag-bo":"","flag-bq":"","flag-br":"","flag-bs":"","flag-bt":"","flag-bv":"","flag-bw":"","flag-by":"","flag-bz":"","flag-ca":"","flag-cc":"","flag-cd":"","flag-cf":"","flag-cg":"","flag-ch":"","flag-ci":"","flag-ck":"","flag-cl":"","flag-cm":"","flag-cn":"",\
"cn":"","flag-co":"","flag-cp":"","flag-cr":"","flag-cu":"","flag-cv":"","flag-cw":"","flag-cx":"","flag-cy":"","flag-cz":"","flag-de":"","de":"","flag-dg":"","flag-dj":"","flag-dk":"","flag-dm":"","flag-do":"","flag-dz":"","flag-ea":"","flag-ec":"","flag-ee":"","flag-eg":"","flag-eh":"","flag-er":"","flag-es":"","es":"","flag-et":"","flag-eu":"","flag-fi":"","flag-fj":"","flag-fk":"","flag-fm":"","flag-fo":"","flag-fr":"","fr":"","flag-ga":"","flag-gb":"","gb":"","uk":"","flag-gd":"","flag-ge":"","flag-gf":"","flag-gg":"","flag-gh":"","flag-gi":"","flag-gl":"","flag-gm":"","flag-gn":"","flag-gp":"","flag-gq":"","flag-gr":"","flag-gs":"","flag-gt":"","flag-gu":"","flag-gw":"","flag-gy":"","flag-hk":"","flag-hm":"","flag-hn":"","flag-hr":"","flag-ht":"","flag-hu":"","flag-ic":"","flag-id":"","flag-ie":"","flag-il":"","flag-im":"","flag-in":"","flag-io":"","flag-iq":"","flag-ir":"","flag-is":"","flag-it":"","it":"","flag-je":"","flag-jm":"","flag-jo":"","flag-jp":"","jp":"","flag-ke":"","flag-kg":"","flag-kh":"","flag-ki":"","flag-km":"","flag-kn":"","flag-kp":"","flag-kr":"","kr":"","flag-kw":"","flag-ky":"","flag-kz":"","flag-la":"","flag-lb":"","flag-lc":"","flag-li":"","flag-lk":"","flag-lr":"","flag-ls":"","flag-lt":"","flag-lu":"","flag-lv":"","flag-ly":"","flag-ma":"","flag-mc":"","flag-md":"","flag-me":"","flag-mf":"","flag-mg":"","flag-mh":"","flag-mk":"","flag-ml":"","flag-mm":"","flag-mn":"","flag-mo":"","flag-mp":"","flag-mq":"","flag-mr":"","flag-ms":"","flag-mt":"","flag-mu":"","flag-mv":"","flag-mw":"","flag-mx":"","flag-my":"","flag-mz":"","flag-na":"","flag-nc":"","flag-ne":"","flag-nf":"","flag-ng":"","flag-ni":"","flag-nl":"","flag-no":"","flag-np":"","flag-nr":"","flag-nu":"","flag-nz":"","flag-om":"","flag-pa":"","flag-pe":"","flag-pf":"","flag-pg":"","flag-ph":"","flag-pk":"","flag-pl":"","flag-pm":"","flag-pn":"","flag-pr":"","flag-ps":"","flag-pt":"","flag-pw":"","flag-py":"","flag-qa":"","flag-re":"","flag-ro":"","flag-rs":"","flag-ru":"","ru":"","flag-rw":"","flag-sa":"","flag-sb":"","flag-sc":"","flag-sd":"","flag-se":"","flag-sg":"","flag-sh":"","flag-si":"","flag-sj":"","flag-sk":"","flag-sl":"","flag-sm":"","flag-sn":"","flag-so":"","flag-sr":"","flag-ss":"","flag-st":"","flag-sv":"","flag-sx":"","flag-sy":"","flag-sz":"","flag-ta":"","flag-tc":"","flag-td":"","flag-tf":"","flag-tg":"","flag-th":"","flag-tj":"","flag-tk":"","flag-tl":"","flag-tm":"","flag-tn":"","flag-to":"","flag-tr":"","flag-tt":"","flag-tv":"","flag-tw":"","flag-tz":"","flag-ua":"","flag-ug":"","flag-um":"","flag-us":"","us":"","flag-uy":"","flag-uz":"","flag-va":"","flag-vc":"","flag-ve":"","flag-vg":"","flag-vi":"","flag-vn":"","flag-vu":"","flag-wf":"","flag-ws":"","flag-xk":"","flag-ye":"","flag-yt":"","flag-za":"","flag-zm":"","flag-zw":"","man-man-boy":"","man-man-boy-boy":"","man-man-girl":"","man-man-girl-boy":"","man-man-girl-girl":"","man-woman-boy-boy":"","man-woman-girl":"","man-woman-girl-boy":"","man-woman-girl-girl":"","man-heart-man":"",\
"man-kiss-man":"","woman-woman-boy":"","woman-woman-boy-boy":"","woman-woman-girl":"","woman-woman-girl-boy":"","woman-woman-girl-girl":"","woman-heart-woman":"","woman-kiss-woman":""}'
);
//
},
leven:
function(module) {
//
var arr = [],
  charCodeCache = [];

module.exports = function(a, b) {
  if (a === b) return 0;

  var swap = a;

  if (a.length > b.length) {
    a = b;
    b = swap;
  }

  var aLen = a.length,
    bLen = b.length;

  if (aLen === 0) return bLen;

  if (bLen === 0) return aLen;

  while (aLen > 0 && a.charCodeAt(~-aLen) === b.charCodeAt(~-bLen)) {
    aLen--;
    bLen--;
  }

  if (aLen === 0) return bLen;

  var start = 0;

  while (start < aLen && a.charCodeAt(start) === b.charCodeAt(start)) start++;

  bLen -= start;

  if ((aLen -= start) == 0) return bLen;

  var bCharCode,
    ret,
    tmp,
    tmp2,
    i = 0,
    j = 0;

  while (i < aLen) {
    charCodeCache[start + i] = a.charCodeAt(start + i);
    arr[i] = ++i;
  }

  while (j < bLen) {
    bCharCode = b.charCodeAt(start + j);
    tmp = j++;
    ret = j;

    for (i = 0; i < aLen; i++) {
      tmp2 = bCharCode === charCodeCache[start + i] ? tmp : tmp + 1;
      tmp = arr[i];
      ret = arr[i] = tmp > ret ? (tmp2 > ret ? ret + 1 : tmp2) : tmp2 > tmp ? tmp + 1 : tmp2;
    }
  }

  return ret;
};
//
},
puka:
function(module, exports) {
//
Object.defineProperty(exports, '__esModule', {value: true});

const formatSymbol = Symbol('format'),
  preformatSymbol = Symbol('preformat');

let stickySupported = true;
try {
  new RegExp('', 'y');
} catch (_e) {
  stickySupported = false;
}
const sticky = stickySupported ? source => new RegExp(source, 'y') : source => new RegExp(`^(?:${source})`);
const execFrom = stickySupported
  ? (re, haystack, index) => ((re.lastIndex = index), re.exec(haystack))
  : (re, haystack, index) => re.exec(haystack.substr(index));

function quoteForCmd(text, forceQuote) {
  let caretDepth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  if (!text.length) return '""';

  if (/[\n\r]/.test(text)) throw new Error("Line breaks can't be quoted on Windows");

  const caretEscape = /["%]/.test(text);
  text = quoteForWin32(text, forceQuote || (!caretEscape && /[&()<>^|]/.test(text)));
  if (caretEscape)
    do {
      text = text.replace(/[\t "%&()<>^|]/g, '^$&');
    } while (caretDepth--);

  return text;
}
const quoteForWin32 = (text, forceQuote) =>
    forceQuote || /[\t "]/.test(text) ? `"${text.replace(/\\+(?=$|")/g, '$&$&').replace(/"/g, '\\"')}"` : text,
  cmdMetaChars = /[\t\n\r "%&()<>^|]/;
class Win32Context {
  constructor() {
    this.currentScope = newScope(null);
    this.scopesByObject = new Map();
  }
  read(text) {
    const length = text.length;
    for (let match, pos = 0; pos < length; ) {
      if ((match = execFrom(reUnimportant, text, pos))) pos += match[0].length;

      if (pos >= length) break;
      if ((match = execFrom(reSeqOp, text, pos))) {
        this.seq();
        pos += match[0].length;
      } else {
        const char = text.charCodeAt(pos);
        if (char === CARET) pos += 2;
        else if (char === QUOTE) pos += execFrom(reNotQuote, text, pos + 1)[0].length + 2;
        else {
          char === OPEN_PAREN
            ? this.enterScope()
            : char === CLOSE_PAREN
            ? this.exitScope()
            : (this.currentScope.depthDelta = 1);

          pos++;
        }
      }
    }
  }
  enterScope() {
    this.currentScope = newScope(this.currentScope);
  }
  exitScope() {
    this.currentScope = this.currentScope.parent || (this.currentScope.parent = newScope(null));
  }
  seq() {
    this.currentScope = newScope(this.currentScope.parent);
  }
  mark(obj) {
    this.scopesByObject.set(obj, this.currentScope);
  }
  at(obj) {
    return {depth: getDepth(this.scopesByObject.get(obj))};
  }
}
const getDepth = scope =>
    scope === null ? 0 : scope.depth !== -1 ? scope.depth : (scope.depth = getDepth(scope.parent) + scope.depthDelta),
  newScope = parent => ({parent, depthDelta: 0, depth: -1}),
  CARET = '^'.charCodeAt(),
  QUOTE = '"'.charCodeAt(),
  OPEN_PAREN = '('.charCodeAt(),
  CLOSE_PAREN = ')'.charCodeAt(),
  reNotQuote = sticky('[^"]*'),
  reSeqOp = sticky('&&?|\\|\\|'),
  reUnimportant = sticky('(?:>&|[^"$&()^|])+');

const quoteForSh = (text, forceQuote) =>
  text.length
    ? forceQuote || shMetaChars.test(text)
      ? `'${text.replace(/'/g, "'\\''")}'`.replace(/^(?:'')+(?!$)/, '').replace(/\\'''/g, "\\'")
      : text
    : "''";
const shMetaChars = /[\t\n\r "#$&'()*;<>?\\`|~]/;

function Formatter() {}
Object.assign(Formatter, {
  for: platform =>
    platform == null
      ? Formatter.default || (Formatter.default = Formatter.for(process.platform))
      : Formatter._registry.get(platform) || Formatter._registry.get('sh'),
  declare(props) {
    const platform = (props && props.platform) || 'sh',
      existingFormatter = Formatter._registry.get(platform),
      formatter = Object.assign(existingFormatter || new Formatter(), props);
    formatter.emptyString === void 0 && (formatter.emptyString = formatter.quote('', true));
    existingFormatter || Formatter._registry.set(formatter.platform, formatter);
  },
  _registry: new Map(),
  prototype: {
    platform: 'sh',
    quote: quoteForSh,
    metaChars: shMetaChars,
    hasExtraMetaChars: false,
    statementSeparator: ';',
    createContext: () => defaultContext
  }
});
const defaultContext = {at() {}};
Formatter.declare();
Formatter.declare({
  platform: 'win32',
  quote: (text, forceQuote, opts) => quoteForCmd(text, forceQuote, (opts && opts.depth) || 0),
  metaChars: cmdMetaChars,
  hasExtraMetaChars: true,
  statementSeparator: '&',
  createContext(root) {
    const context = new this.Context();
    root[preformatSymbol](context);
    return context;
  },
  Context: Win32Context
});

const isObject = any => any === Object(any);
function memoize(f) {
  const cache = new WeakMap();
  return arg => {
    let result = cache.get(arg);
    if (result === void 0) {
      result = f(arg);
      cache.set(arg, result);
    }
    return result;
  };
}

class ShellStringText {
  constructor(contents, untested) {
    this.contents = contents;
    this.untested = untested;
  }
  [formatSymbol](formatter, context) {
    const unformattedContents = this.contents,
      length = unformattedContents.length,
      contents = new Array(length);
    for (let i = 0; i < length; i++) {
      const c = unformattedContents[i];
      contents[i] = isObject(c) && formatSymbol in c ? c[formatSymbol](formatter) : c;
    }
    for (let unquoted = true, i = 0; i < length; i++) {
      const content = contents[i];
      if (content === null) unquoted = !unquoted;
      else if (
        unquoted &&
        (formatter.hasExtraMetaChars || (this.untested && this.untested.has(i))) &&
        formatter.metaChars.test(content)
      )
        return formatter.quote(contents.join(''), false, context.at(this));
    }
    const parts = [];
    for (let quoted = null, i = 0; i < length; i++) {
      const content = contents[i];
      content === null
        ? (quoted = quoted ? (parts.push(formatter.quote(quoted.join(''), true, context.at(this))), null) : [])
        : (quoted || parts).push(content);
    }
    const result = parts.join('');
    return result.length ? result : formatter.emptyString;
  }
  [preformatSymbol](context) {
    context.mark(this);
  }
}

class ShellStringUnquoted {
  constructor(value) {
    this.value = value;
  }
  [formatSymbol]() {
    return this.value;
  }
  [preformatSymbol](context) {
    context.read(this.value);
  }
}

const shellStringSemicolon = {
  [formatSymbol]: formatter => formatter.statementSeparator,
  [preformatSymbol](context) {
    context.seq();
  }
};

const PLACEHOLDER = {};
const parse = memoize(templateSpans => {
  const TOKEN_TEXT = 0,
    TOKEN_QUOTE = 1,
    TOKEN_SEMI = 2,
    TOKEN_UNQUOTED = 3,
    TOKEN_SPACE = 4,
    TOKEN_REDIRECT = 5,
    result = [];
  let placeholderCount = 0,
    prefix = null,
    onlyPrefixOnce = false,
    contents = [],
    quote = 0;
  const lastSpan = templateSpans.length - 1;
  for (let spanIndex = 0; spanIndex <= lastSpan; spanIndex++) {
    const templateSpan = templateSpans[spanIndex],
      posEnd = templateSpan.length;
    let tokenStart = 0;
    if (spanIndex) {
      placeholderCount++;
      contents.push(PLACEHOLDER);
    }
    const recognized = [];
    let firstWordBreak = -1,
      lastWordBreak = -1;

    for (let match, pos = 0; pos < posEnd; )
      if (quote) {
        if ((match = execFrom(quote === CHAR_SQUO ? reQuotation1 : reQuotation2, templateSpan, pos))) {
          recognized.push(TOKEN_TEXT, pos);
          pos += match[0].length;
        }
        if (pos < posEnd) {
          recognized.push(TOKEN_QUOTE, pos++);
          quote = 0;
        }
      } else {
        if ((match = execFrom(reText, templateSpan, pos))) {
          const setBreaks = match[1] != null;
          setBreaks && firstWordBreak < 0 && (firstWordBreak = pos);
          recognized.push(setBreaks ? TOKEN_UNQUOTED : TOKEN_TEXT, pos);
          pos += match[0].length;
          setBreaks && (lastWordBreak = pos);
        }
        if ((match = execFrom(reRedirectOrSpace, templateSpan, pos))) {
          firstWordBreak < 0 && (firstWordBreak = pos);
          lastWordBreak = pos;
          recognized.push(match[1] ? TOKEN_REDIRECT : TOKEN_SPACE, pos);
          pos += match[0].length;
        }
        const char = templateSpan.charCodeAt(pos);
        if (char === CHAR_SEMI) {
          firstWordBreak < 0 && (firstWordBreak = pos);
          recognized.push(TOKEN_SEMI, pos++);
          lastWordBreak = pos;
        } else if (char === CHAR_SQUO || char === CHAR_DQUO) {
          recognized.push(TOKEN_QUOTE, pos++);
          quote = char;
        }
      }

    spanIndex === 0 && (firstWordBreak = -1);
    spanIndex === lastSpan && (lastWordBreak = posEnd);
    const iEnd = recognized.length;
    for (let i = 0, type = -1; i <= iEnd; i += 2) {
      let pos,
        typeNext = -1;
      if (i === iEnd) pos = posEnd;
      else {
        typeNext = recognized[i];
        pos = recognized[i + 1];
        typeNext >= TOKEN_SPACE && pos !== lastWordBreak && (typeNext = TOKEN_UNQUOTED);
      }
      const breakHere = pos === firstWordBreak || pos === lastWordBreak;
      if (pos && (breakHere || typeNext !== type)) {
        let value = type === TOKEN_QUOTE
          ? null
          : type === TOKEN_SEMI ? shellStringSemicolon : templateSpan.substring(tokenStart, pos);
        if (type >= TOKEN_SEMI) {
          type === TOKEN_SEMI || (value = new ShellStringUnquoted(value));
          if (contents.length) {
            result.push(new ShellStringText(contents, null));
            contents = [];
          }
          if (type >= TOKEN_SPACE) {
            prefix = value;
            onlyPrefixOnce = type === TOKEN_SPACE;
          } else result.push(value);
        } else contents.push(value);

        tokenStart = pos;
      }
      if (breakHere) {
        placeholderCount
          ? result.push({contents, placeholderCount, prefix, onlyPrefixOnce})
          : contents.length && result.push(new ShellStringText(contents, null));

        placeholderCount = 0; prefix = null; onlyPrefixOnce = false;
        contents = [];
      }
      type = typeNext;
    }
  }
  if (quote) throw new SyntaxError(`String is missing a ${String.fromCharCode(quote)} character`);

  return result;
});
const CHAR_SEMI = ';'.charCodeAt(),
  CHAR_SQUO = "'".charCodeAt(),
  CHAR_DQUO = '"'.charCodeAt(),
  reQuotation1 = sticky("[^']+"),
  reQuotation2 = sticky('[^"]+'),
  reText = sticky('[^\\s"#$&\'();<>\\\\`|]+|([#$&()\\\\`|]+)'),
  reRedirectOrSpace = sticky('((?:\\s+\\d+|\\s*)[<>]+\\s*)|\\s+');

class BitSet {
  constructor() {
    this.vector = new Int32Array(1);
  }
  has(n) {
    return (this.vector[n >>> 5] & (1 << n)) != 0;
  }
  add(n) {
    const i = n >>> 5,
      requiredLength = i + 1;
    let vector = this.vector,
      length = vector.length;
    if (requiredLength > length) {
      while (requiredLength > (length *= 2));
      const oldValues = vector;
      vector = new Int32Array(length);
      vector.set(oldValues);
      this.vector = vector;
    }
    vector[i] |= 1 << n;
  }
}

function evaluate(template, values) {
  values = values.map(toStringishArray);
  const children = [];
  let valuesStart = 0;
  for (let i = 0, iMax = template.length; i < iMax; i++) {
    const word = template[i];
    if (formatSymbol in word) {
      children.push(word);
      continue;
    }
    const contents = word.contents,
      placeholderCount = word.placeholderCount,
      prefix = word.prefix,
      onlyPrefixOnce = word.onlyPrefixOnce,
      kMax = contents.length,
      valuesEnd = valuesStart + placeholderCount,
      tuples = cartesianProduct(values, valuesStart, valuesEnd);
    valuesStart = valuesEnd;
    for (let j = 0, jMax = tuples.length; j < jMax; j++) {
      const needSpace = j > 0,
        tuple = tuples[j];
      (needSpace || prefix) && children.push(needSpace && (onlyPrefixOnce || !prefix) ? unquotedSpace : prefix);
      let interpolatedContents = [],
        untested = null,
        quoting = false,
        tupleIndex = 0;
      for (let k = 0; k < kMax; k++) {
        const content = contents[k];
        if (content === PLACEHOLDER) {
          const value = tuple[tupleIndex++];
          if (quoting) interpolatedContents.push(value);
          else if (isObject(value) && formatSymbol in value) {
            if (interpolatedContents.length) {
              children.push(new ShellStringText(interpolatedContents, untested));
              interpolatedContents = [];
              untested = null;
            }
            children.push(value);
          } else {
            (untested || (untested = new BitSet())).add(interpolatedContents.length);
            interpolatedContents.push(value);
          }
        } else {
          interpolatedContents.push(content);
          content === null && (quoting = !quoting);
        }
      }
      interpolatedContents.length && children.push(new ShellStringText(interpolatedContents, untested));
    }
  }
  return children;
}
const primToStringish = value => (value == null ? '' + value : value);
function toStringishArray(value) {
  let array;
  switch (true) {
    default:
      if (isObject(value)) {
        if (Array.isArray(value)) {
          array = value; break;
        }
        if (Symbol.iterator in value) {
          array = Array.from(value); break;
        }
      }
      array = [value];
  }
  return array.map(primToStringish);
}
function cartesianProduct(arrs, start, end) {
  const size = end - start;
  let resultLength = 1;
  for (let i = start; i < end; i++) resultLength *= arrs[i].length;

  if (resultLength > 1e6) throw new RangeError("Far too many elements to interpolate");

  const result = new Array(resultLength),
    indices = new Array(size).fill(0);
  for (let i = 0; i < resultLength; i++) {
    const value = (result[i] = new Array(size));
    for (let j = 0; j < size; j++) value[j] = arrs[j + start][indices[j]];

    for (let j = size - 1; j >= 0 && ++indices[j] >= arrs[j + start].length; j--) indices[j] = 0;
  }
  return result;
}
const unquotedSpace = new ShellStringUnquoted(' ');

class ShellString {
  constructor(children) {
    this.children = children;
  }
  static sh(templateSpans) {
    var values = Array.prototype.slice.call(arguments, 1);
    return new ShellString(evaluate(parse(templateSpans), values));
  }
  toString(platform) {
    return this[formatSymbol](Formatter.for(platform));
  }
  [formatSymbol](formatter) {
    let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : formatter.createContext(this);
    return this.children.map(child => child[formatSymbol](formatter, context)).join('');
  }
  [preformatSymbol](context) {
    const children = this.children;
    for (let i = 0, iMax = children.length; i < iMax; i++) {
      const child = children[i];
      preformatSymbol in child && child[preformatSymbol](context);
    }
  }
}

function quoteForShell(text, forceQuote, platform) {
  return Formatter.for(platform).quote(text, forceQuote);
}

const sh = function() {
  return ShellString.sh.apply(ShellString, arguments).toString();
};

const unquoted = value => new ShellStringUnquoted(value);

exports.Formatter = Formatter;
exports.ShellString = ShellString;
exports.ShellStringText = ShellStringText;
exports.ShellStringUnquoted = ShellStringUnquoted;
exports.quoteForCmd = quoteForCmd;
exports.quoteForSh = quoteForSh;
exports.quoteForShell = quoteForShell;
exports.sh = sh;
exports.shellStringSemicolon = shellStringSemicolon;
exports.formatSymbol = formatSymbol;
exports.preformatSymbol = preformatSymbol;
exports.unquoted = unquoted;
//
},
'npm-logical-tree':
function(module, exports, __wpreq__) {
//
let path

class LogicalTree {
  constructor(name, address, opts) {
    this.name = name
    this.version = opts.version
    this.address = address || ''
    this.optional = !!opts.optional
    this.dev = !!opts.dev
    this.bundled = !!opts.bundled
    this.resolved = opts.resolved
    this.integrity = opts.integrity
    this.dependencies = new Map()
    this.requiredBy = new Set()
  }

  get isRoot() { return !this.requiredBy.size }

  addDep(dep) {
    this.dependencies.set(dep.name, dep)
    dep.requiredBy.add(this)
    return this
  }

  delDep(dep) {
    this.dependencies.delete(dep.name)
    dep.requiredBy.delete(this)
    return this
  }

  getDep(name) {
    return this.dependencies.get(name)
  }

  path(prefix) {
    if (this.isRoot) return prefix || ''

    path || (path = __wpreq__('path'))
    return path.join(prefix || '', 'node_modules', this.address.replace(/:/g, '/node_modules/'))
  }

  hasCycle(_seen, _from) {
    _seen || (_seen = new Set())
    _from || (_from = this)
    for (let dep of this.dependencies.values()) {
      if (_seen.has(dep)) continue
      _seen.add(dep)
      if (dep === _from || dep.hasCycle(_seen, _from)) return true
    }
    return false
  }

  forEachAsync(fn, opts, _pending) {
    opts || (opts = _pending || {})
    _pending || (_pending = new Map())
    const P = opts.Promise || Promise
    if (_pending.has(this)) return P.resolve(this.hasCycle() || _pending.get(this))

    const pending = P.resolve().then(() =>
      fn(this, () => promiseMap(this.dependencies.values(), dep => dep.forEachAsync(fn, opts, _pending), opts))
    )
    _pending.set(this, pending)
    return pending
  }

  forEach(fn, _seen) {
    _seen || (_seen = new Set())
    if (_seen.has(this)) return
    _seen.add(this)
    fn(this, () => {
      for (let dep of this.dependencies.values()) dep.forEach(fn, _seen)
    })
  }
}

module.exports = lockTree
function lockTree(pkg, pkgLock, opts) {
  const tree = makeNode(pkg.name, null, pkg),
    allDeps = new Map()
  new Set(
    Object.keys(pkg.devDependencies || {})
      .concat(Object.keys(pkg.optionalDependencies || {}))
      .concat(Object.keys(pkg.dependencies || {}))
  ).forEach(name => {
    let dep = allDeps.get(name)
    dep || (dep = makeNode(name, name, (pkgLock.dependencies || {})[name]))

    addChild(dep, tree, allDeps, pkgLock)
  })
  return tree
}

module.exports.node = makeNode
function makeNode(name, address, opts) {
  return new LogicalTree(name, address, opts || {})
}

function addChild(dep, tree, allDeps, pkgLock) {
  tree.addDep(dep)
  allDeps.set(dep.address, dep)
  const addr = dep.address,
    lockNode = atAddr(pkgLock, addr)
  Object.keys(lockNode.requires || {}).forEach(name => {
    const tdepAddr = reqAddr(pkgLock, name, addr)
    let tdep = allDeps.get(tdepAddr)
    if (!tdep) {
      tdep = makeNode(name, tdepAddr, atAddr(pkgLock, tdepAddr))
      addChild(tdep, dep, allDeps, pkgLock)
    } else dep.addDep(tdep)
  })
}

module.exports._reqAddr = reqAddr
function reqAddr(pkgLock, name, fromAddr) {
  if ((atAddr(pkgLock, fromAddr).dependencies || {})[name]) return `${fromAddr}:${name}`

  for (const parts = fromAddr.split(':'); parts.length; ) {
    parts.pop()
    const joined = parts.join(':'),
      parent = atAddr(pkgLock, joined)
    if (parent && (parent.dependencies || {})[name]) return `${joined}${parts.length ? ':' : ''}${name}`
  }
  const err = new Error(`${name} not accessible from ${fromAddr}`)
  err.pkgLock = pkgLock
  err.target = name
  err.from = fromAddr
  throw err
}

module.exports._atAddr = atAddr
function atAddr(pkgLock, addr) {
  return addr.length
    ? addr.split(':').reduce((acc, next) => acc && (acc.dependencies || {})[next], pkgLock)
    : pkgLock
}

function promiseMap(arr, fn, opts, _index) {
  _index = _index || 0
  const P = (opts && opts.Promise) || Promise
  if (P.map) return P.map(arr, fn, opts)

  arr instanceof Array || (arr = Array.from(arr))

  return _index >= arr.length
    ? P.resolve()
    : P.resolve(fn(arr[_index], _index, arr)).then(() => promiseMap(arr, fn, opts, _index + 1))
}
//
},
yn:
function(module, exports, __wpreq__) {
//
const lenient = __wpreq__('yn/lenient');

module.exports = (val, opts) => {
  val = String(val).trim();
  opts = Object.assign({lenient: false, default: null}, opts);

  if (opts.default !== null && typeof opts.default != 'boolean')
    throw new TypeError('Expected the `default` option to be of type `boolean`, got `' + typeof opts.default + '`');

  return (
    !!/^(?:y|yes|true|1)$/i.test(val) ||
    (!/^(?:n|no|false|0)$/i.test(val) && (opts.lenient === true ? lenient(val, opts) : opts.default))
  );
};
//
},
'yn/lenient':
function(module) {
//
const YES_MATCH_SCORE_THRESHOLD = 2,
  NO_MATCH_SCORE_THRESHOLD = 1.25;

const yMatch = new Map([
  [5, 0.25],
  [6, 0.25],
  [7, 0.25],
  ['t', 0.75],
  ['y', 1],
  ['u', 0.75],
  ['g', 0.25],
  ['h', 0.25],
  ['k', 0.25]
]);

const eMatch = new Map([
  [2, 0.25],
  [3, 0.25],
  [4, 0.25],
  ['w', 0.75],
  ['e', 1],
  ['r', 0.75],
  ['s', 0.25],
  ['d', 0.25],
  ['f', 0.25]
]);

const sMatch = new Map([
  ['q', 0.25],
  ['w', 0.25],
  ['e', 0.25],
  ['a', 0.75],
  ['s', 1],
  ['d', 0.75],
  ['z', 0.25],
  ['x', 0.25],
  ['c', 0.25]
]);

const nMatch = new Map([
  ['h', 0.25],
  ['j', 0.25],
  ['k', 0.25],
  ['b', 0.75],
  ['n', 1],
  ['m', 0.75]
]);

const oMatch = new Map([
  [9, 0.25],
  [0, 0.25],
  ['i', 0.75],
  ['o', 1],
  ['p', 0.75],
  ['k', 0.25],
  ['l', 0.25]
]);

function getYesMatchScore(val) {
  let score = 0;
  const y = val[0],
    e = val[1],
    s = val[2];

  if (yMatch.has(y)) score += yMatch.get(y);

  if (eMatch.has(e)) score += eMatch.get(e);

  if (sMatch.has(s)) score += sMatch.get(s);

  return score;
}

function getNoMatchScore(val) {
  let score = 0;
  const n = val[0],
    o = val[1];

  if (nMatch.has(n)) score += nMatch.get(n);

  if (oMatch.has(o)) score += oMatch.get(o);

  return score;
}

module.exports = (val, opts) =>
  getYesMatchScore(val) >= YES_MATCH_SCORE_THRESHOLD ||
  (getNoMatchScore(val) < NO_MATCH_SCORE_THRESHOLD && opts.default);
//
},
bytes:
function(module) {
//
module.exports = bytes;
module.exports.format = format;
module.exports.parse = parse;

var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g,

  formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;

var map = {
  b: 1,
  kb: 1024,
  mb: 1 << 20,
  gb: 1 << 30,
  tb: 1024 * (1 << 30)
};

var parseRegExp = /^(([-+])?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb)$/i;

function bytes(value, options) {
  return typeof value == 'string' ? parse(value) : typeof value == 'number' ? format(value, options) : null;
}

function format(value, options) {
  if (!Number.isFinite(value)) return null;

  var mag = Math.abs(value),
    thousandsSeparator = (options && options.thousandsSeparator) || '',
    unitSeparator = (options && options.unitSeparator) || '',
    decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2,
    fixedDecimals = Boolean(options && options.fixedDecimals),
    unit = (options && options.unit) || '';

  (unit && map[unit.toLowerCase()]) ||
    (unit = mag >= map.tb ? 'TB' : mag >= map.gb ? 'GB' : mag >= map.mb ? 'MB' : mag >= map.kb ? 'KB' : 'B');

  var str = (value / map[unit.toLowerCase()]).toFixed(decimalPlaces);

  fixedDecimals || (str = str.replace(formatDecimalsRegExp, '$1'));

  if (thousandsSeparator) str = str.replace(formatThousandsRegExp, thousandsSeparator);

  return str + unitSeparator + unit;
}

function parse(val) {
  if (typeof val == 'number' && !isNaN(val)) return val;

  if (typeof val != 'string') return null;

  var floatValue,
    results = parseRegExp.exec(val),
    unit = 'b';

  if (!results) {
    floatValue = parseInt(val, 10);
    unit = 'b'
  } else {
    floatValue = parseFloat(results[1]);
    unit = results[4].toLowerCase();
  }

  return Math.floor(map[unit] * floatValue);
}
//
},
'ci-info':
function(module, exports) {
//
var env = process.env

// noinspection SpellCheckingInspection
var vendors = [
  ['APPVEYOR', 'AppVeyor', 'APPVEYOR'],
  ['BAMBOO', 'Bamboo', 'bamboo_planKey'],
  ['BITBUCKET', 'Bitbucket Pipelines', 'BITBUCKET_COMMIT'],
  ['BUILDKITE', 'Buildkite', 'BUILDKITE'],
  ['CIRCLE', 'CircleCI', 'CIRCLECI'],
  ['CIRRUS', 'Cirrus CI', 'CIRRUS_CI'],
  ['CODEBUILD', 'AWS CodeBuild', 'CODEBUILD_BUILD_ARN'],
  ['CODESHIP', 'Codeship', {CI_NAME: 'codeship'}],
  ['DRONE', 'Drone', 'DRONE'],
  ['GITLAB', 'GitLab CI', 'GITLAB_CI'],
  ['GOCD', 'GoCD', 'GO_PIPELINE_LABEL'],
  ['HUDSON', 'Hudson', 'HUDSON_URL'],
  ['JENKINS', 'Jenkins', 'JENKINS_URL', 'BUILD_ID'],
  ['MAGNUM', 'Magnum CI', 'MAGNUM'],
  ['SEMAPHORE', 'Semaphore', 'SEMAPHORE'],
  ['SHIPPABLE', 'Shippable', 'SHIPPABLE'],
  ['SOLANO', 'Solano CI', 'TDDIUM'],
  ['STRIDER', 'Strider CD', 'STRIDER'],
  ['TASKCLUSTER', 'TaskCluster', 'TASK_ID', 'RUN_ID'],
  ['TDDIUM', 'Solano CI', 'TDDIUM'],
  ['TEAMCITY', 'TeamCity', 'TEAMCITY_VERSION'],
  ['TFS', 'Team Foundation Server', 'TF_BUILD'],
  ['TRAVIS', 'Travis CI', 'TRAVIS']
]

Object.defineProperty(exports, '_vendors', {
  value: vendors.map(function(v) { return v[0] })
})

exports.name = null

vendors.forEach(function(vendor) {
  var constant = vendor.shift(),
    name = vendor.shift()
  var isCI = vendor.every(function(obj) {
    return typeof obj == 'string'
      ? !!env[obj]
      : Object.keys(obj).every(function(k) {
          return env[k] === obj[k]
        })
  })
  exports[constant] = isCI
  if (isCI) exports.name = name
})

exports.isCI = !!(env.CI || env.CONTINUOUS_INTEGRATION || env.BUILD_NUMBER || exports.name)
//
},
'debug/src/node':
function(module, exports, __wpreq__) {
//
var tty = __wpreq__('tty'),
  util = __wpreq__('util');

exports = module.exports = __wpreq__('debug/src/debug');
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

exports.colors = [6, 2, 3, 4, 5, 1];

try {
  var supportsColor = __wpreq__('supports-color');
  if (supportsColor && supportsColor.level >= 2)
    exports.colors = [
      20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92,
      93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171,
      172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220,
      221
    ];
} catch (_err) {}

exports.inspectOpts = Object.keys(process.env).filter(function(key) {
  return /^debug_/i.test(key);
}).reduce(function(obj, key) {
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function(_, k) { return k.toUpperCase() });

  var val = process.env[key];
  val =
    !!/^(yes|on|true|enabled)$/i.test(val) ||
    (!/^(no|off|false|disabled)$/i.test(val) && (val === 'null' ? null : Number(val)));

  obj[prop] = val;
  return obj;
}, {});

function useColors() {
  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
}

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

function formatArgs(args) {
  var name = this.namespace;

  if (this.useColors) {
    var c = this.color,
      colorCode = '\x1b[3' + (c < 8 ? c : '8;5;' + c),
      prefix = '  ' + colorCode + ';1m' + name + ' \x1b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push(colorCode + 'm+' + exports.humanize(this.diff) + '\x1b[0m');
  } else args[0] = getDate() + name + ' ' + args[0];
}

function getDate() {
  return exports.inspectOpts.hideDate ? '' : new Date().toISOString() + ' ';
}

function log() {
  return process.stderr.write(util.format.apply(util, arguments) + '\n');
}

function save(namespaces) {
  null == namespaces ? delete process.env.DEBUG : (process.env.DEBUG = namespaces);
}

function load() {
  return process.env.DEBUG;
}

function init(debug) {
  debug.inspectOpts = {};

  for (var keys = Object.keys(exports.inspectOpts), i = 0; i < keys.length; i++)
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
}

exports.enable(load());
//
},
'debug/src/debug':
function(module, exports, __wpreq__) {
//
exports = module.exports = createDebug.debug = createDebug.default = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __wpreq__('ms');

exports.instances = [];

exports.names = [];
exports.skips = [];

exports.formatters = {};

function selectColor(namespace) {
  var hash = 0;

  for (var i in namespace) {
    hash = (hash << 5) - hash + namespace.charCodeAt(i);
    hash |= 0;
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

function createDebug(namespace) {
  var prevTime;

  function debug() {
    if (!debug.enabled) return;

    var self = debug,

      curr = +new Date();
    self.diff = curr - (prevTime || curr);
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) args[i] = arguments[i];

    args[0] = exports.coerce(args[0]);

    'string' == typeof args[0] || args.unshift('%O');

    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' == typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        args.splice(index, 1);
        index--;
      }
      return match;
    });

    exports.formatArgs.call(self, args);

    (debug.log || exports.log || console.log.bind(console)).apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  'function' != typeof exports.init || exports.init(debug);

  exports.instances.push(debug);

  return debug;
}

function destroy() {
  var index = exports.instances.indexOf(this);
  if (index > -1) {
    exports.instances.splice(index, 1);
    return true;
  }
  return false;
}

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i,
    split = (typeof namespaces == 'string' ? namespaces : '').split(/[\s,]+/),
    len = split.length;

  for (i = 0; i < len; i++)
    if (split[i])
      (namespaces = split[i].replace(/\*/g, '.*?'))[0] === '-'
        ? exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'))
        : exports.names.push(new RegExp('^' + namespaces + '$'));

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

function disable() {
  exports.enable('');
}

function enabled(name) {
  if (name[name.length - 1] === '*') return true;

  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) if (exports.skips[i].test(name)) return false;

  for (i = 0, len = exports.names.length; i < len; i++) if (exports.names[i].test(name)) return true;

  return false;
}

function coerce(val) {
  return val instanceof Error ? val.stack || val.message : val;
}
//
},
ms:
function(module) {
//
var s = 1000,
  m = s * 60,
  h = m * 60,
  d = h * 24,
  y = d * 365.25;

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) return parse(val);
  if (type === 'number' && isNaN(val) === false) return options.long ? fmtLong(val) : fmtShort(val);

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};

function parse(str) {
  if ((str = String(str)).length > 100) return;

  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) return;

  var n = parseFloat(match[1]);
  switch ((match[2] || 'ms').toLowerCase()) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return void 0;
  }
}

function fmtShort(ms) {
  return ms >= d
    ? Math.round(ms / d) + 'd'
    : ms >= h
    ? Math.round(ms / h) + 'h'
    : ms >= m
    ? Math.round(ms / m) + 'm'
    : ms >= s
    ? Math.round(ms / s) + 's'
    : ms + 'ms';
}

function fmtLong(ms) {
  return (
    plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms'
  );
}

function plural(ms, n, name) {
  if (ms >= n) return ms < n * 1.5 ? Math.floor(ms / n) + ' ' + name : Math.ceil(ms / n) + ' ' + name + 's';
}
//
},
rimraf:
function(module, exports, __wpreq__) {
//
module.exports = rimraf
rimraf.sync = rimrafSync

var assert = __wpreq__('assert'),
  path = __wpreq__('path'),
  fs = __wpreq__('fs'),
  glob = __wpreq__('glob'),
  _0666 = parseInt('666', 8),

  defaultGlobOpts = {nosort: true, silent: true},

  timeout = 0,
  isWindows = process.platform === "win32"

function defaults(options) {
  ['unlink', 'chmod', 'stat', 'lstat', 'rmdir', 'readdir'].forEach(function(m) {
    options[m] = options[m] || fs[m]
    options[(m += 'Sync')] = options[m] || fs[m]
  })

  options.maxBusyTries = options.maxBusyTries || 3
  options.emfileWait = options.emfileWait || 1000
  if (options.glob === false) options.disableGlob = true

  options.disableGlob = options.disableGlob || false
  options.glob = options.glob || defaultGlobOpts
}

function rimraf(p, options, cb) {
  if (typeof options == 'function') {
    cb = options
    options = {}
  }

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert.equal(typeof cb, 'function', 'rimraf: callback function required')
  assert(options, 'rimraf: invalid options argument provided')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')

  defaults(options)

  var busyTries = 0,
    errState = null,
    n = 0

  if (options.disableGlob || !glob.hasMagic(p)) return afterGlob(null, [p])

  options.lstat(p, function(er, stat) {
    if (!er) return afterGlob(null, [p])

    glob(p, options.glob, afterGlob)
  })

  function next(er) {
    errState = errState || er
    --n != 0 || cb(errState)
  }

  function afterGlob(er, results) {
    if (er) return cb(er)

    if ((n = results.length) === 0) return cb()

    results.forEach(function(p) {
      rimraf_(p, options, function CB(er) {
        if (er) {
          if (
            (er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") &&
            busyTries < options.maxBusyTries
          ) {
            busyTries++
            return setTimeout(function() {
              rimraf_(p, options, CB)
            }, busyTries * 100)
          }

          if (er.code === "EMFILE" && timeout < options.emfileWait)
            return setTimeout(function() {
              rimraf_(p, options, CB)
            }, timeout++)

          if (er.code === "ENOENT") er = null
        }

        timeout = 0
        next(er)
      })
    })
  }
}

function rimraf_(p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb == 'function')

  options.lstat(p, function(er, st) {
    if (er && er.code === "ENOENT") return cb(null)

    er && er.code === "EPERM" && isWindows && fixWinEPERM(p, options, er, cb)

    if (st && st.isDirectory()) return rmdir(p, options, er, cb)

    options.unlink(p, function(er) {
      if (er) {
        if (er.code === "ENOENT") return cb(null)
        if (er.code === "EPERM") return isWindows ? fixWinEPERM(p, options, er, cb) : rmdir(p, options, er, cb)
        if (er.code === "EISDIR") return rmdir(p, options, er, cb)
      }
      return cb(er)
    })
  })
}

function fixWinEPERM(p, options, er, cb) {
  assert(p)
  assert(options)
  assert(typeof cb == 'function')
  er && assert(er instanceof Error)

  options.chmod(p, _0666, function(er2) {
    er2
      ? cb(er2.code === "ENOENT" ? null : er)
      : options.stat(p, function(er3, stats) {
          er3
            ? cb(er3.code === "ENOENT" ? null : er)
            : stats.isDirectory()
            ? rmdir(p, options, er, cb)
            : options.unlink(p, cb)
        })
  })
}

function fixWinEPERMSync(p, options, er) {
  assert(p)
  assert(options)
  er && assert(er instanceof Error)

  try {
    options.chmodSync(p, _0666)
  } catch (er2) {
    if (er2.code === "ENOENT") return
    throw er
  }

  try {
    var stats = options.statSync(p)
  } catch (er3) {
    if (er3.code === "ENOENT") return
    throw er
  }

  stats.isDirectory() ? rmdirSync(p, options, er) : options.unlinkSync(p)
}

function rmdir(p, options, originalEr, cb) {
  assert(p)
  assert(options)
  originalEr && assert(originalEr instanceof Error)
  assert(typeof cb == 'function')

  options.rmdir(p, function(er) {
    er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
      ? rmkids(p, options, cb)
      : er && er.code === "ENOTDIR"
      ? cb(originalEr)
      : cb(er)
  })
}

function rmkids(p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb == 'function')

  options.readdir(p, function(er, files) {
    if (er) return cb(er)
    var errState,
      n = files.length
    if (n === 0) return options.rmdir(p, cb)
    files.forEach(function(f) {
      rimraf(path.join(p, f), options, function(er) {
        if (errState) return
        if (er) return cb((errState = er))
        --n != 0 || options.rmdir(p, cb)
      })
    })
  })
}

function rimrafSync(p, options) {
  defaults((options = options || {}))

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert(options, 'rimraf: missing options')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')

  var results

  if (options.disableGlob || !glob.hasMagic(p)) results = [p]
  else
    try {
      options.lstatSync(p)
      results = [p]
    } catch (_er) {
      results = glob.sync(p, options.glob)
    }

  if (!results.length) return

  for (var i = 0; i < results.length; i++) {
    p = results[i]

    try {
      var st = options.lstatSync(p)
    } catch (er) {
      if (er.code === "ENOENT") return

      er.code === "EPERM" && isWindows && fixWinEPERMSync(p, options, er)
    }

    try {
      st && st.isDirectory() ? rmdirSync(p, options, null) : options.unlinkSync(p)
    } catch (er) {
      if (er.code === "ENOENT") return
      if (er.code === "EPERM") return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
      if (er.code !== "EISDIR") throw er

      rmdirSync(p, options, er)
    }
  }
}

function rmdirSync(p, options, originalEr) {
  assert(p)
  assert(options)
  originalEr && assert(originalEr instanceof Error)

  try {
    options.rmdirSync(p)
  } catch (er) {
    if (er.code === "ENOENT") return
    if (er.code === "ENOTDIR") throw originalEr
    if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") rmkidsSync(p, options)
  }
}

function rmkidsSync(p, options) {
  assert(p)
  assert(options)
  options.readdirSync(p).forEach(function(f) {
    rimrafSync(path.join(p, f), options)
  })

  for (var retries = isWindows ? 100 : 1, i = 0; ; ) {
    var threw = true
    try {
      var ret = options.rmdirSync(p, options)
      threw = false
      return ret
    } finally {
      if (++i < retries && threw) continue
    }
  }
}
//
},
request:
function(module, exports, __wpreq__) {
//
var extend = __wpreq__('extend'),
  cookies = __wpreq__('request/lib/cookies'),

  paramsHaveRequestBody = __wpreq__('request/lib/helpers').paramsHaveRequestBody

function initParams(uri, options, callback) {
  if (typeof options == 'function') callback = options

  var params = {}
  typeof options == 'object'
    ? extend(params, options, {uri: uri})
    : extend(params, typeof uri == 'string' ? {uri: uri} : uri)

  params.callback = callback || params.callback
  return params
}

function request(uri, options, callback) {
  if (uri === void 0) throw new Error('undefined is not a valid uri or options object.')

  var params = initParams(uri, options, callback)

  if (params.method === 'HEAD' && paramsHaveRequestBody(params))
    throw new Error('HTTP HEAD requests MUST NOT include a request body.')

  return new request.Request(params)
}

function verbFunc(verb) {
  var method = verb.toUpperCase()
  return function(uri, options, callback) {
    var params = initParams(uri, options, callback)
    params.method = method
    return request(params, params.callback)
  }
}

request.get = verbFunc('get')
request.head = verbFunc('head')
request.options = verbFunc('options')
request.post = verbFunc('post')
request.put = verbFunc('put')
request.patch = verbFunc('patch')
request.del = verbFunc('delete')
request.delete = verbFunc('delete')

request.jar = function(store) {
  return cookies.jar(store)
}

request.cookie = function(str) {
  return cookies.parse(str)
}

function wrapRequestMethod(method, options, requester, verb) {
  return function(uri, opts, callback) {
    var params = initParams(uri, opts, callback),

      target = {}
    extend(true, target, options, params)

    target.pool = params.pool || options.pool

    if (verb) target.method = verb.toUpperCase()

    if (typeof requester == 'function') method = requester

    return method(target, target.callback)
  }
}

request.defaults = function(options, requester) {
  var self = this

  if (typeof (options = options || {}) == 'function') {
    requester = options
    options = {}
  }

  var defaults = wrapRequestMethod(self, options, requester)

  ;['get', 'head', 'post', 'put', 'patch', 'del', 'delete'].forEach(function(verb) {
    defaults[verb] = wrapRequestMethod(self[verb], options, requester, verb)
  })

  defaults.cookie = wrapRequestMethod(self.cookie, options, requester)
  defaults.jar = self.jar
  defaults.defaults = self.defaults
  return defaults
}

request.forever = function(agentOptions, optionsArg) {
  var options = {}
  optionsArg && extend(options, optionsArg)
  if (agentOptions) options.agentOptions = agentOptions

  options.forever = true
  return request.defaults(options)
}

module.exports = request
request.Request = __wpreq__('request/request')
request.initParams = initParams

Object.defineProperty(request, 'debug', {
  enumerable: true,
  get: function() {
    return request.Request.debug
  },
  set: function(debug) {
    request.Request.debug = debug
  }
})
//
},
extend:
function(module) {
//
var hasOwn = Object.prototype.hasOwnProperty,
  toStr = Object.prototype.toString,
  defineProperty = Object.defineProperty,
  gOPD = Object.getOwnPropertyDescriptor;

var isArray = function(arr) {
  return typeof Array.isArray == 'function' ? Array.isArray(arr) : toStr.call(arr) === '[object Array]';
};

var isPlainObject = function(obj) {
  if (!obj || toStr.call(obj) !== '[object Object]') return false;

  var hasOwnConstructor = hasOwn.call(obj, 'constructor'),
    hasIsPrototypeOf =
      obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) return false;

  var key; // noinspection StatementWithEmptyBodyJS
  for (key in obj);

  return key === void 0 || hasOwn.call(obj, key);
};

var setProperty = function(target, options) {
  if (defineProperty && options.name === '__proto__')
    defineProperty(target, options.name, {
      enumerable: true,
      configurable: true,
      value: options.newValue,
      writable: true
    });
  else target[options.name] = options.newValue;
};

var getProperty = function(obj, name) {
  if (name === '__proto__') {
    if (!hasOwn.call(obj, name)) return void 0;

    if (gOPD) return gOPD(obj, name).value;
  }

  return obj[name];
};

module.exports = function extend() {
  var options, name, src, copy, copyIsArray, clone;
  var target = arguments[0],
    i = 1,
    length = arguments.length,
    deep = false;

  if (typeof target == 'boolean') {
    deep = target;
    target = arguments[1] || {};
    i = 2;
  }
  if (target == null || (typeof target != 'object' && typeof target != 'function')) target = {};

  for (; i < length; ++i)
    if ((options = arguments[i]) != null)
      for (name in options) {
        src = getProperty(target, name);

        if (target !== (copy = getProperty(options, name)))
          if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && isArray(src) ? src : [];
            } else clone = src && isPlainObject(src) ? src : {};

            setProperty(target, {name: name, newValue: extend(deep, clone, copy)});
          } else copy === void 0 || setProperty(target, {name: name, newValue: copy});
      }

  return target;
};
//
},
'request/lib/cookies':
function(module, exports, __wpreq__) {
//
var tough = __wpreq__('tough-cookie'),

  Cookie = tough.Cookie,
  CookieJar = tough.CookieJar

exports.parse = function(str) {
  if (str && str.uri) str = str.uri

  if (typeof str != 'string') throw new Error('The cookie function only accepts STRING as param')

  return Cookie.parse(str, {loose: true})
}

function RequestJar(store) {
  this._jar = new CookieJar(store, {looseMode: true})
}
RequestJar.prototype.setCookie = function(cookieOrStr, uri, options) {
  return this._jar.setCookieSync(cookieOrStr, uri, options || {})
}
RequestJar.prototype.getCookieString = function(uri) {
  return this._jar.getCookieStringSync(uri)
}
RequestJar.prototype.getCookies = function(uri) {
  return this._jar.getCookiesSync(uri)
}

exports.jar = function(store) {
  return new RequestJar(store)
}
//
},
'tough-cookie':
function(module, exports, __wpreq__) {
//
var net = __wpreq__('net'),
  urlParse = __wpreq__('url').parse,
  pubsuffix = __wpreq__('tough-cookie/lib/pubsuffix'),
  Store = __wpreq__('tough-cookie/lib/store').Store,
  MemoryCookieStore = __wpreq__('tough-cookie/lib/memstore').MemoryCookieStore,
  pathMatch = __wpreq__('tough-cookie/lib/pathMatch').pathMatch,
  VERSION = __wpreq__('tough-cookie/package.json').version;

var punycode;
try {
  punycode = __wpreq__('punycode');
} catch (_e) {
  console.warn("cookie: can't load punycode; won't use punycode for domain normalization");
}

var COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/,
  CONTROL_CHARS = /[\x00-\x1F]/,

  TERMINATORS = ['\n', '\r', '\0'],

  PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/,
  DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/,

  MONTH_TO_NUM = {jan: 0, feb: 1, mar: 2, apr: 3, may: 4, jun: 5, jul: 6, aug: 7, sep: 8, oct: 9, nov: 10, dec: 11},
  NUM_TO_MONTH = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  NUM_TO_DAY = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],

  MAX_TIME = 2147483647000,
  MIN_TIME = 0;

function parseDigits(token, minDigits, maxDigits, trailingOK) {
  var count = 0;
  while (count < token.length) {
    var c = token.charCodeAt(count);
    if (c <= 0x2F || c >= 0x3A) break;

    count++;
  }

  return count < minDigits || count > maxDigits || (!trailingOK && count != token.length)
    ? null
    : parseInt(token.substr(0, count), 10);
}

function parseTime(token) {
  var parts = token.split(':'),
    result = [0, 0, 0];

  if (parts.length !== 3) return null;

  for (var i = 0; i < 3; i++) {
    var trailingOK = i == 2,
      num = parseDigits(parts[i], 1, 2, trailingOK);
    if (num === null) return null;

    result[i] = num;
  }

  return result;
}

function parseMonth(token) {
  token = String(token).substr(0, 3).toLowerCase();
  var num = MONTH_TO_NUM[token];
  return num >= 0 ? num : null;
}

function parseDate(str) {
  if (!str) return;

  var tokens = str.split(DATE_DELIM);
  if (!tokens) return;

  var hour = null,
    minute = null,
    second = null,
    dayOfMonth = null,
    month = null,
    year = null;

  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i].trim();
    if (!token.length) continue;

    var result;

    if (second === null && (result = parseTime(token))) {
      hour = result[0];
      minute = result[1];
      second = result[2];
    } else if (dayOfMonth === null && (result = parseDigits(token, 1, 2, true)) !== null) dayOfMonth = result;
    else if (month === null && (result = parseMonth(token)) !== null) month = result;
    else if (year === null && (result = parseDigits(token, 2, 4, true)) !== null)
      if ((year = result) >= 70 && year <= 99) year += 1900;
      else if (year >= 0 && year <= 69) year += 2000;
  }

  if (!(
    dayOfMonth === null || month === null || year === null || second === null ||
    dayOfMonth < 1 || dayOfMonth > 31 ||
    year < 1601 ||
    hour > 23 ||
    minute > 59 ||
    second > 59
  ))
    return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
}

function formatDate(date) {
  var d = date.getUTCDate(); d = d >= 10 ? d : '0' + d;
  var h = date.getUTCHours(); h = h >= 10 ? h : '0' + h;
  var m = date.getUTCMinutes(); m = m >= 10 ? m : '0' + m;
  var s = date.getUTCSeconds(); s = s >= 10 ? s : '0' + s;
  return (
    NUM_TO_DAY[date.getUTCDay()] + ', ' +
    d + ' ' + NUM_TO_MONTH[date.getUTCMonth()] + ' ' + date.getUTCFullYear() + ' ' +
    h + ':' + m + ':' + s + ' GMT'
  );
}

function canonicalDomain(str) {
  if (str == null) return null;

  str = str.trim().replace(/^\./, '');

  if (punycode && /[^\u0001-\u007f]/.test(str)) str = punycode.toASCII(str);

  return str.toLowerCase();
}

function domainMatch(str, domStr, canonicalize) {
  if (str == null || domStr == null) return null;

  if (canonicalize !== false) {
    str = canonicalDomain(str);
    domStr = canonicalDomain(domStr);
  }

  if (str == domStr) return true;

  if (net.isIP(str)) return false;

  var idx = str.indexOf(domStr);
  return idx > 0 && str.length === domStr.length + idx && str.substr(idx - 1, 1) === '.';
}

function defaultPath(path) {
  if (!path || path.substr(0, 1) !== "/") return "/";

  if (path === "/") return path;

  var rightSlash = path.lastIndexOf("/");
  return rightSlash === 0 ? "/" : path.slice(0, rightSlash);
}

function trimTerminator(str) {
  for (var t = 0; t < TERMINATORS.length; t++) {
    var terminatorIdx = str.indexOf(TERMINATORS[t]);
    if (terminatorIdx > -1) str = str.substr(0, terminatorIdx);
  }

  return str;
}

function parseCookiePair(cookiePair, looseMode) {
  var firstEq = (cookiePair = trimTerminator(cookiePair)).indexOf('=');

  if (looseMode) {
    if (firstEq === 0) firstEq = (cookiePair = cookiePair.substr(1)).indexOf('=');
  } else if (firstEq <= 0) return;

  var cookieName, cookieValue;
  if (firstEq <= 0) {
    cookieName = "";
    cookieValue = cookiePair.trim();
  } else {
    cookieName = cookiePair.substr(0, firstEq).trim();
    cookieValue = cookiePair.substr(firstEq + 1).trim();
  }

  if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) return;

  var c = new Cookie();
  c.key = cookieName;
  c.value = cookieValue;
  return c;
}

function parse(str, options) {
  if (!options || typeof options != 'object') options = {};

  var firstSemi = (str = str.trim()).indexOf(';'),
    c = parseCookiePair(firstSemi < 0 ? str : str.substr(0, firstSemi), !!options.loose);
  if (!c) return;

  if (firstSemi < 0) return c;

  var unparsed = str.slice(firstSemi + 1).trim();

  if (unparsed.length === 0) return c;

  for (var cookie_avs = unparsed.split(';'); cookie_avs.length; ) {
    var av = cookie_avs.shift().trim();
    if (av.length === 0) continue;

    var av_sep = av.indexOf('=');
    var av_key, av_value;

    if (av_sep < 0) {
      av_key = av;
      av_value = null;
    } else {
      av_key = av.substr(0, av_sep);
      av_value = av.substr(av_sep + 1);
    }

    av_key = av_key.trim().toLowerCase();

    if (av_value) av_value = av_value.trim();

    switch (av_key) {
    case 'expires':
      if (av_value) {
        var exp = parseDate(av_value);
        if (exp) c.expires = exp;
      }
      break;

    case 'max-age':
      if (av_value && /^-?[0-9]+$/.test(av_value)) {
        var delta = parseInt(av_value, 10);
        c.setMaxAge(delta);
      }
      break;

    case 'domain':
      if (av_value) {
        var domain = av_value.trim().replace(/^\./, '');
        if (domain) c.domain = domain.toLowerCase();
      }
      break;

    case 'path':
      c.path = av_value && av_value[0] === "/" ? av_value : null;
      break;

    case 'secure':
      c.secure = true;
      break;

    case 'httponly':
      c.httpOnly = true;
      break;

    default:
      c.extensions = c.extensions || [];
      c.extensions.push(av);
      break;
    }
  }

  return c;
}

function jsonParse(str) {
  var obj;
  try {
    obj = JSON.parse(str);
  } catch (e) {
    return e;
  }
  return obj;
}

function fromJSON(str) {
  if (!str) return null;

  var obj;
  if (typeof str == 'string') {
    if ((obj = jsonParse(str)) instanceof Error) return null;
  } else obj = str;

  var c = new Cookie();
  for (var i = 0; i < Cookie.serializableProperties.length; i++) {
    var prop = Cookie.serializableProperties[i];
    if (obj[prop] === void 0 || obj[prop] === Cookie.prototype[prop]) continue;

    prop === 'expires' || prop === 'creation' || prop === 'lastAccessed'
      ? obj[prop] === null
        ? (c[prop] = null)
        : (c[prop] = obj[prop] == "Infinity" ? "Infinity" : new Date(obj[prop]))
      : (c[prop] = obj[prop]);
  }

  return c;
}

function cookieCompare(a, b) {
  var cmp = 0,
    aPathLen = a.path ? a.path.length : 0;

  return (cmp = (b.path ? b.path.length : 0) - aPathLen) != 0 ||
    (cmp = (a.creation ? a.creation.getTime() : MAX_TIME) - (b.creation ? b.creation.getTime() : MAX_TIME)) != 0
    ? cmp
    : (cmp = a.creationIndex - b.creationIndex);
}

function permutePath(path) {
  if (path === '/') return ['/'];

  if (path.lastIndexOf('/') === path.length - 1) path = path.substr(0, path.length - 1);

  var permutations = [path];
  while (path.length > 1) {
    var lindex = path.lastIndexOf('/');
    if (lindex === 0) break;

    path = path.substr(0, lindex);
    permutations.push(path);
  }
  permutations.push('/');
  return permutations;
}

function getCookieContext(url) {
  if (url instanceof Object) return url;

  try {
    url = decodeURI(url);
  } catch (_err) {}

  return urlParse(url);
}

function Cookie(options) {
  options = options || {};

  Object.keys(options).forEach(function(prop) {
    if (Cookie.prototype.hasOwnProperty(prop) && Cookie.prototype[prop] !== options[prop] && prop.substr(0, 1) !== '_')
      this[prop] = options[prop];
  }, this);

  this.creation = this.creation || new Date();

  Object.defineProperty(this, 'creationIndex', {
    configurable: false,
    enumerable: false,
    writable: true,
    value: ++Cookie.cookiesCreated
  });
}

Cookie.cookiesCreated = 0;

Cookie.parse = parse;
Cookie.fromJSON = fromJSON;

Cookie.prototype.key = "";
Cookie.prototype.value = "";

Cookie.prototype.expires = "Infinity";
Cookie.prototype.maxAge = null;
Cookie.prototype.domain = null;
Cookie.prototype.path = null;
Cookie.prototype.secure = false;
Cookie.prototype.httpOnly = false;
Cookie.prototype.extensions = null;

Cookie.prototype.hostOnly = null;
Cookie.prototype.pathIsDefault = null;
Cookie.prototype.creation = null;
Cookie.prototype.lastAccessed = null;
Object.defineProperty(Cookie.prototype, 'creationIndex', {
  configurable: true,
  enumerable: false,
  writable: true,
  value: 0
});

Cookie.serializableProperties = Object.keys(Cookie.prototype).filter(function(prop) {
  return !(Cookie.prototype[prop] instanceof Function || prop === 'creationIndex' || prop.substr(0, 1) === '_');
});

Cookie.prototype.inspect = function() {
  var now = Date.now();
  return (
    'Cookie="' + this.toString() +
    '; hostOnly=' + (this.hostOnly != null ? this.hostOnly : '?') +
    '; aAge=' + (this.lastAccessed ? now - this.lastAccessed.getTime() + 'ms' : '?') +
    '; cAge=' + (this.creation ? now - this.creation.getTime() + 'ms' : '?') +
    '"'
  );
};

Cookie.prototype.toJSON = function() {
  var obj = {};

  for (var props = Cookie.serializableProperties, i = 0; i < props.length; i++) {
    var prop = props[i];
    if (this[prop] === Cookie.prototype[prop]) continue;

    if (prop === 'expires' || prop === 'creation' || prop === 'lastAccessed')
      this[prop] === null
        ? (obj[prop] = null)
        : (obj[prop] = this[prop] == "Infinity" ? "Infinity" : this[prop].toISOString());
    else if (prop === 'maxAge') {
      if (this[prop] !== null)
        obj[prop] = this[prop] == Infinity || this[prop] == -Infinity ? this[prop].toString() : this[prop];
    } else if (this[prop] !== Cookie.prototype[prop]) obj[prop] = this[prop];
  }

  return obj;
};

Cookie.prototype.clone = function() {
  return fromJSON(this.toJSON());
};

Cookie.prototype.validate = function() {
  if (!COOKIE_OCTETS.test(this.value)) return false;

  if (!(this.expires == Infinity || this.expires instanceof Date || parseDate(this.expires))) return false;

  if (this.maxAge != null && this.maxAge <= 0) return false;
  if (this.path != null && !PATH_VALUE.test(this.path)) return false;

  var cdomain = this.cdomain();
  if (cdomain) {
    if (cdomain.match(/\.$/)) return false;

    if (pubsuffix.getPublicSuffix(cdomain) == null) return false;
  }
  return true;
};

Cookie.prototype.setExpires = function(exp) {
  exp instanceof Date ? (this.expires = exp) : (this.expires = parseDate(exp) || "Infinity");
};

Cookie.prototype.setMaxAge = function(age) {
  this.maxAge = age === Infinity || age === -Infinity ? age.toString() : age;
};

Cookie.prototype.cookieString = function() {
  var val = this.value;
  if (val == null) val = '';

  return this.key === '' ? val : this.key + '=' + val;
};

Cookie.prototype.toString = function() {
  var str = this.cookieString();

  if (this.expires != Infinity)
    this.expires instanceof Date
      ? (str += '; Expires=' + formatDate(this.expires))
      : (str += '; Expires=' + this.expires);

  if (this.maxAge != null && this.maxAge != Infinity) str += '; Max-Age=' + this.maxAge;

  if (this.domain && !this.hostOnly) str += '; Domain=' + this.domain;
  if (this.path) str += '; Path=' + this.path;

  if (this.secure) str += '; Secure';
  if (this.httpOnly) str += '; HttpOnly';

  this.extensions &&
    this.extensions.forEach(function(ext) {
      str += '; ' + ext;
    });

  return str;
};

Cookie.prototype.TTL = function(now) {
  if (this.maxAge != null) return this.maxAge <= 0 ? 0 : this.maxAge * 1000;

  var expires = this.expires;
  if (expires != Infinity) {
    expires instanceof Date || (expires = parseDate(expires) || Infinity);

    return expires == Infinity ? Infinity : expires.getTime() - (now || Date.now());
  }

  return Infinity;
};

Cookie.prototype.expiryTime = function(now) {
  if (this.maxAge != null) {
    var relativeTo = now || this.creation || new Date(),
      age = this.maxAge <= 0 ? -Infinity : this.maxAge * 1000;
    return relativeTo.getTime() + age;
  }

  return this.expires == Infinity ? Infinity : this.expires.getTime();
};

Cookie.prototype.expiryDate = function(now) {
  var millisec = this.expiryTime(now);
  return millisec == Infinity ? new Date(MAX_TIME) : millisec == -Infinity ? new Date(MIN_TIME) : new Date(millisec);
};

Cookie.prototype.isPersistent = function() {
  return this.maxAge != null || this.expires != Infinity;
};

Cookie.prototype.cdomain = Cookie.prototype.canonicalizedDomain = function() {
  return this.domain == null ? null : canonicalDomain(this.domain);
};

function CookieJar(store, options) {
  if (typeof options == "boolean") options = {rejectPublicSuffixes: options};
  else if (options == null) options = {};

  if (options.rejectPublicSuffixes != null) this.rejectPublicSuffixes = options.rejectPublicSuffixes;
  if (options.looseMode != null) this.enableLooseMode = options.looseMode;

  store || (store = new MemoryCookieStore());
  this.store = store;
}
CookieJar.prototype.store = null;
CookieJar.prototype.rejectPublicSuffixes = true;
CookieJar.prototype.enableLooseMode = false;
var CAN_BE_SYNC = [];

CAN_BE_SYNC.push('setCookie');
CookieJar.prototype.setCookie = function(cookie, url, options, cb) {
  var err,
    context = getCookieContext(url);
  if (options instanceof Function) {
    cb = options;
    options = {};
  }

  var host = canonicalDomain(context.hostname),
    loose = this.enableLooseMode;
  if (options.loose != null) loose = options.loose;

  cookie instanceof Cookie || (cookie = Cookie.parse(cookie, {loose: loose}));
  if (!cookie) {
    err = new Error("Cookie failed to parse");
    return cb(options.ignoreError ? null : err);
  }

  var now = options.now || new Date();

  if (this.rejectPublicSuffixes && cookie.domain && pubsuffix.getPublicSuffix(cookie.cdomain()) == null) {
    err = new Error("Cookie has domain set to a public suffix");
    return cb(options.ignoreError ? null : err);
  }

  if (cookie.domain) {
    if (!domainMatch(host, cookie.cdomain(), false)) {
      err = new Error("Cookie not in this host's domain. Cookie:" + cookie.cdomain() + " Request:" + host);
      return cb(options.ignoreError ? null : err);
    }

    if (cookie.hostOnly == null) cookie.hostOnly = false;
  } else {
    cookie.hostOnly = true;
    cookie.domain = host;
  }

  if (!cookie.path || cookie.path[0] !== '/') {
    cookie.path = defaultPath(context.pathname);
    cookie.pathIsDefault = true;
  }

  if (options.http === false && cookie.httpOnly) {
    err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
    return cb(options.ignoreError ? null : err);
  }

  var store = this.store;

  store.updateCookie ||
    (store.updateCookie = function(oldCookie, newCookie, cb) {
      this.putCookie(newCookie, cb);
    });

  function withCookie(err, oldCookie) {
    if (err) return cb(err);

    var next = function(err) {
      if (err) return cb(err);

      cb(null, cookie);
    };

    if (oldCookie) {
      if (options.http === false && oldCookie.httpOnly) {
        err = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
        return cb(options.ignoreError ? null : err);
      }
      cookie.creation = oldCookie.creation;
      cookie.creationIndex = oldCookie.creationIndex;
      cookie.lastAccessed = now;
      store.updateCookie(oldCookie, cookie, next);
    } else {
      cookie.creation = cookie.lastAccessed = now;
      store.putCookie(cookie, next);
    }
  }

  store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
};

CAN_BE_SYNC.push('getCookies');
CookieJar.prototype.getCookies = function(url, options, cb) {
  var context = getCookieContext(url);
  if (options instanceof Function) {
    cb = options;
    options = {};
  }

  var host = canonicalDomain(context.hostname),
    path = context.pathname || '/',

    secure = options.secure;
  if (secure == null && context.protocol && (context.protocol == 'https:' || context.protocol == 'wss:'))
    secure = true;

  var http = options.http;
  if (http == null) http = true;

  var now = options.now || Date.now(),
    expireCheck = options.expire !== false,
    allPaths = !!options.allPaths,
    store = this.store;

  function matchingCookie(c) {
    if (c.hostOnly) {
      if (c.domain != host) return false;
    } else if (!domainMatch(host, c.domain, false)) return false;

    if (!allPaths && !pathMatch(path, c.path)) return false;

    if (c.secure && !secure) return false;

    if (c.httpOnly && !http) return false;

    if (expireCheck && c.expiryTime() <= now) {
      store.removeCookie(c.domain, c.path, c.key, function() {});
      return false;
    }

    return true;
  }

  store.findCookies(host, allPaths ? null : path, function(err, cookies) {
    if (err) return cb(err);

    cookies = cookies.filter(matchingCookie);

    if (options.sort !== false) cookies = cookies.sort(cookieCompare);

    var now = new Date();
    cookies.forEach(function(c) {
      c.lastAccessed = now;
    });

    cb(null, cookies);
  });
};

CAN_BE_SYNC.push('getCookieString');
CookieJar.prototype.getCookieString = function() {
  var args = Array.prototype.slice.call(arguments, 0),
    cb = args.pop();
  var next = function(err, cookies) {
    err
      ? cb(err)
      : cb(null, cookies
          .sort(cookieCompare)
          .map(function(c) {
            return c.cookieString();
          })
          .join('; '));
  };
  args.push(next);
  this.getCookies.apply(this, args);
};

CAN_BE_SYNC.push('getSetCookieStrings');
CookieJar.prototype.getSetCookieStrings = function() {
  var args = Array.prototype.slice.call(arguments, 0),
    cb = args.pop();
  var next = function(err, cookies) {
    err
      ? cb(err)
      : cb(null, cookies.map(function(c) {
          return c.toString();
        }));
  };
  args.push(next);
  this.getCookies.apply(this, args);
};

CAN_BE_SYNC.push('serialize');
CookieJar.prototype.serialize = function(cb) {
  var type = this.store.constructor.name;
  if (type === 'Object') type = null;

  var serialized = {
    version: 'tough-cookie@' + VERSION,
    storeType: type,
    rejectPublicSuffixes: !!this.rejectPublicSuffixes,
    cookies: []
  };

  if (!this.store.getAllCookies || typeof this.store.getAllCookies != 'function')
    return cb(new Error('store does not support getAllCookies and cannot be serialized'));

  this.store.getAllCookies(function(err, cookies) {
    if (err) return cb(err);

    serialized.cookies = cookies.map(function(cookie) {
      delete (cookie = cookie instanceof Cookie ? cookie.toJSON() : cookie).creationIndex;

      return cookie;
    });

    return cb(null, serialized);
  });
};

CookieJar.prototype.toJSON = function() {
  return this.serializeSync();
};

CAN_BE_SYNC.push('_importCookies');
CookieJar.prototype._importCookies = function(serialized, cb) {
  var jar = this,
    cookies = serialized.cookies;
  if (!cookies || !Array.isArray(cookies)) return cb(new Error('serialized jar has no cookies array'));

  cookies = cookies.slice();

  function putNext(err) {
    if (err) return cb(err);

    if (!cookies.length) return cb(err, jar);

    var cookie;
    try {
      cookie = fromJSON(cookies.shift());
    } catch (e) {
      return cb(e);
    }

    if (cookie === null) return putNext(null);

    jar.store.putCookie(cookie, putNext);
  }

  putNext();
};

CookieJar.deserialize = function(strOrObj, store, cb) {
  if (arguments.length !== 3) {
    cb = store;
    store = null;
  }

  var serialized;
  if (typeof strOrObj == 'string') {
    if ((serialized = jsonParse(strOrObj)) instanceof Error) return cb(serialized);
  } else serialized = strOrObj;

  var jar = new CookieJar(store, serialized.rejectPublicSuffixes);
  jar._importCookies(serialized, function(err) {
    if (err) return cb(err);

    cb(null, jar);
  });
};

CookieJar.deserializeSync = function(strOrObj, store) {
  var serialized = typeof strOrObj == 'string' ? JSON.parse(strOrObj) : strOrObj,
    jar = new CookieJar(store, serialized.rejectPublicSuffixes);

  if (!jar.store.synchronous) throw new Error('CookieJar store is not synchronous; use async API instead.');

  jar._importCookiesSync(serialized);
  return jar;
};
CookieJar.fromJSON = CookieJar.deserializeSync;

CAN_BE_SYNC.push('clone');
CookieJar.prototype.clone = function(newStore, cb) {
  if (arguments.length === 1) {
    cb = newStore;
    newStore = null;
  }

  this.serialize(function(err, serialized) {
    if (err) return cb(err);

    CookieJar.deserialize(newStore, serialized, cb);
  });
};

function syncWrap(method) {
  return function() {
    if (!this.store.synchronous) throw new Error('CookieJar store is not synchronous; use async API instead.');

    var args = Array.prototype.slice.call(arguments);
    var syncErr, syncResult;
    args.push(function(err, result) {
      syncErr = err;
      syncResult = result;
    });
    this[method].apply(this, args);

    if (syncErr) throw syncErr;
    return syncResult;
  };
}

CAN_BE_SYNC.forEach(function(method) {
  CookieJar.prototype[method + 'Sync'] = syncWrap(method);
});

module.exports = {
  CookieJar: CookieJar,
  Cookie: Cookie,
  Store: Store,
  MemoryCookieStore: MemoryCookieStore,
  parseDate: parseDate,
  formatDate: formatDate,
  parse: parse,
  fromJSON: fromJSON,
  domainMatch: domainMatch,
  defaultPath: defaultPath,
  pathMatch: pathMatch,
  getPublicSuffix: pubsuffix.getPublicSuffix,
  cookieCompare: cookieCompare,
  permuteDomain: __wpreq__('tough-cookie/lib/permuteDomain').permuteDomain,
  permutePath: permutePath,
  canonicalDomain: canonicalDomain
};
//
},
net:
function(module) {
//
module.exports = require('net');
//
},
'tough-cookie/lib/pubsuffix':
function(module, exports, __wpreq__) {
//
var punycode = __wpreq__('punycode');

module.exports.getPublicSuffix = function(domain) {
  if (!domain || domain.match(/^\./)) return null;

  var asciiDomain = punycode.toASCII(domain),
    converted = false;
  if (asciiDomain !== domain) {
    domain = asciiDomain;
    converted = true;
  }
  if (index[domain]) return null;

  var parts = (domain = domain.toLowerCase()).split('.').reverse(),

    suffix = '',
    suffixLen = 0;
  for (var i = 0; i < parts.length; i++) {
    var partstr = parts[i] + suffix;

    if (index['*' + suffix]) {
      suffixLen = i + 1;
      index[partstr] !== false || suffixLen--;
    } else if (index[partstr]) suffixLen = i + 1;

    suffix = '.' + partstr;
  }

  if (index['*' + suffix]) return null;

  suffixLen = suffixLen || 1;
  if (parts.length > suffixLen) {
    var publicSuffix = parts.slice(0, suffixLen + 1).reverse().join('.');
    return converted ? punycode.toUnicode(publicSuffix) : publicSuffix;
  }

  return null;
};

// noinspection SpellCheckingInspection
var index = JSON.parse(
  '{"ac":true,"com.ac":true,"edu.ac":true,"gov.ac":true,"net.ac":true,"mil.ac":true,"org.ac":true,"ad":true,"nom.ad":true,"ae":true,"co.ae":true,"net.ae":true,"org.ae":true,"sch.ae":true,"ac.ae":true,"gov.ae":true,"mil.ae":true,"aero":true,"accident-investigation.aero":true,"accident-prevention.aero":true,"aerobatic.aero":true,"aeroclub.aero":true,"aerodrome.aero":true,"agents.aero":true,"aircraft.aero":true,"airline.aero":true,"airport.aero":true,"air-surveillance.aero":true,"airtraffic.aero":true,"air-traffic-control.aero":true,"ambulance.aero":true,"amusement.aero":true,"association.aero":true,"author.aero":true,"ballooning.aero":true,"broker.aero":true,"caa.aero":true,"cargo.aero":true,"catering.aero":true,"certification.aero":true,"championship.aero":true,"charter.aero":true,"civilaviation.aero":true,"club.aero":true,"conference.aero":true,"consultant.aero":true,"consulting.aero":true,"control.aero":true,"council.aero":true,"crew.aero":true,"design.aero":true,"dgca.aero":true,"educator.aero":true,"emergency.aero":true,"engine.aero":true,"engineer.aero":true,"entertainment.aero":true,"equipment.aero":true,"exchange.aero":true,"express.aero":true,"federation.aero":true,"flight.aero":true,"freight.aero":true,"fuel.aero":true,"gliding.aero":true,"government.aero":true,"groundhandling.aero":true,"group.aero":true,"hanggliding.aero":true,"homebuilt.aero":true,"insurance.aero":true,"journal.aero":true,"journalist.aero":true,"leasing.aero":true,"logistics.aero":true,"magazine.aero":true,"maintenance.aero":true,"media.aero":true,"microlight.aero":true,"modelling.aero":true,"navigation.aero":true,"parachuting.aero":true,"paragliding.aero":true,"passenger-association.aero":true,"pilot.aero":true,"press.aero":true,"production.aero":true,"recreation.aero":true,"repbody.aero":true,"res.aero":true,"research.aero":true,"rotorcraft.aero":true,"safety.aero":true,"scientist.aero":true,"services.aero":true,"show.aero":true,"skydiving.aero":true,"software.aero":true,"student.aero":true,"trader.aero":true,"trading.aero":true,"trainer.aero":true,"union.aero":true,"workinggroup.aero":true,"works.aero":true,"af":true,"gov.af":true,"com.af":true,"org.af":true,"net.af":true,"edu.af":true,"ag":true,"com.ag":true,"org.ag":true,"net.ag":true,"co.ag":true,"nom.ag":true,"ai":true,"off.ai":true,"com.ai":true,"net.ai":true,"org.ai":true,"al":true,"com.al":true,"edu.al":true,"gov.al":true,"mil.al":true,"net.al":true,"org.al":true,"am":true,"ao":true,"ed.ao":true,"gv.ao":true,"og.ao":true,"co.ao":true,"pb.ao":true,"it.ao":true,"aq":true,"ar":true,"com.ar":true,"edu.ar":true,"gob.ar":true,"gov.ar":true,"int.ar":true,"mil.ar":true,"musica.ar":true,"net.ar":true,"org.ar":true,"tur.ar":true,"arpa":true,"e164.arpa":true,"in-addr.arpa":true,"ip6.arpa":true,"iris.arpa":true,"uri.arpa":true,"urn.arpa":true,"as":true,"gov.as":true,"asia":true,"at":true,"ac.at":true,"co.at":true,"gv.at":true,"or.at":true,"au":true,"com.au":true,"net.au":true,"org.au":true,"edu.au":true,"gov.au":true,"asn.au":true,"id.au":true,"info.au":true,"conf.au":true,"oz.au":true,"act.au":true,"nsw.au":true,"nt.au":true,"qld.au":true,"sa.au":true,"tas.au":true,"vic.au":true,"wa.au":true,"act.edu.au":true,"nsw.edu.au":true,"nt.edu.au":true,"qld.edu.au":true,"sa.edu.au":true,"tas.edu.au":true,"vic.edu.au":true,"wa.edu.au":true,"qld.gov.au":true,"sa.gov.au":true,"tas.gov.au":true,"vic.gov.au":true,"wa.gov.au":true,"aw":true,"com.aw":true,"ax":true,"az":true,"com.az":true,"net.az":true,"int.az":true,"gov.az":true,"org.az":true,"edu.az":true,"info.az":true,"pp.az":true,"mil.az":true,"name.az":true,"pro.az":true,"biz.az":true,"ba":true,"com.ba":true,"edu.ba":true,"gov.ba":true,"mil.ba":true,"net.ba":true,"org.ba":true,"bb":true,"biz.bb":true,"co.bb":true,"com.bb":true,"edu.bb":true,"gov.bb":true,"info.bb":true,"net.bb":true,"org.bb":true,"store.bb":true,"tv.bb":true,"*.bd":true,"be":true,"ac.be":true,"bf":true,"gov.bf":true,"bg":true,"a.bg":true,"b.bg":true,"c.bg":true,"d.bg":true,"e.bg":true,\
"f.bg":true,"g.bg":true,"h.bg":true,"i.bg":true,"j.bg":true,"k.bg":true,"l.bg":true,"m.bg":true,"n.bg":true,"o.bg":true,"p.bg":true,"q.bg":true,"r.bg":true,"s.bg":true,"t.bg":true,"u.bg":true,"v.bg":true,"w.bg":true,"x.bg":true,"y.bg":true,"z.bg":true,"0.bg":true,"1.bg":true,"2.bg":true,"3.bg":true,"4.bg":true,"5.bg":true,"6.bg":true,"7.bg":true,"8.bg":true,"9.bg":true,"bh":true,"com.bh":true,"edu.bh":true,"net.bh":true,"org.bh":true,"gov.bh":true,"bi":true,"co.bi":true,"com.bi":true,"edu.bi":true,"or.bi":true,"org.bi":true,"biz":true,"bj":true,"asso.bj":true,"barreau.bj":true,"gouv.bj":true,"bm":true,"com.bm":true,"edu.bm":true,"gov.bm":true,"net.bm":true,"org.bm":true,"*.bn":true,"bo":true,"com.bo":true,"edu.bo":true,"gob.bo":true,"int.bo":true,"org.bo":true,"net.bo":true,"mil.bo":true,"tv.bo":true,"web.bo":true,"academia.bo":true,"agro.bo":true,"arte.bo":true,"blog.bo":true,"bolivia.bo":true,"ciencia.bo":true,"cooperativa.bo":true,"democracia.bo":true,"deporte.bo":true,"ecologia.bo":true,"economia.bo":true,"empresa.bo":true,"indigena.bo":true,"industria.bo":true,"info.bo":true,"medicina.bo":true,"movimiento.bo":true,"musica.bo":true,"natural.bo":true,"nombre.bo":true,"noticias.bo":true,"patria.bo":true,"politica.bo":true,"profesional.bo":true,"plurinacional.bo":true,"pueblo.bo":true,"revista.bo":true,"salud.bo":true,"tecnologia.bo":true,"tksat.bo":true,"transporte.bo":true,"wiki.bo":true,"br":true,"9guacu.br":true,"abc.br":true,"adm.br":true,"adv.br":true,"agr.br":true,"aju.br":true,"am.br":true,"anani.br":true,"aparecida.br":true,"arq.br":true,"art.br":true,"ato.br":true,"b.br":true,"belem.br":true,"bhz.br":true,"bio.br":true,"blog.br":true,"bmd.br":true,"boavista.br":true,"bsb.br":true,"campinagrande.br":true,"campinas.br":true,"caxias.br":true,"cim.br":true,"cng.br":true,"cnt.br":true,"com.br":true,"contagem.br":true,"coop.br":true,"cri.br":true,"cuiaba.br":true,"curitiba.br":true,"def.br":true,"ecn.br":true,"eco.br":true,"edu.br":true,"emp.br":true,"eng.br":true,"esp.br":true,"etc.br":true,"eti.br":true,"far.br":true,"feira.br":true,"flog.br":true,"floripa.br":true,"fm.br":true,"fnd.br":true,"fortal.br":true,"fot.br":true,"foz.br":true,"fst.br":true,"g12.br":true,"ggf.br":true,"goiania.br":true,"gov.br":true,"ac.gov.br":true,"al.gov.br":true,"am.gov.br":true,"ap.gov.br":true,"ba.gov.br":true,"ce.gov.br":true,"df.gov.br":true,"es.gov.br":true,"go.gov.br":true,"ma.gov.br":true,"mg.gov.br":true,"ms.gov.br":true,"mt.gov.br":true,"pa.gov.br":true,"pb.gov.br":true,"pe.gov.br":true,"pi.gov.br":true,"pr.gov.br":true,"rj.gov.br":true,"rn.gov.br":true,"ro.gov.br":true,"rr.gov.br":true,"rs.gov.br":true,"sc.gov.br":true,"se.gov.br":true,"sp.gov.br":true,"to.gov.br":true,"gru.br":true,"imb.br":true,"ind.br":true,"inf.br":true,"jab.br":true,"jampa.br":true,"jdf.br":true,"joinville.br":true,"jor.br":true,"jus.br":true,"leg.br":true,"lel.br":true,"londrina.br":true,"macapa.br":true,"maceio.br":true,"manaus.br":true,"maringa.br":true,"mat.br":true,"med.br":true,"mil.br":true,"morena.br":true,"mp.br":true,"mus.br":true,"natal.br":true,"net.br":true,"niteroi.br":true,"*.nom.br":true,"not.br":true,"ntr.br":true,"odo.br":true,"org.br":true,"osasco.br":true,"palmas.br":true,"poa.br":true,"ppg.br":true,"pro.br":true,"psc.br":true,"psi.br":true,"pvh.br":true,"qsl.br":true,"radio.br":true,"rec.br":true,"recife.br":true,"ribeirao.br":true,"rio.br":true,"riobranco.br":true,"riopreto.br":true,"salvador.br":true,"sampa.br":true,"santamaria.br":true,"santoandre.br":true,"saobernardo.br":true,"saogonca.br":true,"sjc.br":true,"slg.br":true,"slz.br":true,"sorocaba.br":true,"srv.br":true,"taxi.br":true,"teo.br":true,"the.br":true,"tmp.br":true,"trd.br":true,"tur.br":true,"tv.br":true,"udi.br":true,"vet.br":true,"vix.br":true,"vlog.br":true,"wiki.br":true,"zlg.br":true,"bs":true,"com.bs":true,"net.bs":true,"org.bs":true,"edu.bs":true,"gov.bs":true,"bt":true,"com.bt":true,"edu.bt":true,"gov.bt":true,"net.bt":true,"org.bt":true,"bv":true,"bw":true,\
"co.bw":true,"org.bw":true,"by":true,"gov.by":true,"mil.by":true,"com.by":true,"of.by":true,"bz":true,"com.bz":true,"net.bz":true,"org.bz":true,"edu.bz":true,"gov.bz":true,"ca":true,"ab.ca":true,"bc.ca":true,"mb.ca":true,"nb.ca":true,"nf.ca":true,"nl.ca":true,"ns.ca":true,"nt.ca":true,"nu.ca":true,"on.ca":true,"pe.ca":true,"qc.ca":true,"sk.ca":true,"yk.ca":true,"gc.ca":true,"cat":true,"cc":true,"cd":true,"gov.cd":true,"cf":true,"cg":true,"ch":true,"ci":true,"org.ci":true,"or.ci":true,"com.ci":true,"co.ci":true,"edu.ci":true,"ed.ci":true,"ac.ci":true,"net.ci":true,"go.ci":true,"asso.ci":true,"xn--aroport-bya.ci":true,"int.ci":true,"presse.ci":true,"md.ci":true,"gouv.ci":true,"*.ck":true,"www.ck":false,"cl":true,"gov.cl":true,"gob.cl":true,"co.cl":true,"mil.cl":true,"cm":true,"co.cm":true,"com.cm":true,"gov.cm":true,"net.cm":true,"cn":true,"ac.cn":true,"com.cn":true,"edu.cn":true,"gov.cn":true,"net.cn":true,"org.cn":true,"mil.cn":true,"xn--55qx5d.cn":true,"xn--io0a7i.cn":true,"xn--od0alg.cn":true,"ah.cn":true,"bj.cn":true,"cq.cn":true,"fj.cn":true,"gd.cn":true,"gs.cn":true,"gz.cn":true,"gx.cn":true,"ha.cn":true,"hb.cn":true,"he.cn":true,"hi.cn":true,"hl.cn":true,"hn.cn":true,"jl.cn":true,"js.cn":true,"jx.cn":true,"ln.cn":true,"nm.cn":true,"nx.cn":true,"qh.cn":true,"sc.cn":true,"sd.cn":true,"sh.cn":true,"sn.cn":true,"sx.cn":true,"tj.cn":true,"xj.cn":true,"xz.cn":true,"yn.cn":true,"zj.cn":true,"hk.cn":true,"mo.cn":true,"tw.cn":true,"co":true,"arts.co":true,"com.co":true,"edu.co":true,"firm.co":true,"gov.co":true,"info.co":true,"int.co":true,"mil.co":true,"net.co":true,"nom.co":true,"org.co":true,"rec.co":true,"web.co":true,"com":true,"coop":true,"cr":true,"ac.cr":true,"co.cr":true,"ed.cr":true,"fi.cr":true,"go.cr":true,"or.cr":true,"sa.cr":true,"cu":true,"com.cu":true,"edu.cu":true,"org.cu":true,"net.cu":true,"gov.cu":true,"inf.cu":true,"cv":true,"cw":true,"com.cw":true,"edu.cw":true,"net.cw":true,"org.cw":true,"cx":true,"gov.cx":true,"cy":true,"ac.cy":true,"biz.cy":true,"com.cy":true,"ekloges.cy":true,"gov.cy":true,"ltd.cy":true,"name.cy":true,"net.cy":true,"org.cy":true,"parliament.cy":true,"press.cy":true,"pro.cy":true,"tm.cy":true,"cz":true,"de":true,"dj":true,"dk":true,"dm":true,"com.dm":true,"net.dm":true,"org.dm":true,"edu.dm":true,"gov.dm":true,"do":true,"art.do":true,"com.do":true,"edu.do":true,"gob.do":true,"gov.do":true,"mil.do":true,"net.do":true,"org.do":true,"sld.do":true,"web.do":true,"dz":true,"com.dz":true,"org.dz":true,"net.dz":true,"gov.dz":true,"edu.dz":true,"asso.dz":true,"pol.dz":true,"art.dz":true,"ec":true,"com.ec":true,"info.ec":true,"net.ec":true,"fin.ec":true,"k12.ec":true,"med.ec":true,"pro.ec":true,"org.ec":true,"edu.ec":true,"gov.ec":true,"gob.ec":true,"mil.ec":true,"edu":true,"ee":true,"edu.ee":true,"gov.ee":true,"riik.ee":true,"lib.ee":true,"med.ee":true,"com.ee":true,"pri.ee":true,"aip.ee":true,"org.ee":true,"fie.ee":true,"eg":true,"com.eg":true,"edu.eg":true,"eun.eg":true,"gov.eg":true,"mil.eg":true,"name.eg":true,"net.eg":true,"org.eg":true,"sci.eg":true,"*.er":true,"es":true,"com.es":true,"nom.es":true,"org.es":true,"gob.es":true,"edu.es":true,"et":true,"com.et":true,"gov.et":true,"org.et":true,"edu.et":true,"biz.et":true,"name.et":true,"info.et":true,"net.et":true,"eu":true,"fi":true,"aland.fi":true,"*.fj":true,"*.fk":true,"fm":true,"fo":true,"fr":true,"com.fr":true,"asso.fr":true,"nom.fr":true,"prd.fr":true,"presse.fr":true,"tm.fr":true,"aeroport.fr":true,"assedic.fr":true,"avocat.fr":true,"avoues.fr":true,"cci.fr":true,"chambagri.fr":true,"chirurgiens-dentistes.fr":true,"experts-comptables.fr":true,"geometre-expert.fr":true,"gouv.fr":true,"greta.fr":true,"huissier-justice.fr":true,"medecin.fr":true,"notaires.fr":true,"pharmacien.fr":true,"port.fr":true,"veterinaire.fr":true,"ga":true,"gb":true,"gd":true,"ge":true,"com.ge":true,"edu.ge":true,"gov.ge":true,"org.ge":true,"mil.ge":true,"net.ge":true,"pvt.ge":true,"gf":true,"gg":true,"co.gg":true,"net.gg":true,"org.gg":true,"gh":true,\
"com.gh":true,"edu.gh":true,"gov.gh":true,"org.gh":true,"mil.gh":true,"gi":true,"com.gi":true,"ltd.gi":true,"gov.gi":true,"mod.gi":true,"edu.gi":true,"org.gi":true,"gl":true,"co.gl":true,"com.gl":true,"edu.gl":true,"net.gl":true,"org.gl":true,"gm":true,"gn":true,"ac.gn":true,"com.gn":true,"edu.gn":true,"gov.gn":true,"org.gn":true,"net.gn":true,"gov":true,"gp":true,"com.gp":true,"net.gp":true,"mobi.gp":true,"edu.gp":true,"org.gp":true,"asso.gp":true,"gq":true,"gr":true,"com.gr":true,"edu.gr":true,"net.gr":true,"org.gr":true,"gov.gr":true,"gs":true,"gt":true,"com.gt":true,"edu.gt":true,"gob.gt":true,"ind.gt":true,"mil.gt":true,"net.gt":true,"org.gt":true,"*.gu":true,"gw":true,"gy":true,"co.gy":true,"com.gy":true,"edu.gy":true,"gov.gy":true,"net.gy":true,"org.gy":true,"hk":true,"com.hk":true,"edu.hk":true,"gov.hk":true,"idv.hk":true,"net.hk":true,"org.hk":true,"xn--55qx5d.hk":true,"xn--wcvs22d.hk":true,"xn--lcvr32d.hk":true,"xn--mxtq1m.hk":true,"xn--gmqw5a.hk":true,"xn--ciqpn.hk":true,"xn--gmq050i.hk":true,"xn--zf0avx.hk":true,"xn--io0a7i.hk":true,"xn--mk0axi.hk":true,"xn--od0alg.hk":true,"xn--od0aq3b.hk":true,"xn--tn0ag.hk":true,"xn--uc0atv.hk":true,"xn--uc0ay4a.hk":true,"hm":true,"hn":true,"com.hn":true,"edu.hn":true,"org.hn":true,"net.hn":true,"mil.hn":true,"gob.hn":true,"hr":true,"iz.hr":true,"from.hr":true,"name.hr":true,"com.hr":true,"ht":true,"com.ht":true,"shop.ht":true,"firm.ht":true,"info.ht":true,"adult.ht":true,"net.ht":true,"pro.ht":true,"org.ht":true,"med.ht":true,"art.ht":true,"coop.ht":true,"pol.ht":true,"asso.ht":true,"edu.ht":true,"rel.ht":true,"gouv.ht":true,"perso.ht":true,"hu":true,"co.hu":true,"info.hu":true,"org.hu":true,"priv.hu":true,"sport.hu":true,"tm.hu":true,"2000.hu":true,"agrar.hu":true,"bolt.hu":true,"casino.hu":true,"city.hu":true,"erotica.hu":true,"erotika.hu":true,"film.hu":true,"forum.hu":true,"games.hu":true,"hotel.hu":true,"ingatlan.hu":true,"jogasz.hu":true,"konyvelo.hu":true,"lakas.hu":true,"media.hu":true,"news.hu":true,"reklam.hu":true,"sex.hu":true,"shop.hu":true,"suli.hu":true,"szex.hu":true,"tozsde.hu":true,"utazas.hu":true,"video.hu":true,"id":true,"ac.id":true,"biz.id":true,"co.id":true,"desa.id":true,"go.id":true,"mil.id":true,"my.id":true,"net.id":true,"or.id":true,"sch.id":true,"web.id":true,"ie":true,"gov.ie":true,"il":true,"ac.il":true,"co.il":true,"gov.il":true,"idf.il":true,"k12.il":true,"muni.il":true,"net.il":true,"org.il":true,"im":true,"ac.im":true,"co.im":true,"com.im":true,"ltd.co.im":true,"net.im":true,"org.im":true,"plc.co.im":true,"tt.im":true,"tv.im":true,"in":true,"co.in":true,"firm.in":true,"net.in":true,"org.in":true,"gen.in":true,"ind.in":true,"nic.in":true,"ac.in":true,"edu.in":true,"res.in":true,"gov.in":true,"mil.in":true,"info":true,"int":true,"eu.int":true,"io":true,"com.io":true,"iq":true,"gov.iq":true,"edu.iq":true,"mil.iq":true,"com.iq":true,"org.iq":true,"net.iq":true,"ir":true,"ac.ir":true,"co.ir":true,"gov.ir":true,"id.ir":true,"net.ir":true,"org.ir":true,"sch.ir":true,"xn--mgba3a4f16a.ir":true,"xn--mgba3a4fra.ir":true,"is":true,"net.is":true,"com.is":true,"edu.is":true,"gov.is":true,"org.is":true,"int.is":true,"it":true,"gov.it":true,"edu.it":true,"abr.it":true,"abruzzo.it":true,"aosta-valley.it":true,"aostavalley.it":true,"bas.it":true,"basilicata.it":true,"cal.it":true,"calabria.it":true,"cam.it":true,"campania.it":true,"emilia-romagna.it":true,"emiliaromagna.it":true,"emr.it":true,"friuli-v-giulia.it":true,"friuli-ve-giulia.it":true,"friuli-vegiulia.it":true,"friuli-venezia-giulia.it":true,"friuli-veneziagiulia.it":true,"friuli-vgiulia.it":true,"friuliv-giulia.it":true,"friulive-giulia.it":true,"friulivegiulia.it":true,"friulivenezia-giulia.it":true,"friuliveneziagiulia.it":true,"friulivgiulia.it":true,"fvg.it":true,"laz.it":true,"lazio.it":true,"lig.it":true,"liguria.it":true,"lom.it":true,"lombardia.it":true,"lombardy.it":true,"lucania.it":true,"mar.it":true,"marche.it":true,"mol.it":true,"molise.it":true,"piedmont.it":true,"piemonte.it":true,\
"pmn.it":true,"pug.it":true,"puglia.it":true,"sar.it":true,"sardegna.it":true,"sardinia.it":true,"sic.it":true,"sicilia.it":true,"sicily.it":true,"taa.it":true,"tos.it":true,"toscana.it":true,"trentino-a-adige.it":true,"trentino-aadige.it":true,"trentino-alto-adige.it":true,"trentino-altoadige.it":true,"trentino-s-tirol.it":true,"trentino-stirol.it":true,"trentino-sud-tirol.it":true,"trentino-sudtirol.it":true,"trentino-sued-tirol.it":true,"trentino-suedtirol.it":true,"trentinoa-adige.it":true,"trentinoaadige.it":true,"trentinoalto-adige.it":true,"trentinoaltoadige.it":true,"trentinos-tirol.it":true,"trentinostirol.it":true,"trentinosud-tirol.it":true,"trentinosudtirol.it":true,"trentinosued-tirol.it":true,"trentinosuedtirol.it":true,"tuscany.it":true,"umb.it":true,"umbria.it":true,"val-d-aosta.it":true,"val-daosta.it":true,"vald-aosta.it":true,"valdaosta.it":true,"valle-aosta.it":true,"valle-d-aosta.it":true,"valle-daosta.it":true,"valleaosta.it":true,"valled-aosta.it":true,"valledaosta.it":true,"vallee-aoste.it":true,"valleeaoste.it":true,"vao.it":true,"vda.it":true,"ven.it":true,"veneto.it":true,"ag.it":true,"agrigento.it":true,"al.it":true,"alessandria.it":true,"alto-adige.it":true,"altoadige.it":true,"an.it":true,"ancona.it":true,"andria-barletta-trani.it":true,"andria-trani-barletta.it":true,"andriabarlettatrani.it":true,"andriatranibarletta.it":true,"ao.it":true,"aosta.it":true,"aoste.it":true,"ap.it":true,"aq.it":true,"aquila.it":true,"ar.it":true,"arezzo.it":true,"ascoli-piceno.it":true,"ascolipiceno.it":true,"asti.it":true,"at.it":true,"av.it":true,"avellino.it":true,"ba.it":true,"balsan.it":true,"bari.it":true,"barletta-trani-andria.it":true,"barlettatraniandria.it":true,"belluno.it":true,"benevento.it":true,"bergamo.it":true,"bg.it":true,"bi.it":true,"biella.it":true,"bl.it":true,"bn.it":true,"bo.it":true,"bologna.it":true,"bolzano.it":true,"bozen.it":true,"br.it":true,"brescia.it":true,"brindisi.it":true,"bs.it":true,"bt.it":true,"bz.it":true,"ca.it":true,"cagliari.it":true,"caltanissetta.it":true,"campidano-medio.it":true,"campidanomedio.it":true,"campobasso.it":true,"carbonia-iglesias.it":true,"carboniaiglesias.it":true,"carrara-massa.it":true,"carraramassa.it":true,"caserta.it":true,"catania.it":true,"catanzaro.it":true,"cb.it":true,"ce.it":true,"cesena-forli.it":true,"cesenaforli.it":true,"ch.it":true,"chieti.it":true,"ci.it":true,"cl.it":true,"cn.it":true,"co.it":true,"como.it":true,"cosenza.it":true,"cr.it":true,"cremona.it":true,"crotone.it":true,"cs.it":true,"ct.it":true,"cuneo.it":true,"cz.it":true,"dell-ogliastra.it":true,"dellogliastra.it":true,"en.it":true,"enna.it":true,"fc.it":true,"fe.it":true,"fermo.it":true,"ferrara.it":true,"fg.it":true,"fi.it":true,"firenze.it":true,"florence.it":true,"fm.it":true,"foggia.it":true,"forli-cesena.it":true,"forlicesena.it":true,"fr.it":true,"frosinone.it":true,"ge.it":true,"genoa.it":true,"genova.it":true,"go.it":true,"gorizia.it":true,"gr.it":true,"grosseto.it":true,"iglesias-carbonia.it":true,"iglesiascarbonia.it":true,"im.it":true,"imperia.it":true,"is.it":true,"isernia.it":true,"kr.it":true,"la-spezia.it":true,"laquila.it":true,"laspezia.it":true,"latina.it":true,"lc.it":true,"le.it":true,"lecce.it":true,"lecco.it":true,"li.it":true,"livorno.it":true,"lo.it":true,"lodi.it":true,"lt.it":true,"lu.it":true,"lucca.it":true,"macerata.it":true,"mantova.it":true,"massa-carrara.it":true,"massacarrara.it":true,"matera.it":true,"mb.it":true,"mc.it":true,"me.it":true,"medio-campidano.it":true,"mediocampidano.it":true,"messina.it":true,"mi.it":true,"milan.it":true,"milano.it":true,"mn.it":true,"mo.it":true,"modena.it":true,"monza-brianza.it":true,"monza-e-della-brianza.it":true,"monza.it":true,"monzabrianza.it":true,"monzaebrianza.it":true,"monzaedellabrianza.it":true,"ms.it":true,"mt.it":true,"na.it":true,"naples.it":true,"napoli.it":true,"no.it":true,"novara.it":true,"nu.it":true,"nuoro.it":true,"og.it":true,"ogliastra.it":true,"olbia-tempio.it":true,\
"olbiatempio.it":true,"or.it":true,"oristano.it":true,"ot.it":true,"pa.it":true,"padova.it":true,"padua.it":true,"palermo.it":true,"parma.it":true,"pavia.it":true,"pc.it":true,"pd.it":true,"pe.it":true,"perugia.it":true,"pesaro-urbino.it":true,"pesarourbino.it":true,"pescara.it":true,"pg.it":true,"pi.it":true,"piacenza.it":true,"pisa.it":true,"pistoia.it":true,"pn.it":true,"po.it":true,"pordenone.it":true,"potenza.it":true,"pr.it":true,"prato.it":true,"pt.it":true,"pu.it":true,"pv.it":true,"pz.it":true,"ra.it":true,"ragusa.it":true,"ravenna.it":true,"rc.it":true,"re.it":true,"reggio-calabria.it":true,"reggio-emilia.it":true,"reggiocalabria.it":true,"reggioemilia.it":true,"rg.it":true,"ri.it":true,"rieti.it":true,"rimini.it":true,"rm.it":true,"rn.it":true,"ro.it":true,"roma.it":true,"rome.it":true,"rovigo.it":true,"sa.it":true,"salerno.it":true,"sassari.it":true,"savona.it":true,"si.it":true,"siena.it":true,"siracusa.it":true,"so.it":true,"sondrio.it":true,"sp.it":true,"sr.it":true,"ss.it":true,"suedtirol.it":true,"sv.it":true,"ta.it":true,"taranto.it":true,"te.it":true,"tempio-olbia.it":true,"tempioolbia.it":true,"teramo.it":true,"terni.it":true,"tn.it":true,"to.it":true,"torino.it":true,"tp.it":true,"tr.it":true,"trani-andria-barletta.it":true,"trani-barletta-andria.it":true,"traniandriabarletta.it":true,"tranibarlettaandria.it":true,"trapani.it":true,"trentino.it":true,"trento.it":true,"treviso.it":true,"trieste.it":true,"ts.it":true,"turin.it":true,"tv.it":true,"ud.it":true,"udine.it":true,"urbino-pesaro.it":true,"urbinopesaro.it":true,"va.it":true,"varese.it":true,"vb.it":true,"vc.it":true,"ve.it":true,"venezia.it":true,"venice.it":true,"verbania.it":true,"vercelli.it":true,"verona.it":true,"vi.it":true,"vibo-valentia.it":true,"vibovalentia.it":true,"vicenza.it":true,"viterbo.it":true,"vr.it":true,"vs.it":true,"vt.it":true,"vv.it":true,"je":true,"co.je":true,"net.je":true,"org.je":true,"*.jm":true,"jo":true,"com.jo":true,"org.jo":true,"net.jo":true,"edu.jo":true,"sch.jo":true,"gov.jo":true,"mil.jo":true,"name.jo":true,"jobs":true,"jp":true,"ac.jp":true,"ad.jp":true,"co.jp":true,"ed.jp":true,"go.jp":true,"gr.jp":true,"lg.jp":true,"ne.jp":true,"or.jp":true,"aichi.jp":true,"akita.jp":true,"aomori.jp":true,"chiba.jp":true,"ehime.jp":true,"fukui.jp":true,"fukuoka.jp":true,"fukushima.jp":true,"gifu.jp":true,"gunma.jp":true,"hiroshima.jp":true,"hokkaido.jp":true,"hyogo.jp":true,"ibaraki.jp":true,"ishikawa.jp":true,"iwate.jp":true,"kagawa.jp":true,"kagoshima.jp":true,"kanagawa.jp":true,"kochi.jp":true,"kumamoto.jp":true,"kyoto.jp":true,"mie.jp":true,"miyagi.jp":true,"miyazaki.jp":true,"nagano.jp":true,"nagasaki.jp":true,"nara.jp":true,"niigata.jp":true,"oita.jp":true,"okayama.jp":true,"okinawa.jp":true,"osaka.jp":true,"saga.jp":true,"saitama.jp":true,"shiga.jp":true,"shimane.jp":true,"shizuoka.jp":true,"tochigi.jp":true,"tokushima.jp":true,"tokyo.jp":true,"tottori.jp":true,"toyama.jp":true,"wakayama.jp":true,"yamagata.jp":true,"yamaguchi.jp":true,"yamanashi.jp":true,"xn--4pvxs.jp":true,"xn--vgu402c.jp":true,"xn--c3s14m.jp":true,"xn--f6qx53a.jp":true,"xn--8pvr4u.jp":true,"xn--uist22h.jp":true,"xn--djrs72d6uy.jp":true,"xn--mkru45i.jp":true,"xn--0trq7p7nn.jp":true,"xn--8ltr62k.jp":true,"xn--2m4a15e.jp":true,"xn--efvn9s.jp":true,"xn--32vp30h.jp":true,"xn--4it797k.jp":true,"xn--1lqs71d.jp":true,"xn--5rtp49c.jp":true,"xn--5js045d.jp":true,"xn--ehqz56n.jp":true,"xn--1lqs03n.jp":true,"xn--qqqt11m.jp":true,"xn--kbrq7o.jp":true,"xn--pssu33l.jp":true,"xn--ntsq17g.jp":true,"xn--uisz3g.jp":true,"xn--6btw5a.jp":true,"xn--1ctwo.jp":true,"xn--6orx2r.jp":true,"xn--rht61e.jp":true,"xn--rht27z.jp":true,"xn--djty4k.jp":true,"xn--nit225k.jp":true,"xn--rht3d.jp":true,"xn--klty5x.jp":true,"xn--kltx9a.jp":true,"xn--kltp7d.jp":true,"xn--uuwu58a.jp":true,"xn--zbx025d.jp":true,"xn--ntso0iqx3a.jp":true,"xn--elqq16h.jp":true,"xn--4it168d.jp":true,"xn--klt787d.jp":true,"xn--rny31h.jp":true,"xn--7t0a264c.jp":true,"xn--5rtq34k.jp":true,"xn--k7yn95e.jp":true,\
"xn--tor131o.jp":true,"xn--d5qv7z876c.jp":true,"*.kawasaki.jp":true,"*.kitakyushu.jp":true,"*.kobe.jp":true,"*.nagoya.jp":true,"*.sapporo.jp":true,"*.sendai.jp":true,"*.yokohama.jp":true,"city.kawasaki.jp":false,"city.kitakyushu.jp":false,"city.kobe.jp":false,"city.nagoya.jp":false,"city.sapporo.jp":false,"city.sendai.jp":false,"city.yokohama.jp":false,"aisai.aichi.jp":true,"ama.aichi.jp":true,"anjo.aichi.jp":true,"asuke.aichi.jp":true,"chiryu.aichi.jp":true,"chita.aichi.jp":true,"fuso.aichi.jp":true,"gamagori.aichi.jp":true,"handa.aichi.jp":true,"hazu.aichi.jp":true,"hekinan.aichi.jp":true,"higashiura.aichi.jp":true,"ichinomiya.aichi.jp":true,"inazawa.aichi.jp":true,"inuyama.aichi.jp":true,"isshiki.aichi.jp":true,"iwakura.aichi.jp":true,"kanie.aichi.jp":true,"kariya.aichi.jp":true,"kasugai.aichi.jp":true,"kira.aichi.jp":true,"kiyosu.aichi.jp":true,"komaki.aichi.jp":true,"konan.aichi.jp":true,"kota.aichi.jp":true,"mihama.aichi.jp":true,"miyoshi.aichi.jp":true,"nishio.aichi.jp":true,"nisshin.aichi.jp":true,"obu.aichi.jp":true,"oguchi.aichi.jp":true,"oharu.aichi.jp":true,"okazaki.aichi.jp":true,"owariasahi.aichi.jp":true,"seto.aichi.jp":true,"shikatsu.aichi.jp":true,"shinshiro.aichi.jp":true,"shitara.aichi.jp":true,"tahara.aichi.jp":true,"takahama.aichi.jp":true,"tobishima.aichi.jp":true,"toei.aichi.jp":true,"togo.aichi.jp":true,"tokai.aichi.jp":true,"tokoname.aichi.jp":true,"toyoake.aichi.jp":true,"toyohashi.aichi.jp":true,"toyokawa.aichi.jp":true,"toyone.aichi.jp":true,"toyota.aichi.jp":true,"tsushima.aichi.jp":true,"yatomi.aichi.jp":true,"akita.akita.jp":true,"daisen.akita.jp":true,"fujisato.akita.jp":true,"gojome.akita.jp":true,"hachirogata.akita.jp":true,"happou.akita.jp":true,"higashinaruse.akita.jp":true,"honjo.akita.jp":true,"honjyo.akita.jp":true,"ikawa.akita.jp":true,"kamikoani.akita.jp":true,"kamioka.akita.jp":true,"katagami.akita.jp":true,"kazuno.akita.jp":true,"kitaakita.akita.jp":true,"kosaka.akita.jp":true,"kyowa.akita.jp":true,"misato.akita.jp":true,"mitane.akita.jp":true,"moriyoshi.akita.jp":true,"nikaho.akita.jp":true,"noshiro.akita.jp":true,"odate.akita.jp":true,"oga.akita.jp":true,"ogata.akita.jp":true,"semboku.akita.jp":true,"yokote.akita.jp":true,"yurihonjo.akita.jp":true,"aomori.aomori.jp":true,"gonohe.aomori.jp":true,"hachinohe.aomori.jp":true,"hashikami.aomori.jp":true,"hiranai.aomori.jp":true,"hirosaki.aomori.jp":true,"itayanagi.aomori.jp":true,"kuroishi.aomori.jp":true,"misawa.aomori.jp":true,"mutsu.aomori.jp":true,"nakadomari.aomori.jp":true,"noheji.aomori.jp":true,"oirase.aomori.jp":true,"owani.aomori.jp":true,"rokunohe.aomori.jp":true,"sannohe.aomori.jp":true,"shichinohe.aomori.jp":true,"shingo.aomori.jp":true,"takko.aomori.jp":true,"towada.aomori.jp":true,"tsugaru.aomori.jp":true,"tsuruta.aomori.jp":true,"abiko.chiba.jp":true,"asahi.chiba.jp":true,"chonan.chiba.jp":true,"chosei.chiba.jp":true,"choshi.chiba.jp":true,"chuo.chiba.jp":true,"funabashi.chiba.jp":true,"futtsu.chiba.jp":true,"hanamigawa.chiba.jp":true,"ichihara.chiba.jp":true,"ichikawa.chiba.jp":true,"ichinomiya.chiba.jp":true,"inzai.chiba.jp":true,"isumi.chiba.jp":true,"kamagaya.chiba.jp":true,"kamogawa.chiba.jp":true,"kashiwa.chiba.jp":true,"katori.chiba.jp":true,"katsuura.chiba.jp":true,"kimitsu.chiba.jp":true,"kisarazu.chiba.jp":true,"kozaki.chiba.jp":true,"kujukuri.chiba.jp":true,"kyonan.chiba.jp":true,"matsudo.chiba.jp":true,"midori.chiba.jp":true,"mihama.chiba.jp":true,"minamiboso.chiba.jp":true,"mobara.chiba.jp":true,"mutsuzawa.chiba.jp":true,"nagara.chiba.jp":true,"nagareyama.chiba.jp":true,"narashino.chiba.jp":true,"narita.chiba.jp":true,"noda.chiba.jp":true,"oamishirasato.chiba.jp":true,"omigawa.chiba.jp":true,"onjuku.chiba.jp":true,"otaki.chiba.jp":true,"sakae.chiba.jp":true,"sakura.chiba.jp":true,"shimofusa.chiba.jp":true,"shirako.chiba.jp":true,"shiroi.chiba.jp":true,"shisui.chiba.jp":true,"sodegaura.chiba.jp":true,"sosa.chiba.jp":true,"tako.chiba.jp":true,"tateyama.chiba.jp":true,"togane.chiba.jp":true,\
"tohnosho.chiba.jp":true,"tomisato.chiba.jp":true,"urayasu.chiba.jp":true,"yachimata.chiba.jp":true,"yachiyo.chiba.jp":true,"yokaichiba.chiba.jp":true,"yokoshibahikari.chiba.jp":true,"yotsukaido.chiba.jp":true,"ainan.ehime.jp":true,"honai.ehime.jp":true,"ikata.ehime.jp":true,"imabari.ehime.jp":true,"iyo.ehime.jp":true,"kamijima.ehime.jp":true,"kihoku.ehime.jp":true,"kumakogen.ehime.jp":true,"masaki.ehime.jp":true,"matsuno.ehime.jp":true,"matsuyama.ehime.jp":true,"namikata.ehime.jp":true,"niihama.ehime.jp":true,"ozu.ehime.jp":true,"saijo.ehime.jp":true,"seiyo.ehime.jp":true,"shikokuchuo.ehime.jp":true,"tobe.ehime.jp":true,"toon.ehime.jp":true,"uchiko.ehime.jp":true,"uwajima.ehime.jp":true,"yawatahama.ehime.jp":true,"echizen.fukui.jp":true,"eiheiji.fukui.jp":true,"fukui.fukui.jp":true,"ikeda.fukui.jp":true,"katsuyama.fukui.jp":true,"mihama.fukui.jp":true,"minamiechizen.fukui.jp":true,"obama.fukui.jp":true,"ohi.fukui.jp":true,"ono.fukui.jp":true,"sabae.fukui.jp":true,"sakai.fukui.jp":true,"takahama.fukui.jp":true,"tsuruga.fukui.jp":true,"wakasa.fukui.jp":true,"ashiya.fukuoka.jp":true,"buzen.fukuoka.jp":true,"chikugo.fukuoka.jp":true,"chikuho.fukuoka.jp":true,"chikujo.fukuoka.jp":true,"chikushino.fukuoka.jp":true,"chikuzen.fukuoka.jp":true,"chuo.fukuoka.jp":true,"dazaifu.fukuoka.jp":true,"fukuchi.fukuoka.jp":true,"hakata.fukuoka.jp":true,"higashi.fukuoka.jp":true,"hirokawa.fukuoka.jp":true,"hisayama.fukuoka.jp":true,"iizuka.fukuoka.jp":true,"inatsuki.fukuoka.jp":true,"kaho.fukuoka.jp":true,"kasuga.fukuoka.jp":true,"kasuya.fukuoka.jp":true,"kawara.fukuoka.jp":true,"keisen.fukuoka.jp":true,"koga.fukuoka.jp":true,"kurate.fukuoka.jp":true,"kurogi.fukuoka.jp":true,"kurume.fukuoka.jp":true,"minami.fukuoka.jp":true,"miyako.fukuoka.jp":true,"miyama.fukuoka.jp":true,"miyawaka.fukuoka.jp":true,"mizumaki.fukuoka.jp":true,"munakata.fukuoka.jp":true,"nakagawa.fukuoka.jp":true,"nakama.fukuoka.jp":true,"nishi.fukuoka.jp":true,"nogata.fukuoka.jp":true,"ogori.fukuoka.jp":true,"okagaki.fukuoka.jp":true,"okawa.fukuoka.jp":true,"oki.fukuoka.jp":true,"omuta.fukuoka.jp":true,"onga.fukuoka.jp":true,"onojo.fukuoka.jp":true,"oto.fukuoka.jp":true,"saigawa.fukuoka.jp":true,"sasaguri.fukuoka.jp":true,"shingu.fukuoka.jp":true,"shinyoshitomi.fukuoka.jp":true,"shonai.fukuoka.jp":true,"soeda.fukuoka.jp":true,"sue.fukuoka.jp":true,"tachiarai.fukuoka.jp":true,"tagawa.fukuoka.jp":true,"takata.fukuoka.jp":true,"toho.fukuoka.jp":true,"toyotsu.fukuoka.jp":true,"tsuiki.fukuoka.jp":true,"ukiha.fukuoka.jp":true,"umi.fukuoka.jp":true,"usui.fukuoka.jp":true,"yamada.fukuoka.jp":true,"yame.fukuoka.jp":true,"yanagawa.fukuoka.jp":true,"yukuhashi.fukuoka.jp":true,"aizubange.fukushima.jp":true,"aizumisato.fukushima.jp":true,"aizuwakamatsu.fukushima.jp":true,"asakawa.fukushima.jp":true,"bandai.fukushima.jp":true,"date.fukushima.jp":true,"fukushima.fukushima.jp":true,"furudono.fukushima.jp":true,"futaba.fukushima.jp":true,"hanawa.fukushima.jp":true,"higashi.fukushima.jp":true,"hirata.fukushima.jp":true,"hirono.fukushima.jp":true,"iitate.fukushima.jp":true,"inawashiro.fukushima.jp":true,"ishikawa.fukushima.jp":true,"iwaki.fukushima.jp":true,"izumizaki.fukushima.jp":true,"kagamiishi.fukushima.jp":true,"kaneyama.fukushima.jp":true,"kawamata.fukushima.jp":true,"kitakata.fukushima.jp":true,"kitashiobara.fukushima.jp":true,"koori.fukushima.jp":true,"koriyama.fukushima.jp":true,"kunimi.fukushima.jp":true,"miharu.fukushima.jp":true,"mishima.fukushima.jp":true,"namie.fukushima.jp":true,"nango.fukushima.jp":true,"nishiaizu.fukushima.jp":true,"nishigo.fukushima.jp":true,"okuma.fukushima.jp":true,"omotego.fukushima.jp":true,"ono.fukushima.jp":true,"otama.fukushima.jp":true,"samegawa.fukushima.jp":true,"shimogo.fukushima.jp":true,"shirakawa.fukushima.jp":true,"showa.fukushima.jp":true,"soma.fukushima.jp":true,"sukagawa.fukushima.jp":true,"taishin.fukushima.jp":true,"tamakawa.fukushima.jp":true,"tanagura.fukushima.jp":true,"tenei.fukushima.jp":true,"yabuki.fukushima.jp":true,\
"yamato.fukushima.jp":true,"yamatsuri.fukushima.jp":true,"yanaizu.fukushima.jp":true,"yugawa.fukushima.jp":true,"anpachi.gifu.jp":true,"ena.gifu.jp":true,"gifu.gifu.jp":true,"ginan.gifu.jp":true,"godo.gifu.jp":true,"gujo.gifu.jp":true,"hashima.gifu.jp":true,"hichiso.gifu.jp":true,"hida.gifu.jp":true,"higashishirakawa.gifu.jp":true,"ibigawa.gifu.jp":true,"ikeda.gifu.jp":true,"kakamigahara.gifu.jp":true,"kani.gifu.jp":true,"kasahara.gifu.jp":true,"kasamatsu.gifu.jp":true,"kawaue.gifu.jp":true,"kitagata.gifu.jp":true,"mino.gifu.jp":true,"minokamo.gifu.jp":true,"mitake.gifu.jp":true,"mizunami.gifu.jp":true,"motosu.gifu.jp":true,"nakatsugawa.gifu.jp":true,"ogaki.gifu.jp":true,"sakahogi.gifu.jp":true,"seki.gifu.jp":true,"sekigahara.gifu.jp":true,"shirakawa.gifu.jp":true,"tajimi.gifu.jp":true,"takayama.gifu.jp":true,"tarui.gifu.jp":true,"toki.gifu.jp":true,"tomika.gifu.jp":true,"wanouchi.gifu.jp":true,"yamagata.gifu.jp":true,"yaotsu.gifu.jp":true,"yoro.gifu.jp":true,"annaka.gunma.jp":true,"chiyoda.gunma.jp":true,"fujioka.gunma.jp":true,"higashiagatsuma.gunma.jp":true,"isesaki.gunma.jp":true,"itakura.gunma.jp":true,"kanna.gunma.jp":true,"kanra.gunma.jp":true,"katashina.gunma.jp":true,"kawaba.gunma.jp":true,"kiryu.gunma.jp":true,"kusatsu.gunma.jp":true,"maebashi.gunma.jp":true,"meiwa.gunma.jp":true,"midori.gunma.jp":true,"minakami.gunma.jp":true,"naganohara.gunma.jp":true,"nakanojo.gunma.jp":true,"nanmoku.gunma.jp":true,"numata.gunma.jp":true,"oizumi.gunma.jp":true,"ora.gunma.jp":true,"ota.gunma.jp":true,"shibukawa.gunma.jp":true,"shimonita.gunma.jp":true,"shinto.gunma.jp":true,"showa.gunma.jp":true,"takasaki.gunma.jp":true,"takayama.gunma.jp":true,"tamamura.gunma.jp":true,"tatebayashi.gunma.jp":true,"tomioka.gunma.jp":true,"tsukiyono.gunma.jp":true,"tsumagoi.gunma.jp":true,"ueno.gunma.jp":true,"yoshioka.gunma.jp":true,"asaminami.hiroshima.jp":true,"daiwa.hiroshima.jp":true,"etajima.hiroshima.jp":true,"fuchu.hiroshima.jp":true,"fukuyama.hiroshima.jp":true,"hatsukaichi.hiroshima.jp":true,"higashihiroshima.hiroshima.jp":true,"hongo.hiroshima.jp":true,"jinsekikogen.hiroshima.jp":true,"kaita.hiroshima.jp":true,"kui.hiroshima.jp":true,"kumano.hiroshima.jp":true,"kure.hiroshima.jp":true,"mihara.hiroshima.jp":true,"miyoshi.hiroshima.jp":true,"naka.hiroshima.jp":true,"onomichi.hiroshima.jp":true,"osakikamijima.hiroshima.jp":true,"otake.hiroshima.jp":true,"saka.hiroshima.jp":true,"sera.hiroshima.jp":true,"seranishi.hiroshima.jp":true,"shinichi.hiroshima.jp":true,"shobara.hiroshima.jp":true,"takehara.hiroshima.jp":true,"abashiri.hokkaido.jp":true,"abira.hokkaido.jp":true,"aibetsu.hokkaido.jp":true,"akabira.hokkaido.jp":true,"akkeshi.hokkaido.jp":true,"asahikawa.hokkaido.jp":true,"ashibetsu.hokkaido.jp":true,"ashoro.hokkaido.jp":true,"assabu.hokkaido.jp":true,"atsuma.hokkaido.jp":true,"bibai.hokkaido.jp":true,"biei.hokkaido.jp":true,"bifuka.hokkaido.jp":true,"bihoro.hokkaido.jp":true,"biratori.hokkaido.jp":true,"chippubetsu.hokkaido.jp":true,"chitose.hokkaido.jp":true,"date.hokkaido.jp":true,"ebetsu.hokkaido.jp":true,"embetsu.hokkaido.jp":true,"eniwa.hokkaido.jp":true,"erimo.hokkaido.jp":true,"esan.hokkaido.jp":true,"esashi.hokkaido.jp":true,"fukagawa.hokkaido.jp":true,"fukushima.hokkaido.jp":true,"furano.hokkaido.jp":true,"furubira.hokkaido.jp":true,"haboro.hokkaido.jp":true,"hakodate.hokkaido.jp":true,"hamatonbetsu.hokkaido.jp":true,"hidaka.hokkaido.jp":true,"higashikagura.hokkaido.jp":true,"higashikawa.hokkaido.jp":true,"hiroo.hokkaido.jp":true,"hokuryu.hokkaido.jp":true,"hokuto.hokkaido.jp":true,"honbetsu.hokkaido.jp":true,"horokanai.hokkaido.jp":true,"horonobe.hokkaido.jp":true,"ikeda.hokkaido.jp":true,"imakane.hokkaido.jp":true,"ishikari.hokkaido.jp":true,"iwamizawa.hokkaido.jp":true,"iwanai.hokkaido.jp":true,"kamifurano.hokkaido.jp":true,"kamikawa.hokkaido.jp":true,"kamishihoro.hokkaido.jp":true,"kamisunagawa.hokkaido.jp":true,"kamoenai.hokkaido.jp":true,"kayabe.hokkaido.jp":true,"kembuchi.hokkaido.jp":true,"kikonai.hokkaido.jp":true,\
"kimobetsu.hokkaido.jp":true,"kitahiroshima.hokkaido.jp":true,"kitami.hokkaido.jp":true,"kiyosato.hokkaido.jp":true,"koshimizu.hokkaido.jp":true,"kunneppu.hokkaido.jp":true,"kuriyama.hokkaido.jp":true,"kuromatsunai.hokkaido.jp":true,"kushiro.hokkaido.jp":true,"kutchan.hokkaido.jp":true,"kyowa.hokkaido.jp":true,"mashike.hokkaido.jp":true,"matsumae.hokkaido.jp":true,"mikasa.hokkaido.jp":true,"minamifurano.hokkaido.jp":true,"mombetsu.hokkaido.jp":true,"moseushi.hokkaido.jp":true,"mukawa.hokkaido.jp":true,"muroran.hokkaido.jp":true,"naie.hokkaido.jp":true,"nakagawa.hokkaido.jp":true,"nakasatsunai.hokkaido.jp":true,"nakatombetsu.hokkaido.jp":true,"nanae.hokkaido.jp":true,"nanporo.hokkaido.jp":true,"nayoro.hokkaido.jp":true,"nemuro.hokkaido.jp":true,"niikappu.hokkaido.jp":true,"niki.hokkaido.jp":true,"nishiokoppe.hokkaido.jp":true,"noboribetsu.hokkaido.jp":true,"numata.hokkaido.jp":true,"obihiro.hokkaido.jp":true,"obira.hokkaido.jp":true,"oketo.hokkaido.jp":true,"okoppe.hokkaido.jp":true,"otaru.hokkaido.jp":true,"otobe.hokkaido.jp":true,"otofuke.hokkaido.jp":true,"otoineppu.hokkaido.jp":true,"oumu.hokkaido.jp":true,"ozora.hokkaido.jp":true,"pippu.hokkaido.jp":true,"rankoshi.hokkaido.jp":true,"rebun.hokkaido.jp":true,"rikubetsu.hokkaido.jp":true,"rishiri.hokkaido.jp":true,"rishirifuji.hokkaido.jp":true,"saroma.hokkaido.jp":true,"sarufutsu.hokkaido.jp":true,"shakotan.hokkaido.jp":true,"shari.hokkaido.jp":true,"shibecha.hokkaido.jp":true,"shibetsu.hokkaido.jp":true,"shikabe.hokkaido.jp":true,"shikaoi.hokkaido.jp":true,"shimamaki.hokkaido.jp":true,"shimizu.hokkaido.jp":true,"shimokawa.hokkaido.jp":true,"shinshinotsu.hokkaido.jp":true,"shintoku.hokkaido.jp":true,"shiranuka.hokkaido.jp":true,"shiraoi.hokkaido.jp":true,"shiriuchi.hokkaido.jp":true,"sobetsu.hokkaido.jp":true,"sunagawa.hokkaido.jp":true,"taiki.hokkaido.jp":true,"takasu.hokkaido.jp":true,"takikawa.hokkaido.jp":true,"takinoue.hokkaido.jp":true,"teshikaga.hokkaido.jp":true,"tobetsu.hokkaido.jp":true,"tohma.hokkaido.jp":true,"tomakomai.hokkaido.jp":true,"tomari.hokkaido.jp":true,"toya.hokkaido.jp":true,"toyako.hokkaido.jp":true,"toyotomi.hokkaido.jp":true,"toyoura.hokkaido.jp":true,"tsubetsu.hokkaido.jp":true,"tsukigata.hokkaido.jp":true,"urakawa.hokkaido.jp":true,"urausu.hokkaido.jp":true,"uryu.hokkaido.jp":true,"utashinai.hokkaido.jp":true,"wakkanai.hokkaido.jp":true,"wassamu.hokkaido.jp":true,"yakumo.hokkaido.jp":true,"yoichi.hokkaido.jp":true,"aioi.hyogo.jp":true,"akashi.hyogo.jp":true,"ako.hyogo.jp":true,"amagasaki.hyogo.jp":true,"aogaki.hyogo.jp":true,"asago.hyogo.jp":true,"ashiya.hyogo.jp":true,"awaji.hyogo.jp":true,"fukusaki.hyogo.jp":true,"goshiki.hyogo.jp":true,"harima.hyogo.jp":true,"himeji.hyogo.jp":true,"ichikawa.hyogo.jp":true,"inagawa.hyogo.jp":true,"itami.hyogo.jp":true,"kakogawa.hyogo.jp":true,"kamigori.hyogo.jp":true,"kamikawa.hyogo.jp":true,"kasai.hyogo.jp":true,"kasuga.hyogo.jp":true,"kawanishi.hyogo.jp":true,"miki.hyogo.jp":true,"minamiawaji.hyogo.jp":true,"nishinomiya.hyogo.jp":true,"nishiwaki.hyogo.jp":true,"ono.hyogo.jp":true,"sanda.hyogo.jp":true,"sannan.hyogo.jp":true,"sasayama.hyogo.jp":true,"sayo.hyogo.jp":true,"shingu.hyogo.jp":true,"shinonsen.hyogo.jp":true,"shiso.hyogo.jp":true,"sumoto.hyogo.jp":true,"taishi.hyogo.jp":true,"taka.hyogo.jp":true,"takarazuka.hyogo.jp":true,"takasago.hyogo.jp":true,"takino.hyogo.jp":true,"tamba.hyogo.jp":true,"tatsuno.hyogo.jp":true,"toyooka.hyogo.jp":true,"yabu.hyogo.jp":true,"yashiro.hyogo.jp":true,"yoka.hyogo.jp":true,"yokawa.hyogo.jp":true,"ami.ibaraki.jp":true,"asahi.ibaraki.jp":true,"bando.ibaraki.jp":true,"chikusei.ibaraki.jp":true,"daigo.ibaraki.jp":true,"fujishiro.ibaraki.jp":true,"hitachi.ibaraki.jp":true,"hitachinaka.ibaraki.jp":true,"hitachiomiya.ibaraki.jp":true,"hitachiota.ibaraki.jp":true,"ibaraki.ibaraki.jp":true,"ina.ibaraki.jp":true,"inashiki.ibaraki.jp":true,"itako.ibaraki.jp":true,"iwama.ibaraki.jp":true,"joso.ibaraki.jp":true,"kamisu.ibaraki.jp":true,"kasama.ibaraki.jp":true,\
"kashima.ibaraki.jp":true,"kasumigaura.ibaraki.jp":true,"koga.ibaraki.jp":true,"miho.ibaraki.jp":true,"mito.ibaraki.jp":true,"moriya.ibaraki.jp":true,"naka.ibaraki.jp":true,"namegata.ibaraki.jp":true,"oarai.ibaraki.jp":true,"ogawa.ibaraki.jp":true,"omitama.ibaraki.jp":true,"ryugasaki.ibaraki.jp":true,"sakai.ibaraki.jp":true,"sakuragawa.ibaraki.jp":true,"shimodate.ibaraki.jp":true,"shimotsuma.ibaraki.jp":true,"shirosato.ibaraki.jp":true,"sowa.ibaraki.jp":true,"suifu.ibaraki.jp":true,"takahagi.ibaraki.jp":true,"tamatsukuri.ibaraki.jp":true,"tokai.ibaraki.jp":true,"tomobe.ibaraki.jp":true,"tone.ibaraki.jp":true,"toride.ibaraki.jp":true,"tsuchiura.ibaraki.jp":true,"tsukuba.ibaraki.jp":true,"uchihara.ibaraki.jp":true,"ushiku.ibaraki.jp":true,"yachiyo.ibaraki.jp":true,"yamagata.ibaraki.jp":true,"yawara.ibaraki.jp":true,"yuki.ibaraki.jp":true,"anamizu.ishikawa.jp":true,"hakui.ishikawa.jp":true,"hakusan.ishikawa.jp":true,"kaga.ishikawa.jp":true,"kahoku.ishikawa.jp":true,"kanazawa.ishikawa.jp":true,"kawakita.ishikawa.jp":true,"komatsu.ishikawa.jp":true,"nakanoto.ishikawa.jp":true,"nanao.ishikawa.jp":true,"nomi.ishikawa.jp":true,"nonoichi.ishikawa.jp":true,"noto.ishikawa.jp":true,"shika.ishikawa.jp":true,"suzu.ishikawa.jp":true,"tsubata.ishikawa.jp":true,"tsurugi.ishikawa.jp":true,"uchinada.ishikawa.jp":true,"wajima.ishikawa.jp":true,"fudai.iwate.jp":true,"fujisawa.iwate.jp":true,"hanamaki.iwate.jp":true,"hiraizumi.iwate.jp":true,"hirono.iwate.jp":true,"ichinohe.iwate.jp":true,"ichinoseki.iwate.jp":true,"iwaizumi.iwate.jp":true,"iwate.iwate.jp":true,"joboji.iwate.jp":true,"kamaishi.iwate.jp":true,"kanegasaki.iwate.jp":true,"karumai.iwate.jp":true,"kawai.iwate.jp":true,"kitakami.iwate.jp":true,"kuji.iwate.jp":true,"kunohe.iwate.jp":true,"kuzumaki.iwate.jp":true,"miyako.iwate.jp":true,"mizusawa.iwate.jp":true,"morioka.iwate.jp":true,"ninohe.iwate.jp":true,"noda.iwate.jp":true,"ofunato.iwate.jp":true,"oshu.iwate.jp":true,"otsuchi.iwate.jp":true,"rikuzentakata.iwate.jp":true,"shiwa.iwate.jp":true,"shizukuishi.iwate.jp":true,"sumita.iwate.jp":true,"tanohata.iwate.jp":true,"tono.iwate.jp":true,"yahaba.iwate.jp":true,"yamada.iwate.jp":true,"ayagawa.kagawa.jp":true,"higashikagawa.kagawa.jp":true,"kanonji.kagawa.jp":true,"kotohira.kagawa.jp":true,"manno.kagawa.jp":true,"marugame.kagawa.jp":true,"mitoyo.kagawa.jp":true,"naoshima.kagawa.jp":true,"sanuki.kagawa.jp":true,"tadotsu.kagawa.jp":true,"takamatsu.kagawa.jp":true,"tonosho.kagawa.jp":true,"uchinomi.kagawa.jp":true,"utazu.kagawa.jp":true,"zentsuji.kagawa.jp":true,"akune.kagoshima.jp":true,"amami.kagoshima.jp":true,"hioki.kagoshima.jp":true,"isa.kagoshima.jp":true,"isen.kagoshima.jp":true,"izumi.kagoshima.jp":true,"kagoshima.kagoshima.jp":true,"kanoya.kagoshima.jp":true,"kawanabe.kagoshima.jp":true,"kinko.kagoshima.jp":true,"kouyama.kagoshima.jp":true,"makurazaki.kagoshima.jp":true,"matsumoto.kagoshima.jp":true,"minamitane.kagoshima.jp":true,"nakatane.kagoshima.jp":true,"nishinoomote.kagoshima.jp":true,"satsumasendai.kagoshima.jp":true,"soo.kagoshima.jp":true,"tarumizu.kagoshima.jp":true,"yusui.kagoshima.jp":true,"aikawa.kanagawa.jp":true,"atsugi.kanagawa.jp":true,"ayase.kanagawa.jp":true,"chigasaki.kanagawa.jp":true,"ebina.kanagawa.jp":true,"fujisawa.kanagawa.jp":true,"hadano.kanagawa.jp":true,"hakone.kanagawa.jp":true,"hiratsuka.kanagawa.jp":true,"isehara.kanagawa.jp":true,"kaisei.kanagawa.jp":true,"kamakura.kanagawa.jp":true,"kiyokawa.kanagawa.jp":true,"matsuda.kanagawa.jp":true,"minamiashigara.kanagawa.jp":true,"miura.kanagawa.jp":true,"nakai.kanagawa.jp":true,"ninomiya.kanagawa.jp":true,"odawara.kanagawa.jp":true,"oi.kanagawa.jp":true,"oiso.kanagawa.jp":true,"sagamihara.kanagawa.jp":true,"samukawa.kanagawa.jp":true,"tsukui.kanagawa.jp":true,"yamakita.kanagawa.jp":true,"yamato.kanagawa.jp":true,"yokosuka.kanagawa.jp":true,"yugawara.kanagawa.jp":true,"zama.kanagawa.jp":true,"zushi.kanagawa.jp":true,"aki.kochi.jp":true,"geisei.kochi.jp":true,"hidaka.kochi.jp":true,\
"higashitsuno.kochi.jp":true,"ino.kochi.jp":true,"kagami.kochi.jp":true,"kami.kochi.jp":true,"kitagawa.kochi.jp":true,"kochi.kochi.jp":true,"mihara.kochi.jp":true,"motoyama.kochi.jp":true,"muroto.kochi.jp":true,"nahari.kochi.jp":true,"nakamura.kochi.jp":true,"nankoku.kochi.jp":true,"nishitosa.kochi.jp":true,"niyodogawa.kochi.jp":true,"ochi.kochi.jp":true,"okawa.kochi.jp":true,"otoyo.kochi.jp":true,"otsuki.kochi.jp":true,"sakawa.kochi.jp":true,"sukumo.kochi.jp":true,"susaki.kochi.jp":true,"tosa.kochi.jp":true,"tosashimizu.kochi.jp":true,"toyo.kochi.jp":true,"tsuno.kochi.jp":true,"umaji.kochi.jp":true,"yasuda.kochi.jp":true,"yusuhara.kochi.jp":true,"amakusa.kumamoto.jp":true,"arao.kumamoto.jp":true,"aso.kumamoto.jp":true,"choyo.kumamoto.jp":true,"gyokuto.kumamoto.jp":true,"kamiamakusa.kumamoto.jp":true,"kikuchi.kumamoto.jp":true,"kumamoto.kumamoto.jp":true,"mashiki.kumamoto.jp":true,"mifune.kumamoto.jp":true,"minamata.kumamoto.jp":true,"minamioguni.kumamoto.jp":true,"nagasu.kumamoto.jp":true,"nishihara.kumamoto.jp":true,"oguni.kumamoto.jp":true,"ozu.kumamoto.jp":true,"sumoto.kumamoto.jp":true,"takamori.kumamoto.jp":true,"uki.kumamoto.jp":true,"uto.kumamoto.jp":true,"yamaga.kumamoto.jp":true,"yamato.kumamoto.jp":true,"yatsushiro.kumamoto.jp":true,"ayabe.kyoto.jp":true,"fukuchiyama.kyoto.jp":true,"higashiyama.kyoto.jp":true,"ide.kyoto.jp":true,"ine.kyoto.jp":true,"joyo.kyoto.jp":true,"kameoka.kyoto.jp":true,"kamo.kyoto.jp":true,"kita.kyoto.jp":true,"kizu.kyoto.jp":true,"kumiyama.kyoto.jp":true,"kyotamba.kyoto.jp":true,"kyotanabe.kyoto.jp":true,"kyotango.kyoto.jp":true,"maizuru.kyoto.jp":true,"minami.kyoto.jp":true,"minamiyamashiro.kyoto.jp":true,"miyazu.kyoto.jp":true,"muko.kyoto.jp":true,"nagaokakyo.kyoto.jp":true,"nakagyo.kyoto.jp":true,"nantan.kyoto.jp":true,"oyamazaki.kyoto.jp":true,"sakyo.kyoto.jp":true,"seika.kyoto.jp":true,"tanabe.kyoto.jp":true,"uji.kyoto.jp":true,"ujitawara.kyoto.jp":true,"wazuka.kyoto.jp":true,"yamashina.kyoto.jp":true,"yawata.kyoto.jp":true,"asahi.mie.jp":true,"inabe.mie.jp":true,"ise.mie.jp":true,"kameyama.mie.jp":true,"kawagoe.mie.jp":true,"kiho.mie.jp":true,"kisosaki.mie.jp":true,"kiwa.mie.jp":true,"komono.mie.jp":true,"kumano.mie.jp":true,"kuwana.mie.jp":true,"matsusaka.mie.jp":true,"meiwa.mie.jp":true,"mihama.mie.jp":true,"minamiise.mie.jp":true,"misugi.mie.jp":true,"miyama.mie.jp":true,"nabari.mie.jp":true,"shima.mie.jp":true,"suzuka.mie.jp":true,"tado.mie.jp":true,"taiki.mie.jp":true,"taki.mie.jp":true,"tamaki.mie.jp":true,"toba.mie.jp":true,"tsu.mie.jp":true,"udono.mie.jp":true,"ureshino.mie.jp":true,"watarai.mie.jp":true,"yokkaichi.mie.jp":true,"furukawa.miyagi.jp":true,"higashimatsushima.miyagi.jp":true,"ishinomaki.miyagi.jp":true,"iwanuma.miyagi.jp":true,"kakuda.miyagi.jp":true,"kami.miyagi.jp":true,"kawasaki.miyagi.jp":true,"marumori.miyagi.jp":true,"matsushima.miyagi.jp":true,"minamisanriku.miyagi.jp":true,"misato.miyagi.jp":true,"murata.miyagi.jp":true,"natori.miyagi.jp":true,"ogawara.miyagi.jp":true,"ohira.miyagi.jp":true,"onagawa.miyagi.jp":true,"osaki.miyagi.jp":true,"rifu.miyagi.jp":true,"semine.miyagi.jp":true,"shibata.miyagi.jp":true,"shichikashuku.miyagi.jp":true,"shikama.miyagi.jp":true,"shiogama.miyagi.jp":true,"shiroishi.miyagi.jp":true,"tagajo.miyagi.jp":true,"taiwa.miyagi.jp":true,"tome.miyagi.jp":true,"tomiya.miyagi.jp":true,"wakuya.miyagi.jp":true,"watari.miyagi.jp":true,"yamamoto.miyagi.jp":true,"zao.miyagi.jp":true,"aya.miyazaki.jp":true,"ebino.miyazaki.jp":true,"gokase.miyazaki.jp":true,"hyuga.miyazaki.jp":true,"kadogawa.miyazaki.jp":true,"kawaminami.miyazaki.jp":true,"kijo.miyazaki.jp":true,"kitagawa.miyazaki.jp":true,"kitakata.miyazaki.jp":true,"kitaura.miyazaki.jp":true,"kobayashi.miyazaki.jp":true,"kunitomi.miyazaki.jp":true,"kushima.miyazaki.jp":true,"mimata.miyazaki.jp":true,"miyakonojo.miyazaki.jp":true,"miyazaki.miyazaki.jp":true,"morotsuka.miyazaki.jp":true,"nichinan.miyazaki.jp":true,"nishimera.miyazaki.jp":true,"nobeoka.miyazaki.jp":true,\
"saito.miyazaki.jp":true,"shiiba.miyazaki.jp":true,"shintomi.miyazaki.jp":true,"takaharu.miyazaki.jp":true,"takanabe.miyazaki.jp":true,"takazaki.miyazaki.jp":true,"tsuno.miyazaki.jp":true,"achi.nagano.jp":true,"agematsu.nagano.jp":true,"anan.nagano.jp":true,"aoki.nagano.jp":true,"asahi.nagano.jp":true,"azumino.nagano.jp":true,"chikuhoku.nagano.jp":true,"chikuma.nagano.jp":true,"chino.nagano.jp":true,"fujimi.nagano.jp":true,"hakuba.nagano.jp":true,"hara.nagano.jp":true,"hiraya.nagano.jp":true,"iida.nagano.jp":true,"iijima.nagano.jp":true,"iiyama.nagano.jp":true,"iizuna.nagano.jp":true,"ikeda.nagano.jp":true,"ikusaka.nagano.jp":true,"ina.nagano.jp":true,"karuizawa.nagano.jp":true,"kawakami.nagano.jp":true,"kiso.nagano.jp":true,"kisofukushima.nagano.jp":true,"kitaaiki.nagano.jp":true,"komagane.nagano.jp":true,"komoro.nagano.jp":true,"matsukawa.nagano.jp":true,"matsumoto.nagano.jp":true,"miasa.nagano.jp":true,"minamiaiki.nagano.jp":true,"minamimaki.nagano.jp":true,"minamiminowa.nagano.jp":true,"minowa.nagano.jp":true,"miyada.nagano.jp":true,"miyota.nagano.jp":true,"mochizuki.nagano.jp":true,"nagano.nagano.jp":true,"nagawa.nagano.jp":true,"nagiso.nagano.jp":true,"nakagawa.nagano.jp":true,"nakano.nagano.jp":true,"nozawaonsen.nagano.jp":true,"obuse.nagano.jp":true,"ogawa.nagano.jp":true,"okaya.nagano.jp":true,"omachi.nagano.jp":true,"omi.nagano.jp":true,"ookuwa.nagano.jp":true,"ooshika.nagano.jp":true,"otaki.nagano.jp":true,"otari.nagano.jp":true,"sakae.nagano.jp":true,"sakaki.nagano.jp":true,"saku.nagano.jp":true,"sakuho.nagano.jp":true,"shimosuwa.nagano.jp":true,"shinanomachi.nagano.jp":true,"shiojiri.nagano.jp":true,"suwa.nagano.jp":true,"suzaka.nagano.jp":true,"takagi.nagano.jp":true,"takamori.nagano.jp":true,"takayama.nagano.jp":true,"tateshina.nagano.jp":true,"tatsuno.nagano.jp":true,"togakushi.nagano.jp":true,"togura.nagano.jp":true,"tomi.nagano.jp":true,"ueda.nagano.jp":true,"wada.nagano.jp":true,"yamagata.nagano.jp":true,"yamanouchi.nagano.jp":true,"yasaka.nagano.jp":true,"yasuoka.nagano.jp":true,"chijiwa.nagasaki.jp":true,"futsu.nagasaki.jp":true,"goto.nagasaki.jp":true,"hasami.nagasaki.jp":true,"hirado.nagasaki.jp":true,"iki.nagasaki.jp":true,"isahaya.nagasaki.jp":true,"kawatana.nagasaki.jp":true,"kuchinotsu.nagasaki.jp":true,"matsuura.nagasaki.jp":true,"nagasaki.nagasaki.jp":true,"obama.nagasaki.jp":true,"omura.nagasaki.jp":true,"oseto.nagasaki.jp":true,"saikai.nagasaki.jp":true,"sasebo.nagasaki.jp":true,"seihi.nagasaki.jp":true,"shimabara.nagasaki.jp":true,"shinkamigoto.nagasaki.jp":true,"togitsu.nagasaki.jp":true,"tsushima.nagasaki.jp":true,"unzen.nagasaki.jp":true,"ando.nara.jp":true,"gose.nara.jp":true,"heguri.nara.jp":true,"higashiyoshino.nara.jp":true,"ikaruga.nara.jp":true,"ikoma.nara.jp":true,"kamikitayama.nara.jp":true,"kanmaki.nara.jp":true,"kashiba.nara.jp":true,"kashihara.nara.jp":true,"katsuragi.nara.jp":true,"kawai.nara.jp":true,"kawakami.nara.jp":true,"kawanishi.nara.jp":true,"koryo.nara.jp":true,"kurotaki.nara.jp":true,"mitsue.nara.jp":true,"miyake.nara.jp":true,"nara.nara.jp":true,"nosegawa.nara.jp":true,"oji.nara.jp":true,"ouda.nara.jp":true,"oyodo.nara.jp":true,"sakurai.nara.jp":true,"sango.nara.jp":true,"shimoichi.nara.jp":true,"shimokitayama.nara.jp":true,"shinjo.nara.jp":true,"soni.nara.jp":true,"takatori.nara.jp":true,"tawaramoto.nara.jp":true,"tenkawa.nara.jp":true,"tenri.nara.jp":true,"uda.nara.jp":true,"yamatokoriyama.nara.jp":true,"yamatotakada.nara.jp":true,"yamazoe.nara.jp":true,"yoshino.nara.jp":true,"aga.niigata.jp":true,"agano.niigata.jp":true,"gosen.niigata.jp":true,"itoigawa.niigata.jp":true,"izumozaki.niigata.jp":true,"joetsu.niigata.jp":true,"kamo.niigata.jp":true,"kariwa.niigata.jp":true,"kashiwazaki.niigata.jp":true,"minamiuonuma.niigata.jp":true,"mitsuke.niigata.jp":true,"muika.niigata.jp":true,"murakami.niigata.jp":true,"myoko.niigata.jp":true,"nagaoka.niigata.jp":true,"niigata.niigata.jp":true,"ojiya.niigata.jp":true,"omi.niigata.jp":true,"sado.niigata.jp":true,\
"sanjo.niigata.jp":true,"seiro.niigata.jp":true,"seirou.niigata.jp":true,"sekikawa.niigata.jp":true,"shibata.niigata.jp":true,"tagami.niigata.jp":true,"tainai.niigata.jp":true,"tochio.niigata.jp":true,"tokamachi.niigata.jp":true,"tsubame.niigata.jp":true,"tsunan.niigata.jp":true,"uonuma.niigata.jp":true,"yahiko.niigata.jp":true,"yoita.niigata.jp":true,"yuzawa.niigata.jp":true,"beppu.oita.jp":true,"bungoono.oita.jp":true,"bungotakada.oita.jp":true,"hasama.oita.jp":true,"hiji.oita.jp":true,"himeshima.oita.jp":true,"hita.oita.jp":true,"kamitsue.oita.jp":true,"kokonoe.oita.jp":true,"kuju.oita.jp":true,"kunisaki.oita.jp":true,"kusu.oita.jp":true,"oita.oita.jp":true,"saiki.oita.jp":true,"taketa.oita.jp":true,"tsukumi.oita.jp":true,"usa.oita.jp":true,"usuki.oita.jp":true,"yufu.oita.jp":true,"akaiwa.okayama.jp":true,"asakuchi.okayama.jp":true,"bizen.okayama.jp":true,"hayashima.okayama.jp":true,"ibara.okayama.jp":true,"kagamino.okayama.jp":true,"kasaoka.okayama.jp":true,"kibichuo.okayama.jp":true,"kumenan.okayama.jp":true,"kurashiki.okayama.jp":true,"maniwa.okayama.jp":true,"misaki.okayama.jp":true,"nagi.okayama.jp":true,"niimi.okayama.jp":true,"nishiawakura.okayama.jp":true,"okayama.okayama.jp":true,"satosho.okayama.jp":true,"setouchi.okayama.jp":true,"shinjo.okayama.jp":true,"shoo.okayama.jp":true,"soja.okayama.jp":true,"takahashi.okayama.jp":true,"tamano.okayama.jp":true,"tsuyama.okayama.jp":true,"wake.okayama.jp":true,"yakage.okayama.jp":true,"aguni.okinawa.jp":true,"ginowan.okinawa.jp":true,"ginoza.okinawa.jp":true,"gushikami.okinawa.jp":true,"haebaru.okinawa.jp":true,"higashi.okinawa.jp":true,"hirara.okinawa.jp":true,"iheya.okinawa.jp":true,"ishigaki.okinawa.jp":true,"ishikawa.okinawa.jp":true,"itoman.okinawa.jp":true,"izena.okinawa.jp":true,"kadena.okinawa.jp":true,"kin.okinawa.jp":true,"kitadaito.okinawa.jp":true,"kitanakagusuku.okinawa.jp":true,"kumejima.okinawa.jp":true,"kunigami.okinawa.jp":true,"minamidaito.okinawa.jp":true,"motobu.okinawa.jp":true,"nago.okinawa.jp":true,"naha.okinawa.jp":true,"nakagusuku.okinawa.jp":true,"nakijin.okinawa.jp":true,"nanjo.okinawa.jp":true,"nishihara.okinawa.jp":true,"ogimi.okinawa.jp":true,"okinawa.okinawa.jp":true,"onna.okinawa.jp":true,"shimoji.okinawa.jp":true,"taketomi.okinawa.jp":true,"tarama.okinawa.jp":true,"tokashiki.okinawa.jp":true,"tomigusuku.okinawa.jp":true,"tonaki.okinawa.jp":true,"urasoe.okinawa.jp":true,"uruma.okinawa.jp":true,"yaese.okinawa.jp":true,"yomitan.okinawa.jp":true,"yonabaru.okinawa.jp":true,"yonaguni.okinawa.jp":true,"zamami.okinawa.jp":true,"abeno.osaka.jp":true,"chihayaakasaka.osaka.jp":true,"chuo.osaka.jp":true,"daito.osaka.jp":true,"fujiidera.osaka.jp":true,"habikino.osaka.jp":true,"hannan.osaka.jp":true,"higashiosaka.osaka.jp":true,"higashisumiyoshi.osaka.jp":true,"higashiyodogawa.osaka.jp":true,"hirakata.osaka.jp":true,"ibaraki.osaka.jp":true,"ikeda.osaka.jp":true,"izumi.osaka.jp":true,"izumiotsu.osaka.jp":true,"izumisano.osaka.jp":true,"kadoma.osaka.jp":true,"kaizuka.osaka.jp":true,"kanan.osaka.jp":true,"kashiwara.osaka.jp":true,"katano.osaka.jp":true,"kawachinagano.osaka.jp":true,"kishiwada.osaka.jp":true,"kita.osaka.jp":true,"kumatori.osaka.jp":true,"matsubara.osaka.jp":true,"minato.osaka.jp":true,"minoh.osaka.jp":true,"misaki.osaka.jp":true,"moriguchi.osaka.jp":true,"neyagawa.osaka.jp":true,"nishi.osaka.jp":true,"nose.osaka.jp":true,"osakasayama.osaka.jp":true,"sakai.osaka.jp":true,"sayama.osaka.jp":true,"sennan.osaka.jp":true,"settsu.osaka.jp":true,"shijonawate.osaka.jp":true,"shimamoto.osaka.jp":true,"suita.osaka.jp":true,"tadaoka.osaka.jp":true,"taishi.osaka.jp":true,"tajiri.osaka.jp":true,"takaishi.osaka.jp":true,"takatsuki.osaka.jp":true,"tondabayashi.osaka.jp":true,"toyonaka.osaka.jp":true,"toyono.osaka.jp":true,"yao.osaka.jp":true,"ariake.saga.jp":true,"arita.saga.jp":true,"fukudomi.saga.jp":true,"genkai.saga.jp":true,"hamatama.saga.jp":true,"hizen.saga.jp":true,"imari.saga.jp":true,"kamimine.saga.jp":true,"kanzaki.saga.jp":true,\
"karatsu.saga.jp":true,"kashima.saga.jp":true,"kitagata.saga.jp":true,"kitahata.saga.jp":true,"kiyama.saga.jp":true,"kouhoku.saga.jp":true,"kyuragi.saga.jp":true,"nishiarita.saga.jp":true,"ogi.saga.jp":true,"omachi.saga.jp":true,"ouchi.saga.jp":true,"saga.saga.jp":true,"shiroishi.saga.jp":true,"taku.saga.jp":true,"tara.saga.jp":true,"tosu.saga.jp":true,"yoshinogari.saga.jp":true,"arakawa.saitama.jp":true,"asaka.saitama.jp":true,"chichibu.saitama.jp":true,"fujimi.saitama.jp":true,"fujimino.saitama.jp":true,"fukaya.saitama.jp":true,"hanno.saitama.jp":true,"hanyu.saitama.jp":true,"hasuda.saitama.jp":true,"hatogaya.saitama.jp":true,"hatoyama.saitama.jp":true,"hidaka.saitama.jp":true,"higashichichibu.saitama.jp":true,"higashimatsuyama.saitama.jp":true,"honjo.saitama.jp":true,"ina.saitama.jp":true,"iruma.saitama.jp":true,"iwatsuki.saitama.jp":true,"kamiizumi.saitama.jp":true,"kamikawa.saitama.jp":true,"kamisato.saitama.jp":true,"kasukabe.saitama.jp":true,"kawagoe.saitama.jp":true,"kawaguchi.saitama.jp":true,"kawajima.saitama.jp":true,"kazo.saitama.jp":true,"kitamoto.saitama.jp":true,"koshigaya.saitama.jp":true,"kounosu.saitama.jp":true,"kuki.saitama.jp":true,"kumagaya.saitama.jp":true,"matsubushi.saitama.jp":true,"minano.saitama.jp":true,"misato.saitama.jp":true,"miyashiro.saitama.jp":true,"miyoshi.saitama.jp":true,"moroyama.saitama.jp":true,"nagatoro.saitama.jp":true,"namegawa.saitama.jp":true,"niiza.saitama.jp":true,"ogano.saitama.jp":true,"ogawa.saitama.jp":true,"ogose.saitama.jp":true,"okegawa.saitama.jp":true,"omiya.saitama.jp":true,"otaki.saitama.jp":true,"ranzan.saitama.jp":true,"ryokami.saitama.jp":true,"saitama.saitama.jp":true,"sakado.saitama.jp":true,"satte.saitama.jp":true,"sayama.saitama.jp":true,"shiki.saitama.jp":true,"shiraoka.saitama.jp":true,"soka.saitama.jp":true,"sugito.saitama.jp":true,"toda.saitama.jp":true,"tokigawa.saitama.jp":true,"tokorozawa.saitama.jp":true,"tsurugashima.saitama.jp":true,"urawa.saitama.jp":true,"warabi.saitama.jp":true,"yashio.saitama.jp":true,"yokoze.saitama.jp":true,"yono.saitama.jp":true,"yorii.saitama.jp":true,"yoshida.saitama.jp":true,"yoshikawa.saitama.jp":true,"yoshimi.saitama.jp":true,"aisho.shiga.jp":true,"gamo.shiga.jp":true,"higashiomi.shiga.jp":true,"hikone.shiga.jp":true,"koka.shiga.jp":true,"konan.shiga.jp":true,"kosei.shiga.jp":true,"koto.shiga.jp":true,"kusatsu.shiga.jp":true,"maibara.shiga.jp":true,"moriyama.shiga.jp":true,"nagahama.shiga.jp":true,"nishiazai.shiga.jp":true,"notogawa.shiga.jp":true,"omihachiman.shiga.jp":true,"otsu.shiga.jp":true,"ritto.shiga.jp":true,"ryuoh.shiga.jp":true,"takashima.shiga.jp":true,"takatsuki.shiga.jp":true,"torahime.shiga.jp":true,"toyosato.shiga.jp":true,"yasu.shiga.jp":true,"akagi.shimane.jp":true,"ama.shimane.jp":true,"gotsu.shimane.jp":true,"hamada.shimane.jp":true,"higashiizumo.shimane.jp":true,"hikawa.shimane.jp":true,"hikimi.shimane.jp":true,"izumo.shimane.jp":true,"kakinoki.shimane.jp":true,"masuda.shimane.jp":true,"matsue.shimane.jp":true,"misato.shimane.jp":true,"nishinoshima.shimane.jp":true,"ohda.shimane.jp":true,"okinoshima.shimane.jp":true,"okuizumo.shimane.jp":true,"shimane.shimane.jp":true,"tamayu.shimane.jp":true,"tsuwano.shimane.jp":true,"unnan.shimane.jp":true,"yakumo.shimane.jp":true,"yasugi.shimane.jp":true,"yatsuka.shimane.jp":true,"arai.shizuoka.jp":true,"atami.shizuoka.jp":true,"fuji.shizuoka.jp":true,"fujieda.shizuoka.jp":true,"fujikawa.shizuoka.jp":true,"fujinomiya.shizuoka.jp":true,"fukuroi.shizuoka.jp":true,"gotemba.shizuoka.jp":true,"haibara.shizuoka.jp":true,"hamamatsu.shizuoka.jp":true,"higashiizu.shizuoka.jp":true,"ito.shizuoka.jp":true,"iwata.shizuoka.jp":true,"izu.shizuoka.jp":true,"izunokuni.shizuoka.jp":true,"kakegawa.shizuoka.jp":true,"kannami.shizuoka.jp":true,"kawanehon.shizuoka.jp":true,"kawazu.shizuoka.jp":true,"kikugawa.shizuoka.jp":true,"kosai.shizuoka.jp":true,"makinohara.shizuoka.jp":true,"matsuzaki.shizuoka.jp":true,"minamiizu.shizuoka.jp":true,"mishima.shizuoka.jp":true,\
"morimachi.shizuoka.jp":true,"nishiizu.shizuoka.jp":true,"numazu.shizuoka.jp":true,"omaezaki.shizuoka.jp":true,"shimada.shizuoka.jp":true,"shimizu.shizuoka.jp":true,"shimoda.shizuoka.jp":true,"shizuoka.shizuoka.jp":true,"susono.shizuoka.jp":true,"yaizu.shizuoka.jp":true,"yoshida.shizuoka.jp":true,"ashikaga.tochigi.jp":true,"bato.tochigi.jp":true,"haga.tochigi.jp":true,"ichikai.tochigi.jp":true,"iwafune.tochigi.jp":true,"kaminokawa.tochigi.jp":true,"kanuma.tochigi.jp":true,"karasuyama.tochigi.jp":true,"kuroiso.tochigi.jp":true,"mashiko.tochigi.jp":true,"mibu.tochigi.jp":true,"moka.tochigi.jp":true,"motegi.tochigi.jp":true,"nasu.tochigi.jp":true,"nasushiobara.tochigi.jp":true,"nikko.tochigi.jp":true,"nishikata.tochigi.jp":true,"nogi.tochigi.jp":true,"ohira.tochigi.jp":true,"ohtawara.tochigi.jp":true,"oyama.tochigi.jp":true,"sakura.tochigi.jp":true,"sano.tochigi.jp":true,"shimotsuke.tochigi.jp":true,"shioya.tochigi.jp":true,"takanezawa.tochigi.jp":true,"tochigi.tochigi.jp":true,"tsuga.tochigi.jp":true,"ujiie.tochigi.jp":true,"utsunomiya.tochigi.jp":true,"yaita.tochigi.jp":true,"aizumi.tokushima.jp":true,"anan.tokushima.jp":true,"ichiba.tokushima.jp":true,"itano.tokushima.jp":true,"kainan.tokushima.jp":true,"komatsushima.tokushima.jp":true,"matsushige.tokushima.jp":true,"mima.tokushima.jp":true,"minami.tokushima.jp":true,"miyoshi.tokushima.jp":true,"mugi.tokushima.jp":true,"nakagawa.tokushima.jp":true,"naruto.tokushima.jp":true,"sanagochi.tokushima.jp":true,"shishikui.tokushima.jp":true,"tokushima.tokushima.jp":true,"wajiki.tokushima.jp":true,"adachi.tokyo.jp":true,"akiruno.tokyo.jp":true,"akishima.tokyo.jp":true,"aogashima.tokyo.jp":true,"arakawa.tokyo.jp":true,"bunkyo.tokyo.jp":true,"chiyoda.tokyo.jp":true,"chofu.tokyo.jp":true,"chuo.tokyo.jp":true,"edogawa.tokyo.jp":true,"fuchu.tokyo.jp":true,"fussa.tokyo.jp":true,"hachijo.tokyo.jp":true,"hachioji.tokyo.jp":true,"hamura.tokyo.jp":true,"higashikurume.tokyo.jp":true,"higashimurayama.tokyo.jp":true,"higashiyamato.tokyo.jp":true,"hino.tokyo.jp":true,"hinode.tokyo.jp":true,"hinohara.tokyo.jp":true,"inagi.tokyo.jp":true,"itabashi.tokyo.jp":true,"katsushika.tokyo.jp":true,"kita.tokyo.jp":true,"kiyose.tokyo.jp":true,"kodaira.tokyo.jp":true,"koganei.tokyo.jp":true,"kokubunji.tokyo.jp":true,"komae.tokyo.jp":true,"koto.tokyo.jp":true,"kouzushima.tokyo.jp":true,"kunitachi.tokyo.jp":true,"machida.tokyo.jp":true,"meguro.tokyo.jp":true,"minato.tokyo.jp":true,"mitaka.tokyo.jp":true,"mizuho.tokyo.jp":true,"musashimurayama.tokyo.jp":true,"musashino.tokyo.jp":true,"nakano.tokyo.jp":true,"nerima.tokyo.jp":true,"ogasawara.tokyo.jp":true,"okutama.tokyo.jp":true,"ome.tokyo.jp":true,"oshima.tokyo.jp":true,"ota.tokyo.jp":true,"setagaya.tokyo.jp":true,"shibuya.tokyo.jp":true,"shinagawa.tokyo.jp":true,"shinjuku.tokyo.jp":true,"suginami.tokyo.jp":true,"sumida.tokyo.jp":true,"tachikawa.tokyo.jp":true,"taito.tokyo.jp":true,"tama.tokyo.jp":true,"toshima.tokyo.jp":true,"chizu.tottori.jp":true,"hino.tottori.jp":true,"kawahara.tottori.jp":true,"koge.tottori.jp":true,"kotoura.tottori.jp":true,"misasa.tottori.jp":true,"nanbu.tottori.jp":true,"nichinan.tottori.jp":true,"sakaiminato.tottori.jp":true,"tottori.tottori.jp":true,"wakasa.tottori.jp":true,"yazu.tottori.jp":true,"yonago.tottori.jp":true,"asahi.toyama.jp":true,"fuchu.toyama.jp":true,"fukumitsu.toyama.jp":true,"funahashi.toyama.jp":true,"himi.toyama.jp":true,"imizu.toyama.jp":true,"inami.toyama.jp":true,"johana.toyama.jp":true,"kamiichi.toyama.jp":true,"kurobe.toyama.jp":true,"nakaniikawa.toyama.jp":true,"namerikawa.toyama.jp":true,"nanto.toyama.jp":true,"nyuzen.toyama.jp":true,"oyabe.toyama.jp":true,"taira.toyama.jp":true,"takaoka.toyama.jp":true,"tateyama.toyama.jp":true,"toga.toyama.jp":true,"tonami.toyama.jp":true,"toyama.toyama.jp":true,"unazuki.toyama.jp":true,"uozu.toyama.jp":true,"yamada.toyama.jp":true,"arida.wakayama.jp":true,"aridagawa.wakayama.jp":true,"gobo.wakayama.jp":true,"hashimoto.wakayama.jp":true,"hidaka.wakayama.jp":true,\
"hirogawa.wakayama.jp":true,"inami.wakayama.jp":true,"iwade.wakayama.jp":true,"kainan.wakayama.jp":true,"kamitonda.wakayama.jp":true,"katsuragi.wakayama.jp":true,"kimino.wakayama.jp":true,"kinokawa.wakayama.jp":true,"kitayama.wakayama.jp":true,"koya.wakayama.jp":true,"koza.wakayama.jp":true,"kozagawa.wakayama.jp":true,"kudoyama.wakayama.jp":true,"kushimoto.wakayama.jp":true,"mihama.wakayama.jp":true,"misato.wakayama.jp":true,"nachikatsuura.wakayama.jp":true,"shingu.wakayama.jp":true,"shirahama.wakayama.jp":true,"taiji.wakayama.jp":true,"tanabe.wakayama.jp":true,"wakayama.wakayama.jp":true,"yuasa.wakayama.jp":true,"yura.wakayama.jp":true,"asahi.yamagata.jp":true,"funagata.yamagata.jp":true,"higashine.yamagata.jp":true,"iide.yamagata.jp":true,"kahoku.yamagata.jp":true,"kaminoyama.yamagata.jp":true,"kaneyama.yamagata.jp":true,"kawanishi.yamagata.jp":true,"mamurogawa.yamagata.jp":true,"mikawa.yamagata.jp":true,"murayama.yamagata.jp":true,"nagai.yamagata.jp":true,"nakayama.yamagata.jp":true,"nanyo.yamagata.jp":true,"nishikawa.yamagata.jp":true,"obanazawa.yamagata.jp":true,"oe.yamagata.jp":true,"oguni.yamagata.jp":true,"ohkura.yamagata.jp":true,"oishida.yamagata.jp":true,"sagae.yamagata.jp":true,"sakata.yamagata.jp":true,"sakegawa.yamagata.jp":true,"shinjo.yamagata.jp":true,"shirataka.yamagata.jp":true,"shonai.yamagata.jp":true,"takahata.yamagata.jp":true,"tendo.yamagata.jp":true,"tozawa.yamagata.jp":true,"tsuruoka.yamagata.jp":true,"yamagata.yamagata.jp":true,"yamanobe.yamagata.jp":true,"yonezawa.yamagata.jp":true,"yuza.yamagata.jp":true,"abu.yamaguchi.jp":true,"hagi.yamaguchi.jp":true,"hikari.yamaguchi.jp":true,"hofu.yamaguchi.jp":true,"iwakuni.yamaguchi.jp":true,"kudamatsu.yamaguchi.jp":true,"mitou.yamaguchi.jp":true,"nagato.yamaguchi.jp":true,"oshima.yamaguchi.jp":true,"shimonoseki.yamaguchi.jp":true,"shunan.yamaguchi.jp":true,"tabuse.yamaguchi.jp":true,"tokuyama.yamaguchi.jp":true,"toyota.yamaguchi.jp":true,"ube.yamaguchi.jp":true,"yuu.yamaguchi.jp":true,"chuo.yamanashi.jp":true,"doshi.yamanashi.jp":true,"fuefuki.yamanashi.jp":true,"fujikawa.yamanashi.jp":true,"fujikawaguchiko.yamanashi.jp":true,"fujiyoshida.yamanashi.jp":true,"hayakawa.yamanashi.jp":true,"hokuto.yamanashi.jp":true,"ichikawamisato.yamanashi.jp":true,"kai.yamanashi.jp":true,"kofu.yamanashi.jp":true,"koshu.yamanashi.jp":true,"kosuge.yamanashi.jp":true,"minami-alps.yamanashi.jp":true,"minobu.yamanashi.jp":true,"nakamichi.yamanashi.jp":true,"nanbu.yamanashi.jp":true,"narusawa.yamanashi.jp":true,"nirasaki.yamanashi.jp":true,"nishikatsura.yamanashi.jp":true,"oshino.yamanashi.jp":true,"otsuki.yamanashi.jp":true,"showa.yamanashi.jp":true,"tabayama.yamanashi.jp":true,"tsuru.yamanashi.jp":true,"uenohara.yamanashi.jp":true,"yamanakako.yamanashi.jp":true,"yamanashi.yamanashi.jp":true,"ke":true,"ac.ke":true,"co.ke":true,"go.ke":true,"info.ke":true,"me.ke":true,"mobi.ke":true,"ne.ke":true,"or.ke":true,"sc.ke":true,"kg":true,"org.kg":true,"net.kg":true,"com.kg":true,"edu.kg":true,"gov.kg":true,"mil.kg":true,"*.kh":true,"ki":true,"edu.ki":true,"biz.ki":true,"net.ki":true,"org.ki":true,"gov.ki":true,"info.ki":true,"com.ki":true,"km":true,"org.km":true,"nom.km":true,"gov.km":true,"prd.km":true,"tm.km":true,"edu.km":true,"mil.km":true,"ass.km":true,"com.km":true,"coop.km":true,"asso.km":true,"presse.km":true,"medecin.km":true,"notaires.km":true,"pharmaciens.km":true,"veterinaire.km":true,"gouv.km":true,"kn":true,"net.kn":true,"org.kn":true,"edu.kn":true,"gov.kn":true,"kp":true,"com.kp":true,"edu.kp":true,"gov.kp":true,"org.kp":true,"rep.kp":true,"tra.kp":true,"kr":true,"ac.kr":true,"co.kr":true,"es.kr":true,"go.kr":true,"hs.kr":true,"kg.kr":true,"mil.kr":true,"ms.kr":true,"ne.kr":true,"or.kr":true,"pe.kr":true,"re.kr":true,"sc.kr":true,"busan.kr":true,"chungbuk.kr":true,"chungnam.kr":true,"daegu.kr":true,"daejeon.kr":true,"gangwon.kr":true,"gwangju.kr":true,"gyeongbuk.kr":true,"gyeonggi.kr":true,"gyeongnam.kr":true,"incheon.kr":true,"jeju.kr":true,"jeonbuk.kr":true,\
"jeonnam.kr":true,"seoul.kr":true,"ulsan.kr":true,"*.kw":true,"ky":true,"edu.ky":true,"gov.ky":true,"com.ky":true,"org.ky":true,"net.ky":true,"kz":true,"org.kz":true,"edu.kz":true,"net.kz":true,"gov.kz":true,"mil.kz":true,"com.kz":true,"la":true,"int.la":true,"net.la":true,"info.la":true,"edu.la":true,"gov.la":true,"per.la":true,"com.la":true,"org.la":true,"lb":true,"com.lb":true,"edu.lb":true,"gov.lb":true,"net.lb":true,"org.lb":true,"lc":true,"com.lc":true,"net.lc":true,"co.lc":true,"org.lc":true,"edu.lc":true,"gov.lc":true,"li":true,"lk":true,"gov.lk":true,"sch.lk":true,"net.lk":true,"int.lk":true,"com.lk":true,"org.lk":true,"edu.lk":true,"ngo.lk":true,"soc.lk":true,"web.lk":true,"ltd.lk":true,"assn.lk":true,"grp.lk":true,"hotel.lk":true,"ac.lk":true,"lr":true,"com.lr":true,"edu.lr":true,"gov.lr":true,"org.lr":true,"net.lr":true,"ls":true,"co.ls":true,"org.ls":true,"lt":true,"gov.lt":true,"lu":true,"lv":true,"com.lv":true,"edu.lv":true,"gov.lv":true,"org.lv":true,"mil.lv":true,"id.lv":true,"net.lv":true,"asn.lv":true,"conf.lv":true,"ly":true,"com.ly":true,"net.ly":true,"gov.ly":true,"plc.ly":true,"edu.ly":true,"sch.ly":true,"med.ly":true,"org.ly":true,"id.ly":true,"ma":true,"co.ma":true,"net.ma":true,"gov.ma":true,"org.ma":true,"ac.ma":true,"press.ma":true,"mc":true,"tm.mc":true,"asso.mc":true,"md":true,"me":true,"co.me":true,"net.me":true,"org.me":true,"edu.me":true,"ac.me":true,"gov.me":true,"its.me":true,"priv.me":true,"mg":true,"org.mg":true,"nom.mg":true,"gov.mg":true,"prd.mg":true,"tm.mg":true,"edu.mg":true,"mil.mg":true,"com.mg":true,"co.mg":true,"mh":true,"mil":true,"mk":true,"com.mk":true,"org.mk":true,"net.mk":true,"edu.mk":true,"gov.mk":true,"inf.mk":true,"name.mk":true,"ml":true,"com.ml":true,"edu.ml":true,"gouv.ml":true,"gov.ml":true,"net.ml":true,"org.ml":true,"presse.ml":true,"*.mm":true,"mn":true,"gov.mn":true,"edu.mn":true,"org.mn":true,"mo":true,"com.mo":true,"net.mo":true,"org.mo":true,"edu.mo":true,"gov.mo":true,"mobi":true,"mp":true,"mq":true,"mr":true,"gov.mr":true,"ms":true,"com.ms":true,"edu.ms":true,"gov.ms":true,"net.ms":true,"org.ms":true,"mt":true,"com.mt":true,"edu.mt":true,"net.mt":true,"org.mt":true,"mu":true,"com.mu":true,"net.mu":true,"org.mu":true,"gov.mu":true,"ac.mu":true,"co.mu":true,"or.mu":true,"museum":true,"academy.museum":true,"agriculture.museum":true,"air.museum":true,"airguard.museum":true,"alabama.museum":true,"alaska.museum":true,"amber.museum":true,"ambulance.museum":true,"american.museum":true,"americana.museum":true,"americanantiques.museum":true,"americanart.museum":true,"amsterdam.museum":true,"and.museum":true,"annefrank.museum":true,"anthro.museum":true,"anthropology.museum":true,"antiques.museum":true,"aquarium.museum":true,"arboretum.museum":true,"archaeological.museum":true,"archaeology.museum":true,"architecture.museum":true,"art.museum":true,"artanddesign.museum":true,"artcenter.museum":true,"artdeco.museum":true,"arteducation.museum":true,"artgallery.museum":true,"arts.museum":true,"artsandcrafts.museum":true,"asmatart.museum":true,"assassination.museum":true,"assisi.museum":true,"association.museum":true,"astronomy.museum":true,"atlanta.museum":true,"austin.museum":true,"australia.museum":true,"automotive.museum":true,"aviation.museum":true,"axis.museum":true,"badajoz.museum":true,"baghdad.museum":true,"bahn.museum":true,"bale.museum":true,"baltimore.museum":true,"barcelona.museum":true,"baseball.museum":true,"basel.museum":true,"baths.museum":true,"bauern.museum":true,"beauxarts.museum":true,"beeldengeluid.museum":true,"bellevue.museum":true,"bergbau.museum":true,"berkeley.museum":true,"berlin.museum":true,"bern.museum":true,"bible.museum":true,"bilbao.museum":true,"bill.museum":true,"birdart.museum":true,"birthplace.museum":true,"bonn.museum":true,"boston.museum":true,"botanical.museum":true,"botanicalgarden.museum":true,"botanicgarden.museum":true,"botany.museum":true,"brandywinevalley.museum":true,"brasil.museum":true,"bristol.museum":true,\
"british.museum":true,"britishcolumbia.museum":true,"broadcast.museum":true,"brunel.museum":true,"brussel.museum":true,"brussels.museum":true,"bruxelles.museum":true,"building.museum":true,"burghof.museum":true,"bus.museum":true,"bushey.museum":true,"cadaques.museum":true,"california.museum":true,"cambridge.museum":true,"can.museum":true,"canada.museum":true,"capebreton.museum":true,"carrier.museum":true,"cartoonart.museum":true,"casadelamoneda.museum":true,"castle.museum":true,"castres.museum":true,"celtic.museum":true,"center.museum":true,"chattanooga.museum":true,"cheltenham.museum":true,"chesapeakebay.museum":true,"chicago.museum":true,"children.museum":true,"childrens.museum":true,"childrensgarden.museum":true,"chiropractic.museum":true,"chocolate.museum":true,"christiansburg.museum":true,"cincinnati.museum":true,"cinema.museum":true,"circus.museum":true,"civilisation.museum":true,"civilization.museum":true,"civilwar.museum":true,"clinton.museum":true,"clock.museum":true,"coal.museum":true,"coastaldefence.museum":true,"cody.museum":true,"coldwar.museum":true,"collection.museum":true,"colonialwilliamsburg.museum":true,"coloradoplateau.museum":true,"columbia.museum":true,"columbus.museum":true,"communication.museum":true,"communications.museum":true,"community.museum":true,"computer.museum":true,"computerhistory.museum":true,"xn--comunicaes-v6a2o.museum":true,"contemporary.museum":true,"contemporaryart.museum":true,"convent.museum":true,"copenhagen.museum":true,"corporation.museum":true,"xn--correios-e-telecomunicaes-ghc29a.museum":true,"corvette.museum":true,"costume.museum":true,"countryestate.museum":true,"county.museum":true,"crafts.museum":true,"cranbrook.museum":true,"creation.museum":true,"cultural.museum":true,"culturalcenter.museum":true,"culture.museum":true,"cyber.museum":true,"cymru.museum":true,"dali.museum":true,"dallas.museum":true,"database.museum":true,"ddr.museum":true,"decorativearts.museum":true,"delaware.museum":true,"delmenhorst.museum":true,"denmark.museum":true,"depot.museum":true,"design.museum":true,"detroit.museum":true,"dinosaur.museum":true,"discovery.museum":true,"dolls.museum":true,"donostia.museum":true,"durham.museum":true,"eastafrica.museum":true,"eastcoast.museum":true,"education.museum":true,"educational.museum":true,"egyptian.museum":true,"eisenbahn.museum":true,"elburg.museum":true,"elvendrell.museum":true,"embroidery.museum":true,"encyclopedic.museum":true,"england.museum":true,"entomology.museum":true,"environment.museum":true,"environmentalconservation.museum":true,"epilepsy.museum":true,"essex.museum":true,"estate.museum":true,"ethnology.museum":true,"exeter.museum":true,"exhibition.museum":true,"family.museum":true,"farm.museum":true,"farmequipment.museum":true,"farmers.museum":true,"farmstead.museum":true,"field.museum":true,"figueres.museum":true,"filatelia.museum":true,"film.museum":true,"fineart.museum":true,"finearts.museum":true,"finland.museum":true,"flanders.museum":true,"florida.museum":true,"force.museum":true,"fortmissoula.museum":true,"fortworth.museum":true,"foundation.museum":true,"francaise.museum":true,"frankfurt.museum":true,"franziskaner.museum":true,"freemasonry.museum":true,"freiburg.museum":true,"fribourg.museum":true,"frog.museum":true,"fundacio.museum":true,"furniture.museum":true,"gallery.museum":true,"garden.museum":true,"gateway.museum":true,"geelvinck.museum":true,"gemological.museum":true,"geology.museum":true,"georgia.museum":true,"giessen.museum":true,"glas.museum":true,"glass.museum":true,"gorge.museum":true,"grandrapids.museum":true,"graz.museum":true,"guernsey.museum":true,"halloffame.museum":true,"hamburg.museum":true,"handson.museum":true,"harvestcelebration.museum":true,"hawaii.museum":true,"health.museum":true,"heimatunduhren.museum":true,"hellas.museum":true,"helsinki.museum":true,"hembygdsforbund.museum":true,"heritage.museum":true,"histoire.museum":true,"historical.museum":true,"historicalsociety.museum":true,"historichouses.museum":true,\
"historisch.museum":true,"historisches.museum":true,"history.museum":true,"historyofscience.museum":true,"horology.museum":true,"house.museum":true,"humanities.museum":true,"illustration.museum":true,"imageandsound.museum":true,"indian.museum":true,"indiana.museum":true,"indianapolis.museum":true,"indianmarket.museum":true,"intelligence.museum":true,"interactive.museum":true,"iraq.museum":true,"iron.museum":true,"isleofman.museum":true,"jamison.museum":true,"jefferson.museum":true,"jerusalem.museum":true,"jewelry.museum":true,"jewish.museum":true,"jewishart.museum":true,"jfk.museum":true,"journalism.museum":true,"judaica.museum":true,"judygarland.museum":true,"juedisches.museum":true,"juif.museum":true,"karate.museum":true,"karikatur.museum":true,"kids.museum":true,"koebenhavn.museum":true,"koeln.museum":true,"kunst.museum":true,"kunstsammlung.museum":true,"kunstunddesign.museum":true,"labor.museum":true,"labour.museum":true,"lajolla.museum":true,"lancashire.museum":true,"landes.museum":true,"lans.museum":true,"xn--lns-qla.museum":true,"larsson.museum":true,"lewismiller.museum":true,"lincoln.museum":true,"linz.museum":true,"living.museum":true,"livinghistory.museum":true,"localhistory.museum":true,"london.museum":true,"losangeles.museum":true,"louvre.museum":true,"loyalist.museum":true,"lucerne.museum":true,"luxembourg.museum":true,"luzern.museum":true,"mad.museum":true,"madrid.museum":true,"mallorca.museum":true,"manchester.museum":true,"mansion.museum":true,"mansions.museum":true,"manx.museum":true,"marburg.museum":true,"maritime.museum":true,"maritimo.museum":true,"maryland.museum":true,"marylhurst.museum":true,"media.museum":true,"medical.museum":true,"medizinhistorisches.museum":true,"meeres.museum":true,"memorial.museum":true,"mesaverde.museum":true,"michigan.museum":true,"midatlantic.museum":true,"military.museum":true,"mill.museum":true,"miners.museum":true,"mining.museum":true,"minnesota.museum":true,"missile.museum":true,"missoula.museum":true,"modern.museum":true,"moma.museum":true,"money.museum":true,"monmouth.museum":true,"monticello.museum":true,"montreal.museum":true,"moscow.museum":true,"motorcycle.museum":true,"muenchen.museum":true,"muenster.museum":true,"mulhouse.museum":true,"muncie.museum":true,"museet.museum":true,"museumcenter.museum":true,"museumvereniging.museum":true,"music.museum":true,"national.museum":true,"nationalfirearms.museum":true,"nationalheritage.museum":true,"nativeamerican.museum":true,"naturalhistory.museum":true,"naturalhistorymuseum.museum":true,"naturalsciences.museum":true,"nature.museum":true,"naturhistorisches.museum":true,"natuurwetenschappen.museum":true,"naumburg.museum":true,"naval.museum":true,"nebraska.museum":true,"neues.museum":true,"newhampshire.museum":true,"newjersey.museum":true,"newmexico.museum":true,"newport.museum":true,"newspaper.museum":true,"newyork.museum":true,"niepce.museum":true,"norfolk.museum":true,"north.museum":true,"nrw.museum":true,"nuernberg.museum":true,"nuremberg.museum":true,"nyc.museum":true,"nyny.museum":true,"oceanographic.museum":true,"oceanographique.museum":true,"omaha.museum":true,"online.museum":true,"ontario.museum":true,"openair.museum":true,"oregon.museum":true,"oregontrail.museum":true,"otago.museum":true,"oxford.museum":true,"pacific.museum":true,"paderborn.museum":true,"palace.museum":true,"paleo.museum":true,"palmsprings.museum":true,"panama.museum":true,"paris.museum":true,"pasadena.museum":true,"pharmacy.museum":true,"philadelphia.museum":true,"philadelphiaarea.museum":true,"philately.museum":true,"phoenix.museum":true,"photography.museum":true,"pilots.museum":true,"pittsburgh.museum":true,"planetarium.museum":true,"plantation.museum":true,"plants.museum":true,"plaza.museum":true,"portal.museum":true,"portland.museum":true,"portlligat.museum":true,"posts-and-telecommunications.museum":true,"preservation.museum":true,"presidio.museum":true,"press.museum":true,"project.museum":true,"public.museum":true,"pubol.museum":true,\
"quebec.museum":true,"railroad.museum":true,"railway.museum":true,"research.museum":true,"resistance.museum":true,"riodejaneiro.museum":true,"rochester.museum":true,"rockart.museum":true,"roma.museum":true,"russia.museum":true,"saintlouis.museum":true,"salem.museum":true,"salvadordali.museum":true,"salzburg.museum":true,"sandiego.museum":true,"sanfrancisco.museum":true,"santabarbara.museum":true,"santacruz.museum":true,"santafe.museum":true,"saskatchewan.museum":true,"satx.museum":true,"savannahga.museum":true,"schlesisches.museum":true,"schoenbrunn.museum":true,"schokoladen.museum":true,"school.museum":true,"schweiz.museum":true,"science.museum":true,"scienceandhistory.museum":true,"scienceandindustry.museum":true,"sciencecenter.museum":true,"sciencecenters.museum":true,"science-fiction.museum":true,"sciencehistory.museum":true,"sciences.museum":true,"sciencesnaturelles.museum":true,"scotland.museum":true,"seaport.museum":true,"settlement.museum":true,"settlers.museum":true,"shell.museum":true,"sherbrooke.museum":true,"sibenik.museum":true,"silk.museum":true,"ski.museum":true,"skole.museum":true,"society.museum":true,"sologne.museum":true,"soundandvision.museum":true,"southcarolina.museum":true,"southwest.museum":true,"space.museum":true,"spy.museum":true,"square.museum":true,"stadt.museum":true,"stalbans.museum":true,"starnberg.museum":true,"state.museum":true,"stateofdelaware.museum":true,"station.museum":true,"steam.museum":true,"steiermark.museum":true,"stjohn.museum":true,"stockholm.museum":true,"stpetersburg.museum":true,"stuttgart.museum":true,"suisse.museum":true,"surgeonshall.museum":true,"surrey.museum":true,"svizzera.museum":true,"sweden.museum":true,"sydney.museum":true,"tank.museum":true,"tcm.museum":true,"technology.museum":true,"telekommunikation.museum":true,"television.museum":true,"texas.museum":true,"textile.museum":true,"theater.museum":true,"time.museum":true,"timekeeping.museum":true,"topology.museum":true,"torino.museum":true,"touch.museum":true,"town.museum":true,"transport.museum":true,"tree.museum":true,"trolley.museum":true,"trust.museum":true,"trustee.museum":true,"uhren.museum":true,"ulm.museum":true,"undersea.museum":true,"university.museum":true,"usa.museum":true,"usantiques.museum":true,"usarts.museum":true,"uscountryestate.museum":true,"usculture.museum":true,"usdecorativearts.museum":true,"usgarden.museum":true,"ushistory.museum":true,"ushuaia.museum":true,"uslivinghistory.museum":true,"utah.museum":true,"uvic.museum":true,"valley.museum":true,"vantaa.museum":true,"versailles.museum":true,"viking.museum":true,"village.museum":true,"virginia.museum":true,"virtual.museum":true,"virtuel.museum":true,"vlaanderen.museum":true,"volkenkunde.museum":true,"wales.museum":true,"wallonie.museum":true,"war.museum":true,"washingtondc.museum":true,"watchandclock.museum":true,"watch-and-clock.museum":true,"western.museum":true,"westfalen.museum":true,"whaling.museum":true,"wildlife.museum":true,"williamsburg.museum":true,"windmill.museum":true,"workshop.museum":true,"york.museum":true,"yorkshire.museum":true,"yosemite.museum":true,"youth.museum":true,"zoological.museum":true,"zoology.museum":true,"xn--9dbhblg6di.museum":true,"xn--h1aegh.museum":true,"mv":true,"aero.mv":true,"biz.mv":true,"com.mv":true,"coop.mv":true,"edu.mv":true,"gov.mv":true,"info.mv":true,"int.mv":true,"mil.mv":true,"museum.mv":true,"name.mv":true,"net.mv":true,"org.mv":true,"pro.mv":true,"mw":true,"ac.mw":true,"biz.mw":true,"co.mw":true,"com.mw":true,"coop.mw":true,"edu.mw":true,"gov.mw":true,"int.mw":true,"museum.mw":true,"net.mw":true,"org.mw":true,"mx":true,"com.mx":true,"org.mx":true,"gob.mx":true,"edu.mx":true,"net.mx":true,"my":true,"com.my":true,"net.my":true,"org.my":true,"gov.my":true,"edu.my":true,"mil.my":true,"name.my":true,"mz":true,"ac.mz":true,"adv.mz":true,"co.mz":true,"edu.mz":true,"gov.mz":true,"mil.mz":true,"net.mz":true,"org.mz":true,"na":true,"info.na":true,"pro.na":true,"name.na":true,"school.na":true,"or.na":true,\
"dr.na":true,"us.na":true,"mx.na":true,"ca.na":true,"in.na":true,"cc.na":true,"tv.na":true,"ws.na":true,"mobi.na":true,"co.na":true,"com.na":true,"org.na":true,"name":true,"nc":true,"asso.nc":true,"nom.nc":true,"ne":true,"net":true,"nf":true,"com.nf":true,"net.nf":true,"per.nf":true,"rec.nf":true,"web.nf":true,"arts.nf":true,"firm.nf":true,"info.nf":true,"other.nf":true,"store.nf":true,"ng":true,"com.ng":true,"edu.ng":true,"gov.ng":true,"i.ng":true,"mil.ng":true,"mobi.ng":true,"name.ng":true,"net.ng":true,"org.ng":true,"sch.ng":true,"ni":true,"ac.ni":true,"biz.ni":true,"co.ni":true,"com.ni":true,"edu.ni":true,"gob.ni":true,"in.ni":true,"info.ni":true,"int.ni":true,"mil.ni":true,"net.ni":true,"nom.ni":true,"org.ni":true,"web.ni":true,"nl":true,"bv.nl":true,"no":true,"fhs.no":true,"vgs.no":true,"fylkesbibl.no":true,"folkebibl.no":true,"museum.no":true,"idrett.no":true,"priv.no":true,"mil.no":true,"stat.no":true,"dep.no":true,"kommune.no":true,"herad.no":true,"aa.no":true,"ah.no":true,"bu.no":true,"fm.no":true,"hl.no":true,"hm.no":true,"jan-mayen.no":true,"mr.no":true,"nl.no":true,"nt.no":true,"of.no":true,"ol.no":true,"oslo.no":true,"rl.no":true,"sf.no":true,"st.no":true,"svalbard.no":true,"tm.no":true,"tr.no":true,"va.no":true,"vf.no":true,"gs.aa.no":true,"gs.ah.no":true,"gs.bu.no":true,"gs.fm.no":true,"gs.hl.no":true,"gs.hm.no":true,"gs.jan-mayen.no":true,"gs.mr.no":true,"gs.nl.no":true,"gs.nt.no":true,"gs.of.no":true,"gs.ol.no":true,"gs.oslo.no":true,"gs.rl.no":true,"gs.sf.no":true,"gs.st.no":true,"gs.svalbard.no":true,"gs.tm.no":true,"gs.tr.no":true,"gs.va.no":true,"gs.vf.no":true,"akrehamn.no":true,"xn--krehamn-dxa.no":true,"algard.no":true,"xn--lgrd-poac.no":true,"arna.no":true,"brumunddal.no":true,"bryne.no":true,"bronnoysund.no":true,"xn--brnnysund-m8ac.no":true,"drobak.no":true,"xn--drbak-wua.no":true,"egersund.no":true,"fetsund.no":true,"floro.no":true,"xn--flor-jra.no":true,"fredrikstad.no":true,"hokksund.no":true,"honefoss.no":true,"xn--hnefoss-q1a.no":true,"jessheim.no":true,"jorpeland.no":true,"xn--jrpeland-54a.no":true,"kirkenes.no":true,"kopervik.no":true,"krokstadelva.no":true,"langevag.no":true,"xn--langevg-jxa.no":true,"leirvik.no":true,"mjondalen.no":true,"xn--mjndalen-64a.no":true,"mo-i-rana.no":true,"mosjoen.no":true,"xn--mosjen-eya.no":true,"nesoddtangen.no":true,"orkanger.no":true,"osoyro.no":true,"xn--osyro-wua.no":true,"raholt.no":true,"xn--rholt-mra.no":true,"sandnessjoen.no":true,"xn--sandnessjen-ogb.no":true,"skedsmokorset.no":true,"slattum.no":true,"spjelkavik.no":true,"stathelle.no":true,"stavern.no":true,"stjordalshalsen.no":true,"xn--stjrdalshalsen-sqb.no":true,"tananger.no":true,"tranby.no":true,"vossevangen.no":true,"afjord.no":true,"xn--fjord-lra.no":true,"agdenes.no":true,"al.no":true,"xn--l-1fa.no":true,"alesund.no":true,"xn--lesund-hua.no":true,"alstahaug.no":true,"alta.no":true,"xn--lt-liac.no":true,"alaheadju.no":true,"xn--laheadju-7ya.no":true,"alvdal.no":true,"amli.no":true,"xn--mli-tla.no":true,"amot.no":true,"xn--mot-tla.no":true,"andebu.no":true,"andoy.no":true,"xn--andy-ira.no":true,"andasuolo.no":true,"ardal.no":true,"xn--rdal-poa.no":true,"aremark.no":true,"arendal.no":true,"xn--s-1fa.no":true,"aseral.no":true,"xn--seral-lra.no":true,"asker.no":true,"askim.no":true,"askvoll.no":true,"askoy.no":true,"xn--asky-ira.no":true,"asnes.no":true,"xn--snes-poa.no":true,"audnedaln.no":true,"aukra.no":true,"aure.no":true,"aurland.no":true,"aurskog-holand.no":true,"xn--aurskog-hland-jnb.no":true,"austevoll.no":true,"austrheim.no":true,"averoy.no":true,"xn--avery-yua.no":true,"balestrand.no":true,"ballangen.no":true,"balat.no":true,"xn--blt-elab.no":true,"balsfjord.no":true,"bahccavuotna.no":true,"xn--bhccavuotna-k7a.no":true,"bamble.no":true,"bardu.no":true,"beardu.no":true,"beiarn.no":true,"bajddar.no":true,"xn--bjddar-pta.no":true,"baidar.no":true,"xn--bidr-5nac.no":true,"berg.no":true,"bergen.no":true,"berlevag.no":true,"xn--berlevg-jxa.no":true,"bearalvahki.no":true,\
"xn--bearalvhki-y4a.no":true,"bindal.no":true,"birkenes.no":true,"bjarkoy.no":true,"xn--bjarky-fya.no":true,"bjerkreim.no":true,"bjugn.no":true,"bodo.no":true,"xn--bod-2na.no":true,"badaddja.no":true,"xn--bdddj-mrabd.no":true,"budejju.no":true,"bokn.no":true,"bremanger.no":true,"bronnoy.no":true,"xn--brnny-wuac.no":true,"bygland.no":true,"bykle.no":true,"barum.no":true,"xn--brum-voa.no":true,"bo.telemark.no":true,"xn--b-5ga.telemark.no":true,"bo.nordland.no":true,"xn--b-5ga.nordland.no":true,"bievat.no":true,"xn--bievt-0qa.no":true,"bomlo.no":true,"xn--bmlo-gra.no":true,"batsfjord.no":true,"xn--btsfjord-9za.no":true,"bahcavuotna.no":true,"xn--bhcavuotna-s4a.no":true,"dovre.no":true,"drammen.no":true,"drangedal.no":true,"dyroy.no":true,"xn--dyry-ira.no":true,"donna.no":true,"xn--dnna-gra.no":true,"eid.no":true,"eidfjord.no":true,"eidsberg.no":true,"eidskog.no":true,"eidsvoll.no":true,"eigersund.no":true,"elverum.no":true,"enebakk.no":true,"engerdal.no":true,"etne.no":true,"etnedal.no":true,"evenes.no":true,"evenassi.no":true,"xn--eveni-0qa01ga.no":true,"evje-og-hornnes.no":true,"farsund.no":true,"fauske.no":true,"fuossko.no":true,"fuoisku.no":true,"fedje.no":true,"fet.no":true,"finnoy.no":true,"xn--finny-yua.no":true,"fitjar.no":true,"fjaler.no":true,"fjell.no":true,"flakstad.no":true,"flatanger.no":true,"flekkefjord.no":true,"flesberg.no":true,"flora.no":true,"fla.no":true,"xn--fl-zia.no":true,"folldal.no":true,"forsand.no":true,"fosnes.no":true,"frei.no":true,"frogn.no":true,"froland.no":true,"frosta.no":true,"frana.no":true,"xn--frna-woa.no":true,"froya.no":true,"xn--frya-hra.no":true,"fusa.no":true,"fyresdal.no":true,"forde.no":true,"xn--frde-gra.no":true,"gamvik.no":true,"gangaviika.no":true,"xn--ggaviika-8ya47h.no":true,"gaular.no":true,"gausdal.no":true,"gildeskal.no":true,"xn--gildeskl-g0a.no":true,"giske.no":true,"gjemnes.no":true,"gjerdrum.no":true,"gjerstad.no":true,"gjesdal.no":true,"gjovik.no":true,"xn--gjvik-wua.no":true,"gloppen.no":true,"gol.no":true,"gran.no":true,"grane.no":true,"granvin.no":true,"gratangen.no":true,"grimstad.no":true,"grong.no":true,"kraanghke.no":true,"xn--kranghke-b0a.no":true,"grue.no":true,"gulen.no":true,"hadsel.no":true,"halden.no":true,"halsa.no":true,"hamar.no":true,"hamaroy.no":true,"habmer.no":true,"xn--hbmer-xqa.no":true,"hapmir.no":true,"xn--hpmir-xqa.no":true,"hammerfest.no":true,"hammarfeasta.no":true,"xn--hmmrfeasta-s4ac.no":true,"haram.no":true,"hareid.no":true,"harstad.no":true,"hasvik.no":true,"aknoluokta.no":true,"xn--koluokta-7ya57h.no":true,"hattfjelldal.no":true,"aarborte.no":true,"haugesund.no":true,"hemne.no":true,"hemnes.no":true,"hemsedal.no":true,"heroy.more-og-romsdal.no":true,"xn--hery-ira.xn--mre-og-romsdal-qqb.no":true,"heroy.nordland.no":true,"xn--hery-ira.nordland.no":true,"hitra.no":true,"hjartdal.no":true,"hjelmeland.no":true,"hobol.no":true,"xn--hobl-ira.no":true,"hof.no":true,"hol.no":true,"hole.no":true,"holmestrand.no":true,"holtalen.no":true,"xn--holtlen-hxa.no":true,"hornindal.no":true,"horten.no":true,"hurdal.no":true,"hurum.no":true,"hvaler.no":true,"hyllestad.no":true,"hagebostad.no":true,"xn--hgebostad-g3a.no":true,"hoyanger.no":true,"xn--hyanger-q1a.no":true,"hoylandet.no":true,"xn--hylandet-54a.no":true,"ha.no":true,"xn--h-2fa.no":true,"ibestad.no":true,"inderoy.no":true,"xn--indery-fya.no":true,"iveland.no":true,"jevnaker.no":true,"jondal.no":true,"jolster.no":true,"xn--jlster-bya.no":true,"karasjok.no":true,"karasjohka.no":true,"xn--krjohka-hwab49j.no":true,"karlsoy.no":true,"galsa.no":true,"xn--gls-elac.no":true,"karmoy.no":true,"xn--karmy-yua.no":true,"kautokeino.no":true,"guovdageaidnu.no":true,"klepp.no":true,"klabu.no":true,"xn--klbu-woa.no":true,"kongsberg.no":true,"kongsvinger.no":true,"kragero.no":true,"xn--krager-gya.no":true,"kristiansand.no":true,"kristiansund.no":true,"krodsherad.no":true,"xn--krdsherad-m8a.no":true,"kvalsund.no":true,"rahkkeravju.no":true,"xn--rhkkervju-01af.no":true,"kvam.no":true,"kvinesdal.no":true,\
"kvinnherad.no":true,"kviteseid.no":true,"kvitsoy.no":true,"xn--kvitsy-fya.no":true,"kvafjord.no":true,"xn--kvfjord-nxa.no":true,"giehtavuoatna.no":true,"kvanangen.no":true,"xn--kvnangen-k0a.no":true,"navuotna.no":true,"xn--nvuotna-hwa.no":true,"kafjord.no":true,"xn--kfjord-iua.no":true,"gaivuotna.no":true,"xn--givuotna-8ya.no":true,"larvik.no":true,"lavangen.no":true,"lavagis.no":true,"loabat.no":true,"xn--loabt-0qa.no":true,"lebesby.no":true,"davvesiida.no":true,"leikanger.no":true,"leirfjord.no":true,"leka.no":true,"leksvik.no":true,"lenvik.no":true,"leangaviika.no":true,"xn--leagaviika-52b.no":true,"lesja.no":true,"levanger.no":true,"lier.no":true,"lierne.no":true,"lillehammer.no":true,"lillesand.no":true,"lindesnes.no":true,"lindas.no":true,"xn--linds-pra.no":true,"lom.no":true,"loppa.no":true,"lahppi.no":true,"xn--lhppi-xqa.no":true,"lund.no":true,"lunner.no":true,"luroy.no":true,"xn--lury-ira.no":true,"luster.no":true,"lyngdal.no":true,"lyngen.no":true,"ivgu.no":true,"lardal.no":true,"lerdal.no":true,"xn--lrdal-sra.no":true,"lodingen.no":true,"xn--ldingen-q1a.no":true,"lorenskog.no":true,"xn--lrenskog-54a.no":true,"loten.no":true,"xn--lten-gra.no":true,"malvik.no":true,"masoy.no":true,"xn--msy-ula0h.no":true,"muosat.no":true,"xn--muost-0qa.no":true,"mandal.no":true,"marker.no":true,"marnardal.no":true,"masfjorden.no":true,"meland.no":true,"meldal.no":true,"melhus.no":true,"meloy.no":true,"xn--mely-ira.no":true,"meraker.no":true,"xn--merker-kua.no":true,"moareke.no":true,"xn--moreke-jua.no":true,"midsund.no":true,"midtre-gauldal.no":true,"modalen.no":true,"modum.no":true,"molde.no":true,"moskenes.no":true,"moss.no":true,"mosvik.no":true,"malselv.no":true,"xn--mlselv-iua.no":true,"malatvuopmi.no":true,"xn--mlatvuopmi-s4a.no":true,"namdalseid.no":true,"aejrie.no":true,"namsos.no":true,"namsskogan.no":true,"naamesjevuemie.no":true,"xn--nmesjevuemie-tcba.no":true,"laakesvuemie.no":true,"nannestad.no":true,"narvik.no":true,"narviika.no":true,"naustdal.no":true,"nedre-eiker.no":true,"nes.akershus.no":true,"nes.buskerud.no":true,"nesna.no":true,"nesodden.no":true,"nesseby.no":true,"unjarga.no":true,"xn--unjrga-rta.no":true,"nesset.no":true,"nissedal.no":true,"nittedal.no":true,"nord-aurdal.no":true,"nord-fron.no":true,"nord-odal.no":true,"norddal.no":true,"nordkapp.no":true,"davvenjarga.no":true,"xn--davvenjrga-y4a.no":true,"nordre-land.no":true,"nordreisa.no":true,"raisa.no":true,"xn--risa-5na.no":true,"nore-og-uvdal.no":true,"notodden.no":true,"naroy.no":true,"xn--nry-yla5g.no":true,"notteroy.no":true,"xn--nttery-byae.no":true,"odda.no":true,"oksnes.no":true,"xn--ksnes-uua.no":true,"oppdal.no":true,"oppegard.no":true,"xn--oppegrd-ixa.no":true,"orkdal.no":true,"orland.no":true,"xn--rland-uua.no":true,"orskog.no":true,"xn--rskog-uua.no":true,"orsta.no":true,"xn--rsta-fra.no":true,"os.hedmark.no":true,"os.hordaland.no":true,"osen.no":true,"osteroy.no":true,"xn--ostery-fya.no":true,"ostre-toten.no":true,"xn--stre-toten-zcb.no":true,"overhalla.no":true,"ovre-eiker.no":true,"xn--vre-eiker-k8a.no":true,"oyer.no":true,"xn--yer-zna.no":true,"oygarden.no":true,"xn--ygarden-p1a.no":true,"oystre-slidre.no":true,"xn--ystre-slidre-ujb.no":true,"porsanger.no":true,"porsangu.no":true,"xn--porsgu-sta26f.no":true,"porsgrunn.no":true,"radoy.no":true,"xn--rady-ira.no":true,"rakkestad.no":true,"rana.no":true,"ruovat.no":true,"randaberg.no":true,"rauma.no":true,"rendalen.no":true,"rennebu.no":true,"rennesoy.no":true,"xn--rennesy-v1a.no":true,"rindal.no":true,"ringebu.no":true,"ringerike.no":true,"ringsaker.no":true,"rissa.no":true,"risor.no":true,"xn--risr-ira.no":true,"roan.no":true,"rollag.no":true,"rygge.no":true,"ralingen.no":true,"xn--rlingen-mxa.no":true,"rodoy.no":true,"xn--rdy-0nab.no":true,"romskog.no":true,"xn--rmskog-bya.no":true,"roros.no":true,"xn--rros-gra.no":true,"rost.no":true,"xn--rst-0na.no":true,"royken.no":true,"xn--ryken-vua.no":true,"royrvik.no":true,"xn--ryrvik-bya.no":true,"rade.no":true,"xn--rde-ula.no":true,\
"salangen.no":true,"siellak.no":true,"saltdal.no":true,"salat.no":true,"xn--slt-elab.no":true,"xn--slat-5na.no":true,"samnanger.no":true,"sande.more-og-romsdal.no":true,"sande.xn--mre-og-romsdal-qqb.no":true,"sande.vestfold.no":true,"sandefjord.no":true,"sandnes.no":true,"sandoy.no":true,"xn--sandy-yua.no":true,"sarpsborg.no":true,"sauda.no":true,"sauherad.no":true,"sel.no":true,"selbu.no":true,"selje.no":true,"seljord.no":true,"sigdal.no":true,"siljan.no":true,"sirdal.no":true,"skaun.no":true,"skedsmo.no":true,"ski.no":true,"skien.no":true,"skiptvet.no":true,"skjervoy.no":true,"xn--skjervy-v1a.no":true,"skierva.no":true,"xn--skierv-uta.no":true,"skjak.no":true,"xn--skjk-soa.no":true,"skodje.no":true,"skanland.no":true,"xn--sknland-fxa.no":true,"skanit.no":true,"xn--sknit-yqa.no":true,"smola.no":true,"xn--smla-hra.no":true,"snillfjord.no":true,"snasa.no":true,"xn--snsa-roa.no":true,"snoasa.no":true,"snaase.no":true,"xn--snase-nra.no":true,"sogndal.no":true,"sokndal.no":true,"sola.no":true,"solund.no":true,"songdalen.no":true,"sortland.no":true,"spydeberg.no":true,"stange.no":true,"stavanger.no":true,"steigen.no":true,"steinkjer.no":true,"stjordal.no":true,"xn--stjrdal-s1a.no":true,"stokke.no":true,"stor-elvdal.no":true,"stord.no":true,"stordal.no":true,"storfjord.no":true,"omasvuotna.no":true,"strand.no":true,"stranda.no":true,"stryn.no":true,"sula.no":true,"suldal.no":true,"sund.no":true,"sunndal.no":true,"surnadal.no":true,"sveio.no":true,"svelvik.no":true,"sykkylven.no":true,"sogne.no":true,"xn--sgne-gra.no":true,"somna.no":true,"xn--smna-gra.no":true,"sondre-land.no":true,"xn--sndre-land-0cb.no":true,"sor-aurdal.no":true,"xn--sr-aurdal-l8a.no":true,"sor-fron.no":true,"xn--sr-fron-q1a.no":true,"sor-odal.no":true,"xn--sr-odal-q1a.no":true,"sor-varanger.no":true,"xn--sr-varanger-ggb.no":true,"matta-varjjat.no":true,"xn--mtta-vrjjat-k7af.no":true,"sorfold.no":true,"xn--srfold-bya.no":true,"sorreisa.no":true,"xn--srreisa-q1a.no":true,"sorum.no":true,"xn--srum-gra.no":true,"tana.no":true,"deatnu.no":true,"time.no":true,"tingvoll.no":true,"tinn.no":true,"tjeldsund.no":true,"dielddanuorri.no":true,"tjome.no":true,"xn--tjme-hra.no":true,"tokke.no":true,"tolga.no":true,"torsken.no":true,"tranoy.no":true,"xn--trany-yua.no":true,"tromso.no":true,"xn--troms-zua.no":true,"tromsa.no":true,"romsa.no":true,"trondheim.no":true,"troandin.no":true,"trysil.no":true,"trana.no":true,"xn--trna-woa.no":true,"trogstad.no":true,"xn--trgstad-r1a.no":true,"tvedestrand.no":true,"tydal.no":true,"tynset.no":true,"tysfjord.no":true,"divtasvuodna.no":true,"divttasvuotna.no":true,"tysnes.no":true,"tysvar.no":true,"xn--tysvr-vra.no":true,"tonsberg.no":true,"xn--tnsberg-q1a.no":true,"ullensaker.no":true,"ullensvang.no":true,"ulvik.no":true,"utsira.no":true,"vadso.no":true,"xn--vads-jra.no":true,"cahcesuolo.no":true,"xn--hcesuolo-7ya35b.no":true,"vaksdal.no":true,"valle.no":true,"vang.no":true,"vanylven.no":true,"vardo.no":true,"xn--vard-jra.no":true,"varggat.no":true,"xn--vrggt-xqad.no":true,"vefsn.no":true,"vaapste.no":true,"vega.no":true,"vegarshei.no":true,"xn--vegrshei-c0a.no":true,"vennesla.no":true,"verdal.no":true,"verran.no":true,"vestby.no":true,"vestnes.no":true,"vestre-slidre.no":true,"vestre-toten.no":true,"vestvagoy.no":true,"xn--vestvgy-ixa6o.no":true,"vevelstad.no":true,"vik.no":true,"vikna.no":true,"vindafjord.no":true,"volda.no":true,"voss.no":true,"varoy.no":true,"xn--vry-yla5g.no":true,"vagan.no":true,"xn--vgan-qoa.no":true,"voagat.no":true,"vagsoy.no":true,"xn--vgsy-qoa0j.no":true,"vaga.no":true,"xn--vg-yiab.no":true,"valer.ostfold.no":true,"xn--vler-qoa.xn--stfold-9xa.no":true,"valer.hedmark.no":true,"xn--vler-qoa.hedmark.no":true,"*.np":true,"nr":true,"biz.nr":true,"info.nr":true,"gov.nr":true,"edu.nr":true,"org.nr":true,"net.nr":true,"com.nr":true,"nu":true,"nz":true,"ac.nz":true,"co.nz":true,"cri.nz":true,"geek.nz":true,"gen.nz":true,"govt.nz":true,"health.nz":true,"iwi.nz":true,"kiwi.nz":true,"maori.nz":true,"mil.nz":true,\
"xn--mori-qsa.nz":true,"net.nz":true,"org.nz":true,"parliament.nz":true,"school.nz":true,"om":true,"co.om":true,"com.om":true,"edu.om":true,"gov.om":true,"med.om":true,"museum.om":true,"net.om":true,"org.om":true,"pro.om":true,"onion":true,"org":true,"pa":true,"ac.pa":true,"gob.pa":true,"com.pa":true,"org.pa":true,"sld.pa":true,"edu.pa":true,"net.pa":true,"ing.pa":true,"abo.pa":true,"med.pa":true,"nom.pa":true,"pe":true,"edu.pe":true,"gob.pe":true,"nom.pe":true,"mil.pe":true,"org.pe":true,"com.pe":true,"net.pe":true,"pf":true,"com.pf":true,"org.pf":true,"edu.pf":true,"*.pg":true,"ph":true,"com.ph":true,"net.ph":true,"org.ph":true,"gov.ph":true,"edu.ph":true,"ngo.ph":true,"mil.ph":true,"i.ph":true,"pk":true,"com.pk":true,"net.pk":true,"edu.pk":true,"org.pk":true,"fam.pk":true,"biz.pk":true,"web.pk":true,"gov.pk":true,"gob.pk":true,"gok.pk":true,"gon.pk":true,"gop.pk":true,"gos.pk":true,"info.pk":true,"pl":true,"com.pl":true,"net.pl":true,"org.pl":true,"aid.pl":true,"agro.pl":true,"atm.pl":true,"auto.pl":true,"biz.pl":true,"edu.pl":true,"gmina.pl":true,"gsm.pl":true,"info.pl":true,"mail.pl":true,"miasta.pl":true,"media.pl":true,"mil.pl":true,"nieruchomosci.pl":true,"nom.pl":true,"pc.pl":true,"powiat.pl":true,"priv.pl":true,"realestate.pl":true,"rel.pl":true,"sex.pl":true,"shop.pl":true,"sklep.pl":true,"sos.pl":true,"szkola.pl":true,"targi.pl":true,"tm.pl":true,"tourism.pl":true,"travel.pl":true,"turystyka.pl":true,"gov.pl":true,"ap.gov.pl":true,"ic.gov.pl":true,"is.gov.pl":true,"us.gov.pl":true,"kmpsp.gov.pl":true,"kppsp.gov.pl":true,"kwpsp.gov.pl":true,"psp.gov.pl":true,"wskr.gov.pl":true,"kwp.gov.pl":true,"mw.gov.pl":true,"ug.gov.pl":true,"um.gov.pl":true,"umig.gov.pl":true,"ugim.gov.pl":true,"upow.gov.pl":true,"uw.gov.pl":true,"starostwo.gov.pl":true,"pa.gov.pl":true,"po.gov.pl":true,"psse.gov.pl":true,"pup.gov.pl":true,"rzgw.gov.pl":true,"sa.gov.pl":true,"so.gov.pl":true,"sr.gov.pl":true,"wsa.gov.pl":true,"sko.gov.pl":true,"uzs.gov.pl":true,"wiih.gov.pl":true,"winb.gov.pl":true,"pinb.gov.pl":true,"wios.gov.pl":true,"witd.gov.pl":true,"wzmiuw.gov.pl":true,"piw.gov.pl":true,"wiw.gov.pl":true,"griw.gov.pl":true,"wif.gov.pl":true,"oum.gov.pl":true,"sdn.gov.pl":true,"zp.gov.pl":true,"uppo.gov.pl":true,"mup.gov.pl":true,"wuoz.gov.pl":true,"konsulat.gov.pl":true,"oirm.gov.pl":true,"augustow.pl":true,"babia-gora.pl":true,"bedzin.pl":true,"beskidy.pl":true,"bialowieza.pl":true,"bialystok.pl":true,"bielawa.pl":true,"bieszczady.pl":true,"boleslawiec.pl":true,"bydgoszcz.pl":true,"bytom.pl":true,"cieszyn.pl":true,"czeladz.pl":true,"czest.pl":true,"dlugoleka.pl":true,"elblag.pl":true,"elk.pl":true,"glogow.pl":true,"gniezno.pl":true,"gorlice.pl":true,"grajewo.pl":true,"ilawa.pl":true,"jaworzno.pl":true,"jelenia-gora.pl":true,"jgora.pl":true,"kalisz.pl":true,"kazimierz-dolny.pl":true,"karpacz.pl":true,"kartuzy.pl":true,"kaszuby.pl":true,"katowice.pl":true,"kepno.pl":true,"ketrzyn.pl":true,"klodzko.pl":true,"kobierzyce.pl":true,"kolobrzeg.pl":true,"konin.pl":true,"konskowola.pl":true,"kutno.pl":true,"lapy.pl":true,"lebork.pl":true,"legnica.pl":true,"lezajsk.pl":true,"limanowa.pl":true,"lomza.pl":true,"lowicz.pl":true,"lubin.pl":true,"lukow.pl":true,"malbork.pl":true,"malopolska.pl":true,"mazowsze.pl":true,"mazury.pl":true,"mielec.pl":true,"mielno.pl":true,"mragowo.pl":true,"naklo.pl":true,"nowaruda.pl":true,"nysa.pl":true,"olawa.pl":true,"olecko.pl":true,"olkusz.pl":true,"olsztyn.pl":true,"opoczno.pl":true,"opole.pl":true,"ostroda.pl":true,"ostroleka.pl":true,"ostrowiec.pl":true,"ostrowwlkp.pl":true,"pila.pl":true,"pisz.pl":true,"podhale.pl":true,"podlasie.pl":true,"polkowice.pl":true,"pomorze.pl":true,"pomorskie.pl":true,"prochowice.pl":true,"pruszkow.pl":true,"przeworsk.pl":true,"pulawy.pl":true,"radom.pl":true,"rawa-maz.pl":true,"rybnik.pl":true,"rzeszow.pl":true,"sanok.pl":true,"sejny.pl":true,"slask.pl":true,"slupsk.pl":true,"sosnowiec.pl":true,"stalowa-wola.pl":true,"skoczow.pl":true,"starachowice.pl":true,"stargard.pl":true,\
"suwalki.pl":true,"swidnica.pl":true,"swiebodzin.pl":true,"swinoujscie.pl":true,"szczecin.pl":true,"szczytno.pl":true,"tarnobrzeg.pl":true,"tgory.pl":true,"turek.pl":true,"tychy.pl":true,"ustka.pl":true,"walbrzych.pl":true,"warmia.pl":true,"warszawa.pl":true,"waw.pl":true,"wegrow.pl":true,"wielun.pl":true,"wlocl.pl":true,"wloclawek.pl":true,"wodzislaw.pl":true,"wolomin.pl":true,"wroclaw.pl":true,"zachpomor.pl":true,"zagan.pl":true,"zarow.pl":true,"zgora.pl":true,"zgorzelec.pl":true,"pm":true,"pn":true,"gov.pn":true,"co.pn":true,"org.pn":true,"edu.pn":true,"net.pn":true,"post":true,"pr":true,"com.pr":true,"net.pr":true,"org.pr":true,"gov.pr":true,"edu.pr":true,"isla.pr":true,"pro.pr":true,"biz.pr":true,"info.pr":true,"name.pr":true,"est.pr":true,"prof.pr":true,"ac.pr":true,"pro":true,"aaa.pro":true,"aca.pro":true,"acct.pro":true,"avocat.pro":true,"bar.pro":true,"cpa.pro":true,"eng.pro":true,"jur.pro":true,"law.pro":true,"med.pro":true,"recht.pro":true,"ps":true,"edu.ps":true,"gov.ps":true,"sec.ps":true,"plo.ps":true,"com.ps":true,"org.ps":true,"net.ps":true,"pt":true,"net.pt":true,"gov.pt":true,"org.pt":true,"edu.pt":true,"int.pt":true,"publ.pt":true,"com.pt":true,"nome.pt":true,"pw":true,"co.pw":true,"ne.pw":true,"or.pw":true,"ed.pw":true,"go.pw":true,"belau.pw":true,"py":true,"com.py":true,"coop.py":true,"edu.py":true,"gov.py":true,"mil.py":true,"net.py":true,"org.py":true,"qa":true,"com.qa":true,"edu.qa":true,"gov.qa":true,"mil.qa":true,"name.qa":true,"net.qa":true,"org.qa":true,"sch.qa":true,"re":true,"asso.re":true,"com.re":true,"nom.re":true,"ro":true,"arts.ro":true,"com.ro":true,"firm.ro":true,"info.ro":true,"nom.ro":true,"nt.ro":true,"org.ro":true,"rec.ro":true,"store.ro":true,"tm.ro":true,"www.ro":true,"rs":true,"ac.rs":true,"co.rs":true,"edu.rs":true,"gov.rs":true,"in.rs":true,"org.rs":true,"ru":true,"ac.ru":true,"edu.ru":true,"gov.ru":true,"int.ru":true,"mil.ru":true,"test.ru":true,"rw":true,"gov.rw":true,"net.rw":true,"edu.rw":true,"ac.rw":true,"com.rw":true,"co.rw":true,"int.rw":true,"mil.rw":true,"gouv.rw":true,"sa":true,"com.sa":true,"net.sa":true,"org.sa":true,"gov.sa":true,"med.sa":true,"pub.sa":true,"edu.sa":true,"sch.sa":true,"sb":true,"com.sb":true,"edu.sb":true,"gov.sb":true,"net.sb":true,"org.sb":true,"sc":true,"com.sc":true,"gov.sc":true,"net.sc":true,"org.sc":true,"edu.sc":true,"sd":true,"com.sd":true,"net.sd":true,"org.sd":true,"edu.sd":true,"med.sd":true,"tv.sd":true,"gov.sd":true,"info.sd":true,"se":true,"a.se":true,"ac.se":true,"b.se":true,"bd.se":true,"brand.se":true,"c.se":true,"d.se":true,"e.se":true,"f.se":true,"fh.se":true,"fhsk.se":true,"fhv.se":true,"g.se":true,"h.se":true,"i.se":true,"k.se":true,"komforb.se":true,"kommunalforbund.se":true,"komvux.se":true,"l.se":true,"lanbib.se":true,"m.se":true,"n.se":true,"naturbruksgymn.se":true,"o.se":true,"org.se":true,"p.se":true,"parti.se":true,"pp.se":true,"press.se":true,"r.se":true,"s.se":true,"t.se":true,"tm.se":true,"u.se":true,"w.se":true,"x.se":true,"y.se":true,"z.se":true,"sg":true,"com.sg":true,"net.sg":true,"org.sg":true,"gov.sg":true,"edu.sg":true,"per.sg":true,"sh":true,"com.sh":true,"net.sh":true,"gov.sh":true,"org.sh":true,"mil.sh":true,"si":true,"sj":true,"sk":true,"sl":true,"com.sl":true,"net.sl":true,"edu.sl":true,"gov.sl":true,"org.sl":true,"sm":true,"sn":true,"art.sn":true,"com.sn":true,"edu.sn":true,"gouv.sn":true,"org.sn":true,"perso.sn":true,"univ.sn":true,"so":true,"com.so":true,"net.so":true,"org.so":true,"sr":true,"st":true,"co.st":true,"com.st":true,"consulado.st":true,"edu.st":true,"embaixada.st":true,"gov.st":true,"mil.st":true,"net.st":true,"org.st":true,"principe.st":true,"saotome.st":true,"store.st":true,"su":true,"sv":true,"com.sv":true,"edu.sv":true,"gob.sv":true,"org.sv":true,"red.sv":true,"sx":true,"gov.sx":true,"sy":true,"edu.sy":true,"gov.sy":true,"net.sy":true,"mil.sy":true,"com.sy":true,"org.sy":true,"sz":true,"co.sz":true,"ac.sz":true,"org.sz":true,"tc":true,"td":true,"tel":true,"tf":true,"tg":true,"th":true,\
"ac.th":true,"co.th":true,"go.th":true,"in.th":true,"mi.th":true,"net.th":true,"or.th":true,"tj":true,"ac.tj":true,"biz.tj":true,"co.tj":true,"com.tj":true,"edu.tj":true,"go.tj":true,"gov.tj":true,"int.tj":true,"mil.tj":true,"name.tj":true,"net.tj":true,"nic.tj":true,"org.tj":true,"test.tj":true,"web.tj":true,"tk":true,"tl":true,"gov.tl":true,"tm":true,"com.tm":true,"co.tm":true,"org.tm":true,"net.tm":true,"nom.tm":true,"gov.tm":true,"mil.tm":true,"edu.tm":true,"tn":true,"com.tn":true,"ens.tn":true,"fin.tn":true,"gov.tn":true,"ind.tn":true,"intl.tn":true,"nat.tn":true,"net.tn":true,"org.tn":true,"info.tn":true,"perso.tn":true,"tourism.tn":true,"edunet.tn":true,"rnrt.tn":true,"rns.tn":true,"rnu.tn":true,"mincom.tn":true,"agrinet.tn":true,"defense.tn":true,"turen.tn":true,"to":true,"com.to":true,"gov.to":true,"net.to":true,"org.to":true,"edu.to":true,"mil.to":true,"tr":true,"com.tr":true,"info.tr":true,"biz.tr":true,"net.tr":true,"org.tr":true,"web.tr":true,"gen.tr":true,"tv.tr":true,"av.tr":true,"dr.tr":true,"bbs.tr":true,"name.tr":true,"tel.tr":true,"gov.tr":true,"bel.tr":true,"pol.tr":true,"mil.tr":true,"k12.tr":true,"edu.tr":true,"kep.tr":true,"nc.tr":true,"gov.nc.tr":true,"travel":true,"tt":true,"co.tt":true,"com.tt":true,"org.tt":true,"net.tt":true,"biz.tt":true,"info.tt":true,"pro.tt":true,"int.tt":true,"coop.tt":true,"jobs.tt":true,"mobi.tt":true,"travel.tt":true,"museum.tt":true,"aero.tt":true,"name.tt":true,"gov.tt":true,"edu.tt":true,"tv":true,"tw":true,"edu.tw":true,"gov.tw":true,"mil.tw":true,"com.tw":true,"net.tw":true,"org.tw":true,"idv.tw":true,"game.tw":true,"ebiz.tw":true,"club.tw":true,"xn--zf0ao64a.tw":true,"xn--uc0atv.tw":true,"xn--czrw28b.tw":true,"tz":true,"ac.tz":true,"co.tz":true,"go.tz":true,"hotel.tz":true,"info.tz":true,"me.tz":true,"mil.tz":true,"mobi.tz":true,"ne.tz":true,"or.tz":true,"sc.tz":true,"tv.tz":true,"ua":true,"com.ua":true,"edu.ua":true,"gov.ua":true,"in.ua":true,"net.ua":true,"org.ua":true,"cherkassy.ua":true,"cherkasy.ua":true,"chernigov.ua":true,"chernihiv.ua":true,"chernivtsi.ua":true,"chernovtsy.ua":true,"ck.ua":true,"cn.ua":true,"cr.ua":true,"crimea.ua":true,"cv.ua":true,"dn.ua":true,"dnepropetrovsk.ua":true,"dnipropetrovsk.ua":true,"dominic.ua":true,"donetsk.ua":true,"dp.ua":true,"if.ua":true,"ivano-frankivsk.ua":true,"kh.ua":true,"kharkiv.ua":true,"kharkov.ua":true,"kherson.ua":true,"khmelnitskiy.ua":true,"khmelnytskyi.ua":true,"kiev.ua":true,"kirovograd.ua":true,"km.ua":true,"kr.ua":true,"krym.ua":true,"ks.ua":true,"kv.ua":true,"kyiv.ua":true,"lg.ua":true,"lt.ua":true,"lugansk.ua":true,"lutsk.ua":true,"lv.ua":true,"lviv.ua":true,"mk.ua":true,"mykolaiv.ua":true,"nikolaev.ua":true,"od.ua":true,"odesa.ua":true,"odessa.ua":true,"pl.ua":true,"poltava.ua":true,"rivne.ua":true,"rovno.ua":true,"rv.ua":true,"sb.ua":true,"sebastopol.ua":true,"sevastopol.ua":true,"sm.ua":true,"sumy.ua":true,"te.ua":true,"ternopil.ua":true,"uz.ua":true,"uzhgorod.ua":true,"vinnica.ua":true,"vinnytsia.ua":true,"vn.ua":true,"volyn.ua":true,"yalta.ua":true,"zaporizhzhe.ua":true,"zaporizhzhia.ua":true,"zhitomir.ua":true,"zhytomyr.ua":true,"zp.ua":true,"zt.ua":true,"ug":true,"co.ug":true,"or.ug":true,"ac.ug":true,"sc.ug":true,"go.ug":true,"ne.ug":true,"com.ug":true,"org.ug":true,"uk":true,"ac.uk":true,"co.uk":true,"gov.uk":true,"ltd.uk":true,"me.uk":true,"net.uk":true,"nhs.uk":true,"org.uk":true,"plc.uk":true,"police.uk":true,"*.sch.uk":true,"us":true,"dni.us":true,"fed.us":true,"isa.us":true,"kids.us":true,"nsn.us":true,"ak.us":true,"al.us":true,"ar.us":true,"as.us":true,"az.us":true,"ca.us":true,"co.us":true,"ct.us":true,"dc.us":true,"de.us":true,"fl.us":true,"ga.us":true,"gu.us":true,"hi.us":true,"ia.us":true,"id.us":true,"il.us":true,"in.us":true,"ks.us":true,"ky.us":true,"la.us":true,"ma.us":true,"md.us":true,"me.us":true,"mi.us":true,"mn.us":true,"mo.us":true,"ms.us":true,"mt.us":true,"nc.us":true,"nd.us":true,"ne.us":true,"nh.us":true,"nj.us":true,"nm.us":true,"nv.us":true,"ny.us":true,"oh.us":true,\
"ok.us":true,"or.us":true,"pa.us":true,"pr.us":true,"ri.us":true,"sc.us":true,"sd.us":true,"tn.us":true,"tx.us":true,"ut.us":true,"vi.us":true,"vt.us":true,"va.us":true,"wa.us":true,"wi.us":true,"wv.us":true,"wy.us":true,"k12.ak.us":true,"k12.al.us":true,"k12.ar.us":true,"k12.as.us":true,"k12.az.us":true,"k12.ca.us":true,"k12.co.us":true,"k12.ct.us":true,"k12.dc.us":true,"k12.de.us":true,"k12.fl.us":true,"k12.ga.us":true,"k12.gu.us":true,"k12.ia.us":true,"k12.id.us":true,"k12.il.us":true,"k12.in.us":true,"k12.ks.us":true,"k12.ky.us":true,"k12.la.us":true,"k12.ma.us":true,"k12.md.us":true,"k12.me.us":true,"k12.mi.us":true,"k12.mn.us":true,"k12.mo.us":true,"k12.ms.us":true,"k12.mt.us":true,"k12.nc.us":true,"k12.ne.us":true,"k12.nh.us":true,"k12.nj.us":true,"k12.nm.us":true,"k12.nv.us":true,"k12.ny.us":true,"k12.oh.us":true,"k12.ok.us":true,"k12.or.us":true,"k12.pa.us":true,"k12.pr.us":true,"k12.ri.us":true,"k12.sc.us":true,"k12.tn.us":true,"k12.tx.us":true,"k12.ut.us":true,"k12.vi.us":true,"k12.vt.us":true,"k12.va.us":true,"k12.wa.us":true,"k12.wi.us":true,"k12.wy.us":true,"cc.ak.us":true,"cc.al.us":true,"cc.ar.us":true,"cc.as.us":true,"cc.az.us":true,"cc.ca.us":true,"cc.co.us":true,"cc.ct.us":true,"cc.dc.us":true,"cc.de.us":true,"cc.fl.us":true,"cc.ga.us":true,"cc.gu.us":true,"cc.hi.us":true,"cc.ia.us":true,"cc.id.us":true,"cc.il.us":true,"cc.in.us":true,"cc.ks.us":true,"cc.ky.us":true,"cc.la.us":true,"cc.ma.us":true,"cc.md.us":true,"cc.me.us":true,"cc.mi.us":true,"cc.mn.us":true,"cc.mo.us":true,"cc.ms.us":true,"cc.mt.us":true,"cc.nc.us":true,"cc.nd.us":true,"cc.ne.us":true,"cc.nh.us":true,"cc.nj.us":true,"cc.nm.us":true,"cc.nv.us":true,"cc.ny.us":true,"cc.oh.us":true,"cc.ok.us":true,"cc.or.us":true,"cc.pa.us":true,"cc.pr.us":true,"cc.ri.us":true,"cc.sc.us":true,"cc.sd.us":true,"cc.tn.us":true,"cc.tx.us":true,"cc.ut.us":true,"cc.vi.us":true,"cc.vt.us":true,"cc.va.us":true,"cc.wa.us":true,"cc.wi.us":true,"cc.wv.us":true,"cc.wy.us":true,"lib.ak.us":true,"lib.al.us":true,"lib.ar.us":true,"lib.as.us":true,"lib.az.us":true,"lib.ca.us":true,"lib.co.us":true,"lib.ct.us":true,"lib.dc.us":true,"lib.fl.us":true,"lib.ga.us":true,"lib.gu.us":true,"lib.hi.us":true,"lib.ia.us":true,"lib.id.us":true,"lib.il.us":true,"lib.in.us":true,"lib.ks.us":true,"lib.ky.us":true,"lib.la.us":true,"lib.ma.us":true,"lib.md.us":true,"lib.me.us":true,"lib.mi.us":true,"lib.mn.us":true,"lib.mo.us":true,"lib.ms.us":true,"lib.mt.us":true,"lib.nc.us":true,"lib.nd.us":true,"lib.ne.us":true,"lib.nh.us":true,"lib.nj.us":true,"lib.nm.us":true,"lib.nv.us":true,"lib.ny.us":true,"lib.oh.us":true,"lib.ok.us":true,"lib.or.us":true,"lib.pa.us":true,"lib.pr.us":true,"lib.ri.us":true,"lib.sc.us":true,"lib.sd.us":true,"lib.tn.us":true,"lib.tx.us":true,"lib.ut.us":true,"lib.vi.us":true,"lib.vt.us":true,"lib.va.us":true,"lib.wa.us":true,"lib.wi.us":true,"lib.wy.us":true,"pvt.k12.ma.us":true,"chtr.k12.ma.us":true,"paroch.k12.ma.us":true,"ann-arbor.mi.us":true,"cog.mi.us":true,"dst.mi.us":true,"eaton.mi.us":true,"gen.mi.us":true,"mus.mi.us":true,"tec.mi.us":true,"washtenaw.mi.us":true,"uy":true,"com.uy":true,"edu.uy":true,"gub.uy":true,"mil.uy":true,"net.uy":true,"org.uy":true,"uz":true,"co.uz":true,"com.uz":true,"net.uz":true,"org.uz":true,"va":true,"vc":true,"com.vc":true,"net.vc":true,"org.vc":true,"gov.vc":true,"mil.vc":true,"edu.vc":true,"ve":true,"arts.ve":true,"co.ve":true,"com.ve":true,"e12.ve":true,"edu.ve":true,"firm.ve":true,"gob.ve":true,"gov.ve":true,"info.ve":true,"int.ve":true,"mil.ve":true,"net.ve":true,"org.ve":true,"rec.ve":true,"store.ve":true,"tec.ve":true,"web.ve":true,"vg":true,"vi":true,"co.vi":true,"com.vi":true,"k12.vi":true,"net.vi":true,"org.vi":true,"vn":true,"com.vn":true,"net.vn":true,"org.vn":true,"edu.vn":true,"gov.vn":true,"int.vn":true,"ac.vn":true,"biz.vn":true,"info.vn":true,"name.vn":true,"pro.vn":true,"health.vn":true,"vu":true,"com.vu":true,"edu.vu":true,"net.vu":true,"org.vu":true,"wf":true,"ws":true,"com.ws":true,"net.ws":true,\
"org.ws":true,"gov.ws":true,"edu.ws":true,"yt":true,"xn--mgbaam7a8h":true,"xn--y9a3aq":true,"xn--54b7fta0cc":true,"xn--90ae":true,"xn--90ais":true,"xn--fiqs8s":true,"xn--fiqz9s":true,"xn--lgbbat1ad8j":true,"xn--wgbh1c":true,"xn--e1a4c":true,"xn--node":true,"xn--qxam":true,"xn--j6w193g":true,"xn--2scrj9c":true,"xn--3hcrj9c":true,"xn--45br5cyl":true,"xn--h2breg3eve":true,"xn--h2brj9c8c":true,"xn--mgbgu82a":true,"xn--rvc1e0am3e":true,"xn--h2brj9c":true,"xn--mgbbh1a71e":true,"xn--fpcrj9c3d":true,"xn--gecrj9c":true,"xn--s9brj9c":true,"xn--45brj9c":true,"xn--xkc2dl3a5ee0h":true,"xn--mgba3a4f16a":true,"xn--mgba3a4fra":true,"xn--mgbtx2b":true,"xn--mgbayh7gpa":true,"xn--3e0b707e":true,"xn--80ao21a":true,"xn--fzc2c9e2c":true,"xn--xkc2al3hye2a":true,"xn--mgbc0a9azcg":true,"xn--d1alf":true,"xn--l1acc":true,"xn--mix891f":true,"xn--mix082f":true,"xn--mgbx4cd0ab":true,"xn--mgb9awbf":true,"xn--mgbai9azgqp6j":true,"xn--mgbai9a5eva00b":true,"xn--ygbi2ammx":true,"xn--90a3ac":true,"xn--o1ac.xn--90a3ac":true,"xn--c1avg.xn--90a3ac":true,"xn--90azh.xn--90a3ac":true,"xn--d1at.xn--90a3ac":true,"xn--o1ach.xn--90a3ac":true,"xn--80au.xn--90a3ac":true,"xn--p1ai":true,"xn--wgbl6a":true,"xn--mgberp4a5d4ar":true,"xn--mgberp4a5d4a87g":true,"xn--mgbqly7c0a67fbc":true,"xn--mgbqly7cvafr":true,"xn--mgbpl2fh":true,"xn--yfro4i67o":true,"xn--clchc0ea0b2g2a9gcd":true,"xn--ogbpf8fl":true,"xn--mgbtf8fl":true,"xn--o3cw4h":true,"xn--12c1fe0br.xn--o3cw4h":true,"xn--12co0c3b4eva.xn--o3cw4h":true,"xn--h3cuzk1di.xn--o3cw4h":true,"xn--o3cyx2a.xn--o3cw4h":true,"xn--m3ch0j3a.xn--o3cw4h":true,"xn--12cfi8ixb8l.xn--o3cw4h":true,"xn--pgbs0dh":true,"xn--kpry57d":true,"xn--kprw13d":true,"xn--nnx388a":true,"xn--j1amh":true,"xn--mgb2ddes":true,"xxx":true,"*.ye":true,"ac.za":true,"agric.za":true,"alt.za":true,"co.za":true,"edu.za":true,"gov.za":true,"grondar.za":true,"law.za":true,"mil.za":true,"net.za":true,"ngo.za":true,"nis.za":true,"nom.za":true,"org.za":true,"school.za":true,"tm.za":true,"web.za":true,"zm":true,"ac.zm":true,"biz.zm":true,"co.zm":true,"com.zm":true,"edu.zm":true,"gov.zm":true,"info.zm":true,"mil.zm":true,"net.zm":true,"org.zm":true,"sch.zm":true,"zw":true,"ac.zw":true,"co.zw":true,"gov.zw":true,"mil.zw":true,"org.zw":true,"aaa":true,"aarp":true,"abarth":true,"abb":true,"abbott":true,"abbvie":true,"abc":true,"able":true,"abogado":true,"abudhabi":true,"academy":true,"accenture":true,"accountant":true,"accountants":true,"aco":true,"active":true,"actor":true,"adac":true,"ads":true,"adult":true,"aeg":true,"aetna":true,"afamilycompany":true,"afl":true,"africa":true,"agakhan":true,"agency":true,"aig":true,"aigo":true,"airbus":true,"airforce":true,"airtel":true,"akdn":true,"alfaromeo":true,"alibaba":true,"alipay":true,"allfinanz":true,"allstate":true,"ally":true,"alsace":true,"alstom":true,"americanexpress":true,"americanfamily":true,"amex":true,"amfam":true,"amica":true,"amsterdam":true,"analytics":true,"android":true,"anquan":true,"anz":true,"aol":true,"apartments":true,"app":true,"apple":true,"aquarelle":true,"arab":true,"aramco":true,"archi":true,"army":true,"art":true,"arte":true,"asda":true,"associates":true,"athleta":true,"attorney":true,"auction":true,"audi":true,"audible":true,"audio":true,"auspost":true,"author":true,"auto":true,"autos":true,"avianca":true,"aws":true,"axa":true,"azure":true,"baby":true,"baidu":true,"banamex":true,"bananarepublic":true,"band":true,"bank":true,"bar":true,"barcelona":true,"barclaycard":true,"barclays":true,"barefoot":true,"bargains":true,"baseball":true,"basketball":true,"bauhaus":true,"bayern":true,"bbc":true,"bbt":true,"bbva":true,"bcg":true,"bcn":true,"beats":true,"beauty":true,"beer":true,"bentley":true,"berlin":true,"best":true,"bestbuy":true,"bet":true,"bharti":true,"bible":true,"bid":true,"bike":true,"bing":true,"bingo":true,"bio":true,"black":true,"blackfriday":true,"blanco":true,"blockbuster":true,"blog":true,"bloomberg":true,"blue":true,"bms":true,"bmw":true,"bnl":true,"bnpparibas":true,"boats":true,"boehringer":true,\
"bofa":true,"bom":true,"bond":true,"boo":true,"book":true,"booking":true,"boots":true,"bosch":true,"bostik":true,"boston":true,"bot":true,"boutique":true,"box":true,"bradesco":true,"bridgestone":true,"broadway":true,"broker":true,"brother":true,"brussels":true,"budapest":true,"bugatti":true,"build":true,"builders":true,"business":true,"buy":true,"buzz":true,"bzh":true,"cab":true,"cafe":true,"cal":true,"call":true,"calvinklein":true,"cam":true,"camera":true,"camp":true,"cancerresearch":true,"canon":true,"capetown":true,"capital":true,"capitalone":true,"car":true,"caravan":true,"cards":true,"care":true,"career":true,"careers":true,"cars":true,"cartier":true,"casa":true,"case":true,"caseih":true,"cash":true,"casino":true,"catering":true,"catholic":true,"cba":true,"cbn":true,"cbre":true,"cbs":true,"ceb":true,"center":true,"ceo":true,"cern":true,"cfa":true,"cfd":true,"chanel":true,"channel":true,"chase":true,"chat":true,"cheap":true,"chintai":true,"christmas":true,"chrome":true,"chrysler":true,"church":true,"cipriani":true,"circle":true,"cisco":true,"citadel":true,"citi":true,"citic":true,"city":true,"cityeats":true,"claims":true,"cleaning":true,"click":true,"clinic":true,"clinique":true,"clothing":true,"cloud":true,"club":true,"clubmed":true,"coach":true,"codes":true,"coffee":true,"college":true,"cologne":true,"comcast":true,"commbank":true,"community":true,"company":true,"compare":true,"computer":true,"comsec":true,"condos":true,"construction":true,"consulting":true,"contact":true,"contractors":true,"cooking":true,"cookingchannel":true,"cool":true,"corsica":true,"country":true,"coupon":true,"coupons":true,"courses":true,"credit":true,"creditcard":true,"creditunion":true,"cricket":true,"crown":true,"crs":true,"cruise":true,"cruises":true,"csc":true,"cuisinella":true,"cymru":true,"cyou":true,"dabur":true,"dad":true,"dance":true,"data":true,"date":true,"dating":true,"datsun":true,"day":true,"dclk":true,"dds":true,"deal":true,"dealer":true,"deals":true,"degree":true,"delivery":true,"dell":true,"deloitte":true,"delta":true,"democrat":true,"dental":true,"dentist":true,"desi":true,"design":true,"dev":true,"dhl":true,"diamonds":true,"diet":true,"digital":true,"direct":true,"directory":true,"discount":true,"discover":true,"dish":true,"diy":true,"dnp":true,"docs":true,"doctor":true,"dodge":true,"dog":true,"doha":true,"domains":true,"dot":true,"download":true,"drive":true,"dtv":true,"dubai":true,"duck":true,"dunlop":true,"duns":true,"dupont":true,"durban":true,"dvag":true,"dvr":true,"earth":true,"eat":true,"eco":true,"edeka":true,"education":true,"email":true,"emerck":true,"energy":true,"engineer":true,"engineering":true,"enterprises":true,"epost":true,"epson":true,"equipment":true,"ericsson":true,"erni":true,"esq":true,"estate":true,"esurance":true,"etisalat":true,"eurovision":true,"eus":true,"events":true,"everbank":true,"exchange":true,"expert":true,"exposed":true,"express":true,"extraspace":true,"fage":true,"fail":true,"fairwinds":true,"faith":true,"family":true,"fan":true,"fans":true,"farm":true,"farmers":true,"fashion":true,"fast":true,"fedex":true,"feedback":true,"ferrari":true,"ferrero":true,"fiat":true,"fidelity":true,"fido":true,"film":true,"final":true,"finance":true,"financial":true,"fire":true,"firestone":true,"firmdale":true,"fish":true,"fishing":true,"fit":true,"fitness":true,"flickr":true,"flights":true,"flir":true,"florist":true,"flowers":true,"fly":true,"foo":true,"food":true,"foodnetwork":true,"football":true,"ford":true,"forex":true,"forsale":true,"forum":true,"foundation":true,"fox":true,"free":true,"fresenius":true,"frl":true,"frogans":true,"frontdoor":true,"frontier":true,"ftr":true,"fujitsu":true,"fujixerox":true,"fun":true,"fund":true,"furniture":true,"futbol":true,"fyi":true,"gal":true,"gallery":true,"gallo":true,"gallup":true,"game":true,"games":true,"gap":true,"garden":true,"gbiz":true,"gdn":true,"gea":true,"gent":true,"genting":true,"george":true,"ggee":true,"gift":true,"gifts":true,"gives":true,"giving":true,\
"glade":true,"glass":true,"gle":true,"global":true,"globo":true,"gmail":true,"gmbh":true,"gmo":true,"gmx":true,"godaddy":true,"gold":true,"goldpoint":true,"golf":true,"goo":true,"goodhands":true,"goodyear":true,"goog":true,"google":true,"gop":true,"got":true,"grainger":true,"graphics":true,"gratis":true,"green":true,"gripe":true,"grocery":true,"group":true,"guardian":true,"gucci":true,"guge":true,"guide":true,"guitars":true,"guru":true,"hair":true,"hamburg":true,"hangout":true,"haus":true,"hbo":true,"hdfc":true,"hdfcbank":true,"health":true,"healthcare":true,"help":true,"helsinki":true,"here":true,"hermes":true,"hgtv":true,"hiphop":true,"hisamitsu":true,"hitachi":true,"hiv":true,"hkt":true,"hockey":true,"holdings":true,"holiday":true,"homedepot":true,"homegoods":true,"homes":true,"homesense":true,"honda":true,"honeywell":true,"horse":true,"hospital":true,"host":true,"hosting":true,"hot":true,"hoteles":true,"hotels":true,"hotmail":true,"house":true,"how":true,"hsbc":true,"hughes":true,"hyatt":true,"hyundai":true,"ibm":true,"icbc":true,"ice":true,"icu":true,"ieee":true,"ifm":true,"ikano":true,"imamat":true,"imdb":true,"immo":true,"immobilien":true,"industries":true,"infiniti":true,"ing":true,"ink":true,"institute":true,"insurance":true,"insure":true,"intel":true,"international":true,"intuit":true,"investments":true,"ipiranga":true,"irish":true,"iselect":true,"ismaili":true,"ist":true,"istanbul":true,"itau":true,"itv":true,"iveco":true,"iwc":true,"jaguar":true,"java":true,"jcb":true,"jcp":true,"jeep":true,"jetzt":true,"jewelry":true,"jio":true,"jlc":true,"jll":true,"jmp":true,"jnj":true,"joburg":true,"jot":true,"joy":true,"jpmorgan":true,"jprs":true,"juegos":true,"juniper":true,"kaufen":true,"kddi":true,"kerryhotels":true,"kerrylogistics":true,"kerryproperties":true,"kfh":true,"kia":true,"kim":true,"kinder":true,"kindle":true,"kitchen":true,"kiwi":true,"koeln":true,"komatsu":true,"kosher":true,"kpmg":true,"kpn":true,"krd":true,"kred":true,"kuokgroup":true,"kyoto":true,"lacaixa":true,"ladbrokes":true,"lamborghini":true,"lamer":true,"lancaster":true,"lancia":true,"lancome":true,"land":true,"landrover":true,"lanxess":true,"lasalle":true,"lat":true,"latino":true,"latrobe":true,"law":true,"lawyer":true,"lds":true,"lease":true,"leclerc":true,"lefrak":true,"legal":true,"lego":true,"lexus":true,"lgbt":true,"liaison":true,"lidl":true,"life":true,"lifeinsurance":true,"lifestyle":true,"lighting":true,"like":true,"lilly":true,"limited":true,"limo":true,"lincoln":true,"linde":true,"link":true,"lipsy":true,"live":true,"living":true,"lixil":true,"loan":true,"loans":true,"locker":true,"locus":true,"loft":true,"lol":true,"london":true,"lotte":true,"lotto":true,"love":true,"lpl":true,"lplfinancial":true,"ltd":true,"ltda":true,"lundbeck":true,"lupin":true,"luxe":true,"luxury":true,"macys":true,"madrid":true,"maif":true,"maison":true,"makeup":true,"man":true,"management":true,"mango":true,"map":true,"market":true,"marketing":true,"markets":true,"marriott":true,"marshalls":true,"maserati":true,"mattel":true,"mba":true,"mckinsey":true,"med":true,"media":true,"meet":true,"melbourne":true,"meme":true,"memorial":true,"men":true,"menu":true,"meo":true,"merckmsd":true,"metlife":true,"miami":true,"microsoft":true,"mini":true,"mint":true,"mit":true,"mitsubishi":true,"mlb":true,"mls":true,"mma":true,"mobile":true,"mobily":true,"moda":true,"moe":true,"moi":true,"mom":true,"monash":true,"money":true,"monster":true,"mopar":true,"mormon":true,"mortgage":true,"moscow":true,"moto":true,"motorcycles":true,"mov":true,"movie":true,"movistar":true,"msd":true,"mtn":true,"mtpc":true,"mtr":true,"mutual":true,"nab":true,"nadex":true,"nagoya":true,"nationwide":true,"natura":true,"navy":true,"nba":true,"nec":true,"netbank":true,"netflix":true,"network":true,"neustar":true,"new":true,"newholland":true,"news":true,"next":true,"nextdirect":true,"nexus":true,"nfl":true,"ngo":true,"nhk":true,"nico":true,"nike":true,"nikon":true,"ninja":true,"nissan":true,"nissay":true,\
"nokia":true,"northwesternmutual":true,"norton":true,"now":true,"nowruz":true,"nowtv":true,"nra":true,"nrw":true,"ntt":true,"nyc":true,"obi":true,"observer":true,"off":true,"office":true,"okinawa":true,"olayan":true,"olayangroup":true,"oldnavy":true,"ollo":true,"omega":true,"one":true,"ong":true,"onl":true,"online":true,"onyourside":true,"ooo":true,"open":true,"oracle":true,"orange":true,"organic":true,"origins":true,"osaka":true,"otsuka":true,"ott":true,"ovh":true,"page":true,"panasonic":true,"panerai":true,"paris":true,"pars":true,"partners":true,"parts":true,"party":true,"passagens":true,"pay":true,"pccw":true,"pet":true,"pfizer":true,"pharmacy":true,"phd":true,"philips":true,"phone":true,"photo":true,"photography":true,"photos":true,"physio":true,"piaget":true,"pics":true,"pictet":true,"pictures":true,"pid":true,"pin":true,"ping":true,"pink":true,"pioneer":true,"pizza":true,"place":true,"play":true,"playstation":true,"plumbing":true,"plus":true,"pnc":true,"pohl":true,"poker":true,"politie":true,"porn":true,"pramerica":true,"praxi":true,"press":true,"prime":true,"prod":true,"productions":true,"prof":true,"progressive":true,"promo":true,"properties":true,"property":true,"protection":true,"pru":true,"prudential":true,"pub":true,"pwc":true,"qpon":true,"quebec":true,"quest":true,"qvc":true,"racing":true,"radio":true,"raid":true,"read":true,"realestate":true,"realtor":true,"realty":true,"recipes":true,"red":true,"redstone":true,"redumbrella":true,"rehab":true,"reise":true,"reisen":true,"reit":true,"reliance":true,"ren":true,"rent":true,"rentals":true,"repair":true,"report":true,"republican":true,"rest":true,"restaurant":true,"review":true,"reviews":true,"rexroth":true,"rich":true,"richardli":true,"ricoh":true,"rightathome":true,"ril":true,"rio":true,"rip":true,"rmit":true,"rocher":true,"rocks":true,"rodeo":true,"rogers":true,"room":true,"rsvp":true,"rugby":true,"ruhr":true,"run":true,"rwe":true,"ryukyu":true,"saarland":true,"safe":true,"safety":true,"sakura":true,"sale":true,"salon":true,"samsclub":true,"samsung":true,"sandvik":true,"sandvikcoromant":true,"sanofi":true,"sap":true,"sapo":true,"sarl":true,"sas":true,"save":true,"saxo":true,"sbi":true,"sbs":true,"sca":true,"scb":true,"schaeffler":true,"schmidt":true,"scholarships":true,"school":true,"schule":true,"schwarz":true,"science":true,"scjohnson":true,"scor":true,"scot":true,"search":true,"seat":true,"secure":true,"security":true,"seek":true,"select":true,"sener":true,"services":true,"ses":true,"seven":true,"sew":true,"sex":true,"sexy":true,"sfr":true,"shangrila":true,"sharp":true,"shaw":true,"shell":true,"shia":true,"shiksha":true,"shoes":true,"shop":true,"shopping":true,"shouji":true,"show":true,"showtime":true,"shriram":true,"silk":true,"sina":true,"singles":true,"site":true,"ski":true,"skin":true,"sky":true,"skype":true,"sling":true,"smart":true,"smile":true,"sncf":true,"soccer":true,"social":true,"softbank":true,"software":true,"sohu":true,"solar":true,"solutions":true,"song":true,"sony":true,"soy":true,"space":true,"spiegel":true,"spot":true,"spreadbetting":true,"srl":true,"srt":true,"stada":true,"staples":true,"star":true,"starhub":true,"statebank":true,"statefarm":true,"statoil":true,"stc":true,"stcgroup":true,"stockholm":true,"storage":true,"store":true,"stream":true,"studio":true,"study":true,"style":true,"sucks":true,"supplies":true,"supply":true,"support":true,"surf":true,"surgery":true,"suzuki":true,"swatch":true,"swiftcover":true,"swiss":true,"sydney":true,"symantec":true,"systems":true,"tab":true,"taipei":true,"talk":true,"taobao":true,"target":true,"tatamotors":true,"tatar":true,"tattoo":true,"tax":true,"taxi":true,"tci":true,"tdk":true,"team":true,"tech":true,"technology":true,"telecity":true,"telefonica":true,"temasek":true,"tennis":true,"teva":true,"thd":true,"theater":true,"theatre":true,"tiaa":true,"tickets":true,"tienda":true,"tiffany":true,"tips":true,"tires":true,"tirol":true,"tjmaxx":true,"tjx":true,"tkmaxx":true,"tmall":true,"today":true,\
"tokyo":true,"tools":true,"top":true,"toray":true,"toshiba":true,"total":true,"tours":true,"town":true,"toyota":true,"toys":true,"trade":true,"trading":true,"training":true,"travelchannel":true,"travelers":true,"travelersinsurance":true,"trust":true,"trv":true,"tube":true,"tui":true,"tunes":true,"tushu":true,"tvs":true,"ubank":true,"ubs":true,"uconnect":true,"unicom":true,"university":true,"uno":true,"uol":true,"ups":true,"vacations":true,"vana":true,"vanguard":true,"vegas":true,"ventures":true,"verisign":true,"versicherung":true,"vet":true,"viajes":true,"video":true,"vig":true,"viking":true,"villas":true,"vin":true,"vip":true,"virgin":true,"visa":true,"vision":true,"vista":true,"vistaprint":true,"viva":true,"vivo":true,"vlaanderen":true,"vodka":true,"volkswagen":true,"volvo":true,"vote":true,"voting":true,"voto":true,"voyage":true,"vuelos":true,"wales":true,"walmart":true,"walter":true,"wang":true,"wanggou":true,"warman":true,"watch":true,"watches":true,"weather":true,"weatherchannel":true,"webcam":true,"weber":true,"website":true,"wed":true,"wedding":true,"weibo":true,"weir":true,"whoswho":true,"wien":true,"wiki":true,"williamhill":true,"win":true,"windows":true,"wine":true,"winners":true,"wme":true,"wolterskluwer":true,"woodside":true,"work":true,"works":true,"world":true,"wow":true,"wtc":true,"wtf":true,"xbox":true,"xerox":true,"xfinity":true,"xihuan":true,"xin":true,"xn--11b4c3d":true,"xn--1ck2e1b":true,"xn--1qqw23a":true,"xn--30rr7y":true,"xn--3bst00m":true,"xn--3ds443g":true,"xn--3oq18vl8pn36a":true,"xn--3pxu8k":true,"xn--42c2d9a":true,"xn--45q11c":true,"xn--4gbrim":true,"xn--55qw42g":true,"xn--55qx5d":true,"xn--5su34j936bgsg":true,"xn--5tzm5g":true,"xn--6frz82g":true,"xn--6qq986b3xl":true,"xn--80adxhks":true,"xn--80aqecdr1a":true,"xn--80asehdb":true,"xn--80aswg":true,"xn--8y0a063a":true,"xn--9dbq2a":true,"xn--9et52u":true,"xn--9krt00a":true,"xn--b4w605ferd":true,"xn--bck1b9a5dre4c":true,"xn--c1avg":true,"xn--c2br7g":true,"xn--cck2b3b":true,"xn--cg4bki":true,"xn--czr694b":true,"xn--czrs0t":true,"xn--czru2d":true,"xn--d1acj3b":true,"xn--eckvdtc9d":true,"xn--efvy88h":true,"xn--estv75g":true,"xn--fct429k":true,"xn--fhbei":true,"xn--fiq228c5hs":true,"xn--fiq64b":true,"xn--fjq720a":true,"xn--flw351e":true,"xn--fzys8d69uvgm":true,"xn--g2xx48c":true,"xn--gckr3f0f":true,"xn--gk3at1e":true,"xn--hxt814e":true,"xn--i1b6b1a6a2e":true,"xn--imr513n":true,"xn--io0a7i":true,"xn--j1aef":true,"xn--jlq61u9w7b":true,"xn--jvr189m":true,"xn--kcrx77d1x4a":true,"xn--kpu716f":true,"xn--kput3i":true,"xn--mgba3a3ejt":true,"xn--mgba7c0bbn0a":true,"xn--mgbaakc7dvf":true,"xn--mgbab2bd":true,"xn--mgbb9fbpob":true,"xn--mgbca7dzdo":true,"xn--mgbi4ecexp":true,"xn--mgbt3dhd":true,"xn--mk1bu44c":true,"xn--mxtq1m":true,"xn--ngbc5azd":true,"xn--ngbe9e0a":true,"xn--ngbrx":true,"xn--nqv7f":true,"xn--nqv7fs00ema":true,"xn--nyqy26a":true,"xn--p1acf":true,"xn--pbt977c":true,"xn--pssy2u":true,"xn--q9jyb4c":true,"xn--qcka1pmc":true,"xn--rhqv96g":true,"xn--rovu88b":true,"xn--ses554g":true,"xn--t60b56a":true,"xn--tckwe":true,"xn--tiq49xqyj":true,"xn--unup4y":true,"xn--vermgensberater-ctb":true,"xn--vermgensberatung-pwb":true,"xn--vhquv":true,"xn--vuq861b":true,"xn--w4r85el8fhu5dnra":true,"xn--w4rs40l":true,"xn--xhq521b":true,"xn--zfr164b":true,"xperia":true,"xyz":true,"yachts":true,"yahoo":true,"yamaxun":true,"yandex":true,"yodobashi":true,"yoga":true,"yokohama":true,"you":true,"youtube":true,"yun":true,"zappos":true,"zara":true,"zero":true,"zip":true,"zippo":true,"zone":true,"zuerich":true,"cc.ua":true,"inf.ua":true,"ltd.ua":true,"1password.ca":true,"1password.com":true,"1password.eu":true,"beep.pl":true,"*.compute.estate":true,"*.alces.network":true,"alwaysdata.net":true,"cloudfront.net":true,"*.compute.amazonaws.com":true,"*.compute-1.amazonaws.com":true,"*.compute.amazonaws.com.cn":true,"us-east-1.amazonaws.com":true,"cn-north-1.eb.amazonaws.com.cn":true,"elasticbeanstalk.com":true,"ap-northeast-1.elasticbeanstalk.com":true,\
"ap-northeast-2.elasticbeanstalk.com":true,"ap-south-1.elasticbeanstalk.com":true,"ap-southeast-1.elasticbeanstalk.com":true,"ap-southeast-2.elasticbeanstalk.com":true,"ca-central-1.elasticbeanstalk.com":true,"eu-central-1.elasticbeanstalk.com":true,"eu-west-1.elasticbeanstalk.com":true,"eu-west-2.elasticbeanstalk.com":true,"eu-west-3.elasticbeanstalk.com":true,"sa-east-1.elasticbeanstalk.com":true,"us-east-1.elasticbeanstalk.com":true,"us-east-2.elasticbeanstalk.com":true,"us-gov-west-1.elasticbeanstalk.com":true,"us-west-1.elasticbeanstalk.com":true,"us-west-2.elasticbeanstalk.com":true,"*.elb.amazonaws.com":true,"*.elb.amazonaws.com.cn":true,"s3.amazonaws.com":true,"s3-ap-northeast-1.amazonaws.com":true,"s3-ap-northeast-2.amazonaws.com":true,"s3-ap-south-1.amazonaws.com":true,"s3-ap-southeast-1.amazonaws.com":true,"s3-ap-southeast-2.amazonaws.com":true,"s3-ca-central-1.amazonaws.com":true,"s3-eu-central-1.amazonaws.com":true,"s3-eu-west-1.amazonaws.com":true,"s3-eu-west-2.amazonaws.com":true,"s3-eu-west-3.amazonaws.com":true,"s3-external-1.amazonaws.com":true,"s3-fips-us-gov-west-1.amazonaws.com":true,"s3-sa-east-1.amazonaws.com":true,"s3-us-gov-west-1.amazonaws.com":true,"s3-us-east-2.amazonaws.com":true,"s3-us-west-1.amazonaws.com":true,"s3-us-west-2.amazonaws.com":true,"s3.ap-northeast-2.amazonaws.com":true,"s3.ap-south-1.amazonaws.com":true,"s3.cn-north-1.amazonaws.com.cn":true,"s3.ca-central-1.amazonaws.com":true,"s3.eu-central-1.amazonaws.com":true,"s3.eu-west-2.amazonaws.com":true,"s3.eu-west-3.amazonaws.com":true,"s3.us-east-2.amazonaws.com":true,"s3.dualstack.ap-northeast-1.amazonaws.com":true,"s3.dualstack.ap-northeast-2.amazonaws.com":true,"s3.dualstack.ap-south-1.amazonaws.com":true,"s3.dualstack.ap-southeast-1.amazonaws.com":true,"s3.dualstack.ap-southeast-2.amazonaws.com":true,"s3.dualstack.ca-central-1.amazonaws.com":true,"s3.dualstack.eu-central-1.amazonaws.com":true,"s3.dualstack.eu-west-1.amazonaws.com":true,"s3.dualstack.eu-west-2.amazonaws.com":true,"s3.dualstack.eu-west-3.amazonaws.com":true,"s3.dualstack.sa-east-1.amazonaws.com":true,"s3.dualstack.us-east-1.amazonaws.com":true,"s3.dualstack.us-east-2.amazonaws.com":true,"s3-website-us-east-1.amazonaws.com":true,"s3-website-us-west-1.amazonaws.com":true,"s3-website-us-west-2.amazonaws.com":true,"s3-website-ap-northeast-1.amazonaws.com":true,"s3-website-ap-southeast-1.amazonaws.com":true,"s3-website-ap-southeast-2.amazonaws.com":true,"s3-website-eu-west-1.amazonaws.com":true,"s3-website-sa-east-1.amazonaws.com":true,"s3-website.ap-northeast-2.amazonaws.com":true,"s3-website.ap-south-1.amazonaws.com":true,"s3-website.ca-central-1.amazonaws.com":true,"s3-website.eu-central-1.amazonaws.com":true,"s3-website.eu-west-2.amazonaws.com":true,"s3-website.eu-west-3.amazonaws.com":true,"s3-website.us-east-2.amazonaws.com":true,"t3l3p0rt.net":true,"tele.amune.org":true,"on-aptible.com":true,"user.party.eus":true,"pimienta.org":true,"poivron.org":true,"potager.org":true,"sweetpepper.org":true,"myasustor.com":true,"myfritz.net":true,"*.awdev.ca":true,"*.advisor.ws":true,"backplaneapp.io":true,"betainabox.com":true,"bnr.la":true,"boomla.net":true,"boxfuse.io":true,"square7.ch":true,"bplaced.com":true,"bplaced.de":true,"square7.de":true,"bplaced.net":true,"square7.net":true,"browsersafetymark.io":true,"mycd.eu":true,"ae.org":true,"ar.com":true,"br.com":true,"cn.com":true,"com.de":true,"com.se":true,"de.com":true,"eu.com":true,"gb.com":true,"gb.net":true,"hu.com":true,"hu.net":true,"jp.net":true,"jpn.com":true,"kr.com":true,"mex.com":true,"no.com":true,"qc.com":true,"ru.com":true,"sa.com":true,"se.com":true,"se.net":true,"uk.com":true,"uk.net":true,"us.com":true,"uy.com":true,"za.bz":true,"za.com":true,"africa.com":true,"gr.com":true,"in.net":true,"us.org":true,"co.com":true,"c.la":true,"certmgr.org":true,"xenapponazure.com":true,"virtueeldomein.nl":true,"c66.me":true,"cloud66.ws":true,"jdevcloud.com":true,"wpdevcloud.com":true,"cloudaccess.host":true,\
"freesite.host":true,"cloudaccess.net":true,"cloudcontrolled.com":true,"cloudcontrolapp.com":true,"co.ca":true,"co.cz":true,"c.cdn77.org":true,"cdn77-ssl.net":true,"r.cdn77.net":true,"rsc.cdn77.org":true,"ssl.origin.cdn77-secure.org":true,"cloudns.asia":true,"cloudns.biz":true,"cloudns.club":true,"cloudns.cc":true,"cloudns.eu":true,"cloudns.in":true,"cloudns.info":true,"cloudns.org":true,"cloudns.pro":true,"cloudns.pw":true,"cloudns.us":true,"co.nl":true,"co.no":true,"webhosting.be":true,"hosting-cluster.nl":true,"dyn.cosidns.de":true,"dynamisches-dns.de":true,"dnsupdater.de":true,"internet-dns.de":true,"l-o-g-i-n.de":true,"dynamic-dns.info":true,"feste-ip.net":true,"knx-server.net":true,"static-access.net":true,"realm.cz":true,"*.cryptonomic.net":true,"cupcake.is":true,"cyon.link":true,"cyon.site":true,"daplie.me":true,"localhost.daplie.me":true,"biz.dk":true,"co.dk":true,"firm.dk":true,"reg.dk":true,"store.dk":true,"debian.net":true,"dedyn.io":true,"dnshome.de":true,"drayddns.com":true,"dreamhosters.com":true,"mydrobo.com":true,"drud.io":true,"drud.us":true,"duckdns.org":true,"dy.fi":true,"tunk.org":true,"dyndns-at-home.com":true,"dyndns-at-work.com":true,"dyndns-blog.com":true,"dyndns-free.com":true,"dyndns-home.com":true,"dyndns-ip.com":true,"dyndns-mail.com":true,"dyndns-office.com":true,"dyndns-pics.com":true,"dyndns-remote.com":true,"dyndns-server.com":true,"dyndns-web.com":true,"dyndns-wiki.com":true,"dyndns-work.com":true,"dyndns.biz":true,"dyndns.info":true,"dyndns.org":true,"dyndns.tv":true,"at-band-camp.net":true,"ath.cx":true,"barrel-of-knowledge.info":true,"barrell-of-knowledge.info":true,"better-than.tv":true,"blogdns.com":true,"blogdns.net":true,"blogdns.org":true,"blogsite.org":true,"boldlygoingnowhere.org":true,"broke-it.net":true,"buyshouses.net":true,"cechire.com":true,"dnsalias.com":true,"dnsalias.net":true,"dnsalias.org":true,"dnsdojo.com":true,"dnsdojo.net":true,"dnsdojo.org":true,"does-it.net":true,"doesntexist.com":true,"doesntexist.org":true,"dontexist.com":true,"dontexist.net":true,"dontexist.org":true,"doomdns.com":true,"doomdns.org":true,"dvrdns.org":true,"dyn-o-saur.com":true,"dynalias.com":true,"dynalias.net":true,"dynalias.org":true,"dynathome.net":true,"dyndns.ws":true,"endofinternet.net":true,"endofinternet.org":true,"endoftheinternet.org":true,"est-a-la-maison.com":true,"est-a-la-masion.com":true,"est-le-patron.com":true,"est-mon-blogueur.com":true,"for-better.biz":true,"for-more.biz":true,"for-our.info":true,"for-some.biz":true,"for-the.biz":true,"forgot.her.name":true,"forgot.his.name":true,"from-ak.com":true,"from-al.com":true,"from-ar.com":true,"from-az.net":true,"from-ca.com":true,"from-co.net":true,"from-ct.com":true,"from-dc.com":true,"from-de.com":true,"from-fl.com":true,"from-ga.com":true,"from-hi.com":true,"from-ia.com":true,"from-id.com":true,"from-il.com":true,"from-in.com":true,"from-ks.com":true,"from-ky.com":true,"from-la.net":true,"from-ma.com":true,"from-md.com":true,"from-me.org":true,"from-mi.com":true,"from-mn.com":true,"from-mo.com":true,"from-ms.com":true,"from-mt.com":true,"from-nc.com":true,"from-nd.com":true,"from-ne.com":true,"from-nh.com":true,"from-nj.com":true,"from-nm.com":true,"from-nv.com":true,"from-ny.net":true,"from-oh.com":true,"from-ok.com":true,"from-or.com":true,"from-pa.com":true,"from-pr.com":true,"from-ri.com":true,"from-sc.com":true,"from-sd.com":true,"from-tn.com":true,"from-tx.com":true,"from-ut.com":true,"from-va.com":true,"from-vt.com":true,"from-wa.com":true,"from-wi.com":true,"from-wv.com":true,"from-wy.com":true,"ftpaccess.cc":true,"fuettertdasnetz.de":true,"game-host.org":true,"game-server.cc":true,"getmyip.com":true,"gets-it.net":true,"go.dyndns.org":true,"gotdns.com":true,"gotdns.org":true,"groks-the.info":true,"groks-this.info":true,"ham-radio-op.net":true,"here-for-more.info":true,"hobby-site.com":true,"hobby-site.org":true,"home.dyndns.org":true,"homedns.org":true,"homeftp.net":true,"homeftp.org":true,"homeip.net":true,\
"homelinux.com":true,"homelinux.net":true,"homelinux.org":true,"homeunix.com":true,"homeunix.net":true,"homeunix.org":true,"iamallama.com":true,"in-the-band.net":true,"is-a-anarchist.com":true,"is-a-blogger.com":true,"is-a-bookkeeper.com":true,"is-a-bruinsfan.org":true,"is-a-bulls-fan.com":true,"is-a-candidate.org":true,"is-a-caterer.com":true,"is-a-celticsfan.org":true,"is-a-chef.com":true,"is-a-chef.net":true,"is-a-chef.org":true,"is-a-conservative.com":true,"is-a-cpa.com":true,"is-a-cubicle-slave.com":true,"is-a-democrat.com":true,"is-a-designer.com":true,"is-a-doctor.com":true,"is-a-financialadvisor.com":true,"is-a-geek.com":true,"is-a-geek.net":true,"is-a-geek.org":true,"is-a-green.com":true,"is-a-guru.com":true,"is-a-hard-worker.com":true,"is-a-hunter.com":true,"is-a-knight.org":true,"is-a-landscaper.com":true,"is-a-lawyer.com":true,"is-a-liberal.com":true,"is-a-libertarian.com":true,"is-a-linux-user.org":true,"is-a-llama.com":true,"is-a-musician.com":true,"is-a-nascarfan.com":true,"is-a-nurse.com":true,"is-a-painter.com":true,"is-a-patsfan.org":true,"is-a-personaltrainer.com":true,"is-a-photographer.com":true,"is-a-player.com":true,"is-a-republican.com":true,"is-a-rockstar.com":true,"is-a-socialist.com":true,"is-a-soxfan.org":true,"is-a-student.com":true,"is-a-teacher.com":true,"is-a-techie.com":true,"is-a-therapist.com":true,"is-an-accountant.com":true,"is-an-actor.com":true,"is-an-actress.com":true,"is-an-anarchist.com":true,"is-an-artist.com":true,"is-an-engineer.com":true,"is-an-entertainer.com":true,"is-by.us":true,"is-certified.com":true,"is-found.org":true,"is-gone.com":true,"is-into-anime.com":true,"is-into-cars.com":true,"is-into-cartoons.com":true,"is-into-games.com":true,"is-leet.com":true,"is-lost.org":true,"is-not-certified.com":true,"is-saved.org":true,"is-slick.com":true,"is-uberleet.com":true,"is-very-bad.org":true,"is-very-evil.org":true,"is-very-good.org":true,"is-very-nice.org":true,"is-very-sweet.org":true,"is-with-theband.com":true,"isa-geek.com":true,"isa-geek.net":true,"isa-geek.org":true,"isa-hockeynut.com":true,"issmarterthanyou.com":true,"isteingeek.de":true,"istmein.de":true,"kicks-ass.net":true,"kicks-ass.org":true,"knowsitall.info":true,"land-4-sale.us":true,"lebtimnetz.de":true,"leitungsen.de":true,"likes-pie.com":true,"likescandy.com":true,"merseine.nu":true,"mine.nu":true,"misconfused.org":true,"mypets.ws":true,"myphotos.cc":true,"neat-url.com":true,"office-on-the.net":true,"on-the-web.tv":true,"podzone.net":true,"podzone.org":true,"readmyblog.org":true,"saves-the-whales.com":true,"scrapper-site.net":true,"scrapping.cc":true,"selfip.biz":true,"selfip.com":true,"selfip.info":true,"selfip.net":true,"selfip.org":true,"sells-for-less.com":true,"sells-for-u.com":true,"sells-it.net":true,"sellsyourhome.org":true,"servebbs.com":true,"servebbs.net":true,"servebbs.org":true,"serveftp.net":true,"serveftp.org":true,"servegame.org":true,"shacknet.nu":true,"simple-url.com":true,"space-to-rent.com":true,"stuff-4-sale.org":true,"stuff-4-sale.us":true,"teaches-yoga.com":true,"thruhere.net":true,"traeumtgerade.de":true,"webhop.biz":true,"webhop.info":true,"webhop.net":true,"webhop.org":true,"worse-than.tv":true,"writesthisblog.com":true,"ddnss.de":true,"dyn.ddnss.de":true,"dyndns.ddnss.de":true,"dyndns1.de":true,"dyn-ip24.de":true,"home-webserver.de":true,"dyn.home-webserver.de":true,"myhome-server.de":true,"ddnss.org":true,"definima.net":true,"definima.io":true,"ddnsfree.com":true,"ddnsgeek.com":true,"giize.com":true,"gleeze.com":true,"kozow.com":true,"loseyourip.com":true,"ooguy.com":true,"theworkpc.com":true,"casacam.net":true,"dynu.net":true,"accesscam.org":true,"camdvr.org":true,"freeddns.org":true,"mywire.org":true,"webredirect.org":true,"myddns.rocks":true,"blogsite.xyz":true,"dynv6.net":true,"e4.cz":true,"mytuleap.com":true,"enonic.io":true,"customer.enonic.io":true,"eu.org":true,"al.eu.org":true,"asso.eu.org":true,"at.eu.org":true,"au.eu.org":true,"be.eu.org":true,"bg.eu.org":true,\
"ca.eu.org":true,"cd.eu.org":true,"ch.eu.org":true,"cn.eu.org":true,"cy.eu.org":true,"cz.eu.org":true,"de.eu.org":true,"dk.eu.org":true,"edu.eu.org":true,"ee.eu.org":true,"es.eu.org":true,"fi.eu.org":true,"fr.eu.org":true,"gr.eu.org":true,"hr.eu.org":true,"hu.eu.org":true,"ie.eu.org":true,"il.eu.org":true,"in.eu.org":true,"int.eu.org":true,"is.eu.org":true,"it.eu.org":true,"jp.eu.org":true,"kr.eu.org":true,"lt.eu.org":true,"lu.eu.org":true,"lv.eu.org":true,"mc.eu.org":true,"me.eu.org":true,"mk.eu.org":true,"mt.eu.org":true,"my.eu.org":true,"net.eu.org":true,"ng.eu.org":true,"nl.eu.org":true,"no.eu.org":true,"nz.eu.org":true,"paris.eu.org":true,"pl.eu.org":true,"pt.eu.org":true,"q-a.eu.org":true,"ro.eu.org":true,"ru.eu.org":true,"se.eu.org":true,"si.eu.org":true,"sk.eu.org":true,"tr.eu.org":true,"uk.eu.org":true,"us.eu.org":true,"eu-1.evennode.com":true,"eu-2.evennode.com":true,"eu-3.evennode.com":true,"eu-4.evennode.com":true,"us-1.evennode.com":true,"us-2.evennode.com":true,"us-3.evennode.com":true,"us-4.evennode.com":true,"twmail.cc":true,"twmail.net":true,"twmail.org":true,"mymailer.com.tw":true,"url.tw":true,"apps.fbsbx.com":true,"ru.net":true,"adygeya.ru":true,"bashkiria.ru":true,"bir.ru":true,"cbg.ru":true,"com.ru":true,"dagestan.ru":true,"grozny.ru":true,"kalmykia.ru":true,"kustanai.ru":true,"marine.ru":true,"mordovia.ru":true,"msk.ru":true,"mytis.ru":true,"nalchik.ru":true,"nov.ru":true,"pyatigorsk.ru":true,"spb.ru":true,"vladikavkaz.ru":true,"vladimir.ru":true,"abkhazia.su":true,"adygeya.su":true,"aktyubinsk.su":true,"arkhangelsk.su":true,"armenia.su":true,"ashgabad.su":true,"azerbaijan.su":true,"balashov.su":true,"bashkiria.su":true,"bryansk.su":true,"bukhara.su":true,"chimkent.su":true,"dagestan.su":true,"east-kazakhstan.su":true,"exnet.su":true,"georgia.su":true,"grozny.su":true,"ivanovo.su":true,"jambyl.su":true,"kalmykia.su":true,"kaluga.su":true,"karacol.su":true,"karaganda.su":true,"karelia.su":true,"khakassia.su":true,"krasnodar.su":true,"kurgan.su":true,"kustanai.su":true,"lenug.su":true,"mangyshlak.su":true,"mordovia.su":true,"msk.su":true,"murmansk.su":true,"nalchik.su":true,"navoi.su":true,"north-kazakhstan.su":true,"nov.su":true,"obninsk.su":true,"penza.su":true,"pokrovsk.su":true,"sochi.su":true,"spb.su":true,"tashkent.su":true,"termez.su":true,"togliatti.su":true,"troitsk.su":true,"tselinograd.su":true,"tula.su":true,"tuva.su":true,"vladikavkaz.su":true,"vladimir.su":true,"vologda.su":true,"channelsdvr.net":true,"fastlylb.net":true,"map.fastlylb.net":true,"freetls.fastly.net":true,"map.fastly.net":true,"a.prod.fastly.net":true,"global.prod.fastly.net":true,"a.ssl.fastly.net":true,"b.ssl.fastly.net":true,"global.ssl.fastly.net":true,"fhapp.xyz":true,"fedorainfracloud.org":true,"fedorapeople.org":true,"cloud.fedoraproject.org":true,"app.os.fedoraproject.org":true,"app.os.stg.fedoraproject.org":true,"filegear.me":true,"firebaseapp.com":true,"flynnhub.com":true,"flynnhosting.net":true,"freebox-os.com":true,"freeboxos.com":true,"fbx-os.fr":true,"fbxos.fr":true,"freebox-os.fr":true,"freeboxos.fr":true,"*.futurecms.at":true,"futurehosting.at":true,"futuremailing.at":true,"*.ex.ortsinfo.at":true,"*.kunden.ortsinfo.at":true,"*.statics.cloud":true,"service.gov.uk":true,"github.io":true,"githubusercontent.com":true,"gitlab.io":true,"homeoffice.gov.uk":true,"ro.im":true,"shop.ro":true,"goip.de":true,"*.0emm.com":true,"appspot.com":true,"blogspot.ae":true,"blogspot.al":true,"blogspot.am":true,"blogspot.ba":true,"blogspot.be":true,"blogspot.bg":true,"blogspot.bj":true,"blogspot.ca":true,"blogspot.cf":true,"blogspot.ch":true,"blogspot.cl":true,"blogspot.co.at":true,"blogspot.co.id":true,"blogspot.co.il":true,"blogspot.co.ke":true,"blogspot.co.nz":true,"blogspot.co.uk":true,"blogspot.co.za":true,"blogspot.com":true,"blogspot.com.ar":true,"blogspot.com.au":true,"blogspot.com.br":true,"blogspot.com.by":true,"blogspot.com.co":true,"blogspot.com.cy":true,"blogspot.com.ee":true,"blogspot.com.eg":true,\
"blogspot.com.es":true,"blogspot.com.mt":true,"blogspot.com.ng":true,"blogspot.com.tr":true,"blogspot.com.uy":true,"blogspot.cv":true,"blogspot.cz":true,"blogspot.de":true,"blogspot.dk":true,"blogspot.fi":true,"blogspot.fr":true,"blogspot.gr":true,"blogspot.hk":true,"blogspot.hr":true,"blogspot.hu":true,"blogspot.ie":true,"blogspot.in":true,"blogspot.is":true,"blogspot.it":true,"blogspot.jp":true,"blogspot.kr":true,"blogspot.li":true,"blogspot.lt":true,"blogspot.lu":true,"blogspot.md":true,"blogspot.mk":true,"blogspot.mr":true,"blogspot.mx":true,"blogspot.my":true,"blogspot.nl":true,"blogspot.no":true,"blogspot.pe":true,"blogspot.pt":true,"blogspot.qa":true,"blogspot.re":true,"blogspot.ro":true,"blogspot.rs":true,"blogspot.ru":true,"blogspot.se":true,"blogspot.sg":true,"blogspot.si":true,"blogspot.sk":true,"blogspot.sn":true,"blogspot.td":true,"blogspot.tw":true,"blogspot.ug":true,"blogspot.vn":true,"cloudfunctions.net":true,"cloud.goog":true,"codespot.com":true,"googleapis.com":true,"googlecode.com":true,"pagespeedmobilizer.com":true,"publishproxy.com":true,"withgoogle.com":true,"withyoutube.com":true,"hashbang.sh":true,"hasura-app.io":true,"hepforge.org":true,"herokuapp.com":true,"herokussl.com":true,"moonscale.net":true,"iki.fi":true,"biz.at":true,"info.at":true,"info.cx":true,"ac.leg.br":true,"al.leg.br":true,"am.leg.br":true,"ap.leg.br":true,"ba.leg.br":true,"ce.leg.br":true,"df.leg.br":true,"es.leg.br":true,"go.leg.br":true,"ma.leg.br":true,"mg.leg.br":true,"ms.leg.br":true,"mt.leg.br":true,"pa.leg.br":true,"pb.leg.br":true,"pe.leg.br":true,"pi.leg.br":true,"pr.leg.br":true,"rj.leg.br":true,"rn.leg.br":true,"ro.leg.br":true,"rr.leg.br":true,"rs.leg.br":true,"sc.leg.br":true,"se.leg.br":true,"sp.leg.br":true,"to.leg.br":true,"pixolino.com":true,"ipifony.net":true,"*.triton.zone":true,"*.cns.joyent.com":true,"js.org":true,"keymachine.de":true,"knightpoint.systems":true,"co.krd":true,"edu.krd":true,"git-repos.de":true,"lcube-server.de":true,"svn-repos.de":true,"linkyard.cloud":true,"linkyard-cloud.ch":true,"we.bs":true,"barsy.bg":true,"barsyonline.com":true,"barsy.de":true,"barsy.eu":true,"barsy.in":true,"barsy.net":true,"barsy.online":true,"barsy.support":true,"*.magentosite.cloud":true,"hb.cldmail.ru":true,"cloud.metacentrum.cz":true,"custom.metacentrum.cz":true,"meteorapp.com":true,"eu.meteorapp.com":true,"co.pl":true,"azurewebsites.net":true,"azure-mobile.net":true,"cloudapp.net":true,"mozilla-iot.org":true,"bmoattachments.org":true,"net.ru":true,"org.ru":true,"pp.ru":true,"bitballoon.com":true,"netlify.com":true,"4u.com":true,"ngrok.io":true,"nh-serv.co.uk":true,"nfshost.com":true,"nsupdate.info":true,"nerdpol.ovh":true,"blogsyte.com":true,"brasilia.me":true,"cable-modem.org":true,"ciscofreak.com":true,"collegefan.org":true,"couchpotatofries.org":true,"damnserver.com":true,"ddns.me":true,"ditchyourip.com":true,"dnsfor.me":true,"dnsiskinky.com":true,"dvrcam.info":true,"dynns.com":true,"eating-organic.net":true,"fantasyleague.cc":true,"geekgalaxy.com":true,"golffan.us":true,"health-carereform.com":true,"homesecuritymac.com":true,"homesecuritypc.com":true,"hopto.me":true,"ilovecollege.info":true,"loginto.me":true,"mlbfan.org":true,"mmafan.biz":true,"myactivedirectory.com":true,"mydissent.net":true,"myeffect.net":true,"mymediapc.net":true,"mypsx.net":true,"mysecuritycamera.com":true,"mysecuritycamera.net":true,"mysecuritycamera.org":true,"net-freaks.com":true,"nflfan.org":true,"nhlfan.net":true,"no-ip.ca":true,"no-ip.co.uk":true,"no-ip.net":true,"noip.us":true,"onthewifi.com":true,"pgafan.net":true,"point2this.com":true,"pointto.us":true,"privatizehealthinsurance.net":true,"quicksytes.com":true,"read-books.org":true,"securitytactics.com":true,"serveexchange.com":true,"servehumour.com":true,"servep2p.com":true,"servesarcasm.com":true,"stufftoread.com":true,"ufcfan.org":true,"unusualperson.com":true,"workisboring.com":true,"3utilities.com":true,"bounceme.net":true,"ddns.net":true,"ddnsking.com":true,"gotdns.ch":true,\
"hopto.org":true,"myftp.biz":true,"myftp.org":true,"myvnc.com":true,"no-ip.biz":true,"no-ip.info":true,"no-ip.org":true,"noip.me":true,"redirectme.net":true,"servebeer.com":true,"serveblog.net":true,"servecounterstrike.com":true,"serveftp.com":true,"servegame.com":true,"servehalflife.com":true,"servehttp.com":true,"serveirc.com":true,"serveminecraft.net":true,"servemp3.com":true,"servepics.com":true,"servequake.com":true,"sytes.net":true,"webhop.me":true,"zapto.org":true,"stage.nodeart.io":true,"nodum.co":true,"nodum.io":true,"nyc.mn":true,"nom.ae":true,"nom.ai":true,"nom.al":true,"nym.by":true,"nym.bz":true,"nom.cl":true,"nom.gd":true,"nom.gl":true,"nym.gr":true,"nom.gt":true,"nom.hn":true,"nom.im":true,"nym.kz":true,"nym.la":true,"nom.li":true,"nym.li":true,"nym.lt":true,"nym.lu":true,"nym.me":true,"nom.mk":true,"nym.mx":true,"nom.nu":true,"nym.nz":true,"nym.pe":true,"nym.pt":true,"nom.pw":true,"nom.qa":true,"nom.rs":true,"nom.si":true,"nym.sk":true,"nym.su":true,"nym.sx":true,"nym.tw":true,"nom.ug":true,"nom.uy":true,"nom.vc":true,"nom.vg":true,"cya.gg":true,"nid.io":true,"opencraft.hosting":true,"operaunite.com":true,"outsystemscloud.com":true,"ownprovider.com":true,"oy.lc":true,"pgfog.com":true,"pagefrontapp.com":true,"art.pl":true,"gliwice.pl":true,"krakow.pl":true,"poznan.pl":true,"wroc.pl":true,"zakopane.pl":true,"pantheonsite.io":true,"gotpantheon.com":true,"mypep.link":true,"on-web.fr":true,"*.platform.sh":true,"*.platformsh.site":true,"xen.prgmr.com":true,"priv.at":true,"protonet.io":true,"chirurgiens-dentistes-en-france.fr":true,"byen.site":true,"qa2.com":true,"dev-myqnapcloud.com":true,"alpha-myqnapcloud.com":true,"myqnapcloud.com":true,"*.quipelements.com":true,"vapor.cloud":true,"vaporcloud.io":true,"rackmaze.com":true,"rackmaze.net":true,"rhcloud.com":true,"resindevice.io":true,"devices.resinstaging.io":true,"hzc.io":true,"wellbeingzone.eu":true,"ptplus.fit":true,"wellbeingzone.co.uk":true,"sandcats.io":true,"logoip.de":true,"logoip.com":true,"schokokeks.net":true,"scrysec.com":true,"firewall-gateway.com":true,"firewall-gateway.de":true,"my-gateway.de":true,"my-router.de":true,"spdns.de":true,"spdns.eu":true,"firewall-gateway.net":true,"my-firewall.org":true,"myfirewall.org":true,"spdns.org":true,"*.s5y.io":true,"*.sensiosite.cloud":true,"biz.ua":true,"co.ua":true,"pp.ua":true,"shiftedit.io":true,"myshopblocks.com":true,"1kapp.com":true,"appchizi.com":true,"applinzi.com":true,"sinaapp.com":true,"vipsinaapp.com":true,"bounty-full.com":true,"alpha.bounty-full.com":true,"beta.bounty-full.com":true,"static.land":true,"dev.static.land":true,"sites.static.land":true,"apps.lair.io":true,"*.stolos.io":true,"spacekit.io":true,"stackspace.space":true,"storj.farm":true,"temp-dns.com":true,"diskstation.me":true,"dscloud.biz":true,"dscloud.me":true,"dscloud.mobi":true,"dsmynas.com":true,"dsmynas.net":true,"dsmynas.org":true,"familyds.com":true,"familyds.net":true,"familyds.org":true,"i234.me":true,"myds.me":true,"synology.me":true,"vpnplus.to":true,"taifun-dns.de":true,"gda.pl":true,"gdansk.pl":true,"gdynia.pl":true,"med.pl":true,"sopot.pl":true,"cust.dev.thingdust.io":true,"cust.disrec.thingdust.io":true,"cust.prod.thingdust.io":true,"cust.testing.thingdust.io":true,"bloxcms.com":true,"townnews-staging.com":true,"12hp.at":true,"2ix.at":true,"4lima.at":true,"lima-city.at":true,"12hp.ch":true,"2ix.ch":true,"4lima.ch":true,"lima-city.ch":true,"trafficplex.cloud":true,"de.cool":true,"12hp.de":true,"2ix.de":true,"4lima.de":true,"lima-city.de":true,"1337.pictures":true,"clan.rip":true,"lima-city.rocks":true,"webspace.rocks":true,"lima.zone":true,"*.transurl.be":true,"*.transurl.eu":true,"*.transurl.nl":true,"tuxfamily.org":true,"dd-dns.de":true,"diskstation.eu":true,"diskstation.org":true,"dray-dns.de":true,"draydns.de":true,"dyn-vpn.de":true,"dynvpn.de":true,"mein-vigor.de":true,"my-vigor.de":true,"my-wan.de":true,"syno-ds.de":true,"synology-diskstation.de":true,"synology-ds.de":true,"uber.space":true,"hk.com":true,\
"hk.org":true,"ltd.hk":true,"inc.hk":true,"lib.de.us":true,"2038.io":true,"router.management":true,"v-info.info":true,"wedeploy.io":true,"wedeploy.me":true,"wedeploy.sh":true,"remotewd.com":true,"wmflabs.org":true,"cistron.nl":true,"demon.nl":true,"xs4all.space":true,"official.academy":true,"yolasite.com":true,"ybo.faith":true,"yombo.me":true,"homelink.one":true,"ybo.party":true,"ybo.review":true,"ybo.science":true,"ybo.trade":true,"za.net":true,"za.org":true,"now.sh":true}'
);
module.exports.index = Object.freeze(index);
//
},
'tough-cookie/lib/store':
function(module, exports) {
//
function Store() {}
exports.Store = Store;

Store.prototype.synchronous = false;

Store.prototype.findCookie = function(domain, path, key, cb) {
  throw new Error('findCookie is not implemented');
};

Store.prototype.findCookies = function(domain, path, cb) {
  throw new Error('findCookies is not implemented');
};

Store.prototype.putCookie = function(cookie, cb) {
  throw new Error('putCookie is not implemented');
};

Store.prototype.updateCookie = function(oldCookie, newCookie, cb) {
  throw new Error('updateCookie is not implemented');
};

Store.prototype.removeCookie = function(domain, path, key, cb) {
  throw new Error('removeCookie is not implemented');
};

Store.prototype.removeCookies = function(domain, path, cb) {
  throw new Error('removeCookies is not implemented');
};

Store.prototype.getAllCookies = function(cb) {
  throw new Error('getAllCookies is not implemented (therefore jar cannot be serialized)');
};
//
},
'tough-cookie/lib/memstore':
function(module, exports, __wpreq__) {
//
var Store = __wpreq__('tough-cookie/lib/store').Store,
  permuteDomain = __wpreq__('tough-cookie/lib/permuteDomain').permuteDomain,
  pathMatch = __wpreq__('tough-cookie/lib/pathMatch').pathMatch,
  util = __wpreq__('util');

function MemoryCookieStore() {
  Store.call(this);
  this.idx = {};
}
util.inherits(MemoryCookieStore, Store);
exports.MemoryCookieStore = MemoryCookieStore;
MemoryCookieStore.prototype.idx = null;

MemoryCookieStore.prototype.synchronous = true;

MemoryCookieStore.prototype.inspect = function() {
  return "{ idx: " + util.inspect(this.idx, false, 2) + ' }';
};

MemoryCookieStore.prototype.findCookie = function(domain, path, key, cb) {
  return this.idx[domain] && this.idx[domain][path]
    ? cb(null, this.idx[domain][path][key] || null)
    : cb(null, void 0);
};

MemoryCookieStore.prototype.findCookies = function(domain, path, cb) {
  var pathMatcher,
    results = [];
  if (!domain) return cb(null, []);

  pathMatcher = path
    ? function(domainIndex) {
        Object.keys(domainIndex).forEach(function(cookiePath) {
          if (pathMatch(path, cookiePath)) {
            var pathIndex = domainIndex[cookiePath];

            for (var key in pathIndex) results.push(pathIndex[key]);
          }
        });
      }
    : function(domainIndex) {
        for (var curPath in domainIndex) {
          var pathIndex = domainIndex[curPath];
          for (var key in pathIndex) results.push(pathIndex[key]);
        }
      };

  var domains = permuteDomain(domain) || [domain],
    idx = this.idx;
  domains.forEach(function(curDomain) {
    var domainIndex = idx[curDomain];
    domainIndex && pathMatcher(domainIndex);
  });

  cb(null, results);
};

MemoryCookieStore.prototype.putCookie = function(cookie, cb) {
  this.idx[cookie.domain] || (this.idx[cookie.domain] = {});

  this.idx[cookie.domain][cookie.path] || (this.idx[cookie.domain][cookie.path] = {});

  this.idx[cookie.domain][cookie.path][cookie.key] = cookie;
  cb(null);
};

MemoryCookieStore.prototype.updateCookie = function(oldCookie, newCookie, cb) {
  this.putCookie(newCookie, cb);
};

MemoryCookieStore.prototype.removeCookie = function(domain, path, key, cb) {
  this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key] && delete this.idx[domain][path][key];

  cb(null);
};

MemoryCookieStore.prototype.removeCookies = function(domain, path, cb) {
  if (this.idx[domain]) path ? delete this.idx[domain][path] : delete this.idx[domain];

  return cb(null);
};

MemoryCookieStore.prototype.getAllCookies = function(cb) {
  var cookies = [],
    idx = this.idx;

  Object.keys(idx).forEach(function(domain) {
    Object.keys(idx[domain]).forEach(function(path) {
      Object.keys(idx[domain][path]).forEach(function(key) {
        key === null || cookies.push(idx[domain][path][key]);
      });
    });
  });

  cookies.sort(function(a, b) {
    return (a.creationIndex || 0) - (b.creationIndex || 0);
  });

  cb(null, cookies);
};
//
},
'tough-cookie/lib/permuteDomain':
function(module, exports, __wpreq__) {
//
var pubsuffix = __wpreq__('tough-cookie/lib/pubsuffix');

function permuteDomain(domain) {
  var pubSuf = pubsuffix.getPublicSuffix(domain);
  if (!pubSuf) return null;
  if (pubSuf == domain) return [domain];

  var parts = domain.slice(0, -(pubSuf.length + 1)).split('.').reverse(),
    cur = pubSuf,
    permutations = [cur];
  while (parts.length) {
    cur = parts.shift() + '.' + cur;
    permutations.push(cur);
  }
  return permutations;
}

exports.permuteDomain = permuteDomain;
//
},
'tough-cookie/lib/pathMatch':
function(module, exports) {
//
function pathMatch(reqPath, cookiePath) {
  if (cookiePath === reqPath) return true;

  if (reqPath.indexOf(cookiePath) === 0) {
    if (cookiePath.substr(-1) === "/") return true;

    if (reqPath.substr(cookiePath.length, 1) === "/") return true;
  }

  return false;
}

exports.pathMatch = pathMatch;
//
},
'tough-cookie/package.json':
function(module) {
//
module.exports = {
  name: 'tough-cookie',
  description: 'RFC6265 Cookies and Cookie Jar for node.js',
  version: '2.3.4'
};
//
},
'request/lib/helpers':
function(module, exports, __wpreq__) {
//
var jsonSafeStringify = __wpreq__('json-stringify-safe'),
  crypto = __wpreq__('crypto'),
  Buffer = __wpreq__('safe-buffer').Buffer,

  defer = typeof setImmediate == 'undefined' ? process.nextTick : setImmediate

function paramsHaveRequestBody(params) {
  return (
    params.body || params.requestBodyStream || (params.json && typeof params.json != 'boolean') || params.multipart
  )
}

function safeStringify(obj, replacer) {
  var ret
  try {
    ret = JSON.stringify(obj, replacer)
  } catch (_e) {
    ret = jsonSafeStringify(obj, replacer)
  }
  return ret
}

function md5(str) {
  return crypto.createHash('md5').update(str).digest('hex')
}

function isReadStream(rs) {
  return rs.readable && rs.path && rs.mode
}

function toBase64(str) {
  return Buffer.from(str || '', 'utf8').toString('base64')
}

function copy(obj) {
  var o = {}
  Object.keys(obj).forEach(function(i) {
    o[i] = obj[i]
  })
  return o
}

function version() {
  var numbers = process.version.replace('v', '').split('.')
  return {major: parseInt(numbers[0], 10), minor: parseInt(numbers[1], 10), patch: parseInt(numbers[2], 10)}
}

exports.paramsHaveRequestBody = paramsHaveRequestBody
exports.safeStringify = safeStringify
exports.md5 = md5
exports.isReadStream = isReadStream
exports.toBase64 = toBase64
exports.copy = copy
exports.version = version
exports.defer = defer
//
},
'json-stringify-safe':
function(module) {
//
(module.exports = stringify).getSerialize = serializer

function stringify(obj, replacer, spaces, cycleReplacer) {
  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)
}

function serializer(replacer, cycleReplacer) {
  var stack = [], keys = []

  if (cycleReplacer == null)
    cycleReplacer = function(key, value) {
      return stack[0] === value ? "[Circular ~]" : "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]"
    }

  return function(key, value) {
    if (stack.length > 0) {
      var thisPos = stack.indexOf(this)
      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)
      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)
      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)
    } else stack.push(value)

    return replacer == null ? value : replacer.call(this, key, value)
  }
}
//
},
'request/request':
function(module, exports, __wpreq__) {
//
var http = __wpreq__('http'),
  https = __wpreq__('https'),
  url = __wpreq__('url'),
  util = __wpreq__('util'),
  stream = __wpreq__('stream'),
  zlib = __wpreq__('zlib'),
  aws2 = __wpreq__('aws-sign2'),
  aws4 = __wpreq__('aws4'),
  httpSignature = __wpreq__('http-signature/lib/signer'),
  mime = __wpreq__('mime-types'),
  caseless = __wpreq__('caseless'),
  ForeverAgent = __wpreq__('forever-agent'),
  FormData = __wpreq__('form-data'),
  extend = __wpreq__('extend'),
  isstream = __wpreq__('isstream'),
  isTypedArray = __wpreq__('is-typedarray').strict,
  helpers = __wpreq__('request/lib/helpers'),
  cookies = __wpreq__('request/lib/cookies'),
  getProxyFromURI = __wpreq__('request/lib/getProxyFromURI'),
  Querystring = __wpreq__('request/lib/querystring').Querystring,
  Har = __wpreq__('request/lib/har').Har,
  Auth = __wpreq__('request/lib/auth').Auth,
  OAuth = __wpreq__('request/lib/oauth').OAuth,
  hawk = __wpreq__('request/lib/hawk'),
  Multipart = __wpreq__('request/lib/multipart').Multipart,
  Redirect = __wpreq__('request/lib/redirect').Redirect,
  Tunnel = __wpreq__('request/lib/tunnel').Tunnel,
  now = __wpreq__('performance-now'),
  Buffer = __wpreq__('safe-buffer').Buffer,

  safeStringify = helpers.safeStringify,
  isReadStream = helpers.isReadStream,
  toBase64 = helpers.toBase64,
  defer = helpers.defer,
  copy = helpers.copy,
  version = helpers.version,
  globalCookieJar = cookies.jar(),

  globalPool = {}

function filterForNonReserved(reserved, options) {
  var object = {}
  for (var i in options) if (reserved.indexOf(i) < 0) object[i] = options[i]

  return object
}

function filterOutReservedFunctions(reserved, options) {
  var object = {}
  for (var i in options) {
    var isReserved = reserved.indexOf(i) > -1,
      isFunction = typeof options[i] == 'function';
    (isReserved && isFunction) || (object[i] = options[i])
  }
  return object
}

function requestToJSON() {
  var self = this
  return {uri: self.uri, method: self.method, headers: self.headers}
}

function responseToJSON() {
  var self = this
  return {
    statusCode: self.statusCode,
    body: self.body,
    headers: self.headers,
    request: requestToJSON.call(self.request)
  }
}

/** @prop {*} body */
function Request(options) {
  var self = this

  if (options.har) {
    self._har = new Har(self)
    options = self._har.options(options)
  }

  stream.Stream.call(self)
  var reserved = Object.keys(Request.prototype),
    nonReserved = filterForNonReserved(reserved, options)

  extend(self, nonReserved)
  options = filterOutReservedFunctions(reserved, options)

  self.readable = true
  self.writable = true
  if (options.method) self.explicitMethod = true

  self._qs = new Querystring(self)
  self._auth = new Auth(self)
  self._oauth = new OAuth(self)
  self._multipart = new Multipart(self)
  self._redirect = new Redirect(self)
  self._tunnel = new Tunnel(self)
  self.init(options)
}

util.inherits(Request, stream.Stream)

Request.debug = process.env.NODE_DEBUG && /\brequest\b/.test(process.env.NODE_DEBUG)
function debug() {
  Request.debug && console.error('REQUEST %s', util.format.apply(util, arguments))
}
Request.prototype.debug = debug

Request.prototype.init = function(options) {
  var self = this
  options || (options = {})
  self.headers = self.headers ? copy(self.headers) : {}

  for (var headerName in self.headers) self.headers[headerName] !== void 0 || delete self.headers[headerName]

  caseless.httpify(self, self.headers)

  self.method || (self.method = options.method || 'GET')
  self.localAddress || (self.localAddress = options.localAddress)

  self._qs.init(options)

  debug(options)
  self.pool || self.pool === false || (self.pool = globalPool)
  self.dests = self.dests || []
  self.__isRequestRequest = true

  if (!self._callback && self.callback) {
    self._callback = self.callback
    self.callback = function() {
      if (self._callbackCalled) return

      self._callbackCalled = true
      self._callback.apply(self, arguments)
    }
    self.on('error', self.callback.bind())
    self.on('complete', self.callback.bind(self, null))
  }

  if (!self.uri && self.url) {
    self.uri = self.url
    delete self.url
  }

  if (self.baseUrl) {
    if (typeof self.baseUrl != 'string') return self.emit('error', new Error('options.baseUrl must be a string'))

    if (typeof self.uri != 'string')
      return self.emit('error', new Error('options.uri must be a string when using options.baseUrl'))

    if (self.uri.indexOf('//') === 0 || self.uri.indexOf('://') > -1)
      return self.emit('error', new Error('options.uri must be a path when using options.baseUrl'))

    var baseUrlEndsWithSlash = self.baseUrl.lastIndexOf('/') === self.baseUrl.length - 1,
      uriStartsWithSlash = self.uri.indexOf('/') === 0

    baseUrlEndsWithSlash && uriStartsWithSlash
      ? (self.uri = self.baseUrl + self.uri.slice(1))
      : baseUrlEndsWithSlash || uriStartsWithSlash
      ? (self.uri = self.baseUrl + self.uri)
      : self.uri === ''
      ? (self.uri = self.baseUrl)
      : (self.uri = self.baseUrl + '/' + self.uri)

    delete self.baseUrl
  }

  if (!self.uri) return self.emit('error', new Error('options.uri is a required argument'))

  if (typeof self.uri == 'string') self.uri = url.parse(self.uri)

  self.uri.href || (self.uri.href = url.format(self.uri))

  if (self.uri.protocol === 'unix:')
    return self.emit('error',
      new Error('`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`')
    )

  self.uri.host !== 'unix' || self.enableUnixSocket()

  if (self.strictSSL === false) self.rejectUnauthorized = false

  self.uri.pathname || (self.uri.pathname = '/')

  if (!(self.uri.host || (self.uri.hostname && self.uri.port) || self.uri.isUnix)) {
    var message = 'Invalid URI "' + url.format(self.uri) + '"'
    if (Object.keys(options).length === 0) message += '. This can be caused by a crappy redirection.'

    self.abort()
    return self.emit('error', new Error(message))
  }

  self.hasOwnProperty('proxy') || (self.proxy = getProxyFromURI(self.uri))

  self.tunnel = self._tunnel.isEnabled()
  self.proxy && self._tunnel.setup(options)

  self._redirect.onRequest(options)

  self.setHost = false
  if (!self.hasHeader('host')) {
    var hostHeaderName = self.originalHostHeaderName || 'host'
    self.setHeader(hostHeaderName, self.uri.host)
    self.setHost = true
  }

  self.jar(self._jar || options.jar)

  if (!self.uri.port)
    if (self.uri.protocol === 'http:') self.uri.port = 80
    else if (self.uri.protocol === 'https:') self.uri.port = 443

  if (self.proxy && !self.tunnel) {
    self.port = self.proxy.port
    self.host = self.proxy.hostname
  } else {
    self.port = self.uri.port
    self.host = self.uri.hostname
  }

  options.form && self.form(options.form)

  if (options.formData) {
    var formData = options.formData,
      requestForm = self.form()
    var appendFormValue = function(key, value) {
      value && value.hasOwnProperty('value') && value.hasOwnProperty('options')
        ? requestForm.append(key, value.value, value.options)
        : requestForm.append(key, value)
    }
    for (var formKey in formData)
      if (formData.hasOwnProperty(formKey)) {
        var formValue = formData[formKey]
        if (formValue instanceof Array)
          for (var j = 0; j < formValue.length; j++) appendFormValue(formKey, formValue[j])
        else appendFormValue(formKey, formValue)
      }
  }

  options.qs && self.qs(options.qs)

  self.uri.path ? (self.path = self.uri.path) : (self.path = self.uri.pathname + (self.uri.search || ''))

  if (self.path.length === 0) self.path = '/'

  options.aws && self.aws(options.aws)

  options.hawk && self.hawk(options.hawk)

  options.httpSignature && self.httpSignature(options.httpSignature)

  if (options.auth) {
    if (Object.prototype.hasOwnProperty.call(options.auth, 'username')) options.auth.user = options.auth.username
    if (Object.prototype.hasOwnProperty.call(options.auth, 'password')) options.auth.pass = options.auth.password

    self.auth(options.auth.user, options.auth.pass, options.auth.sendImmediately, options.auth.bearer)
  }

  !self.gzip || self.hasHeader('accept-encoding') || self.setHeader('accept-encoding', 'gzip, deflate')

  if (self.uri.auth && !self.hasHeader('authorization')) {
    var uriAuthPieces = self.uri.auth.split(':').map(function(item) { return self._qs.unescape(item) })
    self.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(':'), true)
  }

  if (!self.tunnel && self.proxy && self.proxy.auth && !self.hasHeader('proxy-authorization')) {
    var proxyAuthPieces = self.proxy.auth.split(':').map(function(item) { return self._qs.unescape(item) })
    var authHeader = 'Basic ' + toBase64(proxyAuthPieces.join(':'))
    self.setHeader('proxy-authorization', authHeader)
  }

  if (self.proxy && !self.tunnel) self.path = self.uri.protocol + '//' + self.uri.host + self.path

  options.json && self.json(options.json)
  options.multipart && self.multipart(options.multipart)

  if (options.time) {
    self.timing = true

    self.elapsedTime = self.elapsedTime || 0
  }

  function setContentLength() {
    if (isTypedArray(self.body)) self.body = Buffer.from(self.body)

    if (!self.hasHeader('content-length')) {
      var length =
        typeof self.body == 'string'
          ? Buffer.byteLength(self.body)
          : Array.isArray(self.body)
          ? self.body.reduce(function(a, b) { return a + b.length }, 0)
          : self.body.length

      length
        ? self.setHeader('content-length', length)
        : self.emit('error', new Error('Argument error, options.body.'))
    }
  }
  !self.body || isstream(self.body) || setContentLength()

  options.oauth
    ? self.oauth(options.oauth)
    : self._oauth.params && self.hasHeader('authorization') && self.oauth(self._oauth.params)

  var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol,
    defaultModules = {'http:': http, 'https:': https},
    httpModules = self.httpModules || {}

  self.httpModule = httpModules[protocol] || defaultModules[protocol]

  if (!self.httpModule) return self.emit('error', new Error('Invalid protocol: ' + protocol))

  if (options.ca) self.ca = options.ca

  if (!self.agent) {
    if (options.agentOptions) self.agentOptions = options.agentOptions

    if (options.agentClass) self.agentClass = options.agentClass
    else if (options.forever) {
      var v = version()
      if (v.major === 0 && v.minor <= 10) self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL
      else {
        self.agentClass = self.httpModule.Agent
        self.agentOptions = self.agentOptions || {}
        self.agentOptions.keepAlive = true
      }
    } else self.agentClass = self.httpModule.Agent
  }

  self.pool === false ? (self.agent = false) : (self.agent = self.agent || self.getNewAgent())

  self.on('pipe', function(src) {
    self.ntick && self._started &&
      self.emit('error', new Error('You cannot pipe to this stream after the outbound request has started.'))

    self.src = src
    if (isReadStream(src)) self.hasHeader('content-type') || self.setHeader('content-type', mime.lookup(src.path))
    else {
      if (src.headers) for (var i in src.headers) self.hasHeader(i) || self.setHeader(i, src.headers[i])

      !self._json || self.hasHeader('content-type') || self.setHeader('content-type', 'application/json')

      if (src.method && !self.explicitMethod) self.method = src.method
    }
  })

  defer(function() {
    if (self._aborted) return

    var end = function() {
      if (self._form)
        self._auth.hasAuth
          ? self._auth.hasAuth && self._auth.sentAuth && self._form.pipe(self)
          : self._form.pipe(self)

      self._multipart && self._multipart.chunked && self._multipart.body.pipe(self)

      if (self.body)
        if (isstream(self.body)) self.body.pipe(self)
        else {
          setContentLength()
          Array.isArray(self.body)
            ? self.body.forEach(function(part) {
                self.write(part)
              })
            : self.write(self.body)

          self.end()
        }
      else if (self.requestBodyStream) {
        console.warn('options.requestBodyStream is deprecated, please pass the request object to stream.pipe.')
        self.requestBodyStream.pipe(self)
      } else if (!self.src) {
        if (self._auth.hasAuth && !self._auth.sentAuth) {
          self.end()
          return
        }
        self.method === 'GET' || self.method === void 0 || self.setHeader('content-length', 0)

        self.end()
      }
    }

    if (self._form && !self.hasHeader('content-length')) {
      self.setHeader(self._form.getHeaders(), true)
      self._form.getLength(function(err, length) {
        err || isNaN(length) || self.setHeader('content-length', length)

        end()
      })
    } else end()

    self.ntick = true
  })
}

Request.prototype.getNewAgent = function() {
  var self = this,
    Agent = self.agentClass,
    options = {}
  if (self.agentOptions) for (var i in self.agentOptions) options[i] = self.agentOptions[i]

  if (self.ca) options.ca = self.ca
  if (self.ciphers) options.ciphers = self.ciphers
  if (self.secureProtocol) options.secureProtocol = self.secureProtocol
  if (self.secureOptions) options.secureOptions = self.secureOptions
  if (self.rejectUnauthorized !== void 0) options.rejectUnauthorized = self.rejectUnauthorized

  if (self.cert && self.key) {
    options.key = self.key
    options.cert = self.cert
  }

  if (self.pfx) options.pfx = self.pfx
  if (self.passphrase) options.passphrase = self.passphrase

  var poolKey = ''
  if (Agent !== self.httpModule.Agent) poolKey += Agent.name

  var proxy = self.proxy
  if (typeof proxy == 'string') proxy = url.parse(proxy)

  if ((proxy && proxy.protocol === 'https:') || this.uri.protocol === 'https:') {
    if (options.ca) {
      if (poolKey) poolKey += ':'
      poolKey += options.ca
    }

    if (options.rejectUnauthorized !== void 0) {
      if (poolKey) poolKey += ':'
      poolKey += options.rejectUnauthorized
    }

    if (options.cert) {
      if (poolKey) poolKey += ':'
      poolKey += options.cert.toString('ascii') + options.key.toString('ascii')
    }

    if (options.pfx) {
      if (poolKey) poolKey += ':'
      poolKey += options.pfx.toString('ascii')
    }

    if (options.ciphers) {
      if (poolKey) poolKey += ':'
      poolKey += options.ciphers
    }

    if (options.secureProtocol) {
      if (poolKey) poolKey += ':'
      poolKey += options.secureProtocol
    }

    if (options.secureOptions) {
      if (poolKey) poolKey += ':'
      poolKey += options.secureOptions
    }
  }

  if (self.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self.httpModule.globalAgent)
    return self.httpModule.globalAgent

  poolKey = self.uri.protocol + poolKey

  if (!self.pool[poolKey]) {
    self.pool[poolKey] = new Agent(options)
    if (self.pool.maxSockets) self.pool[poolKey].maxSockets = self.pool.maxSockets
  }

  return self.pool[poolKey]
}

Request.prototype.start = function() {
  var self = this

  if (self.timing)
    var startTime = new Date().getTime(),
      startTimeNow = now()

  if (self._aborted) return

  self._started = true
  self.method = self.method || 'GET'
  self.href = self.uri.href

  self.src && self.src.stat && self.src.stat.size && !self.hasHeader('content-length') &&
    self.setHeader('content-length', self.src.stat.size)

  self._aws && self.aws(self._aws, true)

  var reqOptions = copy(self)
  delete reqOptions.auth

  debug('make request', self.uri.href)

  delete reqOptions.timeout

  try {
    self.req = self.httpModule.request(reqOptions)
  } catch (err) {
    self.emit('error', err)
    return
  }

  if (self.timing) {
    self.startTime = startTime
    self.startTimeNow = startTimeNow

    self.timings = {}
  }

  var timeout
  if (self.timeout && !self.timeoutTimer)
    if (self.timeout < 0) timeout = 0
    else if (typeof self.timeout == 'number' && isFinite(self.timeout)) timeout = self.timeout

  self.req.on('response', self.onRequestResponse.bind(self))
  self.req.on('error', self.onRequestError.bind(self))
  self.req.on('drain', function() {
    self.emit('drain')
  })

  self.req.on('socket', function(socket) {
    var isConnecting = socket._connecting || socket.connecting
    if (self.timing) {
      self.timings.socket = now() - self.startTimeNow

      if (isConnecting) {
        var onLookupTiming = function() {
          self.timings.lookup = now() - self.startTimeNow
        }

        var onConnectTiming = function() {
          self.timings.connect = now() - self.startTimeNow
        }

        socket.once('lookup', onLookupTiming)
        socket.once('connect', onConnectTiming)

        self.req.once('error', function() {
          socket.removeListener('lookup', onLookupTiming)
          socket.removeListener('connect', onConnectTiming)
        })
      }
    }

    var setReqTimeout = function() {
      self.req.setTimeout(timeout, function() {
        if (self.req) {
          self.abort()
          var e = new Error('ESOCKETTIMEDOUT')
          e.code = 'ESOCKETTIMEDOUT'
          e.connect = false
          self.emit('error', e)
        }
      })
    }
    if (timeout !== void 0)
      if (isConnecting) {
        var onReqSockConnect = function() {
          socket.removeListener('connect', onReqSockConnect)
          clearTimeout(self.timeoutTimer)
          self.timeoutTimer = null
          setReqTimeout()
        }

        socket.on('connect', onReqSockConnect)

        self.req.on('error', function(err) {
          socket.removeListener('connect', onReqSockConnect)
        })

        self.timeoutTimer = setTimeout(function() {
          socket.removeListener('connect', onReqSockConnect)
          self.abort()
          var e = new Error('ETIMEDOUT')
          e.code = 'ETIMEDOUT'
          e.connect = true
          self.emit('error', e)
        }, timeout)
      } else setReqTimeout()

    self.emit('socket', socket)
  })

  self.emit('request', self.req)
}

Request.prototype.onRequestError = function(error) {
  var self = this
  if (self._aborted) return

  if (self.req && self.req._reusedSocket && error.code === 'ECONNRESET' && self.agent.addRequestNoreuse) {
    self.agent = {addRequest: self.agent.addRequestNoreuse.bind(self.agent)}
    self.start()
    self.req.end()
    return
  }
  if (self.timeout && self.timeoutTimer) {
    clearTimeout(self.timeoutTimer)
    self.timeoutTimer = null
  }
  self.emit('error', error)
}

Request.prototype.onRequestResponse = function(response) {
  var self = this

  if (self.timing) self.timings.response = now() - self.startTimeNow

  debug('onRequestResponse', self.uri.href, response.statusCode, response.headers)
  response.on('end', function() {
    if (self.timing) {
      self.timings.end = now() - self.startTimeNow
      response.timingStart = self.startTime

      self.timings.socket || (self.timings.socket = 0)
      self.timings.lookup || (self.timings.lookup = self.timings.socket)
      self.timings.connect || (self.timings.connect = self.timings.lookup)
      self.timings.response || (self.timings.response = self.timings.connect)

      debug('elapsed time', self.timings.end)

      self.elapsedTime += Math.round(self.timings.end)

      response.elapsedTime = self.elapsedTime
      response.timings = self.timings

      response.timingPhases = {
        wait: self.timings.socket,
        dns: self.timings.lookup - self.timings.socket,
        tcp: self.timings.connect - self.timings.lookup,
        firstByte: self.timings.response - self.timings.connect,
        download: self.timings.end - self.timings.response,
        total: self.timings.end
      }
    }
    debug('response end', self.uri.href, response.statusCode, response.headers)
  })

  if (self._aborted) {
    debug('aborted', self.uri.href)
    response.resume()
    return
  }

  self.response = response
  response.request = self
  response.toJSON = responseToJSON

  if (
    self.httpModule === https &&
    self.strictSSL &&
    !(response.hasOwnProperty('socket') && response.socket.authorized)
  ) {
    debug('strict ssl error', self.uri.href)
    var sslErr = response.hasOwnProperty('socket')
      ? response.socket.authorizationError
      : self.uri.href + ' does not support SSL'
    self.emit('error', new Error('SSL Error: ' + sslErr))
    return
  }

  self.originalHost = self.getHeader('host')
  self.originalHostHeaderName || (self.originalHostHeaderName = self.hasHeader('host'))
  self.setHost && self.removeHeader('host')

  if (self.timeout && self.timeoutTimer) {
    clearTimeout(self.timeoutTimer)
    self.timeoutTimer = null
  }

  var targetCookieJar = self._jar && self._jar.setCookie ? self._jar : globalCookieJar
  var addCookie = function(cookie) {
    try {
      targetCookieJar.setCookie(cookie, self.uri.href, {ignoreError: true})
    } catch (e) {
      self.emit('error', e)
    }
  }

  response.caseless = caseless(response.headers)

  if (response.caseless.has('set-cookie') && !self._disableCookies) {
    var headerName = response.caseless.has('set-cookie')
    Array.isArray(response.headers[headerName])
      ? response.headers[headerName].forEach(addCookie)
      : addCookie(response.headers[headerName])
  }

  if (self._redirect.onResponse(response)) return

  response.on('close', function() {
    self._ended || self.response.emit('end')
  })

  response.once('end', function() {
    self._ended = true
  })

  var noBody = function(code) {
    return self.method === 'HEAD' || (code >= 100 && code < 200) || code === 204 || code === 304
  }

  var responseContent
  if (self.gzip && !noBody(response.statusCode)) {
    var contentEncoding = response.headers['content-encoding'] || 'identity'
    contentEncoding = contentEncoding.trim().toLowerCase()

    var zlibOptions = {flush: zlib.Z_SYNC_FLUSH, finishFlush: zlib.Z_SYNC_FLUSH}

    if (contentEncoding === 'gzip') {
      responseContent = zlib.createGunzip(zlibOptions)
      response.pipe(responseContent)
    } else if (contentEncoding === 'deflate') {
      responseContent = zlib.createInflate(zlibOptions)
      response.pipe(responseContent)
    } else {
      contentEncoding === 'identity' || debug('ignoring unrecognized Content-Encoding ' + contentEncoding)

      responseContent = response
    }
  } else responseContent = response

  if (self.encoding)
    self.dests.length > 0
      ? console.error(
          'Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.'
        )
      : responseContent.setEncoding(self.encoding)

  self._paused && responseContent.pause()

  self.responseContent = responseContent

  self.emit('response', response)

  self.dests.forEach(function(dest) {
    self.pipeDest(dest)
  })

  responseContent.on('data', function(chunk) {
    if (self.timing && !self.responseStarted) {
      self.responseStartTime = new Date().getTime()

      response.responseStartTime = self.responseStartTime
    }
    self._destdata = true
    self.emit('data', chunk)
  })
  responseContent.once('end', function(chunk) {
    self.emit('end', chunk)
  })
  responseContent.on('error', function(error) {
    self.emit('error', error)
  })
  responseContent.on('close', function() { self.emit('close') })

  self.callback
    ? self.readResponseBody(response)
    : self.on('end', function() {
        self._aborted ? debug('aborted', self.uri.href) : self.emit('complete', response)
      })

  debug('finish init function', self.uri.href)
}

Request.prototype.readResponseBody = function(response) {
  var self = this
  debug("reading response's body")
  var buffers = [],
    bufferLength = 0,
    strings = []

  self.on('data', function(chunk) {
    if (!Buffer.isBuffer(chunk)) strings.push(chunk)
    else if (chunk.length) {
      bufferLength += chunk.length
      buffers.push(chunk)
    }
  })
  self.on('end', function() {
    debug('end event', self.uri.href)
    if (self._aborted) {
      debug('aborted', self.uri.href)
      buffers = []
      bufferLength = 0
      return
    }

    if (bufferLength) {
      debug('has body', self.uri.href, bufferLength)
      response.body = Buffer.concat(buffers, bufferLength)
      if (self.encoding !== null) response.body = response.body.toString(self.encoding)

      buffers = []
      bufferLength = 0
    } else if (strings.length) {
      if (self.encoding === 'utf8' && strings[0].length > 0 && strings[0][0] === '\uFEFF')
        strings[0] = strings[0].substring(1)

      response.body = strings.join('')
    }

    if (self._json)
      try {
        response.body = JSON.parse(response.body, self._jsonReviver)
      } catch (_e) {
        debug('invalid JSON received', self.uri.href)
      }

    debug('emitting complete', self.uri.href)
    response.body !== void 0 || self._json || (response.body = self.encoding === null ? Buffer.alloc(0) : '')

    self.emit('complete', response, response.body)
  })
}

Request.prototype.abort = function() {
  var self = this
  self._aborted = true

  self.req ? self.req.abort() : self.response && self.response.destroy()

  self.emit('abort')
}

Request.prototype.pipeDest = function(dest) {
  var self = this,
    response = self.response
  if (dest.headers && !dest.headersSent) {
    if (response.caseless.has('content-type')) {
      var ctname = response.caseless.has('content-type')
      dest.setHeader
        ? dest.setHeader(ctname, response.headers[ctname])
        : (dest.headers[ctname] = response.headers[ctname])
    }

    if (response.caseless.has('content-length')) {
      var clname = response.caseless.has('content-length')
      dest.setHeader
        ? dest.setHeader(clname, response.headers[clname])
        : (dest.headers[clname] = response.headers[clname])
    }
  }
  if (dest.setHeader && !dest.headersSent) {
    for (var i in response.headers) (self.gzip && i === 'content-encoding') || dest.setHeader(i, response.headers[i])

    dest.statusCode = response.statusCode
  }
  self.pipefilter && self.pipefilter(response, dest)
}

Request.prototype.qs = function(q, clobber) {
  var self = this,
    base = !clobber && self.uri.query ? self._qs.parse(self.uri.query) : {}

  for (var i in q) base[i] = q[i]

  var qs = self._qs.stringify(base)

  if (qs === '') return self

  self.uri = url.parse(self.uri.href.split('?')[0] + '?' + qs)
  self.url = self.uri
  self.path = self.uri.path

  self.uri.host !== 'unix' || self.enableUnixSocket()

  return self
}
Request.prototype.form = function(form) {
  var self = this
  if (form) {
    /^application\/x-www-form-urlencoded\b/.test(self.getHeader('content-type')) ||
      self.setHeader('content-type', 'application/x-www-form-urlencoded')

    self.body =
      typeof form == 'string' ? self._qs.rfc3986(form.toString('utf8')) : self._qs.stringify(form).toString('utf8')
    return self
  }
  self._form = new FormData()
  self._form.on('error', function(err) {
    err.message = 'form-data: ' + err.message
    self.emit('error', err)
    self.abort()
  })
  return self._form
}
Request.prototype.multipart = function(multipart) {
  var self = this

  self._multipart.onRequest(multipart)

  self._multipart.chunked || (self.body = self._multipart.body)

  return self
}
Request.prototype.json = function(val) {
  var self = this

  self.hasHeader('accept') || self.setHeader('accept', 'application/json')

  if (typeof self.jsonReplacer == 'function') self._jsonReplacer = self.jsonReplacer

  self._json = true
  if (typeof val == 'boolean') {
    if (self.body !== void 0) {
      /^application\/x-www-form-urlencoded\b/.test(self.getHeader('content-type'))
        ? (self.body = self._qs.rfc3986(self.body))
        : (self.body = safeStringify(self.body, self._jsonReplacer))

      self.hasHeader('content-type') || self.setHeader('content-type', 'application/json')
    }
  } else {
    self.body = safeStringify(val, self._jsonReplacer)
    self.hasHeader('content-type') || self.setHeader('content-type', 'application/json')
  }

  if (typeof self.jsonReviver == 'function') self._jsonReviver = self.jsonReviver

  return self
}
Request.prototype.getHeader = function(name, headers) {
  var result, re
  headers || (headers = this.headers)

  Object.keys(headers).forEach(function(key) {
    if (key.length !== name.length) return

    re = new RegExp(name, 'i')
    if (key.match(re)) result = headers[key]
  })
  return result
}
Request.prototype.enableUnixSocket = function() {
  var unixParts = this.uri.path.split(':'),
    host = unixParts[0],
    path = unixParts[1]
  this.socketPath = host
  this.uri.pathname = path
  this.uri.path = path
  this.uri.host = host
  this.uri.hostname = host
  this.uri.isUnix = true
}

Request.prototype.auth = function(user, pass, sendImmediately, bearer) {
  var self = this

  self._auth.onRequest(user, pass, sendImmediately, bearer)

  return self
}
Request.prototype.aws = function(opts, now) {
  var self = this

  if (!now) {
    self._aws = opts
    return self
  }

  if (opts.sign_version === 4 || opts.sign_version === '4') {
    var options = {
      host: self.uri.host,
      path: self.uri.path,
      method: self.method,
      headers: {'content-type': self.getHeader('content-type') || ''},
      body: self.body
    }
    var signRes = aws4.sign(options, {
      accessKeyId: opts.key,
      secretAccessKey: opts.secret,
      sessionToken: opts.session
    })
    self.setHeader('authorization', signRes.headers.Authorization)
    self.setHeader('x-amz-date', signRes.headers['X-Amz-Date'])
    signRes.headers['X-Amz-Security-Token'] &&
      self.setHeader('x-amz-security-token', signRes.headers['X-Amz-Security-Token'])
  } else {
    var date = new Date()
    self.setHeader('date', date.toUTCString())
    var auth = {
      key: opts.key,
      secret: opts.secret,
      verb: self.method.toUpperCase(),
      date: date,
      contentType: self.getHeader('content-type') || '',
      md5: self.getHeader('content-md5') || '',
      amazonHeaders: aws2.canonicalizeHeaders(self.headers)
    }
    var path = self.uri.path
    opts.bucket && path
      ? (auth.resource = '/' + opts.bucket + path)
      : opts.bucket && !path
      ? (auth.resource = '/' + opts.bucket)
      : !opts.bucket && path
      ? (auth.resource = path)
      : opts.bucket || path || (auth.resource = '/')

    auth.resource = aws2.canonicalizeResource(auth.resource)
    self.setHeader('authorization', aws2.authorization(auth))
  }

  return self
}
Request.prototype.httpSignature = function(opts) {
  var self = this
  httpSignature.signRequest({
    getHeader: function(header) {
      return self.getHeader(header, self.headers)
    },
    setHeader: function(header, value) {
      self.setHeader(header, value)
    },
    method: self.method,
    path: self.path
  }, opts)
  debug('httpSignature authorization', self.getHeader('authorization'))

  return self
}
Request.prototype.hawk = function(opts) {
  var self = this
  self.setHeader('Authorization', hawk.header(self.uri, self.method, opts))
}
Request.prototype.oauth = function(_oauth) {
  var self = this

  self._oauth.onRequest(_oauth)

  return self
}

Request.prototype.jar = function(jar) {
  var cookies,
    self = this

  if (self._redirect.redirectsFollowed === 0) self.originalCookieHeader = self.getHeader('cookie')

  if (jar) {
    var targetCookieJar = jar && jar.getCookieString ? jar : globalCookieJar,
      urihref = self.uri.href
    if (targetCookieJar) cookies = targetCookieJar.getCookieString(urihref)
  } else {
    cookies = false
    self._disableCookies = true
  }

  if (cookies && cookies.length)
    self.originalCookieHeader
      ? self.setHeader('cookie', self.originalCookieHeader + '; ' + cookies)
      : self.setHeader('cookie', cookies)

  self._jar = jar
  return self
}

Request.prototype.pipe = function(dest, opts) {
  var self = this

  if (!self.response) {
    self.dests.push(dest)
    stream.Stream.prototype.pipe.call(self, dest, opts)
    return dest
  }

  if (self._destdata) self.emit('error', new Error('You cannot pipe after data has been emitted from the response.'))
  else if (!self._ended) {
    stream.Stream.prototype.pipe.call(self, dest, opts)
    self.pipeDest(dest)
    return dest
  } else self.emit('error', new Error('You cannot pipe after the response has been ended.'))
}
Request.prototype.write = function() {
  var self = this
  if (self._aborted) return

  self._started || self.start()
  if (self.req) return self.req.write.apply(self.req, arguments)
}
Request.prototype.end = function(chunk) {
  var self = this
  if (self._aborted) return

  chunk && self.write(chunk)
  self._started || self.start()
  self.req && self.req.end()
}
Request.prototype.pause = function() {
  var self = this
  self.responseContent ? self.responseContent.pause.apply(self.responseContent, arguments) : (self._paused = true)
}
Request.prototype.resume = function() {
  var self = this
  self.responseContent ? self.responseContent.resume.apply(self.responseContent, arguments) : (self._paused = false)
}
Request.prototype.destroy = function() {
  var self = this
  self._ended ? self.response && self.response.destroy() : self.end()
}

Request.defaultProxyHeaderWhiteList = Tunnel.defaultProxyHeaderWhiteList.slice()

Request.defaultProxyHeaderExclusiveList = Tunnel.defaultProxyHeaderExclusiveList.slice()

Request.prototype.toJSON = requestToJSON
module.exports = Request
//
},
http:
function(module) {
//
module.exports = require('http');
//
},
https:
function(module) {
//
module.exports = require('https');
//
},
'aws-sign2':
function(module, exports, __wpreq__) {
//
var crypto = __wpreq__('crypto'),
  parse = __wpreq__('url').parse;

var keys = [
  'acl',
  'location',
  'logging',
  'notification',
  'partNumber',
  'policy',
  'requestPayment',
  'torrent',
  'uploadId',
  'uploads',
  'versionId',
  'versioning',
  'versions',
  'website'
]

function authorization(options) {
  return 'AWS ' + options.key + ':' + sign(options)
}

module.exports = authorization
module.exports.authorization = authorization

function hmacSha1(options) {
  return crypto.createHmac('sha1', options.secret).update(options.message).digest('base64')
}

module.exports.hmacSha1 = hmacSha1

function sign(options) {
  options.message = stringToSign(options)
  return hmacSha1(options)
}
module.exports.sign = sign

function signQuery(options) {
  options.message = queryStringToSign(options)
  return hmacSha1(options)
}
module.exports.signQuery = signQuery

function stringToSign(options) {
  var headers = options.amazonHeaders || ''
  if (headers) headers += '\n'
  return [
    options.verb,
    options.md5,
    options.contentType,
    options.date ? options.date.toUTCString() : '',
    headers + options.resource
  ].join('\n')
}
module.exports.stringToSign = stringToSign

function queryStringToSign(options) {
  return 'GET\n\n\n' + options.date + '\n' + options.resource
}
module.exports.queryStringToSign = queryStringToSign

function canonicalizeHeaders(headers) {
  var buf = [];
  for (var fields = Object.keys(headers), i = 0, len = fields.length; i < len; ++i) {
    var field = fields[i],
      val = headers[field];
    0 !== (field = field.toLowerCase()).indexOf('x-amz') || buf.push(field + ':' + val)
  }
  return buf.sort().join('\n')
}
module.exports.canonicalizeHeaders = canonicalizeHeaders

function canonicalizeResource(resource) {
  var url = parse(resource, true),
    path = url.pathname,
    buf = [];

  Object.keys(url.query).forEach(function(key) {
    if (!~keys.indexOf(key)) return
    var val = '' == url.query[key] ? '' : '=' + encodeURIComponent(url.query[key])
    buf.push(key + val)
  })

  return path + (buf.length ? '?' + buf.sort().join('&') : '')
}
module.exports.canonicalizeResource = canonicalizeResource
//
},
aws4:
function(module, exports, __wpreq__) {
//
var aws4 = exports,
  url = __wpreq__('url'),
  querystring = __wpreq__('querystring'),
  crypto = __wpreq__('crypto'),
  credentialsCache = __wpreq__('aws4/lru')(1000)

function hmac(key, string, encoding) {
  return crypto.createHmac('sha256', key).update(string, 'utf8').digest(encoding)
}

function hash(string, encoding) {
  return crypto.createHash('sha256').update(string, 'utf8').digest(encoding)
}

function encodeRfc3986(urlEncodedString) {
  return urlEncodedString.replace(/[!'()*]/g, function(c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

function RequestSigner(request, credentials) {
  if (typeof request == 'string') request = url.parse(request)

  var headers = (request.headers = request.headers || {}),
    hostParts = this.matchHost(request.hostname || request.host || headers.Host || headers.host)

  this.request = request
  this.credentials = credentials || this.defaultCredentials()

  this.service = request.service || hostParts[0] || ''
  this.region = request.region || hostParts[1] || 'us-east-1'

  if (this.service === 'email') this.service = 'ses'

  if (!request.method && request.body) request.method = 'POST'

  if (!headers.Host && !headers.host) {
    headers.Host = request.hostname || request.host || this.createHost()

    if (request.port) headers.Host += ':' + request.port
  }
  request.hostname || request.host || (request.hostname = headers.Host || headers.host)

  this.isCodeCommitGit = this.service === 'codecommit' && request.method === 'GIT'
}

RequestSigner.prototype.matchHost = function(host) {
  var hostParts = ((host || '').match(/([^.]+)\.(?:([^.]*)\.)?amazonaws\.com$/) || []).slice(1, 3)

  if (hostParts[1] === 'es') hostParts = hostParts.reverse()

  return hostParts
}

RequestSigner.prototype.isSingleRegion = function() {
  return (
    (['s3', 'sdb'].indexOf(this.service) >= 0 && this.region === 'us-east-1') ||
    ['cloudfront', 'ls', 'route53', 'iam', 'importexport', 'sts'].indexOf(this.service) >= 0
  )
}

RequestSigner.prototype.createHost = function() {
  var region = this.isSingleRegion()
    ? ''
    : (this.service === 's3' && this.region !== 'us-east-1' ? '-' : '.') + this.region
  return (this.service === 'ses' ? 'email' : this.service) + region + '.amazonaws.com'
}

RequestSigner.prototype.prepareRequest = function() {
  this.parsePath()

  var query, request = this.request, headers = request.headers

  if (request.signQuery) {
    this.parsedPath.query = query = this.parsedPath.query || {}

    if (this.credentials.sessionToken) query['X-Amz-Security-Token'] = this.credentials.sessionToken

    this.service !== 's3' || query['X-Amz-Expires'] || (query['X-Amz-Expires'] = 86400)

    query['X-Amz-Date'] ? (this.datetime = query['X-Amz-Date']) : (query['X-Amz-Date'] = this.getDateTime())

    query['X-Amz-Algorithm'] = 'AWS4-HMAC-SHA256'
    query['X-Amz-Credential'] = this.credentials.accessKeyId + '/' + this.credentialString()
    query['X-Amz-SignedHeaders'] = this.signedHeaders()
  } else {
    if (!request.doNotModifyHeaders && !this.isCodeCommitGit) {
      !request.body || headers['Content-Type'] || headers['content-type'] ||
        (headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=utf-8')

      !request.body || headers['Content-Length'] || headers['content-length'] ||
        (headers['Content-Length'] = Buffer.byteLength(request.body))

      !this.credentials.sessionToken || headers['X-Amz-Security-Token'] || headers['x-amz-security-token'] ||
        (headers['X-Amz-Security-Token'] = this.credentials.sessionToken)

      this.service !== 's3' || headers['X-Amz-Content-Sha256'] || headers['x-amz-content-sha256'] ||
        (headers['X-Amz-Content-Sha256'] = hash(this.request.body || '', 'hex'))

      headers['X-Amz-Date'] || headers['x-amz-date']
        ? (this.datetime = headers['X-Amz-Date'] || headers['x-amz-date'])
        : (headers['X-Amz-Date'] = this.getDateTime())
    }

    delete headers.Authorization
    delete headers.authorization
  }
}

RequestSigner.prototype.sign = function() {
  this.parsedPath || this.prepareRequest()

  this.request.signQuery
    ? (this.parsedPath.query['X-Amz-Signature'] = this.signature())
    : (this.request.headers.Authorization = this.authHeader())

  this.request.path = this.formatPath()

  return this.request
}

RequestSigner.prototype.getDateTime = function() {
  if (!this.datetime) {
    var headers = this.request.headers,
      date = new Date(headers.Date || headers.date || new Date())

    this.datetime = date.toISOString().replace(/[:\-]|\.\d{3}/g, '')

    if (this.isCodeCommitGit) this.datetime = this.datetime.slice(0, -1)
  }
  return this.datetime
}

RequestSigner.prototype.getDate = function() {
  return this.getDateTime().substr(0, 8)
}

RequestSigner.prototype.authHeader = function() {
  return [
    'AWS4-HMAC-SHA256 Credential=' + this.credentials.accessKeyId + '/' + this.credentialString(),
    'SignedHeaders=' + this.signedHeaders(),
    'Signature=' + this.signature()
  ].join(', ')
}

RequestSigner.prototype.signature = function() {
  var kDate, kRegion, kService,
    date = this.getDate(),
    cacheKey = [this.credentials.secretAccessKey, date, this.region, this.service].join(),
    kCredentials = credentialsCache.get(cacheKey)
  if (!kCredentials) {
    kDate = hmac('AWS4' + this.credentials.secretAccessKey, date)
    kRegion = hmac(kDate, this.region)
    kService = hmac(kRegion, this.service)
    kCredentials = hmac(kService, 'aws4_request')
    credentialsCache.set(cacheKey, kCredentials)
  }
  return hmac(kCredentials, this.stringToSign(), 'hex')
}

RequestSigner.prototype.stringToSign = function() {
  return [
    'AWS4-HMAC-SHA256',
    this.getDateTime(),
    this.credentialString(),
    hash(this.canonicalString(), 'hex')
  ].join('\n')
}

RequestSigner.prototype.canonicalString = function() {
  this.parsedPath || this.prepareRequest()

  var pathStr = this.parsedPath.path,
    query = this.parsedPath.query,
    headers = this.request.headers,
    queryStr = '',
    normalizePath = this.service !== 's3',
    decodePath = this.service === 's3' || this.request.doNotEncodePath,
    decodeSlashesInPath = this.service === 's3',
    firstValOnly = this.service === 's3'

  var bodyHash =
    this.service === 's3' && this.request.signQuery
      ? 'UNSIGNED-PAYLOAD'
      : this.isCodeCommitGit
      ? ''
      : headers['X-Amz-Content-Sha256'] || headers['x-amz-content-sha256'] || hash(this.request.body || '', 'hex')

  if (query)
    queryStr = encodeRfc3986(querystring.stringify(
      Object.keys(query).sort().reduce(function(obj, key) {
        if (!key) return obj
        obj[key] = Array.isArray(query[key]) ? (firstValOnly ? query[key][0] : query[key].slice().sort()) : query[key]
        return obj
      }, {})
    ))

  if (pathStr !== '/') {
    if (normalizePath) pathStr = pathStr.replace(/\/{2,}/g, '/')
    pathStr = pathStr.split('/').reduce(function(path, piece) {
      if (normalizePath && piece === '..') path.pop()
      else if (!normalizePath || piece !== '.') {
        if (decodePath) piece = decodeURIComponent(piece)
        path.push(encodeRfc3986(encodeURIComponent(piece)))
      }
      return path
    }, []).join('/')
    if (pathStr[0] !== '/') pathStr = '/' + pathStr
    if (decodeSlashesInPath) pathStr = pathStr.replace(/%2F/g, '/')
  }

  return [
    this.request.method || 'GET',
    pathStr,
    queryStr,
    this.canonicalHeaders() + '\n',
    this.signedHeaders(),
    bodyHash
  ].join('\n')
}

RequestSigner.prototype.canonicalHeaders = function() {
  var headers = this.request.headers
  function trimAll(header) {
    return header.toString().trim().replace(/\s+/g, ' ')
  }
  return Object.keys(headers)
    .sort(function(a, b) { return a.toLowerCase() < b.toLowerCase() ? -1 : 1 })
    .map(function(key) { return key.toLowerCase() + ':' + trimAll(headers[key]) })
    .join('\n')
}

RequestSigner.prototype.signedHeaders = function() {
  return Object.keys(this.request.headers)
    .map(function(key) { return key.toLowerCase() })
    .sort()
    .join(';')
}

RequestSigner.prototype.credentialString = function() {
  return [this.getDate(), this.region, this.service, 'aws4_request'].join('/')
}

RequestSigner.prototype.defaultCredentials = function() {
  var env = process.env
  return {
    accessKeyId: env.AWS_ACCESS_KEY_ID || env.AWS_ACCESS_KEY,
    secretAccessKey: env.AWS_SECRET_ACCESS_KEY || env.AWS_SECRET_KEY,
    sessionToken: env.AWS_SESSION_TOKEN
  }
}

RequestSigner.prototype.parsePath = function() {
  var path = this.request.path || '/',
    queryIx = path.indexOf('?'),
    query = null

  if (queryIx >= 0) {
    query = querystring.parse(path.slice(queryIx + 1))
    path = path.slice(0, queryIx)
  }

  if (/[^0-9A-Za-z!'()*\-._~%/]/.test(path))
    path = path.split('/').map(function(piece) {
      return encodeURIComponent(decodeURIComponent(piece))
    }).join('/')

  this.parsedPath = {path: path, query: query}
}

RequestSigner.prototype.formatPath = function() {
  var path = this.parsedPath.path,
    query = this.parsedPath.query

  if (!query) return path

  query[''] == null || delete query['']

  return path + '?' + encodeRfc3986(querystring.stringify(query))
}

aws4.RequestSigner = RequestSigner

aws4.sign = function(request, credentials) {
  return new RequestSigner(request, credentials).sign()
}
//
},
querystring:
function(module) {
//
module.exports = require('querystring');
//
},
'aws4/lru':
function(module) {
//
module.exports = function(size) {
  return new LruCache(size)
}

function LruCache(size) {
  this.capacity = size | 0
  this.map = Object.create(null)
  this.list = new DoublyLinkedList()
}

LruCache.prototype.get = function(key) {
  var node = this.map[key]
  if (node == null) return void 0
  this.used(node)
  return node.val
}

LruCache.prototype.set = function(key, val) {
  var node = this.map[key]
  if (node != null) node.val = val
  else {
    this.capacity || this.prune()
    if (!this.capacity) return false
    node = new DoublyLinkedNode(key, val)
    this.map[key] = node
    this.capacity--
  }
  this.used(node)
  return true
}

LruCache.prototype.used = function(node) {
  this.list.moveToFront(node)
}

LruCache.prototype.prune = function() {
  var node = this.list.pop()
  if (node != null) {
    delete this.map[node.key]
    this.capacity++
  }
}

function DoublyLinkedList() {
  this.firstNode = null
  this.lastNode = null
}

DoublyLinkedList.prototype.moveToFront = function(node) {
  if (this.firstNode == node) return

  this.remove(node)

  if (this.firstNode == null) {
    this.firstNode = node
    this.lastNode = node
    node.prev = null
    node.next = null
  } else {
    node.prev = null
    node.next = this.firstNode
    node.next.prev = node
    this.firstNode = node
  }
}

DoublyLinkedList.prototype.pop = function() {
  var lastNode = this.lastNode
  lastNode == null || this.remove(lastNode)

  return lastNode
}

DoublyLinkedList.prototype.remove = function(node) {
  if (this.firstNode == node) this.firstNode = node.next
  else if (node.prev != null) node.prev.next = node.next

  if (this.lastNode == node) this.lastNode = node.prev
  else if (node.next != null) node.next.prev = node.prev
}

function DoublyLinkedNode(key, val) {
  this.key = key
  this.val = val
  this.prev = null
  this.next = null
}
//
},
'http-signature/lib/signer':
function(module, exports, __wpreq__) {
//
var assert = __wpreq__('assert-plus'),
  crypto = __wpreq__('crypto'),
  util = __wpreq__('util'),
  sshpk = __wpreq__('sshpk/lib/private-key'),
  jsprim = __wpreq__('jsprim'),
  utils = __wpreq__('http-signature/lib/utils'),

  sprintf = __wpreq__('util').format,

  HASH_ALGOS = utils.HASH_ALGOS,
  PK_ALGOS = utils.PK_ALGOS,
  InvalidAlgorithmError = utils.InvalidAlgorithmError,
  HttpSignatureError = utils.HttpSignatureError,
  validateAlgorithm = utils.validateAlgorithm,

  AUTHZ_FMT = 'Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';

function MissingHeaderError(message) {
  HttpSignatureError.call(this, message, MissingHeaderError);
}
util.inherits(MissingHeaderError, HttpSignatureError);

function StrictParsingError(message) {
  HttpSignatureError.call(this, message, StrictParsingError);
}
util.inherits(StrictParsingError, HttpSignatureError);

//module.exports = {}
exports.signRequest = function(request, options) {
  assert.object(request, 'request');
  assert.object(options, 'options');
  assert.optionalString(options.algorithm, 'options.algorithm');
  assert.string(options.keyId, 'options.keyId');
  assert.optionalArrayOfString(options.headers, 'options.headers');
  assert.optionalString(options.httpVersion, 'options.httpVersion');

  request.getHeader('Date') || request.setHeader('Date', jsprim.rfc1123(new Date()));
  options.headers || (options.headers = ['date']);
  options.httpVersion || (options.httpVersion = '1.1');

  var alg = [];
  if (options.algorithm) {
    options.algorithm = options.algorithm.toLowerCase();
    alg = validateAlgorithm(options.algorithm);
  }

  var i,
    stringToSign = '';
  for (i = 0; i < options.headers.length; i++) {
    if (typeof options.headers[i] != 'string') throw new TypeError('options.headers must be an array of Strings');

    var h = options.headers[i].toLowerCase();

    if (h === 'request-line') {
      if (options.strict)
        throw new StrictParsingError('request-line is not a valid header with strict parsing enabled.');

      stringToSign += request.method + ' ' + request.path + ' HTTP/' + options.httpVersion;
    } else if (h === '(request-target)')
      stringToSign += '(request-target): ' + request.method.toLowerCase() + ' ' + request.path;
    else {
      var value = request.getHeader(h);
      if (value === void 0 || value === '') throw new MissingHeaderError(h + ' was not in the request');

      stringToSign += h + ': ' + value;
    }

    if (i + 1 < options.headers.length) stringToSign += '\n';
  }

  if (request.hasOwnProperty('_stringToSign')) request._stringToSign = stringToSign;

  var signature;
  if (alg[0] === 'hmac') {
    if (typeof options.key != 'string' && !Buffer.isBuffer(options.key))
      throw new TypeError('options.key must be a string or Buffer');

    var hmac = crypto.createHmac(alg[1].toUpperCase(), options.key);
    hmac.update(stringToSign);
    signature = hmac.digest('base64');
  } else {
    var key = options.key;
    if (typeof key == 'string' || Buffer.isBuffer(key)) key = sshpk.parsePrivateKey(options.key);

    assert.ok(sshpk.PrivateKey.isPrivateKey(key, [1, 2]), 'options.key must be a sshpk.PrivateKey');

    if (!PK_ALGOS[key.type])
      throw new InvalidAlgorithmError(key.type.toUpperCase() + ' type keys are not supported');

    if (alg[0] !== void 0 && key.type !== alg[0])
      throw new InvalidAlgorithmError('options.key must be a ' +
          alg[0].toUpperCase() + ' key, was given a ' + key.type.toUpperCase() + ' key instead');

    var signer = key.createSign(alg[1]);
    signer.update(stringToSign);
    var sigObj = signer.sign();
    if (!HASH_ALGOS[sigObj.hashAlgorithm])
      throw new InvalidAlgorithmError(sigObj.hashAlgorithm.toUpperCase() + ' is not a supported hash algorithm');

    options.algorithm = key.type + '-' + sigObj.hashAlgorithm;
    signature = sigObj.toString();
    assert.notStrictEqual(signature, '', 'empty signature produced');
  }

  var authzHeaderName = options.authorizationHeaderName || 'Authorization';

  request.setHeader(
    authzHeaderName,
    sprintf(AUTHZ_FMT, options.keyId, options.algorithm, options.headers.join(' '), signature)
  );

  return true;
};
//
},
'assert-plus':
function(module, exports, __wpreq__) {
//
var assert = __wpreq__('assert'),
  Stream = __wpreq__('stream').Stream,
  util = __wpreq__('util'),

  UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;

function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function _toss(name, expected, oper, arg, actual) {
  try {
    // noinspection CallerJS
    var caller = _toss.caller;
  } catch (_) {}
  throw new assert.AssertionError({
    message: util.format('%s (%s) is required', name, expected),
    actual: actual === void 0 ? typeof arg : actual(arg),
    expected: expected,
    operator: oper || '===',
    stackStartFunction: caller
  });
}

function _getClass(arg) {
  return Object.prototype.toString.call(arg).slice(8, -1);
}

function noop() {}

var types = {
  bool: {
    check: function(arg) { return typeof arg == 'boolean'; }
  },
  func: {
    check: function(arg) { return typeof arg == 'function'; }
  },
  string: {
    check: function(arg) { return typeof arg == 'string'; }
  },
  object: {
    check: function(arg) {
      return typeof arg == 'object' && arg !== null;
    }
  },
  number: {
    check: function(arg) {
      return typeof arg == 'number' && !isNaN(arg);
    }
  },
  finite: {
    check: function(arg) {
      return typeof arg == 'number' && !isNaN(arg) && isFinite(arg);
    }
  },
  buffer: {
    check: function(arg) { return Buffer.isBuffer(arg); },
    operator: 'Buffer.isBuffer'
  },
  array: {
    check: function(arg) { return Array.isArray(arg); },
    operator: 'Array.isArray'
  },
  stream: {
    check: function(arg) { return arg instanceof Stream; },
    operator: 'instanceof',
    actual: _getClass
  },
  date: {
    check: function(arg) { return arg instanceof Date; },
    operator: 'instanceof',
    actual: _getClass
  },
  regexp: {
    check: function(arg) { return arg instanceof RegExp; },
    operator: 'instanceof',
    actual: _getClass
  },
  uuid: {
    check: function(arg) {
      return typeof arg == 'string' && UUID_REGEXP.test(arg);
    },
    operator: 'isUUID'
  }
};

function _setExports(ndebug) {
  var keys = Object.keys(types);

  var out = process.env.NODE_NDEBUG
    ? noop
    : function(arg, msg) {
        arg || _toss(msg, 'true', arg);
      };

  keys.forEach(function(k) {
    if (ndebug) {
      out[k] = noop;
      return;
    }
    var type = types[k];
    out[k] = function(arg, msg) {
      type.check(arg) || _toss(msg, k, type.operator, arg, type.actual);
    };
  });

  keys.forEach(function(k) {
    var name = 'optional' + _capitalize(k);
    if (ndebug) {
      out[name] = noop;
      return;
    }
    var type = types[k];
    out[name] = function(arg, msg) {
      arg === void 0 || arg === null || type.check(arg) || _toss(msg, k, type.operator, arg, type.actual);
    };
  });

  keys.forEach(function(k) {
    var name = 'arrayOf' + _capitalize(k);
    if (ndebug) {
      out[name] = noop;
      return;
    }
    var type = types[k],
      expected = '[' + k + ']';
    out[name] = function(arg, msg) {
      Array.isArray(arg) || _toss(msg, expected, type.operator, arg, type.actual);

      for (var i = 0; i < arg.length; i++)
        type.check(arg[i]) || _toss(msg, expected, type.operator, arg, type.actual);
    };
  });

  keys.forEach(function(k) {
    var name = 'optionalArrayOf' + _capitalize(k);
    if (ndebug) {
      out[name] = noop;
      return;
    }
    var type = types[k],
      expected = '[' + k + ']';
    out[name] = function(arg, msg) {
      if (arg === void 0 || arg === null) return;

      Array.isArray(arg) || _toss(msg, expected, type.operator, arg, type.actual);

      for (var i = 0; i < arg.length; i++)
        type.check(arg[i]) || _toss(msg, expected, type.operator, arg, type.actual);
    };
  });

  Object.keys(assert).forEach(function(k) {
    out[k] = k !== 'AssertionError' && ndebug ? noop : assert[k];
  });

  out._setExports = _setExports;

  return out;
}

module.exports = _setExports(process.env.NODE_NDEBUG);
//
},
'sshpk/lib/private-key':
function(module, exports, __wpreq__) {
//
module.exports = PrivateKey;

var assert = __wpreq__('assert-plus'),
  Buffer = __wpreq__('safer-buffer').Buffer,
  algs = __wpreq__('sshpk/lib/algs'),
  crypto = __wpreq__('crypto'),
  Signature = __wpreq__('sshpk/lib/signature'),
  errs = __wpreq__('sshpk/lib/errors'),
  util = __wpreq__('util'),
  utils = __wpreq__('sshpk/lib/utils');
var edCompat, nacl;

try {
  edCompat = __wpreq__('sshpk/lib/ed-compat');
} catch (_) {}

var Key = __wpreq__('sshpk/lib/key'),

  KeyParseError = errs.KeyParseError,

  formats = {};
formats.auto = __wpreq__('sshpk/lib/formats/auto');
formats.pem = __wpreq__('sshpk/lib/formats/pem');
formats.pkcs1 = __wpreq__('sshpk/lib/formats/pkcs1');
formats.pkcs8 = __wpreq__('sshpk/lib/formats/pkcs8');
formats.rfc4253 = __wpreq__('sshpk/lib/formats/rfc4253');
formats['ssh-private'] = __wpreq__('sshpk/lib/formats/ssh-private');
formats.openssh = formats['ssh-private'];
formats.ssh = formats['ssh-private'];
formats.dnssec = __wpreq__('sshpk/lib/formats/dnssec');

function PrivateKey(opts) {
  assert.object(opts, 'options');
  Key.call(this, opts);

  this._pubCache = void 0;
}
util.inherits(PrivateKey, Key);

PrivateKey.formats = formats;

PrivateKey.prototype.toBuffer = function(format, options) {
  if (format === void 0) format = 'pkcs1';
  assert.string(format, 'format');
  assert.object(formats[format], 'formats[format]');
  assert.optionalObject(options, 'options');

  return formats[format].write(this, options);
};

PrivateKey.prototype.hash = function(algo) {
  return this.toPublic().hash(algo);
};

PrivateKey.prototype.toPublic = function() {
  if (this._pubCache) return this._pubCache;

  var pubParts = [];
  for (var algInfo = algs.info[this.type], i = 0; i < algInfo.parts.length; ++i) {
    var p = algInfo.parts[i];
    pubParts.push(this.part[p]);
  }

  this._pubCache = new Key({type: this.type, source: this, parts: pubParts});
  if (this.comment) this._pubCache.comment = this.comment;
  return this._pubCache;
};

PrivateKey.prototype.derive = function(newType) {
  assert.string(newType, 'type');
  var priv, pub, pair;

  if (this.type === 'ed25519' && newType === 'curve25519') {
    if (nacl === void 0) nacl = __wpreq__('tweetnacl');

    if ((priv = this.part.k.data)[0] === 0x00) priv = priv.slice(1);

    pair = nacl.box.keyPair.fromSecretKey(new Uint8Array(priv));
    pub = Buffer.from(pair.publicKey);

    return new PrivateKey({
      type: 'curve25519',
      parts: [
        {name: 'A', data: utils.mpNormalize(pub)},
        {name: 'k', data: utils.mpNormalize(priv)}
      ]
    });
  }
  if (this.type === 'curve25519' && newType === 'ed25519') {
    if (nacl === void 0) nacl = __wpreq__('tweetnacl');

    if ((priv = this.part.k.data)[0] === 0x00) priv = priv.slice(1);

    pair = nacl.sign.keyPair.fromSeed(new Uint8Array(priv));
    pub = Buffer.from(pair.publicKey);

    return new PrivateKey({
      type: 'ed25519',
      parts: [
        {name: 'A', data: utils.mpNormalize(pub)},
        {name: 'k', data: utils.mpNormalize(priv)}
      ]
    });
  }
  throw new Error('Key derivation not supported from ' + this.type + ' to ' + newType);
};

PrivateKey.prototype.createVerify = function(hashAlgo) {
  return this.toPublic().createVerify(hashAlgo);
};

PrivateKey.prototype.createSign = function(hashAlgo) {
  if (hashAlgo === void 0) hashAlgo = this.defaultHashAlgorithm();
  assert.string(hashAlgo, 'hash algorithm');

  if (this.type === 'ed25519' && edCompat !== void 0) return new edCompat.Signer(this, hashAlgo);
  if (this.type === 'curve25519') throw new Error('Curve25519 keys are not suitable for signing or verification');

  var v, nm, err;
  try {
    nm = hashAlgo.toUpperCase();
    v = crypto.createSign(nm);
  } catch (e) {
    err = e;
  }
  if (v === void 0 || (err instanceof Error && err.message.match(/Unknown message digest/))) {
    nm = 'RSA-';
    nm += hashAlgo.toUpperCase();
    v = crypto.createSign(nm);
  }
  assert.ok(v, 'failed to create verifier');
  var oldSign = v.sign.bind(v),
    key = this.toBuffer('pkcs1'),
    type = this.type,
    curve = this.curve;
  v.sign = function() {
    var sig = oldSign(key);
    if (typeof sig == 'string') sig = Buffer.from(sig, 'binary');
    (sig = Signature.parse(sig, type, 'asn1')).hashAlgorithm = hashAlgo;
    sig.curve = curve;
    return sig;
  };
  return v;
};

PrivateKey.parse = function(data, format, options) {
  typeof data == 'string' || assert.buffer(data, 'data');
  if (format === void 0) format = 'auto';
  assert.string(format, 'format');
  if (typeof options == 'string') options = {filename: options};
  assert.optionalObject(options, 'options');
  if (options === void 0) options = {};
  assert.optionalString(options.filename, 'options.filename');
  if (options.filename === void 0) options.filename = '(unnamed)';

  assert.object(formats[format], 'formats[format]');

  try {
    var k = formats[format].read(data, options);
    assert.ok(k instanceof PrivateKey, 'key is not a private key');
    k.comment || (k.comment = options.filename);
    return k;
  } catch (e) {
    if (e.name === 'KeyEncryptedError') throw e;
    throw new KeyParseError(options.filename, format, e);
  }
};

PrivateKey.isPrivateKey = function(obj, ver) {
  return utils.isCompatible(obj, PrivateKey, ver);
};

PrivateKey.prototype._sshpkApiVersion = [1, 5];

PrivateKey._oldVersionDetect = function(obj) {
  assert.func(obj.toPublic);
  assert.func(obj.createSign);
  return obj.derive ? [1, 3] : obj.defaultHashAlgorithm ? [1, 2] : obj.formats.auto ? [1, 1] : [1, 0];
};

PrivateKey.PrivateKey = PrivateKey;
PrivateKey.parsePrivateKey = PrivateKey.parse;
//
},
'sshpk/lib/algs':
function(module, exports, __wpreq__) {
//
var Buffer = __wpreq__('safer-buffer').Buffer;

var algInfo = {
  dsa: {parts: ['p', 'q', 'g', 'y'], sizePart: 'p'},
  rsa: {parts: ['e', 'n'], sizePart: 'n'},
  ecdsa: {parts: ['curve', 'Q'], sizePart: 'Q'},
  ed25519: {parts: ['A'], sizePart: 'A'}
};
algInfo.curve25519 = algInfo.ed25519;

var algPrivInfo = {
  dsa: {parts: ['p', 'q', 'g', 'y', 'x']},
  rsa: {parts: ['n', 'e', 'd', 'iqmp', 'p', 'q']},
  ecdsa: {parts: ['curve', 'Q', 'd']},
  ed25519: {parts: ['A', 'k']}
};
algPrivInfo.curve25519 = algPrivInfo.ed25519;

var hashAlgs = {
  md5: true,
  sha1: true,
  sha256: true,
  sha384: true,
  sha512: true
};

var curves = {
  nistp256: {
    size: 256,
    pkcs8oid: '1.2.840.10045.3.1.7',
    p: Buffer.from(
      '00 ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff'.replace(/ /g, ''),
      'hex'
    ),
    a: Buffer.from(
      '00 FFFFFFFF 00000001 00000000 00000000 00000000 FFFFFFFF FFFFFFFF FFFFFFFC'.replace(/ /g, ''),
      'hex'
    ),
    b: Buffer.from('5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b'.replace(/ /g, ''), 'hex'),
    s: Buffer.from('00 c49d3608 86e70493 6a6678e1 139d26b7 819f7e90'.replace(/ /g, ''), 'hex'),
    n: Buffer.from(
      '00 ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551'.replace(/ /g, ''),
      'hex'
    ),
    G: Buffer.from(
      '04 6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296\
 4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'.replace(/ /g, ''),
      'hex'
    )
  },
  nistp384: {
    size: 384,
    pkcs8oid: '1.3.132.0.34',
    p: Buffer.from(
      '00 ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe\
 ffffffff 00000000 00000000 ffffffff'.replace(/ /g, ''),
      'hex'
    ),
    a: Buffer.from(
      '00 FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE\
 FFFFFFFF 00000000 00000000 FFFFFFFC'.replace(/ /g, ''),
      'hex'
    ),
    b: Buffer.from(
      'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a\
 c656398d 8a2ed19d 2a85c8ed d3ec2aef'.replace(/ /g, ''),
      'hex'
    ),
    s: Buffer.from('00 a335926a a319a27a 1d00896a 6773a482 7acdac73'.replace(/ /g, ''), 'hex'),
    n: Buffer.from(
      '00 ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf\
 581a0db2 48b0a77a ecec196a ccc52973'.replace(/ /g, ''),
      'hex'
    ),
    G: Buffer.from(
      '04 aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38\
 5502f25d bf55296c 3a545e38 72760ab7 3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0\
 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'.replace(/ /g, ''),
      'hex'
    )
  },
  nistp521: {
    size: 521,
    pkcs8oid: '1.3.132.0.35',
    p: Buffer.from(
      '01ffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff\
 ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffff'.replace(/ /g, ''),
      'hex'
    ),
    a: Buffer.from(
      '01FF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF\
 FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFC'.replace(/ /g, ''),
      'hex'
    ),
    b: Buffer.from(
      '51 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1\
 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00'.replace(/ /g, ''),
      'hex'
    ),
    s: Buffer.from('00 d09e8800 291cb853 96cc6717 393284aa a0da64ba'.replace(/ /g, ''), 'hex'),
    n: Buffer.from(
      '01ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa\
 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409'.replace(/ /g, ''),
      'hex'
    ),
    G: Buffer.from(
      '04 00c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba\
 a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66\
 0118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c\
 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650'.replace(/ /g, ''),
      'hex'
    )
  }
};

module.exports = {
  info: algInfo,
  privInfo: algPrivInfo,
  hashAlgs: hashAlgs,
  curves: curves
};
//
},
'sshpk/lib/fingerprint':
function(module, exports, __wpreq__) {
//
module.exports = Fingerprint;

var assert = __wpreq__('assert-plus'),
  Buffer = __wpreq__('safer-buffer').Buffer,
  algs = __wpreq__('sshpk/lib/algs'),
  crypto = __wpreq__('crypto'),
  errs = __wpreq__('sshpk/lib/errors'),
  Key = __wpreq__('sshpk/lib/key'),
  Certificate = __wpreq__('sshpk/lib/certificate'),
  utils = __wpreq__('sshpk/lib/utils'),

  FingerprintFormatError = errs.FingerprintFormatError,
  InvalidAlgorithmError = errs.InvalidAlgorithmError;

function Fingerprint(opts) {
  assert.object(opts, 'options');
  assert.string(opts.type, 'options.type');
  assert.buffer(opts.hash, 'options.hash');
  assert.string(opts.algorithm, 'options.algorithm');

  this.algorithm = opts.algorithm.toLowerCase();
  if (algs.hashAlgs[this.algorithm] !== true) throw new InvalidAlgorithmError(this.algorithm);

  this.hash = opts.hash;
  this.type = opts.type;
}

Fingerprint.prototype.toString = function(format) {
  if (format === void 0) format = this.algorithm === 'md5' ? 'hex' : 'base64';
  assert.string(format);

  switch (format) {
  case 'hex':
    return addColons(this.hash.toString('hex'));
  case 'base64':
    return sshBase64Format(this.algorithm, this.hash.toString('base64'));
  default:
    throw new FingerprintFormatError(void 0, format);
  }
};

Fingerprint.prototype.matches = function(other) {
  assert.object(other, 'key or certificate');
  this.type === 'key'
    ? utils.assertCompatible(other, Key, [1, 0], 'key')
    : utils.assertCompatible(other, Certificate, [1, 0], 'certificate');

  var theirHash = other.hash(this.algorithm),
    theirHash2 = crypto.createHash(this.algorithm).update(theirHash).digest('base64');

  if (this.hash2 === void 0) this.hash2 = crypto.createHash(this.algorithm).update(this.hash).digest('base64');

  return this.hash2 === theirHash2;
};

Fingerprint.parse = function(fp, options) {
  assert.string(fp, 'fingerprint');

  var alg, hash, enAlgs;
  if (Array.isArray(options)) {
    enAlgs = options;
    options = {};
  }
  assert.optionalObject(options, 'options');
  if (options === void 0) options = {};
  if (options.enAlgs !== void 0) enAlgs = options.enAlgs;
  assert.optionalArrayOfString(enAlgs, 'algorithms');

  var parts = fp.split(':');
  if (parts.length == 2) {
    alg = parts[0].toLowerCase();
    if (!/^[A-Za-z0-9+\/=]+$/.test(parts[1])) throw new FingerprintFormatError(fp);
    try {
      hash = Buffer.from(parts[1], 'base64');
    } catch (_e) {
      throw new FingerprintFormatError(fp);
    }
  } else if (parts.length > 2) {
    alg = 'md5';
    if (parts[0].toLowerCase() === 'md5') parts = parts.slice(1);
    parts = parts.join('');
    if (!/^[a-fA-F0-9]+$/.test(parts)) throw new FingerprintFormatError(fp);
    try {
      hash = Buffer.from(parts, 'hex');
    } catch (_e) {
      throw new FingerprintFormatError(fp);
    }
  }

  if (alg === void 0) throw new FingerprintFormatError(fp);

  if (algs.hashAlgs[alg] === void 0) throw new InvalidAlgorithmError(alg);

  if (enAlgs !== void 0 && (enAlgs = enAlgs.map(function(a) { return a.toLowerCase(); })).indexOf(alg) < 0)
    throw new InvalidAlgorithmError(alg);

  return new Fingerprint({algorithm: alg, hash: hash, type: options.type || 'key'});
};

function addColons(s) {
  return s.replace(/(.{2})(?=.)/g, '$1:');
}

function base64Strip(s) {
  return s.replace(/=*$/, '');
}

function sshBase64Format(alg, h) {
  return alg.toUpperCase() + ':' + base64Strip(h);
}

Fingerprint.isFingerprint = function(obj, ver) {
  return utils.isCompatible(obj, Fingerprint, ver);
};

Fingerprint.prototype._sshpkApiVersion = [1, 1];

Fingerprint._oldVersionDetect = function(obj) {
  assert.func(obj.toString);
  assert.func(obj.matches);
  return [1, 0];
};
//
},
'sshpk/lib/errors':
function(module, exports, __wpreq__) {
//
var util = __wpreq__('util');

function FingerprintFormatError(fp, format) {
  Error.captureStackTrace && Error.captureStackTrace(this, FingerprintFormatError);
  this.name = 'FingerprintFormatError';
  this.fingerprint = fp;
  this.format = format;
  this.message = 'Fingerprint format is not supported, or is invalid: ';
  if (fp !== void 0) this.message += ' fingerprint = ' + fp;
  if (format !== void 0) this.message += ' format = ' + format;
}
util.inherits(FingerprintFormatError, Error);

function InvalidAlgorithmError(alg) {
  Error.captureStackTrace && Error.captureStackTrace(this, InvalidAlgorithmError);
  this.name = 'InvalidAlgorithmError';
  this.algorithm = alg;
  this.message = 'Algorithm "' + alg + '" is not supported';
}
util.inherits(InvalidAlgorithmError, Error);

function KeyParseError(name, format, innerErr) {
  Error.captureStackTrace && Error.captureStackTrace(this, KeyParseError);
  this.name = 'KeyParseError';
  this.format = format;
  this.keyName = name;
  this.innerErr = innerErr;
  this.message = 'Failed to parse ' + name + ' as a valid ' + format + ' format key: ' + innerErr.message;
}
util.inherits(KeyParseError, Error);

function SignatureParseError(type, format, innerErr) {
  Error.captureStackTrace && Error.captureStackTrace(this, SignatureParseError);
  this.name = 'SignatureParseError';
  this.type = type;
  this.format = format;
  this.innerErr = innerErr;
  this.message =
    'Failed to parse the given data as a ' + type + ' signature in ' + format + ' format: ' + innerErr.message;
}
util.inherits(SignatureParseError, Error);

function CertificateParseError(name, format, innerErr) {
  Error.captureStackTrace && Error.captureStackTrace(this, CertificateParseError);
  this.name = 'CertificateParseError';
  this.format = format;
  this.certName = name;
  this.innerErr = innerErr;
  this.message = 'Failed to parse ' + name + ' as a valid ' + format + ' format certificate: ' + innerErr.message;
}
util.inherits(CertificateParseError, Error);

function KeyEncryptedError(name, format) {
  Error.captureStackTrace && Error.captureStackTrace(this, KeyEncryptedError);
  this.name = 'KeyEncryptedError';
  this.format = format;
  this.keyName = name;
  this.message = 'The ' + format + ' format key ' + name +
    ' is encrypted (password-protected), and no passphrase was provided in `options`';
}
util.inherits(KeyEncryptedError, Error);

module.exports = {
  FingerprintFormatError: FingerprintFormatError,
  InvalidAlgorithmError: InvalidAlgorithmError,
  KeyParseError: KeyParseError,
  SignatureParseError: SignatureParseError,
  KeyEncryptedError: KeyEncryptedError,
  CertificateParseError: CertificateParseError
};
//
},
'sshpk/lib/key':
function(module, exports, __wpreq__) {
//
module.exports = Key;

var assert = __wpreq__('assert-plus'),
  algs = __wpreq__('sshpk/lib/algs'),
  crypto = __wpreq__('crypto'),
  Fingerprint = __wpreq__('sshpk/lib/fingerprint'),
  Signature = __wpreq__('sshpk/lib/signature'),
  errs = __wpreq__('sshpk/lib/errors'),
  utils = __wpreq__('sshpk/lib/utils'),
  PrivateKey = __wpreq__('sshpk/lib/private-key');
var edCompat;

try {
  edCompat = __wpreq__('sshpk/lib/ed-compat');
} catch (_) {}

var InvalidAlgorithmError = errs.InvalidAlgorithmError,
  KeyParseError = errs.KeyParseError,

  formats = {};
formats.auto = __wpreq__('sshpk/lib/formats/auto');
formats.pem = __wpreq__('sshpk/lib/formats/pem');
formats.pkcs1 = __wpreq__('sshpk/lib/formats/pkcs1');
formats.pkcs8 = __wpreq__('sshpk/lib/formats/pkcs8');
formats.rfc4253 = __wpreq__('sshpk/lib/formats/rfc4253');
formats.ssh = __wpreq__('sshpk/lib/formats/ssh');
formats['ssh-private'] = __wpreq__('sshpk/lib/formats/ssh-private');
formats.openssh = formats['ssh-private'];
formats.dnssec = __wpreq__('sshpk/lib/formats/dnssec');

function Key(opts) {
  assert.object(opts, 'options');
  assert.arrayOfObject(opts.parts, 'options.parts');
  assert.string(opts.type, 'options.type');
  assert.optionalString(opts.comment, 'options.comment');

  var algInfo = algs.info[opts.type];
  if (typeof algInfo != 'object') throw new InvalidAlgorithmError(opts.type);

  var sz,
    partLookup = {};
  for (var i = 0; i < opts.parts.length; ++i) {
    var part = opts.parts[i];
    partLookup[part.name] = part;
  }

  this.type = opts.type;
  this.parts = opts.parts;
  this.part = partLookup;
  this.comment = void 0;
  this.source = opts.source;

  this._rfc4253Cache = opts._rfc4253Cache;
  this._hashCache = {};

  this.curve = void 0;
  if (this.type === 'ecdsa') {
    var curve = this.part.curve.data.toString();
    this.curve = curve;
    sz = algs.curves[curve].size;
  } else if (this.type === 'ed25519' || this.type === 'curve25519') {
    sz = 256;
    this.curve = 'curve25519';
  } else {
    var szPart = this.part[algInfo.sizePart];
    sz = (sz = szPart.data.length) * 8 - utils.countZeros(szPart.data);
  }
  this.size = sz;
}

Key.formats = formats;

Key.prototype.toBuffer = function(format, options) {
  if (format === void 0) format = 'ssh';
  assert.string(format, 'format');
  assert.object(formats[format], 'formats[format]');
  assert.optionalObject(options, 'options');

  if (format === 'rfc4253') {
    if (this._rfc4253Cache === void 0) this._rfc4253Cache = formats.rfc4253.write(this);
    return this._rfc4253Cache;
  }

  return formats[format].write(this, options);
};

Key.prototype.toString = function(format, options) {
  return this.toBuffer(format, options).toString();
};

Key.prototype.hash = function(algo) {
  assert.string(algo, 'algorithm');
  algo = algo.toLowerCase();
  if (algs.hashAlgs[algo] === void 0) throw new InvalidAlgorithmError(algo);

  if (this._hashCache[algo]) return this._hashCache[algo];
  var hash = crypto.createHash(algo).update(this.toBuffer('rfc4253')).digest();
  this._hashCache[algo] = hash;
  return hash;
};

Key.prototype.fingerprint = function(algo) {
  if (algo === void 0) algo = 'sha256';
  assert.string(algo, 'algorithm');
  var opts = {type: 'key', hash: this.hash(algo), algorithm: algo};
  return new Fingerprint(opts);
};

Key.prototype.defaultHashAlgorithm = function() {
  var hashAlgo = 'sha1';
  if (this.type === 'rsa') hashAlgo = 'sha256';
  if (this.type === 'dsa' && this.size > 1024) hashAlgo = 'sha256';
  if (this.type === 'ed25519') hashAlgo = 'sha512';
  if (this.type === 'ecdsa') hashAlgo = this.size <= 256 ? 'sha256' : this.size <= 384 ? 'sha384' : 'sha512';

  return hashAlgo;
};

Key.prototype.createVerify = function(hashAlgo) {
  if (hashAlgo === void 0) hashAlgo = this.defaultHashAlgorithm();
  assert.string(hashAlgo, 'hash algorithm');

  if (this.type === 'ed25519' && edCompat !== void 0) return new edCompat.Verifier(this, hashAlgo);
  if (this.type === 'curve25519') throw new Error('Curve25519 keys are not suitable for signing or verification');

  var v, nm, err;
  try {
    nm = hashAlgo.toUpperCase();
    v = crypto.createVerify(nm);
  } catch (e) {
    err = e;
  }
  if (v === void 0 || (err instanceof Error && err.message.match(/Unknown message digest/))) {
    nm = 'RSA-';
    nm += hashAlgo.toUpperCase();
    v = crypto.createVerify(nm);
  }
  assert.ok(v, 'failed to create verifier');
  var oldVerify = v.verify.bind(v),
    key = this.toBuffer('pkcs8'),
    curve = this.curve,
    self = this;
  v.verify = function(signature, fmt) {
    if (Signature.isSignature(signature, [2, 0]))
      return (
        signature.type === self.type &&
        (!signature.hashAlgorithm || signature.hashAlgorithm === hashAlgo) &&
        (!signature.curve || self.type !== 'ecdsa' || signature.curve === curve) &&
        oldVerify(key, signature.toBuffer('asn1'))
      );
    if (typeof signature == 'string' || Buffer.isBuffer(signature)) return oldVerify(key, signature, fmt);

    throw Signature.isSignature(signature, [1, 0])
      ? new Error('signature was created by too old a version of sshpk and cannot be verified')
      : new TypeError('signature must be a string, Buffer, or Signature object');
  };
  return v;
};

Key.prototype.createDH = {};

Key.parse = function(data, format, options) {
  typeof data == 'string' || assert.buffer(data, 'data');
  if (format === void 0) format = 'auto';
  assert.string(format, 'format');
  if (typeof options == 'string') options = {filename: options};
  assert.optionalObject(options, 'options');
  if (options === void 0) options = {};
  assert.optionalString(options.filename, 'options.filename');
  if (options.filename === void 0) options.filename = '(unnamed)';

  assert.object(formats[format], 'formats[format]');

  try {
    var k = formats[format].read(data, options);
    if (k instanceof PrivateKey) k = k.toPublic();
    k.comment || (k.comment = options.filename);
    return k;
  } catch (e) {
    if (e.name === 'KeyEncryptedError') throw e;
    throw new KeyParseError(options.filename, format, e);
  }
};

Key.isKey = function(obj, ver) {
  return utils.isCompatible(obj, Key, ver);
};

Key.prototype._sshpkApiVersion = [1, 6];

Key._oldVersionDetect = function(obj) {
  assert.func(obj.toBuffer);
  assert.func(obj.fingerprint);
  return obj.createDH
    ? [1, 4]
    : obj.defaultHashAlgorithm
    ? [1, 3]
    : obj.formats.auto
    ? [1, 2]
    : obj.formats.pkcs1
    ? [1, 1]
    : [1, 0];
};
//
},
'sshpk/lib/signature':
function(module, exports, __wpreq__) {
//
module.exports = Signature;

var assert = __wpreq__('assert-plus'),
  Buffer = __wpreq__('safer-buffer').Buffer,
  errs = __wpreq__('sshpk/lib/errors'),
  utils = __wpreq__('sshpk/lib/utils'),
  asn1 = __wpreq__('asn1'),
  SSHBuffer = __wpreq__('sshpk/lib/ssh-buffer'),

  InvalidAlgorithmError = errs.InvalidAlgorithmError,
  SignatureParseError = errs.SignatureParseError;

function Signature(opts) {
  assert.object(opts, 'options');
  assert.arrayOfObject(opts.parts, 'options.parts');
  assert.string(opts.type, 'options.type');

  var partLookup = {};
  for (var i = 0; i < opts.parts.length; ++i) {
    var part = opts.parts[i];
    partLookup[part.name] = part;
  }

  this.type = opts.type;
  this.hashAlgorithm = opts.hashAlgo;
  this.curve = opts.curve;
  this.parts = opts.parts;
  this.part = partLookup;
}

Signature.prototype.toBuffer = function(format) {
  if (format === void 0) format = 'asn1';
  assert.string(format, 'format');

  var buf,
    stype = 'ssh-' + this.type;

  switch (this.type) {
  case 'rsa':
    switch (this.hashAlgorithm) {
    case 'sha256':
      stype = 'rsa-sha2-256';
      break;
    case 'sha512':
      stype = 'rsa-sha2-512';
      break;
    case 'sha1':
    case void 0:
      break;
    default:
      throw new Error('SSH signature format does not support hash algorithm ' + this.hashAlgorithm);
    }
    if (format !== 'ssh') return this.part.sig.data;

    (buf = new SSHBuffer({})).writeString(stype);
    buf.writePart(this.part.sig);
    return buf.toBuffer();

  case 'ed25519':
    if (format !== 'ssh') return this.part.sig.data;

    (buf = new SSHBuffer({})).writeString(stype);
    buf.writePart(this.part.sig);
    return buf.toBuffer();

  case 'dsa':
  case 'ecdsa':
    var r, s;
    if (format === 'asn1') {
      var der = new asn1.BerWriter();
      der.startSequence();
      r = utils.mpNormalize(this.part.r.data);
      s = utils.mpNormalize(this.part.s.data);
      der.writeBuffer(r, asn1.Ber.Integer);
      der.writeBuffer(s, asn1.Ber.Integer);
      der.endSequence();
      return der.buffer;
    }
    if (format === 'ssh' && this.type === 'dsa') {
      (buf = new SSHBuffer({})).writeString('ssh-dss');
      if ((r = this.part.r.data).length > 20 && r[0] === 0x00) r = r.slice(1);
      if ((s = this.part.s.data).length > 20 && s[0] === 0x00) s = s.slice(1);
      if ((this.hashAlgorithm && this.hashAlgorithm !== 'sha1') || r.length + s.length !== 40)
        throw new Error('OpenSSH only supports DSA signatures with SHA1 hash');

      buf.writeBuffer(Buffer.concat([r, s]));
      return buf.toBuffer();
    }
    if (format === 'ssh' && this.type === 'ecdsa') {
      var curve,
        inner = new SSHBuffer({});
      r = this.part.r.data;
      inner.writeBuffer(r);
      inner.writePart(this.part.s);

      buf = new SSHBuffer({});
      if (r[0] === 0x00) r = r.slice(1);
      var sz = r.length * 8;
      if (sz === 256) curve = 'nistp256';
      else if (sz === 384) curve = 'nistp384';
      else if (sz === 528) curve = 'nistp521';
      buf.writeString('ecdsa-sha2-' + curve);
      buf.writeBuffer(inner.toBuffer());
      return buf.toBuffer();
    }
    throw new Error('Invalid signature format');
  default:
    throw new Error('Invalid signature data');
  }
};

Signature.prototype.toString = function(format) {
  assert.optionalString(format, 'format');
  return this.toBuffer(format).toString('base64');
};

Signature.parse = function(data, type, format) {
  if (typeof data == 'string') data = Buffer.from(data, 'base64');
  assert.buffer(data, 'data');
  assert.string(format, 'format');
  assert.string(type, 'type');

  var opts = {};
  opts.type = type.toLowerCase();
  opts.parts = [];

  try {
    assert.ok(data.length > 0, 'signature must not be empty');
    switch (opts.type) {
    case 'rsa':
    case 'ed25519':
      return parseOneNum(data, type, format, opts);

    case 'dsa':
    case 'ecdsa':
      return format === 'asn1'
        ? parseDSAasn1(data, type, format, opts)
        : opts.type === 'dsa'
        ? parseDSA(data, type, format, opts)
        : parseECDSA(data, type, format, opts);

    default:
      // noinspection ExceptionCaughtLocallyJS
      throw new InvalidAlgorithmError(type);
    }
  } catch (e) {
    if (e instanceof InvalidAlgorithmError) throw e;
    throw new SignatureParseError(type, format, e);
  }
};

function parseOneNum(data, type, format, opts) {
  if (format === 'ssh') {
    try {
      var buf = new SSHBuffer({buffer: data}),
        head = buf.readString();
    } catch (_) {}

    if (buf !== void 0) {
      var msg = 'SSH signature does not match expected type (expected ' + type + ', got ' + head + ')';
      switch (head) {
      case 'ssh-rsa':
        assert.strictEqual(type, 'rsa', msg);
        opts.hashAlgo = 'sha1';
        break;
      case 'rsa-sha2-256':
        assert.strictEqual(type, 'rsa', msg);
        opts.hashAlgo = 'sha256';
        break;
      case 'rsa-sha2-512':
        assert.strictEqual(type, 'rsa', msg);
        opts.hashAlgo = 'sha512';
        break;
      case 'ssh-ed25519':
        assert.strictEqual(type, 'ed25519', msg);
        opts.hashAlgo = 'sha512';
        break;
      default:
        throw new Error('Unknown SSH signature type: ' + head);
      }
      var sig = buf.readPart();
      assert.ok(buf.atEnd(), 'extra trailing bytes');
      sig.name = 'sig';
      opts.parts.push(sig);
      return new Signature(opts);
    }
  }
  opts.parts.push({name: 'sig', data: data});
  return new Signature(opts);
}

function parseDSAasn1(data, type, format, opts) {
  var der = new asn1.BerReader(data);
  der.readSequence();
  var r = der.readString(asn1.Ber.Integer, true),
    s = der.readString(asn1.Ber.Integer, true);

  opts.parts.push({name: 'r', data: utils.mpNormalize(r)});
  opts.parts.push({name: 's', data: utils.mpNormalize(s)});

  return new Signature(opts);
}

function parseDSA(data, type, format, opts) {
  if (data.length != 40) {
    var buf = new SSHBuffer({buffer: data}),
      d = buf.readBuffer();
    if (d.toString('ascii') === 'ssh-dss') d = buf.readBuffer();
    assert.ok(buf.atEnd(), 'extra trailing bytes');
    assert.strictEqual(d.length, 40, 'invalid inner length');
    data = d;
  }
  opts.parts.push({name: 'r', data: data.slice(0, 20)});
  opts.parts.push({name: 's', data: data.slice(20, 40)});
  return new Signature(opts);
}

function parseECDSA(data, type, format, opts) {
  var r, s;
  var buf = new SSHBuffer({buffer: data}),

    inner = buf.readBuffer(),
    stype = inner.toString('ascii');
  if (stype.slice(0, 6) === 'ecdsa-') {
    var parts = stype.split('-');
    assert.strictEqual(parts[0], 'ecdsa');
    assert.strictEqual(parts[1], 'sha2');
    opts.curve = parts[2];
    switch (opts.curve) {
    case 'nistp256':
      opts.hashAlgo = 'sha256';
      break;
    case 'nistp384':
      opts.hashAlgo = 'sha384';
      break;
    case 'nistp521':
      opts.hashAlgo = 'sha512';
      break;
    default:
      throw new Error('Unsupported ECDSA curve: ' + opts.curve);
    }
    inner = buf.readBuffer();
    assert.ok(buf.atEnd(), 'extra trailing bytes on outer');
    r = (buf = new SSHBuffer({buffer: inner})).readPart();
  } else r = {data: inner};

  s = buf.readPart();
  assert.ok(buf.atEnd(), 'extra trailing bytes');

  r.name = 'r';
  s.name = 's';

  opts.parts.push(r);
  opts.parts.push(s);
  return new Signature(opts);
}

Signature.isSignature = function(obj, ver) {
  return utils.isCompatible(obj, Signature, ver);
};

Signature.prototype._sshpkApiVersion = [2, 1];

Signature._oldVersionDetect = function(obj) {
  assert.func(obj.toBuffer);
  return obj.hasOwnProperty('hashAlgorithm') ? [2, 0] : [1, 0];
};
//
},
'sshpk/lib/utils':
function(module, exports, __wpreq__) {
//
module.exports = {
  bufferSplit: bufferSplit,
  addRSAMissing: addRSAMissing,
  calculateDSAPublic: calculateDSAPublic,
  calculateED25519Public: calculateED25519Public,
  calculateX25519Public: calculateX25519Public,
  mpNormalize: mpNormalize,
  mpDenormalize: mpDenormalize,
  ecNormalize: ecNormalize,
  countZeros: countZeros,
  assertCompatible: assertCompatible,
  isCompatible: isCompatible,
  opensslKeyDeriv: opensslKeyDeriv,
  opensshCipherInfo: opensshCipherInfo,
  publicFromPrivateECDSA: publicFromPrivateECDSA,
  zeroPadToLength: zeroPadToLength,
  writeBitString: writeBitString,
  readBitString: readBitString
};

var assert = __wpreq__('assert-plus'),
  Buffer = __wpreq__('safer-buffer').Buffer,
  PrivateKey = __wpreq__('sshpk/lib/private-key'),
  Key = __wpreq__('sshpk/lib/key'),
  crypto = __wpreq__('crypto'),
  algs = __wpreq__('sshpk/lib/algs'),
  asn1 = __wpreq__('asn1');

var ec, jsbn, nacl;

var MAX_CLASS_DEPTH = 3;

function isCompatible(obj, klass, needVer) {
  if (obj === null || typeof obj != 'object') return false;
  if (needVer === void 0) needVer = klass.prototype._sshpkApiVersion;
  if (obj instanceof klass && klass.prototype._sshpkApiVersion[0] == needVer[0]) return true;
  var proto = Object.getPrototypeOf(obj);
  for (var depth = 0; proto.constructor.name !== klass.name; )
    if (!(proto = Object.getPrototypeOf(proto)) || ++depth > MAX_CLASS_DEPTH) return false;

  if (proto.constructor.name !== klass.name) return false;
  var ver = proto._sshpkApiVersion;
  if (ver === void 0) ver = klass._oldVersionDetect(obj);
  return !(ver[0] != needVer[0] || ver[1] < needVer[1]);
}

function assertCompatible(obj, klass, needVer, name) {
  if (name === void 0) name = 'object';
  assert.ok(obj, name + ' must not be null');
  assert.object(obj, name + ' must be an object');
  if (needVer === void 0) needVer = klass.prototype._sshpkApiVersion;
  if (obj instanceof klass && klass.prototype._sshpkApiVersion[0] == needVer[0]) return;
  var proto = Object.getPrototypeOf(obj);
  for (var depth = 0; proto.constructor.name !== klass.name; ) {
    proto = Object.getPrototypeOf(proto);
    assert.ok(proto && ++depth <= MAX_CLASS_DEPTH, name + ' must be a ' + klass.name + ' instance');
  }
  assert.strictEqual(proto.constructor.name, klass.name, name + ' must be a ' + klass.name + ' instance');
  var ver = proto._sshpkApiVersion;
  if (ver === void 0) ver = klass._oldVersionDetect(obj);
  assert.ok(
    ver[0] == needVer[0] && ver[1] >= needVer[1],
    name + ' must be compatible with ' + klass.name + ' klass version ' + needVer[0] + '.' + needVer[1]
  );
}

var CIPHER_LEN = {
  'des-ede3-cbc': {key: 7, iv: 8},
  'aes-128-cbc': {key: 16, iv: 16}
};
var PKCS5_SALT_LEN = 8;

function opensslKeyDeriv(cipher, salt, passphrase, count) {
  assert.buffer(salt, 'salt');
  assert.buffer(passphrase, 'passphrase');
  assert.number(count, 'iteration count');

  var clen = CIPHER_LEN[cipher];
  assert.object(clen, 'supported cipher');

  salt = salt.slice(0, PKCS5_SALT_LEN);

  var material = Buffer.alloc(0);
  for (var D, D_prev, bufs; material.length < clen.key + clen.iv; ) {
    bufs = [];
    D_prev && bufs.push(D_prev);
    bufs.push(passphrase);
    bufs.push(salt);
    D = Buffer.concat(bufs);
    for (var j = 0; j < count; ++j) D = crypto.createHash('md5').update(D).digest();
    material = Buffer.concat([material, D]);
    D_prev = D;
  }

  return {key: material.slice(0, clen.key), iv: material.slice(clen.key, clen.key + clen.iv)};
}

function countZeros(buf) {
  var o = 0, obit = 8;
  while (o < buf.length) {
    var mask = 1 << obit;
    if ((buf[o] & mask) === mask) break;
    if (--obit < 0) {
      o++;
      obit = 8;
    }
  }
  return o * 8 + (8 - obit) - 1;
}

function bufferSplit(buf, chr) {
  assert.buffer(buf);
  assert.string(chr);

  var parts = [],
    lastPart = 0;
  for (var matches = 0, i = 0; i < buf.length; ++i) {
    buf[i] === chr.charCodeAt(matches) ? ++matches : (matches = buf[i] === chr.charCodeAt(0) ? 1 : 0);

    if (matches >= chr.length) {
      var newPart = i + 1;
      parts.push(buf.slice(lastPart, newPart - matches));
      lastPart = newPart;
      matches = 0;
    }
  }
  lastPart <= buf.length && parts.push(buf.slice(lastPart, buf.length));

  return parts;
}

function ecNormalize(buf, addZero) {
  assert.buffer(buf);
  if (buf[0] === 0x00 && buf[1] === 0x04) return addZero ? buf : buf.slice(1);
  if (buf[0] === 0x04) {
    if (!addZero) return buf;
  } else {
    while (buf[0] === 0x00) buf = buf.slice(1);
    if (buf[0] === 0x02 || buf[0] === 0x03) throw new Error('Compressed elliptic curve points are not supported');
    if (buf[0] !== 0x04) throw new Error('Not a valid elliptic curve point');
    if (!addZero) return buf;
  }
  var b = Buffer.alloc(buf.length + 1);
  b[0] = 0x0;
  buf.copy(b, 1);
  return b;
}

function readBitString(der, tag) {
  if (tag === void 0) tag = asn1.Ber.BitString;
  var buf = der.readString(tag, true);
  assert.strictEqual(buf[0], 0x00, 'bit strings with unused bits are not supported (0x' + buf[0].toString(16) + ')');
  return buf.slice(1);
}

function writeBitString(der, buf, tag) {
  if (tag === void 0) tag = asn1.Ber.BitString;
  var b = Buffer.alloc(buf.length + 1);
  b[0] = 0x00;
  buf.copy(b, 1);
  der.writeBuffer(b, tag);
}

function mpNormalize(buf) {
  assert.buffer(buf);
  while (buf.length > 1 && buf[0] === 0x00 && (buf[1] & 0x80) == 0x00) buf = buf.slice(1);
  if ((buf[0] & 0x80) == 0x80) {
    var b = Buffer.alloc(buf.length + 1);
    b[0] = 0x00;
    buf.copy(b, 1);
    buf = b;
  }
  return buf;
}

function mpDenormalize(buf) {
  assert.buffer(buf);
  while (buf.length > 1 && buf[0] === 0x00) buf = buf.slice(1);
  return buf;
}

function zeroPadToLength(buf, len) {
  assert.buffer(buf);
  assert.number(len);
  while (buf.length > len) {
    assert.equal(buf[0], 0x00);
    buf = buf.slice(1);
  }
  while (buf.length < len) {
    var b = Buffer.alloc(buf.length + 1);
    b[0] = 0x00;
    buf.copy(b, 1);
    buf = b;
  }
  return buf;
}

function bigintToMpBuf(bigint) {
  var buf = Buffer.from(bigint.toByteArray());
  return mpNormalize(buf);
}

function calculateDSAPublic(g, p, x) {
  assert.buffer(g);
  assert.buffer(p);
  assert.buffer(x);
  try {
    var BigInt = __wpreq__('jsbn').BigInteger;
  } catch (_e) {
    throw new Error('To load a PKCS#8 format DSA private key, the node jsbn library is required.');
  }
  g = new BigInt(g);
  p = new BigInt(p);
  x = new BigInt(x);
  return bigintToMpBuf(g.modPow(x, p));
}

function calculateED25519Public(k) {
  assert.buffer(k);

  if (nacl === void 0) nacl = __wpreq__('tweetnacl');

  var kp = nacl.sign.keyPair.fromSeed(new Uint8Array(k));
  return Buffer.from(kp.publicKey);
}

function calculateX25519Public(k) {
  assert.buffer(k);

  if (nacl === void 0) nacl = __wpreq__('tweetnacl');

  var kp = nacl.box.keyPair.fromSeed(new Uint8Array(k));
  return Buffer.from(kp.publicKey);
}

function addRSAMissing(key) {
  assert.object(key);
  assertCompatible(key, PrivateKey, [1, 1]);
  try {
    var BigInt = __wpreq__('jsbn').BigInteger;
  } catch (_e) {
    throw new Error('To write a PEM private key from this source, the node jsbn lib is required.');
  }

  var buf,
    d = new BigInt(key.part.d.data);

  if (!key.part.dmodp) {
    var p = new BigInt(key.part.p.data);

    buf = bigintToMpBuf(d.mod(p.subtract(1)));
    key.part.dmodp = {name: 'dmodp', data: buf};
    key.parts.push(key.part.dmodp);
  }
  if (!key.part.dmodq) {
    var q = new BigInt(key.part.q.data);

    buf = bigintToMpBuf(d.mod(q.subtract(1)));
    key.part.dmodq = {name: 'dmodq', data: buf};
    key.parts.push(key.part.dmodq);
  }
}

function publicFromPrivateECDSA(curveName, priv) {
  assert.string(curveName, 'curveName');
  assert.buffer(priv);
  if (ec === void 0) ec = __wpreq__('ecc-jsbn/lib/ec');
  if (jsbn === void 0) jsbn = __wpreq__('jsbn').BigInteger;
  var params = algs.curves[curveName],
    p = new jsbn(params.p),
    a = new jsbn(params.a),
    b = new jsbn(params.b),
    curve = new ec.ECCurveFp(p, a, b),
    G = curve.decodePointHex(params.G.toString('hex')),

    d = new jsbn(mpNormalize(priv)),
    pub = G.multiply(d);
  pub = Buffer.from(curve.encodePointHex(pub), 'hex');

  var parts = [];
  parts.push({name: 'curve', data: Buffer.from(curveName)});
  parts.push({name: 'Q', data: pub});

  return new Key({type: 'ecdsa', curve: curve, parts: parts});
}

function opensshCipherInfo(cipher) {
  var inf = {};
  switch (cipher) {
  case '3des-cbc':
    inf.keySize = 24;
    inf.blockSize = 8;
    inf.opensslName = 'des-ede3-cbc';
    break;
  case 'blowfish-cbc':
    inf.keySize = 16;
    inf.blockSize = 8;
    inf.opensslName = 'bf-cbc';
    break;
  case 'aes128-cbc':
  case 'aes128-ctr':
  case 'aes128-gcm@openssh.com':
    inf.keySize = 16;
    inf.blockSize = 16;
    inf.opensslName = 'aes-128-' + cipher.slice(7, 10);
    break;
  case 'aes192-cbc':
  case 'aes192-ctr':
  case 'aes192-gcm@openssh.com':
    inf.keySize = 24;
    inf.blockSize = 16;
    inf.opensslName = 'aes-192-' + cipher.slice(7, 10);
    break;
  case 'aes256-cbc':
  case 'aes256-ctr':
  case 'aes256-gcm@openssh.com':
    inf.keySize = 32;
    inf.blockSize = 16;
    inf.opensslName = 'aes-256-' + cipher.slice(7, 10);
    break;
  default:
    throw new Error('Unsupported openssl cipher "' + cipher + '"');
  }
  return inf;
}
//
},
asn1:
function(module, exports, __wpreq__) {
//
var Ber = __wpreq__('asn1/lib/ber');

module.exports = {
  Ber: Ber,
  BerReader: Ber.Reader,
  BerWriter: Ber.Writer
};
//
},
'asn1/lib/ber':
function(module, exports, __wpreq__) {
//
var errors = __wpreq__('asn1/lib/ber/errors'),
  types = __wpreq__('asn1/lib/ber/types'),

  Reader = __wpreq__('asn1/lib/ber/reader'),
  Writer = __wpreq__('asn1/lib/ber/writer');

module.exports = {Reader: Reader, Writer: Writer};

for (var t in types) if (types.hasOwnProperty(t)) module.exports[t] = types[t];

for (var e in errors) if (errors.hasOwnProperty(e)) module.exports[e] = errors[e];
//
},
'asn1/lib/ber/errors':
function(module) {
//
module.exports = {
  newInvalidAsn1Error: function(msg) {
    var e = new Error();
    e.name = 'InvalidAsn1Error';
    e.message = msg || '';
    return e;
  }
};
//
},
'asn1/lib/ber/types':
function(module) {
//
module.exports = {
  EOC: 0,
  Boolean: 1,
  Integer: 2,
  BitString: 3,
  OctetString: 4,
  Null: 5,
  OID: 6,
  ObjectDescriptor: 7,
  External: 8,
  Real: 9,
  Enumeration: 10,
  PDV: 11,
  Utf8String: 12,
  RelativeOID: 13,
  Sequence: 16,
  Set: 17,
  NumericString: 18,
  PrintableString: 19,
  T61String: 20,
  VideotexString: 21,
  IA5String: 22,
  UTCTime: 23,
  GeneralizedTime: 24,
  GraphicString: 25,
  VisibleString: 26,
  GeneralString: 28,
  UniversalString: 29,
  CharacterString: 30,
  BMPString: 31,
  Constructor: 32,
  Context: 128
};
//
},
'asn1/lib/ber/reader':
function(module, exports, __wpreq__) {
//
var assert = __wpreq__('assert'),
  Buffer = __wpreq__('safer-buffer').Buffer,

  ASN1 = __wpreq__('asn1/lib/ber/types'),

  newInvalidAsn1Error = __wpreq__('asn1/lib/ber/errors').newInvalidAsn1Error;

function Reader(data) {
  if (!data || !Buffer.isBuffer(data)) throw new TypeError('data must be a node Buffer');

  this._buf = data;
  this._size = data.length;

  this._len = 0;
  this._offset = 0;
}

Object.defineProperty(Reader.prototype, 'length', {
  enumerable: true,
  get: function() { return this._len; }
});

Object.defineProperty(Reader.prototype, 'offset', {
  enumerable: true,
  get: function() { return this._offset; }
});

Object.defineProperty(Reader.prototype, 'remain', {
  get: function() { return this._size - this._offset; }
});

Object.defineProperty(Reader.prototype, 'buffer', {
  get: function() { return this._buf.slice(this._offset); }
});

Reader.prototype.readByte = function(peek) {
  if (this._size - this._offset < 1) return null;

  var b = this._buf[this._offset] & 0xff;

  peek || (this._offset += 1);

  return b;
};

Reader.prototype.peek = function() {
  return this.readByte(true);
};

Reader.prototype.readLength = function(offset) {
  if (offset === void 0) offset = this._offset;

  if (offset >= this._size) return null;

  var lenB = this._buf[offset++] & 0xff;
  if (lenB === null) return null;

  if ((lenB & 0x80) == 0x80) {
    if ((lenB &= 0x7f) == 0) throw newInvalidAsn1Error('Indefinite length not supported');

    if (lenB > 4) throw newInvalidAsn1Error('encoding too long');

    if (this._size - offset < lenB) return null;

    this._len = 0;
    for (var i = 0; i < lenB; i++) this._len = (this._len << 8) + (this._buf[offset++] & 0xff);
  } else this._len = lenB;

  return offset;
};

Reader.prototype.readSequence = function(tag) {
  var seq = this.peek();
  if (seq === null) return null;
  if (tag !== void 0 && tag !== seq)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) + ': got 0x' + seq.toString(16));

  var o = this.readLength(this._offset + 1);
  if (o === null) return null;

  this._offset = o;
  return seq;
};

Reader.prototype.readInt = function() {
  return this._readTag(ASN1.Integer);
};

Reader.prototype.readBoolean = function() {
  return this._readTag(ASN1.Boolean) !== 0;
};

Reader.prototype.readEnumeration = function() {
  return this._readTag(ASN1.Enumeration);
};

Reader.prototype.readString = function(tag, retbuf) {
  tag || (tag = ASN1.OctetString);

  var b = this.peek();
  if (b === null) return null;

  if (b !== tag) throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) + ': got 0x' + b.toString(16));

  var o = this.readLength(this._offset + 1);

  if (o === null) return null;

  if (this.length > this._size - o) return null;

  this._offset = o;

  if (this.length === 0) return retbuf ? Buffer.alloc(0) : '';

  var str = this._buf.slice(this._offset, this._offset + this.length);
  this._offset += this.length;

  return retbuf ? str : str.toString('utf8');
};

Reader.prototype.readOID = function(tag) {
  tag || (tag = ASN1.OID);

  var b = this.readString(tag, true);
  if (b === null) return null;

  var values = [],
    value = 0;

  for (var i = 0; i < b.length; i++) {
    var byte = b[i] & 0xff;

    value <<= 7;
    value += byte & 0x7f;
    if ((byte & 0x80) == 0) {
      values.push(value);
      value = 0;
    }
  }

  value = values.shift();
  values.unshift(value % 40);
  values.unshift((value / 40) >> 0);

  return values.join('.');
};

Reader.prototype._readTag = function(tag) {
  assert.ok(tag !== void 0);

  var b = this.peek();

  if (b === null) return null;

  if (b !== tag) throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) + ': got 0x' + b.toString(16));

  var o = this.readLength(this._offset + 1);
  if (o === null) return null;

  if (this.length > 4) throw newInvalidAsn1Error('Integer too long: ' + this.length);

  if (this.length > this._size - o) return null;
  this._offset = o;

  var fb = this._buf[this._offset],
    value = 0;

  for (var i = 0; i < this.length; i++) {
    value <<= 8;
    value |= this._buf[this._offset++] & 0xff;
  }

  if ((fb & 0x80) == 0x80 && i !== 4) value -= 1 << (i * 8);

  return value >> 0;
};

module.exports = Reader;
//
},
'asn1/lib/ber/writer':
function(module, exports, __wpreq__) {
//
var assert = __wpreq__('assert'),
  Buffer = __wpreq__('safer-buffer').Buffer,
  ASN1 = __wpreq__('asn1/lib/ber/types'),

  newInvalidAsn1Error = __wpreq__('asn1/lib/ber/errors').newInvalidAsn1Error,

  DEFAULT_OPTS = {size: 1024, growthFactor: 8};

function merge(from, to) {
  assert.ok(from);
  assert.equal(typeof from, 'object');
  assert.ok(to);
  assert.equal(typeof to, 'object');

  Object.getOwnPropertyNames(from).forEach(function(key) {
    if (to[key]) return;

    var value = Object.getOwnPropertyDescriptor(from, key);
    Object.defineProperty(to, key, value);
  });

  return to;
}

function Writer(options) {
  options = merge(DEFAULT_OPTS, options || {});

  this._buf = Buffer.alloc(options.size || 1024);
  this._size = this._buf.length;
  this._offset = 0;
  this._options = options;

  this._seq = [];
}

Object.defineProperty(Writer.prototype, 'buffer', {
  get: function() {
    if (this._seq.length) throw newInvalidAsn1Error(this._seq.length + ' unended sequence(s)');

    return this._buf.slice(0, this._offset);
  }
});

Writer.prototype.writeByte = function(b) {
  if (typeof b != 'number') throw new TypeError('argument must be a Number');

  this._ensure(1);
  this._buf[this._offset++] = b;
};

Writer.prototype.writeInt = function(i, tag) {
  if (typeof i != 'number') throw new TypeError('argument must be a Number');
  if (typeof tag != 'number') tag = ASN1.Integer;

  var sz = 4;

  while (((i & 0xff800000) == 0 || (i & 0xff800000) == -0x800000) && sz > 1) {
    sz--;
    i <<= 8;
  }

  if (sz > 4) throw newInvalidAsn1Error('BER ints cannot be > 0xffffffff');

  this._ensure(2 + sz);
  this._buf[this._offset++] = tag;
  this._buf[this._offset++] = sz;

  while (sz-- > 0) {
    this._buf[this._offset++] = (i & 0xff000000) >>> 24;
    i <<= 8;
  }
};

Writer.prototype.writeNull = function() {
  this.writeByte(ASN1.Null);
  this.writeByte(0x00);
};

Writer.prototype.writeEnumeration = function(i, tag) {
  if (typeof i != 'number') throw new TypeError('argument must be a Number');
  if (typeof tag != 'number') tag = ASN1.Enumeration;

  return this.writeInt(i, tag);
};

Writer.prototype.writeBoolean = function(b, tag) {
  if (typeof b != 'boolean') throw new TypeError('argument must be a Boolean');
  if (typeof tag != 'number') tag = ASN1.Boolean;

  this._ensure(3);
  this._buf[this._offset++] = tag;
  this._buf[this._offset++] = 0x01;
  this._buf[this._offset++] = b ? 0xff : 0x00;
};

Writer.prototype.writeString = function(s, tag) {
  if (typeof s != 'string') throw new TypeError('argument must be a string (was: ' + typeof s + ')');
  if (typeof tag != 'number') tag = ASN1.OctetString;

  var len = Buffer.byteLength(s);
  this.writeByte(tag);
  this.writeLength(len);
  if (len) {
    this._ensure(len);
    this._buf.write(s, this._offset);
    this._offset += len;
  }
};

Writer.prototype.writeBuffer = function(buf, tag) {
  if (typeof tag != 'number') throw new TypeError('tag must be a number');
  if (!Buffer.isBuffer(buf)) throw new TypeError('argument must be a buffer');

  this.writeByte(tag);
  this.writeLength(buf.length);
  this._ensure(buf.length);
  buf.copy(this._buf, this._offset, 0, buf.length);
  this._offset += buf.length;
};

Writer.prototype.writeStringArray = function(strings) {
  if (!(strings instanceof Array)) throw new TypeError('argument must be an Array[String]');

  var self = this;
  strings.forEach(function(s) {
    self.writeString(s);
  });
};

Writer.prototype.writeOID = function(s, tag) {
  if (typeof s != 'string') throw new TypeError('argument must be a string');
  if (typeof tag != 'number') tag = ASN1.OID;

  if (!/^([0-9]+\.){3,}[0-9]+$/.test(s)) throw new Error('argument is not a valid OID string');

  function encodeOctet(bytes, octet) {
    if (octet < 128) bytes.push(octet);
    else if (octet < 16384) {
      bytes.push((octet >>> 7) | 0x80);
      bytes.push(octet & 0x7F);
    } else if (octet < 2097152) {
      bytes.push((octet >>> 14) | 0x80);
      bytes.push(0xFF & ((octet >>> 7) | 0x80));
      bytes.push(octet & 0x7F);
    } else if (octet < 268435456) {
      bytes.push((octet >>> 21) | 0x80);
      bytes.push(0xFF & ((octet >>> 14) | 0x80));
      bytes.push(0xFF & ((octet >>> 7) | 0x80));
      bytes.push(octet & 0x7F);
    } else {
      bytes.push(0xFF & ((octet >>> 28) | 0x80));
      bytes.push(0xFF & ((octet >>> 21) | 0x80));
      bytes.push(0xFF & ((octet >>> 14) | 0x80));
      bytes.push(0xFF & ((octet >>> 7) | 0x80));
      bytes.push(octet & 0x7F);
    }
  }

  var tmp = s.split('.'),
    bytes = [];
  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
  tmp.slice(2).forEach(function(b) {
    encodeOctet(bytes, parseInt(b, 10));
  });

  var self = this;
  this._ensure(2 + bytes.length);
  this.writeByte(tag);
  this.writeLength(bytes.length);
  bytes.forEach(function(b) {
    self.writeByte(b);
  });
};

Writer.prototype.writeLength = function(len) {
  if (typeof len != 'number') throw new TypeError('argument must be a Number');

  this._ensure(4);

  if (len <= 0x7f) this._buf[this._offset++] = len;
  else if (len <= 0xff) {
    this._buf[this._offset++] = 0x81;
    this._buf[this._offset++] = len;
  } else if (len <= 0xffff) {
    this._buf[this._offset++] = 0x82;
    this._buf[this._offset++] = len >> 8;
    this._buf[this._offset++] = len;
  } else {
    if (len > 0xffffff) throw newInvalidAsn1Error('Length too long (> 4 bytes)');

    this._buf[this._offset++] = 0x83;
    this._buf[this._offset++] = len >> 16;
    this._buf[this._offset++] = len >> 8;
    this._buf[this._offset++] = len;
  }
};

Writer.prototype.startSequence = function(tag) {
  if (typeof tag != 'number') tag = ASN1.Sequence | ASN1.Constructor;

  this.writeByte(tag);
  this._seq.push(this._offset);
  this._ensure(3);
  this._offset += 3;
};

Writer.prototype.endSequence = function() {
  var seq = this._seq.pop(),
    start = seq + 3,
    len = this._offset - start;

  if (len <= 0x7f) {
    this._shift(start, len, -2);
    this._buf[seq] = len;
  } else if (len <= 0xff) {
    this._shift(start, len, -1);
    this._buf[seq] = 0x81;
    this._buf[seq + 1] = len;
  } else if (len <= 0xffff) {
    this._buf[seq] = 0x82;
    this._buf[seq + 1] = len >> 8;
    this._buf[seq + 2] = len;
  } else {
    if (len > 0xffffff) throw newInvalidAsn1Error('Sequence too long');

    this._shift(start, len, 1);
    this._buf[seq] = 0x83;
    this._buf[seq + 1] = len >> 16;
    this._buf[seq + 2] = len >> 8;
    this._buf[seq + 3] = len;
  }
};

Writer.prototype._shift = function(start, len, shift) {
  assert.ok(start !== void 0);
  assert.ok(len !== void 0);
  assert.ok(shift);

  this._buf.copy(this._buf, start + shift, start, start + len);
  this._offset += shift;
};

Writer.prototype._ensure = function(len) {
  assert.ok(len);

  if (this._size - this._offset < len) {
    var sz = this._size * this._options.growthFactor;
    if (sz - this._offset < len) sz += len;

    var buf = Buffer.alloc(sz);

    this._buf.copy(buf, 0, 0, this._offset);
    this._buf = buf;
    this._size = sz;
  }
};

module.exports = Writer;
//
},
jsbn:
function(module) {
//
var dbits,

  //canary
  j_lm = (0xdeadbeefcafe & 0xffffff) == 0xefcafe;

function BigInteger(a, b, c) {
  if (a != null)
    "number" == typeof a
      ? this.fromNumber(a, b, c)
      : b == null && "string" != typeof a
      ? this.fromString(a, 256)
      : this.fromString(a, b);
}

function nbi() { return new BigInteger(null); }

function am1(i, x, w, j, c, n) {
  while (--n >= 0) {
    var v = x * this[i++] + w[j] + c;
    c = Math.floor(v / 0x4000000);
    w[j++] = v & 0x3ffffff;
  }
  return c;
}
function am2(i, x, w, j, c, n) {
  for (var xl = x & 0x7fff, xh = x >> 15; --n >= 0; ) {
    var l = this[i] & 0x7fff,
      h = this[i++] >> 15,
      m = xh * l + h * xl;
    c = ((l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff)) >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
    w[j++] = l & 0x3fffffff;
  }
  return c;
}
function am3(i, x, w, j, c, n) {
  for (var xl = x & 0x3fff, xh = x >> 14; --n >= 0; ) {
    var l = this[i] & 0x3fff,
      h = this[i++] >> 14,
      m = xh * l + h * xl;
    c = ((l = xl * l + ((m & 0x3fff) << 14) + w[j] + c) >> 28) + (m >> 14) + xh * h;
    w[j++] = l & 0xfffffff;
  }
  return c;
}
var inBrowser = typeof navigator != "undefined";
if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
  BigInteger.prototype.am = am2;
  dbits = 30;
} else if (inBrowser && j_lm && navigator.appName != "Netscape") {
  BigInteger.prototype.am = am1;
  dbits = 26;
} else {
  BigInteger.prototype.am = am3;
  dbits = 28;
}

BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = (1 << dbits) - 1;
BigInteger.prototype.DV = 1 << dbits;

var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2, BI_FP);
BigInteger.prototype.F1 = BI_FP - dbits;
BigInteger.prototype.F2 = 2 * dbits - BI_FP;

var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz",
  BI_RC = [];
var rr, vv;
rr = "0".charCodeAt(0);
for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
rr = "a".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
rr = "A".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

function int2char(n) { return BI_RM.charAt(n); }
function intAt(s, i) {
  var c = BI_RC[s.charCodeAt(i)];
  return c == null ? -1 : c;
}

function bnpCopyTo(r) {
  for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
  r.t = this.t;
  r.s = this.s;
}

function bnpFromInt(x) {
  this.t = 1;
  this.s = x < 0 ? -1 : 0;
  x > 0 ? (this[0] = x) : x < -1 ? (this[0] = x + this.DV) : (this.t = 0);
}

function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

function bnpFromString(s, b) {
  var k;
  if (b == 16) k = 4;
  else if (b == 8) k = 3;
  else if (b == 256) k = 8;
  else if (b == 2) k = 1;
  else if (b == 32) k = 5;
  else if (b == 4) k = 2;
  else {
    this.fromRadix(s, b);
    return;
  }
  this.t = 0;
  this.s = 0;
  var mi = false, sh = 0;
  for (var i = s.length; --i >= 0; ) {
    var x = k == 8 ? s[i] & 0xff : intAt(s, i);
    if (x < 0) {
      if (s.charAt(i) == "-") mi = true;
      continue;
    }
    mi = false;
    if (sh == 0) this[this.t++] = x;
    else if (sh + k > this.DB) {
      this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
      this[this.t++] = x >> (this.DB - sh);
    } else this[this.t - 1] |= x << sh;

    if ((sh += k) >= this.DB) sh -= this.DB;
  }
  if (k == 8 && (s[0] & 0x80) != 0) {
    this.s = -1;
    if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
  }
  this.clamp();
  mi && BigInteger.ZERO.subTo(this, this);
}

function bnpClamp() {
  for (var c = this.s & this.DM; this.t > 0 && this[this.t - 1] == c; ) --this.t;
}

function bnToString(b) {
  if (this.s < 0) return "-" + this.negate().toString(b);
  var k;
  if (b == 16) k = 4;
  else if (b == 8) k = 3;
  else if (b == 2) k = 1;
  else if (b == 32) k = 5;
  else if (b == 4) k = 2;
  else return this.toRadix(b);

  var d, km = (1 << k) - 1, m = false, r = "", i = this.t,
    p = this.DB - ((i * this.DB) % k);
  if (i-- > 0) {
    if (p < this.DB && (d = this[i] >> p) > 0) {
      m = true;
      r = int2char(d);
    }
    while (i >= 0) {
      if (p < k) {
        d = (this[i] & ((1 << p) - 1)) << (k - p);
        d |= this[--i] >> (p += this.DB - k);
      } else {
        d = (this[i] >> (p -= k)) & km;
        if (p <= 0) { p += this.DB; --i; }
      }
      if (d > 0) m = true;
      if (m) r += int2char(d);
    }
  }
  return m ? r : "0";
}

function bnNegate() {
  var r = nbi();
  BigInteger.ZERO.subTo(this, r);
  return r;
}

function bnAbs() { return this.s < 0 ? this.negate() : this; }

function bnCompareTo(a) {
  var r = this.s - a.s;
  if (r != 0) return r;
  var i = this.t;
  if ((r = i - a.t) != 0) return this.s < 0 ? -r : r;
  while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;
  return 0;
}

function nbits(x) {
  var t, r = 1;
  if ((t = x >>> 16) != 0) { x = t; r += 16; }
  if ((t = x >> 8) != 0) { x = t; r += 8; }
  if ((t = x >> 4) != 0) { x = t; r += 4; }
  if ((t = x >> 2) != 0) { x = t; r += 2; }
  if ((t = x >> 1) != 0) { x = t; r += 1; }
  return r;
}

function bnBitLength() {
  return this.t <= 0 ? 0 : this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));
}

function bnpDLShiftTo(n, r) {
  var i;
  for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
  for (i = n - 1; i >= 0; --i) r[i] = 0;
  r.t = this.t + n;
  r.s = this.s;
}

function bnpDRShiftTo(n, r) {
  for (var i = n; i < this.t; ++i) r[i - n] = this[i];
  r.t = Math.max(this.t - n, 0);
  r.s = this.s;
}

function bnpLShiftTo(n, r) {
  var bs = n % this.DB,
    cbs = this.DB - bs,
    bm = (1 << cbs) - 1,
    ds = Math.floor(n / this.DB),
    c = (this.s << bs) & this.DM;
  for (var i = this.t - 1; i >= 0; --i) {
    r[i + ds + 1] = (this[i] >> cbs) | c;
    c = (this[i] & bm) << bs;
  }
  for (i = ds - 1; i >= 0; --i) r[i] = 0;
  r[ds] = c;
  r.t = this.t + ds + 1;
  r.s = this.s;
  r.clamp();
}

function bnpRShiftTo(n, r) {
  r.s = this.s;
  var ds = Math.floor(n / this.DB);
  if (ds >= this.t) {
    r.t = 0;
    return;
  }
  var bs = n % this.DB,
    cbs = this.DB - bs,
    bm = (1 << bs) - 1;
  r[0] = this[ds] >> bs;
  for (var i = ds + 1; i < this.t; ++i) {
    r[i - ds - 1] |= (this[i] & bm) << cbs;
    r[i - ds] = this[i] >> bs;
  }
  if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
  r.t = this.t - ds;
  r.clamp();
}

function bnpSubTo(a, r) {
  var i = 0, c = 0;
  for (var m = Math.min(a.t, this.t); i < m; ) {
    c += this[i] - a[i];
    r[i++] = c & this.DM;
    c >>= this.DB;
  }
  if (a.t < this.t) {
    c -= a.s;
    while (i < this.t) {
      c += this[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    c += this.s;
  } else {
    c += this.s;
    while (i < a.t) {
      c -= a[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    c -= a.s;
  }
  r.s = c < 0 ? -1 : 0;
  if (c < -1) r[i++] = this.DV + c;
  else if (c > 0) r[i++] = c;
  r.t = i;
  r.clamp();
}

function bnpMultiplyTo(a, r) {
  var x = this.abs(), y = a.abs(),
    i = x.t;
  r.t = i + y.t;
  while (--i >= 0) r[i] = 0;
  for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
  r.s = 0;
  r.clamp();
  this.s == a.s || BigInteger.ZERO.subTo(r, r);
}

function bnpSquareTo(r) {
  var x = this.abs(),
    i = (r.t = 2 * x.t);
  while (--i >= 0) r[i] = 0;
  for (i = 0; i < x.t - 1; ++i) {
    var c = x.am(i, x[i], r, 2 * i, 0, 1);
    if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
      r[i + x.t] -= x.DV;
      r[i + x.t + 1] = 1;
    }
  }
  if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
  r.s = 0;
  r.clamp();
}

function bnpDivRemTo(m, q, r) {
  var pm = m.abs();
  if (pm.t <= 0) return;
  var pt = this.abs();
  if (pt.t < pm.t) {
    q == null || q.fromInt(0);
    r == null || this.copyTo(r);
    return;
  }
  if (r == null) r = nbi();
  var y = nbi(), ts = this.s, ms = m.s,
    nsh = this.DB - nbits(pm[pm.t - 1]);
  if (nsh > 0) {
    pm.lShiftTo(nsh, y);
    pt.lShiftTo(nsh, r);
  } else {
    pm.copyTo(y);
    pt.copyTo(r);
  }
  var ys = y.t,
    y0 = y[ys - 1];
  if (y0 == 0) return;
  var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0),
    d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2,
    i = r.t, j = i - ys, t = q == null ? nbi() : q;
  y.dlShiftTo(j, t);
  if (r.compareTo(t) >= 0) {
    r[r.t++] = 1;
    r.subTo(t, r);
  }
  BigInteger.ONE.dlShiftTo(ys, t);
  t.subTo(y, y);
  while (y.t < ys) y[y.t++] = 0;
  while (--j >= 0) {
    var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
    if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
      y.dlShiftTo(j, t);
      r.subTo(t, r);
      while (r[i] < --qd) r.subTo(t, r);
    }
  }
  if (q != null) {
    r.drShiftTo(ys, q);
    ts == ms || BigInteger.ZERO.subTo(q, q);
  }
  r.t = ys;
  r.clamp();
  nsh > 0 && r.rShiftTo(nsh, r);
  ts < 0 && BigInteger.ZERO.subTo(r, r);
}

function bnMod(a) {
  var r = nbi();
  this.abs().divRemTo(a, null, r);
  this.s < 0 && r.compareTo(BigInteger.ZERO) > 0 && a.subTo(r, r);
  return r;
}

function Classic(m) { this.m = m; }
function cConvert(x) {
  return x.s < 0 || x.compareTo(this.m) >= 0 ? x.mod(this.m) : x;
}
function cRevert(x) { return x; }
function cReduce(x) { x.divRemTo(this.m, null, x); }
function cMulTo(x, y, r) { x.multiplyTo(y, r); this.reduce(r); }
function cSqrTo(x, r) { x.squareTo(r); this.reduce(r); }

Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;

function bnpInvDigit() {
  if (this.t < 1) return 0;
  var x = this[0];
  if ((x & 1) == 0) return 0;
  var y = x & 3;
  y = (y * (2 - (x & 0xf) * y)) & 0xf;
  y = (y * (2 - (x & 0xff) * y)) & 0xff;
  y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff;
  y = (y * (2 - ((x * y) % this.DV))) % this.DV;
  return y > 0 ? this.DV - y : -y;
}

function Montgomery(m) {
  this.m = m;
  this.mp = m.invDigit();
  this.mpl = this.mp & 0x7fff;
  this.mph = this.mp >> 15;
  this.um = (1 << (m.DB - 15)) - 1;
  this.mt2 = 2 * m.t;
}

function montConvert(x) {
  var r = nbi();
  x.abs().dlShiftTo(this.m.t, r);
  r.divRemTo(this.m, null, r);
  x.s < 0 && r.compareTo(BigInteger.ZERO) > 0 && this.m.subTo(r, r);
  return r;
}

function montRevert(x) {
  var r = nbi();
  x.copyTo(r);
  this.reduce(r);
  return r;
}

function montReduce(x) {
  while (x.t <= this.mt2) x[x.t++] = 0;
  for (var i = 0; i < this.m.t; ++i) {
    var j = x[i] & 0x7fff,
      u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
    x[(j = i + this.m.t)] += this.m.am(0, u0, x, i, 0, this.m.t);
    while (x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
  }
  x.clamp();
  x.drShiftTo(this.m.t, x);
  x.compareTo(this.m) >= 0 && x.subTo(this.m, x);
}

function montSqrTo(x, r) { x.squareTo(r); this.reduce(r); }

function montMulTo(x, y, r) { x.multiplyTo(y, r); this.reduce(r); }

Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;

function bnpIsEven() { return (this.t > 0 ? this[0] & 1 : this.s) == 0; }

function bnpExp(e, z) {
  if (e > 0xffffffff || e < 1) return BigInteger.ONE;
  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
  g.copyTo(r);
  while (--i >= 0) {
    z.sqrTo(r, r2);
    if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);
    else { var t = r; r = r2; r2 = t; }
  }
  return z.revert(r);
}

function bnModPowInt(e, m) {
  var z = e < 256 || m.isEven() ? new Classic(m) : new Montgomery(m);
  return this.exp(e, z);
}

BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
BigInteger.prototype.clamp = bnpClamp;
BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger.prototype.drShiftTo = bnpDRShiftTo;
BigInteger.prototype.lShiftTo = bnpLShiftTo;
BigInteger.prototype.rShiftTo = bnpRShiftTo;
BigInteger.prototype.subTo = bnpSubTo;
BigInteger.prototype.multiplyTo = bnpMultiplyTo;
BigInteger.prototype.squareTo = bnpSquareTo;
BigInteger.prototype.divRemTo = bnpDivRemTo;
BigInteger.prototype.invDigit = bnpInvDigit;
BigInteger.prototype.isEven = bnpIsEven;
BigInteger.prototype.exp = bnpExp;

BigInteger.prototype.toString = bnToString;
BigInteger.prototype.negate = bnNegate;
BigInteger.prototype.abs = bnAbs;
BigInteger.prototype.compareTo = bnCompareTo;
BigInteger.prototype.bitLength = bnBitLength;
BigInteger.prototype.mod = bnMod;
BigInteger.prototype.modPowInt = bnModPowInt;

BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);

function bnClone() { var r = nbi(); this.copyTo(r); return r; }

function bnIntValue() {
  if (this.s < 0) {
    if (this.t == 1) return this[0] - this.DV;
    if (this.t == 0) return -1;
  } else {
    if (this.t == 1) return this[0];
    if (this.t == 0) return 0;
  }
  return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
}

function bnByteValue() { return this.t == 0 ? this.s : (this[0] << 24) >> 24; }

function bnShortValue() { return this.t == 0 ? this.s : (this[0] << 16) >> 16; }

function bnpChunkSize(r) { return Math.floor((Math.LN2 * this.DB) / Math.log(r)); }

function bnSigNum() {
  return this.s < 0 ? -1 : this.t <= 0 || (this.t == 1 && this[0] <= 0) ? 0 : 1;
}

function bnpToRadix(b) {
  if (b == null) b = 10;
  if (this.signum() == 0 || b < 2 || b > 36) return "0";
  var cs = this.chunkSize(b),
    a = Math.pow(b, cs),
    d = nbv(a), y = nbi(), z = nbi(), r = "";
  this.divRemTo(d, y, z);
  while (y.signum() > 0) {
    r = (a + z.intValue()).toString(b).substr(1) + r;
    y.divRemTo(d, y, z);
  }
  return z.intValue().toString(b) + r;
}

function bnpFromRadix(s, b) {
  this.fromInt(0);
  if (b == null) b = 10;
  var mi = false, j = 0, w = 0;
  for (var cs = this.chunkSize(b), d = Math.pow(b, cs), i = 0; i < s.length; ++i) {
    var x = intAt(s, i);
    if (x < 0) {
      if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
      continue;
    }
    w = b * w + x;
    if (++j >= cs) {
      this.dMultiply(d);
      this.dAddOffset(w, 0);
      j = 0;
      w = 0;
    }
  }
  if (j > 0) {
    this.dMultiply(Math.pow(b, j));
    this.dAddOffset(w, 0);
  }
  mi && BigInteger.ZERO.subTo(this, this);
}

function bnpFromNumber(a, b, c) {
  if ("number" == typeof b)
    if (a < 2) this.fromInt(1);
    else {
      this.fromNumber(a, c);
      this.testBit(a - 1) || this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
      this.isEven() && this.dAddOffset(1, 0);
      while (!this.isProbablePrime(b)) {
        this.dAddOffset(2, 0);
        this.bitLength() > a && this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
      }
    }
  else {
    var x = [], t = a & 7;
    x.length = 1 + (a >> 3);
    b.nextBytes(x);
    t > 0 ? (x[0] &= (1 << t) - 1) : (x[0] = 0);
    this.fromString(x, 256);
  }
}

function bnToByteArray() {
  var i = this.t, r = [];
  r[0] = this.s;
  var d, p = this.DB - ((i * this.DB) % 8), k = 0;
  if (i-- > 0) {
    if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p) r[k++] = d | (this.s << (this.DB - p));

    while (i >= 0) {
      if (p < 8) {
        d = (this[i] & ((1 << p) - 1)) << (8 - p);
        d |= this[--i] >> (p += this.DB - 8);
      } else {
        d = (this[i] >> (p -= 8)) & 0xff;
        if (p <= 0) { p += this.DB; --i; }
      }
      if ((d & 0x80) != 0) d |= -256;
      k != 0 || (this.s & 0x80) == (d & 0x80) || ++k;
      if (k > 0 || d != this.s) r[k++] = d;
    }
  }
  return r;
}

function bnEquals(a) { return this.compareTo(a) == 0; }
function bnMin(a) { return this.compareTo(a) < 0 ? this : a; }
function bnMax(a) { return this.compareTo(a) > 0 ? this : a; }

function bnpBitwiseTo(a, op, r) {
  var i, f, m = Math.min(a.t, this.t);
  for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);
  if (a.t < this.t) {
    f = a.s & this.DM;
    for (i = m; i < this.t; ++i) r[i] = op(this[i], f);
    r.t = this.t;
  } else {
    f = this.s & this.DM;
    for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
    r.t = a.t;
  }
  r.s = op(this.s, a.s);
  r.clamp();
}

function op_and(x, y) { return x & y; }
function bnAnd(a) { var r = nbi(); this.bitwiseTo(a, op_and, r); return r; }

function op_or(x, y) { return x | y; }
function bnOr(a) { var r = nbi(); this.bitwiseTo(a, op_or, r); return r; }

function op_xor(x, y) { return x ^ y; }
function bnXor(a) { var r = nbi(); this.bitwiseTo(a, op_xor, r); return r; }

function op_andnot(x, y) { return x & ~y; }
function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a, op_andnot, r); return r; }

function bnNot() {
  var r = nbi();
  for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
  r.t = this.t;
  r.s = ~this.s;
  return r;
}

function bnShiftLeft(n) {
  var r = nbi();
  n < 0 ? this.rShiftTo(-n, r) : this.lShiftTo(n, r);
  return r;
}

function bnShiftRight(n) {
  var r = nbi();
  n < 0 ? this.lShiftTo(-n, r) : this.rShiftTo(n, r);
  return r;
}

function lbit(x) {
  if (x == 0) return -1;
  var r = 0;
  if ((x & 0xffff) == 0) { x >>= 16; r += 16; }
  if ((x & 0xff) == 0) { x >>= 8; r += 8; }
  if ((x & 0xf) == 0) { x >>= 4; r += 4; }
  if ((x & 3) == 0) { x >>= 2; r += 2; }
  (x & 1) != 0 || ++r;
  return r;
}

function bnGetLowestSetBit() {
  for (var i = 0; i < this.t; ++i) if (this[i] != 0) return i * this.DB + lbit(this[i]);

  return this.s < 0 ? this.t * this.DB : -1;
}

function cbit(x) {
  var r = 0;
  while (x != 0) { x &= x - 1; ++r; }
  return r;
}

function bnBitCount() {
  var r = 0;
  for (var x = this.s & this.DM, i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
  return r;
}

function bnTestBit(n) {
  var j = Math.floor(n / this.DB);
  return j >= this.t ? this.s != 0 : (this[j] & (1 << n % this.DB)) != 0;
}

function bnpChangeBit(n, op) {
  var r = BigInteger.ONE.shiftLeft(n);
  this.bitwiseTo(r, op, r);
  return r;
}

function bnSetBit(n) { return this.changeBit(n, op_or); }

function bnClearBit(n) { return this.changeBit(n, op_andnot); }

function bnFlipBit(n) { return this.changeBit(n, op_xor); }

function bnpAddTo(a, r) {
  var i = 0, c = 0;
  for (var m = Math.min(a.t, this.t); i < m; ) {
    c += this[i] + a[i];
    r[i++] = c & this.DM;
    c >>= this.DB;
  }
  if (a.t < this.t) {
    c += a.s;
    while (i < this.t) {
      c += this[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    c += this.s;
  } else {
    c += this.s;
    while (i < a.t) {
      c += a[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    c += a.s;
  }
  r.s = c < 0 ? -1 : 0;
  if (c > 0) r[i++] = c;
  else if (c < -1) r[i++] = this.DV + c;
  r.t = i;
  r.clamp();
}

function bnAdd(a) { var r = nbi(); this.addTo(a, r); return r; }

function bnSubtract(a) { var r = nbi(); this.subTo(a, r); return r; }

function bnMultiply(a) { var r = nbi(); this.multiplyTo(a, r); return r; }

function bnSquare() { var r = nbi(); this.squareTo(r); return r; }

function bnDivide(a) { var r = nbi(); this.divRemTo(a, r, null); return r; }

function bnRemainder(a) { var r = nbi(); this.divRemTo(a, null, r); return r; }

function bnDivideAndRemainder(a) {
  var q = nbi(), r = nbi();
  this.divRemTo(a, q, r);
  return [q, r];
}

function bnpDMultiply(n) {
  this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
  ++this.t;
  this.clamp();
}

function bnpDAddOffset(n, w) {
  if (n == 0) return;
  while (this.t <= w) this[this.t++] = 0;
  this[w] += n;
  while (this[w] >= this.DV) {
    this[w] -= this.DV;
    if (++w >= this.t) this[this.t++] = 0;
    ++this[w];
  }
}

function NullExp() {}
function nNop(x) { return x; }
function nMulTo(x, y, r) { x.multiplyTo(y, r); }
function nSqrTo(x, r) { x.squareTo(r); }

NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo;

function bnPow(e) { return this.exp(e, new NullExp()); }

function bnpMultiplyLowerTo(a, n, r) {
  var j,
    i = Math.min(this.t + a.t, n);
  r.s = 0;
  r.t = i;
  while (i > 0) r[--i] = 0;
  for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
  for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);
  r.clamp();
}

function bnpMultiplyUpperTo(a, n, r) {
  --n;
  var i = (r.t = this.t + a.t - n);
  r.s = 0;
  while (--i >= 0) r[i] = 0;
  for (i = Math.max(n - this.t, 0); i < a.t; ++i) r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
  r.clamp();
  r.drShiftTo(1, r);
}

function Barrett(m) {
  this.r2 = nbi();
  this.q3 = nbi();
  BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
  this.mu = this.r2.divide(m);
  this.m = m;
}

function barrettConvert(x) {
  if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
  if (x.compareTo(this.m) < 0) return x;
  var r = nbi(); x.copyTo(r); this.reduce(r); return r;
}

function barrettRevert(x) { return x; }

function barrettReduce(x) {
  x.drShiftTo(this.m.t - 1, this.r2);
  if (x.t > this.m.t + 1) { x.t = this.m.t + 1; x.clamp(); }
  this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
  this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
  while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
  x.subTo(this.r2, x);
  while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
}

function barrettSqrTo(x, r) { x.squareTo(r); this.reduce(r); }

function barrettMulTo(x, y, r) { x.multiplyTo(y, r); this.reduce(r); }

Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo;

function bnModPow(e, m) {
  var k, z, i = e.bitLength(), r = nbv(1);
  if (i <= 0) return r;
  k = i < 18 ? 1 : i < 48 ? 3 : i < 144 ? 4 : i < 768 ? 5 : 6;
  z = i < 8 ? new Classic(m) : m.isEven() ? new Barrett(m) : new Montgomery(m);

  var g = [], n = 3, k1 = k - 1, km = (1 << k) - 1;
  g[1] = z.convert(this);
  if (k > 1) {
    var g2 = nbi();
    z.sqrTo(g[1], g2);
    while (n <= km) {
      g[n] = nbi();
      z.mulTo(g2, g[n - 2], g[n]);
      n += 2;
    }
  }

  var w, t, j = e.t - 1, is1 = true, r2 = nbi();
  i = nbits(e[j]) - 1;
  while (j >= 0) {
    if (i >= k1) w = (e[j] >> (i - k1)) & km;
    else {
      w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
      if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);
    }

    n = k;
    while ((w & 1) == 0) { w >>= 1; --n; }
    if ((i -= n) < 0) { i += this.DB; --j; }
    if (is1) {
      g[w].copyTo(r);
      is1 = false;
    } else {
      while (n > 1) { z.sqrTo(r, r2); z.sqrTo(r2, r); n -= 2; }
      if (n > 0) z.sqrTo(r, r2);
      else { t = r; r = r2; r2 = t; }
      z.mulTo(r2, g[w], r);
    }

    while (j >= 0 && (e[j] & (1 << i)) == 0) {
      z.sqrTo(r, r2); t = r; r = r2; r2 = t;
      if (--i < 0) { i = this.DB - 1; --j; }
    }
  }
  return z.revert(r);
}

function bnGCD(a) {
  var x = this.s < 0 ? this.negate() : this.clone(),
    y = a.s < 0 ? a.negate() : a.clone();
  if (x.compareTo(y) < 0) { var t = x; // noinspection JSSuspiciousNameCombination
    x = y; y = t; }
  var i = x.getLowestSetBit(), g = y.getLowestSetBit();
  if (g < 0) return x;
  if (i < g) g = i;
  if (g > 0) {
    x.rShiftTo(g, x);
    y.rShiftTo(g, y);
  }
  while (x.signum() > 0) {
    (i = x.getLowestSetBit()) > 0 && x.rShiftTo(i, x);
    (i = y.getLowestSetBit()) > 0 && y.rShiftTo(i, y);
    if (x.compareTo(y) >= 0) {
      x.subTo(y, x);
      x.rShiftTo(1, x);
    } else {
      y.subTo(x, y);
      y.rShiftTo(1, y);
    }
  }
  g > 0 && y.lShiftTo(g, y);
  return y;
}

function bnpModInt(n) {
  if (n <= 0) return 0;
  var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
  if (this.t > 0)
    if (d == 0) r = this[0] % n;
    else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;
  return r;
}

function bnModInverse(m) {
  var ac = m.isEven();
  if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
  var u = m.clone(), v = this.clone(),
    a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
  while (u.signum() != 0) {
    while (u.isEven()) {
      u.rShiftTo(1, u);
      if (ac) {
        if (!a.isEven() || !b.isEven()) {
          a.addTo(this, a);
          b.subTo(m, b);
        }
        a.rShiftTo(1, a);
      } else b.isEven() || b.subTo(m, b);

      b.rShiftTo(1, b);
    }
    while (v.isEven()) {
      v.rShiftTo(1, v);
      if (ac) {
        if (!c.isEven() || !d.isEven()) {
          c.addTo(this, c);
          d.subTo(m, d);
        }
        c.rShiftTo(1, c);
      } else d.isEven() || d.subTo(m, d);

      d.rShiftTo(1, d);
    }
    if (u.compareTo(v) >= 0) {
      u.subTo(v, u);
      ac && a.subTo(c, a);
      b.subTo(d, b);
    } else {
      v.subTo(u, v);
      ac && c.subTo(a, c);
      d.subTo(b, d);
    }
  }
  if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
  if (d.compareTo(m) >= 0) return d.subtract(m);
  if (d.signum() >= 0) return d;
  d.addTo(m, d);
  return d.signum() < 0 ? d.add(m) : d;
}

var lowprimes = [
  2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109,
  113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239,
  241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379,
  383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521,
  523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661,
  673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827,
  829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991,
  997
];
var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];

function bnIsProbablePrime(t) {
  var i, x = this.abs();
  if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
    for (i = 0; i < lowprimes.length; ++i) if (x[0] == lowprimes[i]) return true;
    return false;
  }
  if (x.isEven()) return false;
  for (i = 1; i < lowprimes.length; ) {
    var m = lowprimes[i], j = i + 1;
    while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
    m = x.modInt(m);
    while (i < j) if (m % lowprimes[i++] == 0) return false;
  }
  return x.millerRabin(t);
}

function bnpMillerRabin(t) {
  var n1 = this.subtract(BigInteger.ONE),
    k = n1.getLowestSetBit();
  if (k <= 0) return false;
  var r = n1.shiftRight(k);
  if ((t = (t + 1) >> 1) > lowprimes.length) t = lowprimes.length;
  for (var a = nbi(), i = 0; i < t; ++i) {
    a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
    var y = a.modPow(r, this);
    if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
      for (var j = 1; j++ < k && y.compareTo(n1) != 0; )
        if ((y = y.modPowInt(2, this)).compareTo(BigInteger.ONE) == 0) return false;

      if (y.compareTo(n1) != 0) return false;
    }
  }
  return true;
}

BigInteger.prototype.chunkSize = bnpChunkSize;
BigInteger.prototype.toRadix = bnpToRadix;
BigInteger.prototype.fromRadix = bnpFromRadix;
BigInteger.prototype.fromNumber = bnpFromNumber;
BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger.prototype.changeBit = bnpChangeBit;
BigInteger.prototype.addTo = bnpAddTo;
BigInteger.prototype.dMultiply = bnpDMultiply;
BigInteger.prototype.dAddOffset = bnpDAddOffset;
BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger.prototype.modInt = bnpModInt;
BigInteger.prototype.millerRabin = bnpMillerRabin;

BigInteger.prototype.clone = bnClone;
BigInteger.prototype.intValue = bnIntValue;
BigInteger.prototype.byteValue = bnByteValue;
BigInteger.prototype.shortValue = bnShortValue;
BigInteger.prototype.signum = bnSigNum;
BigInteger.prototype.toByteArray = bnToByteArray;
BigInteger.prototype.equals = bnEquals;
BigInteger.prototype.min = bnMin;
BigInteger.prototype.max = bnMax;
BigInteger.prototype.and = bnAnd;
BigInteger.prototype.or = bnOr;
BigInteger.prototype.xor = bnXor;
BigInteger.prototype.andNot = bnAndNot;
BigInteger.prototype.not = bnNot;
BigInteger.prototype.shiftLeft = bnShiftLeft;
BigInteger.prototype.shiftRight = bnShiftRight;
BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger.prototype.bitCount = bnBitCount;
BigInteger.prototype.testBit = bnTestBit;
BigInteger.prototype.setBit = bnSetBit;
BigInteger.prototype.clearBit = bnClearBit;
BigInteger.prototype.flipBit = bnFlipBit;
BigInteger.prototype.add = bnAdd;
BigInteger.prototype.subtract = bnSubtract;
BigInteger.prototype.multiply = bnMultiply;
BigInteger.prototype.divide = bnDivide;
BigInteger.prototype.remainder = bnRemainder;
BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger.prototype.modPow = bnModPow;
BigInteger.prototype.modInverse = bnModInverse;
BigInteger.prototype.pow = bnPow;
BigInteger.prototype.gcd = bnGCD;
BigInteger.prototype.isProbablePrime = bnIsProbablePrime;

BigInteger.prototype.square = bnSquare;

BigInteger.prototype.Barrett = Barrett

var rng_state, rng_pool, rng_pptr;

function rng_seed_int(x) {
  rng_pool[rng_pptr++] ^= x & 255;
  rng_pool[rng_pptr++] ^= (x >> 8) & 255;
  rng_pool[rng_pptr++] ^= (x >> 16) & 255;
  rng_pool[rng_pptr++] ^= (x >> 24) & 255;
  if (rng_pptr >= rng_psize) rng_pptr -= rng_psize;
}

function rng_seed_time() {
  rng_seed_int(new Date().getTime());
}

if (rng_pool == null) {
  rng_pool = [];
  rng_pptr = 0;
  var t;
  if (typeof window != "undefined" && window.crypto)
    if (window.crypto.getRandomValues) {
      var ua = new Uint8Array(32);
      window.crypto.getRandomValues(ua);
      for (t = 0; t < 32; ++t) rng_pool[rng_pptr++] = ua[t];
    } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
      var z = window.crypto.random(32);
      for (t = 0; t < z.length; ++t) rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
    }

  while (rng_pptr < rng_psize) {
    t = Math.floor(65536 * Math.random());
    rng_pool[rng_pptr++] = t >>> 8;
    rng_pool[rng_pptr++] = t & 255;
  }
  rng_pptr = 0;
  rng_seed_time();
}

function rng_get_byte() {
  if (rng_state == null) {
    rng_seed_time();
    (rng_state = prng_newstate()).init(rng_pool);
    for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) rng_pool[rng_pptr] = 0;
    rng_pptr = 0;
  }
  return rng_state.next();
}

function rng_get_bytes(ba) {
  for (var i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
}

function SecureRandom() {}

SecureRandom.prototype.nextBytes = rng_get_bytes;

function Arcfour() {
  this.i = 0;
  this.j = 0;
  this.S = [];
}

function ARC4init(key) {
  var i, j, t;
  for (i = 0; i < 256; ++i) this.S[i] = i;
  j = 0;
  for (i = 0; i < 256; ++i) {
    j = (j + this.S[i] + key[i % key.length]) & 255;
    t = this.S[i];
    this.S[i] = this.S[j];
    this.S[j] = t;
  }
  this.i = 0;
  this.j = 0;
}

function ARC4next() {
  var t;
  this.i = (this.i + 1) & 255;
  this.j = (this.j + this.S[this.i]) & 255;
  t = this.S[this.i];
  this.S[this.i] = this.S[this.j];
  this.S[this.j] = t;
  return this.S[(t + this.S[this.i]) & 255];
}

Arcfour.prototype.init = ARC4init;
Arcfour.prototype.next = ARC4next;

function prng_newstate() {
  return new Arcfour();
}

var rng_psize = 256;

BigInteger.SecureRandom = SecureRandom;
BigInteger.BigInteger = BigInteger;

/*exports =*/ module.exports = BigInteger;
//
},
tweetnacl:
function(module, exports, __wpreq__) {
//
var nacl = module.exports;

var gf = function(init) {
  var i, r = new Float64Array(16);
  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
  return r;
};

var randombytes = function() { throw new Error('no PRNG'); };

var _0 = new Uint8Array(16),
  _9 = new Uint8Array(32); _9[0] = 9;

var gf0 = gf(),
  gf1 = gf([1]),
  _121665 = gf([0xdb41, 1]);
var D = gf([
  0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f,
  0x6cee, 0x5203
]);
var D2 = gf([
  0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df,
  0xd9dc, 0x2406
]);
var X = gf([
  0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e,
  0x36d3, 0x2169
]);
var Y = gf([
  0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666,
  0x6666, 0x6666
]);
var I = gf([
  0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1,
  0x2480, 0x2b83
]);

function ts64(x, i, h, l) {
  x[i] = (h >> 24) & 0xff;
  x[i + 1] = (h >> 16) & 0xff;
  x[i + 2] = (h >> 8) & 0xff;
  x[i + 3] = h & 0xff;
  x[i + 4] = (l >> 24) & 0xff;
  x[i + 5] = (l >> 16) & 0xff;
  x[i + 6] = (l >> 8) & 0xff;
  x[i + 7] = l & 0xff;
}

function vn(x, xi, y, yi, n) {
  var i, d = 0;
  for (i = 0; i < n; i++) d |= x[xi + i] ^ y[yi + i];
  return (1 & ((d - 1) >>> 8)) - 1;
}

function crypto_verify_16(x, xi, y, yi) {
  return vn(x, xi, y, yi, 16);
}

function crypto_verify_32(x, xi, y, yi) {
  return vn(x, xi, y, yi, 32);
}

function core_salsa20(o, p, k, c) {
  var j0 = (c[0] & 0xff) | ((c[1] & 0xff) << 8) | ((c[2] & 0xff) << 16) | ((c[3] & 0xff) << 24),
    j1 = (k[0] & 0xff) | ((k[1] & 0xff) << 8) | ((k[2] & 0xff) << 16) | ((k[3] & 0xff) << 24),
    j2 = (k[4] & 0xff) | ((k[5] & 0xff) << 8) | ((k[6] & 0xff) << 16) | ((k[7] & 0xff) << 24),
    j3 = (k[8] & 0xff) | ((k[9] & 0xff) << 8) | ((k[10] & 0xff) << 16) | ((k[11] & 0xff) << 24),
    j4 = (k[12] & 0xff) | ((k[13] & 0xff) << 8) | ((k[14] & 0xff) << 16) | ((k[15] & 0xff) << 24),
    j5 = (c[4] & 0xff) | ((c[5] & 0xff) << 8) | ((c[6] & 0xff) << 16) | ((c[7] & 0xff) << 24),
    j6 = (p[0] & 0xff) | ((p[1] & 0xff) << 8) | ((p[2] & 0xff) << 16) | ((p[3] & 0xff) << 24),
    j7 = (p[4] & 0xff) | ((p[5] & 0xff) << 8) | ((p[6] & 0xff) << 16) | ((p[7] & 0xff) << 24),
    j8 = (p[8] & 0xff) | ((p[9] & 0xff) << 8) | ((p[10] & 0xff) << 16) | ((p[11] & 0xff) << 24),
    j9 = (p[12] & 0xff) | ((p[13] & 0xff) << 8) | ((p[14] & 0xff) << 16) | ((p[15] & 0xff) << 24),
    j10 = (c[8] & 0xff) | ((c[9] & 0xff) << 8) | ((c[10] & 0xff) << 16) | ((c[11] & 0xff) << 24),
    j11 = (k[16] & 0xff) | ((k[17] & 0xff) << 8) | ((k[18] & 0xff) << 16) | ((k[19] & 0xff) << 24),
    j12 = (k[20] & 0xff) | ((k[21] & 0xff) << 8) | ((k[22] & 0xff) << 16) | ((k[23] & 0xff) << 24),
    j13 = (k[24] & 0xff) | ((k[25] & 0xff) << 8) | ((k[26] & 0xff) << 16) | ((k[27] & 0xff) << 24),
    j14 = (k[28] & 0xff) | ((k[29] & 0xff) << 8) | ((k[30] & 0xff) << 16) | ((k[31] & 0xff) << 24),
    j15 = (c[12] & 0xff) | ((c[13] & 0xff) << 8) | ((c[14] & 0xff) << 16) | ((c[15] & 0xff) << 24);

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
    x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
    x15 = j15;

  for (var u, i = 0; i < 20; i += 2) {
    x4 ^= ((u = (x0 + x12) | 0) << 7) | (u >>> 25);
    x8 ^= ((u = (x4 + x0) | 0) << 9) | (u >>> 23);
    x12 ^= ((u = (x8 + x4) | 0) << 13) | (u >>> 19);
    x0 ^= ((u = (x12 + x8) | 0) << 18) | (u >>> 14);

    x9 ^= ((u = (x5 + x1) | 0) << 7) | (u >>> 25);
    x13 ^= ((u = (x9 + x5) | 0) << 9) | (u >>> 23);
    x1 ^= ((u = (x13 + x9) | 0) << 13) | (u >>> 19);
    x5 ^= ((u = (x1 + x13) | 0) << 18) | (u >>> 14);

    x14 ^= ((u = (x10 + x6) | 0) << 7) | (u >>> 25);
    x2 ^= ((u = (x14 + x10) | 0) << 9) | (u >>> 23);
    x6 ^= ((u = (x2 + x14) | 0) << 13) | (u >>> 19);
    x10 ^= ((u = (x6 + x2) | 0) << 18) | (u >>> 14);

    x3 ^= ((u = (x15 + x11) | 0) << 7) | (u >>> 25);
    x7 ^= ((u = (x3 + x15) | 0) << 9) | (u >>> 23);
    x11 ^= ((u = (x7 + x3) | 0) << 13) | (u >>> 19);
    x15 ^= ((u = (x11 + x7) | 0) << 18) | (u >>> 14);

    x1 ^= ((u = (x0 + x3) | 0) << 7) | (u >>> 25);
    x2 ^= ((u = (x1 + x0) | 0) << 9) | (u >>> 23);
    x3 ^= ((u = (x2 + x1) | 0) << 13) | (u >>> 19);
    x0 ^= ((u = (x3 + x2) | 0) << 18) | (u >>> 14);

    x6 ^= ((u = (x5 + x4) | 0) << 7) | (u >>> 25);
    x7 ^= ((u = (x6 + x5) | 0) << 9) | (u >>> 23);
    x4 ^= ((u = (x7 + x6) | 0) << 13) | (u >>> 19);
    x5 ^= ((u = (x4 + x7) | 0) << 18) | (u >>> 14);

    x11 ^= ((u = (x10 + x9) | 0) << 7) | (u >>> 25);
    x8 ^= ((u = (x11 + x10) | 0) << 9) | (u >>> 23);
    x9 ^= ((u = (x8 + x11) | 0) << 13) | (u >>> 19);
    x10 ^= ((u = (x9 + x8) | 0) << 18) | (u >>> 14);

    x12 ^= ((u = (x15 + x14) | 0) << 7) | (u >>> 25);
    x13 ^= ((u = (x12 + x15) | 0) << 9) | (u >>> 23);
    x14 ^= ((u = (x13 + x12) | 0) << 13) | (u >>> 19);
    x15 ^= ((u = (x14 + x13) | 0) << 18) | (u >>> 14);
  }
  x0 = (x0 + j0) | 0;
  x1 = (x1 + j1) | 0;
  x2 = (x2 + j2) | 0;
  x3 = (x3 + j3) | 0;
  x4 = (x4 + j4) | 0;
  x5 = (x5 + j5) | 0;
  x6 = (x6 + j6) | 0;
  x7 = (x7 + j7) | 0;
  x8 = (x8 + j8) | 0;
  x9 = (x9 + j9) | 0;
  x10 = (x10 + j10) | 0;
  x11 = (x11 + j11) | 0;
  x12 = (x12 + j12) | 0;
  x13 = (x13 + j13) | 0;
  x14 = (x14 + j14) | 0;
  x15 = (x15 + j15) | 0;

  o[0] = (x0 >>> 0) & 0xff;
  o[1] = (x0 >>> 8) & 0xff;
  o[2] = (x0 >>> 16) & 0xff;
  o[3] = (x0 >>> 24) & 0xff;

  o[4] = (x1 >>> 0) & 0xff;
  o[5] = (x1 >>> 8) & 0xff;
  o[6] = (x1 >>> 16) & 0xff;
  o[7] = (x1 >>> 24) & 0xff;

  o[8] = (x2 >>> 0) & 0xff;
  o[9] = (x2 >>> 8) & 0xff;
  o[10] = (x2 >>> 16) & 0xff;
  o[11] = (x2 >>> 24) & 0xff;

  o[12] = (x3 >>> 0) & 0xff;
  o[13] = (x3 >>> 8) & 0xff;
  o[14] = (x3 >>> 16) & 0xff;
  o[15] = (x3 >>> 24) & 0xff;

  o[16] = (x4 >>> 0) & 0xff;
  o[17] = (x4 >>> 8) & 0xff;
  o[18] = (x4 >>> 16) & 0xff;
  o[19] = (x4 >>> 24) & 0xff;

  o[20] = (x5 >>> 0) & 0xff;
  o[21] = (x5 >>> 8) & 0xff;
  o[22] = (x5 >>> 16) & 0xff;
  o[23] = (x5 >>> 24) & 0xff;

  o[24] = (x6 >>> 0) & 0xff;
  o[25] = (x6 >>> 8) & 0xff;
  o[26] = (x6 >>> 16) & 0xff;
  o[27] = (x6 >>> 24) & 0xff;

  o[28] = (x7 >>> 0) & 0xff;
  o[29] = (x7 >>> 8) & 0xff;
  o[30] = (x7 >>> 16) & 0xff;
  o[31] = (x7 >>> 24) & 0xff;

  o[32] = (x8 >>> 0) & 0xff;
  o[33] = (x8 >>> 8) & 0xff;
  o[34] = (x8 >>> 16) & 0xff;
  o[35] = (x8 >>> 24) & 0xff;

  o[36] = (x9 >>> 0) & 0xff;
  o[37] = (x9 >>> 8) & 0xff;
  o[38] = (x9 >>> 16) & 0xff;
  o[39] = (x9 >>> 24) & 0xff;

  o[40] = (x10 >>> 0) & 0xff;
  o[41] = (x10 >>> 8) & 0xff;
  o[42] = (x10 >>> 16) & 0xff;
  o[43] = (x10 >>> 24) & 0xff;

  o[44] = (x11 >>> 0) & 0xff;
  o[45] = (x11 >>> 8) & 0xff;
  o[46] = (x11 >>> 16) & 0xff;
  o[47] = (x11 >>> 24) & 0xff;

  o[48] = (x12 >>> 0) & 0xff;
  o[49] = (x12 >>> 8) & 0xff;
  o[50] = (x12 >>> 16) & 0xff;
  o[51] = (x12 >>> 24) & 0xff;

  o[52] = (x13 >>> 0) & 0xff;
  o[53] = (x13 >>> 8) & 0xff;
  o[54] = (x13 >>> 16) & 0xff;
  o[55] = (x13 >>> 24) & 0xff;

  o[56] = (x14 >>> 0) & 0xff;
  o[57] = (x14 >>> 8) & 0xff;
  o[58] = (x14 >>> 16) & 0xff;
  o[59] = (x14 >>> 24) & 0xff;

  o[60] = (x15 >>> 0) & 0xff;
  o[61] = (x15 >>> 8) & 0xff;
  o[62] = (x15 >>> 16) & 0xff;
  o[63] = (x15 >>> 24) & 0xff;
}

function core_hsalsa20(o, p, k, c) {
  var x0 = (c[0] & 0xff) | ((c[1] & 0xff) << 8) | ((c[2] & 0xff) << 16) | ((c[3] & 0xff) << 24),
    x1 = (k[0] & 0xff) | ((k[1] & 0xff) << 8) | ((k[2] & 0xff) << 16) | ((k[3] & 0xff) << 24),
    x2 = (k[4] & 0xff) | ((k[5] & 0xff) << 8) | ((k[6] & 0xff) << 16) | ((k[7] & 0xff) << 24),
    x3 = (k[8] & 0xff) | ((k[9] & 0xff) << 8) | ((k[10] & 0xff) << 16) | ((k[11] & 0xff) << 24),
    x4 = (k[12] & 0xff) | ((k[13] & 0xff) << 8) | ((k[14] & 0xff) << 16) | ((k[15] & 0xff) << 24),
    x5 = (c[4] & 0xff) | ((c[5] & 0xff) << 8) | ((c[6] & 0xff) << 16) | ((c[7] & 0xff) << 24),
    x6 = (p[0] & 0xff) | ((p[1] & 0xff) << 8) | ((p[2] & 0xff) << 16) | ((p[3] & 0xff) << 24),
    x7 = (p[4] & 0xff) | ((p[5] & 0xff) << 8) | ((p[6] & 0xff) << 16) | ((p[7] & 0xff) << 24),
    x8 = (p[8] & 0xff) | ((p[9] & 0xff) << 8) | ((p[10] & 0xff) << 16) | ((p[11] & 0xff) << 24),
    x9 = (p[12] & 0xff) | ((p[13] & 0xff) << 8) | ((p[14] & 0xff) << 16) | ((p[15] & 0xff) << 24),
    x10 = (c[8] & 0xff) | ((c[9] & 0xff) << 8) | ((c[10] & 0xff) << 16) | ((c[11] & 0xff) << 24),
    x11 = (k[16] & 0xff) | ((k[17] & 0xff) << 8) | ((k[18] & 0xff) << 16) | ((k[19] & 0xff) << 24),
    x12 = (k[20] & 0xff) | ((k[21] & 0xff) << 8) | ((k[22] & 0xff) << 16) | ((k[23] & 0xff) << 24),
    x13 = (k[24] & 0xff) | ((k[25] & 0xff) << 8) | ((k[26] & 0xff) << 16) | ((k[27] & 0xff) << 24),
    x14 = (k[28] & 0xff) | ((k[29] & 0xff) << 8) | ((k[30] & 0xff) << 16) | ((k[31] & 0xff) << 24),
    x15 = (c[12] & 0xff) | ((c[13] & 0xff) << 8) | ((c[14] & 0xff) << 16) | ((c[15] & 0xff) << 24);

  for (var u, i = 0; i < 20; i += 2) {
    x4 ^= ((u = (x0 + x12) | 0) << 7) | (u >>> 25);
    x8 ^= ((u = (x4 + x0) | 0) << 9) | (u >>> 23);
    x12 ^= ((u = (x8 + x4) | 0) << 13) | (u >>> 19);
    x0 ^= ((u = (x12 + x8) | 0) << 18) | (u >>> 14);

    x9 ^= ((u = (x5 + x1) | 0) << 7) | (u >>> 25);
    x13 ^= ((u = (x9 + x5) | 0) << 9) | (u >>> 23);
    x1 ^= ((u = (x13 + x9) | 0) << 13) | (u >>> 19);
    x5 ^= ((u = (x1 + x13) | 0) << 18) | (u >>> 14);

    x14 ^= ((u = (x10 + x6) | 0) << 7) | (u >>> 25);
    x2 ^= ((u = (x14 + x10) | 0) << 9) | (u >>> 23);
    x6 ^= ((u = (x2 + x14) | 0) << 13) | (u >>> 19);
    x10 ^= ((u = (x6 + x2) | 0) << 18) | (u >>> 14);

    x3 ^= ((u = (x15 + x11) | 0) << 7) | (u >>> 25);
    x7 ^= ((u = (x3 + x15) | 0) << 9) | (u >>> 23);
    x11 ^= ((u = (x7 + x3) | 0) << 13) | (u >>> 19);
    x15 ^= ((u = (x11 + x7) | 0) << 18) | (u >>> 14);

    x1 ^= ((u = (x0 + x3) | 0) << 7) | (u >>> 25);
    x2 ^= ((u = (x1 + x0) | 0) << 9) | (u >>> 23);
    x3 ^= ((u = (x2 + x1) | 0) << 13) | (u >>> 19);
    x0 ^= ((u = (x3 + x2) | 0) << 18) | (u >>> 14);

    x6 ^= ((u = (x5 + x4) | 0) << 7) | (u >>> 25);
    x7 ^= ((u = (x6 + x5) | 0) << 9) | (u >>> 23);
    x4 ^= ((u = (x7 + x6) | 0) << 13) | (u >>> 19);
    x5 ^= ((u = (x4 + x7) | 0) << 18) | (u >>> 14);

    x11 ^= ((u = (x10 + x9) | 0) << 7) | (u >>> 25);
    x8 ^= ((u = (x11 + x10) | 0) << 9) | (u >>> 23);
    x9 ^= ((u = (x8 + x11) | 0) << 13) | (u >>> 19);
    x10 ^= ((u = (x9 + x8) | 0) << 18) | (u >>> 14);

    x12 ^= ((u = (x15 + x14) | 0) << 7) | (u >>> 25);
    x13 ^= ((u = (x12 + x15) | 0) << 9) | (u >>> 23);
    x14 ^= ((u = (x13 + x12) | 0) << 13) | (u >>> 19);
    x15 ^= ((u = (x14 + x13) | 0) << 18) | (u >>> 14);
  }

  o[0] = (x0 >>> 0) & 0xff;
  o[1] = (x0 >>> 8) & 0xff;
  o[2] = (x0 >>> 16) & 0xff;
  o[3] = (x0 >>> 24) & 0xff;

  o[4] = (x5 >>> 0) & 0xff;
  o[5] = (x5 >>> 8) & 0xff;
  o[6] = (x5 >>> 16) & 0xff;
  o[7] = (x5 >>> 24) & 0xff;

  o[8] = (x10 >>> 0) & 0xff;
  o[9] = (x10 >>> 8) & 0xff;
  o[10] = (x10 >>> 16) & 0xff;
  o[11] = (x10 >>> 24) & 0xff;

  o[12] = (x15 >>> 0) & 0xff;
  o[13] = (x15 >>> 8) & 0xff;
  o[14] = (x15 >>> 16) & 0xff;
  o[15] = (x15 >>> 24) & 0xff;

  o[16] = (x6 >>> 0) & 0xff;
  o[17] = (x6 >>> 8) & 0xff;
  o[18] = (x6 >>> 16) & 0xff;
  o[19] = (x6 >>> 24) & 0xff;

  o[20] = (x7 >>> 0) & 0xff;
  o[21] = (x7 >>> 8) & 0xff;
  o[22] = (x7 >>> 16) & 0xff;
  o[23] = (x7 >>> 24) & 0xff;

  o[24] = (x8 >>> 0) & 0xff;
  o[25] = (x8 >>> 8) & 0xff;
  o[26] = (x8 >>> 16) & 0xff;
  o[27] = (x8 >>> 24) & 0xff;

  o[28] = (x9 >>> 0) & 0xff;
  o[29] = (x9 >>> 8) & 0xff;
  o[30] = (x9 >>> 16) & 0xff;
  o[31] = (x9 >>> 24) & 0xff;
}

function crypto_core_salsa20(out, inp, k, c) {
  core_salsa20(out, inp, k, c);
}

function crypto_core_hsalsa20(out, inp, k, c) {
  core_hsalsa20(out, inp, k, c);
}

var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);

function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
  var u, i,
    z = new Uint8Array(16), x = new Uint8Array(64);
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x, z, k, sigma);
    for (i = 0; i < 64; i++) c[cpos + i] = m[mpos + i] ^ x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = (u + (z[i] & 0xff)) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
    mpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x, z, k, sigma);
    for (i = 0; i < b; i++) c[cpos + i] = m[mpos + i] ^ x[i];
  }
  return 0;
}

function crypto_stream_salsa20(c, cpos, b, n, k) {
  var u, i,
    z = new Uint8Array(16), x = new Uint8Array(64);
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x, z, k, sigma);
    for (i = 0; i < 64; i++) c[cpos + i] = x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = (u + (z[i] & 0xff)) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x, z, k, sigma);
    for (i = 0; i < b; i++) c[cpos + i] = x[i];
  }
  return 0;
}

function crypto_stream(c, cpos, d, n, k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s, n, k, sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
  return crypto_stream_salsa20(c, cpos, d, sn, s);
}

function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s, n, k, sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
  return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
}

var poly1305 = function(key) {
  this.buffer = new Uint8Array(16);
  this.r = new Uint16Array(10);
  this.h = new Uint16Array(10);
  this.pad = new Uint16Array(8);
  this.leftover = 0;
  this.fin = 0;

  var t0, t1, t2, t3, t4, t5, t6, t7;

  t0 = (key[0] & 0xff) | ((key[1] & 0xff) << 8); this.r[0] = t0 & 0x1fff;
  t1 = (key[2] & 0xff) | ((key[3] & 0xff) << 8); this.r[1] = 0x1fff & ((t0 >>> 13) | (t1 << 3));
  t2 = (key[4] & 0xff) | ((key[5] & 0xff) << 8); this.r[2] = 0x1f03 & ((t1 >>> 10) | (t2 << 6));
  t3 = (key[6] & 0xff) | ((key[7] & 0xff) << 8); this.r[3] = 0x1fff & ((t2 >>> 7) | (t3 << 9));
  t4 = (key[8] & 0xff) | ((key[9] & 0xff) << 8); this.r[4] = 0x00ff & ((t3 >>> 4) | (t4 << 12));
  this.r[5] = (t4 >>> 1) & 0x1ffe;
  t5 = (key[10] & 0xff) | ((key[11] & 0xff) << 8); this.r[6] = 0x1fff & ((t4 >>> 14) | (t5 << 2));
  t6 = (key[12] & 0xff) | ((key[13] & 0xff) << 8); this.r[7] = 0x1f81 & ((t5 >>> 11) | (t6 << 5));
  t7 = (key[14] & 0xff) | ((key[15] & 0xff) << 8); this.r[8] = 0x1fff & ((t6 >>> 8) | (t7 << 8));
  this.r[9] = (t7 >>> 5) & 0x007f;

  this.pad[0] = (key[16] & 0xff) | ((key[17] & 0xff) << 8);
  this.pad[1] = (key[18] & 0xff) | ((key[19] & 0xff) << 8);
  this.pad[2] = (key[20] & 0xff) | ((key[21] & 0xff) << 8);
  this.pad[3] = (key[22] & 0xff) | ((key[23] & 0xff) << 8);
  this.pad[4] = (key[24] & 0xff) | ((key[25] & 0xff) << 8);
  this.pad[5] = (key[26] & 0xff) | ((key[27] & 0xff) << 8);
  this.pad[6] = (key[28] & 0xff) | ((key[29] & 0xff) << 8);
  this.pad[7] = (key[30] & 0xff) | ((key[31] & 0xff) << 8);
};

poly1305.prototype.blocks = function(m, mpos, bytes) {
  var hibit = this.fin ? 0 : 1 << 11;
  var t0, t1, t2, t3, t4, t5, t6, t7, c;
  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

  var h0 = this.h[0],
    h1 = this.h[1],
    h2 = this.h[2],
    h3 = this.h[3],
    h4 = this.h[4],
    h5 = this.h[5],
    h6 = this.h[6],
    h7 = this.h[7],
    h8 = this.h[8],
    h9 = this.h[9];

  var r0 = this.r[0],
    r1 = this.r[1],
    r2 = this.r[2],
    r3 = this.r[3],
    r4 = this.r[4],
    r5 = this.r[5],
    r6 = this.r[6],
    r7 = this.r[7],
    r8 = this.r[8],
    r9 = this.r[9];

  while (bytes >= 16) {
    h0 += 0x1fff & (t0 = (m[mpos + 0] & 0xff) | ((m[mpos + 1] & 0xff) << 8));
    h1 += 0x1fff & ((t0 >>> 13) | ((t1 = (m[mpos + 2] & 0xff) | ((m[mpos + 3] & 0xff) << 8)) << 3));
    h2 += 0x1fff & ((t1 >>> 10) | ((t2 = (m[mpos + 4] & 0xff) | ((m[mpos + 5] & 0xff) << 8)) << 6));
    h3 += 0x1fff & ((t2 >>> 7) | ((t3 = (m[mpos + 6] & 0xff) | ((m[mpos + 7] & 0xff) << 8)) << 9));
    h4 += 0x1fff & ((t3 >>> 4) | ((t4 = (m[mpos + 8] & 0xff) | ((m[mpos + 9] & 0xff) << 8)) << 12));
    h5 += (t4 >>> 1) & 0x1fff;
    h6 += 0x1fff & ((t4 >>> 14) | ((t5 = (m[mpos + 10] & 0xff) | ((m[mpos + 11] & 0xff) << 8)) << 2));
    h7 += 0x1fff & ((t5 >>> 11) | ((t6 = (m[mpos + 12] & 0xff) | ((m[mpos + 13] & 0xff) << 8)) << 5));
    h8 += 0x1fff & ((t6 >>> 8) | ((t7 = (m[mpos + 14] & 0xff) | ((m[mpos + 15] & 0xff) << 8)) << 8));
    h9 += (t7 >>> 5) | hibit;

    d0 = c = 0;

    d0 += h0 * r0;
    d0 += h1 * (5 * r9);
    d0 += h2 * (5 * r8);
    d0 += h3 * (5 * r7);
    d0 += h4 * (5 * r6);
    c = d0 >>> 13; d0 &= 0x1fff;
    d0 += h5 * (5 * r5);
    d0 += h6 * (5 * r4);
    d0 += h7 * (5 * r3);
    d0 += h8 * (5 * r2);
    d0 += h9 * (5 * r1);
    c += d0 >>> 13; d0 &= 0x1fff;

    d1 = c;
    d1 += h0 * r1;
    d1 += h1 * r0;
    d1 += h2 * (5 * r9);
    d1 += h3 * (5 * r8);
    d1 += h4 * (5 * r7);
    c = d1 >>> 13; d1 &= 0x1fff;
    d1 += h5 * (5 * r6);
    d1 += h6 * (5 * r5);
    d1 += h7 * (5 * r4);
    d1 += h8 * (5 * r3);
    d1 += h9 * (5 * r2);
    c += d1 >>> 13; d1 &= 0x1fff;

    d2 = c;
    d2 += h0 * r2;
    d2 += h1 * r1;
    d2 += h2 * r0;
    d2 += h3 * (5 * r9);
    d2 += h4 * (5 * r8);
    c = d2 >>> 13; d2 &= 0x1fff;
    d2 += h5 * (5 * r7);
    d2 += h6 * (5 * r6);
    d2 += h7 * (5 * r5);
    d2 += h8 * (5 * r4);
    d2 += h9 * (5 * r3);
    c += d2 >>> 13; d2 &= 0x1fff;

    d3 = c;
    d3 += h0 * r3;
    d3 += h1 * r2;
    d3 += h2 * r1;
    d3 += h3 * r0;
    d3 += h4 * (5 * r9);
    c = d3 >>> 13; d3 &= 0x1fff;
    d3 += h5 * (5 * r8);
    d3 += h6 * (5 * r7);
    d3 += h7 * (5 * r6);
    d3 += h8 * (5 * r5);
    d3 += h9 * (5 * r4);
    c += d3 >>> 13; d3 &= 0x1fff;

    d4 = c;
    d4 += h0 * r4;
    d4 += h1 * r3;
    d4 += h2 * r2;
    d4 += h3 * r1;
    d4 += h4 * r0;
    c = d4 >>> 13; d4 &= 0x1fff;
    d4 += h5 * (5 * r9);
    d4 += h6 * (5 * r8);
    d4 += h7 * (5 * r7);
    d4 += h8 * (5 * r6);
    d4 += h9 * (5 * r5);
    c += d4 >>> 13; d4 &= 0x1fff;

    d5 = c;
    d5 += h0 * r5;
    d5 += h1 * r4;
    d5 += h2 * r3;
    d5 += h3 * r2;
    d5 += h4 * r1;
    c = d5 >>> 13; d5 &= 0x1fff;
    d5 += h5 * r0;
    d5 += h6 * (5 * r9);
    d5 += h7 * (5 * r8);
    d5 += h8 * (5 * r7);
    d5 += h9 * (5 * r6);
    c += d5 >>> 13; d5 &= 0x1fff;

    d6 = c;
    d6 += h0 * r6;
    d6 += h1 * r5;
    d6 += h2 * r4;
    d6 += h3 * r3;
    d6 += h4 * r2;
    c = d6 >>> 13; d6 &= 0x1fff;
    d6 += h5 * r1;
    d6 += h6 * r0;
    d6 += h7 * (5 * r9);
    d6 += h8 * (5 * r8);
    d6 += h9 * (5 * r7);
    c += d6 >>> 13; d6 &= 0x1fff;

    d7 = c;
    d7 += h0 * r7;
    d7 += h1 * r6;
    d7 += h2 * r5;
    d7 += h3 * r4;
    d7 += h4 * r3;
    c = d7 >>> 13; d7 &= 0x1fff;
    d7 += h5 * r2;
    d7 += h6 * r1;
    d7 += h7 * r0;
    d7 += h8 * (5 * r9);
    d7 += h9 * (5 * r8);
    c += d7 >>> 13; d7 &= 0x1fff;

    d8 = c;
    d8 += h0 * r8;
    d8 += h1 * r7;
    d8 += h2 * r6;
    d8 += h3 * r5;
    d8 += h4 * r4;
    c = d8 >>> 13; d8 &= 0x1fff;
    d8 += h5 * r3;
    d8 += h6 * r2;
    d8 += h7 * r1;
    d8 += h8 * r0;
    d8 += h9 * (5 * r9);
    c += d8 >>> 13; d8 &= 0x1fff;

    d9 = c;
    d9 += h0 * r9;
    d9 += h1 * r8;
    d9 += h2 * r7;
    d9 += h3 * r6;
    d9 += h4 * r5;
    c = d9 >>> 13; d9 &= 0x1fff;
    d9 += h5 * r4;
    d9 += h6 * r3;
    d9 += h7 * r2;
    d9 += h8 * r1;
    d9 += h9 * r0;
    c += d9 >>> 13; d9 &= 0x1fff;

    d0 = 0x1fff & (c = ((c = ((c << 2) + c) | 0) + d0) | 0);
    d1 += c >>>= 13;

    h0 = d0;
    h1 = d1;
    h2 = d2;
    h3 = d3;
    h4 = d4;
    h5 = d5;
    h6 = d6;
    h7 = d7;
    h8 = d8;
    h9 = d9;

    mpos += 16;
    bytes -= 16;
  }
  this.h[0] = h0;
  this.h[1] = h1;
  this.h[2] = h2;
  this.h[3] = h3;
  this.h[4] = h4;
  this.h[5] = h5;
  this.h[6] = h6;
  this.h[7] = h7;
  this.h[8] = h8;
  this.h[9] = h9;
};

poly1305.prototype.finish = function(mac, macpos) {
  var c, mask, f, i,
    g = new Uint16Array(10);

  if (this.leftover) {
    i = this.leftover;
    this.buffer[i++] = 1;
    for (; i < 16; i++) this.buffer[i] = 0;
    this.fin = 1;
    this.blocks(this.buffer, 0, 16);
  }

  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  for (i = 2; i < 10; i++) {
    this.h[i] += c;
    c = this.h[i] >>> 13;
    this.h[i] &= 0x1fff;
  }
  this.h[0] += c * 5;
  c = this.h[0] >>> 13;
  this.h[0] &= 0x1fff;
  this.h[1] += c;
  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  this.h[2] += c;

  g[0] = this.h[0] + 5;
  c = g[0] >>> 13;
  g[0] &= 0x1fff;
  for (i = 1; i < 10; i++) {
    g[i] = this.h[i] + c;
    c = g[i] >>> 13;
    g[i] &= 0x1fff;
  }
  g[9] -= 1 << 13;

  mask = (c ^ 1) - 1;
  for (i = 0; i < 10; i++) g[i] &= mask;
  mask = ~mask;
  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

  this.h[0] = 0xffff & (this.h[0] | (this.h[1] << 13));
  this.h[1] = 0xffff & ((this.h[1] >>> 3) | (this.h[2] << 10));
  this.h[2] = 0xffff & ((this.h[2] >>> 6) | (this.h[3] << 7));
  this.h[3] = 0xffff & ((this.h[3] >>> 9) | (this.h[4] << 4));
  this.h[4] = 0xffff & ((this.h[4] >>> 12) | (this.h[5] << 1) | (this.h[6] << 14));
  this.h[5] = 0xffff & ((this.h[6] >>> 2) | (this.h[7] << 11));
  this.h[6] = 0xffff & ((this.h[7] >>> 5) | (this.h[8] << 8));
  this.h[7] = 0xffff & ((this.h[8] >>> 8) | (this.h[9] << 5));

  f = this.h[0] + this.pad[0];
  this.h[0] = f & 0xffff;
  for (i = 1; i < 8; i++) {
    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
    this.h[i] = f & 0xffff;
  }

  mac[macpos + 0] = (this.h[0] >>> 0) & 0xff;
  mac[macpos + 1] = (this.h[0] >>> 8) & 0xff;
  mac[macpos + 2] = (this.h[1] >>> 0) & 0xff;
  mac[macpos + 3] = (this.h[1] >>> 8) & 0xff;
  mac[macpos + 4] = (this.h[2] >>> 0) & 0xff;
  mac[macpos + 5] = (this.h[2] >>> 8) & 0xff;
  mac[macpos + 6] = (this.h[3] >>> 0) & 0xff;
  mac[macpos + 7] = (this.h[3] >>> 8) & 0xff;
  mac[macpos + 8] = (this.h[4] >>> 0) & 0xff;
  mac[macpos + 9] = (this.h[4] >>> 8) & 0xff;
  mac[macpos + 10] = (this.h[5] >>> 0) & 0xff;
  mac[macpos + 11] = (this.h[5] >>> 8) & 0xff;
  mac[macpos + 12] = (this.h[6] >>> 0) & 0xff;
  mac[macpos + 13] = (this.h[6] >>> 8) & 0xff;
  mac[macpos + 14] = (this.h[7] >>> 0) & 0xff;
  mac[macpos + 15] = (this.h[7] >>> 8) & 0xff;
};

poly1305.prototype.update = function(m, mpos, bytes) {
  var i, want;

  if (this.leftover) {
    if ((want = 16 - this.leftover) > bytes) want = bytes;
    for (i = 0; i < want; i++) this.buffer[this.leftover + i] = m[mpos + i];
    bytes -= want;
    mpos += want;
    this.leftover += want;
    if (this.leftover < 16) return;
    this.blocks(this.buffer, 0, 16);
    this.leftover = 0;
  }

  if (bytes >= 16) {
    want = bytes - (bytes % 16);
    this.blocks(m, mpos, want);
    mpos += want;
    bytes -= want;
  }

  if (bytes) {
    for (i = 0; i < bytes; i++) this.buffer[this.leftover + i] = m[mpos + i];
    this.leftover += bytes;
  }
};

function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
  var s = new poly1305(k);
  s.update(m, mpos, n);
  s.finish(out, outpos);
  return 0;
}

function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
  var y = new Uint8Array(16);
  crypto_onetimeauth(y, 0, m, mpos, n, k);
  return crypto_verify_16(h, hpos, y, 0);
}

function crypto_secretbox(c, m, d, n, k) {
  if (d < 32) return -1;
  crypto_stream_xor(c, 0, m, 0, d, n, k);
  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
  for (var i = 0; i < 16; i++) c[i] = 0;
  return 0;
}

function crypto_secretbox_open(m, c, d, n, k) {
  var x = new Uint8Array(32);
  if (d < 32) return -1;
  crypto_stream(x, 0, 32, n, k);
  if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;
  crypto_stream_xor(m, 0, c, 0, d, n, k);
  for (var i = 0; i < 32; i++) m[i] = 0;
  return 0;
}

function set25519(r, a) {
  for (var i = 0; i < 16; i++) r[i] = a[i] | 0;
}

function car25519(o) {
  var i, v, c = 1;
  for (i = 0; i < 16; i++) {
    v = o[i] + c + 65535;
    c = Math.floor(v / 65536);
    o[i] = v - c * 65536;
  }
  o[0] += c - 1 + 37 * (c - 1);
}

function sel25519(p, q, b) {
  for (var t, c = ~(b - 1), i = 0; i < 16; i++) {
    t = c & (p[i] ^ q[i]);
    p[i] ^= t;
    q[i] ^= t;
  }
}

function pack25519(o, n) {
  var i, j, b,
    m = gf(), t = gf();
  for (i = 0; i < 16; i++) t[i] = n[i];
  car25519(t);
  car25519(t);
  car25519(t);
  for (j = 0; j < 2; j++) {
    m[0] = t[0] - 0xffed;
    for (i = 1; i < 15; i++) {
      m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);
      m[i - 1] &= 0xffff;
    }
    m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);
    b = (m[15] >> 16) & 1;
    m[14] &= 0xffff;
    sel25519(t, m, 1 - b);
  }
  for (i = 0; i < 16; i++) {
    o[2 * i] = t[i] & 0xff;
    o[2 * i + 1] = t[i] >> 8;
  }
}

function neq25519(a, b) {
  var c = new Uint8Array(32), d = new Uint8Array(32);
  pack25519(c, a);
  pack25519(d, b);
  return crypto_verify_32(c, 0, d, 0);
}

function par25519(a) {
  var d = new Uint8Array(32);
  pack25519(d, a);
  return d[0] & 1;
}

function unpack25519(o, n) {
  for (var i = 0; i < 16; i++) o[i] = n[2 * i] + (n[2 * i + 1] << 8);
  o[15] &= 0x7fff;
}

function A(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
}

function Z(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
}

function M(o, a, b) {
  var v, c,
    t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0,
    t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
    b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7],
    b8 = b[8],
    b9 = b[9],
    b10 = b[10],
    b11 = b[11],
    b12 = b[12],
    b13 = b[13],
    b14 = b[14],
    b15 = b[15];

  t0 += (v = a[0]) * b0;
  t1 += v * b1;
  t2 += v * b2;
  t3 += v * b3;
  t4 += v * b4;
  t5 += v * b5;
  t6 += v * b6;
  t7 += v * b7;
  t8 += v * b8;
  t9 += v * b9;
  t10 += v * b10;
  t11 += v * b11;
  t12 += v * b12;
  t13 += v * b13;
  t14 += v * b14;
  t15 += v * b15;
  t1 += (v = a[1]) * b0;
  t2 += v * b1;
  t3 += v * b2;
  t4 += v * b3;
  t5 += v * b4;
  t6 += v * b5;
  t7 += v * b6;
  t8 += v * b7;
  t9 += v * b8;
  t10 += v * b9;
  t11 += v * b10;
  t12 += v * b11;
  t13 += v * b12;
  t14 += v * b13;
  t15 += v * b14;
  t16 += v * b15;
  t2 += (v = a[2]) * b0;
  t3 += v * b1;
  t4 += v * b2;
  t5 += v * b3;
  t6 += v * b4;
  t7 += v * b5;
  t8 += v * b6;
  t9 += v * b7;
  t10 += v * b8;
  t11 += v * b9;
  t12 += v * b10;
  t13 += v * b11;
  t14 += v * b12;
  t15 += v * b13;
  t16 += v * b14;
  t17 += v * b15;
  t3 += (v = a[3]) * b0;
  t4 += v * b1;
  t5 += v * b2;
  t6 += v * b3;
  t7 += v * b4;
  t8 += v * b5;
  t9 += v * b6;
  t10 += v * b7;
  t11 += v * b8;
  t12 += v * b9;
  t13 += v * b10;
  t14 += v * b11;
  t15 += v * b12;
  t16 += v * b13;
  t17 += v * b14;
  t18 += v * b15;
  t4 += (v = a[4]) * b0;
  t5 += v * b1;
  t6 += v * b2;
  t7 += v * b3;
  t8 += v * b4;
  t9 += v * b5;
  t10 += v * b6;
  t11 += v * b7;
  t12 += v * b8;
  t13 += v * b9;
  t14 += v * b10;
  t15 += v * b11;
  t16 += v * b12;
  t17 += v * b13;
  t18 += v * b14;
  t19 += v * b15;
  t5 += (v = a[5]) * b0;
  t6 += v * b1;
  t7 += v * b2;
  t8 += v * b3;
  t9 += v * b4;
  t10 += v * b5;
  t11 += v * b6;
  t12 += v * b7;
  t13 += v * b8;
  t14 += v * b9;
  t15 += v * b10;
  t16 += v * b11;
  t17 += v * b12;
  t18 += v * b13;
  t19 += v * b14;
  t20 += v * b15;
  t6 += (v = a[6]) * b0;
  t7 += v * b1;
  t8 += v * b2;
  t9 += v * b3;
  t10 += v * b4;
  t11 += v * b5;
  t12 += v * b6;
  t13 += v * b7;
  t14 += v * b8;
  t15 += v * b9;
  t16 += v * b10;
  t17 += v * b11;
  t18 += v * b12;
  t19 += v * b13;
  t20 += v * b14;
  t21 += v * b15;
  t7 += (v = a[7]) * b0;
  t8 += v * b1;
  t9 += v * b2;
  t10 += v * b3;
  t11 += v * b4;
  t12 += v * b5;
  t13 += v * b6;
  t14 += v * b7;
  t15 += v * b8;
  t16 += v * b9;
  t17 += v * b10;
  t18 += v * b11;
  t19 += v * b12;
  t20 += v * b13;
  t21 += v * b14;
  t22 += v * b15;
  t8 += (v = a[8]) * b0;
  t9 += v * b1;
  t10 += v * b2;
  t11 += v * b3;
  t12 += v * b4;
  t13 += v * b5;
  t14 += v * b6;
  t15 += v * b7;
  t16 += v * b8;
  t17 += v * b9;
  t18 += v * b10;
  t19 += v * b11;
  t20 += v * b12;
  t21 += v * b13;
  t22 += v * b14;
  t23 += v * b15;
  t9 += (v = a[9]) * b0;
  t10 += v * b1;
  t11 += v * b2;
  t12 += v * b3;
  t13 += v * b4;
  t14 += v * b5;
  t15 += v * b6;
  t16 += v * b7;
  t17 += v * b8;
  t18 += v * b9;
  t19 += v * b10;
  t20 += v * b11;
  t21 += v * b12;
  t22 += v * b13;
  t23 += v * b14;
  t24 += v * b15;
  t10 += (v = a[10]) * b0;
  t11 += v * b1;
  t12 += v * b2;
  t13 += v * b3;
  t14 += v * b4;
  t15 += v * b5;
  t16 += v * b6;
  t17 += v * b7;
  t18 += v * b8;
  t19 += v * b9;
  t20 += v * b10;
  t21 += v * b11;
  t22 += v * b12;
  t23 += v * b13;
  t24 += v * b14;
  t25 += v * b15;
  t11 += (v = a[11]) * b0;
  t12 += v * b1;
  t13 += v * b2;
  t14 += v * b3;
  t15 += v * b4;
  t16 += v * b5;
  t17 += v * b6;
  t18 += v * b7;
  t19 += v * b8;
  t20 += v * b9;
  t21 += v * b10;
  t22 += v * b11;
  t23 += v * b12;
  t24 += v * b13;
  t25 += v * b14;
  t26 += v * b15;
  t12 += (v = a[12]) * b0;
  t13 += v * b1;
  t14 += v * b2;
  t15 += v * b3;
  t16 += v * b4;
  t17 += v * b5;
  t18 += v * b6;
  t19 += v * b7;
  t20 += v * b8;
  t21 += v * b9;
  t22 += v * b10;
  t23 += v * b11;
  t24 += v * b12;
  t25 += v * b13;
  t26 += v * b14;
  t27 += v * b15;
  t13 += (v = a[13]) * b0;
  t14 += v * b1;
  t15 += v * b2;
  t16 += v * b3;
  t17 += v * b4;
  t18 += v * b5;
  t19 += v * b6;
  t20 += v * b7;
  t21 += v * b8;
  t22 += v * b9;
  t23 += v * b10;
  t24 += v * b11;
  t25 += v * b12;
  t26 += v * b13;
  t27 += v * b14;
  t28 += v * b15;
  t14 += (v = a[14]) * b0;
  t15 += v * b1;
  t16 += v * b2;
  t17 += v * b3;
  t18 += v * b4;
  t19 += v * b5;
  t20 += v * b6;
  t21 += v * b7;
  t22 += v * b8;
  t23 += v * b9;
  t24 += v * b10;
  t25 += v * b11;
  t26 += v * b12;
  t27 += v * b13;
  t28 += v * b14;
  t29 += v * b15;
  t15 += (v = a[15]) * b0;

  t0 += 38 * (t16 += v * b1);
  t1 += 38 * (t17 += v * b2);
  t2 += 38 * (t18 += v * b3);
  t3 += 38 * (t19 += v * b4);
  t4 += 38 * (t20 += v * b5);
  t5 += 38 * (t21 += v * b6);
  t6 += 38 * (t22 += v * b7);
  t7 += 38 * (t23 += v * b8);
  t8 += 38 * (t24 += v * b9);
  t9 += 38 * (t25 += v * b10);
  t10 += 38 * (t26 += v * b11);
  t11 += 38 * (t27 += v * b12);
  t12 += 38 * (t28 += v * b13);
  t13 += 38 * (t29 += v * b14);
  t14 += 38 * (t30 += v * b15);

  t0 = (v = t0 + (c = 1) + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t1 = (v = t1 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t2 = (v = t2 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t3 = (v = t3 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t4 = (v = t4 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t5 = (v = t5 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t6 = (v = t6 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t7 = (v = t7 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t8 = (v = t8 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t9 = (v = t9 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t10 = (v = t10 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t11 = (v = t11 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t12 = (v = t12 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t13 = (v = t13 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t14 = (v = t14 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t15 = (v = t15 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t0 += c - 1 + 37 * (c - 1);

  t0 = (v = t0 + (c = 1) + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t1 = (v = t1 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t2 = (v = t2 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t3 = (v = t3 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t4 = (v = t4 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t5 = (v = t5 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t6 = (v = t6 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t7 = (v = t7 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t8 = (v = t8 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t9 = (v = t9 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t10 = (v = t10 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t11 = (v = t11 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t12 = (v = t12 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t13 = (v = t13 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t14 = (v = t14 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t15 = (v = t15 + c + 65535) - (c = Math.floor(v / 65536)) * 65536;
  t0 += c - 1 + 37 * (c - 1);

  o[0] = t0;
  o[1] = t1;
  o[2] = t2;
  o[3] = t3;
  o[4] = t4;
  o[5] = t5;
  o[6] = t6;
  o[7] = t7;
  o[8] = t8;
  o[9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}

function S(o, a) {
  M(o, a, a);
}

function inv25519(o, i) {
  var a,
    c = gf();
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 253; a >= 0; a--) {
    S(c, c);
    a === 2 || a === 4 || M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function pow2523(o, i) {
  var a,
    c = gf();
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 250; a >= 0; a--) {
    S(c, c);
    a === 1 || M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function crypto_scalarmult(q, n, p) {
  var r, i, z = new Uint8Array(32),
    x = new Float64Array(80),
    a = gf(), b = gf(), c = gf(),
    d = gf(), e = gf(), f = gf();
  for (i = 0; i < 31; i++) z[i] = n[i];
  z[31] = (n[31] & 127) | 64;
  z[0] &= 248;
  unpack25519(x, p);
  for (i = 0; i < 16; i++) {
    b[i] = x[i];
    d[i] = a[i] = c[i] = 0;
  }
  a[0] = d[0] = 1;
  for (i = 254; i >= 0; --i) {
    sel25519(a, b, (r = (z[i >>> 3] >>> (i & 7)) & 1));
    sel25519(c, d, r);
    A(e, a, c);
    Z(a, a, c);
    A(c, b, d);
    Z(b, b, d);
    S(d, e);
    S(f, a);
    M(a, c, a);
    M(c, b, e);
    A(e, a, c);
    Z(a, a, c);
    S(b, a);
    Z(c, d, f);
    M(a, c, _121665);
    A(a, a, d);
    M(c, c, a);
    M(a, d, f);
    M(d, b, x);
    S(b, e);
    sel25519(a, b, r);
    sel25519(c, d, r);
  }
  for (i = 0; i < 16; i++) {
    x[i + 16] = a[i];
    x[i + 32] = c[i];
    x[i + 48] = b[i];
    x[i + 64] = d[i];
  }
  var x32 = x.subarray(32),
    x16 = x.subarray(16);
  inv25519(x32, x32);
  M(x16, x16, x32);
  pack25519(q, x16);
  return 0;
}

function crypto_scalarmult_base(q, n) {
  return crypto_scalarmult(q, n, _9);
}

function crypto_box_keypair(y, x) {
  randombytes(x, 32);
  return crypto_scalarmult_base(y, x);
}

function crypto_box_beforenm(k, y, x) {
  var s = new Uint8Array(32);
  crypto_scalarmult(s, x, y);
  return crypto_core_hsalsa20(k, _0, s, sigma);
}

var crypto_box_afternm = crypto_secretbox,
  crypto_box_open_afternm = crypto_secretbox_open;

function crypto_box(c, m, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_afternm(c, m, d, n, k);
}

function crypto_box_open(m, c, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_open_afternm(m, c, d, n, k);
}

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538,
  0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235,
  0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab,
  0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed,
  0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218,
  0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373,
  0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c,
  0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc,
  0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function crypto_hashblocks_hl(hh, hl, m, n) {
  var wh = new Int32Array(16), wl = new Int32Array(16),
    bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
    bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
    th, tl, i, j, h, l, a, b, c, d;

  var ah0 = hh[0],
    ah1 = hh[1],
    ah2 = hh[2],
    ah3 = hh[3],
    ah4 = hh[4],
    ah5 = hh[5],
    ah6 = hh[6],
    ah7 = hh[7],

    al0 = hl[0],
    al1 = hl[1],
    al2 = hl[2],
    al3 = hl[3],
    al4 = hl[4],
    al5 = hl[5],
    al6 = hl[6],
    al7 = hl[7];

  for (var pos = 0; n >= 128; ) {
    for (i = 0; i < 16; i++) {
      j = 8 * i + pos;
      // noinspection PointlessArithmeticExpressionJS
      wh[i] = (m[j + 0] << 24) | (m[j + 1] << 16) | (m[j + 2] << 8) | m[j + 3];
      wl[i] = (m[j + 4] << 24) | (m[j + 5] << 16) | (m[j + 6] << 8) | m[j + 7];
    }
    for (i = 0; i < 80; i++) {
      bh0 = ah0;
      bh1 = ah1;
      bh2 = ah2;
      bh3 = ah3;
      bh4 = ah4;
      bh5 = ah5;
      bh6 = ah6;
      bh7 = ah7;

      bl0 = al0;
      bl1 = al1;
      bl2 = al2;
      bl3 = al3;
      bl4 = al4;
      bl5 = al5;
      bl6 = al6;
      bl7 = al7;

      a = (l = al7) & 0xffff; b = l >>> 16;
      c = (h = ah7) & 0xffff; d = h >>> 16;

      h = ((ah4 >>> 14) | (al4 << 18)) ^ ((ah4 >>> 18) | (al4 << 14)) ^ ((al4 >>> 9) | (ah4 << 23));
      l = ((al4 >>> 14) | (ah4 << 18)) ^ ((al4 >>> 18) | (ah4 << 14)) ^ ((ah4 >>> 9) | (al4 << 23));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      a += 0xffff & (l = (al4 & al5) ^ (~al4 & al6)); b += l >>> 16;
      c += 0xffff & (h = (ah4 & ah5) ^ (~ah4 & ah6)); d += h >>> 16;

      h = K[i * 2];
      l = K[i * 2 + 1];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      h = wh[i % 16];
      l = wl[i % 16];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      d += (c += (b += a >>> 16) >>> 16) >>> 16;

      a = 0xffff & (l = tl = (a & 0xffff) | (b << 16)); b = l >>> 16;
      c = 0xffff & (h = th = (c & 0xffff) | (d << 16)); d = h >>> 16;

      h = ((ah0 >>> 28) | (al0 << 4)) ^ ((al0 >>> 2) | (ah0 << 30)) ^ ((al0 >>> 7) | (ah0 << 25));
      l = ((al0 >>> 28) | (ah0 << 4)) ^ ((ah0 >>> 2) | (al0 << 30)) ^ ((ah0 >>> 7) | (al0 << 25));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      d += (c += (b += a >>> 16) >>> 16) >>> 16;

      bh7 = (c & 0xffff) | (d << 16);
      bl7 = (a & 0xffff) | (b << 16);

      a = (l = bl3) & 0xffff; b = l >>> 16;
      c = (h = bh3) & 0xffff; d = h >>> 16;

      a += (l = tl) & 0xffff; b += l >>> 16;
      c += (h = th) & 0xffff; d += h >>> 16;

      d += (c += (b += a >>> 16) >>> 16) >>> 16;

      bh3 = (c & 0xffff) | (d << 16);
      bl3 = (a & 0xffff) | (b << 16);

      ah1 = bh0;
      ah2 = bh1;
      ah3 = bh2;
      ah4 = bh3;
      ah5 = bh4;
      ah6 = bh5;
      ah7 = bh6;
      ah0 = bh7;

      al1 = bl0;
      al2 = bl1;
      al3 = bl2;
      al4 = bl3;
      al5 = bl4;
      al6 = bl5;
      al7 = bl6;
      al0 = bl7;

      if (i % 16 == 15)
        for (j = 0; j < 16; j++) {
          h = wh[j];
          l = wl[j];

          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;

          h = wh[(j + 9) % 16];
          l = wl[(j + 9) % 16];

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          th = wh[(j + 1) % 16];
          tl = wl[(j + 1) % 16];
          h = ((th >>> 1) | (tl << 31)) ^ ((th >>> 8) | (tl << 24)) ^ (th >>> 7);
          l = ((tl >>> 1) | (th << 31)) ^ ((tl >>> 8) | (th << 24)) ^ ((tl >>> 7) | (th << 25));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          th = wh[(j + 14) % 16];
          tl = wl[(j + 14) % 16];
          h = ((th >>> 19) | (tl << 13)) ^ ((tl >>> 29) | (th << 3)) ^ (th >>> 6);
          l = ((tl >>> 19) | (th << 13)) ^ ((th >>> 29) | (tl << 3)) ^ ((tl >>> 6) | (th << 26));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          d += (c += (b += a >>> 16) >>> 16) >>> 16;

          wh[j] = (c & 0xffff) | (d << 16);
          wl[j] = (a & 0xffff) | (b << 16);
        }
    }

    a = (l = al0) & 0xffff; b = l >>> 16;
    c = (h = ah0) & 0xffff; d = h >>> 16;

    h = hh[0];
    l = hl[0];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    d += (c += (b += a >>> 16) >>> 16) >>> 16;

    hh[0] = ah0 = (c & 0xffff) | (d << 16);
    hl[0] = al0 = (a & 0xffff) | (b << 16);

    a = (l = al1) & 0xffff; b = l >>> 16;
    c = (h = ah1) & 0xffff; d = h >>> 16;

    h = hh[1];
    l = hl[1];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    d += (c += (b += a >>> 16) >>> 16) >>> 16;

    hh[1] = ah1 = (c & 0xffff) | (d << 16);
    hl[1] = al1 = (a & 0xffff) | (b << 16);

    a = (l = al2) & 0xffff; b = l >>> 16;
    c = (h = ah2) & 0xffff; d = h >>> 16;

    h = hh[2];
    l = hl[2];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    d += (c += (b += a >>> 16) >>> 16) >>> 16;

    hh[2] = ah2 = (c & 0xffff) | (d << 16);
    hl[2] = al2 = (a & 0xffff) | (b << 16);

    a = (l = al3) & 0xffff; b = l >>> 16;
    c = (h = ah3) & 0xffff; d = h >>> 16;

    h = hh[3];
    l = hl[3];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    d += (c += (b += a >>> 16) >>> 16) >>> 16;

    hh[3] = ah3 = (c & 0xffff) | (d << 16);
    hl[3] = al3 = (a & 0xffff) | (b << 16);

    a = (l = al4) & 0xffff; b = l >>> 16;
    c = (h = ah4) & 0xffff; d = h >>> 16;

    h = hh[4];
    l = hl[4];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    d += (c += (b += a >>> 16) >>> 16) >>> 16;

    hh[4] = ah4 = (c & 0xffff) | (d << 16);
    hl[4] = al4 = (a & 0xffff) | (b << 16);

    a = (l = al5) & 0xffff; b = l >>> 16;
    c = (h = ah5) & 0xffff; d = h >>> 16;

    h = hh[5];
    l = hl[5];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    d += (c += (b += a >>> 16) >>> 16) >>> 16;

    hh[5] = ah5 = (c & 0xffff) | (d << 16);
    hl[5] = al5 = (a & 0xffff) | (b << 16);

    a = (l = al6) & 0xffff; b = l >>> 16;
    c = (h = ah6) & 0xffff; d = h >>> 16;

    h = hh[6];
    l = hl[6];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    d += (c += (b += a >>> 16) >>> 16) >>> 16;

    hh[6] = ah6 = (c & 0xffff) | (d << 16);
    hl[6] = al6 = (a & 0xffff) | (b << 16);

    a = (l = al7) & 0xffff; b = l >>> 16;
    c = (h = ah7) & 0xffff; d = h >>> 16;

    h = hh[7];
    l = hl[7];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    d += (c += (b += a >>> 16) >>> 16) >>> 16;

    hh[7] = ah7 = (c & 0xffff) | (d << 16);
    hl[7] = al7 = (a & 0xffff) | (b << 16);

    pos += 128;
    n -= 128;
  }

  return n;
}

function crypto_hash(out, m, n) {
  var i,
    hh = new Int32Array(8),
    hl = new Int32Array(8),
    x = new Uint8Array(256),
    b = n;

  hh[0] = 0x6a09e667;
  hh[1] = 0xbb67ae85;
  hh[2] = 0x3c6ef372;
  hh[3] = 0xa54ff53a;
  hh[4] = 0x510e527f;
  hh[5] = 0x9b05688c;
  hh[6] = 0x1f83d9ab;
  hh[7] = 0x5be0cd19;

  hl[0] = 0xf3bcc908;
  hl[1] = 0x84caa73b;
  hl[2] = 0xfe94f82b;
  hl[3] = 0x5f1d36f1;
  hl[4] = 0xade682d1;
  hl[5] = 0x2b3e6c1f;
  hl[6] = 0xfb41bd6b;
  hl[7] = 0x137e2179;

  crypto_hashblocks_hl(hh, hl, m, n);
  n %= 128;

  for (i = 0; i < n; i++) x[i] = m[b - n + i];
  x[n] = 128;

  x[(n = 256 - 128 * (n < 112 ? 1 : 0)) - 9] = 0;
  ts64(x, n - 8, (b / 0x20000000) | 0, b << 3);
  crypto_hashblocks_hl(hh, hl, x, n);

  for (i = 0; i < 8; i++) ts64(out, 8 * i, hh[i], hl[i]);

  return 0;
}

function add(p, q) {
  var a = gf(), b = gf(), c = gf(),
    d = gf(), e = gf(), f = gf(),
    g = gf(), h = gf(), t = gf();

  Z(a, p[1], p[0]);
  Z(t, q[1], q[0]);
  M(a, a, t);
  A(b, p[0], p[1]);
  A(t, q[0], q[1]);
  M(b, b, t);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d, p[2], q[2]);
  A(d, d, d);
  Z(e, b, a);
  Z(f, d, c);
  A(g, d, c);
  A(h, b, a);

  M(p[0], e, f);
  M(p[1], h, g);
  M(p[2], g, f);
  M(p[3], e, h);
}

function cswap(p, q, b) {
  for (var i = 0; i < 4; i++) sel25519(p[i], q[i], b);
}

function pack(r, p) {
  var tx = gf(), ty = gf(), zi = gf();
  inv25519(zi, p[2]);
  M(tx, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r, ty);
  r[31] ^= par25519(tx) << 7;
}

function scalarmult(p, q, s) {
  var b, i;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);
  for (i = 255; i >= 0; --i) {
    cswap(p, q, (b = (s[(i / 8) | 0] >> (i & 7)) & 1));
    add(q, p);
    add(p, p);
    cswap(p, q, b);
  }
}

function scalarbase(p, s) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s);
}

function crypto_sign_keypair(pk, sk, seeded) {
  var i,
    d = new Uint8Array(64),
    p = [gf(), gf(), gf(), gf()];

  seeded || randombytes(sk, 32);
  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  scalarbase(p, d);
  pack(pk, p);

  for (i = 0; i < 32; i++) sk[i + 32] = pk[i];
  return 0;
}

var L = new Float64Array([
  0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0x10
]);

function modL(r, x) {
  var carry, i, j, k;
  for (i = 63; i >= 32; --i) {
    carry = 0;
    for (j = i - 32, k = i - 12; j < k; ++j) {
      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
      carry = (x[j] + 128) >> 8;
      x[j] -= carry * 256;
    }
    x[j] += carry;
    x[i] = 0;
  }
  carry = 0;
  for (j = 0; j < 32; j++) {
    x[j] += carry - (x[31] >> 4) * L[j];
    carry = x[j] >> 8;
    x[j] &= 255;
  }
  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
  for (i = 0; i < 32; i++) {
    x[i + 1] += x[i] >> 8;
    r[i] = x[i] & 255;
  }
}

function reduce(r) {
  var i, x = new Float64Array(64);
  for (i = 0; i < 64; i++) x[i] = r[i];
  for (i = 0; i < 64; i++) r[i] = 0;
  modL(r, x);
}

function crypto_sign(sm, m, n, sk) {
  var i, j,
    d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64),
    x = new Float64Array(64),
    p = [gf(), gf(), gf(), gf()];

  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  var smlen = n + 64;
  for (i = 0; i < n; i++) sm[64 + i] = m[i];
  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

  crypto_hash(r, sm.subarray(32), n + 32);
  reduce(r);
  scalarbase(p, r);
  pack(sm, p);

  for (i = 32; i < 64; i++) sm[i] = sk[i];
  crypto_hash(h, sm, n + 64);
  reduce(h);

  for (i = 0; i < 64; i++) x[i] = 0;
  for (i = 0; i < 32; i++) x[i] = r[i];
  for (i = 0; i < 32; i++) for (j = 0; j < 32; j++) x[i + j] += h[i] * d[j];

  modL(sm.subarray(32), x);
  return smlen;
}

function unpackneg(r, p) {
  var t = gf(), chk = gf(), num = gf(),
    den = gf(), den2 = gf(), den4 = gf(),
    den6 = gf();

  set25519(r[2], gf1);
  unpack25519(r[1], p);
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);

  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t, den6, num);
  M(t, t, den);

  pow2523(t, t);
  M(t, t, num);
  M(t, t, den);
  M(t, t, den);
  M(r[0], t, den);

  S(chk, r[0]);
  M(chk, chk, den);
  neq25519(chk, num) && M(r[0], r[0], I);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) return -1;

  par25519(r[0]) !== p[31] >> 7 || Z(r[0], gf0, r[0]);

  M(r[3], r[0], r[1]);
  return 0;
}

function crypto_sign_open(m, sm, n, pk) {
  var i,
    t = new Uint8Array(32), h = new Uint8Array(64),
    p = [gf(), gf(), gf(), gf()],
    q = [gf(), gf(), gf(), gf()];

  if (n < 64) return -1;

  if (unpackneg(q, pk)) return -1;

  for (i = 0; i < n; i++) m[i] = sm[i];
  for (i = 0; i < 32; i++) m[i + 32] = pk[i];
  crypto_hash(h, m, n);
  reduce(h);
  scalarmult(p, q, h);

  scalarbase(q, sm.subarray(32));
  add(p, q);
  pack(t, p);

  n -= 64;
  if (crypto_verify_32(sm, 0, t, 0)) {
    for (i = 0; i < n; i++) m[i] = 0;
    return -1;
  }

  for (i = 0; i < n; i++) m[i] = sm[i + 64];
  return n;
}

// noinspection UnnecessaryLocalVariableJS
var crypto_secretbox_KEYBYTES = 32,
  crypto_secretbox_NONCEBYTES = 24,
  crypto_secretbox_ZEROBYTES = 32,
  crypto_secretbox_BOXZEROBYTES = 16,
  crypto_scalarmult_BYTES = 32,
  crypto_scalarmult_SCALARBYTES = 32,
  crypto_box_PUBLICKEYBYTES = 32,
  crypto_box_SECRETKEYBYTES = 32,
  crypto_box_BEFORENMBYTES = 32,
  crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
  crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
  crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
  crypto_sign_BYTES = 64,
  crypto_sign_PUBLICKEYBYTES = 32,
  crypto_sign_SECRETKEYBYTES = 64,
  crypto_sign_SEEDBYTES = 32,
  crypto_hash_BYTES = 64;

nacl.lowlevel = {
  crypto_core_hsalsa20: crypto_core_hsalsa20,
  crypto_stream_xor: crypto_stream_xor,
  crypto_stream: crypto_stream,
  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
  crypto_stream_salsa20: crypto_stream_salsa20,
  crypto_onetimeauth: crypto_onetimeauth,
  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
  crypto_verify_16: crypto_verify_16,
  crypto_verify_32: crypto_verify_32,
  crypto_secretbox: crypto_secretbox,
  crypto_secretbox_open: crypto_secretbox_open,
  crypto_scalarmult: crypto_scalarmult,
  crypto_scalarmult_base: crypto_scalarmult_base,
  crypto_box_beforenm: crypto_box_beforenm,
  crypto_box_afternm: crypto_box_afternm,
  crypto_box: crypto_box,
  crypto_box_open: crypto_box_open,
  crypto_box_keypair: crypto_box_keypair,
  crypto_hash: crypto_hash,
  crypto_sign: crypto_sign,
  crypto_sign_keypair: crypto_sign_keypair,
  crypto_sign_open: crypto_sign_open,

  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
  crypto_sign_BYTES: crypto_sign_BYTES,
  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
  crypto_hash_BYTES: crypto_hash_BYTES
};

function checkLengths(k, n) {
  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
}

function checkBoxLengths(pk, sk) {
  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
}

function checkArrayTypes() {
  for (var t, i = 0; i < arguments.length; i++)
    if ((t = Object.prototype.toString.call(arguments[i])) !== '[object Uint8Array]')
      throw new TypeError('unexpected type ' + t + ', use Uint8Array');
}

function cleanup(arr) {
  for (var i = 0; i < arr.length; i++) arr[i] = 0;
}

if (!nacl.util) {
  nacl.util = {};
  nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function() {
    throw new Error('nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js');
  };
}

nacl.randomBytes = function(n) {
  var b = new Uint8Array(n);
  randombytes(b, n);
  return b;
};

nacl.secretbox = function(msg, nonce, key) {
  checkArrayTypes(msg, nonce, key);
  checkLengths(key, nonce);
  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length),
    c = new Uint8Array(m.length);
  for (var i = 0; i < msg.length; i++) m[i + crypto_secretbox_ZEROBYTES] = msg[i];
  crypto_secretbox(c, m, m.length, nonce, key);
  return c.subarray(crypto_secretbox_BOXZEROBYTES);
};

nacl.secretbox.open = function(box, nonce, key) {
  checkArrayTypes(box, nonce, key);
  checkLengths(key, nonce);
  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length),
    m = new Uint8Array(c.length);
  for (var i = 0; i < box.length; i++) c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
  return (
    c.length >= 32 && crypto_secretbox_open(m, c, c.length, nonce, key) === 0 && m.subarray(crypto_secretbox_ZEROBYTES)
  );
};

nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

nacl.scalarMult = function(n, p) {
  checkArrayTypes(n, p);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult(q, n, p);
  return q;
};

nacl.scalarMult.base = function(n) {
  checkArrayTypes(n);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult_base(q, n);
  return q;
};

nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

nacl.box = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox(msg, nonce, k);
};

nacl.box.before = function(publicKey, secretKey) {
  checkArrayTypes(publicKey, secretKey);
  checkBoxLengths(publicKey, secretKey);
  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
  crypto_box_beforenm(k, publicKey, secretKey);
  return k;
};

nacl.box.after = nacl.secretbox;

nacl.box.open = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox.open(msg, nonce, k);
};

nacl.box.open.after = nacl.secretbox.open;

nacl.box.keyPair = function() {
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES),
    sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
  crypto_box_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.box.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  crypto_scalarmult_base(pk, secretKey);
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
nacl.box.nonceLength = crypto_box_NONCEBYTES;
nacl.box.overheadLength = nacl.secretbox.overheadLength;

nacl.sign = function(msg, secretKey) {
  checkArrayTypes(msg, secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error('bad secret key size');
  var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
  crypto_sign(signedMsg, msg, msg.length, secretKey);
  return signedMsg;
};

nacl.sign.open = function(signedMsg, publicKey) {
  if (arguments.length !== 2)
    throw new Error('nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?');
  checkArrayTypes(signedMsg, publicKey);
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error('bad public key size');
  var tmp = new Uint8Array(signedMsg.length),
    mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
  if (mlen < 0) return null;
  var m = new Uint8Array(mlen);
  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
  return m;
};

nacl.sign.detached = function(msg, secretKey) {
  var signedMsg = nacl.sign(msg, secretKey),
    sig = new Uint8Array(crypto_sign_BYTES);
  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
  return sig;
};

nacl.sign.detached.verify = function(msg, sig, publicKey) {
  checkArrayTypes(msg, sig, publicKey);
  if (sig.length !== crypto_sign_BYTES) throw new Error('bad signature size');
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error('bad public key size');
  var i,
    sm = new Uint8Array(crypto_sign_BYTES + msg.length),
    m = new Uint8Array(crypto_sign_BYTES + msg.length);
  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
  for (i = 0; i < msg.length; i++) sm[i + crypto_sign_BYTES] = msg[i];
  return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
};

nacl.sign.keyPair = function() {
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES),
    sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  crypto_sign_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32 + i];
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.sign.keyPair.fromSeed = function(seed) {
  checkArrayTypes(seed);
  if (seed.length !== crypto_sign_SEEDBYTES) throw new Error('bad seed size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES),
    sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  for (var i = 0; i < 32; i++) sk[i] = seed[i];
  crypto_sign_keypair(pk, sk, true);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
nacl.sign.seedLength = crypto_sign_SEEDBYTES;
nacl.sign.signatureLength = crypto_sign_BYTES;

nacl.hash = function(msg) {
  checkArrayTypes(msg);
  var h = new Uint8Array(crypto_hash_BYTES);
  crypto_hash(h, msg, msg.length);
  return h;
};

nacl.hash.hashLength = crypto_hash_BYTES;

nacl.verify = function(x, y) {
  checkArrayTypes(x, y);
  return x.length !== 0 && y.length !== 0 && x.length === y.length && vn(x, 0, y, 0, x.length) === 0;
};

nacl.setPRNG = function(fn) {
  randombytes = fn;
};

!(function() {
  var crypto = typeof self != 'undefined' ? self.crypto || self.msCrypto : null;
  if (crypto && crypto.getRandomValues) {
    var QUOTA = 65536;
    nacl.setPRNG(function(x, n) {
      var i, v = new Uint8Array(n);
      for (i = 0; i < n; i += QUOTA) crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));

      for (i = 0; i < n; i++) x[i] = v[i];
      cleanup(v);
    });
  } else
    (crypto = __wpreq__('crypto')) && crypto.randomBytes &&
      nacl.setPRNG(function(x, n) {
        var i, v = crypto.randomBytes(n);
        for (i = 0; i < n; i++) x[i] = v[i];
        cleanup(v);
      });
})();
//
},
'ecc-jsbn/lib/ec':
function(module, exports, __wpreq__) {
//
var BigInteger = __wpreq__('jsbn').BigInteger,
  Barrett = BigInteger.prototype.Barrett

function ECFieldElementFp(q, x) {
  this.x = x;
  this.q = q;
}

function feFpEquals(other) {
  return other == this || (this.q.equals(other.q) && this.x.equals(other.x));
}

function feFpToBigInteger() {
  return this.x;
}

function feFpNegate() {
  return new ECFieldElementFp(this.q, this.x.negate().mod(this.q));
}

function feFpAdd(b) {
  return new ECFieldElementFp(this.q, this.x.add(b.toBigInteger()).mod(this.q));
}

function feFpSubtract(b) {
  return new ECFieldElementFp(this.q, this.x.subtract(b.toBigInteger()).mod(this.q));
}

function feFpMultiply(b) {
  return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger()).mod(this.q));
}

function feFpSquare() {
  return new ECFieldElementFp(this.q, this.x.square().mod(this.q));
}

function feFpDivide(b) {
  return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q));
}

ECFieldElementFp.prototype.equals = feFpEquals;
ECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;
ECFieldElementFp.prototype.negate = feFpNegate;
ECFieldElementFp.prototype.add = feFpAdd;
ECFieldElementFp.prototype.subtract = feFpSubtract;
ECFieldElementFp.prototype.multiply = feFpMultiply;
ECFieldElementFp.prototype.square = feFpSquare;
ECFieldElementFp.prototype.divide = feFpDivide;

function ECPointFp(curve, x, y, z) {
  this.curve = curve;
  this.x = x;
  this.y = y;
  this.z = z == null ? BigInteger.ONE : z;

  this.zinv = null;
}

function pointFpGetX() {
  if (this.zinv == null) this.zinv = this.z.modInverse(this.curve.q);

  var r = this.x.toBigInteger().multiply(this.zinv);
  this.curve.reduce(r);
  return this.curve.fromBigInteger(r);
}

function pointFpGetY() {
  if (this.zinv == null) this.zinv = this.z.modInverse(this.curve.q);

  var r = this.y.toBigInteger().multiply(this.zinv);
  this.curve.reduce(r);
  return this.curve.fromBigInteger(r);
}

function pointFpEquals(other) {
  return other == this ||
    (this.isInfinity() ? other.isInfinity()
      : other.isInfinity() ? this.isInfinity()
      : !!other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q)
          .equals(BigInteger.ZERO) &&
        other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q)
          .equals(BigInteger.ZERO));
}

function pointFpIsInfinity() {
  return (
    (this.x == null && this.y == null) ||
    (this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO))
  );
}

function pointFpNegate() {
  return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);
}

function pointFpAdd(b) {
  if (this.isInfinity()) return b;
  if (b.isInfinity()) return this;

  var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q),
    v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);

  if (BigInteger.ZERO.equals(v)) return BigInteger.ZERO.equals(u) ? this.twice() : this.curve.getInfinity();

  var THREE = new BigInteger("3"),
    x1 = this.x.toBigInteger(),
    y1 = this.y.toBigInteger(),
    //x2 = b.x.toBigInteger(),
    //y2 = b.y.toBigInteger(),

    v2 = v.square(),
    v3 = v2.multiply(v),
    x1v2 = x1.multiply(v2),
    zu2 = u.square().multiply(this.z),

    x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);
  var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u))
    .multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);
  var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.q);

  return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
}

function pointFpTwice() {
  if (this.isInfinity()) return this;
  if (this.y.toBigInteger().signum() == 0) return this.curve.getInfinity();

  var THREE = new BigInteger("3"),
    x1 = this.x.toBigInteger(),
    y1 = this.y.toBigInteger(),

    y1z1 = y1.multiply(this.z),
    y1sqz1 = y1z1.multiply(y1).mod(this.curve.q),
    a = this.curve.a.toBigInteger(),

    w = x1.square().multiply(THREE);
  BigInteger.ZERO.equals(a) || (w = w.add(this.z.square().multiply(a)));

  w = w.mod(this.curve.q);
  var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);
  var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1)
    .subtract(w.square().multiply(w)).mod(this.curve.q);
  var z3 = y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);

  return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
}

function pointFpMultiply(k) {
  if (this.isInfinity()) return this;
  if (k.signum() == 0) return this.curve.getInfinity();

  var e = k,
    h = e.multiply(new BigInteger("3")),

    neg = this.negate(),
    R = this;

  for (var i = h.bitLength() - 2; i > 0; --i) {
    R = R.twice();

    var hBit = h.testBit(i);

    if (hBit != e.testBit(i)) R = R.add(hBit ? this : neg);
  }

  return R;
}

function pointFpMultiplyTwo(j, x, k) {
  var i = j.bitLength() > k.bitLength() ? j.bitLength() - 1 : k.bitLength() - 1;

  var R = this.curve.getInfinity();
  for (var both = this.add(x); i >= 0; ) {
    R = R.twice();
    if (j.testBit(i)) R = k.testBit(i) ? R.add(both) : R.add(this);
    else if (k.testBit(i)) R = R.add(x);

    --i;
  }

  return R;
}

ECPointFp.prototype.getX = pointFpGetX;
ECPointFp.prototype.getY = pointFpGetY;
ECPointFp.prototype.equals = pointFpEquals;
ECPointFp.prototype.isInfinity = pointFpIsInfinity;
ECPointFp.prototype.negate = pointFpNegate;
ECPointFp.prototype.add = pointFpAdd;
ECPointFp.prototype.twice = pointFpTwice;
ECPointFp.prototype.multiply = pointFpMultiply;
ECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;

function ECCurveFp(q, a, b) {
  this.q = q;
  this.a = this.fromBigInteger(a);
  this.b = this.fromBigInteger(b);
  this.infinity = new ECPointFp(this, null, null);
  this.reducer = new Barrett(this.q);
}

function curveFpGetQ() {
  return this.q;
}

function curveFpGetA() {
  return this.a;
}

function curveFpGetB() {
  return this.b;
}

function curveFpEquals(other) {
  return other == this || (this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b));
}

function curveFpGetInfinity() {
  return this.infinity;
}

function curveFpFromBigInteger(x) {
  return new ECFieldElementFp(this.q, x);
}

function curveReduce(x) {
  this.reducer.reduce(x);
}

function curveFpEncodePointHex(p) {
  if (p.isInfinity()) return "00";
  var xHex = p.getX().toBigInteger().toString(16),
    yHex = p.getY().toBigInteger().toString(16),
    oLen = this.getQ().toString(16).length;
  oLen % 2 == 0 || oLen++;
  while (xHex.length < oLen) xHex = "0" + xHex;
  while (yHex.length < oLen) yHex = "0" + yHex;

  return "04" + xHex + yHex;
}

ECCurveFp.prototype.getQ = curveFpGetQ;
ECCurveFp.prototype.getA = curveFpGetA;
ECCurveFp.prototype.getB = curveFpGetB;
ECCurveFp.prototype.equals = curveFpEquals;
ECCurveFp.prototype.getInfinity = curveFpGetInfinity;
ECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;
ECCurveFp.prototype.reduce = curveReduce;
ECCurveFp.prototype.encodePointHex = curveFpEncodePointHex;

ECCurveFp.prototype.decodePointHex = function(s) {
  var yIsEven;
  switch (parseInt(s.substr(0, 2), 16)) {
  case 0:
    return this.infinity;
  case 2:
    yIsEven = false;
  case 3:
    if (yIsEven == null) yIsEven = true;
    var len = s.length - 2,
      xHex = s.substr(2, len),
      x = this.fromBigInteger(new BigInteger(xHex, 16)),
      beta = x.multiply(x.square().add(this.getA())).add(this.getB()).sqrt();

    if (beta == null) throw "Invalid point compression";

    var betaValue = beta.toBigInteger();
    if (betaValue.testBit(0) != yIsEven) beta = this.fromBigInteger(this.getQ().subtract(betaValue));

    return new ECPointFp(this, x, beta);
  case 4:
  case 6:
  case 7:
    len = (s.length - 2) / 2;
    xHex = s.substr(2, len);
    var yHex = s.substr(len + 2, len);

    return new ECPointFp(this,
      this.fromBigInteger(new BigInteger(xHex, 16)),
      this.fromBigInteger(new BigInteger(yHex, 16))
    );

  default:
    return null;
  }
}
ECCurveFp.prototype.encodeCompressedPointHex = function(p) {
  if (p.isInfinity()) return "00";
  var xHex = p.getX().toBigInteger().toString(16),
    oLen = this.getQ().toString(16).length;
  oLen % 2 == 0 || oLen++;
  while (xHex.length < oLen) xHex = "0" + xHex;

  return (p.getY().toBigInteger().isEven() ? "02" : "03") + xHex;
}

ECFieldElementFp.prototype.getR = function() {
  if (this.r != null) return this.r;

  this.r = null;
  var bitLength = this.q.bitLength();
  if (bitLength > 128 && this.q.shiftRight(bitLength - 64).intValue() == -1)
    this.r = BigInteger.ONE.shiftLeft(bitLength).subtract(this.q);

  return this.r;
}
ECFieldElementFp.prototype.modMult = function(x1, x2) {
  return this.modReduce(x1.multiply(x2));
}
ECFieldElementFp.prototype.modReduce = function(x) {
  if (this.getR() != null) {
    for (var qLen = q.bitLength(); x.bitLength() > qLen + 1; ) {
      var u = x.shiftRight(qLen),
        v = x.subtract(u.shiftLeft(qLen));
      this.getR().equals(BigInteger.ONE) || (u = u.multiply(this.getR()));

      x = u.add(v);
    }
    while (x.compareTo(q) >= 0) x = x.subtract(q);
  } else x = x.mod(q);

  return x;
}
ECFieldElementFp.prototype.sqrt = function() {
  if (!this.q.testBit(0)) throw "unsupported";

  if (this.q.testBit(1)) {
    var z = new ECFieldElementFp(this.q, this.x.modPow(this.q.shiftRight(2).add(BigInteger.ONE), this.q));
    return z.square().equals(this) ? z : null;
  }

  var qMinusOne = this.q.subtract(BigInteger.ONE),

    legendreExponent = qMinusOne.shiftRight(1);
  if (!this.x.modPow(legendreExponent, this.q).equals(BigInteger.ONE)) return null;

  var U, V,
    k = qMinusOne.shiftRight(2).shiftLeft(1).add(BigInteger.ONE),

    Q = this.x,
    fourQ = modDouble(modDouble(Q));

  do {
    var P;
    do {
      P = new BigInteger(this.q.bitLength(), new SecureRandom());
    } while (
      P.compareTo(this.q) >= 0 ||
      !P.multiply(P).subtract(fourQ).modPow(legendreExponent, this.q).equals(qMinusOne)
    );

    var result = this.lucasSequence(P, Q, k);
    U = result[0];
    V = result[1];

    if (this.modMult(V, V).equals(fourQ)) {
      if (V.testBit(0)) V = V.add(q);

      V = V.shiftRight(1);

      return new ECFieldElementFp(q, V);
    }
  } while (U.equals(BigInteger.ONE) || U.equals(qMinusOne));

  return null;
}
ECFieldElementFp.prototype.lucasSequence = function(P, Q, k) {
  var n = k.bitLength(),
    s = k.getLowestSetBit(),

    Uh = BigInteger.ONE,
    Vl = BigInteger.TWO,
    Vh = P,
    Ql = BigInteger.ONE,
    Qh = BigInteger.ONE;

  for (var j = n - 1; j >= s + 1; --j) {
    Ql = this.modMult(Ql, Qh);

    if (k.testBit(j)) {
      Qh = this.modMult(Ql, Q);
      Uh = this.modMult(Uh, Vh);
      Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
      Vh = this.modReduce(Vh.multiply(Vh).subtract(Qh.shiftLeft(1)));
    } else {
      Qh = Ql;
      Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
      Vh = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
      Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
    }
  }

  Ql = this.modMult(Ql, Qh);
  Qh = this.modMult(Ql, Q);
  Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
  Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
  Ql = this.modMult(Ql, Qh);

  for (j = 1; j <= s; ++j) {
    Uh = this.modMult(Uh, Vl);
    Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
    Ql = this.modMult(Ql, Ql);
  }

  return [Uh, Vl];
}

exports = {
  ECCurveFp: ECCurveFp,
  ECPointFp: ECPointFp,
  ECFieldElementFp: ECFieldElementFp
}
module.exports = exports
//
},
'sshpk/lib/ssh-buffer':
function(module, exports, __wpreq__) {
//
module.exports = SSHBuffer;

var assert = __wpreq__('assert-plus'),
  Buffer = __wpreq__('safer-buffer').Buffer;

function SSHBuffer(opts) {
  assert.object(opts, 'options');
  opts.buffer === void 0 || assert.buffer(opts.buffer, 'options.buffer');

  this._size = opts.buffer ? opts.buffer.length : 1024;
  this._buffer = opts.buffer || Buffer.alloc(this._size);
  this._offset = 0;
}

SSHBuffer.prototype.toBuffer = function() {
  return this._buffer.slice(0, this._offset);
};

SSHBuffer.prototype.atEnd = function() {
  return this._offset >= this._buffer.length;
};

SSHBuffer.prototype.remainder = function() {
  return this._buffer.slice(this._offset);
};

SSHBuffer.prototype.skip = function(n) {
  this._offset += n;
};

SSHBuffer.prototype.expand = function() {
  this._size *= 2;
  var buf = Buffer.alloc(this._size);
  this._buffer.copy(buf, 0);
  this._buffer = buf;
};

SSHBuffer.prototype.readPart = function() {
  return {data: this.readBuffer()};
};

SSHBuffer.prototype.readBuffer = function() {
  var len = this._buffer.readUInt32BE(this._offset);
  this._offset += 4;
  assert.ok(
    this._offset + len <= this._buffer.length,
    'length out of bounds at +0x' + this._offset.toString(16) + ' (data truncated?)'
  );
  var buf = this._buffer.slice(this._offset, this._offset + len);
  this._offset += len;
  return buf;
};

SSHBuffer.prototype.readString = function() {
  return this.readBuffer().toString();
};

SSHBuffer.prototype.readCString = function() {
  var offset = this._offset;
  while (offset < this._buffer.length && this._buffer[offset] !== 0x00) offset++;
  assert.ok(offset < this._buffer.length, 'c string does not terminate');
  var str = this._buffer.slice(this._offset, offset).toString();
  this._offset = offset + 1;
  return str;
};

SSHBuffer.prototype.readInt = function() {
  var v = this._buffer.readUInt32BE(this._offset);
  this._offset += 4;
  return v;
};

SSHBuffer.prototype.readInt64 = function() {
  assert.ok(this._offset + 8 < this._buffer.length, 'buffer not long enough to read Int64');
  var v = this._buffer.slice(this._offset, this._offset + 8);
  this._offset += 8;
  return v;
};

SSHBuffer.prototype.readChar = function() {
  return this._buffer[this._offset++];
};

SSHBuffer.prototype.writeBuffer = function(buf) {
  while (this._offset + 4 + buf.length > this._size) this.expand();
  this._buffer.writeUInt32BE(buf.length, this._offset);
  this._offset += 4;
  buf.copy(this._buffer, this._offset);
  this._offset += buf.length;
};

SSHBuffer.prototype.writeString = function(str) {
  this.writeBuffer(Buffer.from(str, 'utf8'));
};

SSHBuffer.prototype.writeCString = function(str) {
  while (this._offset + 1 + str.length > this._size) this.expand();
  this._buffer.write(str, this._offset);
  this._offset += str.length;
  this._buffer[this._offset++] = 0;
};

SSHBuffer.prototype.writeInt = function(v) {
  while (this._offset + 4 > this._size) this.expand();
  this._buffer.writeUInt32BE(v, this._offset);
  this._offset += 4;
};

SSHBuffer.prototype.writeInt64 = function(v) {
  assert.buffer(v, 'value');
  if (v.length > 8) {
    for (var lead = v.slice(0, v.length - 8), i = 0; i < lead.length; ++i)
      assert.strictEqual(lead[i], 0, 'must fit in 64 bits of precision');

    v = v.slice(v.length - 8, v.length);
  }
  while (this._offset + 8 > this._size) this.expand();
  v.copy(this._buffer, this._offset);
  this._offset += 8;
};

SSHBuffer.prototype.writeChar = function(v) {
  while (this._offset + 1 > this._size) this.expand();
  this._buffer[this._offset++] = v;
};

SSHBuffer.prototype.writePart = function(p) {
  this.writeBuffer(p.data);
};

SSHBuffer.prototype.write = function(buf) {
  while (this._offset + buf.length > this._size) this.expand();
  buf.copy(this._buffer, this._offset);
  this._offset += buf.length;
};
//
},
'sshpk/lib/ed-compat':
function(module, exports, __wpreq__) {
//
module.exports = {
  Verifier: Verifier,
  Signer: Signer
};

var nacl,
  stream = __wpreq__('stream'),
  util = __wpreq__('util'),
  assert = __wpreq__('assert-plus'),
  Buffer = __wpreq__('safer-buffer').Buffer,
  Signature = __wpreq__('sshpk/lib/signature');

function Verifier(key, hashAlgo) {
  if (nacl === void 0) nacl = __wpreq__('tweetnacl');

  if (hashAlgo.toLowerCase() !== 'sha512') throw new Error('ED25519 only supports the use of SHA-512 hashes');

  this.key = key;
  this.chunks = [];

  stream.Writable.call(this, {});
}
util.inherits(Verifier, stream.Writable);

Verifier.prototype._write = function(chunk, enc, cb) {
  this.chunks.push(chunk);
  cb();
};

Verifier.prototype.update = function(chunk) {
  if (typeof chunk == 'string') chunk = Buffer.from(chunk, 'binary');
  this.chunks.push(chunk);
};

Verifier.prototype.verify = function(signature, fmt) {
  var sig;
  if (Signature.isSignature(signature, [2, 0])) {
    if (signature.type !== 'ed25519') return false;
    sig = signature.toBuffer('raw');
  } else if (typeof signature == 'string') sig = Buffer.from(signature, 'base64');
  else if (Signature.isSignature(signature, [1, 0]))
    throw new Error('signature was created by too old a version of sshpk and cannot be verified');

  assert.buffer(sig);
  return nacl.sign.detached.verify(
    new Uint8Array(Buffer.concat(this.chunks)),
    new Uint8Array(sig),
    new Uint8Array(this.key.part.A.data)
  );
};

function Signer(key, hashAlgo) {
  if (nacl === void 0) nacl = __wpreq__('tweetnacl');

  if (hashAlgo.toLowerCase() !== 'sha512') throw new Error('ED25519 only supports the use of SHA-512 hashes');

  this.key = key;
  this.chunks = [];

  stream.Writable.call(this, {});
}
util.inherits(Signer, stream.Writable);

Signer.prototype._write = function(chunk, enc, cb) {
  this.chunks.push(chunk);
  cb();
};

Signer.prototype.update = function(chunk) {
  if (typeof chunk == 'string') chunk = Buffer.from(chunk, 'binary');
  this.chunks.push(chunk);
};

Signer.prototype.sign = function() {
  var sig = nacl.sign.detached(
    new Uint8Array(Buffer.concat(this.chunks)),
    new Uint8Array(Buffer.concat([this.key.part.k.data, this.key.part.A.data]))
  );
  var sigBuf = Buffer.from(sig),
    sigObj = Signature.parse(sigBuf, 'ed25519', 'raw');
  sigObj.hashAlgorithm = 'sha512';
  return sigObj;
};
//
},
'sshpk/lib/formats/auto':
function(module, exports, __wpreq__) {
//
module.exports = {
  read: read,
  write: write
};

var assert = __wpreq__('assert-plus'),
  Buffer = __wpreq__('safer-buffer').Buffer,

  pem = __wpreq__('sshpk/lib/formats/pem'),
  ssh = __wpreq__('sshpk/lib/formats/ssh'),
  rfc4253 = __wpreq__('sshpk/lib/formats/rfc4253'),
  dnssec = __wpreq__('sshpk/lib/formats/dnssec'),

  DNSSEC_PRIVKEY_HEADER_PREFIX = 'Private-key-format: v1';

function read(buf, options) {
  if (typeof buf == 'string') {
    if (buf.trim().match(/^[-]+[ ]*BEGIN/)) return pem.read(buf, options);
    if (buf.match(/^\s*ssh-[a-z]/)) return ssh.read(buf, options);
    if (buf.match(/^\s*ecdsa-/)) return ssh.read(buf, options);
    if (findDNSSECHeader(buf)) return dnssec.read(buf, options);
    buf = Buffer.from(buf, 'binary');
  } else {
    assert.buffer(buf);
    if (findPEMHeader(buf)) return pem.read(buf, options);
    if (findSSHHeader(buf)) return ssh.read(buf, options);
    if (findDNSSECHeader(buf)) return dnssec.read(buf, options);
  }
  if (buf.readUInt32BE(0) < buf.length) return rfc4253.read(buf, options);
  throw new Error('Failed to auto-detect format of key');
}

function findSSHHeader(buf) {
  var offset = 0;
  while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9)) ++offset;
  return (
    (offset + 4 <= buf.length && buf.slice(offset, offset + 4).toString('ascii') === 'ssh-') ||
    (offset + 6 <= buf.length && buf.slice(offset, offset + 6).toString('ascii') === 'ecdsa-')
  );
}

function findPEMHeader(buf) {
  var offset = 0;
  while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10)) ++offset;
  if (buf[offset] !== 45) return false;
  while (offset < buf.length && buf[offset] === 45) ++offset;
  while (offset < buf.length && buf[offset] === 32) ++offset;
  return !(offset + 5 > buf.length || buf.slice(offset, offset + 5).toString('ascii') !== 'BEGIN');
}

function findDNSSECHeader(buf) {
  if (buf.length <= DNSSEC_PRIVKEY_HEADER_PREFIX.length) return false;
  if (buf.slice(0, DNSSEC_PRIVKEY_HEADER_PREFIX.length).toString('ascii') === DNSSEC_PRIVKEY_HEADER_PREFIX) return true;

  if (typeof buf != 'string') buf = buf.toString('ascii');

  var lines = buf.split('\n'),
    line = 0;
  while (lines[line].match(/^;/)) line++;
  return !!lines[line].toString('ascii').match(/\. IN KEY /) || !!lines[line].toString('ascii').match(/\. IN DNSKEY /);
}

function write(key, options) {
  throw new Error('"auto" format cannot be used for writing');
}
//
},
'sshpk/lib/formats/pem':
function(module, exports, __wpreq__) {
//
module.exports = {
  read: read,
  write: write
};

var assert = __wpreq__('assert-plus'),
  asn1 = __wpreq__('asn1'),
  crypto = __wpreq__('crypto'),
  Buffer = __wpreq__('safer-buffer').Buffer,
  utils = __wpreq__('sshpk/lib/utils'),
  Key = __wpreq__('sshpk/lib/key'),
  PrivateKey = __wpreq__('sshpk/lib/private-key'),

  pkcs1 = __wpreq__('sshpk/lib/formats/pkcs1'),
  pkcs8 = __wpreq__('sshpk/lib/formats/pkcs8'),
  sshpriv = __wpreq__('sshpk/lib/formats/ssh-private'),
  rfc4253 = __wpreq__('sshpk/lib/formats/rfc4253'),

  errors = __wpreq__('sshpk/lib/errors');

function read(buf, options, forceType) {
  var input = buf;
  if (typeof buf != 'string') {
    assert.buffer(buf, 'buf');
    buf = buf.toString('ascii');
  }

  var lines = buf.trim().split('\n'),

    m = lines[0].match(/[-]+[ ]*BEGIN ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
  assert.ok(m, 'invalid PEM header');

  var m2 = lines[lines.length - 1].match(/[-]+[ ]*END ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
  assert.ok(m2, 'invalid PEM footer');

  assert.equal(m[2], m2[2]);
  var type = m[2].toLowerCase();

  var alg;
  if (m[1]) {
    assert.equal(m[1], m2[1], 'PEM header and footer mismatch');
    alg = m[1].trim();
  }

  var headers = {};
  while ((m = (lines = lines.slice(1))[0].match(/^([A-Za-z0-9-]+): (.+)$/))) headers[m[1].toLowerCase()] = m[2];

  var cipher, key, iv;
  if (headers['proc-type']) {
    var parts = headers['proc-type'].split(',');
    if (parts[0] === '4' && parts[1] === 'ENCRYPTED') {
      if (typeof options.passphrase == 'string') options.passphrase = Buffer.from(options.passphrase, 'utf-8');

      if (!Buffer.isBuffer(options.passphrase)) throw new errors.KeyEncryptedError(options.filename, 'PEM');

      parts = headers['dek-info'].split(',');
      assert.ok(parts.length === 2);
      cipher = parts[0].toLowerCase();
      iv = Buffer.from(parts[1], 'hex');
      key = utils.opensslKeyDeriv(cipher, iv, options.passphrase, 1).key;
    }
  }

  lines = lines.slice(0, -1).join('');
  buf = Buffer.from(lines, 'base64');

  if (cipher && key && iv) {
    var cipherStream = crypto.createDecipheriv(cipher, key, iv),
      chunks = [];
    cipherStream.once('error', function(e) {
      if (e.toString().indexOf('bad decrypt') > -1)
        throw new Error('Incorrect passphrase supplied, could not decrypt key');

      throw e;
    });
    cipherStream.write(buf);
    cipherStream.end();
    for (var chunk; (chunk = cipherStream.read()) !== null; ) chunks.push(chunk);
    buf = Buffer.concat(chunks);
  }

  if (alg && alg.toLowerCase() === 'openssh') return sshpriv.readSSHPrivate(type, buf, options);
  if (alg && alg.toLowerCase() === 'ssh2') return rfc4253.readType(type, buf, options);

  var der = new asn1.BerReader(buf);
  der.originalInput = input;

  der.readSequence();

  if (alg) {
    forceType && assert.strictEqual(forceType, 'pkcs1');
    return pkcs1.readPkcs1(alg, type, der);
  }

  forceType && assert.strictEqual(forceType, 'pkcs8');
  return pkcs8.readPkcs8(alg, type, der);
}

function write(key, options, type) {
  assert.object(key);

  var header,
    alg = {ecdsa: 'EC', rsa: 'RSA', dsa: 'DSA', ed25519: 'EdDSA'}[key.type],

    der = new asn1.BerWriter();

  if (PrivateKey.isPrivateKey(key))
    if (type && type === 'pkcs8') {
      header = 'PRIVATE KEY';
      pkcs8.writePkcs8(der, key);
    } else {
      type && assert.strictEqual(type, 'pkcs1');
      header = alg + ' PRIVATE KEY';
      pkcs1.writePkcs1(der, key);
    }
  else if (Key.isKey(key))
    if (type && type === 'pkcs1') {
      header = alg + ' PUBLIC KEY';
      pkcs1.writePkcs1(der, key);
    } else {
      type && assert.strictEqual(type, 'pkcs8');
      header = 'PUBLIC KEY';
      pkcs8.writePkcs8(der, key);
    }
  else throw new Error('key is not a Key or PrivateKey');

  var tmp = der.buffer.toString('base64'),
    len = tmp.length + tmp.length / 64 + 18 + 16 + header.length * 2 + 10,
    buf = Buffer.alloc(len),
    o = 0;
  o += buf.write('-----BEGIN ' + header + '-----\n', o);
  for (var i = 0; i < tmp.length; ) {
    var limit = i + 64;
    if (limit > tmp.length) limit = tmp.length;
    o += buf.write(tmp.slice(i, limit), o);
    buf[o++] = 10;
    i = limit;
  }
  o += buf.write('-----END ' + header + '-----\n', o);

  return buf.slice(0, o);
}
//
},
'sshpk/lib/formats/pkcs1':
function(module, exports, __wpreq__) {
//
module.exports = {
  read: read,
  readPkcs1: readPkcs1,
  write: write,
  writePkcs1: writePkcs1
};

var assert = __wpreq__('assert-plus'),
  asn1 = __wpreq__('asn1'),
  Buffer = __wpreq__('safer-buffer').Buffer,
  algs = __wpreq__('sshpk/lib/algs'),
  utils = __wpreq__('sshpk/lib/utils'),

  Key = __wpreq__('sshpk/lib/key'),
  PrivateKey = __wpreq__('sshpk/lib/private-key'),
  pem = __wpreq__('sshpk/lib/formats/pem'),

  readECDSACurve = __wpreq__('sshpk/lib/formats/pkcs8').readECDSACurve;

function read(buf, options) {
  return pem.read(buf, options, 'pkcs1');
}

function write(key, options) {
  return pem.write(key, options, 'pkcs1');
}

function readMPInt(der, nm) {
  assert.strictEqual(der.peek(), asn1.Ber.Integer, nm + ' is not an Integer');
  return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
}

function readPkcs1(alg, type, der) {
  switch (alg) {
  case 'RSA':
    if (type === 'public') return readPkcs1RSAPublic(der);
    if (type === 'private') return readPkcs1RSAPrivate(der);
    throw new Error('Unknown key type: ' + type);
  case 'DSA':
    if (type === 'public') return readPkcs1DSAPublic(der);
    if (type === 'private') return readPkcs1DSAPrivate(der);
    throw new Error('Unknown key type: ' + type);
  case 'EC':
  case 'ECDSA':
    if (type === 'private') return readPkcs1ECDSAPrivate(der);
    if (type === 'public') return readPkcs1ECDSAPublic(der);
    throw new Error('Unknown key type: ' + type);
  case 'EDDSA':
  case 'EdDSA':
    if (type === 'private') return readPkcs1EdDSAPrivate(der);
    throw new Error(type + ' keys not supported with EdDSA');
  default:
    throw new Error('Unknown key algo: ' + alg);
  }
}

function readPkcs1RSAPublic(der) {
  var n = readMPInt(der, 'modulus'),
    e = readMPInt(der, 'exponent');

  return new Key({
    type: 'rsa',
    parts: [
      {name: 'e', data: e},
      {name: 'n', data: n}
    ]
  });
}

function readPkcs1RSAPrivate(der) {
  var version = readMPInt(der, 'version');
  assert.strictEqual(version[0], 0);

  var n = readMPInt(der, 'modulus'),
    e = readMPInt(der, 'public exponent'),
    d = readMPInt(der, 'private exponent'),
    p = readMPInt(der, 'prime1'),
    q = readMPInt(der, 'prime2'),
    dmodp = readMPInt(der, 'exponent1'),
    dmodq = readMPInt(der, 'exponent2'),
    iqmp = readMPInt(der, 'iqmp');

  return new PrivateKey({
    type: 'rsa',
    parts: [
      {name: 'n', data: n},
      {name: 'e', data: e},
      {name: 'd', data: d},
      {name: 'iqmp', data: iqmp},
      {name: 'p', data: p},
      {name: 'q', data: q},
      {name: 'dmodp', data: dmodp},
      {name: 'dmodq', data: dmodq}
    ]
  });
}

function readPkcs1DSAPrivate(der) {
  var version = readMPInt(der, 'version');
  assert.strictEqual(version.readUInt8(0), 0);

  var p = readMPInt(der, 'p'),
    q = readMPInt(der, 'q'),
    g = readMPInt(der, 'g'),
    y = readMPInt(der, 'y'),
    x = readMPInt(der, 'x');

  return new PrivateKey({
    type: 'dsa',
    parts: [
      {name: 'p', data: p},
      {name: 'q', data: q},
      {name: 'g', data: g},
      {name: 'y', data: y},
      {name: 'x', data: x}
    ]
  });
}

function readPkcs1EdDSAPrivate(der) {
  var version = readMPInt(der, 'version');
  assert.strictEqual(version.readUInt8(0), 1);

  var k = der.readString(asn1.Ber.OctetString, true);

  der.readSequence(0xa0);
  var oid = der.readOID();
  assert.strictEqual(oid, '1.3.101.112', 'the ed25519 curve identifier');

  der.readSequence(0xa1);
  var A = utils.readBitString(der);

  var key = {
    type: 'ed25519',
    parts: [
      {name: 'A', data: utils.zeroPadToLength(A, 32)},
      {name: 'k', data: k}
    ]
  };

  return new PrivateKey(key);
}

function readPkcs1DSAPublic(der) {
  var y = readMPInt(der, 'y'),
    p = readMPInt(der, 'p'),
    q = readMPInt(der, 'q'),
    g = readMPInt(der, 'g');

  return new Key({
    type: 'dsa',
    parts: [
      {name: 'y', data: y},
      {name: 'p', data: p},
      {name: 'q', data: q},
      {name: 'g', data: g}
    ]
  });
}

function readPkcs1ECDSAPublic(der) {
  der.readSequence();

  var oid = der.readOID();
  assert.strictEqual(oid, '1.2.840.10045.2.1', 'must be ecPublicKey');

  var curve;

  for (var curveOid = der.readOID(), curves = Object.keys(algs.curves), j = 0; j < curves.length; ++j) {
    var c = curves[j];
    if (algs.curves[c].pkcs8oid === curveOid) {
      curve = c;
      break;
    }
  }
  assert.string(curve, 'a known ECDSA named curve');

  var Q = der.readString(asn1.Ber.BitString, true);
  Q = utils.ecNormalize(Q);

  var key = {
    type: 'ecdsa',
    parts: [
      {name: 'curve', data: Buffer.from(curve)},
      {name: 'Q', data: Q}
    ]
  };

  return new Key(key);
}

function readPkcs1ECDSAPrivate(der) {
  var version = readMPInt(der, 'version');
  assert.strictEqual(version.readUInt8(0), 1);

  var d = der.readString(asn1.Ber.OctetString, true);

  der.readSequence(0xa0);
  var curve = readECDSACurve(der);
  assert.string(curve, 'a known elliptic curve');

  der.readSequence(0xa1);
  var Q = der.readString(asn1.Ber.BitString, true);
  Q = utils.ecNormalize(Q);

  var key = {
    type: 'ecdsa',
    parts: [
      {name: 'curve', data: Buffer.from(curve)},
      {name: 'Q', data: Q},
      {name: 'd', data: d}
    ]
  };

  return new PrivateKey(key);
}

function writePkcs1(der, key) {
  der.startSequence();

  switch (key.type) {
  case 'rsa':
    PrivateKey.isPrivateKey(key) ? writePkcs1RSAPrivate(der, key) : writePkcs1RSAPublic(der, key);
    break;
  case 'dsa':
    PrivateKey.isPrivateKey(key) ? writePkcs1DSAPrivate(der, key) : writePkcs1DSAPublic(der, key);
    break;
  case 'ecdsa':
    PrivateKey.isPrivateKey(key) ? writePkcs1ECDSAPrivate(der, key) : writePkcs1ECDSAPublic(der, key);
    break;
  case 'ed25519':
    PrivateKey.isPrivateKey(key) ? writePkcs1EdDSAPrivate(der, key) : writePkcs1EdDSAPublic(der, key);
    break;
  default:
    throw new Error('Unknown key algo: ' + key.type);
  }

  der.endSequence();
}

function writePkcs1RSAPublic(der, key) {
  der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
}

function writePkcs1RSAPrivate(der, key) {
  var ver = Buffer.from([0]);
  der.writeBuffer(ver, asn1.Ber.Integer);

  der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.d.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
  (key.part.dmodp && key.part.dmodq) || utils.addRSAMissing(key);

  der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);
}

function writePkcs1DSAPrivate(der, key) {
  var ver = Buffer.from([0]);
  der.writeBuffer(ver, asn1.Ber.Integer);

  der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.x.data, asn1.Ber.Integer);
}

function writePkcs1DSAPublic(der, key) {
  der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
}

function writePkcs1ECDSAPublic(der, key) {
  der.startSequence();

  der.writeOID('1.2.840.10045.2.1');
  var curve = key.part.curve.data.toString(),
    curveOid = algs.curves[curve].pkcs8oid;
  assert.string(curveOid, 'a known ECDSA named curve');
  der.writeOID(curveOid);

  der.endSequence();

  var Q = utils.ecNormalize(key.part.Q.data, true);
  der.writeBuffer(Q, asn1.Ber.BitString);
}

function writePkcs1ECDSAPrivate(der, key) {
  var ver = Buffer.from([1]);
  der.writeBuffer(ver, asn1.Ber.Integer);

  der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);

  der.startSequence(0xa0);
  var curve = key.part.curve.data.toString(),
    curveOid = algs.curves[curve].pkcs8oid;
  assert.string(curveOid, 'a known ECDSA named curve');
  der.writeOID(curveOid);
  der.endSequence();

  der.startSequence(0xa1);
  var Q = utils.ecNormalize(key.part.Q.data, true);
  der.writeBuffer(Q, asn1.Ber.BitString);
  der.endSequence();
}

function writePkcs1EdDSAPrivate(der, key) {
  var ver = Buffer.from([1]);
  der.writeBuffer(ver, asn1.Ber.Integer);

  der.writeBuffer(key.part.k.data, asn1.Ber.OctetString);

  der.startSequence(0xa0);
  der.writeOID('1.3.101.112');
  der.endSequence();

  der.startSequence(0xa1);
  utils.writeBitString(der, key.part.A.data);
  der.endSequence();
}

function writePkcs1EdDSAPublic(der, key) {
  throw new Error('Public keys are not supported for EdDSA PKCS#1');
}
//
},
'sshpk/lib/formats/pkcs8':
function(module, exports, __wpreq__) {
//
module.exports = {
  read: read,
  readPkcs8: readPkcs8,
  write: write,
  writePkcs8: writePkcs8,

  readECDSACurve: readECDSACurve,
  writeECDSACurve: writeECDSACurve
};

var assert = __wpreq__('assert-plus'),
  asn1 = __wpreq__('asn1'),
  Buffer = __wpreq__('safer-buffer').Buffer,
  algs = __wpreq__('sshpk/lib/algs'),
  utils = __wpreq__('sshpk/lib/utils'),
  Key = __wpreq__('sshpk/lib/key'),
  PrivateKey = __wpreq__('sshpk/lib/private-key'),
  pem = __wpreq__('sshpk/lib/formats/pem');

function read(buf, options) {
  return pem.read(buf, options, 'pkcs8');
}

function write(key, options) {
  return pem.write(key, options, 'pkcs8');
}

function readMPInt(der, nm) {
  assert.strictEqual(der.peek(), asn1.Ber.Integer, nm + ' is not an Integer');
  return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
}

function readPkcs8(alg, type, der) {
  if (der.peek() === asn1.Ber.Integer) {
    assert.strictEqual(type, 'private', 'unexpected Integer at start of public key');
    der.readString(asn1.Ber.Integer, true);
  }

  der.readSequence();
  var next = der.offset + der.length,

    oid = der.readOID();
  switch (oid) {
  case '1.2.840.113549.1.1.1':
    der._offset = next;
    return type === 'public' ? readPkcs8RSAPublic(der) : readPkcs8RSAPrivate(der);
  case '1.2.840.10040.4.1':
    return type === 'public' ? readPkcs8DSAPublic(der) : readPkcs8DSAPrivate(der);
  case '1.2.840.10045.2.1':
    return type === 'public' ? readPkcs8ECDSAPublic(der) : readPkcs8ECDSAPrivate(der);
  case '1.3.101.112':
    return type === 'public' ? readPkcs8EdDSAPublic(der) : readPkcs8EdDSAPrivate(der);

  case '1.3.101.110':
    return type === 'public' ? readPkcs8X25519Public(der) : readPkcs8X25519Private(der);

  default:
    throw new Error('Unknown key type OID ' + oid);
  }
}

function readPkcs8RSAPublic(der) {
  der.readSequence(asn1.Ber.BitString);
  der.readByte();
  der.readSequence();

  var n = readMPInt(der, 'modulus'),
    e = readMPInt(der, 'exponent');

  var key = {
    type: 'rsa',
    source: der.originalInput,
    parts: [
      {name: 'e', data: e},
      {name: 'n', data: n}
    ]
  };

  return new Key(key);
}

function readPkcs8RSAPrivate(der) {
  der.readSequence(asn1.Ber.OctetString);
  der.readSequence();

  var ver = readMPInt(der, 'version');
  assert.equal(ver[0], 0x0, 'unknown RSA private key version');

  var n = readMPInt(der, 'modulus'),
    e = readMPInt(der, 'public exponent'),
    d = readMPInt(der, 'private exponent'),
    p = readMPInt(der, 'prime1'),
    q = readMPInt(der, 'prime2'),
    dmodp = readMPInt(der, 'exponent1'),
    dmodq = readMPInt(der, 'exponent2'),
    iqmp = readMPInt(der, 'iqmp');

  return new PrivateKey({
    type: 'rsa',
    parts: [
      {name: 'n', data: n},
      {name: 'e', data: e},
      {name: 'd', data: d},
      {name: 'iqmp', data: iqmp},
      {name: 'p', data: p},
      {name: 'q', data: q},
      {name: 'dmodp', data: dmodp},
      {name: 'dmodq', data: dmodq}
    ]
  });
}

function readPkcs8DSAPublic(der) {
  der.readSequence();

  var p = readMPInt(der, 'p'),
    q = readMPInt(der, 'q'),
    g = readMPInt(der, 'g');

  der.readSequence(asn1.Ber.BitString);
  der.readByte();

  var y = readMPInt(der, 'y');

  return new Key({
    type: 'dsa',
    parts: [
      {name: 'p', data: p},
      {name: 'q', data: q},
      {name: 'g', data: g},
      {name: 'y', data: y}
    ]
  });
}

function readPkcs8DSAPrivate(der) {
  der.readSequence();

  var p = readMPInt(der, 'p'),
    q = readMPInt(der, 'q'),
    g = readMPInt(der, 'g');

  der.readSequence(asn1.Ber.OctetString);
  var x = readMPInt(der, 'x'),

    y = utils.calculateDSAPublic(g, p, x);

  return new PrivateKey({
    type: 'dsa',
    parts: [
      {name: 'p', data: p},
      {name: 'q', data: q},
      {name: 'g', data: g},
      {name: 'y', data: y},
      {name: 'x', data: x}
    ]
  });
}

function readECDSACurve(der) {
  var curveName, curveNames, j, c, cd;

  if (der.peek() === asn1.Ber.OID) {
    var oid = der.readOID();

    curveNames = Object.keys(algs.curves);
    for (j = 0; j < curveNames.length; ++j) {
      c = curveNames[j];
      if ((cd = algs.curves[c]).pkcs8oid === oid) {
        curveName = c;
        break;
      }
    }
  } else {
    der.readSequence();
    var version = der.readString(asn1.Ber.Integer, true);
    assert.strictEqual(version[0], 1, 'ECDSA key not version 1');

    var curve = {};

    der.readSequence();
    var fieldTypeOid = der.readOID();
    assert.strictEqual(fieldTypeOid, '1.2.840.10045.1.1', 'ECDSA key is not from a prime-field');
    var p = (curve.p = utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));
    curve.size = p.length * 8 - utils.countZeros(p);

    der.readSequence();
    curve.a = utils.mpNormalize(der.readString(asn1.Ber.OctetString, true));
    curve.b = utils.mpNormalize(der.readString(asn1.Ber.OctetString, true));
    if (der.peek() === asn1.Ber.BitString) curve.s = der.readString(asn1.Ber.BitString, true);

    curve.G = der.readString(asn1.Ber.OctetString, true);
    assert.strictEqual(curve.G[0], 0x4, 'uncompressed G is required');

    curve.n = utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
    curve.h = utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
    assert.strictEqual(curve.h[0], 0x1, 'a cofactor=1 curve is required');

    curveNames = Object.keys(algs.curves);
    var ks = Object.keys(curve);
    for (j = 0; j < curveNames.length; ++j) {
      c = curveNames[j];
      cd = algs.curves[c];
      var equal = true;
      for (var i = 0; i < ks.length; ++i) {
        var k = ks[i];
        if (cd[k] === void 0) continue;

        if (typeof cd[k] == 'object' && cd[k].equals !== void 0) {
          if (!cd[k].equals(curve[k])) {
            equal = false;
            break;
          }
        } else if (Buffer.isBuffer(cd[k])) {
          if (cd[k].toString('binary') !== curve[k].toString('binary')) {
            equal = false;
            break;
          }
        } else if (cd[k] !== curve[k]) {
          equal = false;
          break;
        }
      }
      if (equal) {
        curveName = c;
        break;
      }
    }
  }
  return curveName;
}

function readPkcs8ECDSAPrivate(der) {
  var curveName = readECDSACurve(der);
  assert.string(curveName, 'a known elliptic curve');

  der.readSequence(asn1.Ber.OctetString);
  der.readSequence();

  var version = readMPInt(der, 'version');
  assert.equal(version[0], 1, 'unknown version of ECDSA key');

  var d = der.readString(asn1.Ber.OctetString, true);
  der.readSequence(0xa1);

  var Q = der.readString(asn1.Ber.BitString, true);
  Q = utils.ecNormalize(Q);

  var key = {
    type: 'ecdsa',
    parts: [
      {name: 'curve', data: Buffer.from(curveName)},
      {name: 'Q', data: Q},
      {name: 'd', data: d}
    ]
  };

  return new PrivateKey(key);
}

function readPkcs8ECDSAPublic(der) {
  var curveName = readECDSACurve(der);
  assert.string(curveName, 'a known elliptic curve');

  var Q = der.readString(asn1.Ber.BitString, true);
  Q = utils.ecNormalize(Q);

  var key = {
    type: 'ecdsa',
    parts: [
      {name: 'curve', data: Buffer.from(curveName)},
      {name: 'Q', data: Q}
    ]
  };

  return new Key(key);
}

function readPkcs8EdDSAPublic(der) {
  der.peek() !== 0x00 || der.readByte();

  var A = utils.readBitString(der);

  var key = {
    type: 'ed25519',
    parts: [{name: 'A', data: utils.zeroPadToLength(A, 32)}]
  };

  return new Key(key);
}

function readPkcs8X25519Public(der) {
  var A = utils.readBitString(der);

  var key = {
    type: 'curve25519',
    parts: [{name: 'A', data: utils.zeroPadToLength(A, 32)}]
  };

  return new Key(key);
}

function readPkcs8EdDSAPrivate(der) {
  der.peek() !== 0x00 || der.readByte();

  der.readSequence(asn1.Ber.OctetString);
  var k = der.readString(asn1.Ber.OctetString, true);
  k = utils.zeroPadToLength(k, 32);

  var A;
  if (der.peek() === asn1.Ber.BitString) {
    A = utils.readBitString(der);
    A = utils.zeroPadToLength(A, 32);
  } else A = utils.calculateED25519Public(k);

  var key = {
    type: 'ed25519',
    parts: [
      {name: 'A', data: utils.zeroPadToLength(A, 32)},
      {name: 'k', data: utils.zeroPadToLength(k, 32)}
    ]
  };

  return new PrivateKey(key);
}

function readPkcs8X25519Private(der) {
  der.peek() !== 0x00 || der.readByte();

  der.readSequence(asn1.Ber.OctetString);
  var k = der.readString(asn1.Ber.OctetString, true);
  k = utils.zeroPadToLength(k, 32);

  var A = utils.calculateX25519Public(k);

  var key = {
    type: 'curve25519',
    parts: [
      {name: 'A', data: utils.zeroPadToLength(A, 32)},
      {name: 'k', data: utils.zeroPadToLength(k, 32)}
    ]
  };

  return new PrivateKey(key);
}

function writePkcs8(der, key) {
  der.startSequence();

  if (PrivateKey.isPrivateKey(key)) {
    var sillyInt = Buffer.from([0]);
    der.writeBuffer(sillyInt, asn1.Ber.Integer);
  }

  der.startSequence();
  switch (key.type) {
  case 'rsa':
    der.writeOID('1.2.840.113549.1.1.1');
    PrivateKey.isPrivateKey(key) ? writePkcs8RSAPrivate(key, der) : writePkcs8RSAPublic(key, der);
    break;
  case 'dsa':
    der.writeOID('1.2.840.10040.4.1');
    PrivateKey.isPrivateKey(key) ? writePkcs8DSAPrivate(key, der) : writePkcs8DSAPublic(key, der);
    break;
  case 'ecdsa':
    der.writeOID('1.2.840.10045.2.1');
    PrivateKey.isPrivateKey(key) ? writePkcs8ECDSAPrivate(key, der) : writePkcs8ECDSAPublic(key, der);
    break;
  case 'ed25519':
    der.writeOID('1.3.101.112');
    if (PrivateKey.isPrivateKey(key)) throw new Error('Ed25519 private keys in pkcs8 format are not supported');
    writePkcs8EdDSAPublic(key, der);
    break;
  default:
    throw new Error('Unsupported key type: ' + key.type);
  }

  der.endSequence();
}

function writePkcs8RSAPrivate(key, der) {
  der.writeNull();
  der.endSequence();

  der.startSequence(asn1.Ber.OctetString);
  der.startSequence();

  var version = Buffer.from([0]);
  der.writeBuffer(version, asn1.Ber.Integer);

  der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.d.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
  (key.part.dmodp && key.part.dmodq) || utils.addRSAMissing(key);

  der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);

  der.endSequence();
  der.endSequence();
}

function writePkcs8RSAPublic(key, der) {
  der.writeNull();
  der.endSequence();

  der.startSequence(asn1.Ber.BitString);
  der.writeByte(0x00);

  der.startSequence();
  der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
  der.endSequence();

  der.endSequence();
}

function writePkcs8DSAPrivate(key, der) {
  der.startSequence();
  der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
  der.endSequence();

  der.endSequence();

  der.startSequence(asn1.Ber.OctetString);
  der.writeBuffer(key.part.x.data, asn1.Ber.Integer);
  der.endSequence();
}

function writePkcs8DSAPublic(key, der) {
  der.startSequence();
  der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
  der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
  der.endSequence();
  der.endSequence();

  der.startSequence(asn1.Ber.BitString);
  der.writeByte(0x00);
  der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
  der.endSequence();
}

function writeECDSACurve(key, der) {
  var curve = algs.curves[key.curve];
  if (curve.pkcs8oid) der.writeOID(curve.pkcs8oid);
  else {
    der.startSequence();

    var version = Buffer.from([1]);
    der.writeBuffer(version, asn1.Ber.Integer);

    der.startSequence();
    der.writeOID('1.2.840.10045.1.1');
    der.writeBuffer(curve.p, asn1.Ber.Integer);
    der.endSequence();

    der.startSequence();
    var a = curve.p;
    if (a[0] === 0x0) a = a.slice(1);
    der.writeBuffer(a, asn1.Ber.OctetString);
    der.writeBuffer(curve.b, asn1.Ber.OctetString);
    der.writeBuffer(curve.s, asn1.Ber.BitString);
    der.endSequence();

    der.writeBuffer(curve.G, asn1.Ber.OctetString);
    der.writeBuffer(curve.n, asn1.Ber.Integer);
    var h = curve.h;
    h || (h = Buffer.from([1]));

    der.writeBuffer(h, asn1.Ber.Integer);

    der.endSequence();
  }
}

function writePkcs8ECDSAPublic(key, der) {
  writeECDSACurve(key, der);
  der.endSequence();

  var Q = utils.ecNormalize(key.part.Q.data, true);
  der.writeBuffer(Q, asn1.Ber.BitString);
}

function writePkcs8ECDSAPrivate(key, der) {
  writeECDSACurve(key, der);
  der.endSequence();

  der.startSequence(asn1.Ber.OctetString);
  der.startSequence();

  var version = Buffer.from([1]);
  der.writeBuffer(version, asn1.Ber.Integer);

  der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);

  der.startSequence(0xa1);
  var Q = utils.ecNormalize(key.part.Q.data, true);
  der.writeBuffer(Q, asn1.Ber.BitString);
  der.endSequence();

  der.endSequence();
  der.endSequence();
}

function writePkcs8EdDSAPublic(key, der) {
  der.endSequence();

  utils.writeBitString(der, key.part.A.data);
}
//
},
'sshpk/lib/formats/ssh-private':
function(module, exports, __wpreq__) {
//
module.exports = {
  read: read,
  readSSHPrivate: readSSHPrivate,
  write: write
};

var bcrypt,
  assert = __wpreq__('assert-plus'),
  Buffer = __wpreq__('safer-buffer').Buffer,
  utils = __wpreq__('sshpk/lib/utils'),
  crypto = __wpreq__('crypto'),

  PrivateKey = __wpreq__('sshpk/lib/private-key'),
  pem = __wpreq__('sshpk/lib/formats/pem'),
  rfc4253 = __wpreq__('sshpk/lib/formats/rfc4253'),
  SSHBuffer = __wpreq__('sshpk/lib/ssh-buffer'),
  errors = __wpreq__('sshpk/lib/errors');

function read(buf, options) {
  return pem.read(buf, options);
}

var MAGIC = 'openssh-key-v1';

function readSSHPrivate(type, buf, options) {
  var magic = (buf = new SSHBuffer({buffer: buf})).readCString();
  assert.strictEqual(magic, MAGIC, 'bad magic string');

  var cipher = buf.readString(),
    kdf = buf.readString(),
    kdfOpts = buf.readBuffer();

  if (buf.readInt() !== 1) throw new Error('OpenSSH-format key file contains multiple keys: this is unsupported.');

  var pubKey = buf.readBuffer();

  if (type === 'public') {
    assert.ok(buf.atEnd(), 'excess bytes left after key');
    return rfc4253.read(pubKey);
  }

  var privKeyBlob = buf.readBuffer();
  assert.ok(buf.atEnd(), 'excess bytes left after key');

  var kdfOptsBuf = new SSHBuffer({buffer: kdfOpts});
  switch (kdf) {
  case 'none':
    if (cipher !== 'none')
      throw new Error('OpenSSH-format key uses KDF "none" but specifies a cipher other than "none"');

    break;
  case 'bcrypt':
    var salt = kdfOptsBuf.readBuffer(),
      rounds = kdfOptsBuf.readInt(),
      cinf = utils.opensshCipherInfo(cipher);
    if (bcrypt === void 0) bcrypt = __wpreq__('bcrypt-pbkdf');

    if (typeof options.passphrase == 'string') options.passphrase = Buffer.from(options.passphrase, 'utf-8');

    if (!Buffer.isBuffer(options.passphrase)) throw new errors.KeyEncryptedError(options.filename, 'OpenSSH');

    var pass = new Uint8Array(options.passphrase),
      salti = new Uint8Array(salt),
      out = new Uint8Array(cinf.keySize + cinf.blockSize);
    if (bcrypt.pbkdf(pass, pass.length, salti, salti.length, out, out.length, rounds) !== 0)
      throw new Error('bcrypt_pbkdf function returned failure, parameters invalid');

    var ckey = (out = Buffer.from(out)).slice(0, cinf.keySize),
      iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize),
      cipherStream = crypto.createDecipheriv(cinf.opensslName, ckey, iv);
    cipherStream.setAutoPadding(false);
    var chunk, chunks = [];
    cipherStream.once('error', function(e) {
      if (e.toString().indexOf('bad decrypt') > -1)
        throw new Error('Incorrect passphrase supplied, could not decrypt key');

      throw e;
    });
    cipherStream.write(privKeyBlob);
    cipherStream.end();
    while ((chunk = cipherStream.read()) !== null) chunks.push(chunk);
    privKeyBlob = Buffer.concat(chunks);
    break;
  default:
    throw new Error('OpenSSH-format key uses unknown KDF "' + kdf + '"');
  }

  if ((buf = new SSHBuffer({buffer: privKeyBlob})).readInt() !== buf.readInt())
    throw new Error('Incorrect passphrase supplied, could not decrypt key');

  var ret = {},
    key = rfc4253.readInternal(ret, 'private', buf.remainder());

  buf.skip(ret.consumed);

  key.comment = buf.readString();

  return key;
}

function write(key, options) {
  var pubKey = PrivateKey.isPrivateKey(key) ? key.toPublic() : key;

  var passphrase,
    privBuf,
    cipher = 'none',
    kdf = 'none',
    kdfopts = Buffer.alloc(0),
    cinf = {blockSize: 8};
  if (options !== void 0) {
    if (typeof (passphrase = options.passphrase) == 'string') passphrase = Buffer.from(passphrase, 'utf-8');
    if (passphrase !== void 0) {
      assert.buffer(passphrase, 'options.passphrase');
      assert.optionalString(options.cipher, 'options.cipher');
      if ((cipher = options.cipher) === void 0) cipher = 'aes128-ctr';
      cinf = utils.opensshCipherInfo(cipher);
      kdf = 'bcrypt';
    }
  }

  if (PrivateKey.isPrivateKey(key)) {
    privBuf = new SSHBuffer({});
    var checkInt = crypto.randomBytes(4).readUInt32BE(0);
    privBuf.writeInt(checkInt);
    privBuf.writeInt(checkInt);
    privBuf.write(key.toBuffer('rfc4253'));
    privBuf.writeString(key.comment || '');

    for (var n = 1; privBuf._offset % cinf.blockSize != 0; ) privBuf.writeChar(n++);
    privBuf = privBuf.toBuffer();
  }

  switch (kdf) {
  case 'none':
    break;
  case 'bcrypt':
    var salt = crypto.randomBytes(16),
      rounds = 16,
      kdfssh = new SSHBuffer({});
    kdfssh.writeBuffer(salt);
    kdfssh.writeInt(rounds);
    kdfopts = kdfssh.toBuffer();

    if (bcrypt === void 0) bcrypt = __wpreq__('bcrypt-pbkdf');

    var pass = new Uint8Array(passphrase),
      salti = new Uint8Array(salt),
      out = new Uint8Array(cinf.keySize + cinf.blockSize);
    if (bcrypt.pbkdf(pass, pass.length, salti, salti.length, out, out.length, rounds) !== 0)
      throw new Error('bcrypt_pbkdf function returned failure, parameters invalid');

    var ckey = (out = Buffer.from(out)).slice(0, cinf.keySize),
      iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize),

      cipherStream = crypto.createCipheriv(cinf.opensslName, ckey, iv);
    cipherStream.setAutoPadding(false);
    var chunk, chunks = [];
    cipherStream.once('error', function(e) {
      throw e;
    });
    cipherStream.write(privBuf);
    cipherStream.end();
    while ((chunk = cipherStream.read()) !== null) chunks.push(chunk);
    privBuf = Buffer.concat(chunks);
    break;
  default:
    throw new Error('Unsupported kdf ' + kdf);
  }

  var buf = new SSHBuffer({});

  buf.writeCString(MAGIC);
  buf.writeString(cipher);
  buf.writeString(kdf);
  buf.writeBuffer(kdfopts);

  buf.writeInt(1);
  buf.writeBuffer(pubKey.toBuffer('rfc4253'));

  privBuf && buf.writeBuffer(privBuf);

  buf = buf.toBuffer();

  var header = PrivateKey.isPrivateKey(key) ? 'OPENSSH PRIVATE KEY' : 'OPENSSH PUBLIC KEY';

  var tmp = buf.toString('base64'),
    len = tmp.length + tmp.length / 70 + 18 + 16 + header.length * 2 + 10,
    o = 0;
  o += (buf = Buffer.alloc(len)).write('-----BEGIN ' + header + '-----\n', o);
  for (var i = 0; i < tmp.length; ) {
    var limit = i + 70;
    if (limit > tmp.length) limit = tmp.length;
    o += buf.write(tmp.slice(i, limit), o);
    buf[o++] = 10;
    i = limit;
  }
  o += buf.write('-----END ' + header + '-----\n', o);

  return buf.slice(0, o);
}
//
},
'sshpk/lib/formats/rfc4253':
function(module, exports, __wpreq__) {
//
module.exports = {
  read: read.bind(void 0, false, void 0),
  readType: read.bind(void 0, false),
  write: write,
  readPartial: read.bind(void 0, true),

  readInternal: read,
  keyTypeToAlg: keyTypeToAlg,
  algToKeyType: algToKeyType
};

var assert = __wpreq__('assert-plus'),
  Buffer = __wpreq__('safer-buffer').Buffer,
  algs = __wpreq__('sshpk/lib/algs'),
  utils = __wpreq__('sshpk/lib/utils'),
  Key = __wpreq__('sshpk/lib/key'),
  PrivateKey = __wpreq__('sshpk/lib/private-key'),
  SSHBuffer = __wpreq__('sshpk/lib/ssh-buffer');

function algToKeyType(alg) {
  assert.string(alg);
  if (alg === 'ssh-dss') return 'dsa';
  if (alg === 'ssh-rsa') return 'rsa';
  if (alg === 'ssh-ed25519') return 'ed25519';
  if (alg === 'ssh-curve25519') return 'curve25519';
  if (alg.match(/^ecdsa-sha2-/)) return 'ecdsa';

  throw new Error('Unknown algorithm ' + alg);
}

function keyTypeToAlg(key) {
  assert.object(key);
  if (key.type === 'dsa') return 'ssh-dss';
  if (key.type === 'rsa') return 'ssh-rsa';
  if (key.type === 'ed25519') return 'ssh-ed25519';
  if (key.type === 'curve25519') return 'ssh-curve25519';
  if (key.type === 'ecdsa') return 'ecdsa-sha2-' + key.part.curve.data.toString();

  throw new Error('Unknown key type ' + key.type);
}

function read(partial, type, buf, options) {
  if (typeof buf == 'string') buf = Buffer.from(buf);
  assert.buffer(buf, 'buf');

  var key = {},

    parts = (key.parts = []),
    sshbuf = new SSHBuffer({buffer: buf}),

    alg = sshbuf.readString();
  assert.ok(!sshbuf.atEnd(), 'key must have at least one part');

  key.type = algToKeyType(alg);

  var partCount = algs.info[key.type].parts.length;
  if (type && type === 'private') partCount = algs.privInfo[key.type].parts.length;

  while (!sshbuf.atEnd() && parts.length < partCount) parts.push(sshbuf.readPart());
  while (!partial && !sshbuf.atEnd()) parts.push(sshbuf.readPart());

  assert.ok(parts.length >= 1, 'key must have at least one part');
  assert.ok(partial || sshbuf.atEnd(), 'leftover bytes at end of key');

  var Constructor = Key,
    algInfo = algs.info[key.type];
  if (type === 'private' || algInfo.parts.length !== parts.length) {
    algInfo = algs.privInfo[key.type];
    Constructor = PrivateKey;
  }
  assert.strictEqual(algInfo.parts.length, parts.length);

  if (key.type === 'ecdsa') {
    var res = /^ecdsa-sha2-(.+)$/.exec(alg);
    assert.ok(res !== null);
    assert.strictEqual(res[1], parts[0].data.toString());
  }

  var normalized = true;
  for (var i = 0; i < algInfo.parts.length; ++i) {
    var p = parts[i];
    p.name = algInfo.parts[i];
    if (key.type === 'ed25519' && p.name === 'k') p.data = p.data.slice(0, 32);

    if (p.name !== 'curve' && algInfo.normalize !== false) {
      var nd = key.type === 'ed25519' ? utils.zeroPadToLength(p.data, 32) : utils.mpNormalize(p.data);

      if (nd.toString('binary') !== p.data.toString('binary')) {
        p.data = nd;
        normalized = false;
      }
    }
  }

  if (normalized) key._rfc4253Cache = sshbuf.toBuffer();

  if (partial && typeof partial == 'object') {
    partial.remainder = sshbuf.remainder();
    partial.consumed = sshbuf._offset;
  }

  return new Constructor(key);
}

function write(key, options) {
  assert.object(key);

  var i,
    alg = keyTypeToAlg(key),

    algInfo = algs.info[key.type];
  if (PrivateKey.isPrivateKey(key)) algInfo = algs.privInfo[key.type];
  var parts = algInfo.parts,

    buf = new SSHBuffer({});

  buf.writeString(alg);

  for (i = 0; i < parts.length; ++i) {
    var data = key.part[parts[i]].data;
    if (algInfo.normalize !== false)
      data = key.type === 'ed25519' ? utils.zeroPadToLength(data, 32) : utils.mpNormalize(data);

    if (key.type === 'ed25519' && parts[i] === 'k') data = Buffer.concat([data, key.part.A.data]);
    buf.writeBuffer(data);
  }

  return buf.toBuffer();
}
//
},
'bcrypt-pbkdf':
function(module, exports, __wpreq__) {
//
var crypto_hash_sha512 = __wpreq__('tweetnacl').lowlevel.crypto_hash,

  BLF_J = 0;

var Blowfish = function() {
  this.S = [
    new Uint32Array([
      0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99, 0x24a19947,
      0xb3916cf7, 0x0801f2e2, 0x858efc16, 0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e, 0x0d95748f, 0x728eb658,
      0x718bcd58, 0x82154aee, 0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013, 0xc5d1b023, 0x286085f0, 0xca417918,
      0xb8db38ef, 0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e, 0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60,
      0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440, 0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce, 0xa15486af,
      0x7c72e993, 0xb3ee1411, 0x636fbc2a, 0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e, 0xafd6ba33, 0x6c24cf5c,
      0x7a325381, 0x28958677, 0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193, 0x61d809cc, 0xfb21a991, 0x487cac60,
      0x5dec8032, 0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88, 0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239,
      0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e, 0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0, 0x6a51a0d2,
      0xd8542f68, 0x960fa728, 0xab5133a3, 0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98, 0xa1f1651d, 0x39af0176,
      0x66ca593e, 0x82430e88, 0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe, 0xe06f75d8, 0x85c12073, 0x401a449f,
      0x56c16aa6, 0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d, 0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b,
      0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7, 0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba, 0xc1a94fb6,
      0x409f60c4, 0x5e5c9ec2, 0x196a2463, 0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f, 0x6dfc511f, 0x9b30952c,
      0xcc814544, 0xaf5ebd09, 0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3, 0xc0cba857, 0x45c8740f, 0xd20b5f39,
      0xb9d3fbdb, 0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279, 0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8,
      0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab, 0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82, 0x9e5c57bb,
      0xca6f8ca0, 0x1a87562e, 0xdf1769db, 0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573, 0x695b27b0, 0xbbca58c8,
      0xe1ffa35d, 0xb8f011a0, 0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b, 0x9a53e479, 0xb6f84565, 0xd28e49bc,
      0x4bfb9790, 0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8, 0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4,
      0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0, 0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7, 0x8ff6e2fb,
      0xf2122b64, 0x8888b812, 0x900df01c, 0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad, 0x2f2f2218, 0xbe0e1777,
      0xea752dfe, 0x8b021fa1, 0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299, 0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81,
      0xd2ada8d9, 0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477, 0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf,
      0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49, 0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af, 0x2464369b,
      0xf009b91e, 0x5563911d, 0x59dfa6aa, 0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5, 0x83260376, 0x6295cfa9,
      0x11c81968, 0x4e734a41, 0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915, 0xd60f573f, 0xbc9bc6e4, 0x2b60a476,
      0x81e67400, 0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915, 0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664,
      0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a
    ]),
    new Uint32Array([
      0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623, 0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266, 0xecaa8c71,
      0x699a17ff, 0x5664526c, 0xc2b19ee1, 0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e, 0x3f54989a, 0x5b429d65,
      0x6b8fe4d6, 0x99f73fd6, 0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1, 0x4cdd2086, 0x8470eb26, 0x6382e9c6,
      0x021ecc5e, 0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1, 0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737,
      0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8, 0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff, 0xae0cf51a,
      0x3cb574b2, 0x25837a58, 0xdc0921bd, 0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701, 0x3ae5e581, 0x37c2dadc,
      0xc8b57634, 0x9af3dda7, 0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41, 0xe238cd99, 0x3bea0e2f, 0x3280bba1,
      0x183eb331, 0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf, 0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af,
      0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e, 0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87, 0x7a584718,
      0x7408da17, 0xbc9f9abc, 0xe94b7d8c, 0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2, 0xef1c1847, 0x3215d908,
      0xdd433b37, 0x24c2ba16, 0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd, 0x71dff89e, 0x10314e55, 0x81ac77d6,
      0x5f11199b, 0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509, 0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e,
      0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3, 0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f, 0x803e89d6,
      0x5266c825, 0x2e4cc978, 0x9c10b36a, 0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4, 0xf2f74ea7, 0x361d2b3d,
      0x1939260f, 0x19c27960, 0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66, 0xe3bc4595, 0xa67bc883, 0xb17f37d1,
      0x018cff28, 0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802, 0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84,
      0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510, 0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf, 0xb5735c90,
      0x4c70a239, 0xd59e9e0b, 0xcbaade14, 0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e, 0x648b1eaf, 0x19bdf0ca,
      0xa02369b9, 0x655abb50, 0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7, 0x9b540b19, 0x875fa099, 0x95f7997e,
      0x623d7da8, 0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281, 0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99,
      0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696, 0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128, 0x58ebf2ef,
      0x34c6ffea, 0xfe28ed61, 0xee7c3c73, 0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0, 0x45eee2b6, 0xa3aaabea,
      0xdb6c4f15, 0xfacb4fd0, 0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105, 0xd81e799e, 0x86854dc7, 0xe44b476a,
      0x3d816250, 0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3, 0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285,
      0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00, 0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061, 0x3372f092,
      0x8d937e41, 0xd65fecf1, 0x6c223bdb, 0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e, 0xa6078084, 0x19f8509e,
      0xe8efd855, 0x61d99735, 0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc, 0x9e447a2e, 0xc3453484, 0xfdd56705,
      0x0e1e9ec9, 0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340, 0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20,
      0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7
    ]),
    new Uint32Array([
      0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934, 0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068, 0xd4082471,
      0x3320f46a, 0x43b7d4b7, 0x500061af, 0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840, 0x4d95fc1d, 0x96b591af,
      0x70f4ddd3, 0x66a02f45, 0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504, 0x96eb27b3, 0x55fd3941, 0xda2547e6,
      0xabca0a9a, 0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb, 0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee,
      0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6, 0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42, 0x20fe9e35,
      0xd9f385b9, 0xee39d7ab, 0x3b124e8b, 0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2, 0x3a6efa74, 0xdd5b4332,
      0x6841e7f7, 0xca7820fb, 0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527, 0x55533a3a, 0x20838d87, 0xfe6ba9b7,
      0xd096954b, 0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33, 0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c,
      0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3, 0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc, 0x07f9c9ee,
      0x41041f0f, 0x404779a4, 0x5d886e17, 0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564, 0x257b7834, 0x602a9c60,
      0xdff8e8a3, 0x1f636c1b, 0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115, 0x6b2395e0, 0x333e92e1, 0x3b240b62,
      0xeebeb922, 0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728, 0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0,
      0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e, 0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37, 0xa812dc60,
      0xa1ebddf8, 0x991be14c, 0xdb6e6b0d, 0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804, 0xf1290dc7, 0xcc00ffa3,
      0xb5390f92, 0x690fed0b, 0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3, 0xbb132f88, 0x515bad24, 0x7b9479bf,
      0x763bd6eb, 0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d, 0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c,
      0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350, 0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9, 0x44421659,
      0x0a121386, 0xd90cec6e, 0xd5abea2a, 0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe, 0x9dbc8057, 0xf0f7c086,
      0x60787bf8, 0x6003604d, 0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc, 0x83426b33, 0xf01eab71, 0xb0804187,
      0x3c005e5f, 0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61, 0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2,
      0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9, 0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2, 0x466e598e,
      0x20b45770, 0x8cd55591, 0xc902de4c, 0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e, 0xb77f19b6, 0xe0a9dc09,
      0x662d09a1, 0xc4324633, 0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10, 0x1ab93d1d, 0x0ba5a4df, 0xa186f20f,
      0x2868f169, 0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52, 0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027,
      0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5, 0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62, 0x11e69ed7,
      0x2338ea63, 0x53c2dd94, 0xc2c21634, 0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76, 0x6f05e409, 0x4b7c0188,
      0x39720a3d, 0x7c927c24, 0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc, 0xed545578, 0x08fca5b5, 0xd83d7cd3,
      0x4dad0fc4, 0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c, 0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837,
      0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0
    ]),
    new Uint32Array([
      0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b, 0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe, 0xd5118e9d,
      0xbf0f7315, 0xd62d1c7e, 0xc700c47b, 0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4, 0x5748ab2f, 0xbc946e79,
      0xc6a376d2, 0x6549c2c8, 0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6, 0x2939bbdb, 0xa9ba4650, 0xac9526e8,
      0xbe5ee304, 0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22, 0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4,
      0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6, 0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9, 0xc72fefd3,
      0xf752f7da, 0x3f046f69, 0x77fa0a59, 0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593, 0xe990fd5a, 0x9e34d797,
      0x2cf0b7d9, 0x022b8b51, 0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28, 0x1f9f25cf, 0xadf2b89b, 0x5ad6b472,
      0x5a88f54c, 0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b, 0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,
      0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c, 0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd, 0xc3eb9e15,
      0x3c9057a2, 0x97271aec, 0xa93a072a, 0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319, 0x7533d928, 0xb155fdf5,
      0x03563482, 0x8aba3cbb, 0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f, 0x4de81751, 0x3830dc8e, 0x379d5862,
      0x9320f991, 0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32, 0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680,
      0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166, 0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae, 0x5bbef7dd,
      0x1b588d40, 0xccd2017f, 0x6bb4e3bb, 0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5, 0x72eacea8, 0xfa6484bb,
      0x8d6612ae, 0xbf3c6f47, 0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370, 0x740e0d8d, 0xe75b1357, 0xf8721671,
      0xaf537d5d, 0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84, 0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048,
      0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8, 0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd, 0xa08839e1,
      0x51ce794b, 0x2f32c9b7, 0xa01fbac9, 0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7, 0x1a908749, 0xd44fbd9a,
      0xd0dadecb, 0xd50ada38, 0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f, 0xf79e59b7, 0x43f5bb3a, 0xf2d519ff,
      0x27d9459c, 0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525, 0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1,
      0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442, 0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964, 0x9f1f9532,
      0xe0d392df, 0xd3a0342b, 0x8971f21e, 0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8, 0xdf359f8d, 0x9b992f2e,
      0xe60b6f47, 0x0fe3f11d, 0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f, 0x1618b166, 0xfd2c1d05, 0x848fd2c5,
      0xf6fb2299, 0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02, 0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc,
      0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614, 0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a, 0xc9aa53fd,
      0x62a80f00, 0xbb25bfe2, 0x35bdd2f6, 0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b, 0x53113ec0, 0x1640e3d3,
      0x38abbd60, 0x2547adf0, 0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060, 0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0,
      0x4cf9aa7e, 0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9, 0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f,
      0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6
    ])
  ];
  this.P = new Uint32Array([
    0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89, 0x452821e6,
    0x38d01377, 0xbe5466cf, 0x34e90c6c, 0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917, 0x9216d5d9, 0x8979fb1b
  ]);
};

function F(S, x8, i) {
  return ((S[0][x8[i + 3]] + S[1][x8[i + 2]]) ^ S[2][x8[i + 1]]) + S[3][x8[i]];
}

Blowfish.prototype.encipher = function(x, x8) {
  if (x8 === void 0) {
    x8 = new Uint8Array(x.buffer);
    if (x.byteOffset !== 0) x8 = x8.subarray(x.byteOffset);
  }
  x[0] ^= this.P[0];
  for (var i = 1; i < 16; i += 2) {
    x[1] ^= F(this.S, x8, 0) ^ this.P[i];
    x[0] ^= F(this.S, x8, 4) ^ this.P[i + 1];
  }
  var t = x[0];
  x[0] = x[1] ^ this.P[17];
  x[1] = t;
};

Blowfish.prototype.decipher = function(x) {
  var x8 = new Uint8Array(x.buffer);
  if (x.byteOffset !== 0) x8 = x8.subarray(x.byteOffset);
  x[0] ^= this.P[17];
  for (var i = 16; i > 0; i -= 2) {
    x[1] ^= F(this.S, x8, 0) ^ this.P[i];
    x[0] ^= F(this.S, x8, 4) ^ this.P[i - 1];
  }
  var t = x[0];
  x[0] = x[1] ^ this.P[0];
  x[1] = t;
};

function stream2word(data, databytes) {
  var i, temp = 0;
  for (i = 0; i < 4; i++, BLF_J++) {
    if (BLF_J >= databytes) BLF_J = 0;
    temp = (temp << 8) | data[BLF_J];
  }
  return temp;
}

Blowfish.prototype.expand0state = function(key, keybytes) {
  var i, k, d = new Uint32Array(2),
    d8 = new Uint8Array(d.buffer);

  for (i = 0, BLF_J = 0; i < 18; i++) this.P[i] ^= stream2word(key, keybytes);

  BLF_J = 0;

  for (i = 0; i < 18; i += 2) {
    this.encipher(d, d8);
    this.P[i] = d[0];
    this.P[i + 1] = d[1];
  }

  for (i = 0; i < 4; i++)
    for (k = 0; k < 256; k += 2) {
      this.encipher(d, d8);
      this.S[i][k] = d[0];
      this.S[i][k + 1] = d[1];
    }
};

Blowfish.prototype.expandstate = function(data, databytes, key, keybytes) {
  var i, k, d = new Uint32Array(2);

  for (i = 0, BLF_J = 0; i < 18; i++) this.P[i] ^= stream2word(key, keybytes);

  for (i = 0, BLF_J = 0; i < 18; i += 2) {
    d[0] ^= stream2word(data, databytes);
    d[1] ^= stream2word(data, databytes);
    this.encipher(d);
    this.P[i] = d[0];
    this.P[i + 1] = d[1];
  }

  for (i = 0; i < 4; i++)
    for (k = 0; k < 256; k += 2) {
      d[0] ^= stream2word(data, databytes);
      d[1] ^= stream2word(data, databytes);
      this.encipher(d);
      this.S[i][k] = d[0];
      this.S[i][k + 1] = d[1];
    }

  BLF_J = 0;
};

Blowfish.prototype.enc = function(data, blocks) {
  for (var i = 0; i < blocks; i++) this.encipher(data.subarray(i * 2));
};

Blowfish.prototype.dec = function(data, blocks) {
  for (var i = 0; i < blocks; i++) this.decipher(data.subarray(i * 2));
};

var BCRYPT_BLOCKS = 8,
  BCRYPT_HASHSIZE = 32;

function bcrypt_hash(sha2pass, sha2salt, out) {
  var i, state = new Blowfish(),
    cdata = new Uint32Array(BCRYPT_BLOCKS);
  var ciphertext = new Uint8Array([
    79, 120, 121, 99, 104, 114, 111, 109, 97, 116, 105, 99, 66, 108, 111, 119, 102, 105, 115, 104, 83, 119, 97, 116,
    68, 121, 110, 97, 109, 105, 116, 101
  ]);

  state.expandstate(sha2salt, 64, sha2pass, 64);
  for (i = 0; i < 64; i++) {
    state.expand0state(sha2salt, 64);
    state.expand0state(sha2pass, 64);
  }

  for (i = 0; i < BCRYPT_BLOCKS; i++) cdata[i] = stream2word(ciphertext, ciphertext.byteLength);
  for (i = 0; i < 64; i++) state.enc(cdata, cdata.byteLength / 8);

  for (i = 0; i < BCRYPT_BLOCKS; i++) {
    out[4 * i + 3] = cdata[i] >>> 24;
    out[4 * i + 2] = cdata[i] >>> 16;
    out[4 * i + 1] = cdata[i] >>> 8;
    // noinspection PointlessArithmeticExpressionJS
    out[4 * i + 0] = cdata[i];
  }
}

function bcrypt_pbkdf(pass, passlen, salt, saltlen, key, keylen, rounds) {
  var i, j, amt, stride, dest, count,
    sha2pass = new Uint8Array(64),
    sha2salt = new Uint8Array(64),
    out = new Uint8Array(BCRYPT_HASHSIZE),
    tmpout = new Uint8Array(BCRYPT_HASHSIZE),
    countsalt = new Uint8Array(saltlen + 4),
    origkeylen = keylen;

  if (rounds < 1) return -1;
  if (passlen === 0 || saltlen === 0 || keylen === 0 || keylen > out.byteLength * out.byteLength || saltlen > 1 << 20)
    return -1;

  stride = Math.floor((keylen + out.byteLength - 1) / out.byteLength);
  amt = Math.floor((keylen + stride - 1) / stride);

  for (i = 0; i < saltlen; i++) countsalt[i] = salt[i];

  crypto_hash_sha512(sha2pass, pass, passlen);

  for (count = 1; keylen > 0; count++) {
    countsalt[saltlen + 0] = count >>> 24;
    countsalt[saltlen + 1] = count >>> 16;
    countsalt[saltlen + 2] = count >>> 8;
    countsalt[saltlen + 3] = count;

    crypto_hash_sha512(sha2salt, countsalt, saltlen + 4);
    bcrypt_hash(sha2pass, sha2salt, tmpout);
    for (i = out.byteLength; i--; ) out[i] = tmpout[i];

    for (i = 1; i < rounds; i++) {
      crypto_hash_sha512(sha2salt, tmpout, tmpout.byteLength);
      bcrypt_hash(sha2pass, sha2salt, tmpout);
      for (j = 0; j < out.byteLength; j++) out[j] ^= tmpout[j];
    }

    amt = Math.min(amt, keylen);
    for (i = 0; i < amt && (dest = i * stride + (count - 1)) < origkeylen; i++) key[dest] = out[i];

    keylen -= i;
  }

  return 0;
}

module.exports = {
  BLOCKS: BCRYPT_BLOCKS,
  HASHSIZE: BCRYPT_HASHSIZE,
  hash: bcrypt_hash,
  pbkdf: bcrypt_pbkdf
};
//
},
'sshpk/lib/formats/ssh':
function(module, exports, __wpreq__) {
//
module.exports = {
  read: read,
  write: write
};

var assert = __wpreq__('assert-plus'),
  Buffer = __wpreq__('safer-buffer').Buffer,
  rfc4253 = __wpreq__('sshpk/lib/formats/rfc4253'),
  Key = __wpreq__('sshpk/lib/key'),

  SSHKEY_RE = /^([a-z0-9-]+)[ \t]+([a-zA-Z0-9+\/]+[=]*)([ \t]+([^ \t][^\n]*[\n]*)?)?$/,
  SSHKEY_RE2 = /^([a-z0-9-]+)[ \t\n]+([a-zA-Z0-9+\/][a-zA-Z0-9+\/ \t\n=]*)([^a-zA-Z0-9+\/ \t\n=].*)?$/;

function read(buf, options) {
  if (typeof buf != 'string') {
    assert.buffer(buf, 'buf');
    buf = buf.toString('ascii');
  }

  var trimmed = buf.trim().replace(/[\\\r]/g, ''),
    m = trimmed.match(SSHKEY_RE);
  m || (m = trimmed.match(SSHKEY_RE2));
  assert.ok(m, 'key must match regex');

  var type = rfc4253.algToKeyType(m[1]),
    kbuf = Buffer.from(m[2], 'base64');

  var key,
    ret = {};
  if (m[4])
    try {
      key = rfc4253.read(kbuf);
    } catch (_e) {
      m = trimmed.match(SSHKEY_RE2);
      assert.ok(m, 'key must match regex');
      kbuf = Buffer.from(m[2], 'base64');
      key = rfc4253.readInternal(ret, 'public', kbuf);
    }
  else key = rfc4253.readInternal(ret, 'public', kbuf);

  assert.strictEqual(type, key.type);

  if (m[4] && m[4].length > 0) key.comment = m[4];
  else if (ret.consumed) {
    var data = m[2] + (m[3] ? m[3] : ''),
      realOffset = Math.ceil(ret.consumed / 3) * 4;
    data = data.slice(0, realOffset - 2).replace(/[^a-zA-Z0-9+\/=]/g, '') + data.slice(realOffset - 2);

    ret.consumed % 3 > 0 && data.slice(realOffset - 1, realOffset) !== '=' && realOffset--;
    while (data.slice(realOffset, realOffset + 1) === '=') realOffset++;

    var trailer = data.slice(realOffset);
    if ((trailer = trailer.replace(/[\r\n]/g, ' ').replace(/^\s+/, '')).match(/^[a-zA-Z0-9]/)) key.comment = trailer;
  }

  return key;
}

function write(key, options) {
  assert.object(key);
  if (!Key.isKey(key)) throw new Error('Must be a public key');

  var parts = [],
    alg = rfc4253.keyTypeToAlg(key);
  parts.push(alg);

  var buf = rfc4253.write(key);
  parts.push(buf.toString('base64'));

  key.comment && parts.push(key.comment);

  return Buffer.from(parts.join(' '));
}
//
},
'sshpk/lib/formats/dnssec':
function(module, exports, __wpreq__) {
//
module.exports = {
  read: read,
  write: write
};

var assert = __wpreq__('assert-plus'),
  Buffer = __wpreq__('safer-buffer').Buffer,
  Key = __wpreq__('sshpk/lib/key'),
  PrivateKey = __wpreq__('sshpk/lib/private-key'),
  utils = __wpreq__('sshpk/lib/utils');

var supportedAlgos = {
  'rsa-sha1': 5,
  'rsa-sha256': 8,
  'rsa-sha512': 10,
  'ecdsa-p256-sha256': 13,
  'ecdsa-p384-sha384': 14
};

var supportedAlgosById = {};
Object.keys(supportedAlgos).forEach(function(k) {
  supportedAlgosById[supportedAlgos[k]] = k.toUpperCase();
});

function read(buf, options) {
  if (typeof buf != 'string') {
    assert.buffer(buf, 'buf');
    buf = buf.toString('ascii');
  }
  var lines = buf.split('\n');
  if (lines[0].match(/^Private-key-format: v1/)) {
    var algElems = lines[1].split(' '),
      algoNum = parseInt(algElems[1], 10),
      algoName = algElems[2];
    if (!supportedAlgosById[algoNum]) throw new Error('Unsupported algorithm: ' + algoName);
    return readDNSSECPrivateKey(algoNum, lines.slice(2));
  }

  var line = 0;
  while (lines[line].match(/^;/)) line++;
  if ((lines[line].match(/\. IN KEY /) || lines[line].match(/\. IN DNSKEY /)) && lines[line + 1].length === 0)
    return readRFC3110(lines[line]);

  throw new Error('Cannot parse dnssec key');
}

function readRFC3110(keyString) {
  var elems = keyString.split(' '),
    algorithm = parseInt(elems[5], 10);
  if (!supportedAlgosById[algorithm]) throw new Error('Unsupported algorithm: ' + algorithm);
  var base64key = elems.slice(6, elems.length).join(),
    keyBuffer = Buffer.from(base64key, 'base64');
  if (supportedAlgosById[algorithm].match(/^RSA-/)) {
    var publicExponentLen = keyBuffer.readUInt8(0);
    if (publicExponentLen != 3 && publicExponentLen != 1)
      throw new Error('Cannot parse dnssec key: unsupported exponent length');

    var publicExponent = keyBuffer.slice(1, publicExponentLen + 1);
    publicExponent = utils.mpNormalize(publicExponent);
    var modulus = keyBuffer.slice(1 + publicExponentLen);
    modulus = utils.mpNormalize(modulus);
    var rsaKey = {type: 'rsa', parts: []};
    rsaKey.parts.push({name: 'e', data: publicExponent});
    rsaKey.parts.push({name: 'n', data: modulus});
    return new Key(rsaKey);
  }
  if (supportedAlgosById[algorithm] === 'ECDSA-P384-SHA384' || supportedAlgosById[algorithm] === 'ECDSA-P256-SHA256') {
    var curve = 'nistp384',
      size = 384;
    if (supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {
      curve = 'nistp256';
      size = 256;
    }

    var ecdsaKey = {
      type: 'ecdsa',
      curve: curve,
      size: size,
      parts: [
        {name: 'curve', data: Buffer.from(curve)},
        {name: 'Q', data: utils.ecNormalize(keyBuffer)}
      ]
    };
    return new Key(ecdsaKey);
  }
  throw new Error('Unsupported algorithm: ' + supportedAlgosById[algorithm]);
}

function elementToBuf(e) {
  return Buffer.from(e.split(' ')[1], 'base64');
}

function readDNSSECRSAPrivateKey(elements) {
  var rsaParams = {};
  elements.forEach(function(element) {
    if (element.split(' ')[0] === 'Modulus:') rsaParams.n = elementToBuf(element);
    else if (element.split(' ')[0] === 'PublicExponent:') rsaParams.e = elementToBuf(element);
    else if (element.split(' ')[0] === 'PrivateExponent:') rsaParams.d = elementToBuf(element);
    else if (element.split(' ')[0] === 'Prime1:') rsaParams.p = elementToBuf(element);
    else if (element.split(' ')[0] === 'Prime2:') rsaParams.q = elementToBuf(element);
    else if (element.split(' ')[0] === 'Exponent1:') rsaParams.dmodp = elementToBuf(element);
    else if (element.split(' ')[0] === 'Exponent2:') rsaParams.dmodq = elementToBuf(element);
    else if (element.split(' ')[0] === 'Coefficient:') rsaParams.iqmp = elementToBuf(element);
  });
  var key = {
    type: 'rsa',
    parts: [
      {name: 'e', data: utils.mpNormalize(rsaParams.e)},
      {name: 'n', data: utils.mpNormalize(rsaParams.n)},
      {name: 'd', data: utils.mpNormalize(rsaParams.d)},
      {name: 'p', data: utils.mpNormalize(rsaParams.p)},
      {name: 'q', data: utils.mpNormalize(rsaParams.q)},
      {name: 'dmodp', data: utils.mpNormalize(rsaParams.dmodp)},
      {name: 'dmodq', data: utils.mpNormalize(rsaParams.dmodq)},
      {name: 'iqmp', data: utils.mpNormalize(rsaParams.iqmp)}
    ]
  };
  return new PrivateKey(key);
}

function readDNSSECPrivateKey(alg, elements) {
  if (supportedAlgosById[alg].match(/^RSA-/)) return readDNSSECRSAPrivateKey(elements);

  if (supportedAlgosById[alg] === 'ECDSA-P384-SHA384' || supportedAlgosById[alg] === 'ECDSA-P256-SHA256') {
    var d = Buffer.from(elements[0].split(' ')[1], 'base64'),
      curve = 'nistp384',
      size = 384;
    if (supportedAlgosById[alg] === 'ECDSA-P256-SHA256') {
      curve = 'nistp256';
      size = 256;
    }
    var Q = utils.publicFromPrivateECDSA(curve, d).part.Q.data;
    var ecdsaKey = {
      type: 'ecdsa',
      curve: curve,
      size: size,
      parts: [
        {name: 'curve', data: Buffer.from(curve)},
        {name: 'd', data: d},
        {name: 'Q', data: Q}
      ]
    };
    return new PrivateKey(ecdsaKey);
  }
  throw new Error('Unsupported algorithm: ' + supportedAlgosById[alg]);
}

function dnssecTimestamp(date) {
  var timestampStr = date.getFullYear() + '' + (date.getMonth() + 1) + date.getUTCDate();
  return (timestampStr += '' + date.getUTCHours() + date.getUTCMinutes()) + date.getUTCSeconds();
}

function rsaAlgFromOptions(opts) {
  if (!opts || !opts.hashAlgo || opts.hashAlgo === 'sha1') return '5 (RSASHA1)';
  if (opts.hashAlgo === 'sha256') return '8 (RSASHA256)';
  if (opts.hashAlgo === 'sha512') return '10 (RSASHA512)';

  throw new Error('Unknown or unsupported hash: ' + opts.hashAlgo);
}

function writeRSA(key, options) {
  (key.part.dmodp && key.part.dmodq) || utils.addRSAMissing(key);

  var out = '';
  out += 'Private-key-format: v1.3\n';
  out += 'Algorithm: ' + rsaAlgFromOptions(options) + '\n';
  out += 'Modulus: ' + utils.mpDenormalize(key.part.n.data).toString('base64') + '\n';
  out += 'PublicExponent: ' + utils.mpDenormalize(key.part.e.data).toString('base64') + '\n';
  out += 'PrivateExponent: ' + utils.mpDenormalize(key.part.d.data).toString('base64') + '\n';
  out += 'Prime1: ' + utils.mpDenormalize(key.part.p.data).toString('base64') + '\n';
  out += 'Prime2: ' + utils.mpDenormalize(key.part.q.data).toString('base64') + '\n';
  out += 'Exponent1: ' + utils.mpDenormalize(key.part.dmodp.data).toString('base64') + '\n';
  out += 'Exponent2: ' + utils.mpDenormalize(key.part.dmodq.data).toString('base64') + '\n';
  out += 'Coefficient: ' + utils.mpDenormalize(key.part.iqmp.data).toString('base64') + '\n';
  var timestamp = new Date();
  out += 'Created: ' + dnssecTimestamp(timestamp) + '\n';
  out += 'Publish: ' + dnssecTimestamp(timestamp) + '\n';
  out += 'Activate: ' + dnssecTimestamp(timestamp) + '\n';
  return Buffer.from(out, 'ascii');
}

function writeECDSA(key, options) {
  var out = '';
  out += 'Private-key-format: v1.3\n';

  if (key.curve === 'nistp256') out += 'Algorithm: 13 (ECDSAP256SHA256)\n';
  else if (key.curve === 'nistp384') out += 'Algorithm: 14 (ECDSAP384SHA384)\n';
  else throw new Error('Unsupported curve');

  out += 'PrivateKey: ' + key.part.d.data.toString('base64') + '\n';

  var timestamp = new Date();
  out += 'Created: ' + dnssecTimestamp(timestamp) + '\n';
  out += 'Publish: ' + dnssecTimestamp(timestamp) + '\n';
  out += 'Activate: ' + dnssecTimestamp(timestamp) + '\n';

  return Buffer.from(out, 'ascii');
}

function write(key, options) {
  if (PrivateKey.isPrivateKey(key)) {
    if (key.type === 'rsa') return writeRSA(key, options);
    if (key.type === 'ecdsa') return writeECDSA(key, options);

    throw new Error('Unsupported algorithm: ' + key.type);
  }

  throw Key.isKey(key)
    ? new Error('Format "dnssec" only supports writing private keys')
    : new Error('key is not a Key or PrivateKey');
}
//
},
'sshpk/lib/certificate':
function(module, exports, __wpreq__) {
//
module.exports = Certificate;

var assert = __wpreq__('assert-plus'),
  Buffer = __wpreq__('safer-buffer').Buffer,
  algs = __wpreq__('sshpk/lib/algs'),
  crypto = __wpreq__('crypto'),
  Fingerprint = __wpreq__('sshpk/lib/fingerprint'),
  errs = __wpreq__('sshpk/lib/errors'),
  utils = __wpreq__('sshpk/lib/utils'),
  Key = __wpreq__('sshpk/lib/key'),
  PrivateKey = __wpreq__('sshpk/lib/private-key'),
  Identity = __wpreq__('sshpk/lib/identity'),

  formats = {};
formats.openssh = __wpreq__('sshpk/lib/formats/openssh-cert');
formats.x509 = __wpreq__('sshpk/lib/formats/x509');
formats.pem = __wpreq__('sshpk/lib/formats/x509-pem');

var CertificateParseError = errs.CertificateParseError,
  InvalidAlgorithmError = errs.InvalidAlgorithmError;

function Certificate(opts) {
  assert.object(opts, 'options');
  assert.arrayOfObject(opts.subjects, 'options.subjects');
  utils.assertCompatible(opts.subjects[0], Identity, [1, 0], 'options.subjects');
  utils.assertCompatible(opts.subjectKey, Key, [1, 0], 'options.subjectKey');
  utils.assertCompatible(opts.issuer, Identity, [1, 0], 'options.issuer');
  opts.issuerKey === void 0 || utils.assertCompatible(opts.issuerKey, Key, [1, 0], 'options.issuerKey');

  assert.object(opts.signatures, 'options.signatures');
  assert.buffer(opts.serial, 'options.serial');
  assert.date(opts.validFrom, 'options.validFrom');
  assert.date(opts.validUntil, 'optons.validUntil');

  assert.optionalArrayOfString(opts.purposes, 'options.purposes');

  this._hashCache = {};

  this.subjects = opts.subjects;
  this.issuer = opts.issuer;
  this.subjectKey = opts.subjectKey;
  this.issuerKey = opts.issuerKey;
  this.signatures = opts.signatures;
  this.serial = opts.serial;
  this.validFrom = opts.validFrom;
  this.validUntil = opts.validUntil;
  this.purposes = opts.purposes;
}

Certificate.formats = formats;

Certificate.prototype.toBuffer = function(format, options) {
  if (format === void 0) format = 'x509';
  assert.string(format, 'format');
  assert.object(formats[format], 'formats[format]');
  assert.optionalObject(options, 'options');

  return formats[format].write(this, options);
};

Certificate.prototype.toString = function(format, options) {
  if (format === void 0) format = 'pem';
  return this.toBuffer(format, options).toString();
};

Certificate.prototype.fingerprint = function(algo) {
  if (algo === void 0) algo = 'sha256';
  assert.string(algo, 'algorithm');
  var opts = {type: 'certificate', hash: this.hash(algo), algorithm: algo};
  return new Fingerprint(opts);
};

Certificate.prototype.hash = function(algo) {
  assert.string(algo, 'algorithm');
  algo = algo.toLowerCase();
  if (algs.hashAlgs[algo] === void 0) throw new InvalidAlgorithmError(algo);

  if (this._hashCache[algo]) return this._hashCache[algo];

  var hash = crypto.createHash(algo).update(this.toBuffer('x509')).digest();
  this._hashCache[algo] = hash;
  return hash;
};

Certificate.prototype.isExpired = function(when) {
  if (when === void 0) when = new Date();
  return !(when.getTime() >= this.validFrom.getTime() && when.getTime() < this.validUntil.getTime());
};

Certificate.prototype.isSignedBy = function(issuerCert) {
  utils.assertCompatible(issuerCert, Certificate, [1, 0], 'issuer');

  return (
    !!this.issuer.equals(issuerCert.subjects[0]) &&
    !(this.issuer.purposes && this.issuer.purposes.length > 0 && this.issuer.purposes.indexOf('ca') < 0) &&
    this.isSignedByKey(issuerCert.subjectKey)
  );
};

Certificate.prototype.isSignedByKey = function(issuerKey) {
  utils.assertCompatible(issuerKey, Key, [1, 2], 'issuerKey');

  if (this.issuerKey !== void 0) return this.issuerKey.fingerprint('sha512').matches(issuerKey);

  var fmt = Object.keys(this.signatures)[0],
    valid = formats[fmt].verify(this, issuerKey);
  if (valid) this.issuerKey = issuerKey;
  return valid;
};

Certificate.prototype.signWith = function(key) {
  utils.assertCompatible(key, PrivateKey, [1, 2], 'key');
  var didOne = false;
  for (var fmts = Object.keys(formats), i = 0; i < fmts.length; ++i)
    if (fmts[i] !== 'pem' && formats[fmts[i]].sign(this, key) === true) didOne = true;

  if (!didOne) throw new Error('Failed to sign the certificate for any available certificate formats');
};

Certificate.createSelfSigned = function(subjectOrSubjects, key, options) {
  var subjects = Array.isArray(subjectOrSubjects) ? subjectOrSubjects : [subjectOrSubjects];

  assert.arrayOfObject(subjects);
  subjects.forEach(function(subject) {
    utils.assertCompatible(subject, Identity, [1, 0], 'subject');
  });

  utils.assertCompatible(key, PrivateKey, [1, 2], 'private key');

  assert.optionalObject(options, 'options');
  if (options === void 0) options = {};
  assert.optionalObject(options.validFrom, 'options.validFrom');
  assert.optionalObject(options.validUntil, 'options.validUntil');
  var validFrom = options.validFrom,
    validUntil = options.validUntil;
  if (validFrom === void 0) validFrom = new Date();
  if (validUntil === void 0) {
    assert.optionalNumber(options.lifetime, 'options.lifetime');
    var lifetime = options.lifetime;
    if (lifetime === void 0) lifetime = 315360000;
    (validUntil = new Date()).setTime(validUntil.getTime() + lifetime * 1000);
  }
  assert.optionalBuffer(options.serial, 'options.serial');
  var serial = options.serial;
  if (serial === void 0) serial = Buffer.from('0000000000000001', 'hex');

  var purposes = options.purposes;
  if (purposes === void 0) purposes = [];

  purposes.indexOf('signature') < 0 && purposes.push('signature');

  purposes.indexOf('ca') < 0 && purposes.push('ca');
  purposes.indexOf('crl') < 0 && purposes.push('crl');

  if (purposes.length <= 3) {
    var hostSubjects = subjects.filter(function(subject) {
      return subject.type === 'host';
    });
    var userSubjects = subjects.filter(function(subject) {
      return subject.type === 'user';
    });
    hostSubjects.length > 0 && purposes.indexOf('serverAuth') < 0 && purposes.push('serverAuth');

    userSubjects.length > 0 && purposes.indexOf('clientAuth') < 0 && purposes.push('clientAuth');

    if (userSubjects.length > 0 || hostSubjects.length > 0) {
      purposes.indexOf('keyAgreement') < 0 && purposes.push('keyAgreement');
      key.type === 'rsa' && purposes.indexOf('encryption') < 0 && purposes.push('encryption');
    }
  }

  var cert = new Certificate({
    subjects: subjects,
    issuer: subjects[0],
    subjectKey: key.toPublic(),
    issuerKey: key.toPublic(),
    signatures: {},
    serial: serial,
    validFrom: validFrom,
    validUntil: validUntil,
    purposes: purposes
  });
  cert.signWith(key);

  return cert;
};

Certificate.create = function(subjectOrSubjects, key, issuer, issuerKey, options) {
  var subjects = Array.isArray(subjectOrSubjects) ? subjectOrSubjects : [subjectOrSubjects];

  assert.arrayOfObject(subjects);
  subjects.forEach(function(subject) {
    utils.assertCompatible(subject, Identity, [1, 0], 'subject');
  });

  utils.assertCompatible(key, Key, [1, 0], 'key');
  if (PrivateKey.isPrivateKey(key)) key = key.toPublic();
  utils.assertCompatible(issuer, Identity, [1, 0], 'issuer');
  utils.assertCompatible(issuerKey, PrivateKey, [1, 2], 'issuer key');

  assert.optionalObject(options, 'options');
  if (options === void 0) options = {};
  assert.optionalObject(options.validFrom, 'options.validFrom');
  assert.optionalObject(options.validUntil, 'options.validUntil');
  var validFrom = options.validFrom,
    validUntil = options.validUntil;
  if (validFrom === void 0) validFrom = new Date();
  if (validUntil === void 0) {
    assert.optionalNumber(options.lifetime, 'options.lifetime');
    var lifetime = options.lifetime;
    if (lifetime === void 0) lifetime = 315360000;
    (validUntil = new Date()).setTime(validUntil.getTime() + lifetime * 1000);
  }
  assert.optionalBuffer(options.serial, 'options.serial');
  var serial = options.serial;
  if (serial === void 0) serial = Buffer.from('0000000000000001', 'hex');

  var purposes = options.purposes;
  if (purposes === void 0) purposes = [];

  purposes.indexOf('signature') < 0 && purposes.push('signature');

  if (options.ca === true) {
    purposes.indexOf('ca') < 0 && purposes.push('ca');
    purposes.indexOf('crl') < 0 && purposes.push('crl');
  }

  var hostSubjects = subjects.filter(function(subject) {
    return subject.type === 'host';
  });
  var userSubjects = subjects.filter(function(subject) {
    return subject.type === 'user';
  });
  hostSubjects.length > 0 && purposes.indexOf('serverAuth') < 0 && purposes.push('serverAuth');

  userSubjects.length > 0 && purposes.indexOf('clientAuth') < 0 && purposes.push('clientAuth');

  if (userSubjects.length > 0 || hostSubjects.length > 0) {
    purposes.indexOf('keyAgreement') < 0 && purposes.push('keyAgreement');
    key.type === 'rsa' && purposes.indexOf('encryption') < 0 && purposes.push('encryption');
  }

  var cert = new Certificate({
    subjects: subjects,
    issuer: issuer,
    subjectKey: key,
    issuerKey: issuerKey.toPublic(),
    signatures: {},
    serial: serial,
    validFrom: validFrom,
    validUntil: validUntil,
    purposes: purposes
  });
  cert.signWith(issuerKey);

  return cert;
};

Certificate.parse = function(data, format, options) {
  typeof data == 'string' || assert.buffer(data, 'data');
  if (format === void 0) format = 'auto';
  assert.string(format, 'format');
  if (typeof options == 'string') options = {filename: options};
  assert.optionalObject(options, 'options');
  if (options === void 0) options = {};
  assert.optionalString(options.filename, 'options.filename');
  if (options.filename === void 0) options.filename = '(unnamed)';

  assert.object(formats[format], 'formats[format]');

  try {
    return formats[format].read(data, options);
  } catch (e) {
    throw new CertificateParseError(options.filename, format, e);
  }
};

Certificate.isCertificate = function(obj, ver) {
  return utils.isCompatible(obj, Certificate, ver);
};

Certificate.prototype._sshpkApiVersion = [1, 0];

Certificate._oldVersionDetect = function(obj) {
  return [1, 0];
};
//
},
'sshpk/lib/identity':
function(module, exports, __wpreq__) {
//
module.exports = Identity;

var assert = __wpreq__('assert-plus'),
  utils = __wpreq__('sshpk/lib/utils'),
  asn1 = __wpreq__('asn1'),
  Buffer = __wpreq__('safer-buffer').Buffer,

  DNS_NAME_RE = /^([*]|[a-z0-9][a-z0-9\-]{0,62})(?:\.([*]|[a-z0-9][a-z0-9\-]{0,62}))*$/i;

var oids = {
  cn: '2.5.4.3',
  o: '2.5.4.10',
  ou: '2.5.4.11',
  l: '2.5.4.7',
  s: '2.5.4.8',
  c: '2.5.4.6',
  sn: '2.5.4.4',
  dc: '0.9.2342.19200300.100.1.25',
  uid: '0.9.2342.19200300.100.1.1',
  mail: '0.9.2342.19200300.100.1.3'
};

var unoids = {};
Object.keys(oids).forEach(function(k) {
  unoids[oids[k]] = k;
});

function Identity(opts) {
  var self = this;
  assert.object(opts, 'options');
  assert.arrayOfObject(opts.components, 'options.components');
  this.components = opts.components;
  this.componentLookup = {};
  this.components.forEach(function(c) {
    if (c.name && !c.oid) c.oid = oids[c.name];
    if (c.oid && !c.name) c.name = unoids[c.oid];
    if (self.componentLookup[c.name] === void 0) self.componentLookup[c.name] = [];
    self.componentLookup[c.name].push(c);
  });
  if (this.componentLookup.cn && this.componentLookup.cn.length > 0) this.cn = this.componentLookup.cn[0].value;

  assert.optionalString(opts.type, 'options.type');
  if (opts.type === void 0)
    if (
      this.components.length === 1 &&
      this.componentLookup.cn &&
      this.componentLookup.cn.length === 1 &&
      this.componentLookup.cn[0].value.match(DNS_NAME_RE)
    ) {
      this.type = 'host';
      this.hostname = this.componentLookup.cn[0].value;
    } else if (this.componentLookup.dc && this.components.length === this.componentLookup.dc.length) {
      this.type = 'host';
      this.hostname = this.componentLookup.dc.map(function(c) {
        return c.value;
      }).join('.');
    } else if (this.componentLookup.uid && this.components.length === this.componentLookup.uid.length) {
      this.type = 'user';
      this.uid = this.componentLookup.uid[0].value;
    } else if (
      this.componentLookup.cn &&
      this.componentLookup.cn.length === 1 &&
      this.componentLookup.cn[0].value.match(DNS_NAME_RE)
    ) {
      this.type = 'host';
      this.hostname = this.componentLookup.cn[0].value;
    } else if (this.componentLookup.uid && this.componentLookup.uid.length === 1) {
      this.type = 'user';
      this.uid = this.componentLookup.uid[0].value;
    } else if (this.componentLookup.mail && this.componentLookup.mail.length === 1) {
      this.type = 'email';
      this.email = this.componentLookup.mail[0].value;
    } else if (this.componentLookup.cn && this.componentLookup.cn.length === 1) {
      this.type = 'user';
      this.uid = this.componentLookup.cn[0].value;
    } else this.type = 'unknown';
  else {
    this.type = opts.type;
    if (this.type === 'host') this.hostname = opts.hostname;
    else if (this.type === 'user') this.uid = opts.uid;
    else if (this.type === 'email') this.email = opts.email;
    else throw new Error('Unknown type ' + this.type);
  }
}

Identity.prototype.toString = function() {
  return this.components.map(function(c) {
    return c.name.toUpperCase() + '=' + c.value;
  }).join(', ');
};

var NOT_PRINTABLE = /[^a-zA-Z0-9 '(),+.\/:=?-]/,
  NOT_IA5 = /[^\x00-\x7f]/;

Identity.prototype.toAsn1 = function(der, tag) {
  der.startSequence(tag);
  this.components.forEach(function(c) {
    der.startSequence(asn1.Ber.Constructor | asn1.Ber.Set);
    der.startSequence();
    der.writeOID(c.oid);
    if (c.asn1type === asn1.Ber.Utf8String || c.value.match(NOT_IA5)) {
      var v = Buffer.from(c.value, 'utf8');
      der.writeBuffer(v, asn1.Ber.Utf8String);
    } else if (c.asn1type === asn1.Ber.IA5String || c.value.match(NOT_PRINTABLE))
      der.writeString(c.value, asn1.Ber.IA5String);
    else {
      var type = asn1.Ber.PrintableString;
      if (c.asn1type !== void 0) type = c.asn1type;
      der.writeString(c.value, type);
    }
    der.endSequence();
    der.endSequence();
  });
  der.endSequence();
};

function globMatch(a, b) {
  if (a === '**' || b === '**') return true;
  var aParts = a.split('.'),
    bParts = b.split('.');
  if (aParts.length !== bParts.length) return false;
  for (var i = 0; i < aParts.length; ++i)
    if (aParts[i] !== '*' && bParts[i] !== '*' && aParts[i] !== bParts[i]) return false;

  return true;
}

Identity.prototype.equals = function(other) {
  if (!Identity.isIdentity(other, [1, 0])) return false;
  if (other.components.length !== this.components.length) return false;
  for (var i = 0; i < this.components.length; ++i) {
    if (this.components[i].oid !== other.components[i].oid) return false;
    if (!globMatch(this.components[i].value, other.components[i].value)) return false;
  }
  return true;
};

Identity.forHost = function(hostname) {
  assert.string(hostname, 'hostname');
  return new Identity({type: 'host', hostname: hostname, components: [{name: 'cn', value: hostname}]});
};

Identity.forUser = function(uid) {
  assert.string(uid, 'uid');
  return new Identity({type: 'user', uid: uid, components: [{name: 'uid', value: uid}]});
};

Identity.forEmail = function(email) {
  assert.string(email, 'email');
  return new Identity({type: 'email', email: email, components: [{name: 'mail', value: email}]});
};

Identity.parseDN = function(dn) {
  assert.string(dn, 'dn');
  return new Identity({
    components: dn.split(',').map(function(c) {
      var eqPos = (c = c.trim()).indexOf('=');
      return {name: c.slice(0, eqPos).toLowerCase(), value: c.slice(eqPos + 1)};
    })
  });
};

Identity.parseAsn1 = function(der, top) {
  var components = [];
  der.readSequence(top);
  var end = der.offset + der.length;
  while (der.offset < end) {
    der.readSequence(asn1.Ber.Constructor | asn1.Ber.Set);
    var after = der.offset + der.length;
    der.readSequence();
    var value,
      oid = der.readOID(),
      type = der.peek();
    switch (type) {
    case asn1.Ber.PrintableString:
    case asn1.Ber.IA5String:
    case asn1.Ber.OctetString:
    case asn1.Ber.T61String:
      value = der.readString(type);
      break;
    case asn1.Ber.Utf8String:
      value = (value = der.readString(type, true)).toString('utf8');
      break;
    case asn1.Ber.CharacterString:
    case asn1.Ber.BMPString:
      value = (value = der.readString(type, true)).toString('utf16le');
      break;
    default:
      throw new Error('Unknown asn1 type ' + type);
    }
    components.push({oid: oid, asn1type: type, value: value});
    der._offset = after;
  }
  der._offset = end;
  return new Identity({components: components});
};

Identity.isIdentity = function(obj, ver) {
  return utils.isCompatible(obj, Identity, ver);
};

Identity.prototype._sshpkApiVersion = [1, 0];

Identity._oldVersionDetect = function(obj) {
  return [1, 0];
};
//
},
'sshpk/lib/formats/openssh-cert':
function(module, exports, __wpreq__) {
//
module.exports = {
  read: read,
  verify: verify,
  sign: sign,
  signAsync: signAsync,
  write: write,

  fromBuffer: fromBuffer,
  toBuffer: toBuffer
};

var assert = __wpreq__('assert-plus'),
  SSHBuffer = __wpreq__('sshpk/lib/ssh-buffer'),
  crypto = __wpreq__('crypto'),
  Buffer = __wpreq__('safer-buffer').Buffer,
  algs = __wpreq__('sshpk/lib/algs'),
  Key = __wpreq__('sshpk/lib/key'),
  Identity = __wpreq__('sshpk/lib/identity'),
  rfc4253 = __wpreq__('sshpk/lib/formats/rfc4253'),
  Signature = __wpreq__('sshpk/lib/signature'),
  utils = __wpreq__('sshpk/lib/utils'),
  Certificate = __wpreq__('sshpk/lib/certificate');

function verify(cert, key) {
  return false;
}

var TYPES = {user: 1, host: 2};
Object.keys(TYPES).forEach(function(k) { TYPES[TYPES[k]] = k; });

var ECDSA_ALGO = /^ecdsa-sha2-([^@-]+)-cert-v01@openssh.com$/;

/**
 * @param {(Buffer|*)} buf
 * @param {*} [options]
 */
function read(buf, options) {
  if (Buffer.isBuffer(buf)) buf = buf.toString('ascii');
  var parts = buf.trim().split(/[ \t\n]+/g);
  if (parts.length < 2 || parts.length > 3) throw new Error('Not a valid SSH certificate line');

  var algo = parts[0],
    data = parts[1];

  return fromBuffer(Buffer.from(data, 'base64'), algo);
}

function fromBuffer(data, algo, partial) {
  var sshbuf = new SSHBuffer({buffer: data}),
    innerAlgo = sshbuf.readString();
  if (algo !== void 0 && innerAlgo !== algo) throw new Error('SSH certificate algorithm mismatch');
  if (algo === void 0) algo = innerAlgo;

  var cert = {signatures: {}};
  cert.signatures.openssh = {};

  cert.signatures.openssh.nonce = sshbuf.readBuffer();

  var key = {},
    parts = (key.parts = []);
  key.type = getAlg(algo);

  for (var partCount = algs.info[key.type].parts.length; parts.length < partCount; ) parts.push(sshbuf.readPart());
  assert.ok(parts.length >= 1, 'key must have at least one part');

  var algInfo = algs.info[key.type];
  if (key.type === 'ecdsa') {
    var res = ECDSA_ALGO.exec(algo);
    assert.ok(res !== null);
    assert.strictEqual(res[1], parts[0].data.toString());
  }

  for (var i = 0; i < algInfo.parts.length; ++i) {
    parts[i].name = algInfo.parts[i];
    if (parts[i].name !== 'curve' && algInfo.normalize !== false) {
      var p = parts[i];
      p.data = utils.mpNormalize(p.data);
    }
  }

  cert.subjectKey = new Key(key);

  cert.serial = sshbuf.readInt64();

  var type = TYPES[sshbuf.readInt()];
  assert.string(type, 'valid cert type');

  cert.signatures.openssh.keyId = sshbuf.readString();

  var principals = [];
  for (var pbuf = sshbuf.readBuffer(), psshbuf = new SSHBuffer({buffer: pbuf}); !psshbuf.atEnd(); )
    principals.push(psshbuf.readString());
  if (principals.length === 0) principals = ['*'];

  cert.subjects = principals.map(function(pr) {
    if (type === 'user') return Identity.forUser(pr);
    if (type === 'host') return Identity.forHost(pr);
    throw new Error('Unknown identity type ' + type);
  });

  cert.validFrom = int64ToDate(sshbuf.readInt64());
  cert.validUntil = int64ToDate(sshbuf.readInt64());

  cert.signatures.openssh.critical = sshbuf.readBuffer();
  cert.signatures.openssh.exts = sshbuf.readBuffer();

  sshbuf.readBuffer();

  var signingKeyBuf = sshbuf.readBuffer();
  cert.issuerKey = rfc4253.read(signingKeyBuf);

  cert.issuer = Identity.forHost('**');

  var sigBuf = sshbuf.readBuffer();
  cert.signatures.openssh.signature = Signature.parse(sigBuf, cert.issuerKey.type, 'ssh');

  if (partial !== void 0) {
    partial.remainder = sshbuf.remainder();
    partial.consumed = sshbuf._offset;
  }

  return new Certificate(cert);
}

function int64ToDate(buf) {
  var i = buf.readUInt32BE(0) * 4294967296;
  i += buf.readUInt32BE(4);
  var d = new Date();
  d.setTime(i * 1000);
  d.sourceInt64 = buf;
  return d;
}

function dateToInt64(date) {
  if (date.sourceInt64 !== void 0) return date.sourceInt64;
  var i = Math.round(date.getTime() / 1000),
    upper = Math.floor(i / 4294967296),
    lower = Math.floor(i % 4294967296),
    buf = Buffer.alloc(8);
  buf.writeUInt32BE(upper, 0);
  buf.writeUInt32BE(lower, 4);
  return buf;
}

function sign(cert, key) {
  if (cert.signatures.openssh === void 0) cert.signatures.openssh = {};
  try {
    var blob = toBuffer(cert, true);
  } catch (_e) {
    delete cert.signatures.openssh;
    return false;
  }
  var sig = cert.signatures.openssh,
    hashAlgo = void 0;
  if (key.type === 'rsa' || key.type === 'dsa') hashAlgo = 'sha1';
  var signer = key.createSign(hashAlgo);
  signer.write(blob);
  sig.signature = signer.sign();
  return true;
}

function signAsync(cert, signer, done) {
  if (cert.signatures.openssh === void 0) cert.signatures.openssh = {};
  try {
    var blob = toBuffer(cert, true);
  } catch (e) {
    delete cert.signatures.openssh;
    done(e);
    return;
  }
  var sig = cert.signatures.openssh;

  signer(blob, function(err, signature) {
    if (err) {
      done(err);
      return;
    }
    try {
      signature.toBuffer('ssh');
    } catch (e) {
      done(e);
      return;
    }
    sig.signature = signature;
    done();
  });
}

function write(cert, options) {
  if (options === void 0) options = {};

  var blob = toBuffer(cert),
    out = getCertType(cert.subjectKey) + ' ' + blob.toString('base64');
  if (options.comment) out = out + ' ' + options.comment;
  return out;
}

/** @returns {Buffer} */
function toBuffer(cert, noSig) {
  assert.object(cert.signatures.openssh, 'signature for openssh format');
  var sig = cert.signatures.openssh;

  if (sig.nonce === void 0) sig.nonce = crypto.randomBytes(16);
  var buf = new SSHBuffer({});
  buf.writeString(getCertType(cert.subjectKey));
  buf.writeBuffer(sig.nonce);

  var key = cert.subjectKey;
  algs.info[key.type].parts.forEach(function(part) {
    buf.writePart(key.part[part]);
  });

  buf.writeInt64(cert.serial);

  var type = cert.subjects[0].type;
  assert.notStrictEqual(type, 'unknown');
  cert.subjects.forEach(function(id) {
    assert.strictEqual(id.type, type);
  });
  type = TYPES[type];
  buf.writeInt(type);

  if (sig.keyId === void 0)
    sig.keyId = cert.subjects[0].type + '_' + (cert.subjects[0].uid || cert.subjects[0].hostname);

  buf.writeString(sig.keyId);

  var sub = new SSHBuffer({});
  cert.subjects.forEach(function(id) {
    type === TYPES.host ? sub.writeString(id.hostname) : type !== TYPES.user || sub.writeString(id.uid);
  });
  buf.writeBuffer(sub.toBuffer());

  buf.writeInt64(dateToInt64(cert.validFrom));
  buf.writeInt64(dateToInt64(cert.validUntil));

  if (sig.critical === void 0) sig.critical = Buffer.alloc(0);
  buf.writeBuffer(sig.critical);

  if (sig.exts === void 0) sig.exts = Buffer.alloc(0);
  buf.writeBuffer(sig.exts);

  buf.writeBuffer(Buffer.alloc(0));

  sub = rfc4253.write(cert.issuerKey);
  buf.writeBuffer(sub);

  noSig || buf.writeBuffer(sig.signature.toBuffer('ssh'));

  return buf.toBuffer();
}

function getAlg(certType) {
  if (certType === 'ssh-rsa-cert-v01@openssh.com') return 'rsa';
  if (certType === 'ssh-dss-cert-v01@openssh.com') return 'dsa';
  if (certType.match(ECDSA_ALGO)) return 'ecdsa';
  if (certType === 'ssh-ed25519-cert-v01@openssh.com') return 'ed25519';
  throw new Error('Unsupported cert type ' + certType);
}

function getCertType(key) {
  if (key.type === 'rsa') return 'ssh-rsa-cert-v01@openssh.com';
  if (key.type === 'dsa') return 'ssh-dss-cert-v01@openssh.com';
  if (key.type === 'ecdsa') return 'ecdsa-sha2-' + key.curve + '-cert-v01@openssh.com';
  if (key.type === 'ed25519') return 'ssh-ed25519-cert-v01@openssh.com';
  throw new Error('Unsupported key type ' + key.type);
}
//
},
'sshpk/lib/formats/x509':
function(module, exports, __wpreq__) {
//
module.exports = {
  read: read,
  verify: verify,
  sign: sign,
  signAsync: signAsync,
  write: write
};

var assert = __wpreq__('assert-plus'),
  asn1 = __wpreq__('asn1'),
  Buffer = __wpreq__('safer-buffer').Buffer,
  utils = __wpreq__('sshpk/lib/utils'),
  Identity = __wpreq__('sshpk/lib/identity'),
  Signature = __wpreq__('sshpk/lib/signature'),
  Certificate = __wpreq__('sshpk/lib/certificate'),
  pkcs8 = __wpreq__('sshpk/lib/formats/pkcs8');

function readMPInt(der, nm) {
  assert.strictEqual(der.peek(), asn1.Ber.Integer, nm + ' is not an Integer');
  return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
}

function verify(cert, key) {
  var sig = cert.signatures.x509;
  assert.object(sig, 'x509 signature');

  var algParts = sig.algo.split('-');
  if (algParts[0] !== key.type) return false;

  var blob = sig.cache;
  if (blob === void 0) {
    var der = new asn1.BerWriter();
    writeTBSCert(cert, der);
    blob = der.buffer;
  }

  var verifier = key.createVerify(algParts[1]);
  verifier.write(blob);
  return verifier.verify(sig.signature);
}

function Local(i) {
  return asn1.Ber.Context | asn1.Ber.Constructor | i;
}

function Context(i) {
  return asn1.Ber.Context | i;
}

var SIGN_ALGS = {
  'rsa-md5': '1.2.840.113549.1.1.4',
  'rsa-sha1': '1.2.840.113549.1.1.5',
  'rsa-sha256': '1.2.840.113549.1.1.11',
  'rsa-sha384': '1.2.840.113549.1.1.12',
  'rsa-sha512': '1.2.840.113549.1.1.13',
  'dsa-sha1': '1.2.840.10040.4.3',
  'dsa-sha256': '2.16.840.1.101.3.4.3.2',
  'ecdsa-sha1': '1.2.840.10045.4.1',
  'ecdsa-sha256': '1.2.840.10045.4.3.2',
  'ecdsa-sha384': '1.2.840.10045.4.3.3',
  'ecdsa-sha512': '1.2.840.10045.4.3.4',
  'ed25519-sha512': '1.3.101.112'
};
Object.keys(SIGN_ALGS).forEach(function(k) {
  SIGN_ALGS[SIGN_ALGS[k]] = k;
});
SIGN_ALGS['1.3.14.3.2.3'] = 'rsa-md5';
SIGN_ALGS['1.3.14.3.2.29'] = 'rsa-sha1';

var EXTS = {
  issuerKeyId: '2.5.29.35',
  altName: '2.5.29.17',
  basicConstraints: '2.5.29.19',
  keyUsage: '2.5.29.15',
  extKeyUsage: '2.5.29.37'
};

function read(buf, options) {
  if (typeof buf == 'string') buf = Buffer.from(buf, 'binary');
  assert.buffer(buf, 'buf');

  var der = new asn1.BerReader(buf);

  der.readSequence();
  if (Math.abs(der.length - der.remain) > 1) throw new Error('DER sequence does not contain whole byte stream');

  var tbsStart = der.offset;
  der.readSequence();
  var sigOffset = der.offset + der.length,
    tbsEnd = sigOffset;

  if (der.peek() === Local(0)) {
    der.readSequence(Local(0));
    var version = der.readInt();
    assert.ok(version <= 3, 'only x.509 versions up to v3 supported');
  }

  var cert = {signatures: {}},
    sig = (cert.signatures.x509 = {});
  sig.extras = {};

  cert.serial = readMPInt(der, 'serial');

  der.readSequence();
  var after = der.offset + der.length,
    certAlgOid = der.readOID();
  if (SIGN_ALGS[certAlgOid] === void 0) throw new Error('unknown signature algorithm ' + certAlgOid);

  der._offset = after;
  cert.issuer = Identity.parseAsn1(der);

  der.readSequence();
  cert.validFrom = readDate(der);
  cert.validUntil = readDate(der);

  cert.subjects = [Identity.parseAsn1(der)];

  der.readSequence();
  after = der.offset + der.length;
  cert.subjectKey = pkcs8.readPkcs8(void 0, 'public', der);
  der._offset = after;

  if (der.peek() === Local(1)) {
    der.readSequence(Local(1));
    sig.extras.issuerUniqueID = buf.slice(der.offset, der.offset + der.length);
    der._offset += der.length;
  }

  if (der.peek() === Local(2)) {
    der.readSequence(Local(2));
    sig.extras.subjectUniqueID = buf.slice(der.offset, der.offset + der.length);
    der._offset += der.length;
  }

  if (der.peek() === Local(3)) {
    der.readSequence(Local(3));
    var extEnd = der.offset + der.length;
    der.readSequence();

    while (der.offset < extEnd) readExtension(cert, buf, der);

    assert.strictEqual(der.offset, extEnd);
  }

  assert.strictEqual(der.offset, sigOffset);

  der.readSequence();
  after = der.offset + der.length;
  var sigAlgOid = der.readOID(),
    sigAlg = SIGN_ALGS[sigAlgOid];
  if (sigAlg === void 0) throw new Error('unknown signature algorithm ' + sigAlgOid);
  der._offset = after;

  var sigData = der.readString(asn1.Ber.BitString, true);
  if (sigData[0] === 0) sigData = sigData.slice(1);
  var algParts = sigAlg.split('-');

  sig.signature = Signature.parse(sigData, algParts[0], 'asn1');
  sig.signature.hashAlgorithm = algParts[1];
  sig.algo = sigAlg;
  sig.cache = buf.slice(tbsStart, tbsEnd);

  return new Certificate(cert);
}

function readDate(der) {
  if (der.peek() === asn1.Ber.UTCTime) return utcTimeToDate(der.readString(asn1.Ber.UTCTime));
  if (der.peek() === asn1.Ber.GeneralizedTime) return gTimeToDate(der.readString(asn1.Ber.GeneralizedTime));

  throw new Error('Unsupported date format');
}

var ALTNAME = {
  OtherName: Local(0),
  RFC822Name: Context(1),
  DNSName: Context(2),
  X400Address: Local(3),
  DirectoryName: Local(4),
  EDIPartyName: Local(5),
  URI: Context(6),
  IPAddress: Context(7),
  OID: Context(8)
};

var EXTPURPOSE = {
  serverAuth: '1.3.6.1.5.5.7.3.1',
  clientAuth: '1.3.6.1.5.5.7.3.2',
  codeSigning: '1.3.6.1.5.5.7.3.3',

  joyentDocker: '1.3.6.1.4.1.38678.1.4.1',
  joyentCmon: '1.3.6.1.4.1.38678.1.4.2'
};
var EXTPURPOSE_REV = {};
Object.keys(EXTPURPOSE).forEach(function(k) {
  EXTPURPOSE_REV[EXTPURPOSE[k]] = k;
});

var KEYUSEBITS = ['signature', 'identity', 'keyEncryption', 'encryption', 'keyAgreement', 'ca', 'crl'];

function readExtension(cert, buf, der) {
  der.readSequence();
  var id,
    critical,
    after = der.offset + der.length,
    extId = der.readOID(),
    sig = cert.signatures.x509;
  sig.extras.exts = [];

  if (der.peek() === asn1.Ber.Boolean) critical = der.readBoolean();

  switch (extId) {
  case EXTS.basicConstraints:
    der.readSequence(asn1.Ber.OctetString);
    der.readSequence();
    var bcEnd = der.offset + der.length,
      ca = false;
    if (der.peek() === asn1.Ber.Boolean) ca = der.readBoolean();
    if (cert.purposes === void 0) cert.purposes = [];
    ca !== true || cert.purposes.push('ca');
    var bc = {oid: extId, critical: critical};
    if (der.offset < bcEnd && der.peek() === asn1.Ber.Integer) bc.pathLen = der.readInt();
    sig.extras.exts.push(bc);
    break;
  case EXTS.extKeyUsage:
    der.readSequence(asn1.Ber.OctetString);
    der.readSequence();
    if (cert.purposes === void 0) cert.purposes = [];
    for (var ekEnd = der.offset + der.length; der.offset < ekEnd; ) {
      var oid = der.readOID();
      cert.purposes.push(EXTPURPOSE_REV[oid] || oid);
    }
    if (cert.purposes.indexOf('serverAuth') > -1 && cert.purposes.indexOf('clientAuth') < 0)
      cert.subjects.forEach(function(ide) {
        if (ide.type !== 'host') {
          ide.type = 'host';
          ide.hostname = ide.uid || ide.email || ide.components[0].value;
        }
      });
    else if (cert.purposes.indexOf('clientAuth') > -1 && cert.purposes.indexOf('serverAuth') < 0)
      cert.subjects.forEach(function(ide) {
        if (ide.type !== 'user') {
          ide.type = 'user';
          ide.uid = ide.hostname || ide.email || ide.components[0].value;
        }
      });

    sig.extras.exts.push({oid: extId, critical: critical});
    break;
  case EXTS.keyUsage:
    der.readSequence(asn1.Ber.OctetString);
    var bits = der.readString(asn1.Ber.BitString, true);
    readBitField(bits, KEYUSEBITS).forEach(function(bit) {
      if (cert.purposes === void 0) cert.purposes = [];
      cert.purposes.indexOf(bit) < 0 && cert.purposes.push(bit);
    });
    sig.extras.exts.push({oid: extId, critical: critical, bits: bits});
    break;
  case EXTS.altName:
    der.readSequence(asn1.Ber.OctetString);
    der.readSequence();
    for (var aeEnd = der.offset + der.length; der.offset < aeEnd; )
      switch (der.peek()) {
      case ALTNAME.OtherName:
      case ALTNAME.EDIPartyName:
        der.readSequence();
        der._offset += der.length;
        break;
      case ALTNAME.OID:
        der.readOID(ALTNAME.OID);
        break;
      case ALTNAME.RFC822Name:
        var email = der.readString(ALTNAME.RFC822Name);
        id = Identity.forEmail(email);
        cert.subjects[0].equals(id) || cert.subjects.push(id);
        break;
      case ALTNAME.DirectoryName:
        der.readSequence(ALTNAME.DirectoryName);
        id = Identity.parseAsn1(der);
        cert.subjects[0].equals(id) || cert.subjects.push(id);
        break;
      case ALTNAME.DNSName:
        var host = der.readString(ALTNAME.DNSName);
        id = Identity.forHost(host);
        cert.subjects[0].equals(id) || cert.subjects.push(id);
        break;
      default:
        der.readString(der.peek());
        break;
      }

    sig.extras.exts.push({oid: extId, critical: critical});
    break;
  default:
    sig.extras.exts.push({oid: extId, critical: critical, data: der.readString(asn1.Ber.OctetString, true)});
    break;
  }

  der._offset = after;
}

var UTCTIME_RE = /^([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
function utcTimeToDate(t) {
  var m = t.match(UTCTIME_RE);
  assert.ok(m, 'timestamps must be in UTC');
  var d = new Date(),

    thisYear = d.getUTCFullYear(),
    century = Math.floor(thisYear / 100) * 100,

    year = parseInt(m[1], 10);
  year += thisYear % 100 < 50 && year >= 60 ? century - 1 : century;
  d.setUTCFullYear(year, parseInt(m[2], 10) - 1, parseInt(m[3], 10));
  d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
  m[6] && m[6].length > 0 && d.setUTCSeconds(parseInt(m[6], 10));
  return d;
}

var GTIME_RE = /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
function gTimeToDate(t) {
  var m = t.match(GTIME_RE);
  assert.ok(m);
  var d = new Date();

  d.setUTCFullYear(parseInt(m[1], 10), parseInt(m[2], 10) - 1, parseInt(m[3], 10));
  d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
  m[6] && m[6].length > 0 && d.setUTCSeconds(parseInt(m[6], 10));
  return d;
}

function zeroPad(n) {
  var s = '' + n;
  while (s.length < 2) s = '0' + s;
  return s;
}

function dateToUTCTime(d) {
  var s = '';
  s += zeroPad(d.getUTCFullYear() % 100);
  s += zeroPad(d.getUTCMonth() + 1);
  s += zeroPad(d.getUTCDate());
  s += zeroPad(d.getUTCHours());
  s += zeroPad(d.getUTCMinutes());
  s += zeroPad(d.getUTCSeconds());
  return s + 'Z';
}

function sign(cert, key) {
  if (cert.signatures.x509 === void 0) cert.signatures.x509 = {};
  var sig = cert.signatures.x509;

  sig.algo = key.type + '-' + key.defaultHashAlgorithm();
  if (SIGN_ALGS[sig.algo] === void 0) return false;

  var der = new asn1.BerWriter();
  writeTBSCert(cert, der);
  var blob = der.buffer;
  sig.cache = blob;

  var signer = key.createSign();
  signer.write(blob);
  cert.signatures.x509.signature = signer.sign();

  return true;
}

function signAsync(cert, signer, done) {
  if (cert.signatures.x509 === void 0) cert.signatures.x509 = {};
  var sig = cert.signatures.x509,

    der = new asn1.BerWriter();
  writeTBSCert(cert, der);
  var blob = der.buffer;
  sig.cache = blob;

  signer(blob, function(err, signature) {
    if (err) {
      done(err);
      return;
    }
    sig.algo = signature.type + '-' + signature.hashAlgorithm;
    if (SIGN_ALGS[sig.algo] !== void 0) {
      sig.signature = signature;
      done();
    } else done(new Error('Invalid signing algorithm "' + sig.algo + '"'));
  });
}

function write(cert, options) {
  var sig = cert.signatures.x509;
  assert.object(sig, 'x509 signature');

  var der = new asn1.BerWriter();
  der.startSequence();
  if (sig.cache) {
    der._ensure(sig.cache.length);
    sig.cache.copy(der._buf, der._offset);
    der._offset += sig.cache.length;
  } else writeTBSCert(cert, der);

  der.startSequence();
  der.writeOID(SIGN_ALGS[sig.algo]);
  sig.algo.match(/^rsa-/) && der.writeNull();
  der.endSequence();

  var sigData = sig.signature.toBuffer('asn1'),
    data = Buffer.alloc(sigData.length + 1);
  data[0] = 0;
  sigData.copy(data, 1);
  der.writeBuffer(data, asn1.Ber.BitString);
  der.endSequence();

  return der.buffer;
}

function writeTBSCert(cert, der) {
  var sig = cert.signatures.x509;
  assert.object(sig, 'x509 signature');

  der.startSequence();

  der.startSequence(Local(0));
  der.writeInt(2);
  der.endSequence();

  der.writeBuffer(utils.mpNormalize(cert.serial), asn1.Ber.Integer);

  der.startSequence();
  der.writeOID(SIGN_ALGS[sig.algo]);
  sig.algo.match(/^rsa-/) && der.writeNull();
  der.endSequence();

  cert.issuer.toAsn1(der);

  der.startSequence();
  der.writeString(dateToUTCTime(cert.validFrom), asn1.Ber.UTCTime);
  der.writeString(dateToUTCTime(cert.validUntil), asn1.Ber.UTCTime);
  der.endSequence();

  var subject = cert.subjects[0],
    altNames = cert.subjects.slice(1);
  subject.toAsn1(der);

  pkcs8.writePkcs8(der, cert.subjectKey);

  sig.extras && sig.extras.issuerUniqueID && der.writeBuffer(sig.extras.issuerUniqueID, Local(1));

  sig.extras && sig.extras.subjectUniqueID && der.writeBuffer(sig.extras.subjectUniqueID, Local(2));

  if (
    altNames.length > 0 || subject.type === 'host' ||
    (cert.purposes !== void 0 && cert.purposes.length > 0) ||
    (sig.extras && sig.extras.exts)
  ) {
    der.startSequence(Local(3));
    der.startSequence();

    var exts = [];
    if (cert.purposes !== void 0 && cert.purposes.length > 0) {
      exts.push({oid: EXTS.basicConstraints, critical: true});
      exts.push({oid: EXTS.keyUsage, critical: true});
      exts.push({oid: EXTS.extKeyUsage, critical: true});
    }
    exts.push({oid: EXTS.altName});
    if (sig.extras && sig.extras.exts) exts = sig.extras.exts;

    for (var i = 0; i < exts.length; ++i) {
      der.startSequence();
      der.writeOID(exts[i].oid);

      exts[i].critical === void 0 || der.writeBoolean(exts[i].critical);

      if (exts[i].oid === EXTS.altName) {
        der.startSequence(asn1.Ber.OctetString);
        der.startSequence();
        subject.type !== 'host' || der.writeString(subject.hostname, Context(2));

        for (var j = 0; j < altNames.length; ++j)
          if (altNames[j].type === 'host') der.writeString(altNames[j].hostname, ALTNAME.DNSName);
          else if (altNames[j].type === 'email') der.writeString(altNames[j].email, ALTNAME.RFC822Name);
          else {
            der.startSequence(ALTNAME.DirectoryName);
            altNames[j].toAsn1(der);
            der.endSequence();
          }

        der.endSequence();
        der.endSequence();
      } else if (exts[i].oid === EXTS.basicConstraints) {
        der.startSequence(asn1.Ber.OctetString);
        der.startSequence();
        var ca = cert.purposes.indexOf('ca') > -1,
          pathLen = exts[i].pathLen;
        der.writeBoolean(ca);
        pathLen === void 0 || der.writeInt(pathLen);
        der.endSequence();
        der.endSequence();
      } else if (exts[i].oid === EXTS.extKeyUsage) {
        der.startSequence(asn1.Ber.OctetString);
        der.startSequence();
        cert.purposes.forEach(function(purpose) {
          if (purpose === 'ca' || KEYUSEBITS.indexOf(purpose) > -1) return;
          var oid = purpose;
          if (EXTPURPOSE[purpose] !== void 0) oid = EXTPURPOSE[purpose];
          der.writeOID(oid);
        });
        der.endSequence();
        der.endSequence();
      } else if (exts[i].oid === EXTS.keyUsage) {
        der.startSequence(asn1.Ber.OctetString);
        if (exts[i].bits !== void 0) der.writeBuffer(exts[i].bits, asn1.Ber.BitString);
        else {
          var bits = writeBitField(cert.purposes, KEYUSEBITS);
          der.writeBuffer(bits, asn1.Ber.BitString);
        }
        der.endSequence();
      } else der.writeBuffer(exts[i].data, asn1.Ber.OctetString);

      der.endSequence();
    }

    der.endSequence();
    der.endSequence();
  }

  der.endSequence();
}

function readBitField(bits, bitIndex) {
  var setBits = {};
  for (var bitLen = 8 * (bits.length - 1) - bits[0], i = 0; i < bitLen; ++i) {
    var mask = 1 << (7 - (i % 8)),
      bitVal = (bits[1 + Math.floor(i / 8)] & mask) != 0,
      name = bitIndex[i];
    if (bitVal && typeof name == 'string') setBits[name] = true;
  }
  return Object.keys(setBits);
}

function writeBitField(setBits, bitIndex) {
  // noinspection UnnecessaryLocalVariableJS
  var bitLen = bitIndex.length,
    blen = Math.ceil(bitLen / 8),
    unused = blen * 8 - bitLen,
    bits = Buffer.alloc(1 + blen);
  bits[0] = unused;
  for (var i = 0; i < bitLen; ++i) {
    var byteN = 1 + Math.floor(i / 8),
      mask = 1 << (7 - (i % 8)),
      name = bitIndex[i];
    if (name !== void 0 && setBits.indexOf(name) > -1) bits[byteN] |= mask;
  }
  return bits;
}
//
},
'sshpk/lib/formats/x509-pem':
function(module, exports, __wpreq__) {
//
var x509 = __wpreq__('sshpk/lib/formats/x509');

module.exports = {
  read: read,
  verify: x509.verify,
  sign: x509.sign,
  write: write
};

var assert = __wpreq__('assert-plus'),
  Buffer = __wpreq__('safer-buffer').Buffer;

function read(/** (Buffer|string) */ buf, options) {
  if (typeof buf != 'string') {
    assert.buffer(buf, 'buf');
    buf = buf.toString('ascii');
  }

  var lines = buf.trim().split(/[\r\n]+/g),

    m = lines[0].match(/[-]+[ ]*BEGIN CERTIFICATE[ ]*[-]+/);
  assert.ok(m, 'invalid PEM header');

  var m2 = lines[lines.length - 1].match(/[-]+[ ]*END CERTIFICATE[ ]*[-]+/);
  assert.ok(m2, 'invalid PEM footer');

  for (var headers = {}; (m = (lines = lines.slice(1))[0].match(/^([A-Za-z0-9-]+): (.+)$/)); )
    headers[m[1].toLowerCase()] = m[2];

  lines = lines.slice(0, -1).join('');
  buf = Buffer.from(lines, 'base64');

  return x509.read(buf, options);
}

function write(cert, options) {
  var header = 'CERTIFICATE',
    tmp = x509.write(cert, options).toString('base64'),
    len = tmp.length + tmp.length / 64 + 18 + 16 + header.length * 2 + 10,
    buf = Buffer.alloc(len),
    o = 0;
  o += buf.write('-----BEGIN ' + header + '-----\n', o);
  for (var i = 0; i < tmp.length; ) {
    var limit = i + 64;
    if (limit > tmp.length) limit = tmp.length;
    o += buf.write(tmp.slice(i, limit), o);
    buf[o++] = 10;
    i = limit;
  }
  o += buf.write('-----END ' + header + '-----\n', o);

  return buf.slice(0, o);
}
//
},
jsprim:
function(module, exports, __wpreq__) {
//
var mod_assert = __wpreq__('assert-plus'),
  mod_extsprintf = __wpreq__('extsprintf');

exports.isEmpty = isEmpty;
exports.hasKey = hasKey;
exports.forEachKey = forEachKey;

exports.startsWith = startsWith;
exports.endsWith = endsWith;

exports.iso8601 = iso8601;
exports.rfc1123 = rfc1123;
exports.parseDateTime = parseDateTime;

function isEmpty(obj) {
  // noinspection LoopStatementThatDoesntLoopJS
  for (var key in obj) return false;
  return true;
}

function hasKey(obj, key) {
  mod_assert.equal(typeof key, 'string');
  return Object.prototype.hasOwnProperty.call(obj, key);
}

function forEachKey(obj, callback) {
  for (var key in obj) hasKey(obj, key) && callback(key, obj[key]);
}

function startsWith(str, prefix) {
  return str.substr(0, prefix.length) == prefix;
}

function endsWith(str, suffix) {
  return str.substr(str.length - suffix.length, suffix.length) == suffix;
}

function iso8601(d) {
  if (typeof d == 'number') d = new Date(d);
  mod_assert.ok(d.constructor === Date);
  return mod_extsprintf.sprintf(
    '%4d-%02d-%02dT%02d:%02d:%02d.%03dZ',
    d.getUTCFullYear(), d.getUTCMonth() + 1, d.getUTCDate(),
    d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(),
    d.getUTCMilliseconds()
  );
}

var RFC1123_MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  RFC1123_DAYS = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

function rfc1123(date) {
  return mod_extsprintf.sprintf(
    '%s, %02d %s %04d %02d:%02d:%02d GMT',
    RFC1123_DAYS[date.getUTCDay()],
    date.getUTCDate(), RFC1123_MONTHS[date.getUTCMonth()], date.getUTCFullYear(),
    date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds()
  );
}

function parseDateTime(str) {
  var numeric = +str;
  return isNaN(numeric) ? new Date(str) : new Date(numeric);
}
//
},
extsprintf:
function(module, exports, __wpreq__) {
//
var mod_assert = __wpreq__('assert'),
  mod_util = __wpreq__('util');

exports.sprintf = jsSprintf;
exports.printf = jsPrintf;
exports.fprintf = jsFprintf;

function jsSprintf(fmt) {
  var flags, width, precision, conversion, left, pad, sign, arg, match;
  var regex = [
    '([^%]*)',
    '%',
    "(['\\-+ #0]*?)",
    '([1-9]\\d*)?',
    '(\\.([1-9]\\d*))?',
    '[lhjztL]*?',
    '([diouxXfFeEgGaAcCsSp%jr])'
  ].join('');

  var re = new RegExp(regex),
    args = Array.prototype.slice.call(arguments, 1),
    ret = '',
    argn = 1;

  mod_assert.equal('string', typeof fmt);

  while ((match = re.exec(fmt)) !== null) {
    ret += match[1];
    fmt = fmt.substring(match[0].length);

    flags = match[2] || '';
    width = match[3] || 0;
    precision = match[4] || '';
    left = false;
    sign = false;
    pad = ' ';

    if ((conversion = match[6]) == '%') {
      ret += '%';
      continue;
    }

    if (args.length === 0) throw new Error('too few args to sprintf');

    arg = /** @type {(number|*)} */ args.shift();
    argn++;

    if (flags.match(/[' #]/)) throw new Error('unsupported flags: ' + flags);

    if (precision.length > 0) throw new Error('non-zero precision not supported');

    if (flags.match(/-/)) left = true;

    if (flags.match(/0/)) pad = '0';

    if (flags.match(/\+/)) sign = true;

    switch (conversion) {
    case 's':
      if (arg === void 0 || arg === null)
        throw new Error('argument ' + argn + ': attempted to print undefined or null as a string');
      ret += doPad(pad, width, left, arg.toString());
      break;

    case 'd':
      arg = Math.floor(arg);
    case 'f':
      ret += (sign = sign && arg > 0 ? '+' : '') + doPad(pad, width, left, arg.toString());
      break;

    case 'x':
      ret += doPad(pad, width, left, arg.toString(16));
      break;

    case 'j':
      if (width === 0) width = 10;
      ret += mod_util.inspect(arg, false, width);
      break;

    case 'r':
      ret += dumpException(arg);
      break;

    default:
      throw new Error('unsupported conversion: ' + conversion);
    }
  }

  return ret + fmt;
}

function jsPrintf() {
  var args = Array.prototype.slice.call(arguments);
  args.unshift(process.stdout);
  jsFprintf.apply(null, args);
}

function jsFprintf(stream) {
  var args = Array.prototype.slice.call(arguments, 1);
  return stream.write(jsSprintf.apply(this, args));
}

function doPad(chr, width, left, str) {
  var ret = str;

  while (ret.length < width) left ? (ret += chr) : (ret = chr + ret);

  return ret;
}

function dumpException(ex) {
  var ret;

  if (!(ex instanceof Error)) throw new Error(jsSprintf('invalid type for %%r: %j', ex));

  ret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;

  if (ex.cause && typeof ex.cause == 'function') {
    var cex = ex.cause();
    if (cex) ret += '\nCaused by: ' + dumpException(cex);
  }

  return ret;
}
//
},
'http-signature/lib/utils':
function(module, exports, __wpreq__) {
//
var util = __wpreq__('util'),

  HASH_ALGOS = {sha1: true, sha256: true, sha512: true},
  PK_ALGOS = {rsa: true, dsa: true, ecdsa: true};

function HttpSignatureError(message, caller) {
  Error.captureStackTrace && Error.captureStackTrace(this, caller || HttpSignatureError);

  this.message = message;
  this.name = caller.name;
}
util.inherits(HttpSignatureError, Error);

function InvalidAlgorithmError(message) {
  HttpSignatureError.call(this, message, InvalidAlgorithmError);
}
util.inherits(InvalidAlgorithmError, HttpSignatureError);

function validateAlgorithm(algorithm) {
  var alg = algorithm.toLowerCase().split('-');

  if (alg.length !== 2) throw new InvalidAlgorithmError(alg[0].toUpperCase() + ' is not a valid algorithm');

  if (alg[0] !== 'hmac' && !PK_ALGOS[alg[0]])
    throw new InvalidAlgorithmError(alg[0].toUpperCase() + ' type keys are not supported');

  if (!HASH_ALGOS[alg[1]])
    throw new InvalidAlgorithmError(alg[1].toUpperCase() + ' is not a supported hash algorithm');

  return alg;
}

module.exports = {
  HASH_ALGOS: HASH_ALGOS,
  PK_ALGOS: PK_ALGOS,

  HttpSignatureError: HttpSignatureError,
  InvalidAlgorithmError: InvalidAlgorithmError,

  validateAlgorithm: validateAlgorithm
};
//
},
'mime-types':
function(module, exports, __wpreq__) {
//
var db = __wpreq__('mime-db'),
  extname = __wpreq__('path').extname,

  EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/,
  TEXT_TYPE_REGEXP = /^text\//i

exports.charset = charset
exports.charsets = {lookup: charset}
exports.contentType = contentType
exports.extension = extension
exports.extensions = Object.create(null)
exports.lookup = lookup
exports.types = Object.create(null)

populateMaps(exports.extensions, exports.types)

function charset(type) {
  if (!type || typeof type != 'string') return false

  var match = EXTRACT_TYPE_REGEXP.exec(type),
    mime = match && db[match[1].toLowerCase()]

  return mime && mime.charset ? mime.charset : !(!match || !TEXT_TYPE_REGEXP.test(match[1])) && 'UTF-8'
}

function contentType(str) {
  if (!str || typeof str != 'string') return false

  var mime = str.indexOf('/') < 0 ? exports.lookup(str) : str

  if (!mime) return false

  if (mime.indexOf('charset') < 0) {
    var charset = exports.charset(mime)
    if (charset) mime += '; charset=' + charset.toLowerCase()
  }

  return mime
}

function extension(type) {
  if (!type || typeof type != 'string') return false

  var match = EXTRACT_TYPE_REGEXP.exec(type),

    exts = match && exports.extensions[match[1].toLowerCase()]

  return !(!exts || !exts.length) && exts[0]
}

function lookup(path) {
  if (!path || typeof path != 'string') return false

  var extension = extname('x.' + path)
    .toLowerCase()
    .substr(1)

  return (extension && exports.types[extension]) || false
}

function populateMaps(extensions, types) {
  var preference = ['nginx', 'apache', void 0, 'iana']

  Object.keys(db).forEach(function(type) {
    var mime = db[type],
      exts = mime.extensions

    if (!exts || !exts.length) return

    extensions[type] = exts

    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i]

      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source),
          to = preference.indexOf(mime.source)

        if (
          types[extension] !== 'application/octet-stream' &&
          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))
        )
          continue
      }

      types[extension] = type
    }
  })
}
//
},
'mime-db':
function(module) {
//
module.exports = JSON.parse(
  '{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/cbor":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},\
"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["ecma","es"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true},"application/fhir+json":{"source":"iana","compressible":true},"application/fhir+xml":{"source":"iana","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},\
"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},\
"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mmt-usd+xml":{"source":"iana","compressible":true},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","compressible":true},"application/msc-mixer+xml":{"source":"iana","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana"},"application/n-triples":{"source":"iana"},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana"},"application/news-groupinfo":{"source":"iana"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana"},"application/nss":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p2p-overlay+xml":{"source":"iana","compressible":true},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana"},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","compressible":true},\
"application/pidf-diff+xml":{"source":"iana","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true},"application/route-s-tsid+xml":{"source":"iana","compressible":true},"application/route-usd+xml":{"source":"iana","compressible":true},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},\
"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana"},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana"},"application/ttml+xml":{"source":"iana","compressible":true},"application/tve-trigger":{"source":"iana"},"application/ulpfec":{"source":"iana"},\
"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true},"application/urc-targetdesc+xml":{"source":"iana","compressible":true},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},\
"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},\
"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume-movie":{"source":"iana"},"application/vnd.desmume.movie":{"source":"apache"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},\
"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},\
"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},\
"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},\
"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},\
"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana"},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},\
"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nervana":{"source":"iana"},\
"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},\
"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},\
"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},\
"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},\
"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos+xml":{"source":"iana","compressible":true},"application/vnd.paos.xml":{"source":"apache"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},\
"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana"},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},\
"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","compressible":true},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},\
"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},\
"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},\
"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},\
"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"apache","extensions":["der","crt","pem"]},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true},"application/xcap-caps+xml":{"source":"iana","compressible":true},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},\
"application/xliff+xml":{"source":"iana","compressible":true},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana"},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},\
"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana"},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},\
"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana"},"image/apng":{"compressible":false,"extensions":["apng"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana"},"image/emf":{"source":"iana"},"image/fits":{"source":"iana"},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana"},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana"},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana"},"image/tiff":{"source":"iana","compressible":false,"extensions":["tiff","tif"]},"image/tiff-fx":{"source":"iana"},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana"},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana"},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},\
"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana"},"image/vnd.valve.source.texture":{"source":"iana"},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana"},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana"},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/stl":{"source":"iana"},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana"},\
"model/vnd.parasolid.transmit.binary":{"source":"iana"},"model/vnd.parasolid.transmit.text":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.usdz+zip":{"source":"iana","compressible":false},"model/vnd.valve.source.compiled-map":{"source":"iana"},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana"},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana"},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana","compressible":false},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shex":{"extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},\
"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},\
"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana"},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vp8":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},\
"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}'
);
//
},
caseless:
function(module) {
//
function Caseless(dict) {
  this.dict = dict || {}
}
Caseless.prototype.set = function(name, value, clobber) {
  if (typeof name != 'object') {
    if (clobber === void 0) clobber = true
    var has = this.has(name)

    !clobber && has ? (this.dict[has] = this.dict[has] + ',' + value) : (this.dict[has || name] = value)
    return has
  }

  for (var i in name) this.set(i, name[i], value)
}
Caseless.prototype.has = function(name) {
  for (var keys = Object.keys(this.dict), i = ((name = name.toLowerCase()), 0); i < keys.length; i++)
    if (keys[i].toLowerCase() === name) return keys[i]

  return false
}
Caseless.prototype.get = function(name) {
  name = name.toLowerCase()
  var result, _key,
    headers = this.dict
  Object.keys(headers).forEach(function(key) {
    _key = key.toLowerCase()
    if (name === _key) result = headers[key]
  })
  return result
}
Caseless.prototype.swap = function(name) {
  var has = this.has(name)
  if (has === name) return
  if (!has) throw new Error('There is no header than matches "' + name + '"')
  this.dict[name] = this.dict[has]
  delete this.dict[has]
}
Caseless.prototype.del = function(name) {
  var has = this.has(name)
  return delete this.dict[has || name]
}

module.exports = function(dict) {
  return new Caseless(dict)
}
module.exports.httpify = function(resp, headers) {
  var c = new Caseless(headers)
  resp.setHeader = function(key, value, clobber) {
    if (value !== void 0) return c.set(key, value, clobber)
  }
  resp.hasHeader = function(key) {
    return c.has(key)
  }
  resp.getHeader = function(key) {
    return c.get(key)
  }
  resp.removeHeader = function(key) {
    return c.del(key)
  }
  resp.headers = c.dict
  return c
}
//
},
'forever-agent':
function(module, exports, __wpreq__) {
//
module.exports = ForeverAgent
ForeverAgent.SSL = ForeverAgentSSL

var util = __wpreq__('util'),
  Agent = __wpreq__('http').Agent,
  net = __wpreq__('net'),
  tls = __wpreq__('tls'),
  AgentSSL = __wpreq__('https').Agent

function getConnectionName(host, port) {
  return typeof host == 'string'
    ? host + ':' + port
    : host.host + ':' + host.port + ':' + (host.localAddress ? host.localAddress + ':' : ':')
}

function ForeverAgent(options) {
  var self = this
  self.options = options || {}
  self.requests = {}
  self.sockets = {}
  self.freeSockets = {}
  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets
  self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets
  self.on('free', function(socket, host, port) {
    var name = getConnectionName(host, port)

    if (self.requests[name] && self.requests[name].length) self.requests[name].shift().onSocket(socket)
    else if (self.sockets[name].length < self.minSockets) {
      self.freeSockets[name] || (self.freeSockets[name] = [])
      self.freeSockets[name].push(socket)

      var onIdleError = function() {
        socket.destroy()
      }
      socket._onIdleError = onIdleError
      socket.on('error', onIdleError)
    } else socket.destroy()
  })
}
util.inherits(ForeverAgent, Agent)

ForeverAgent.defaultMinSockets = 5

ForeverAgent.prototype.createConnection = net.createConnection
ForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest
ForeverAgent.prototype.addRequest = function(req, host, port) {
  var name = getConnectionName(host, port)

  if (typeof host != 'string') {
    var options = host
    port = options.port
    host = options.host
  }

  if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {
    var idleSocket = this.freeSockets[name].pop()
    idleSocket.removeListener('error', idleSocket._onIdleError)
    delete idleSocket._onIdleError
    req._reusedSocket = true
    req.onSocket(idleSocket)
  } else this.addRequestNoreuse(req, host, port)
}

ForeverAgent.prototype.removeSocket = function(s, name, host, port) {
  var index
  if (this.sockets[name]) (index = this.sockets[name].indexOf(s)) < 0 || this.sockets[name].splice(index, 1)
  else if (this.sockets[name] && this.sockets[name].length === 0) {
    delete this.sockets[name]
    delete this.requests[name]
  }

  if (this.freeSockets[name] && (index = this.freeSockets[name].indexOf(s)) > -1) {
    this.freeSockets[name].splice(index, 1)
    this.freeSockets[name].length > 0 || delete this.freeSockets[name]
  }

  this.requests[name] && this.requests[name].length && this.createSocket(name, host, port).emit('free')
}

function ForeverAgentSSL(options) {
  ForeverAgent.call(this, options)
}
util.inherits(ForeverAgentSSL, ForeverAgent)

ForeverAgentSSL.prototype.createConnection = createConnectionSSL
ForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest

function createConnectionSSL(port, host, options) {
  options = typeof port == 'object' ? port : typeof host == 'object' ? host : typeof options == 'object' ? options : {};

  if (typeof port == 'number') options.port = port;

  if (typeof host == 'string') options.host = host;

  return tls.connect(options);
}
//
},
tls:
function(module) {
//
module.exports = require('tls');
//
},
'form-data':
function(module, exports, __wpreq__) {
//
var CombinedStream = __wpreq__('combined-stream'),
  util = __wpreq__('util'),
  path = __wpreq__('path'),
  http = __wpreq__('http'),
  https = __wpreq__('https'),
  parseUrl = __wpreq__('url').parse,
  fs = __wpreq__('fs'),
  mime = __wpreq__('mime-types'),
  asynckit = {parallel: __wpreq__('asynckit/parallel')},
  populate = __wpreq__('form-data/lib/populate');

module.exports = FormData;

util.inherits(FormData, CombinedStream);

function FormData(options) {
  if (!(this instanceof FormData)) return new FormData();

  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];

  CombinedStream.call(this);

  options = options || {};
  for (var option in options) this[option] = options[option];
}

FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

FormData.prototype.append = function(field, value, options) {
  if (typeof (options = options || {}) == 'string') options = {filename: options};

  var append = CombinedStream.prototype.append.bind(this);

  if (typeof value == 'number') value = '' + value;

  if (util.isArray(value)) {
    this._error(new Error('Arrays are not supported.'));
    return;
  }

  var header = this._multiPartHeader(field, value, options),
    footer = this._multiPartFooter();

  append(header);
  append(value);
  append(footer);

  this._trackLength(header, value, options);
};

FormData.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;

  if (options.knownLength != null) valueLength += +options.knownLength;
  else if (Buffer.isBuffer(value)) valueLength = value.length;
  else if (typeof value == 'string') valueLength = Buffer.byteLength(value);

  this._valueLength += valueLength;

  this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;

  value &&
    (value.path || (value.readable && value.hasOwnProperty('httpVersion'))) &&
    (options.knownLength || this._valuesToMeasure.push(value));
};

FormData.prototype._lengthRetriever = function(value, callback) {
  if (value.hasOwnProperty('fd'))
    value.end != null && value.end != Infinity && value.start != null
      ? callback(null, value.end + 1 - (value.start ? value.start : 0))
      : fs.stat(value.path, function(err, stat) {
          if (err) callback(err);
          else {
            var fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          }
        });
  else if (value.hasOwnProperty('httpVersion')) callback(null, +value.headers['content-length']);
  else if (value.hasOwnProperty('httpModule')) {
    value.on('response', function(response) {
      value.pause();
      callback(null, +response.headers['content-length']);
    });
    value.resume();
  } else callback('Unknown stream');
};

FormData.prototype._multiPartHeader = function(field, value, options) {
  if (typeof options.header == 'string') return options.header;

  var header,
    contentDisposition = this._getContentDisposition(value, options),
    contentType = this._getContentType(value, options),

    contents = '';
  var headers = {
    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
    'Content-Type': [].concat(contentType || [])
  };

  typeof options.header != 'object' || populate(headers, options.header);

  for (var prop in headers)
    if (headers.hasOwnProperty(prop) && (header = headers[prop]) != null) {
      Array.isArray(header) || (header = [header]);

      if (header.length) contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
    }

  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
};

FormData.prototype._getContentDisposition = function(value, options) {
  var filename, contentDisposition;

  if (typeof options.filepath == 'string') filename = path.normalize(options.filepath).replace(/\\/g, '/');
  else if (options.filename || value.name || value.path)
    filename = path.basename(options.filename || value.name || value.path);
  else if (value.readable && value.hasOwnProperty('httpVersion'))
    filename = path.basename(value.client._httpMessage.path);

  if (filename) contentDisposition = 'filename="' + filename + '"';

  return contentDisposition;
};

FormData.prototype._getContentType = function(value, options) {
  var contentType = options.contentType;

  if (!contentType && value.name) contentType = mime.lookup(value.name);

  if (!contentType && value.path) contentType = mime.lookup(value.path);

  if (!contentType && value.readable && value.hasOwnProperty('httpVersion'))
    contentType = value.headers['content-type'];

  contentType || (!options.filepath && !options.filename) ||
    (contentType = mime.lookup(options.filepath || options.filename));

  contentType || typeof value != 'object' || (contentType = FormData.DEFAULT_CONTENT_TYPE);

  return contentType;
};

FormData.prototype._multiPartFooter = function() {
  return function(next) {
    var footer = FormData.LINE_BREAK;

    if (this._streams.length === 0) footer += this._lastBoundary();

    next(footer);
  }.bind(this);
};

FormData.prototype._lastBoundary = function() {
  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
};

FormData.prototype.getHeaders = function(userHeaders) {
  var formHeaders = {'content-type': 'multipart/form-data; boundary=' + this.getBoundary()};

  for (var header in userHeaders)
    if (userHeaders.hasOwnProperty(header)) formHeaders[header.toLowerCase()] = userHeaders[header];

  return formHeaders;
};

FormData.prototype.getBoundary = function() {
  this._boundary || this._generateBoundary();

  return this._boundary;
};

FormData.prototype._generateBoundary = function() {
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) boundary += Math.floor(Math.random() * 10).toString(16);

  this._boundary = boundary;
};

FormData.prototype.getLengthSync = function() {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) knownLength += this._lastBoundary().length;

  this.hasKnownLength() || this._error(new Error('Cannot calculate proper length in synchronous way.'));

  return knownLength;
};

FormData.prototype.hasKnownLength = function() {
  var hasKnownLength = true;

  if (this._valuesToMeasure.length) hasKnownLength = false;

  return hasKnownLength;
};

FormData.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) knownLength += this._lastBoundary().length;

  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }

  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
    if (err) cb(err);
    else {
      values.forEach(function(length) {
        knownLength += length;
      });

      cb(null, knownLength);
    }
  });
};

FormData.prototype.submit = function(params, cb) {
  var request,
    options,
    defaults = {method: 'post'};

  if (typeof params == 'string') {
    params = parseUrl(params);
    options = populate(
      {port: params.port, path: params.pathname, host: params.hostname, protocol: params.protocol},
      defaults
    );
  } else (options = populate(params, defaults)).port || (options.port = options.protocol == 'https:' ? 443 : 80);

  options.headers = this.getHeaders(params.headers);

  request = options.protocol == 'https:' ? https.request(options) : http.request(options);

  this.getLength(function(err, length) {
    if (err) {
      this._error(err);
      return;
    }

    request.setHeader('Content-Length', length);

    this.pipe(request);
    if (cb) {
      request.on('error', cb);
      request.on('response', cb.bind(this, null));
    }
  }.bind(this));

  return request;
};

FormData.prototype._error = function(err) {
  if (!this.error) {
    this.error = err;
    this.pause();
    this.emit('error', err);
  }
};

FormData.prototype.toString = function() {
  return '[object FormData]';
};
//
},
'combined-stream':
function(module, exports, __wpreq__) {
//
var util = __wpreq__('util'),
  Stream = __wpreq__('stream').Stream,
  DelayedStream = __wpreq__('delayed-stream'),
  defer = __wpreq__('combined-stream/lib/defer');

module.exports = CombinedStream;
function CombinedStream() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2097152;
  this.pauseStreams = true;

  this._released = false;
  this._streams = [];
  this._currentStream = null;
}
util.inherits(CombinedStream, Stream);

CombinedStream.create = function(options) {
  var combinedStream = new this();

  options = options || {};
  for (var option in options) combinedStream[option] = options[option];

  return combinedStream;
};

CombinedStream.isStreamLike = function(stream) {
  return (
    typeof stream != 'function' &&
    typeof stream != 'string' &&
    typeof stream != 'boolean' &&
    typeof stream != 'number' &&
    !Buffer.isBuffer(stream)
  );
};

CombinedStream.prototype.append = function(stream) {
  if (CombinedStream.isStreamLike(stream)) {
    if (!(stream instanceof DelayedStream)) {
      var newStream = DelayedStream.create(stream, {maxDataSize: Infinity, pauseStream: this.pauseStreams});
      stream.on('data', this._checkDataSize.bind(this));
      stream = newStream;
    }

    this._handleErrors(stream);

    this.pauseStreams && stream.pause();
  }

  this._streams.push(stream);
  return this;
};

CombinedStream.prototype.pipe = function(dest, options) {
  Stream.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};

CombinedStream.prototype._getNext = function() {
  this._currentStream = null;
  var stream = this._streams.shift();

  stream === void 0
    ? this.end()
    : typeof stream != 'function'
    ? this._pipeNext(stream)
    : stream(function(stream) {
        if (CombinedStream.isStreamLike(stream)) {
          stream.on('data', this._checkDataSize.bind(this));
          this._handleErrors(stream);
        }

        defer(this._pipeNext.bind(this, stream));
      }.bind(this));
};

CombinedStream.prototype._pipeNext = function(stream) {
  this._currentStream = stream;

  if (CombinedStream.isStreamLike(stream)) {
    stream.on('end', this._getNext.bind(this));
    stream.pipe(this, {end: false});
    return;
  }

  this.write(stream);
  this._getNext();
};

CombinedStream.prototype._handleErrors = function(stream) {
  var self = this;
  stream.on('error', function(err) {
    self._emitError(err);
  });
};

CombinedStream.prototype.write = function(data) {
  this.emit('data', data);
};

CombinedStream.prototype.pause = function() {
  if (!this.pauseStreams) return;

  this.pauseStreams && this._currentStream && typeof this._currentStream.pause == 'function' &&
    this._currentStream.pause();
  this.emit('pause');
};

CombinedStream.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }

  this.pauseStreams && this._currentStream && typeof this._currentStream.resume == 'function' &&
    this._currentStream.resume();
  this.emit('resume');
};

CombinedStream.prototype.end = function() {
  this._reset();
  this.emit('end');
};

CombinedStream.prototype.destroy = function() {
  this._reset();
  this.emit('close');
};

CombinedStream.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};

CombinedStream.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) return;

  var message = 'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
  this._emitError(new Error(message));
};

CombinedStream.prototype._updateDataSize = function() {
  this.dataSize = 0;

  var self = this;
  this._streams.forEach(function(stream) {
    if (stream.dataSize) self.dataSize += stream.dataSize;
  });

  if (this._currentStream && this._currentStream.dataSize) this.dataSize += this._currentStream.dataSize;
};

CombinedStream.prototype._emitError = function(err) {
  this._reset();
  this.emit('error', err);
};
//
},
'delayed-stream':
function(module, exports, __wpreq__) {
//
var Stream = __wpreq__('stream').Stream,
  util = __wpreq__('util');

module.exports = DelayedStream;
function DelayedStream() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1048576;
  this.pauseStream = true;

  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);

DelayedStream.create = function(source, options) {
  var delayedStream = new this();

  options = options || {};
  for (var option in options) delayedStream[option] = options[option];

  delayedStream.source = source;

  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };

  source.on('error', function() {});
  delayedStream.pauseStream && source.pause();

  return delayedStream;
};

Object.defineProperty(DelayedStream.prototype, 'readable', {
  configurable: true,
  enumerable: true,
  get: function() {
    return this.source.readable;
  }
});

DelayedStream.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};

DelayedStream.prototype.resume = function() {
  this._released || this.release();

  this.source.resume();
};

DelayedStream.prototype.pause = function() {
  this.source.pause();
};

DelayedStream.prototype.release = function() {
  this._released = true;

  this._bufferedEvents.forEach(function(args) {
    this.emit.apply(this, args);
  }.bind(this));
  this._bufferedEvents = [];
};

DelayedStream.prototype.pipe = function() {
  var r = Stream.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};

DelayedStream.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }

  if (args[0] === 'data') {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }

  this._bufferedEvents.push(args);
};

DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded || this.dataSize <= this.maxDataSize) return;

  this._maxDataSizeExceeded = true;
  var message = 'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
  this.emit('error', new Error(message));
};
//
},
'combined-stream/lib/defer':
function(module) {
//
module.exports = defer;

function defer(fn) {
  var nextTick = typeof setImmediate == 'function'
    ? setImmediate
    : typeof process == 'object' && typeof process.nextTick == 'function'
    ? process.nextTick
    : null;

  nextTick ? nextTick(fn) : setTimeout(fn, 0);
}
//
},
'asynckit/parallel':
function(module, exports, __wpreq__) {
//
var iterate = __wpreq__('asynckit/lib/iterate'),
  initState = __wpreq__('asynckit/lib/state'),
  terminator = __wpreq__('asynckit/lib/terminator');

module.exports = parallel;

function parallel(list, iterator, callback) {
  var state = initState(list);

  while (state.index < (state.keyedList || list).length) {
    iterate(list, iterator, state, function(error, result) {
      error ? callback(error, result) : Object.keys(state.jobs).length > 0 || callback(null, state.results);
    });

    state.index++;
  }

  return terminator.bind(state, callback);
}
//
},
'asynckit/lib/iterate':
function(module, exports, __wpreq__) {
//
var async = __wpreq__('asynckit/lib/async'),
  abort = __wpreq__('asynckit/lib/abort');

module.exports = iterate;

function iterate(list, iterator, state, callback) {
  var key = state.keyedList ? state.keyedList[state.index] : state.index;

  state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
    if (!(key in state.jobs)) return;

    delete state.jobs[key];

    error ? abort(state) : (state.results[key] = output);

    callback(error, state.results);
  });
}

function runJob(iterator, key, item, callback) {
  return iterator.length == 2 ? iterator(item, async(callback)) : iterator(item, key, async(callback));
}
//
},
'asynckit/lib/async':
function(module, exports, __wpreq__) {
//
var defer = __wpreq__('asynckit/lib/defer');

module.exports = async;

function async(callback) {
  var isAsync = false;

  defer(function() { isAsync = true; });

  return function(err, result) {
    isAsync
      ? callback(err, result)
      : defer(function() {
          callback(err, result);
        });
  };
}
//
},
'asynckit/lib/defer':
function(module) {
//
module.exports = defer;

function defer(fn) {
  var nextTick = typeof setImmediate == 'function'
    ? setImmediate
    : typeof process == 'object' && typeof process.nextTick == 'function'
    ? process.nextTick
    : null;

  nextTick ? nextTick(fn) : setTimeout(fn, 0);
}
//
},
'asynckit/lib/abort':
function(module) {
//
module.exports = abort;

function abort(state) {
  Object.keys(state.jobs).forEach(clean.bind(state));

  state.jobs = {};
}

function clean(key) {
  typeof this.jobs[key] != 'function' || this.jobs[key]();
}
//
},
'asynckit/lib/state':
function(module) {
//
module.exports = state;

function state(list, sortMethod) {
  var isNamedList = !Array.isArray(list);
  var initState = {
    index: 0,
    keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
    jobs: {},
    results: isNamedList ? {} : [],
    size: isNamedList ? Object.keys(list).length : list.length
  };

  sortMethod &&
    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
      return sortMethod(list[a], list[b]);
    });

  return initState;
}
//
},
'asynckit/lib/terminator':
function(module, exports, __wpreq__) {
//
var abort = __wpreq__('asynckit/lib/abort'),
  async = __wpreq__('asynckit/lib/async');

module.exports = terminator;

function terminator(callback) {
  if (!Object.keys(this.jobs).length) return;

  this.index = this.size;

  abort(this);

  async(callback)(null, this.results);
}
//
},
'form-data/lib/populate':
function(module) {
//
module.exports = function(dst, src) {
  Object.keys(src).forEach(function(prop) {
    dst[prop] = dst[prop] || src[prop];
  });

  return dst;
};
//
},
isstream:
function(module, exports, __wpreq__) {
//
var stream = __wpreq__('stream')

function isStream(obj) {
  return obj instanceof stream.Stream
}

function isReadable(obj) {
  return isStream(obj) && typeof obj._read == 'function' && typeof obj._readableState == 'object'
}

function isWritable(obj) {
  return isStream(obj) && typeof obj._write == 'function' && typeof obj._writableState == 'object'
}

function isDuplex(obj) {
  return isReadable(obj) && isWritable(obj)
}

module.exports = isStream
module.exports.isReadable = isReadable
module.exports.isWritable = isWritable
module.exports.isDuplex = isDuplex
//
},
'is-typedarray':
function(module) {
//
module.exports = isTypedArray
isTypedArray.strict = isStrictTypedArray
isTypedArray.loose = isLooseTypedArray

var toString = Object.prototype.toString
var names = {
  '[object Int8Array]': true,
  '[object Int16Array]': true,
  '[object Int32Array]': true,
  '[object Uint8Array]': true,
  '[object Uint8ClampedArray]': true,
  '[object Uint16Array]': true,
  '[object Uint32Array]': true,
  '[object Float32Array]': true,
  '[object Float64Array]': true
}

function isTypedArray(arr) {
  return isStrictTypedArray(arr) || isLooseTypedArray(arr)
}

function isStrictTypedArray(arr) {
  return (
    arr instanceof Int8Array ||
    arr instanceof Int16Array ||
    arr instanceof Int32Array ||
    arr instanceof Uint8Array ||
    arr instanceof Uint8ClampedArray ||
    arr instanceof Uint16Array ||
    arr instanceof Uint32Array ||
    arr instanceof Float32Array ||
    arr instanceof Float64Array
  )
}

function isLooseTypedArray(arr) {
  return names[toString.call(arr)]
}
//
},
'request/lib/getProxyFromURI':
function(module) {
//
function formatHostname(hostname) {
  return hostname.replace(/^\.*/, '.').toLowerCase()
}

function parseNoProxyZone(zone) {
  var zoneParts = (zone = zone.trim().toLowerCase()).split(':', 2)

  return {hostname: formatHostname(zoneParts[0]), port: zoneParts[1], hasPort: zone.indexOf(':') > -1}
}

function uriInNoProxy(uri, noProxy) {
  var port = uri.port || (uri.protocol === 'https:' ? '443' : '80'),
    hostname = formatHostname(uri.hostname)

  return noProxy.split(',').map(parseNoProxyZone).some(function(noProxyZone) {
    var isMatchedAt = hostname.indexOf(noProxyZone.hostname),
      hostnameMatched = isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length

    return noProxyZone.hasPort ? port === noProxyZone.port && hostnameMatched : hostnameMatched
  })
}

function getProxyFromURI(uri) {
  var noProxy = process.env.NO_PROXY || process.env.no_proxy || ''

  return noProxy === '*' || (noProxy !== '' && uriInNoProxy(uri, noProxy))
    ? null
    : uri.protocol === 'http:'
    ? process.env.HTTP_PROXY || process.env.http_proxy || null
    : (uri.protocol === 'https:' &&
        (process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy)) ||
      null
}

module.exports = getProxyFromURI
//
},
'request/lib/querystring':
function(module, exports, __wpreq__) {
//
var qs = __wpreq__('qs'),
  querystring = __wpreq__('querystring')

function Querystring(request) {
  this.request = request
  this.lib = null
  this.useQuerystring = null
  this.parseOptions = null
  this.stringifyOptions = null
}

Querystring.prototype.init = function(options) {
  if (this.lib) return

  this.useQuerystring = options.useQuerystring
  this.lib = this.useQuerystring ? querystring : qs

  this.parseOptions = options.qsParseOptions || {}
  this.stringifyOptions = options.qsStringifyOptions || {}
}

Querystring.prototype.stringify = function(obj) {
  return this.useQuerystring
    ? this.rfc3986(this.lib.stringify(
        obj,
        this.stringifyOptions.sep || null,
        this.stringifyOptions.eq || null,
        this.stringifyOptions
      ))
    : this.lib.stringify(obj, this.stringifyOptions)
}

Querystring.prototype.parse = function(str) {
  return this.useQuerystring
    ? this.lib.parse(str, this.parseOptions.sep || null, this.parseOptions.eq || null, this.parseOptions)
    : this.lib.parse(str, this.parseOptions)
}

Querystring.prototype.rfc3986 = function(str) {
  return str.replace(/[!'()*]/g, function(c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

Querystring.prototype.unescape = querystring.unescape

exports.Querystring = Querystring
//
},
qs:
function(module, exports, __wpreq__) {
//
var stringify = __wpreq__('qs/lib/stringify'),
  parse = __wpreq__('qs/lib/parse'),
  formats = __wpreq__('qs/lib/formats');

module.exports = {
  formats: formats,
  parse: parse,
  stringify: stringify
};
//
},
'qs/lib/stringify':
function(module, exports, __wpreq__) {
//
var utils = __wpreq__('qs/lib/utils'),
  formats = __wpreq__('qs/lib/formats');

var arrayPrefixGenerators = {
  brackets: function(prefix) {
    return prefix + '[]';
  },
  indices: function(prefix, key) {
    return prefix + '[' + key + ']';
  },
  repeat: function(prefix) {
    return prefix;
  }
};

var toISO = Date.prototype.toISOString;

var defaults = {
  delimiter: '&',
  encode: true,
  encoder: utils.encode,
  encodeValuesOnly: false,
  serializeDate: function(date) {
    return toISO.call(date);
  },
  skipNulls: false,
  strictNullHandling: false
};

var stringify = function stringify(
  object,
  prefix,
  generateArrayPrefix,
  strictNullHandling,
  skipNulls,
  encoder,
  filter,
  sort,
  allowDots,
  serializeDate,
  formatter,
  encodeValuesOnly
) {
  var obj = object;
  if (typeof filter == 'function') obj = filter(prefix, obj);
  else if (obj instanceof Date) obj = serializeDate(obj);
  else if (obj === null) {
    if (strictNullHandling) return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;

    obj = '';
  }

  if (typeof obj == 'string' || typeof obj == 'number' || typeof obj == 'boolean' || utils.isBuffer(obj))
    return encoder
      ? [
          formatter(encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder)) +
            '=' + formatter(encoder(obj, defaults.encoder))
        ]
      : [formatter(prefix) + '=' + formatter(String(obj))];

  var objKeys,
    values = [];

  if (obj === void 0) return values;

  if (Array.isArray(filter)) objKeys = filter;
  else {
    var keys = Object.keys(obj);
    objKeys = sort ? keys.sort(sort) : keys;
  }

  for (var i = 0; i < objKeys.length; ++i) {
    var key = objKeys[i];

    if (skipNulls && obj[key] === null) continue;

    values = Array.isArray(obj)
    ? values.concat(stringify(
        obj[key],
        generateArrayPrefix(prefix, key),
        generateArrayPrefix,
        strictNullHandling,
        skipNulls,
        encoder,
        filter,
        sort,
        allowDots,
        serializeDate,
        formatter,
        encodeValuesOnly
      ))
    : values.concat(stringify(
        obj[key],
        prefix + (allowDots ? '.' + key : '[' + key + ']'),
        generateArrayPrefix,
        strictNullHandling,
        skipNulls,
        encoder,
        filter,
        sort,
        allowDots,
        serializeDate,
        formatter,
        encodeValuesOnly
      ));
  }

  return values;
};

module.exports = function(object, opts) {
  var obj = object,
    options = opts ? utils.assign({}, opts) : {};

  if (options.encoder !== null && options.encoder !== void 0 && typeof options.encoder != 'function')
    throw new TypeError('Encoder has to be a function.');

  var delimiter = options.delimiter === void 0 ? defaults.delimiter : options.delimiter,
    strictNullHandling =
      typeof options.strictNullHandling == 'boolean' ? options.strictNullHandling : defaults.strictNullHandling,
    skipNulls = typeof options.skipNulls == 'boolean' ? options.skipNulls : defaults.skipNulls,
    encode = typeof options.encode == 'boolean' ? options.encode : defaults.encode,
    encoder = typeof options.encoder == 'function' ? options.encoder : defaults.encoder,
    sort = typeof options.sort == 'function' ? options.sort : null,
    allowDots = options.allowDots !== void 0 && options.allowDots,
    serializeDate = typeof options.serializeDate == 'function' ? options.serializeDate : defaults.serializeDate,
    encodeValuesOnly =
      typeof options.encodeValuesOnly == 'boolean' ? options.encodeValuesOnly : defaults.encodeValuesOnly;
  if (options.format === void 0) options.format = formats.default;
  else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format))
    throw new TypeError('Unknown format option provided.');

  var objKeys,
    filter,
    formatter = formats.formatters[options.format];

  if (typeof options.filter == 'function') obj = (filter = options.filter)('', obj);
  else if (Array.isArray(options.filter)) objKeys = filter = options.filter;

  var keys = [];

  if (typeof obj != 'object' || obj === null) return '';

  var arrayFormat =
    options.arrayFormat in arrayPrefixGenerators
      ? options.arrayFormat
      : 'indices' in options
      ? (options.indices ? 'indices' : 'repeat')
      : 'indices';

  var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

  objKeys || (objKeys = Object.keys(obj));

  sort && objKeys.sort(sort);

  for (var i = 0; i < objKeys.length; ++i) {
    var key = objKeys[i];

    if (skipNulls && obj[key] === null) continue;

    keys = keys.concat(stringify(
      obj[key],
      key,
      generateArrayPrefix,
      strictNullHandling,
      skipNulls,
      encode ? encoder : null,
      filter,
      sort,
      allowDots,
      serializeDate,
      formatter,
      encodeValuesOnly
    ));
  }

  var joined = keys.join(delimiter),
    prefix = options.addQueryPrefix === true ? '?' : '';

  return joined.length > 0 ? prefix + joined : '';
};
//
},
'qs/lib/utils':
function(module) {
//
var has = Object.prototype.hasOwnProperty;

var hexTable = (function() {
  var array = [];
  for (var i = 0; i < 256; ++i) array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());

  return array;
})();

var compactQueue = function(queue) {
  var obj;

  while (queue.length) {
    var item = queue.pop();
    obj = item.obj[item.prop];

    if (Array.isArray(obj)) {
      var compacted = [];

      for (var j = 0; j < obj.length; ++j) obj[j] === void 0 || compacted.push(obj[j]);

      item.obj[item.prop] = compacted;
    }
  }

  return obj;
};

var arrayToObject = function(source, options) {
  var obj = options && options.plainObjects ? Object.create(null) : {};
  for (var i = 0; i < source.length; ++i) if (source[i] !== void 0) obj[i] = source[i];

  return obj;
};

var merge = function merge(target, source, options) {
  if (!source) return target;

  if (typeof source != 'object') {
    if (Array.isArray(target)) target.push(source);
    else if (typeof target != 'object') return [target, source];
    else if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source))
      target[source] = true;

    return target;
  }

  if (typeof target != 'object') return [target].concat(source);

  var mergeTarget = target;
  if (Array.isArray(target) && !Array.isArray(source)) mergeTarget = arrayToObject(target, options);

  if (Array.isArray(target) && Array.isArray(source)) {
    source.forEach(function(item, i) {
      has.call(target, i)
        ? target[i] && typeof target[i] == 'object'
          ? (target[i] = merge(target[i], item, options))
          : target.push(item)
        : (target[i] = item);
    });
    return target;
  }

  return Object.keys(source).reduce(function(acc, key) {
    var value = source[key];

    has.call(acc, key) ? (acc[key] = merge(acc[key], value, options)) : (acc[key] = value);

    return acc;
  }, mergeTarget);
};

var assign = function(target, source) {
  return Object.keys(source).reduce(function(acc, key) {
    acc[key] = source[key];
    return acc;
  }, target);
};

var decode = function(str) {
  try {
    return decodeURIComponent(str.replace(/\+/g, ' '));
  } catch (_e) {
    return str;
  }
};

var encode = function(str) {
  if (str.length === 0) return str;

  var out = '';
  for (var string = typeof str == 'string' ? str : String(str), i = 0; i < string.length; ++i) {
    var c = string.charCodeAt(i);

    if (
      c === 0x2D ||
      c === 0x2E ||
      c === 0x5F ||
      c === 0x7E ||
      (c >= 0x30 && c <= 0x39) ||
      (c >= 0x41 && c <= 0x5A) ||
      (c >= 0x61 && c <= 0x7A)
    )
      out += string.charAt(i);
    else if (c < 0x80) out += hexTable[c];
    else if (c < 0x800) out += hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)];
    else if (c < 0xD800 || c >= 0xE000)
      out += hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)];
    else {
      i += 1;
      c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
      out +=
        hexTable[0xF0 | (c >> 18)] +
        hexTable[0x80 | ((c >> 12) & 0x3F)] +
        hexTable[0x80 | ((c >> 6) & 0x3F)] +
        hexTable[0x80 | (c & 0x3F)];
    }
  }

  return out;
};

var compact = function(value) {
  var queue = [{obj: {o: value}, prop: 'o'}];

  for (var refs = [], i = 0; i < queue.length; ++i)
    for (var item = queue[i], obj = item.obj[item.prop], keys = Object.keys(obj), j = 0; j < keys.length; ++j) {
      var key = keys[j],
        val = obj[key];
      if (typeof val == 'object' && val !== null && refs.indexOf(val) < 0) {
        queue.push({obj: obj, prop: key});
        refs.push(val);
      }
    }

  return compactQueue(queue);
};

var isRegExp = function(obj) {
  return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function(obj) {
  return (
    obj !== null && obj !== void 0 && !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj))
  );
};

module.exports = {
  arrayToObject: arrayToObject,
  assign: assign,
  compact: compact,
  decode: decode,
  encode: encode,
  isBuffer: isBuffer,
  isRegExp: isRegExp,
  merge: merge
};
//
},
'qs/lib/formats':
function(module) {
//
var replace = String.prototype.replace,
  percentTwenties = /%20/g;

module.exports = {
  default: 'RFC3986',
  formatters: {
    RFC1738: function(value) {
      return replace.call(value, percentTwenties, '+');
    },
    RFC3986: function(value) {
      return value;
    }
  },
  RFC1738: 'RFC1738',
  RFC3986: 'RFC3986'
};
//
},
'qs/lib/parse':
function(module, exports, __wpreq__) {
//
var utils = __wpreq__('qs/lib/utils'),

  has = Object.prototype.hasOwnProperty;

var defaults = {
  allowDots: false,
  allowPrototypes: false,
  arrayLimit: 20,
  decoder: utils.decode,
  delimiter: '&',
  depth: 5,
  parameterLimit: 1000,
  plainObjects: false,
  strictNullHandling: false
};

var parseValues = function(str, options) {
  var obj = {},
    cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str,
    limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit,
    parts = cleanStr.split(options.delimiter, limit);

  for (var i = 0; i < parts.length; ++i) {
    var part = parts[i],

      bracketEqualsPos = part.indexOf(']='),
      pos = bracketEqualsPos < 0 ? part.indexOf('=') : bracketEqualsPos + 1;

    var key, val;
    if (pos < 0) {
      key = options.decoder(part, defaults.decoder);
      val = options.strictNullHandling ? null : '';
    } else {
      key = options.decoder(part.slice(0, pos), defaults.decoder);
      val = options.decoder(part.slice(pos + 1), defaults.decoder);
    }

    has.call(obj, key) ? (obj[key] = [].concat(obj[key]).concat(val)) : (obj[key] = val);
  }

  return obj;
};

var parseObject = function(chain, val, options) {
  var leaf = val;

  for (var i = chain.length - 1; i >= 0; --i) {
    var obj,
      root = chain[i];

    if (root === '[]') obj = (obj = []).concat(leaf);
    else {
      obj = options.plainObjects ? Object.create(null) : {};
      var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root,
        index = parseInt(cleanRoot, 10);

      !isNaN(index) &&
      root !== cleanRoot &&
      String(index) === cleanRoot &&
      index >= 0 &&
      options.parseArrays && index <= options.arrayLimit
        ? ((obj = [])[index] = leaf)
        : (obj[cleanRoot] = leaf);
    }

    leaf = obj;
  }

  return leaf;
};

var parseKeys = function(givenKey, val, options) {
  if (!givenKey) return;

  var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey,

    child = /(\[[^[\]]*])/g,

    segment = /(\[[^[\]]*])/.exec(key),
    parent = segment ? key.slice(0, segment.index) : key,

    keys = [];
  if (parent) {
    if (!options.plainObjects && has.call(Object.prototype, parent) && !options.allowPrototypes) return;

    keys.push(parent);
  }

  for (var i = 0; (segment = child.exec(key)) !== null && i < options.depth; ) {
    i += 1;
    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1)) && !options.allowPrototypes)
      return;

    keys.push(segment[1]);
  }

  segment && keys.push('[' + key.slice(segment.index) + ']');

  return parseObject(keys, val, options);
};

module.exports = function(str, opts) {
  var options = opts ? utils.assign({}, opts) : {};

  if (options.decoder !== null && options.decoder !== void 0 && typeof options.decoder != 'function')
    throw new TypeError('Decoder has to be a function.');

  options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
  options.delimiter =
    typeof options.delimiter == 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
  options.depth = typeof options.depth == 'number' ? options.depth : defaults.depth;
  options.arrayLimit = typeof options.arrayLimit == 'number' ? options.arrayLimit : defaults.arrayLimit;
  options.parseArrays = options.parseArrays !== false;
  options.decoder = typeof options.decoder == 'function' ? options.decoder : defaults.decoder;
  options.allowDots = typeof options.allowDots == 'boolean' ? options.allowDots : defaults.allowDots;
  options.plainObjects = typeof options.plainObjects == 'boolean' ? options.plainObjects : defaults.plainObjects;
  options.allowPrototypes =
    typeof options.allowPrototypes == 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
  options.parameterLimit = typeof options.parameterLimit == 'number' ? options.parameterLimit : defaults.parameterLimit;
  options.strictNullHandling =
    typeof options.strictNullHandling == 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;

  if (str === '' || str === null || str === void 0) return options.plainObjects ? Object.create(null) : {};

  var tempObj = typeof str == 'string' ? parseValues(str, options) : str,
    obj = options.plainObjects ? Object.create(null) : {};

  for (var keys = Object.keys(tempObj), i = 0; i < keys.length; ++i) {
    var key = keys[i],
      newObj = parseKeys(key, tempObj[key], options);
    obj = utils.merge(obj, newObj, options);
  }

  return utils.compact(obj);
};
//
},
'request/lib/har':
function(module, exports, __wpreq__) {
//
var fs = __wpreq__('fs'),
  qs = __wpreq__('querystring'),
  validate = __wpreq__('har-validator'),
  extend = __wpreq__('extend')

function Har(request) {
  this.request = request
}

Har.prototype.reducer = function(obj, pair) {
  if (obj[pair.name] === void 0) {
    obj[pair.name] = pair.value
    return obj
  }

  obj[pair.name] = [obj[pair.name], pair.value]

  return obj
}

Har.prototype.prep = function(data) {
  data.queryObj = {}
  data.headersObj = {}
  data.postData.jsonObj = false
  data.postData.paramsObj = false

  if (data.queryString && data.queryString.length) data.queryObj = data.queryString.reduce(this.reducer, {})

  if (data.headers && data.headers.length)
    data.headersObj = data.headers.reduceRight(function(headers, header) {
      headers[header.name] = header.value
      return headers
    }, {})

  if (data.cookies && data.cookies.length) {
    var cookies = data.cookies.map(function(cookie) {
      return cookie.name + '=' + cookie.value
    })

    if (cookies.length) data.headersObj.cookie = cookies.join('; ')
  }

  function some(arr) {
    return arr.some(function(type) {
      return data.postData.mimeType.indexOf(type) === 0
    })
  }

  if (some(['multipart/mixed', 'multipart/related', 'multipart/form-data', 'multipart/alternative']))
    data.postData.mimeType = 'multipart/form-data'
  else if (some(['application/x-www-form-urlencoded']))
    if (data.postData.params) {
      data.postData.paramsObj = data.postData.params.reduce(this.reducer, {})

      data.postData.text = qs.stringify(data.postData.paramsObj)
    } else data.postData.text = ''
  else if (some(['text/json', 'text/x-json', 'application/json', 'application/x-json'])) {
    data.postData.mimeType = 'application/json'

    if (data.postData.text)
      try {
        data.postData.jsonObj = JSON.parse(data.postData.text)
      } catch (e) {
        this.request.debug(e)

        data.postData.mimeType = 'text/plain'
      }
  }

  return data
}

Har.prototype.options = function(options) {
  if (!options.har) return options

  var har = {}
  extend(har, options.har)

  if (har.log && har.log.entries) har = har.log.entries[0]

  har.url = har.url || options.url || options.uri || options.baseUrl || '/'
  har.httpVersion = har.httpVersion || 'HTTP/1.1'
  har.queryString = har.queryString || []
  har.headers = har.headers || []
  har.cookies = har.cookies || []
  har.postData = har.postData || {}
  har.postData.mimeType = har.postData.mimeType || 'application/octet-stream'

  har.bodySize = 0
  har.headersSize = 0
  har.postData.size = 0

  if (!validate.request(har)) return options

  var req = this.prep(har)

  if (req.url) options.url = req.url

  if (req.method) options.method = req.method

  if (Object.keys(req.queryObj).length) options.qs = req.queryObj

  if (Object.keys(req.headersObj).length) options.headers = req.headersObj

  function test(type) {
    return req.postData.mimeType.indexOf(type) === 0
  }

  if (test('application/x-www-form-urlencoded')) options.form = req.postData.paramsObj
  else if (test('application/json')) {
    if (req.postData.jsonObj) {
      options.body = req.postData.jsonObj
      options.json = true
    }
  } else if (test('multipart/form-data')) {
    options.formData = {}

    req.postData.params.forEach(function(param) {
      var attachment = {}

      if (param.fileName || param.fileName || param.contentType) {
        if (param.fileName && !param.value) attachment.value = fs.createReadStream(param.fileName)
        else if (param.value) attachment.value = param.value

        if (param.fileName)
          attachment.options = {filename: param.fileName, contentType: param.contentType ? param.contentType : null}

        options.formData[param.name] = attachment
      } else options.formData[param.name] = param.value
    })
  } else if (req.postData.text) options.body = req.postData.text

  return options
}

exports.Har = Har
//
},
'har-validator':
function(module, exports, __wpreq__) {
//
var ajv,
  Ajv = __wpreq__('ajv'),
  HARError = __wpreq__('har-validator/lib/error'),
  schemas = __wpreq__('har-schema')

function validate(name, data) {
  data = data || {}

  var validate = (ajv = ajv || new Ajv({allErrors: true, schemas: schemas})).getSchema(name + '.json')

  return new Promise(function(resolve, reject) {
    validate(data) ? resolve(data) : reject(new HARError(validate.errors))
  })
}

Object.keys(schemas).forEach(name => {
  exports[name] = data => validate(name, data)
})
//
},
ajv:
function(module, exports, __wpreq__) {
//
var compileSchema = __wpreq__('ajv/lib/compile'),
  resolve = __wpreq__('ajv/lib/compile/resolve'),
  Cache = __wpreq__('ajv/lib/cache'),
  SchemaObject = __wpreq__('ajv/lib/compile/schema_obj'),
  stableStringify = __wpreq__('fast-json-stable-stringify'),
  formats = __wpreq__('ajv/lib/compile/formats'),
  rules = __wpreq__('ajv/lib/compile/rules'),
  $dataMetaSchema = __wpreq__('ajv/lib/$data'),
  patternGroups = __wpreq__('ajv/lib/patternGroups'),
  util = __wpreq__('ajv/lib/compile/util'),
  co = __wpreq__('co');

module.exports = Ajv;

Ajv.prototype.validate = validate;
Ajv.prototype.compile = compile;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;

Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;

Ajv.prototype.compileAsync = __wpreq__('ajv/lib/compile/async');
var customKeyword = __wpreq__('ajv/lib/keyword');
Ajv.prototype.addKeyword = customKeyword.add;
Ajv.prototype.getKeyword = customKeyword.get;
Ajv.prototype.removeKeyword = customKeyword.remove;

var errorClasses = __wpreq__('ajv/lib/compile/error_classes');
Ajv.ValidationError = errorClasses.Validation;
Ajv.MissingRefError = errorClasses.MissingRef;
Ajv.$dataMetaSchema = $dataMetaSchema;

var META_SCHEMA_ID = 'http://json-schema.org/draft-06/schema',

  META_IGNORE_OPTIONS = ['removeAdditional', 'useDefaults', 'coerceTypes'],
  META_SUPPORT_DATA = ['/properties'];

function Ajv(opts) {
  if (!(this instanceof Ajv)) return new Ajv(opts);
  opts = this._opts = util.copy(opts) || {};
  setLogger(this);
  this._schemas = {};
  this._refs = {};
  this._fragments = {};
  this._formats = formats(opts.format);
  var schemaUriFormat = (this._schemaUriFormat = this._formats['uri-reference']);
  this._schemaUriFormatFunc = function(str) { return schemaUriFormat.test(str); };

  this._cache = opts.cache || new Cache();
  this._loadingSchemas = {};
  this._compilations = [];
  this.RULES = rules();
  this._getId = chooseGetId(opts);

  opts.loopRequired = opts.loopRequired || Infinity;
  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
  if (opts.serialize === void 0) opts.serialize = stableStringify;
  this._metaOpts = getMetaSchemaOptions(this);

  opts.formats && addInitialFormats(this);
  addDraft6MetaSchema(this);
  typeof opts.meta != 'object' || this.addMetaSchema(opts.meta);
  addInitialSchemas(this);
  opts.patternGroups && patternGroups(this);
}

function validate(schemaKeyRef, data) {
  var v;
  if (typeof schemaKeyRef == 'string') {
    if (!(v = this.getSchema(schemaKeyRef))) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
  } else {
    var schemaObj = this._addSchema(schemaKeyRef);
    v = schemaObj.validate || this._compile(schemaObj);
  }

  var valid = v(data);
  if (v.$async === true) return this._opts.async == '*' ? co(valid) : valid;
  this.errors = v.errors;
  return valid;
}

function compile(schema, _meta) {
  var schemaObj = this._addSchema(schema, void 0, _meta);
  return schemaObj.validate || this._compile(schemaObj);
}

function addSchema(schema, key, _skipValidation, _meta) {
  if (Array.isArray(schema)) {
    for (var i = 0; i < schema.length; i++) this.addSchema(schema[i], void 0, _skipValidation, _meta);
    return this;
  }
  var id = this._getId(schema);
  if (id !== void 0 && typeof id != 'string') throw new Error('schema id must be string');
  checkUnique(this, (key = resolve.normalizeId(key || id)));
  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
  return this;
}

function addMetaSchema(schema, key, skipValidation) {
  this.addSchema(schema, key, skipValidation, true);
  return this;
}

function validateSchema(schema, throwOrLogError) {
  var $schema = schema.$schema;
  if ($schema !== void 0 && typeof $schema != 'string') throw new Error('$schema must be a string');
  if (!($schema = $schema || this._opts.defaultMeta || defaultMeta(this))) {
    this.logger.warn('meta-schema not available');
    this.errors = null;
    return true;
  }
  var valid,
    currentUriFormat = this._formats.uri;
  this._formats.uri = typeof currentUriFormat == 'function' ? this._schemaUriFormatFunc : this._schemaUriFormat;
  try {
    valid = this.validate($schema, schema);
  } finally {
    this._formats.uri = currentUriFormat;
  }
  if (!valid && throwOrLogError) {
    var message = 'schema is invalid: ' + this.errorsText();
    if (this._opts.validateSchema != 'log') throw new Error(message);
    this.logger.error(message);
  }
  return valid;
}

function defaultMeta(self) {
  var meta = self._opts.meta;
  self._opts.defaultMeta =
    typeof meta == 'object' ? self._getId(meta) || meta : self.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
  return self._opts.defaultMeta;
}

function getSchema(keyRef) {
  var schemaObj = _getSchemaObj(this, keyRef);
  switch (typeof schemaObj) {
    case 'object': return schemaObj.validate || this._compile(schemaObj);
    case 'string': return this.getSchema(schemaObj);
    case 'undefined': return _getSchemaFragment(this, keyRef);
  }
}

function _getSchemaFragment(self, ref) {
  var res = resolve.schema.call(self, {schema: {}}, ref);
  if (res) {
    var schema = res.schema,
      root = res.root,
      baseId = res.baseId,
      v = compileSchema.call(self, schema, root, void 0, baseId);
    self._fragments[ref] = new SchemaObject({
      ref: ref,
      fragment: true,
      schema: schema,
      root: root,
      baseId: baseId,
      validate: v
    });
    return v;
  }
}

function _getSchemaObj(self, keyRef) {
  keyRef = resolve.normalizeId(keyRef);
  return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
}

function removeSchema(schemaKeyRef) {
  if (schemaKeyRef instanceof RegExp) {
    _removeAllSchemas(this, this._schemas, schemaKeyRef);
    _removeAllSchemas(this, this._refs, schemaKeyRef);
    return this;
  }
  switch (typeof schemaKeyRef) {
    case 'undefined':
      _removeAllSchemas(this, this._schemas);
      _removeAllSchemas(this, this._refs);
      this._cache.clear();
      return this;
    case 'string':
      var schemaObj = _getSchemaObj(this, schemaKeyRef);
      schemaObj && this._cache.del(schemaObj.cacheKey);
      delete this._schemas[schemaKeyRef];
      delete this._refs[schemaKeyRef];
      return this;
    case 'object':
      var serialize = this._opts.serialize,
        cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
      this._cache.del(cacheKey);
      var id = this._getId(schemaKeyRef);
      if (id) {
        id = resolve.normalizeId(id);
        delete this._schemas[id];
        delete this._refs[id];
      }
  }
  return this;
}

function _removeAllSchemas(self, schemas, regex) {
  for (var keyRef in schemas) {
    var schemaObj = schemas[keyRef];
    if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
      self._cache.del(schemaObj.cacheKey);
      delete schemas[keyRef];
    }
  }
}

function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
  if (typeof schema != 'object' && typeof schema != 'boolean') throw new Error('schema should be object or boolean');
  var serialize = this._opts.serialize,
    cacheKey = serialize ? serialize(schema) : schema,
    cached = this._cache.get(cacheKey);
  if (cached) return cached;

  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;

  var id = resolve.normalizeId(this._getId(schema));
  id && shouldAddSchema && checkUnique(this, id);

  var recursiveMeta,
    willValidate = this._opts.validateSchema !== false && !skipValidation;
  !willValidate || (recursiveMeta = id && id == resolve.normalizeId(schema.$schema)) ||
    this.validateSchema(schema, true);

  var localRefs = resolve.ids.call(this, schema),

    schemaObj = new SchemaObject({id: id, schema: schema, localRefs: localRefs, cacheKey: cacheKey, meta: meta});

  if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;
  this._cache.put(cacheKey, schemaObj);

  willValidate && recursiveMeta && this.validateSchema(schema, true);

  return schemaObj;
}

function _compile(schemaObj, root) {
  if (schemaObj.compiling) {
    schemaObj.validate = callValidate;
    callValidate.schema = schemaObj.schema;
    callValidate.errors = null;
    callValidate.root = root || callValidate;
    if (schemaObj.schema.$async === true) callValidate.$async = true;
    return callValidate;
  }
  schemaObj.compiling = true;

  var currentOpts, v;
  if (schemaObj.meta) {
    currentOpts = this._opts;
    this._opts = this._metaOpts;
  }

  try {
    v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
  } finally {
    schemaObj.compiling = false;
    if (schemaObj.meta) this._opts = currentOpts;
  }

  schemaObj.validate = v;
  schemaObj.refs = v.refs;
  schemaObj.refVal = v.refVal;
  schemaObj.root = v.root;
  return v;

  function callValidate() {
    var _validate = schemaObj.validate,
      result = _validate.apply(null, arguments);
    callValidate.errors = _validate.errors;
    return result;
  }
}

function chooseGetId(opts) {
  switch (opts.schemaId) {
    case '$id': return _get$Id;
    case 'id': return _getId;
    default: return _get$IdOrId;
  }
}

function _getId(schema) {
  schema.$id && this.logger.warn('schema $id ignored', schema.$id);
  return schema.id;
}

function _get$Id(schema) {
  schema.id && this.logger.warn('schema id ignored', schema.id);
  return schema.$id;
}

function _get$IdOrId(schema) {
  if (schema.$id && schema.id && schema.$id != schema.id) throw new Error('schema $id is different from id');
  return schema.$id || schema.id;
}

function errorsText(errors, options) {
  if (!(errors = errors || this.errors)) return 'No errors';
  var separator = (options = options || {}).separator === void 0 ? ', ' : options.separator,
    dataVar = options.dataVar === void 0 ? 'data' : options.dataVar,

    text = '';
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
  }
  return text.slice(0, -separator.length);
}

function addFormat(name, format) {
  if (typeof format == 'string') format = new RegExp(format);
  this._formats[name] = format;
  return this;
}

function addDraft6MetaSchema(self) {
  var $dataSchema;
  if (self._opts.$data) {
    $dataSchema = __wpreq__('ajv/lib/refs/$data.json');
    self.addMetaSchema($dataSchema, $dataSchema.$id, true);
  }
  if (self._opts.meta === false) return;
  var metaSchema = __wpreq__('ajv/lib/refs/json-schema-draft-06.json');
  if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
  self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
  self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
}

function addInitialSchemas(self) {
  var optsSchemas = self._opts.schemas;
  if (optsSchemas)
    if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
    else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
}

function addInitialFormats(self) {
  for (var name in self._opts.formats) {
    var format = self._opts.formats[name];
    self.addFormat(name, format);
  }
}

function checkUnique(self, id) {
  if (self._schemas[id] || self._refs[id]) throw new Error('schema with key or id "' + id + '" already exists');
}

function getMetaSchemaOptions(self) {
  var metaOpts = util.copy(self._opts);
  for (var i = 0; i < META_IGNORE_OPTIONS.length; i++) delete metaOpts[META_IGNORE_OPTIONS[i]];
  return metaOpts;
}

function setLogger(self) {
  var logger = self._opts.logger;
  if (logger === false) self.logger = {log: noop, warn: noop, error: noop};
  else {
    if (logger === void 0) logger = console;
    if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error))
      throw new Error('logger must implement log, warn and error methods');
    self.logger = logger;
  }
}

function noop() {}
//
},
'ajv/lib/compile':
function(module, exports, __wpreq__) {
//
var resolve = __wpreq__('ajv/lib/compile/resolve'),
  util = __wpreq__('ajv/lib/compile/util'),
  errorClasses = __wpreq__('ajv/lib/compile/error_classes'),
  stableStringify = __wpreq__('fast-json-stable-stringify'),

  validateGenerator = __wpreq__('ajv/lib/dotjs/validate'),

  co = __wpreq__('co'),
  ucs2length = util.ucs2length,
  equal = __wpreq__('fast-deep-equal'),

  ValidationError = errorClasses.Validation;

module.exports = compile;

function compile(schema, root, localRefs, baseId) {
  var self = this,
    opts = this._opts,
    refVal = [void 0],
    refs = {},
    patterns = [],
    patternsHash = {},
    defaults = [],
    defaultsHash = {},
    customRules = [];

  root = root || {schema: schema, refVal: refVal, refs: refs};

  var c = checkCompiling.call(this, schema, root, baseId),
    compilation = this._compilations[c.index];
  if (c.compiling) return (compilation.callValidate = callValidate);

  var formats = this._formats,
    RULES = this.RULES;

  try {
    var v = localCompile(schema, root, localRefs, baseId);
    compilation.validate = v;
    var cv = compilation.callValidate;
    if (cv) {
      cv.schema = v.schema;
      cv.errors = null;
      cv.refs = v.refs;
      cv.refVal = v.refVal;
      cv.root = v.root;
      cv.$async = v.$async;
      if (opts.sourceCode) cv.source = v.source;
    }
    return v;
  } finally {
    endCompiling.call(this, schema, root, baseId);
  }

  function callValidate() {
    var validate = compilation.validate,
      result = validate.apply(null, arguments);
    callValidate.errors = validate.errors;
    return result;
  }

  function localCompile(_schema, _root, localRefs, baseId) {
    var isRoot = !_root || (_root && _root.schema == _schema);
    if (_root.schema != root.schema) return compile.call(self, _schema, _root, localRefs, baseId);

    var $async = _schema.$async === true;

    var sourceCode = validateGenerator({
      isTop: true,
      schema: _schema,
      isRoot: isRoot,
      baseId: baseId,
      root: _root,
      schemaPath: '',
      errSchemaPath: '#',
      errorPath: '""',
      MissingRefError: errorClasses.MissingRef,
      RULES: RULES,
      validate: validateGenerator,
      util: util,
      resolve: resolve,
      resolveRef: resolveRef,
      usePattern: usePattern,
      useDefault: useDefault,
      useCustomRule: useCustomRule,
      opts: opts,
      formats: formats,
      logger: self.logger,
      self: self
    });

    sourceCode =
      vars(refVal, refValCode) + vars(patterns, patternCode) +
      vars(defaults, defaultCode) + vars(customRules, customRuleCode) +
      sourceCode;

    if (opts.processCode) sourceCode = opts.processCode(sourceCode);
    var validate;
    try {
      validate = new Function(
        'self',
        'RULES',
        'formats',
        'root',
        'refVal',
        'defaults',
        'customRules',
        'co',
        'equal',
        'ucs2length',
        'ValidationError',
        sourceCode
      )(self, RULES, formats, root, refVal, defaults, customRules, co, equal, ucs2length, ValidationError);

      refVal[0] = validate;
    } catch (e) {
      self.logger.error('Error compiling schema, function code:', sourceCode);
      throw e;
    }

    validate.schema = _schema;
    validate.errors = null;
    validate.refs = refs;
    validate.refVal = refVal;
    validate.root = isRoot ? validate : _root;
    if ($async) validate.$async = true;
    if (opts.sourceCode === true) validate.source = {code: sourceCode, patterns: patterns, defaults: defaults};

    return validate;
  }

  function resolveRef(baseId, ref, isRoot) {
    ref = resolve.url(baseId, ref);
    var _refVal, refCode,
      refIndex = refs[ref];
    if (refIndex !== void 0)
      return resolvedRef((_refVal = refVal[refIndex]), (refCode = 'refVal[' + refIndex + ']'));

    if (!isRoot && root.refs) {
      var rootRefId = root.refs[ref];
      if (rootRefId !== void 0)
        return resolvedRef((_refVal = root.refVal[rootRefId]), (refCode = addLocalRef(ref, _refVal)));
    }

    refCode = addLocalRef(ref);
    var v = resolve.call(self, localCompile, root, ref);
    if (v === void 0) {
      var localSchema = localRefs && localRefs[ref];
      if (localSchema)
        v = resolve.inlineRef(localSchema, opts.inlineRefs)
          ? localSchema
          : compile.call(self, localSchema, root, localRefs, baseId);
    }

    if (v !== void 0) {
      replaceLocalRef(ref, v);
      return resolvedRef(v, refCode);
    }
    removeLocalRef(ref);
  }

  function addLocalRef(ref, v) {
    var refId = refVal.length;
    refVal[refId] = v;
    refs[ref] = refId;
    return 'refVal' + refId;
  }

  function removeLocalRef(ref) {
    delete refs[ref];
  }

  function replaceLocalRef(ref, v) {
    var refId = refs[ref];
    refVal[refId] = v;
  }

  function resolvedRef(refVal, code) {
    return typeof refVal == 'object' || typeof refVal == 'boolean'
      ? {code: code, schema: refVal, inline: true}
      : {code: code, $async: refVal && refVal.$async};
  }

  function usePattern(regexStr) {
    var index = patternsHash[regexStr];
    if (index === void 0) {
      index = patternsHash[regexStr] = patterns.length;
      patterns[index] = regexStr;
    }
    return 'pattern' + index;
  }

  function useDefault(value) {
    switch (typeof value) {
      case 'boolean':
      case 'number':
        return '' + value;
      case 'string':
        return util.toQuotedString(value);
      case 'object':
        if (value === null) return 'null';
        var valueStr = stableStringify(value),
          index = defaultsHash[valueStr];
        if (index === void 0) {
          index = defaultsHash[valueStr] = defaults.length;
          defaults[index] = value;
        }
        return 'default' + index;
    }
  }

  function useCustomRule(rule, schema, parentSchema, it) {
    var validateSchema = rule.definition.validateSchema;
    if (validateSchema && self._opts.validateSchema !== false && !validateSchema(schema)) {
      var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
      if (self._opts.validateSchema != 'log') throw new Error(message);
      self.logger.error(message);
    }

    var validate,
      compile = rule.definition.compile,
      inline = rule.definition.inline,
      macro = rule.definition.macro;

    if (compile) validate = compile.call(self, schema, parentSchema, it);
    else if (macro) {
      validate = macro.call(self, schema, parentSchema, it);
      opts.validateSchema === false || self.validateSchema(validate, true);
    } else if (inline) validate = inline.call(self, it, rule.keyword, schema, parentSchema);
    else if (!(validate = rule.definition.validate)) return;

    if (validate === void 0) throw new Error('custom keyword "' + rule.keyword + '"failed to compile');

    var index = customRules.length;
    customRules[index] = validate;

    return {code: 'customRule' + index, validate: validate};
  }
}

function checkCompiling(schema, root, baseId) {
  var index = compIndex.call(this, schema, root, baseId);
  if (index >= 0) return {index: index, compiling: true};
  index = this._compilations.length;
  this._compilations[index] = {schema: schema, root: root, baseId: baseId};
  return {index: index, compiling: false};
}

function endCompiling(schema, root, baseId) {
  var i = compIndex.call(this, schema, root, baseId);
  i >= 0 && this._compilations.splice(i, 1);
}

function compIndex(schema, root, baseId) {
  for (var i = 0; i < this._compilations.length; i++) {
    var c = this._compilations[i];
    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
  }
  return -1;
}

function patternCode(i, patterns) {
  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
}

function defaultCode(i) {
  return 'var default' + i + ' = defaults[' + i + '];';
}

function refValCode(i, refVal) {
  return refVal[i] === void 0 ? '' : 'var refVal' + i + ' = refVal[' + i + '];';
}

function customRuleCode(i) {
  return 'var customRule' + i + ' = customRules[' + i + '];';
}

function vars(arr, statement) {
  if (!arr.length) return '';
  var code = '';
  for (var i = 0; i < arr.length; i++) code += statement(i, arr);
  return code;
}
//
},
'ajv/lib/compile/resolve':
function(module, exports, __wpreq__) {
//
var url = __wpreq__('url'),
  equal = __wpreq__('fast-deep-equal'),
  util = __wpreq__('ajv/lib/compile/util'),
  SchemaObject = __wpreq__('ajv/lib/compile/schema_obj'),
  traverse = __wpreq__('json-schema-traverse');

module.exports = resolve;

resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;

function resolve(compile, root, ref) {
  var refVal = this._refs[ref];
  if (typeof refVal == 'string') {
    if (!this._refs[refVal]) return resolve.call(this, compile, root, refVal);
    refVal = this._refs[refVal];
  }

  if ((refVal = refVal || this._schemas[ref]) instanceof SchemaObject)
    return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);

  var schema, v, baseId,
    res = resolveSchema.call(this, root, ref);
  if (res) {
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  }

  if (schema instanceof SchemaObject) v = schema.validate || compile.call(this, schema.schema, root, void 0, baseId);
  else if (schema !== void 0)
    v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root, void 0, baseId);

  return v;
}

function resolveSchema(root, ref) {
  var p = url.parse(ref, false, true),
    refPath = _getFullPath(p),
    baseId = getFullPath(this._getId(root.schema));
  if (refPath !== baseId) {
    var id = normalizeId(refPath),
      refVal = this._refs[id];
    if (typeof refVal == 'string') return resolveRecursive.call(this, root, refVal, p);
    if (refVal instanceof SchemaObject) {
      refVal.validate || this._compile(refVal);
      root = refVal;
    } else if ((refVal = this._schemas[id]) instanceof SchemaObject) {
      refVal.validate || this._compile(refVal);
      if (id == normalizeId(ref)) return {schema: refVal, root: root, baseId: baseId};
      root = refVal;
    } else return;

    if (!root.schema) return;
    baseId = getFullPath(this._getId(root.schema));
  }
  return getJsonPointer.call(this, p, baseId, root.schema, root);
}

function resolveRecursive(root, ref, parsedRef) {
  var res = resolveSchema.call(this, root, ref);
  if (res) {
    var schema = res.schema,
      baseId = res.baseId;
    root = res.root;
    var id = this._getId(schema);
    if (id) baseId = resolveUrl(baseId, id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  }
}

var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
function getJsonPointer(parsedRef, baseId, schema, root) {
  parsedRef.hash = parsedRef.hash || '';
  if (parsedRef.hash.slice(0, 2) != '#/') return;

  for (var parts = parsedRef.hash.split('/'), i = 1; i < parts.length; i++) {
    var part = parts[i];
    if (!part) continue;

    if ((schema = schema[(part = util.unescapeFragment(part))]) === void 0) break;
    var id;
    if (!PREVENT_SCOPE_CHANGE[part]) {
      if ((id = this._getId(schema))) baseId = resolveUrl(baseId, id);
      if (schema.$ref) {
        var $ref = resolveUrl(baseId, schema.$ref),
          res = resolveSchema.call(this, root, $ref);
        if (res) {
          schema = res.schema;
          root = res.root;
          baseId = res.baseId;
        }
      }
    }
  }
  if (schema !== void 0 && schema !== root.schema) return {schema: schema, root: root, baseId: baseId};
}

var SIMPLE_INLINED = util.toHash([
  'type', 'format', 'pattern',
  'maxLength', 'minLength',
  'maxProperties', 'minProperties',
  'maxItems', 'minItems',
  'maximum', 'minimum',
  'uniqueItems', 'multipleOf',
  'required', 'enum'
]);
function inlineRef(schema, limit) {
  return (
    limit !== false &&
    (limit === void 0 || limit === true ? checkNoRef(schema) : limit ? countKeys(schema) <= limit : void 0)
  );
}

function checkNoRef(schema) {
  var item;
  if (Array.isArray(schema)) {
    for (var i = 0; i < schema.length; i++)
      if (typeof (item = schema[i]) == 'object' && !checkNoRef(item)) return false;
  } else
    for (var key in schema) {
      if (key == '$ref') return false;
      if (typeof (item = schema[key]) == 'object' && !checkNoRef(item)) return false;
    }

  return true;
}

function countKeys(schema) {
  var item, count = 0;
  if (Array.isArray(schema))
    for (var i = 0; i < schema.length; i++) {
      if (typeof (item = schema[i]) == 'object') count += countKeys(item);
      if (count == Infinity) return Infinity;
    }
  else
    for (var key in schema) {
      if (key == '$ref') return Infinity;
      if (SIMPLE_INLINED[key]) count++;
      else {
        if (typeof (item = schema[key]) == 'object') count += countKeys(item) + 1;
        if (count == Infinity) return Infinity;
      }
    }

  return count;
}

function getFullPath(id, normalize) {
  if (normalize !== false) id = normalizeId(id);
  return _getFullPath(url.parse(id, false, true));
}

function _getFullPath(p) {
  var protocolSeparator = p.protocol || p.href.slice(0, 2) == '//' ? '//' : '';
  return (p.protocol || '') + protocolSeparator + (p.host || '') + (p.path || '') + '#';
}

var TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
}

function resolveUrl(baseId, id) {
  id = normalizeId(id);
  return url.resolve(baseId, id);
}

function resolveIds(schema) {
  var schemaId = normalizeId(this._getId(schema)),
    baseIds = {'': schemaId},
    fullPaths = {'': getFullPath(schemaId, false)},
    localRefs = {},
    self = this;

  traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (jsonPtr === '') return;
    var id = self._getId(sch),
      baseId = baseIds[parentJsonPtr],
      fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;
    if (keyIndex !== void 0)
      fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));

    if (typeof id == 'string') {
      id = baseId = normalizeId(baseId ? url.resolve(baseId, id) : id);

      var refVal = self._refs[id];
      if (typeof refVal == 'string') refVal = self._refs[refVal];
      if (refVal && refVal.schema) {
        if (!equal(sch, refVal.schema)) throw new Error('id "' + id + '" resolves to more than one schema');
      } else if (id != normalizeId(fullPath))
        if (id[0] == '#') {
          if (localRefs[id] && !equal(sch, localRefs[id]))
            throw new Error('id "' + id + '" resolves to more than one schema');
          localRefs[id] = sch;
        } else self._refs[id] = fullPath;
    }
    baseIds[jsonPtr] = baseId;
    fullPaths[jsonPtr] = fullPath;
  });

  return localRefs;
}
//
},
'fast-deep-equal':
function(module) {
//
var isArray = Array.isArray,
  keyList = Object.keys,
  hasProp = Object.prototype.hasOwnProperty;

module.exports = function equal(a, b) {
  if (a === b) return true;

  var i,
    length,
    key,
    arrA = isArray(a),
    arrB = isArray(b);

  if (arrA && arrB) {
    if ((length = a.length) != b.length) return false;
    for (i = 0; i < length; i++) if (!equal(a[i], b[i])) return false;
    return true;
  }

  if (arrA != arrB) return false;

  var dateA = a instanceof Date,
    dateB = b instanceof Date;
  if (dateA != dateB) return false;
  if (dateA && dateB) return a.getTime() == b.getTime();

  var regexpA = a instanceof RegExp,
    regexpB = b instanceof RegExp;
  if (regexpA != regexpB) return false;
  if (regexpA && regexpB) return a.toString() == b.toString();

  if (a instanceof Object && b instanceof Object) {
    var keys = keyList(a);

    if ((length = keys.length) !== keyList(b).length) return false;

    for (i = 0; i < length; i++) if (!hasProp.call(b, keys[i])) return false;

    for (i = 0; i < length; i++) if (!equal(a[(key = keys[i])], b[key])) return false;

    return true;
  }

  return false;
};
//
},
'ajv/lib/compile/util':
function(module, exports, __wpreq__) {
//
module.exports = {
  copy: copy,
  checkDataType: checkDataType,
  checkDataTypes: checkDataTypes,
  coerceToTypes: coerceToTypes,
  toHash: toHash,
  getProperty: getProperty,
  escapeQuotes: escapeQuotes,
  equal: __wpreq__('fast-deep-equal'),
  ucs2length: __wpreq__('ajv/lib/compile/ucs2length'),
  varOccurences: varOccurences,
  varReplace: varReplace,
  cleanUpCode: cleanUpCode,
  finalCleanUpCode: finalCleanUpCode,
  schemaHasRules: schemaHasRules,
  schemaHasRulesExcept: schemaHasRulesExcept,
  toQuotedString: toQuotedString,
  getPathExpr: getPathExpr,
  getPath: getPath,
  getData: getData,
  unescapeFragment: unescapeFragment,
  unescapeJsonPointer: unescapeJsonPointer,
  escapeFragment: escapeFragment,
  escapeJsonPointer: escapeJsonPointer
};

function copy(o, to) {
  to = to || {};
  for (var key in o) to[key] = o[key];
  return to;
}

function checkDataType(dataType, data, negate) {
  var EQUAL = negate ? ' !== ' : ' === ',
    AND = negate ? ' || ' : ' && ',
    OK = negate ? '!' : '',
    NOT = negate ? '' : '!';
  switch (dataType) {
    case 'null':
      return data + EQUAL + 'null';
    case 'array':
      return OK + 'Array.isArray(' + data + ')';
    case 'object':
      return '(' + OK + data + AND + 'typeof ' + data + EQUAL + '"object"' + AND + NOT + 'Array.isArray(' + data + '))';
    case 'integer':
      return '(typeof ' + data + EQUAL + '"number"' + AND + NOT + '(' + data + ' % 1)' + AND + data + EQUAL + data + ')';
    default:
      return 'typeof ' + data + EQUAL + '"' + dataType + '"';
  }
}

function checkDataTypes(dataTypes, data) {
  switch (dataTypes.length) {
    case 1:
      return checkDataType(dataTypes[0], data, true);
    default:
      var code = '',
        types = toHash(dataTypes);
      if (types.array && types.object) {
        code = types.null ? '(' : '(!' + data + ' || ';
        code += 'typeof ' + data + ' !== "object")';
        delete types.null;
        delete types.array;
        delete types.object;
      }
      types.number && delete types.integer;
      for (var t in types) code += (code ? ' && ' : '') + checkDataType(t, data, true);

      return code;
  }
}

var COERCE_TO_TYPES = toHash(['string', 'number', 'integer', 'boolean', 'null']);
function coerceToTypes(optionCoerceTypes, dataTypes) {
  if (Array.isArray(dataTypes)) {
    var types = [];
    for (var i = 0; i < dataTypes.length; i++) {
      var t = dataTypes[i];
      if (COERCE_TO_TYPES[t]) types[types.length] = t;
      else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;
    }
    if (types.length) return types;
  } else {
    if (COERCE_TO_TYPES[dataTypes]) return [dataTypes];
    if (optionCoerceTypes === 'array' && dataTypes === 'array') return ['array'];
  }
}

function toHash(arr) {
  var hash = {};
  for (var i = 0; i < arr.length; i++) hash[arr[i]] = true;
  return hash;
}

var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i,
  SINGLE_QUOTE = /['\\]/g;
function getProperty(key) {
  return typeof key == 'number' ? '[' + key + ']' : IDENTIFIER.test(key) ? '.' + key : "['" + escapeQuotes(key) + "']";
}

function escapeQuotes(str) {
  return str
    .replace(SINGLE_QUOTE, '\\$&')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r')
    .replace(/\f/g, '\\f')
    .replace(/\t/g, '\\t');
}

function varOccurences(str, dataVar) {
  dataVar += '[^0-9]';
  var matches = str.match(new RegExp(dataVar, 'g'));
  return matches ? matches.length : 0;
}

function varReplace(str, dataVar, expr) {
  dataVar += '([^0-9])';
  expr = expr.replace(/\$/g, '$$$$');
  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
}

var EMPTY_ELSE = /else\s*{\s*}/g,
  EMPTY_IF_NO_ELSE = /if\s*\([^)]+\)\s*{\s*}(?!\s*else)/g,
  EMPTY_IF_WITH_ELSE = /if\s*\(([^)]+)\)\s*{\s*}\s*else(?!\s*if)/g;
function cleanUpCode(out) {
  return out.replace(EMPTY_ELSE, '').replace(EMPTY_IF_NO_ELSE, '').replace(EMPTY_IF_WITH_ELSE, 'if (!($1))');
}

var ERRORS_REGEXP = /[^v.]errors/g,
  REMOVE_ERRORS = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g,
  REMOVE_ERRORS_ASYNC = /var errors = 0;|var vErrors = null;/g,
  RETURN_VALID = 'return errors === 0;',
  RETURN_TRUE = 'validate.errors = null; return true;',
  RETURN_ASYNC = /if \(errors === 0\) return data;\s*else throw new ValidationError\(vErrors\);/,
  RETURN_DATA_ASYNC = 'return data;',
  ROOTDATA_REGEXP = /[^A-Za-z_$]rootData[^A-Za-z0-9_$]/g,
  REMOVE_ROOTDATA = /if \(rootData === undefined\) rootData = data;/;

function finalCleanUpCode(out, async) {
  var matches = out.match(ERRORS_REGEXP);
  if (matches && matches.length == 2)
    out = async
      ? out.replace(REMOVE_ERRORS_ASYNC, '').replace(RETURN_ASYNC, RETURN_DATA_ASYNC)
      : out.replace(REMOVE_ERRORS, '').replace(RETURN_VALID, RETURN_TRUE);

  return (matches = out.match(ROOTDATA_REGEXP)) && matches.length === 3 ? out.replace(REMOVE_ROOTDATA, '') : out;
}

function schemaHasRules(schema, rules) {
  if (typeof schema == 'boolean') return !schema;
  for (var key in schema) if (rules[key]) return true;
}

function schemaHasRulesExcept(schema, rules, exceptKeyword) {
  if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';
  for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
}

function toQuotedString(str) {
  return "'" + escapeQuotes(str) + "'";
}

function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
  return joinPaths(
    currentPath,
    jsonPointers
      ? "'/' + " + expr + (isNumber ? '' : ".replace(/~/g, '~0').replace(/\\//g, '~1')")
      : isNumber ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'"
  );
}

function getPath(currentPath, prop, jsonPointers) {
  return joinPaths(currentPath, toQuotedString(jsonPointers ? '/' + escapeJsonPointer(prop) : getProperty(prop)));
}

var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/,
  RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, lvl, paths) {
  var up, jsonPointer, data, matches;
  if ($data === '') return 'rootData';
  if ($data[0] == '/') {
    if (!JSON_POINTER.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);
    jsonPointer = $data;
    data = 'rootData';
  } else {
    if (!(matches = $data.match(RELATIVE_JSON_POINTER))) throw new Error('Invalid JSON-pointer: ' + $data);
    up = +matches[1];
    if ((jsonPointer = matches[2]) == '#') {
      if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
      return paths[lvl - up];
    }

    if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
    data = 'data' + (lvl - up || '');
    if (!jsonPointer) return data;
  }

  var expr = data;
  for (var segments = jsonPointer.split('/'), i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment) expr += ' && ' + (data += getProperty(unescapeJsonPointer(segment)));
  }
  return expr;
}

function joinPaths(a, b) {
  return a == '""' ? b : (a + ' + ' + b).replace(/' \+ '/g, '');
}

function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}

function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}

function escapeJsonPointer(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}

function unescapeJsonPointer(str) {
  return str.replace(/~1/g, '/').replace(/~0/g, '~');
}
//
},
'ajv/lib/compile/ucs2length':
function(module) {
//
module.exports = function(str) {
  var length = 0;
  for (var value, len = str.length, pos = 0; pos < len; ) {
    length++;
    (value = str.charCodeAt(pos++)) >= 0xD800 && value <= 0xDBFF && pos < len &&
      ((value = str.charCodeAt(pos)) & 0xFC00) == 0xDC00 && pos++;
  }
  return length;
};
//
},
'ajv/lib/compile/schema_obj':
function(module, exports, __wpreq__) {
//
var util = __wpreq__('ajv/lib/compile/util');

module.exports = SchemaObject;

function SchemaObject(obj) {
  util.copy(obj, this);
}
//
},
'json-schema-traverse':
function(module) {
//
var traverse = (module.exports = function(schema, opts, cb) {
  if (typeof opts == 'function') {
    cb = opts;
    opts = {};
  }
  _traverse(opts, cb, schema, '', schema);
});

traverse.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true
};

traverse.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};

traverse.propsKeywords = {
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};

traverse.skipKeywords = {
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};

function _traverse(opts, cb, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (!schema || typeof schema != 'object' || Array.isArray(schema)) return;

  cb(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  for (var key in schema) {
    var sch = schema[key];
    if (Array.isArray(sch)) {
      if (key in traverse.arrayKeywords)
        for (var i = 0; i < sch.length; i++)
          _traverse(opts, cb, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
    } else if (key in traverse.propsKeywords) {
      if (sch && typeof sch == 'object')
        for (var prop in sch)
          _traverse(
            opts, cb, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop
          );
    } else (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) &&
      _traverse(opts, cb, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
  }
}

function escapeJsonPtr(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}
//
},
'ajv/lib/compile/error_classes':
function(module, exports, __wpreq__) {
//
var resolve = __wpreq__('ajv/lib/compile/resolve');

module.exports = {
  Validation: errorSubclass(ValidationError),
  MissingRef: errorSubclass(MissingRefError)
};

function ValidationError(errors) {
  this.message = 'validation failed';
  this.errors = errors;
  this.ajv = this.validation = true;
}

MissingRefError.message = function(baseId, ref) {
  return "can't resolve reference " + ref + ' from id ' + baseId;
};

function MissingRefError(baseId, ref, message) {
  this.message = message || MissingRefError.message(baseId, ref);
  this.missingRef = resolve.url(baseId, ref);
  this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
}

function errorSubclass(Subclass) {
  Subclass.prototype = Object.create(Error.prototype);
  Subclass.prototype.constructor = Subclass;
  return Subclass;
}
//
},
'fast-json-stable-stringify':
function(module) {
//
module.exports = function(data, opts) {
  opts || (opts = {});
  if (typeof opts == 'function') opts = {cmp: opts};
  var cycles = typeof opts.cycles == 'boolean' && opts.cycles;

  var cmp = opts.cmp && (function(f) {
    return function(node) {
      return function(a, b) {
        var aobj = {key: a, value: node[a]},
          bobj = {key: b, value: node[b]};
        return f(aobj, bobj);
      };
    };
  })(opts.cmp);

  var seen = [];
  return (function stringify(node) {
    if (node && node.toJSON && typeof node.toJSON == 'function') node = node.toJSON();

    if (node === void 0) return;
    if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
    if (typeof node != 'object') return JSON.stringify(node);

    var i, out;
    if (Array.isArray(node)) {
      out = '[';
      for (i = 0; i < node.length; i++) {
        if (i) out += ',';
        out += stringify(node[i]) || 'null';
      }
      return out + ']';
    }

    if (node === null) return 'null';

    if (seen.indexOf(node) > -1) {
      if (cycles) return JSON.stringify('__cycle__');
      throw new TypeError('Converting circular structure to JSON');
    }

    var seenIndex = seen.push(node) - 1,
      keys = Object.keys(node).sort(cmp && cmp(node));
    out = '';
    for (i = 0; i < keys.length; i++) {
      var key = keys[i],
        value = stringify(node[key]);

      if (!value) continue;
      if (out) out += ',';
      out += JSON.stringify(key) + ':' + value;
    }
    seen.splice(seenIndex, 1);
    return '{' + out + '}';
  })(data);
};
//
},
'ajv/lib/dotjs/validate':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var out = '',
    $async = it.schema.$async === true,
    $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),
    $id = it.self._getId(it.schema);
  if (it.isTop) {
    if ($async) {
      it.async = true;
      var $es7 = it.opts.async == 'es7';
      it.yieldAwait = $es7 ? 'await' : 'yield';
    }
    out += ' var validate = ';
    if ($async)
      if ($es7) out += ' (async function ';
      else {
        if (it.opts.async != '*') out += 'co.wrap';

        out += '(function* ';
      }
    else out += ' (function ';

    out += " (data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
    if ($id && (it.opts.sourceCode || it.opts.processCode)) out += ' /*# sourceURL=' + $id + ' */ ';
  }
  if (typeof it.schema == 'boolean' || (!$refKeywords && !it.schema.$ref)) {
    $keyword = 'false schema';
    // noinspection JSUnusedAssignment
    var $lvl = it.level,
      $dataLvl = it.dataLevel,
      $schema = it.schema[$keyword],
      $schemaPath = it.schemaPath + it.util.getProperty($keyword),
      $errSchemaPath = it.errSchemaPath + '/' + $keyword,
      $breakOnError = !it.opts.allErrors,
      $data = 'data' + ($dataLvl || ''),
      $valid = 'valid' + $lvl;
    if (it.schema === false) {
      it.isTop ? ($breakOnError = true) : (out += ' var ' + $valid + ' = false; ');

      ($$outStack = $$outStack || []).push(out);
      out = '';
      if (it.createErrors !== false) {
        out +=
          " { keyword: '" + ($errorKeyword || 'false schema') +
          "' , dataPath: (dataPath || '') + " + it.errorPath +
          ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
          ' , params: {} ';
        if (it.opts.messages !== false) out += " , message: 'boolean schema is false' ";

        if (it.opts.verbose)
          out += ' , schema: false , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';

        out += ' } ';
      } else out += ' {} ';

      var __err = out;
      out = $$outStack.pop();
      !it.compositeRule && $breakOnError
        ? it.async
          ? (out += ' throw new ValidationError([' + __err + ']); ')
          : (out += ' validate.errors = [' + __err + ']; return false; ')
        : (out +=
            ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');
    } else
      it.isTop
        ? (out += $async ? ' return data; ' : ' validate.errors = null; return true; ')
        : (out += ' var ' + $valid + ' = true; ');

    if (it.isTop) out += ' }); return validate; ';

    return out;
  }
  if (it.isTop) {
    var $top = it.isTop;
    $lvl = it.level = 0;
    $dataLvl = it.dataLevel = 0;
    $data = 'data';
    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
    it.baseId = it.baseId || it.rootId;
    delete it.isTop;
    it.dataPathArr = [void 0];
    out += ' var vErrors = null; ';
    out += ' var errors = 0;     ';
    out += ' if (rootData === undefined) rootData = data; ';
  } else {
    $lvl = it.level;
    $data = 'data' + (($dataLvl = it.dataLevel) || '');
    if ($id) it.baseId = it.resolve.url(it.baseId, $id);
    if ($async && !it.async) throw new Error('async schema in sync schema');
    out += ' var errs_' + $lvl + ' = errors;';
  }
  $valid = 'valid' + $lvl;
  $breakOnError = !it.opts.allErrors;
  var $errorKeyword,
    $closingBraces1 = '',
    $closingBraces2 = '',
    $typeSchema = it.schema.type,
    $typeIsArray = Array.isArray($typeSchema);
  if ($typeIsArray && $typeSchema.length == 1) {
    $typeSchema = $typeSchema[0];
    $typeIsArray = false;
  }
  if (it.schema.$ref && $refKeywords) {
    if (it.opts.extendRefs == 'fail')
      throw new Error(
        '$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)'
      );
    if (it.opts.extendRefs !== true) {
      $refKeywords = false;
      it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
    }
  }
  if ($typeSchema) {
    if (it.opts.coerceTypes) var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);

    var $rulesGroup = it.RULES.types[$typeSchema];
    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {
      $schemaPath = it.schemaPath + '.type';
      $errSchemaPath = it.errSchemaPath + '/type';
      var $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
      out += ' if (' + it.util[$method]($typeSchema, $data, true) + ') { ';
      if ($coerceToTypes) {
        var $dataType = 'dataType' + $lvl,
          $coerced = 'coerced' + $lvl;
        out += ' var ' + $dataType + ' = typeof ' + $data + '; ';
        if (it.opts.coerceTypes == 'array')
          out += ' if (' + $dataType + " == 'object' && Array.isArray(" + $data + ')) ' + $dataType + " = 'array'; ";

        out += ' var ' + $coerced + ' = undefined; ';
        var $bracesCoercion = '',
          arr1 = $coerceToTypes;
        if (arr1)
          for (var $type, $i = -1, l1 = arr1.length - 1; $i < l1; ) {
            $type = arr1[($i += 1)];
            if ($i) {
              out += ' if (' + $coerced + ' === undefined) { ';
              $bracesCoercion += '}';
            }
            if (it.opts.coerceTypes == 'array' && $type != 'array')
              out +=
                ' if (' + $dataType + " == 'array' && " + $data + '.length == 1) { ' +
                $coerced + ' = ' + $data + ' = ' + $data + '[0]; ' +
                $dataType + ' = typeof ' + $data + ';  } ';

            if ($type == 'string')
              out +=
                ' if (' + $dataType + " == 'number' || " + $dataType + " == 'boolean') " +
                $coerced + " = '' + " + $data +
                '; else if (' + $data + ' === null) ' + $coerced + " = ''; ";
            else if ($type == 'number' || $type == 'integer') {
              out +=
                ' if (' + $dataType + " == 'boolean' || " + $data + ' === null || (' +
                $dataType + " == 'string' && " + $data + ' && ' + $data + ' == +' + $data + ' ';
              if ($type == 'integer') out += ' && !(' + $data + ' % 1)';

              out += ')) ' + $coerced + ' = +' + $data + '; ';
            } else if ($type == 'boolean')
              out +=
                ' if (' + $data + " === 'false' || " + $data + ' === 0 || ' + $data + ' === null) ' +
                $coerced + ' = false; else if (' + $data + " === 'true' || " + $data + ' === 1) ' +
                $coerced + ' = true; ';
            else if ($type == 'null')
              out +=
                ' if (' + $data + " === '' || " + $data + ' === 0 || ' + $data + ' === false) ' + $coerced + ' = null; ';
            else if (it.opts.coerceTypes == 'array' && $type == 'array')
              out +=
                ' if (' +
                $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " +
                $data + ' == null) ' +
                $coerced + ' = [' + $data + ']; ';
          }

        out += ' ' + $bracesCoercion + ' if (' + $coerced + ' === undefined) {   ';
        ($$outStack = $$outStack || []).push(out);
        out = '';
        if (it.createErrors !== false) {
          out +=
            " { keyword: '" + ($errorKeyword || 'type') +
            "' , dataPath: (dataPath || '') + " + it.errorPath +
            ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
            " , params: { type: '";
          out += $typeIsArray ? '' + $typeSchema.join(",") : '' + $typeSchema;

          out += "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should be ";
            out += $typeIsArray ? '' + $typeSchema.join(",") : '' + $typeSchema;

            out += "' ";
          }
          if (it.opts.verbose)
            out +=
              ' , schema: validate.schema' + $schemaPath +
              ' , parentSchema: validate.schema' + it.schemaPath +
              ' , data: ' + $data + ' ';

          out += ' } ';
        } else out += ' {} ';

        __err = out;
        out = $$outStack.pop();
        !it.compositeRule && $breakOnError
          ? it.async
            ? (out += ' throw new ValidationError([' + __err + ']); ')
            : (out += ' validate.errors = [' + __err + ']; return false; ')
          : (out +=
              ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

        out += ' } else {  ';
        var $parentData = $dataLvl ? 'data' + ($dataLvl - 1 || '') : 'parentData';
        out += ' ' + $data + ' = ' + $coerced + '; ';
        $dataLvl || (out += 'if (' + $parentData + ' !== undefined)');

        out +=
          ' ' + $parentData + '[' +
          ($dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty') +
          '] = ' + $coerced + '; } ';
      } else {
        ($$outStack = $$outStack || []).push(out);
        out = '';
        if (it.createErrors !== false) {
          out +=
            " { keyword: '" + ($errorKeyword || 'type') +
            "' , dataPath: (dataPath || '') + " + it.errorPath +
            ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
            " , params: { type: '";
          out += $typeIsArray ? '' + $typeSchema.join(",") : '' + $typeSchema;

          out += "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should be ";
            out += $typeIsArray ? '' + $typeSchema.join(",") : '' + $typeSchema;

            out += "' ";
          }
          if (it.opts.verbose)
            out +=
              ' , schema: validate.schema' + $schemaPath +
              ' , parentSchema: validate.schema' + it.schemaPath +
              ' , data: ' + $data + ' ';

          out += ' } ';
        } else out += ' {} ';

        __err = out;
        out = $$outStack.pop();
        !it.compositeRule && $breakOnError
          ? it.async
            ? (out += ' throw new ValidationError([' + __err + ']); ')
            : (out += ' validate.errors = [' + __err + ']; return false; ')
          : (out +=
              ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');
      }
      out += ' } ';
    }
  }
  if (it.schema.$ref && !$refKeywords) {
    out += ' ' + it.RULES.all.$ref.code(it, '$ref') + ' ';
    if ($breakOnError) {
      out += ' } if (errors === ';
      out += $top ? '0' : 'errs_' + $lvl;

      out += ') { ';
      $closingBraces2 += '}';
    }
  } else {
    it.opts.v5 && it.schema.patternGroups &&
      it.logger.warn('keyword "patternGroups" is deprecated and disabled. Use option patternGroups: true to enable.');

    var arr2 = it.RULES;
    if (arr2)
      for (var i2 = -1, l2 = arr2.length - 1; i2 < l2; )
        if ($shouldUseGroup(($rulesGroup = arr2[(i2 += 1)]))) {
          if ($rulesGroup.type) out += ' if (' + it.util.checkDataType($rulesGroup.type, $data) + ') { ';

          if (it.opts.useDefaults && !it.compositeRule)
            if ($rulesGroup.type == 'object' && it.schema.properties) {
              $schema = it.schema.properties;
              var arr3 = Object.keys($schema);
              if (arr3)
                for (var $propertyKey, i3 = -1, l3 = arr3.length - 1; i3 < l3; )
                  if (($sch = $schema[($propertyKey = arr3[(i3 += 1)])]).default !== void 0) {
                    var $passData = $data + it.util.getProperty($propertyKey);
                    out += '  if (' + $passData + ' === undefined) ' + $passData + ' = ';
                    it.opts.useDefaults == 'shared'
                      ? (out += ' ' + it.useDefault($sch.default) + ' ')
                      : (out += ' ' + JSON.stringify($sch.default) + ' ');

                    out += '; ';
                  }
            } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {
              var arr4 = it.schema.items;
              if (arr4) {
                $i = -1;
                for (var $sch, l4 = arr4.length - 1; $i < l4; )
                  if (($sch = arr4[($i += 1)]).default !== void 0) {
                    out += '  if (' + ($passData = $data + '[' + $i + ']') + ' === undefined) ' + $passData + ' = ';
                    it.opts.useDefaults == 'shared'
                      ? (out += ' ' + it.useDefault($sch.default) + ' ')
                      : (out += ' ' + JSON.stringify($sch.default) + ' ');

                    out += '; ';
                  }
              }
            }

          var arr5 = $rulesGroup.rules;
          if (arr5)
            for (var $rule, i5 = -1, l5 = arr5.length - 1; i5 < l5; )
              if ($shouldUseRule(($rule = arr5[(i5 += 1)]))) {
                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                if ($code) {
                  out += ' ' + $code + ' ';
                  if ($breakOnError) $closingBraces1 += '}';
                }
              }

          if ($breakOnError) {
            out += ' ' + $closingBraces1 + ' ';
            $closingBraces1 = '';
          }
          if ($rulesGroup.type) {
            out += ' } ';
            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
              out += ' else { ';
              var $$outStack;
              $schemaPath = it.schemaPath + '.type';
              $errSchemaPath = it.errSchemaPath + '/type';
              ($$outStack = $$outStack || []).push(out);
              out = '';
              if (it.createErrors !== false) {
                out +=
                  " { keyword: '" + ($errorKeyword || 'type') +
                  "' , dataPath: (dataPath || '') + " + it.errorPath +
                  ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
                  " , params: { type: '";
                out += $typeIsArray ? '' + $typeSchema.join(",") : '' + $typeSchema;

                out += "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: 'should be ";
                  out += $typeIsArray ? '' + $typeSchema.join(",") : '' + $typeSchema;

                  out += "' ";
                }
                if (it.opts.verbose)
                  out +=
                    ' , schema: validate.schema' + $schemaPath +
                    ' , parentSchema: validate.schema' + it.schemaPath +
                    ' , data: ' + $data + ' ';

                out += ' } ';
              } else out += ' {} ';

              __err = out;
              out = $$outStack.pop();
              !it.compositeRule && $breakOnError
                ? it.async
                  ? (out += ' throw new ValidationError([' + __err + ']); ')
                  : (out += ' validate.errors = [' + __err + ']; return false; ')
                : (out +=
                    ' var err = ' + __err +
                    ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

              out += ' } ';
            }
          }
          if ($breakOnError) {
            out += ' if (errors === ';
            out += $top ? '0' : 'errs_' + $lvl;

            out += ') { ';
            $closingBraces2 += '}';
          }
        }
  }
  if ($breakOnError) out += ' ' + $closingBraces2 + ' ';

  if ($top) {
    if ($async) {
      out += ' if (errors === 0) return data;           ';
      out += ' else throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; ';
      out += ' return errors === 0;       ';
    }
    out += ' }); return validate;';
  } else out += ' var ' + $valid + ' = errors === errs_' + $lvl + ';';

  out = it.util.cleanUpCode(out);
  if ($top) out = it.util.finalCleanUpCode(out, $async);

  function $shouldUseGroup($rulesGroup) {
    for (var rules = $rulesGroup.rules, i = 0; i < rules.length; i++) if ($shouldUseRule(rules[i])) return true;
  }

  function $shouldUseRule($rule) {
    return it.schema[$rule.keyword] !== void 0 || ($rule.implements && $ruleImplementsSomeKeyword($rule));
  }

  function $ruleImplementsSomeKeyword($rule) {
    for (var impl = $rule.implements, i = 0; i < impl.length; i++) if (it.schema[impl[i]] !== void 0) return true;
  }
  return out;
}
//
},
co:
function(module) {
//
var slice = Array.prototype.slice;

module.exports = co.default = co.co = co;

co.wrap = function(fn) {
  createPromise.__generatorFunction__ = fn;
  return createPromise;
  function createPromise() {
    return co.call(this, fn.apply(this, arguments));
  }
};

function co(gen) {
  var ctx = this,
    args = slice.call(arguments, 1)

  return new Promise(function(resolve, reject) {
    if (typeof gen == 'function') gen = gen.apply(ctx, args);
    if (!gen || typeof gen.next != 'function') return resolve(gen);

    onFulfilled();

    function onFulfilled(res) {
      var ret;
      try {
        ret = gen.next(res);
      } catch (e) {
        return reject(e);
      }
      next(ret);
    }

    function onRejected(err) {
      var ret;
      try {
        ret = gen.throw(err);
      } catch (e) {
        return reject(e);
      }
      next(ret);
    }

    function next(ret) {
      if (ret.done) return resolve(ret.value);
      var value = toPromise.call(ctx, ret.value);
      if (value && isPromise(value)) return value.then(onFulfilled, onRejected);
      return onRejected(new TypeError(
        'You may only yield a function, promise, generator, array, or object, but the following object was passed: "' +
          String(ret.value) + '"'
      ));
    }
  });
}

function toPromise(obj) {
  return !obj || isPromise(obj) ? obj
    : isGeneratorFunction(obj) || isGenerator(obj) ? co.call(this, obj)
    : 'function' == typeof obj ? thunkToPromise.call(this, obj)
    : Array.isArray(obj) ? arrayToPromise.call(this, obj)
    : isObject(obj) ? objectToPromise.call(this, obj)
    : obj;
}

function thunkToPromise(fn) {
  var ctx = this;
  return new Promise(function(resolve, reject) {
    fn.call(ctx, function(err, res) {
      if (err) return reject(err);
      if (arguments.length > 2) res = slice.call(arguments, 1);
      resolve(res);
    });
  });
}

function arrayToPromise(obj) {
  return Promise.all(obj.map(toPromise, this));
}

function objectToPromise(obj) {
  var results = new obj.constructor(),
    keys = Object.keys(obj),
    promises = [];
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i],
      promise = toPromise.call(this, obj[key]);
    promise && isPromise(promise) ? defer(promise, key) : (results[key] = obj[key]);
  }
  return Promise.all(promises).then(function() {
    return results;
  });

  function defer(promise, key) {
    results[key] = void 0;
    promises.push(promise.then(function(res) {
      results[key] = res;
    }));
  }
}

function isPromise(obj) {
  return 'function' == typeof obj.then;
}

function isGenerator(obj) {
  return 'function' == typeof obj.next && 'function' == typeof obj.throw;
}

function isGeneratorFunction(obj) {
  var constructor = obj.constructor;
  return !!constructor &&
    ('GeneratorFunction' === constructor.name || 'GeneratorFunction' === constructor.displayName ||
      isGenerator(constructor.prototype));
}

function isObject(val) {
  return Object == val.constructor;
}
//
},
'ajv/lib/cache':
function(module) {
//
var Cache = (module.exports = function() {
  this._cache = {};
});

Cache.prototype.put = function(key, value) {
  this._cache[key] = value;
};

Cache.prototype.get = function(key) {
  return this._cache[key];
};

Cache.prototype.del = function(key) {
  delete this._cache[key];
};

Cache.prototype.clear = function() {
  this._cache = {};
};
//
},
'ajv/lib/compile/formats':
function(module, exports, __wpreq__) {
//
var util = __wpreq__('ajv/lib/compile/util'),

  DATE = /^\d\d\d\d-(\d\d)-(\d\d)$/,
  DAYS = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i,
  HOSTNAME = /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*$/i,
  URI =
    /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:)?[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
  URIREF =
    /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:)?[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
  URITEMPLATE =
    /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*})*$/i,
  URL =
    /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i,
  UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
  JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$|^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
  RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;

module.exports = formats;

function formats(mode) {
  mode = mode == 'full' ? 'full' : 'fast';
  return util.copy(formats[mode]);
}

formats.fast = {
  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
  time: /^[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)?$/i,
  'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s][0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)$/i,
  uri: /^(?:[a-z][a-z0-9+-.]*)[:\/]\/?[^\s]*$/i,
  'uri-reference': /^(?:(?:[a-z][a-z0-9+-.]*:)?\/\/)?[^\s]*$/i,
  'uri-template': URITEMPLATE,
  url: URL,
  email:
    /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  hostname: HOSTNAME,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:)(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  uuid: UUID,
  'json-pointer': JSON_POINTER,
  'relative-json-pointer': RELATIVE_JSON_POINTER
};

formats.full = {
  date: date,
  time: time,
  'date-time': date_time,
  uri: uri,
  'uri-reference': URIREF,
  'uri-template': URITEMPLATE,
  url: URL,
  email:
    /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: hostname,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:)(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  uuid: UUID,
  'json-pointer': JSON_POINTER,
  'relative-json-pointer': RELATIVE_JSON_POINTER
};

function date(str) {
  var matches = str.match(DATE);
  if (!matches) return false;

  var month = +matches[1],
    day = +matches[2];
  return month >= 1 && month <= 12 && day >= 1 && day <= DAYS[month];
}

function time(str, full) {
  var matches = str.match(TIME);
  if (!matches) return false;

  var hour = matches[1],
    minute = matches[2],
    second = matches[3],
    timeZone = matches[5];
  return hour <= 23 && minute <= 59 && second <= 59 && (!full || timeZone);
}

var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
  var dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}

function hostname(str) {
  return str.length <= 255 && HOSTNAME.test(str);
}

var NOT_URI_FRAGMENT = /[\/:]/;
function uri(str) {
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}

var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str)) return false;
  try {
    new RegExp(str);
    return true;
  } catch (_e) {
    return false;
  }
}
//
},
'ajv/lib/compile/rules':
function(module, exports, __wpreq__) {
//
var ruleModules = __wpreq__('ajv/lib/compile/_rules'),
  toHash = __wpreq__('ajv/lib/compile/util').toHash;

module.exports = function() {
  var RULES = [
    {
      type: 'number',
      rules: [{maximum: ['exclusiveMaximum']}, {minimum: ['exclusiveMinimum']}, 'multipleOf', 'format']
    },
    {type: 'string', rules: ['maxLength', 'minLength', 'pattern', 'format']},
    {type: 'array', rules: ['maxItems', 'minItems', 'uniqueItems', 'contains', 'items']},
    {
      type: 'object',
      rules: [
        'maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames',
        {properties: ['additionalProperties', 'patternProperties']}
      ]
    },
    {rules: ['$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf']}
  ];

  var ALL = ['type'],
    KEYWORDS = ['additionalItems', '$schema', '$id', 'id', 'title', 'description', 'default', 'definitions'],
    TYPES = ['number', 'integer', 'string', 'array', 'object', 'boolean', 'null'];
  RULES.all = toHash(ALL);
  RULES.types = toHash(TYPES);

  RULES.forEach(function(group) {
    group.rules = group.rules.map(function(keyword) {
      var implKeywords;
      if (typeof keyword == 'object') {
        var key = Object.keys(keyword)[0];
        implKeywords = keyword[key];
        keyword = key;
        implKeywords.forEach(function(k) {
          ALL.push(k);
          RULES.all[k] = true;
        });
      }
      ALL.push(keyword);
      return (RULES.all[keyword] = {keyword: keyword, code: ruleModules[keyword], implements: implKeywords});
    });

    if (group.type) RULES.types[group.type] = group;
  });

  RULES.keywords = toHash(ALL.concat(KEYWORDS));
  RULES.custom = {};

  return RULES;
};
//
},
'ajv/lib/compile/_rules':
function(module, exports, __wpreq__) {
//
module.exports = {
  $ref: __wpreq__('ajv/lib/dotjs/ref'),
  allOf: __wpreq__('ajv/lib/dotjs/allOf'),
  anyOf: __wpreq__('ajv/lib/dotjs/anyOf'),
  const: __wpreq__('ajv/lib/dotjs/const'),
  contains: __wpreq__('ajv/lib/dotjs/contains'),
  dependencies: __wpreq__('ajv/lib/dotjs/dependencies'),
  enum: __wpreq__('ajv/lib/dotjs/enum'),
  format: __wpreq__('ajv/lib/dotjs/format'),
  items: __wpreq__('ajv/lib/dotjs/items'),
  maximum: __wpreq__('ajv/lib/dotjs/_limit'),
  minimum: __wpreq__('ajv/lib/dotjs/_limit'),
  maxItems: __wpreq__('ajv/lib/dotjs/_limitItems'),
  minItems: __wpreq__('ajv/lib/dotjs/_limitItems'),
  maxLength: __wpreq__('ajv/lib/dotjs/_limitLength'),
  minLength: __wpreq__('ajv/lib/dotjs/_limitLength'),
  maxProperties: __wpreq__('ajv/lib/dotjs/_limitProperties'),
  minProperties: __wpreq__('ajv/lib/dotjs/_limitProperties'),
  multipleOf: __wpreq__('ajv/lib/dotjs/multipleOf'),
  not: __wpreq__('ajv/lib/dotjs/not'),
  oneOf: __wpreq__('ajv/lib/dotjs/oneOf'),
  pattern: __wpreq__('ajv/lib/dotjs/pattern'),
  properties: __wpreq__('ajv/lib/dotjs/properties'),
  propertyNames: __wpreq__('ajv/lib/dotjs/propertyNames'),
  required: __wpreq__('ajv/lib/dotjs/required'),
  uniqueItems: __wpreq__('ajv/lib/dotjs/uniqueItems'),
  validate: __wpreq__('ajv/lib/dotjs/validate')
};
//
},
'ajv/lib/dotjs/ref':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var $async, $refCode,
    out = ' ',
    $lvl = it.level,
    $dataLvl = it.dataLevel,
    $schema = it.schema[$keyword],
    $errSchemaPath = it.errSchemaPath + '/' + $keyword,
    $breakOnError = !it.opts.allErrors,
    $data = 'data' + ($dataLvl || ''),
    $valid = 'valid' + $lvl;
  if ($schema == '#' || $schema == '#/')
    if (it.isRoot) {
      $async = it.async;
      $refCode = 'validate';
    } else {
      $async = it.root.schema.$async === true;
      $refCode = 'root.refVal[0]';
    }
  else {
    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
    if ($refVal === void 0) {
      var $message = it.MissingRefError.message(it.baseId, $schema);
      if (it.opts.missingRefs == 'fail') {
        it.logger.error($message);
        ($$outStack = $$outStack || []).push(out);
        out = '';
        if (it.createErrors !== false) {
          out +=
            " { keyword: '$ref' , dataPath: (dataPath || '') + " + it.errorPath +
            ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
            " , params: { ref: '" + it.util.escapeQuotes($schema) + "' } ";
          if (it.opts.messages !== false)
            out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema) + "' ";

          if (it.opts.verbose)
            out +=
              ' , schema: ' + it.util.toQuotedString($schema) +
              ' , parentSchema: validate.schema' + it.schemaPath +
              ' , data: ' + $data + ' ';

          out += ' } ';
        } else out += ' {} ';

        var __err = out;
        out = $$outStack.pop();
        !it.compositeRule && $breakOnError
          ? it.async
            ? (out += ' throw new ValidationError([' + __err + ']); ')
            : (out += ' validate.errors = [' + __err + ']; return false; ')
          : (out +=
              ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

        if ($breakOnError) out += ' if (false) { ';
      } else {
        if (it.opts.missingRefs != 'ignore') throw new it.MissingRefError(it.baseId, $schema, $message);
        it.logger.warn($message);
        if ($breakOnError) out += ' if (true) { ';
      }
    } else if ($refVal.inline) {
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      $it.schema = $refVal.schema;
      $it.schemaPath = '';
      $it.errSchemaPath = $schema;
      out += ' ' + it.validate($it).replace(/validate\.schema/g, $refVal.code) + ' ';
      if ($breakOnError) out += ' if (' + $nextValid + ') { ';
    } else {
      $async = $refVal.$async === true;
      $refCode = $refVal.code;
    }
  }
  if ($refCode) {
    var $$outStack;
    ($$outStack = $$outStack || []).push(out);
    out = '';
    it.opts.passContext ? (out += ' ' + $refCode + '.call(this, ') : (out += ' ' + $refCode + '( ');

    out += ' ' + $data + ", (dataPath || '')";
    if (it.errorPath != '""') out += ' + ' + it.errorPath;

    var __callValidate = (out +=
      ' , ' + ($dataLvl ? 'data' + ($dataLvl - 1 || '') : 'parentData') + ' , ' +
      ($dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty') + ', rootData)  ');
    out = $$outStack.pop();
    if ($async) {
      if (!it.async) throw new Error('async schema referenced by sync schema');
      if ($breakOnError) out += ' var ' + $valid + '; ';

      out += ' try { ' + it.yieldAwait + ' ' + __callValidate + '; ';
      if ($breakOnError) out += ' ' + $valid + ' = true; ';

      out +=
        ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';
      if ($breakOnError) out += ' ' + $valid + ' = false; ';

      out += ' } ';
      if ($breakOnError) out += ' if (' + $valid + ') { ';
    } else {
      out += ' if (!' + __callValidate +
        ') { if (vErrors === null) vErrors = ' + $refCode +
        '.errors; else vErrors = vErrors.concat(' + $refCode + '.errors); errors = vErrors.length; } ';
      if ($breakOnError) out += ' else { ';
    }
  }
  return out;
}
//
},
'ajv/lib/dotjs/allOf':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var out = ' ',
    $schema = it.schema[$keyword],
    $schemaPath = it.schemaPath + it.util.getProperty($keyword),
    $errSchemaPath = it.errSchemaPath + '/' + $keyword,
    $breakOnError = !it.opts.allErrors,
    $it = it.util.copy(it),
    $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level,
    $currentBaseId = $it.baseId,
    $allSchemasEmpty = true,
    arr1 = $schema;
  if (arr1)
    for (var $sch, $i = -1, l1 = arr1.length - 1; $i < l1; ) {
      $sch = arr1[($i += 1)];
      if (it.util.schemaHasRules($sch, it.RULES.all)) {
        $allSchemasEmpty = false;
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + it.validate($it) + ' ';
        $it.baseId = $currentBaseId;
        if ($breakOnError) {
          out += ' if (' + $nextValid + ') { ';
          $closingBraces += '}';
        }
      }
    }

  if ($breakOnError) out += $allSchemasEmpty ? ' if (true) { ' : ' ' + $closingBraces.slice(0, -1) + ' ';

  return it.util.cleanUpCode(out);
}
//
},
'ajv/lib/dotjs/anyOf':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var out = ' ',
    $lvl = it.level,
    $dataLvl = it.dataLevel,
    $schema = it.schema[$keyword],
    $schemaPath = it.schemaPath + it.util.getProperty($keyword),
    $errSchemaPath = it.errSchemaPath + '/' + $keyword,
    $breakOnError = !it.opts.allErrors,
    $data = 'data' + ($dataLvl || ''),
    $valid = 'valid' + $lvl,
    $errs = 'errs__' + $lvl,
    $it = it.util.copy(it),
    $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  if ($schema.every(function($sch) {
    return it.util.schemaHasRules($sch, it.RULES.all);
  })) {
    var $currentBaseId = $it.baseId;
    out += ' var ' + $errs + ' = errors; var ' + $valid + ' = false;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1)
      for (var $sch, $i = -1, l1 = arr1.length - 1; $i < l1; ) {
        $sch = arr1[($i += 1)];
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + it.validate($it) + ' ';
        $it.baseId = $currentBaseId;
        out += ' ' + $valid + ' = ' + $valid + ' || ' + $nextValid + '; if (!' + $valid + ') { ';
        $closingBraces += '}';
      }

    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + $closingBraces + ' if (!' + $valid + ') {   var err =   ';
    if (it.createErrors !== false) {
      out +=
        " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it.errorPath +
        ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
        ' , params: {} ';
      if (it.opts.messages !== false) out += " , message: 'should match some schema in anyOf' ";

      if (it.opts.verbose)
        out +=
          ' , schema: validate.schema' + $schemaPath +
          ' , parentSchema: validate.schema' + it.schemaPath +
          ' , data: ' + $data + ' ';

      out += ' } ';
    } else out += ' {} ';

    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError)
      it.async
        ? (out += ' throw new ValidationError(vErrors); ')
        : (out += ' validate.errors = vErrors; return false; ');

    out +=
      ' } else {  errors = ' + $errs +
      '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; } ';
    if (it.opts.allErrors) out += ' } ';

    out = it.util.cleanUpCode(out);
  } else if ($breakOnError) out += ' if (true) { ';

  return out;
}
//
},
'ajv/lib/dotjs/const':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var out = ' ',
    $lvl = it.level,
    $dataLvl = it.dataLevel,
    $schema = it.schema[$keyword],
    $schemaPath = it.schemaPath + it.util.getProperty($keyword),
    $errSchemaPath = it.errSchemaPath + '/' + $keyword,
    $breakOnError = !it.opts.allErrors,
    $data = 'data' + ($dataLvl || ''),
    $valid = 'valid' + $lvl,
    $isData = it.opts.$data && $schema && $schema.$data;
  if ($isData) out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';

  $isData || (out += ' var schema' + $lvl + ' = validate.schema' + $schemaPath + ';');

  out += 'var ' + $valid + ' = equal(' + $data + ', schema' + $lvl + '); if (!' + $valid + ') {   ';
  var $$outStack;
  ($$outStack = $$outStack || []).push(out);
  out = '';
  if (it.createErrors !== false) {
    out +=
      " { keyword: 'const' , dataPath: (dataPath || '') + " + it.errorPath +
      ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
      ' , params: {} ';
    if (it.opts.messages !== false) out += " , message: 'should be equal to constant' ";

    if (it.opts.verbose)
      out +=
        ' , schema: validate.schema' + $schemaPath +
        ' , parentSchema: validate.schema' + it.schemaPath +
        ' , data: ' + $data + ' ';

    out += ' } ';
  } else out += ' {} ';

  var __err = out;
  out = $$outStack.pop();
  !it.compositeRule && $breakOnError
    ? it.async
      ? (out += ' throw new ValidationError([' + __err + ']); ')
      : (out += ' validate.errors = [' + __err + ']; return false; ')
    : (out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

  out += ' }';
  if ($breakOnError) out += ' else { ';

  return out;
}
//
},
'ajv/lib/dotjs/contains':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var out = ' ',
    $lvl = it.level,
    $dataLvl = it.dataLevel,
    $schema = it.schema[$keyword],
    $schemaPath = it.schemaPath + it.util.getProperty($keyword),
    $errSchemaPath = it.errSchemaPath + '/' + $keyword,
    $breakOnError = !it.opts.allErrors,
    $data = 'data' + ($dataLvl || ''),
    $valid = 'valid' + $lvl,
    $errs = 'errs__' + $lvl,
    $it = it.util.copy(it),
    $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level,
    $idx = 'i' + $lvl,
    $dataNxt = ($it.dataLevel = it.dataLevel + 1),
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId,
    $nonEmptySchema = it.util.schemaHasRules($schema, it.RULES.all);
  out += 'var ' + $errs + ' = errors;var ' + $valid + ';';
  if ($nonEmptySchema) {
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out +=
      ' var ' + $nextValid + ' = false; for (var ' + $idx + ' = 0; ' +
      $idx + ' < ' + $data + '.length; ' + $idx + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    it.util.varOccurences($code, $nextData) < 2
      ? (out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ')
      : (out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ');

    out += ' if (' + $nextValid + ') break; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + $closingBraces + ' if (!' + $nextValid + ') {';
  } else out += ' if (' + $data + '.length == 0) {';

  var $$outStack;
  ($$outStack = $$outStack || []).push(out);
  out = '';
  if (it.createErrors !== false) {
    out +=
      " { keyword: 'contains' , dataPath: (dataPath || '') + " + it.errorPath +
      ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
      ' , params: {} ';
    if (it.opts.messages !== false) out += " , message: 'should contain a valid item' ";

    if (it.opts.verbose)
      out +=
        ' , schema: validate.schema' + $schemaPath +
        ' , parentSchema: validate.schema' + it.schemaPath +
        ' , data: ' + $data + ' ';

    out += ' } ';
  } else out += ' {} ';

  var __err = out;
  out = $$outStack.pop();
  !it.compositeRule && $breakOnError
    ? it.async
      ? (out += ' throw new ValidationError([' + __err + ']); ')
      : (out += ' validate.errors = [' + __err + ']; return false; ')
    : (out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

  out += ' } else { ';
  if ($nonEmptySchema)
    out +=
      '  errors = ' + $errs +
      '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; } ';

  if (it.opts.allErrors) out += ' } ';

  return it.util.cleanUpCode(out);
}
//
},
'ajv/lib/dotjs/dependencies':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var out = ' ',
    $lvl = it.level,
    $dataLvl = it.dataLevel,
    $schema = it.schema[$keyword],
    $schemaPath = it.schemaPath + it.util.getProperty($keyword),
    $errSchemaPath = it.errSchemaPath + '/' + $keyword,
    $breakOnError = !it.opts.allErrors,
    $data = 'data' + ($dataLvl || ''),
    $errs = 'errs__' + $lvl,
    $it = it.util.copy(it),
    $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level,
    $schemaDeps = {},
    $propertyDeps = {},
    $ownProperties = it.opts.ownProperties;
  for (var $property in $schema) {
    var $sch = $schema[$property],
      $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
    $deps[$property] = $sch;
  }
  out += 'var ' + $errs + ' = errors;';
  var $currentErrorPath = it.errorPath;
  out += 'var missing' + $lvl + ';';
  for ($property in $propertyDeps)
    if (($deps = $propertyDeps[$property]).length) {
      out += ' if ( ' + $data + it.util.getProperty($property) + ' !== undefined ';
      if ($ownProperties)
        out += ' && Object.prototype.hasOwnProperty.call(' + $data + ", '" + it.util.escapeQuotes($property) + "') ";

      if ($breakOnError) {
        out += ' && ( ';
        var arr1 = $deps;
        if (arr1)
          for (var $i = -1, l1 = arr1.length - 1; $i < l1; ) {
            $propertyKey = arr1[($i += 1)];
            if ($i) out += ' || ';

            out += ' ( ( ' + ($useData = $data + ($prop = it.util.getProperty($propertyKey))) + ' === undefined ';
            if ($ownProperties)
              out += ' || ! Object.prototype.hasOwnProperty.call(' +
                $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";

            out += ') && (missing' + $lvl + ' = ' +
              it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ') ) ';
          }

        out += ')) {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = "' + " + $propertyPath + " + '";
        if (it.opts._errorDataPathProperty)
          it.errorPath = it.opts.jsonPointers
            ? it.util.getPathExpr($currentErrorPath, $propertyPath, true)
            : $currentErrorPath + ' + ' + $propertyPath;

        var $$outStack;
        ($$outStack = $$outStack || []).push(out);
        out = '';
        if (it.createErrors !== false) {
          out +=
            " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath +
            ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
            " , params: { property: '" + it.util.escapeQuotes($property) +
            "', missingProperty: '" + $missingProperty +
            "', depsCount: " + $deps.length +
            ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should have ";
            $deps.length == 1
              ? (out += 'property ' + it.util.escapeQuotes($deps[0]))
              : (out += 'properties ' + it.util.escapeQuotes($deps.join(", ")));

            out += ' when property ' + it.util.escapeQuotes($property) + " is present' ";
          }
          if (it.opts.verbose)
            out +=
              ' , schema: validate.schema' + $schemaPath +
              ' , parentSchema: validate.schema' + it.schemaPath +
              ' , data: ' + $data + ' ';

          out += ' } ';
        } else out += ' {} ';

        var __err = out;
        out = $$outStack.pop();
        !it.compositeRule && $breakOnError
          ? it.async
            ? (out += ' throw new ValidationError([' + __err + ']); ')
            : (out += ' validate.errors = [' + __err + ']; return false; ')
          : (out +=
              ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');
      } else {
        out += ' ) { ';
        var arr2 = $deps;
        if (arr2)
          for (var $propertyKey, i2 = -1, l2 = arr2.length - 1; i2 < l2; ) {
            $propertyKey = arr2[(i2 += 1)];
            var $prop = it.util.getProperty($propertyKey),
              $useData = (($missingProperty = it.util.escapeQuotes($propertyKey)), $data + $prop);
            if (it.opts._errorDataPathProperty)
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);

            out += ' if ( ' + $useData + ' === undefined ';
            if ($ownProperties)
              out += ' || ! Object.prototype.hasOwnProperty.call(' +
                $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";

            out += ') {  var err =   ';
            if (it.createErrors !== false) {
              out +=
                " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath +
                ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
                " , params: { property: '" + it.util.escapeQuotes($property) +
                "', missingProperty: '" + $missingProperty +
                "', depsCount: " + $deps.length +
                ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should have ";
                $deps.length == 1
                  ? (out += 'property ' + it.util.escapeQuotes($deps[0]))
                  : (out += 'properties ' + it.util.escapeQuotes($deps.join(", ")));

                out += ' when property ' + it.util.escapeQuotes($property) + " is present' ";
              }
              if (it.opts.verbose)
                out +=
                  ' , schema: validate.schema' + $schemaPath +
                  ' , parentSchema: validate.schema' + it.schemaPath +
                  ' , data: ' + $data + ' ';

              out += ' } ';
            } else out += ' {} ';

            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
      }
      out += ' }   ';
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }

  it.errorPath = $currentErrorPath;
  var $currentBaseId = $it.baseId;
  for ($property in $schemaDeps) {
    $sch = $schemaDeps[$property];
    if (it.util.schemaHasRules($sch, it.RULES.all)) {
      out += ' ' + $nextValid + ' = true; if ( ' + $data + it.util.getProperty($property) + ' !== undefined ';
      if ($ownProperties)
        out += ' && Object.prototype.hasOwnProperty.call(' + $data + ", '" + it.util.escapeQuotes($property) + "') ";

      out += ') { ';
      $it.schema = $sch;
      $it.schemaPath = $schemaPath + it.util.getProperty($property);
      $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
      out += '  ' + it.validate($it) + ' ';
      $it.baseId = $currentBaseId;
      out += ' }  ';
      if ($breakOnError) {
        out += ' if (' + $nextValid + ') { ';
        $closingBraces += '}';
      }
    }
  }
  if ($breakOnError) out += '   ' + $closingBraces + ' if (' + $errs + ' == errors) {';

  return it.util.cleanUpCode(out);
}
//
},
'ajv/lib/dotjs/enum':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var out = ' ',
    $lvl = it.level,
    $dataLvl = it.dataLevel,
    $schema = it.schema[$keyword],
    $schemaPath = it.schemaPath + it.util.getProperty($keyword),
    $errSchemaPath = it.errSchemaPath + '/' + $keyword,
    $breakOnError = !it.opts.allErrors,
    $data = 'data' + ($dataLvl || ''),
    $valid = 'valid' + $lvl,
    $isData = it.opts.$data && $schema && $schema.$data;
  if ($isData) out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';

  var $i = 'i' + $lvl,
    $vSchema = 'schema' + $lvl;
  $isData || (out += ' var ' + $vSchema + ' = validate.schema' + $schemaPath + ';');

  out += 'var ' + $valid + ';';
  if ($isData)
    out +=
      ' if (schema' + $lvl + ' === undefined) ' +
      $valid + ' = true; else if (!Array.isArray(schema' + $lvl + ')) ' +
      $valid + ' = false; else {';

  out +=
    $valid + ' = false;for (var ' + $i + '=0; ' +
    $i + '<' + $vSchema + '.length; ' +
    $i + '++) if (equal(' + $data + ', ' + $vSchema + '[' + $i + '])) { ' +
    $valid + ' = true; break; }';
  if ($isData) out += '  }  ';

  out += ' if (!' + $valid + ') {   ';
  var $$outStack;
  ($$outStack = $$outStack || []).push(out);
  out = '';
  if (it.createErrors !== false) {
    out +=
      " { keyword: 'enum' , dataPath: (dataPath || '') + " + it.errorPath +
      ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
      ' , params: { allowedValues: schema' + $lvl + ' } ';
    if (it.opts.messages !== false) out += " , message: 'should be equal to one of the allowed values' ";

    if (it.opts.verbose)
      out +=
        ' , schema: validate.schema' + $schemaPath +
        ' , parentSchema: validate.schema' + it.schemaPath +
        ' , data: ' + $data + ' ';

    out += ' } ';
  } else out += ' {} ';

  var __err = out;
  out = $$outStack.pop();
  !it.compositeRule && $breakOnError
    ? it.async
      ? (out += ' throw new ValidationError([' + __err + ']); ')
      : (out += ' validate.errors = [' + __err + ']; return false; ')
    : (out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

  out += ' }';
  if ($breakOnError) out += ' else { ';

  return out;
}
//
},
'ajv/lib/dotjs/format':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var out = ' ',
    $lvl = it.level,
    $dataLvl = it.dataLevel,
    $schema = it.schema[$keyword],
    $schemaPath = it.schemaPath + it.util.getProperty($keyword),
    $errSchemaPath = it.errSchemaPath + '/' + $keyword,
    $breakOnError = !it.opts.allErrors,
    $data = 'data' + ($dataLvl || '');
  if (it.opts.format === false) {
    if ($breakOnError) out += ' if (true) { ';

    return out;
  }
  var $schemaValue,
    $isData = it.opts.$data && $schema && $schema.$data;
  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else $schemaValue = $schema;

  var $unknownFormats = it.opts.unknownFormats,
    $allowUnknown = Array.isArray($unknownFormats);
  if ($isData) {
    out +=
      ' var ' + ($format = 'format' + $lvl) + ' = formats[' + $schemaValue + ']; var ' +
      ($isObject = 'isObject' + $lvl) + ' = typeof ' + $format + " == 'object' && !(" +
      $format + ' instanceof RegExp) && ' + $format + '.validate; var ' +
      ($formatType = 'formatType' + $lvl) + ' = ' + $isObject + ' && ' + $format + ".type || 'string'; if (" +
      $isObject + ') { ';
    if (it.async) out += ' var async' + $lvl + ' = ' + $format + '.async; ';

    out += ' ' + $format + ' = ' + $format + '.validate; } if (  ';
    if ($isData) out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + " != 'string') || ";

    out += ' (';
    if ($unknownFormats != 'ignore') {
      out += ' (' + $schemaValue + ' && !' + $format + ' ';
      if ($allowUnknown) out += ' && self._opts.unknownFormats.indexOf(' + $schemaValue + ') < 0 ';

      out += ') || ';
    }
    out +=
      ' (' + $format + ' && ' + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
    it.async
      ? (out +=
          ' (async' + $lvl + ' ? ' + it.yieldAwait + ' ' + $format + '(' + $data + ') : ' + $format + '(' + $data + ')) ')
      : (out += ' ' + $format + '(' + $data + ') ');

    out += ' : ' + $format + '.test(' + $data + '))))) {';
  } else {
    var $format = it.formats[$schema];
    if (!$format) {
      if ($unknownFormats == 'ignore') {
        it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
        if ($breakOnError) out += ' if (true) { ';

        return out;
      }
      if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
        if ($breakOnError) out += ' if (true) { ';

        return out;
      }
      throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
    }
    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate,
      $formatType = ($isObject && $format.type) || 'string';
    if ($isObject) {
      var $async = $format.async === true;
      $format = $format.validate;
    }
    if ($formatType != $ruleType) {
      if ($breakOnError) out += ' if (true) { ';

      return out;
    }
    if ($async) {
      if (!it.async) throw new Error('async format in sync schema');
      var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
      out += ' if (!(' + it.yieldAwait + ' ' + $formatRef + '(' + $data + '))) { ';
    } else {
      out += ' if (! ';
      $formatRef = 'formats' + it.util.getProperty($schema);
      if ($isObject) $formatRef += '.validate';
      out +=
        typeof $format == 'function'
          ? ' ' + $formatRef + '(' + $data + ') '
          : ' ' + $formatRef + '.test(' + $data + ') ';
      out += ') { ';
    }
  }
  var $$outStack;
  ($$outStack = $$outStack || []).push(out);
  out = '';
  if (it.createErrors !== false) {
    out +=
      " { keyword: 'format' , dataPath: (dataPath || '') + " + it.errorPath +
      ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
      ' , params: { format:  ';
    out += $isData ? '' + $schemaValue : '' + it.util.toQuotedString($schema);

    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match format "';
      out += $isData ? "' + " + $schemaValue + " + '" : '' + it.util.escapeQuotes($schema);

      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      out += $isData ? 'validate.schema' + $schemaPath : '' + it.util.toQuotedString($schema);

      out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }
    out += ' } ';
  } else out += ' {} ';

  var __err = out;
  out = $$outStack.pop();
  !it.compositeRule && $breakOnError
    ? it.async
      ? (out += ' throw new ValidationError([' + __err + ']); ')
      : (out += ' validate.errors = [' + __err + ']; return false; ')
    : (out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

  out += ' } ';
  if ($breakOnError) out += ' else { ';

  return out;
}
//
},
'ajv/lib/dotjs/items':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var out = ' ',
    $lvl = it.level,
    $dataLvl = it.dataLevel,
    $schema = it.schema[$keyword],
    $schemaPath = it.schemaPath + it.util.getProperty($keyword),
    $errSchemaPath = it.errSchemaPath + '/' + $keyword,
    $breakOnError = !it.opts.allErrors,
    $data = 'data' + ($dataLvl || ''),
    $valid = 'valid' + $lvl,
    $errs = 'errs__' + $lvl,
    $it = it.util.copy(it),
    $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level,
    $idx = 'i' + $lvl,
    $dataNxt = ($it.dataLevel = it.dataLevel + 1),
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId;
  out += 'var ' + $errs + ' = errors;var ' + $valid + ';';
  if (Array.isArray($schema)) {
    var $additionalItems = it.schema.additionalItems;
    if ($additionalItems === false) {
      out += ' ' + $valid + ' = ' + $data + '.length <= ' + $schema.length + '; ';
      var $currErrSchemaPath = $errSchemaPath;
      $errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += '  if (!' + $valid + ') {   ';
      var $$outStack;
      ($$outStack = $$outStack || []).push(out);
      out = '';
      if (it.createErrors !== false) {
        out +=
          " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it.errorPath +
          ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
          ' , params: { limit: ' + $schema.length + ' } ';
        if (it.opts.messages !== false) out += " , message: 'should NOT have more than " + $schema.length + " items' ";

        if (it.opts.verbose)
          out += ' , schema: false , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';

        out += ' } ';
      } else out += ' {} ';

      var __err = out;
      out = $$outStack.pop();
      !it.compositeRule && $breakOnError
        ? it.async
          ? (out += ' throw new ValidationError([' + __err + ']); ')
          : (out += ' validate.errors = [' + __err + ']; return false; ')
        : (out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

      out += ' } ';
      $errSchemaPath = $currErrSchemaPath;
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
    var arr1 = $schema;
    if (arr1)
      for (var $sch, $i = -1, l1 = arr1.length - 1; $i < l1; ) {
        $sch = arr1[($i += 1)];
        if (it.util.schemaHasRules($sch, it.RULES.all)) {
          out += ' ' + $nextValid + ' = true; if (' + $data + '.length > ' + $i + ') { ';
          var $passData = $data + '[' + $i + ']';
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + '[' + $i + ']';
          $it.errSchemaPath = $errSchemaPath + '/' + $i;
          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
          $it.dataPathArr[$dataNxt] = $i;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          it.util.varOccurences($code, $nextData) < 2
            ? (out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ')
            : (out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ');

          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + $nextValid + ') { ';
            $closingBraces += '}';
          }
        }
      }

    if (typeof $additionalItems == 'object' && it.util.schemaHasRules($additionalItems, it.RULES.all)) {
      $it.schema = $additionalItems;
      $it.schemaPath = it.schemaPath + '.additionalItems';
      $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
      out +=
        ' ' + $nextValid + ' = true; if (' + $data + '.length > ' + $schema.length + ') {  for (var ' +
        $idx + ' = ' + $schema.length + '; ' + $idx + ' < ' + $data + '.length; ' + $idx + '++) { ';
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      $passData = $data + '[' + $idx + ']';
      $it.dataPathArr[$dataNxt] = $idx;
      $code = it.validate($it);
      $it.baseId = $currentBaseId;
      it.util.varOccurences($code, $nextData) < 2
        ? (out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ')
        : (out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ');

      if ($breakOnError) out += ' if (!' + $nextValid + ') break; ';

      out += ' } }  ';
      if ($breakOnError) {
        out += ' if (' + $nextValid + ') { ';
        $closingBraces += '}';
      }
    }
  } else if (it.util.schemaHasRules($schema, it.RULES.all)) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += '  for (var ' + $idx + ' = 0; ' + $idx + ' < ' + $data + '.length; ' + $idx + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    $code = it.validate($it);
    $it.baseId = $currentBaseId;
    it.util.varOccurences($code, $nextData) < 2
      ? (out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ')
      : (out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ');

    if ($breakOnError) out += ' if (!' + $nextValid + ') break; ';

    out += ' }';
  }
  if ($breakOnError) out += ' ' + $closingBraces + ' if (' + $errs + ' == errors) {';

  return it.util.cleanUpCode(out);
}
//
},
'ajv/lib/dotjs/_limit':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var $schemaValue,
    out = ' ',
    $lvl = it.level,
    $dataLvl = it.dataLevel,
    $schema = it.schema[$keyword],
    $schemaPath = it.schemaPath + it.util.getProperty($keyword),
    $errSchemaPath = it.errSchemaPath + '/' + $keyword,
    $breakOnError = !it.opts.allErrors,
    $data = 'data' + ($dataLvl || ''),
    $isData = it.opts.$data && $schema && $schema.$data;
  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else $schemaValue = $schema;

  var $isMax = $keyword == 'maximum',
    $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
    $schemaExcl = it.schema[$exclusiveKeyword],
    $op = $isMax ? '<' : '>',
    $notOp = $isMax ? '>' : '<',
    $errorKeyword = void 0;
  if (it.opts.$data && $schemaExcl && $schemaExcl.$data) {
    var $$outStack,
      $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
      $exclusive = 'exclusive' + $lvl,
      $exclType = 'exclType' + $lvl,
      $exclIsNumber = 'exclIsNumber' + $lvl,
      $opStr = "' + " + ($opExpr = 'op' + $lvl) + " + '";
    out += ' var schemaExcl' + $lvl + ' = ' + $schemaValueExcl + '; ';
    out +=
      ' var ' + $exclusive +
      '; var ' + $exclType + ' = typeof ' + ($schemaValueExcl = 'schemaExcl' + $lvl) +
      '; if (' + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
    $errorKeyword = $exclusiveKeyword;
    ($$outStack = $$outStack || []).push(out);
    out = '';
    if (it.createErrors !== false) {
      out +=
        " { keyword: '" + ($errorKeyword || '_exclusiveLimit') +
        "' , dataPath: (dataPath || '') + " + it.errorPath +
        ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
        ' , params: {} ';
      if (it.opts.messages !== false) out += " , message: '" + $exclusiveKeyword + " should be boolean' ";

      if (it.opts.verbose)
        out +=
          ' , schema: validate.schema' + $schemaPath +
          ' , parentSchema: validate.schema' + it.schemaPath +
          ' , data: ' + $data + ' ';

      out += ' } ';
    } else out += ' {} ';

    var __err = out;
    out = $$outStack.pop();
    !it.compositeRule && $breakOnError
      ? it.async
        ? (out += ' throw new ValidationError([' + __err + ']); ')
        : (out += ' validate.errors = [' + __err + ']; return false; ')
      : (out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

    out += ' } else if ( ';
    if ($isData) out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + " != 'number') || ";

    out +=
      ' ' + $exclType + " == 'number' ? ( (" +
      $exclusive + ' = ' + $schemaValue + ' === undefined || ' +
      $schemaValueExcl + ' ' + $op + '= ' + $schemaValue + ') ? ' +
      $data + ' ' + $notOp + '= ' + $schemaValueExcl + ' : ' +
      $data + ' ' + $notOp + ' ' + $schemaValue + ' ) : ( (' +
      $exclusive + ' = ' + $schemaValueExcl + ' === true) ? ' +
      $data + ' ' + $notOp + '= ' + $schemaValue + ' : ' +
      $data + ' ' + $notOp + ' ' + $schemaValue + ' ) || ' +
      $data + ' !== ' + $data +
      ') { var op' + $lvl + ' = ' + $exclusive + " ? '" + $op + "' : '" + $op + "=';";
  } else {
    $opStr = $op;
    if (($exclIsNumber = typeof $schemaExcl == 'number') && $isData) {
      var $opExpr = "'" + $opStr + "'";
      out += ' if ( ';
      if ($isData) out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + " != 'number') || ";

      out +=
        ' ( ' + $schemaValue + ' === undefined || ' +
        $schemaExcl + ' ' + $op + '= ' + $schemaValue + ' ? ' +
        $data + ' ' + $notOp + '= ' + $schemaExcl + ' : ' +
        $data + ' ' + $notOp + ' ' + $schemaValue + ' ) || ' +
        $data + ' !== ' + $data +
        ') { ';
    } else {
      if ($exclIsNumber && $schema === void 0) {
        $exclusive = true;
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
        $schemaValue = $schemaExcl;
        $notOp += '=';
      } else {
        if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);
        if ($schemaExcl === (!$exclIsNumber || $schemaValue)) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
          $notOp += '=';
        } else {
          $exclusive = false;
          $opStr += '=';
        }
      }
      $opExpr = "'" + $opStr + "'";
      out += ' if ( ';
      if ($isData) out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + " != 'number') || ";

      out += ' ' + $data + ' ' + $notOp + ' ' + $schemaValue + ' || ' + $data + ' !== ' + $data + ') { ';
    }
  }
  $errorKeyword = $errorKeyword || $keyword;
  ($$outStack = $$outStack || []).push(out);
  out = '';
  if (it.createErrors !== false) {
    out +=
      " { keyword: '" + ($errorKeyword || '_limit') +
      "' , dataPath: (dataPath || '') + " + it.errorPath +
      ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
      ' , params: { comparison: ' + $opExpr + ', limit: ' + $schemaValue + ', exclusive: ' + $exclusive + ' } ';
    if (it.opts.messages !== false) {
      out += " , message: 'should be " + $opStr + ' ';
      out += $isData ? "' + " + $schemaValue : $schemaValue + "'";
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      out += $isData ? 'validate.schema' + $schemaPath : '' + $schema;

      out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }
    out += ' } ';
  } else out += ' {} ';

  __err = out;
  out = $$outStack.pop();
  !it.compositeRule && $breakOnError
    ? it.async
      ? (out += ' throw new ValidationError([' + __err + ']); ')
      : (out += ' validate.errors = [' + __err + ']; return false; ')
    : (out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

  out += ' } ';
  if ($breakOnError) out += ' else { ';

  return out;
}
//
},
'ajv/lib/dotjs/_limitItems':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var $schemaValue,
    out = ' ',
    $lvl = it.level,
    $dataLvl = it.dataLevel,
    $schema = it.schema[$keyword],
    $schemaPath = it.schemaPath + it.util.getProperty($keyword),
    $errSchemaPath = it.errSchemaPath + '/' + $keyword,
    $breakOnError = !it.opts.allErrors,
    $data = 'data' + ($dataLvl || ''),
    $isData = it.opts.$data && $schema && $schema.$data;
  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else $schemaValue = $schema;

  out += 'if ( ';
  if ($isData) out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + " != 'number') || ";

  out += ' ' + $data + '.length ' + ($keyword == 'maxItems' ? '>' : '<') + ' ' + $schemaValue + ') { ';
  var $$outStack,
    $errorKeyword = $keyword;
  ($$outStack = $$outStack || []).push(out);
  out = '';
  if (it.createErrors !== false) {
    out +=
      " { keyword: '" + ($errorKeyword || '_limitItems') +
      "' , dataPath: (dataPath || '') + " + it.errorPath +
      ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
      ' , params: { limit: ' + $schemaValue + ' } ';
    if (it.opts.messages !== false) {
      out += " , message: 'should NOT have ";
      out += $keyword == 'maxItems' ? 'more' : 'less';

      out += ' than ';
      out += $isData ? "' + " + $schemaValue + " + '" : '' + $schema;

      out += " items' ";
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      out += $isData ? 'validate.schema' + $schemaPath : '' + $schema;

      out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }
    out += ' } ';
  } else out += ' {} ';

  var __err = out;
  out = $$outStack.pop();
  !it.compositeRule && $breakOnError
    ? it.async
      ? (out += ' throw new ValidationError([' + __err + ']); ')
      : (out += ' validate.errors = [' + __err + ']; return false; ')
    : (out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

  out += '} ';
  if ($breakOnError) out += ' else { ';

  return out;
}
//
},
'ajv/lib/dotjs/_limitLength':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var $schemaValue,
    out = ' ',
    $lvl = it.level,
    $dataLvl = it.dataLevel,
    $schema = it.schema[$keyword],
    $schemaPath = it.schemaPath + it.util.getProperty($keyword),
    $errSchemaPath = it.errSchemaPath + '/' + $keyword,
    $breakOnError = !it.opts.allErrors,
    $data = 'data' + ($dataLvl || ''),
    $isData = it.opts.$data && $schema && $schema.$data;
  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else $schemaValue = $schema;

  var $op = $keyword == 'maxLength' ? '>' : '<';
  out += 'if ( ';
  if ($isData) out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + " != 'number') || ";

  it.opts.unicode === false ? (out += ' ' + $data + '.length ') : (out += ' ucs2length(' + $data + ') ');

  out += ' ' + $op + ' ' + $schemaValue + ') { ';
  var $$outStack,
    $errorKeyword = $keyword;
  ($$outStack = $$outStack || []).push(out);
  out = '';
  if (it.createErrors !== false) {
    out +=
      " { keyword: '" + ($errorKeyword || '_limitLength') +
      "' , dataPath: (dataPath || '') + " + it.errorPath +
      ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
      ' , params: { limit: ' + $schemaValue + ' } ';
    if (it.opts.messages !== false) {
      out += " , message: 'should NOT be ";
      out += $keyword == 'maxLength' ? 'longer' : 'shorter';

      out += ' than ';
      out += $isData ? "' + " + $schemaValue + " + '" : '' + $schema;

      out += " characters' ";
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      out += $isData ? 'validate.schema' + $schemaPath : '' + $schema;

      out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }
    out += ' } ';
  } else out += ' {} ';

  var __err = out;
  out = $$outStack.pop();
  !it.compositeRule && $breakOnError
    ? it.async
      ? (out += ' throw new ValidationError([' + __err + ']); ')
      : (out += ' validate.errors = [' + __err + ']; return false; ')
    : (out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

  out += '} ';
  if ($breakOnError) out += ' else { ';

  return out;
}
//
},
'ajv/lib/dotjs/_limitProperties':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var $schemaValue,
    out = ' ',
    $lvl = it.level,
    $dataLvl = it.dataLevel,
    $schema = it.schema[$keyword],
    $schemaPath = it.schemaPath + it.util.getProperty($keyword),
    $errSchemaPath = it.errSchemaPath + '/' + $keyword,
    $breakOnError = !it.opts.allErrors,
    $data = 'data' + ($dataLvl || ''),
    $isData = it.opts.$data && $schema && $schema.$data;
  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else $schemaValue = $schema;

  out += 'if ( ';
  if ($isData) out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + " != 'number') || ";

  out += ' Object.keys(' + $data + ').length ' + ($keyword == 'maxProperties' ? '>' : '<') + ' ' + $schemaValue + ') { ';
  var $$outStack,
    $errorKeyword = $keyword;
  ($$outStack = $$outStack || []).push(out);
  out = '';
  if (it.createErrors !== false) {
    out +=
      " { keyword: '" + ($errorKeyword || '_limitProperties') +
      "' , dataPath: (dataPath || '') + " + it.errorPath +
      ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
      ' , params: { limit: ' + $schemaValue + ' } ';
    if (it.opts.messages !== false) {
      out += " , message: 'should NOT have ";
      out += $keyword == 'maxProperties' ? 'more' : 'less';

      out += ' than ';
      out += $isData ? "' + " + $schemaValue + " + '" : '' + $schema;

      out += " properties' ";
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      out += $isData ? 'validate.schema' + $schemaPath : '' + $schema;

      out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }
    out += ' } ';
  } else out += ' {} ';

  var __err = out;
  out = $$outStack.pop();
  !it.compositeRule && $breakOnError
    ? it.async
      ? (out += ' throw new ValidationError([' + __err + ']); ')
      : (out += ' validate.errors = [' + __err + ']; return false; ')
    : (out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

  out += '} ';
  if ($breakOnError) out += ' else { ';

  return out;
}
//
},
'ajv/lib/dotjs/multipleOf':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var $schemaValue,
    out = ' ',
    $lvl = it.level,
    $dataLvl = it.dataLevel,
    $schema = it.schema[$keyword],
    $schemaPath = it.schemaPath + it.util.getProperty($keyword),
    $errSchemaPath = it.errSchemaPath + '/' + $keyword,
    $breakOnError = !it.opts.allErrors,
    $data = 'data' + ($dataLvl || ''),
    $isData = it.opts.$data && $schema && $schema.$data;
  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else $schemaValue = $schema;

  out += 'var division' + $lvl + ';if (';
  if ($isData) out += ' ' + $schemaValue + ' !== undefined && ( typeof ' + $schemaValue + " != 'number' || ";

  out += ' (division' + $lvl + ' = ' + $data + ' / ' + $schemaValue + ', ';
  it.opts.multipleOfPrecision
    ? (out +=
        ' Math.abs(Math.round(division' + $lvl + ') - division' + $lvl + ') > 1e-' + it.opts.multipleOfPrecision + ' ')
    : (out += ' division' + $lvl + ' !== parseInt(division' + $lvl + ') ');

  out += ' ) ';
  if ($isData) out += '  )  ';

  out += ' ) {   ';
  var $$outStack;
  ($$outStack = $$outStack || []).push(out);
  out = '';
  if (it.createErrors !== false) {
    out +=
      " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it.errorPath +
      ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
      ' , params: { multipleOf: ' + $schemaValue + ' } ';
    if (it.opts.messages !== false) {
      out += " , message: 'should be multiple of ";
      out += $isData ? "' + " + $schemaValue : $schemaValue + "'";
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      out += $isData ? 'validate.schema' + $schemaPath : '' + $schema;

      out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }
    out += ' } ';
  } else out += ' {} ';

  var __err = out;
  out = $$outStack.pop();
  !it.compositeRule && $breakOnError
    ? it.async
      ? (out += ' throw new ValidationError([' + __err + ']); ')
      : (out += ' validate.errors = [' + __err + ']; return false; ')
    : (out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

  out += '} ';
  if ($breakOnError) out += ' else { ';

  return out;
}
//
},
'ajv/lib/dotjs/not':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var out = ' ',
    $lvl = it.level,
    $dataLvl = it.dataLevel,
    $schema = it.schema[$keyword],
    $schemaPath = it.schemaPath + it.util.getProperty($keyword),
    $errSchemaPath = it.errSchemaPath + '/' + $keyword,
    $breakOnError = !it.opts.allErrors,
    $data = 'data' + ($dataLvl || ''),
    $errs = 'errs__' + $lvl,
    $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  if (it.util.schemaHasRules($schema, it.RULES.all)) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + $errs + ' = errors;  ';
    var $allErrorsOption,
      $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.createErrors = false;
    if ($it.opts.allErrors) {
      $allErrorsOption = $it.opts.allErrors;
      $it.opts.allErrors = false;
    }
    out += ' ' + it.validate($it) + ' ';
    $it.createErrors = true;
    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (' + $nextValid + ') {   ';
    var $$outStack;
    ($$outStack = $$outStack || []).push(out);
    out = '';
    if (it.createErrors !== false) {
      out +=
        " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath +
        ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
        ' , params: {} ';
      if (it.opts.messages !== false) out += " , message: 'should NOT be valid' ";

      if (it.opts.verbose)
        out +=
          ' , schema: validate.schema' + $schemaPath +
          ' , parentSchema: validate.schema' + it.schemaPath +
          ' , data: ' + $data + ' ';

      out += ' } ';
    } else out += ' {} ';

    var __err = out;
    out = $$outStack.pop();
    !it.compositeRule && $breakOnError
      ? it.async
        ? (out += ' throw new ValidationError([' + __err + ']); ')
        : (out += ' validate.errors = [' + __err + ']; return false; ')
      : (out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

    out += ' } else {  errors = ' + $errs +
      '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; } ';
    if (it.opts.allErrors) out += ' } ';
  } else {
    out += '  var err =   ';
    if (it.createErrors !== false) {
      out +=
        " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath +
        ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
        ' , params: {} ';
      if (it.opts.messages !== false) out += " , message: 'should NOT be valid' ";

      if (it.opts.verbose)
        out +=
          ' , schema: validate.schema' + $schemaPath +
          ' , parentSchema: validate.schema' + it.schemaPath +
          ' , data: ' + $data + ' ';

      out += ' } ';
    } else out += ' {} ';

    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if ($breakOnError) out += ' if (false) { ';
  }
  return out;
}
//
},
'ajv/lib/dotjs/oneOf':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var out = ' ',
    $lvl = it.level,
    $dataLvl = it.dataLevel,
    $schema = it.schema[$keyword],
    $schemaPath = it.schemaPath + it.util.getProperty($keyword),
    $errSchemaPath = it.errSchemaPath + '/' + $keyword,
    $breakOnError = !it.opts.allErrors,
    $data = 'data' + ($dataLvl || ''),
    $valid = 'valid' + $lvl,
    $errs = 'errs__' + $lvl,
    $it = it.util.copy(it),
    $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  out += 'var ' + $errs + ' = errors;var prevValid' + $lvl + ' = false;var ' + $valid + ' = false;';
  var $currentBaseId = $it.baseId,
    $wasComposite = it.compositeRule;
  it.compositeRule = $it.compositeRule = true;
  var arr1 = $schema;
  if (arr1)
    for (var $sch, $i = -1, l1 = arr1.length - 1; $i < l1; ) {
      $sch = arr1[($i += 1)];
      if (it.util.schemaHasRules($sch, it.RULES.all)) {
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + it.validate($it) + ' ';
        $it.baseId = $currentBaseId;
      } else out += ' var ' + $nextValid + ' = true; ';

      if ($i) {
        out += ' if (' + $nextValid + ' && prevValid' + $lvl + ') ' + $valid + ' = false; else { ';
        $closingBraces += '}';
      }
      out += ' if (' + $nextValid + ') ' + $valid + ' = prevValid' + $lvl + ' = true;';
    }

  it.compositeRule = $it.compositeRule = $wasComposite;
  out += $closingBraces + 'if (!' + $valid + ') {   var err =   ';
  if (it.createErrors !== false) {
    out +=
      " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it.errorPath +
      ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
      ' , params: {} ';
    if (it.opts.messages !== false) out += " , message: 'should match exactly one schema in oneOf' ";

    if (it.opts.verbose)
      out +=
        ' , schema: validate.schema' + $schemaPath +
        ' , parentSchema: validate.schema' + it.schemaPath +
        ' , data: ' + $data + ' ';

    out += ' } ';
  } else out += ' {} ';

  out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  if (!it.compositeRule && $breakOnError)
    it.async
      ? (out += ' throw new ValidationError(vErrors); ')
      : (out += ' validate.errors = vErrors; return false; ');

  out += '} else {  errors = ' + $errs +
    '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; }';
  if (it.opts.allErrors) out += ' } ';

  return out;
}
//
},
'ajv/lib/dotjs/pattern':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var $schemaValue,
    out = ' ',
    $lvl = it.level,
    $dataLvl = it.dataLevel,
    $schema = it.schema[$keyword],
    $schemaPath = it.schemaPath + it.util.getProperty($keyword),
    $errSchemaPath = it.errSchemaPath + '/' + $keyword,
    $breakOnError = !it.opts.allErrors,
    $data = 'data' + ($dataLvl || ''),
    $isData = it.opts.$data && $schema && $schema.$data;
  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else $schemaValue = $schema;

  out += 'if ( ';
  if ($isData) out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + " != 'string') || ";

  out +=
    ' !' + ($isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema)) + '.test(' + $data + ') ) {   ';
  var $$outStack;
  ($$outStack = $$outStack || []).push(out);
  out = '';
  if (it.createErrors !== false) {
    out +=
      " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it.errorPath +
      ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
      ' , params: { pattern:  ';
    out += $isData ? '' + $schemaValue : '' + it.util.toQuotedString($schema);

    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match pattern "';
      out += $isData ? "' + " + $schemaValue + " + '" : '' + it.util.escapeQuotes($schema);

      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      out += $isData ? 'validate.schema' + $schemaPath : '' + it.util.toQuotedString($schema);

      out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }
    out += ' } ';
  } else out += ' {} ';

  var __err = out;
  out = $$outStack.pop();
  !it.compositeRule && $breakOnError
    ? it.async
      ? (out += ' throw new ValidationError([' + __err + ']); ')
      : (out += ' validate.errors = [' + __err + ']; return false; ')
    : (out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

  out += '} ';
  if ($breakOnError) out += ' else { ';

  return out;
}
//
},
'ajv/lib/dotjs/properties':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var out = ' ',
    $lvl = it.level,
    $dataLvl = it.dataLevel,
    $schema = it.schema[$keyword],
    $schemaPath = it.schemaPath + it.util.getProperty($keyword),
    $errSchemaPath = it.errSchemaPath + '/' + $keyword,
    $breakOnError = !it.opts.allErrors,
    $data = 'data' + ($dataLvl || ''),
    $valid = 'valid' + $lvl,
    $errs = 'errs__' + $lvl,
    $it = it.util.copy(it),
    $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level,
    $key = 'key' + $lvl,
    $idx = 'idx' + $lvl,
    $dataNxt = ($it.dataLevel = it.dataLevel + 1),
    $nextData = 'data' + $dataNxt,
    $dataProperties = 'dataProperties' + $lvl,
    $schemaKeys = Object.keys($schema || {}),
    $pProperties = it.schema.patternProperties || {},
    $pPropertyKeys = Object.keys($pProperties),
    $aProperties = it.schema.additionalProperties,
    $someProperties = $schemaKeys.length || $pPropertyKeys.length,
    $noAdditional = $aProperties === false,
    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,
    $removeAdditional = it.opts.removeAdditional,
    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
    $ownProperties = it.opts.ownProperties,
    $currentBaseId = it.baseId,
    $required = it.schema.required;
  if ($required && (!it.opts.v5 || !$required.$data) && $required.length < it.opts.loopRequired)
    var $requiredHash = it.util.toHash($required);
  if (it.opts.patternGroups)
    var $pgProperties = it.schema.patternGroups || {},
      $pgPropertyKeys = Object.keys($pgProperties);

  out += 'var ' + $errs + ' = errors;var ' + $nextValid + ' = true;';
  if ($ownProperties) out += ' var ' + $dataProperties + ' = undefined;';

  if ($checkAdditional) {
    out += $ownProperties
      ? ' ' + $dataProperties + ' = ' + $dataProperties + ' || Object.keys(' + $data + '); for (var ' +
        $idx + '=0; ' + $idx + '<' + $dataProperties + '.length; ' + $idx + '++) { var ' +
        $key + ' = ' + $dataProperties + '[' + $idx + ']; '
      : ' for (var ' + $key + ' in ' + $data + ') { ';

    if ($someProperties) {
      out += ' var isAdditional' + $lvl + ' = !(false ';
      if ($schemaKeys.length)
        if ($schemaKeys.length > 5) out += ' || validate.schema' + $schemaPath + '[' + $key + '] ';
        else {
          var arr1 = $schemaKeys;
          if (arr1)
            for (var i1 = -1, l1 = arr1.length - 1; i1 < l1; ) {
              $propertyKey = arr1[(i1 += 1)];
              out += ' || ' + $key + ' == ' + it.util.toQuotedString($propertyKey) + ' ';
            }
        }

      if ($pPropertyKeys.length) {
        var arr2 = $pPropertyKeys;
        if (arr2)
          for (var $i = -1, l2 = arr2.length - 1; $i < l2; ) {
            $pProperty = arr2[($i += 1)];
            out += ' || ' + it.usePattern($pProperty) + '.test(' + $key + ') ';
          }
      }
      if (it.opts.patternGroups && $pgPropertyKeys.length) {
        var arr3 = $pgPropertyKeys;
        if (arr3) {
          $i = -1;
          for (var l3 = arr3.length - 1; $i < l3; ) {
            $pgProperty = arr3[($i += 1)];
            out += ' || ' + it.usePattern($pgProperty) + '.test(' + $key + ') ';
          }
        }
      }
      out += ' ); if (isAdditional' + $lvl + ') { ';
    }
    if ($removeAdditional == 'all') out += ' delete ' + $data + '[' + $key + ']; ';
    else {
      var $currentErrorPath = it.errorPath,
        $additionalProperty = "' + " + $key + " + '";
      if (it.opts._errorDataPathProperty)
        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);

      if ($noAdditional)
        if ($removeAdditional) out += ' delete ' + $data + '[' + $key + ']; ';
        else {
          out += ' ' + $nextValid + ' = false; ';
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + '/additionalProperties';
          ($$outStack = $$outStack || []).push(out);
          out = '';
          if (it.createErrors !== false) {
            out +=
              " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it.errorPath +
              ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
              " , params: { additionalProperty: '" + $additionalProperty + "' } ";
            if (it.opts.messages !== false) out += " , message: 'should NOT have additional properties' ";

            if (it.opts.verbose)
              out += ' , schema: false , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';

            out += ' } ';
          } else out += ' {} ';

          var __err = out;
          out = $$outStack.pop();
          !it.compositeRule && $breakOnError
            ? it.async
              ? (out += ' throw new ValidationError([' + __err + ']); ')
              : (out += ' validate.errors = [' + __err + ']; return false; ')
            : (out +=
                ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) out += ' break; ';
        }
      else if ($additionalIsSchema)
        if ($removeAdditional == 'failing') {
          out += ' var ' + $errs + ' = errors;  ';
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty
            ? it.errorPath
            : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          it.util.varOccurences($code, $nextData) < 2
            ? (out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ')
            : (out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ');

          out +=
            ' if (!' + $nextValid + ') { errors = ' + $errs +
            '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' +
            $data + '[' + $key + ']; }  ';
          it.compositeRule = $it.compositeRule = $wasComposite;
        } else {
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty
            ? it.errorPath
            : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          $code = it.validate($it);
          $it.baseId = $currentBaseId;
          it.util.varOccurences($code, $nextData) < 2
            ? (out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ')
            : (out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ');

          if ($breakOnError) out += ' if (!' + $nextValid + ') break; ';
        }

      it.errorPath = $currentErrorPath;
    }
    if ($someProperties) out += ' } ';

    out += ' }  ';
    if ($breakOnError) {
      out += ' if (' + $nextValid + ') { ';
      $closingBraces += '}';
    }
  }
  var $useDefaults = it.opts.useDefaults && !it.compositeRule;
  if ($schemaKeys.length) {
    var arr4 = $schemaKeys;
    if (arr4)
      for (var $propertyKey, i4 = -1, l4 = arr4.length - 1; i4 < l4; ) {
        var $sch = $schema[($propertyKey = arr4[(i4 += 1)])];
        if (it.util.schemaHasRules($sch, it.RULES.all)) {
          var $prop = it.util.getProperty($propertyKey),
            $hasDefault = (($passData = $data + $prop), $useDefaults && $sch.default !== void 0);
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + $prop;
          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
          $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            $code = it.util.varReplace($code, $nextData, $passData);
            var $useData = $passData;
          } else {
            $useData = $nextData;
            out += ' var ' + $nextData + ' = ' + $passData + '; ';
          }
          if ($hasDefault) out += ' ' + $code + ' ';
          else {
            if ($requiredHash && $requiredHash[$propertyKey]) {
              out += ' if ( ' + $useData + ' === undefined ';
              if ($ownProperties)
                out += ' || ! Object.prototype.hasOwnProperty.call(' +
                  $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";

              out += ') { ' + $nextValid + ' = false; ';
              $currentErrorPath = it.errorPath;
              $currErrSchemaPath = $errSchemaPath;
              var $missingProperty = it.util.escapeQuotes($propertyKey);
              if (it.opts._errorDataPathProperty)
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);

              $errSchemaPath = it.errSchemaPath + '/required';
              ($$outStack = $$outStack || []).push(out);
              out = '';
              if (it.createErrors !== false) {
                out +=
                  " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath +
                  ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
                  " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  it.opts._errorDataPathProperty
                    ? (out += 'is a required property')
                    : (out += "should have required property \\'" + $missingProperty + "\\'");

                  out += "' ";
                }
                if (it.opts.verbose)
                  out +=
                    ' , schema: validate.schema' + $schemaPath +
                    ' , parentSchema: validate.schema' + it.schemaPath +
                    ' , data: ' + $data + ' ';

                out += ' } ';
              } else out += ' {} ';

              __err = out;
              out = $$outStack.pop();
              !it.compositeRule && $breakOnError
                ? it.async
                  ? (out += ' throw new ValidationError([' + __err + ']); ')
                  : (out += ' validate.errors = [' + __err + ']; return false; ')
                : (out += ' var err = ' + __err +
                    ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

              $errSchemaPath = $currErrSchemaPath;
              it.errorPath = $currentErrorPath;
              out += ' } else { ';
            } else if ($breakOnError) {
              out += ' if ( ' + $useData + ' === undefined ';
              if ($ownProperties)
                out += ' || ! Object.prototype.hasOwnProperty.call(' +
                  $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";

              out += ') { ' + $nextValid + ' = true; } else { ';
            } else {
              out += ' if (' + $useData + ' !== undefined ';
              if ($ownProperties)
                out += ' &&   Object.prototype.hasOwnProperty.call(' +
                  $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";

              out += ' ) { ';
            }
            out += ' ' + $code + ' } ';
          }
        }
        if ($breakOnError) {
          out += ' if (' + $nextValid + ') { ';
          $closingBraces += '}';
        }
      }
  }
  if ($pPropertyKeys.length) {
    var arr5 = $pPropertyKeys;
    if (arr5)
      for (var $pProperty, i5 = -1, l5 = arr5.length - 1; i5 < l5; ) {
        $sch = $pProperties[($pProperty = arr5[(i5 += 1)])];
        if (it.util.schemaHasRules($sch, it.RULES.all)) {
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
          $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);
          out += $ownProperties
            ? ' ' + $dataProperties + ' = ' + $dataProperties + ' || Object.keys(' + $data + '); for (var ' +
              $idx + '=0; ' + $idx + '<' + $dataProperties + '.length; ' + $idx + '++) { var ' +
              $key + ' = ' + $dataProperties + '[' + $idx + ']; '
            : ' for (var ' + $key + ' in ' + $data + ') { ';

          out += ' if (' + it.usePattern($pProperty) + '.test(' + $key + ')) { ';
          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          $code = it.validate($it);
          $it.baseId = $currentBaseId;
          it.util.varOccurences($code, $nextData) < 2
            ? (out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ')
            : (out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ');

          if ($breakOnError) out += ' if (!' + $nextValid + ') break; ';

          out += ' } ';
          if ($breakOnError) out += ' else ' + $nextValid + ' = true; ';

          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + $nextValid + ') { ';
            $closingBraces += '}';
          }
        }
      }
  }
  if (it.opts.patternGroups && $pgPropertyKeys.length) {
    var arr6 = $pgPropertyKeys;
    if (arr6)
      for (var $pgProperty, i6 = -1, l6 = arr6.length - 1; i6 < l6; ) {
        var $pgSchema = $pgProperties[($pgProperty = arr6[(i6 += 1)])];
        $sch = $pgSchema.schema;
        if (it.util.schemaHasRules($sch, it.RULES.all)) {
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + '.patternGroups' + it.util.getProperty($pgProperty) + '.schema';
          $it.errSchemaPath = it.errSchemaPath + '/patternGroups/' + it.util.escapeFragment($pgProperty) + '/schema';
          out += ' var pgPropCount' + $lvl + ' = 0;  ';
          out += $ownProperties
            ? ' ' + $dataProperties + ' = ' + $dataProperties + ' || Object.keys(' + $data + '); for (var ' +
              $idx + '=0; ' + $idx + '<' + $dataProperties + '.length; ' + $idx + '++) { var ' +
              $key + ' = ' + $dataProperties + '[' + $idx + ']; '
            : ' for (var ' + $key + ' in ' + $data + ') { ';

          out += ' if (' + it.usePattern($pgProperty) + '.test(' + $key + ')) { pgPropCount' + $lvl + '++; ';
          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          $code = it.validate($it);
          $it.baseId = $currentBaseId;
          it.util.varOccurences($code, $nextData) < 2
            ? (out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ')
            : (out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ');

          if ($breakOnError) out += ' if (!' + $nextValid + ') break; ';

          out += ' } ';
          if ($breakOnError) out += ' else ' + $nextValid + ' = true; ';

          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + $nextValid + ') { ';
            $closingBraces += '}';
          }
          var $pgMin = $pgSchema.minimum,
            $pgMax = $pgSchema.maximum;
          if ($pgMin !== void 0 || $pgMax !== void 0) {
            out += ' var ' + $valid + ' = true; ';
            $currErrSchemaPath = $errSchemaPath;
            if ($pgMin !== void 0) {
              var $limit = $pgMin,
                $reason = 'minimum',
                $moreOrLess = 'less';
              out += ' ' + $valid + ' = pgPropCount' + $lvl + ' >= ' + $pgMin + '; ';
              $errSchemaPath = it.errSchemaPath + '/patternGroups/minimum';
              out += '  if (!' + $valid + ') {   ';
              ($$outStack = $$outStack || []).push(out);
              out = '';
              if (it.createErrors !== false) {
                out +=
                  " { keyword: 'patternGroups' , dataPath: (dataPath || '') + " + it.errorPath +
                  ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
                  " , params: { reason: '" + $reason + "', limit: " + $limit +
                  ", pattern: '" + it.util.escapeQuotes($pgProperty) + "' } ";
                if (it.opts.messages !== false)
                  out += " , message: 'should NOT have " + $moreOrLess + ' than ' +
                    $limit + ' properties matching pattern "' + it.util.escapeQuotes($pgProperty) + '"\' ';

                if (it.opts.verbose)
                  out +=
                    ' , schema: validate.schema' + $schemaPath +
                    ' , parentSchema: validate.schema' + it.schemaPath +
                    ' , data: ' + $data + ' ';

                out += ' } ';
              } else out += ' {} ';

              __err = out;
              out = $$outStack.pop();
              !it.compositeRule && $breakOnError
                ? it.async
                  ? (out += ' throw new ValidationError([' + __err + ']); ')
                  : (out += ' validate.errors = [' + __err + ']; return false; ')
                : (out += ' var err = ' + __err +
                    ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

              out += ' } ';
              if ($pgMax !== void 0) out += ' else ';
            }
            if ($pgMax !== void 0) {
              var $$outStack;
              $limit = $pgMax;
              $reason = 'maximum';
              $moreOrLess = 'more';
              out += ' ' + $valid + ' = pgPropCount' + $lvl + ' <= ' + $pgMax + '; ';
              $errSchemaPath = it.errSchemaPath + '/patternGroups/maximum';
              out += '  if (!' + $valid + ') {   ';
              ($$outStack = $$outStack || []).push(out);
              out = '';
              if (it.createErrors !== false) {
                out +=
                  " { keyword: 'patternGroups' , dataPath: (dataPath || '') + " + it.errorPath +
                  ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
                  " , params: { reason: '" + $reason + "', limit: " + $limit +
                  ", pattern: '" + it.util.escapeQuotes($pgProperty) + "' } ";
                if (it.opts.messages !== false)
                  out += " , message: 'should NOT have " + $moreOrLess + ' than ' +
                    $limit + ' properties matching pattern "' + it.util.escapeQuotes($pgProperty) + '"\' ';

                if (it.opts.verbose)
                  out +=
                    ' , schema: validate.schema' + $schemaPath +
                    ' , parentSchema: validate.schema' + it.schemaPath +
                    ' , data: ' + $data + ' ';

                out += ' } ';
              } else out += ' {} ';

              __err = out;
              out = $$outStack.pop();
              !it.compositeRule && $breakOnError
                ? it.async
                  ? (out += ' throw new ValidationError([' + __err + ']); ')
                  : (out += ' validate.errors = [' + __err + ']; return false; ')
                : (out += ' var err = ' + __err +
                    ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

              out += ' } ';
            }
            $errSchemaPath = $currErrSchemaPath;
            if ($breakOnError) {
              out += ' if (' + $valid + ') { ';
              $closingBraces += '}';
            }
          }
        }
      }
  }
  if ($breakOnError) out += ' ' + $closingBraces + ' if (' + $errs + ' == errors) {';

  return it.util.cleanUpCode(out);
}
//
},
'ajv/lib/dotjs/propertyNames':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var out = ' ',
    $lvl = it.level,
    $dataLvl = it.dataLevel,
    $schema = it.schema[$keyword],
    $schemaPath = it.schemaPath + it.util.getProperty($keyword),
    $errSchemaPath = it.errSchemaPath + '/' + $keyword,
    $breakOnError = !it.opts.allErrors,
    $data = 'data' + ($dataLvl || ''),
    $errs = 'errs__' + $lvl,
    $it = it.util.copy(it),
    $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  if (it.util.schemaHasRules($schema, it.RULES.all)) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    var $key = 'key' + $lvl,
      $idx = 'idx' + $lvl,
      $i = 'i' + $lvl,
      $invalidName = "' + " + $key + " + '",
      $nextData = 'data' + ($it.dataLevel = it.dataLevel + 1),
      $dataProperties = 'dataProperties' + $lvl,
      $ownProperties = it.opts.ownProperties,
      $currentBaseId = it.baseId;
    out += ' var ' + $errs + ' = errors; ';
    if ($ownProperties) out += ' var ' + $dataProperties + ' = undefined; ';

    out += $ownProperties
      ? ' ' + $dataProperties + ' = ' + $dataProperties + ' || Object.keys(' + $data + '); for (var ' +
        $idx + '=0; ' + $idx + '<' + $dataProperties + '.length; ' + $idx + '++) { var ' +
        $key + ' = ' + $dataProperties + '[' + $idx + ']; '
      : ' for (var ' + $key + ' in ' + $data + ') { ';

    out += ' var startErrs' + $lvl + ' = errors; ';
    var $passData = $key,
      $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    it.util.varOccurences($code, $nextData) < 2
      ? (out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ')
      : (out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ');

    it.compositeRule = $it.compositeRule = $wasComposite;
    out +=
      ' if (!' + $nextValid + ') { for (var ' + $i + '=startErrs' + $lvl + '; ' +
      $i + '<errors; ' + $i + '++) { vErrors[' + $i + '].propertyName = ' + $key +
      '; }   var err =   ';
    if (it.createErrors !== false) {
      out +=
        " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it.errorPath +
        ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
        " , params: { propertyName: '" + $invalidName + "' } ";
      if (it.opts.messages !== false) out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";

      if (it.opts.verbose)
        out +=
          ' , schema: validate.schema' + $schemaPath +
          ' , parentSchema: validate.schema' + it.schemaPath +
          ' , data: ' + $data + ' ';

      out += ' } ';
    } else out += ' {} ';

    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError)
      it.async
        ? (out += ' throw new ValidationError(vErrors); ')
        : (out += ' validate.errors = vErrors; return false; ');

    if ($breakOnError) out += ' break; ';

    out += ' } }';
  }
  if ($breakOnError) out += ' ' + $closingBraces + ' if (' + $errs + ' == errors) {';

  return it.util.cleanUpCode(out);
}
//
},
'ajv/lib/dotjs/required':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var out = ' ',
    $lvl = it.level,
    $dataLvl = it.dataLevel,
    $schema = it.schema[$keyword],
    $schemaPath = it.schemaPath + it.util.getProperty($keyword),
    $errSchemaPath = it.errSchemaPath + '/' + $keyword,
    $breakOnError = !it.opts.allErrors,
    $data = 'data' + ($dataLvl || ''),
    $valid = 'valid' + $lvl,
    $isData = it.opts.$data && $schema && $schema.$data;
  if ($isData) out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';

  var $vSchema = 'schema' + $lvl;
  if (!$isData)
    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
      var $required = [],
        arr1 = $schema;
      if (arr1)
        for (var $property, i1 = -1, l1 = arr1.length - 1; i1 < l1; ) {
          $property = arr1[(i1 += 1)];
          var $propertySch = it.schema.properties[$property];
          ($propertySch && it.util.schemaHasRules($propertySch, it.RULES.all)) ||
            ($required[$required.length] = $property);
        }
    } else $required = $schema;

  if ($isData || $required.length) {
    var $currentErrorPath = it.errorPath,
      $loopRequired = $isData || $required.length >= it.opts.loopRequired,
      $ownProperties = it.opts.ownProperties;
    if ($breakOnError) {
      out += ' var missing' + $lvl + '; ';
      if ($loopRequired) {
        $isData || (out += ' var ' + $vSchema + ' = validate.schema' + $schemaPath + '; ');

        var $missingProperty = "' + " + ($propertyPath = 'schema' + $lvl + '[' + ($i = 'i' + $lvl) + ']') + " + '";
        if (it.opts._errorDataPathProperty)
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);

        out += ' var ' + $valid + ' = true; ';
        if ($isData)
          out +=
            ' if (schema' + $lvl + ' === undefined) ' +
            $valid + ' = true; else if (!Array.isArray(schema' + $lvl + ')) ' +
            $valid + ' = false; else {';

        out +=
          ' for (var ' + $i + ' = 0; ' + $i + ' < ' + $vSchema + '.length; ' + $i + '++) { ' +
          $valid + ' = ' + $data + '[' + $vSchema + '[' + $i + ']] !== undefined ';
        if ($ownProperties)
          out += ' &&   Object.prototype.hasOwnProperty.call(' + $data + ', ' + $vSchema + '[' + $i + ']) ';

        out += '; if (!' + $valid + ') break; } ';
        if ($isData) out += '  }  ';

        out += '  if (!' + $valid + ') {   ';
        ($$outStack = $$outStack || []).push(out);
        out = '';
        if (it.createErrors !== false) {
          out +=
            " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath +
            ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
            " , params: { missingProperty: '" + $missingProperty + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: '";
            it.opts._errorDataPathProperty
              ? (out += 'is a required property')
              : (out += "should have required property \\'" + $missingProperty + "\\'");

            out += "' ";
          }
          if (it.opts.verbose)
            out +=
              ' , schema: validate.schema' + $schemaPath +
              ' , parentSchema: validate.schema' + it.schemaPath +
              ' , data: ' + $data + ' ';

          out += ' } ';
        } else out += ' {} ';

        var __err = out;
        out = $$outStack.pop();
        !it.compositeRule && $breakOnError
          ? it.async
            ? (out += ' throw new ValidationError([' + __err + ']); ')
            : (out += ' validate.errors = [' + __err + ']; return false; ')
          : (out +=
              ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

        out += ' } else { ';
      } else {
        out += ' if ( ';
        var $$outStack,
          arr2 = $required;
        if (arr2)
          for (var $i = -1, l2 = arr2.length - 1; $i < l2; ) {
            $propertyKey = arr2[($i += 1)];
            if ($i) out += ' || ';

            out += ' ( ( ' + ($useData = $data + ($prop = it.util.getProperty($propertyKey))) + ' === undefined ';
            if ($ownProperties)
              out += ' || ! Object.prototype.hasOwnProperty.call(' +
                $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";

            out += ') && (missing' + $lvl + ' = ' +
              it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ') ) ';
          }

        out += ') {  ';
        $missingProperty = "' + " + ($propertyPath = 'missing' + $lvl) + " + '";
        if (it.opts._errorDataPathProperty)
          it.errorPath = it.opts.jsonPointers
            ? it.util.getPathExpr($currentErrorPath, $propertyPath, true)
            : $currentErrorPath + ' + ' + $propertyPath;

        ($$outStack = $$outStack || []).push(out);
        out = '';
        if (it.createErrors !== false) {
          out +=
            " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath +
            ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
            " , params: { missingProperty: '" + $missingProperty + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: '";
            it.opts._errorDataPathProperty
              ? (out += 'is a required property')
              : (out += "should have required property \\'" + $missingProperty + "\\'");

            out += "' ";
          }
          if (it.opts.verbose)
            out +=
              ' , schema: validate.schema' + $schemaPath +
              ' , parentSchema: validate.schema' + it.schemaPath +
              ' , data: ' + $data + ' ';

          out += ' } ';
        } else out += ' {} ';

        __err = out;
        out = $$outStack.pop();
        !it.compositeRule && $breakOnError
          ? it.async
            ? (out += ' throw new ValidationError([' + __err + ']); ')
            : (out += ' validate.errors = [' + __err + ']; return false; ')
          : (out +=
              ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

        out += ' } else { ';
      }
    } else if ($loopRequired) {
      $isData || (out += ' var ' + $vSchema + ' = validate.schema' + $schemaPath + '; ');

      var $propertyPath = 'schema' + $lvl + '[' + ($i = 'i' + $lvl) + ']';
      $missingProperty = "' + " + $propertyPath + " + '";
      if (it.opts._errorDataPathProperty)
        it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);

      if ($isData) {
        out += ' if (' + $vSchema + ' && !Array.isArray(' + $vSchema + ')) {  var err =   ';
        if (it.createErrors !== false) {
          out +=
            " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath +
            ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
            " , params: { missingProperty: '" + $missingProperty + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: '";
            it.opts._errorDataPathProperty
              ? (out += 'is a required property')
              : (out += "should have required property \\'" + $missingProperty + "\\'");

            out += "' ";
          }
          if (it.opts.verbose)
            out +=
              ' , schema: validate.schema' + $schemaPath +
              ' , parentSchema: validate.schema' + it.schemaPath +
              ' , data: ' + $data + ' ';

          out += ' } ';
        } else out += ' {} ';

        out +=
          ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' +
          $vSchema + ' !== undefined) { ';
      }
      out +=
        ' for (var ' + $i + ' = 0; ' + $i + ' < ' + $vSchema + '.length; ' + $i + '++) { if (' +
        $data + '[' + $vSchema + '[' + $i + ']] === undefined ';
      if ($ownProperties)
        out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', ' + $vSchema + '[' + $i + ']) ';

      out += ') {  var err =   ';
      if (it.createErrors !== false) {
        out +=
          " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath +
          ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
          " , params: { missingProperty: '" + $missingProperty + "' } ";
        if (it.opts.messages !== false) {
          out += " , message: '";
          it.opts._errorDataPathProperty
            ? (out += 'is a required property')
            : (out += "should have required property \\'" + $missingProperty + "\\'");

          out += "' ";
        }
        if (it.opts.verbose)
          out +=
            ' , schema: validate.schema' + $schemaPath +
            ' , parentSchema: validate.schema' + it.schemaPath +
            ' , data: ' + $data + ' ';

        out += ' } ';
      } else out += ' {} ';

      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';
      if ($isData) out += '  }  ';
    } else {
      var arr3 = $required;
      if (arr3)
        for (var $propertyKey, i3 = -1, l3 = arr3.length - 1; i3 < l3; ) {
          $propertyKey = arr3[(i3 += 1)];
          var $prop = it.util.getProperty($propertyKey),
            $useData = (($missingProperty = it.util.escapeQuotes($propertyKey)), $data + $prop);
          if (it.opts._errorDataPathProperty)
            it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);

          out += ' if ( ' + $useData + ' === undefined ';
          if ($ownProperties)
            out +=
              ' || ! Object.prototype.hasOwnProperty.call(' + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";

          out += ') {  var err =   ';
          if (it.createErrors !== false) {
            out +=
              " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath +
              ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
              " , params: { missingProperty: '" + $missingProperty + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: '";
              it.opts._errorDataPathProperty
                ? (out += 'is a required property')
                : (out += "should have required property \\'" + $missingProperty + "\\'");

              out += "' ";
            }
            if (it.opts.verbose)
              out +=
                ' , schema: validate.schema' + $schemaPath +
                ' , parentSchema: validate.schema' + it.schemaPath +
                ' , data: ' + $data + ' ';

            out += ' } ';
          } else out += ' {} ';

          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
        }
    }
    it.errorPath = $currentErrorPath;
  } else if ($breakOnError) out += ' if (true) {';

  return out;
}
//
},
'ajv/lib/dotjs/uniqueItems':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var $schemaValue,
    out = ' ',
    $lvl = it.level,
    $dataLvl = it.dataLevel,
    $schema = it.schema[$keyword],
    $schemaPath = it.schemaPath + it.util.getProperty($keyword),
    $errSchemaPath = it.errSchemaPath + '/' + $keyword,
    $breakOnError = !it.opts.allErrors,
    $data = 'data' + ($dataLvl || ''),
    $valid = 'valid' + $lvl,
    $isData = it.opts.$data && $schema && $schema.$data;
  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else $schemaValue = $schema;

  if (($schema || $isData) && it.opts.uniqueItems !== false) {
    if ($isData)
      out +=
        ' var ' + $valid + '; if (' + $schemaValue + ' === false || ' + $schemaValue + ' === undefined) ' +
        $valid + ' = true; else if (typeof ' + $schemaValue + " != 'boolean') " +
        $valid + ' = false; else { ';

    out +=
      ' var ' + $valid + ' = true; if (' + $data + '.length > 1) { var i = ' +
      $data + '.length, j; outer: for (;i--;) { for (j = i; j--;) { if (equal(' + $data + '[i], ' + $data + '[j])) { ' +
      $valid + ' = false; break outer; } } } } ';
    if ($isData) out += '  }  ';

    out += ' if (!' + $valid + ') {   ';
    var $$outStack;
    ($$outStack = $$outStack || []).push(out);
    out = '';
    if (it.createErrors !== false) {
      out +=
        " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it.errorPath +
        ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
        ' , params: { i: i, j: j } ';
      if (it.opts.messages !== false)
        out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";

      if (it.opts.verbose) {
        out += ' , schema:  ';
        out += $isData ? 'validate.schema' + $schemaPath : '' + $schema;

        out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
      }
      out += ' } ';
    } else out += ' {} ';

    var __err = out;
    out = $$outStack.pop();
    !it.compositeRule && $breakOnError
      ? it.async
        ? (out += ' throw new ValidationError([' + __err + ']); ')
        : (out += ' validate.errors = [' + __err + ']; return false; ')
      : (out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

    out += ' } ';
    if ($breakOnError) out += ' else { ';
  } else if ($breakOnError) out += ' if (true) { ';

  return out;
}
//
},
'ajv/lib/$data':
function(module) {
//
var KEYWORDS = [
  'multipleOf',
  'maximum',
  'exclusiveMaximum',
  'minimum',
  'exclusiveMinimum',
  'maxLength',
  'minLength',
  'pattern',
  'additionalItems',
  'maxItems',
  'minItems',
  'uniqueItems',
  'maxProperties',
  'minProperties',
  'required',
  'additionalProperties',
  'enum',
  'format',
  'const'
];

module.exports = function(metaSchema, keywordsJsonPointers) {
  for (var i = 0; i < keywordsJsonPointers.length; i++) {
    metaSchema = JSON.parse(JSON.stringify(metaSchema));
    var j,
      segments = keywordsJsonPointers[i].split('/'),
      keywords = metaSchema;
    for (j = 1; j < segments.length; j++) keywords = keywords[segments[j]];

    for (j = 0; j < KEYWORDS.length; j++) {
      var key = KEYWORDS[j],
        schema = keywords[key];
      if (schema)
        keywords[key] = {
          anyOf: [schema, {$ref: 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#'}]
        };
    }
  }

  return metaSchema;
};
//
},
'ajv/lib/patternGroups':
function(module) {
//
var META_SCHEMA_ID = 'http://json-schema.org/draft-06/schema';

module.exports = function(ajv) {
  var defaultMeta = ajv._opts.defaultMeta;
  var metaSchemaRef =
    typeof defaultMeta == 'string' ? {$ref: defaultMeta} : ajv.getSchema(META_SCHEMA_ID) ? {$ref: META_SCHEMA_ID} : {};

  ajv.addKeyword('patternGroups', {
    metaSchema: {
      type: 'object',
      additionalProperties: {
        type: 'object',
        required: ['schema'],
        properties: {
          maximum: {type: 'integer', minimum: 0},
          minimum: {type: 'integer', minimum: 0},
          schema: metaSchemaRef
        },
        additionalProperties: false
      }
    }
  });
  ajv.RULES.all.properties.implements.push('patternGroups');
};
//
},
'ajv/lib/compile/async':
function(module, exports, __wpreq__) {
//
var MissingRefError = __wpreq__('ajv/lib/compile/error_classes').MissingRef;

module.exports = compileAsync;

function compileAsync(schema, meta, callback) {
  var self = this;
  if (typeof this._opts.loadSchema != 'function') throw new Error('options.loadSchema should be a function');

  if (typeof meta == 'function') {
    callback = meta;
    meta = void 0;
  }

  var p = loadMetaSchemaOf(schema).then(function() {
    var schemaObj = self._addSchema(schema, void 0, meta);
    return schemaObj.validate || _compileAsync(schemaObj);
  });

  callback &&
    p.then(function(v) {
      callback(null, v);
    }, callback);

  return p;

  function loadMetaSchemaOf(sch) {
    var $schema = sch.$schema;
    return $schema && !self.getSchema($schema) ? compileAsync.call(self, {$ref: $schema}, true) : Promise.resolve();
  }

  function _compileAsync(schemaObj) {
    try {
      return self._compile(schemaObj);
    } catch (e) {
      if (e instanceof MissingRefError) return loadMissingSchema(e);
      throw e;
    }

    function loadMissingSchema(e) {
      var ref = e.missingSchema;
      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');

      var schemaPromise = self._loadingSchemas[ref];
      schemaPromise ||
        (schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref)).then(removePromise, removePromise);

      return schemaPromise.then(function(sch) {
        if (!added(ref))
          return loadMetaSchemaOf(sch).then(function() {
            added(ref) || self.addSchema(sch, ref, void 0, meta);
          });
      }).then(function() {
        return _compileAsync(schemaObj);
      });

      function removePromise() {
        delete self._loadingSchemas[ref];
      }

      function added(ref) {
        return self._refs[ref] || self._schemas[ref];
      }
    }
  }
}
//
},
'ajv/lib/keyword':
function(module, exports, __wpreq__) {
//
var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i,
  customRuleCode = __wpreq__('ajv/lib/dotjs/custom');

module.exports = {
  add: addKeyword,
  get: getKeyword,
  remove: removeKeyword
};

function addKeyword(keyword, definition) {
  var RULES = this.RULES;

  if (RULES.keywords[keyword]) throw new Error('Keyword ' + keyword + ' is already defined');

  if (!IDENTIFIER.test(keyword)) throw new Error('Keyword ' + keyword + ' is not a valid identifier');

  if (definition) {
    if (definition.macro && definition.valid !== void 0)
      throw new Error('"valid" option cannot be used with macro keywords');

    var dataType = definition.type;
    if (Array.isArray(dataType)) {
      var i, len = dataType.length;
      for (i = 0; i < len; i++) checkDataType(dataType[i]);
      for (i = 0; i < len; i++) _addRule(keyword, dataType[i], definition);
    } else {
      dataType && checkDataType(dataType);
      _addRule(keyword, dataType, definition);
    }

    var $data = definition.$data === true && this._opts.$data;
    if ($data && !definition.validate) throw new Error('$data support: "validate" function is not defined');

    var metaSchema = definition.metaSchema;
    if (metaSchema) {
      if ($data)
        metaSchema = {
          anyOf: [metaSchema, {$ref: 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#'}]
        };

      definition.validateSchema = this.compile(metaSchema, true);
    }
  }

  RULES.keywords[keyword] = RULES.all[keyword] = true;

  function _addRule(keyword, dataType, definition) {
    var ruleGroup;
    for (var i = 0; i < RULES.length; i++) {
      var rg = RULES[i];
      if (rg.type == dataType) {
        ruleGroup = rg;
        break;
      }
    }

    if (!ruleGroup) {
      ruleGroup = {type: dataType, rules: []};
      RULES.push(ruleGroup);
    }

    var rule = {
      keyword: keyword,
      definition: definition,
      custom: true,
      code: customRuleCode,
      implements: definition.implements
    };
    ruleGroup.rules.push(rule);
    RULES.custom[keyword] = rule;
  }

  function checkDataType(dataType) {
    if (!RULES.types[dataType]) throw new Error('Unknown type ' + dataType);
  }

  return this;
}

function getKeyword(keyword) {
  var rule = this.RULES.custom[keyword];
  return rule ? rule.definition : this.RULES.keywords[keyword] || false;
}

function removeKeyword(keyword) {
  var RULES = this.RULES;
  delete RULES.keywords[keyword];
  delete RULES.all[keyword];
  delete RULES.custom[keyword];
  for (var i = 0; i < RULES.length; i++)
    for (var rules = RULES[i].rules, j = 0; j < rules.length; j++)
      if (rules[j].keyword == keyword) {
        rules.splice(j, 1);
        break;
      }

  return this;
}
//
},
'ajv/lib/dotjs/custom':
function(module) {
//
module.exports = function(it, $keyword, $ruleType) {
  var $errorKeyword,
    $schemaValue,
    out = ' ',
    $lvl = it.level,
    $dataLvl = it.dataLevel,
    $schema = it.schema[$keyword],
    $schemaPath = it.schemaPath + it.util.getProperty($keyword),
    $errSchemaPath = it.errSchemaPath + '/' + $keyword,
    $breakOnError = !it.opts.allErrors,
    $data = 'data' + ($dataLvl || ''),
    $valid = 'valid' + $lvl,
    $errs = 'errs__' + $lvl,
    $isData = it.opts.$data && $schema && $schema.$data;
  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else $schemaValue = $schema;

  var $compile, $inline, $macro, $ruleValidate, $validateCode;
  var $rule = this,
    $definition = 'definition' + $lvl,
    $rDef = $rule.definition,
    $closingBraces = '';
  if ($isData && $rDef.$data) {
    $validateCode = 'keywordValidate' + $lvl;
    var $validateSchema = $rDef.validateSchema;
    out +=
      ' var ' + $definition + " = RULES.custom['" + $keyword + "'].definition; var " +
      $validateCode + ' = ' + $definition + '.validate;';
  } else {
    if (!($ruleValidate = it.useCustomRule($rule, $schema, it.schema, it))) return;
    $schemaValue = 'validate.schema' + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $inline = $rDef.inline;
    $macro = $rDef.macro;
  }
  var $ruleErrs = $validateCode + '.errors',
    $i = 'i' + $lvl,
    $ruleErr = 'ruleErr' + $lvl,
    $asyncKeyword = $rDef.async;
  if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');
  $inline || $macro || (out += $ruleErrs + ' = null;');

  out += 'var ' + $errs + ' = errors;var ' + $valid + ';';
  if ($isData && $rDef.$data) {
    $closingBraces += '}';
    out += ' if (' + $schemaValue + ' === undefined) { ' + $valid + ' = true; } else { ';
    if ($validateSchema) {
      $closingBraces += '}';
      out += ' ' + $valid + ' = ' + $definition + '.validateSchema(' + $schemaValue + '); if (' + $valid + ') { ';
    }
  }
  if ($inline)
    $rDef.statements
      ? (out += ' ' + $ruleValidate.validate + ' ')
      : (out += ' ' + $valid + ' = ' + $ruleValidate.validate + '; ');
  else if ($macro) {
    var $it = it.util.copy(it);
    $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    $it.schema = $ruleValidate.validate;
    $it.schemaPath = '';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + $code;
  } else {
    ($$outStack = $$outStack || []).push(out);
    out = '';
    out += '  ' + $validateCode + '.call( ';
    it.opts.passContext ? (out += 'this') : (out += 'self');

    $compile || $rDef.schema === false
      ? (out += ' , ' + $data + ' ')
      : (out += ' , ' + $schemaValue + ' , ' + $data + ' , validate.schema' + it.schemaPath + ' ');

    out += " , (dataPath || '')";
    if (it.errorPath != '""') out += ' + ' + it.errorPath;

    var $parentData = $dataLvl ? 'data' + ($dataLvl - 1 || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty',
      def_callRuleValidate = (out += ' , ' + $parentData + ' , ' + $parentDataProperty + ' , rootData )  ');
    out = $$outStack.pop();
    if ($rDef.errors === false) {
      out += ' ' + $valid + ' = ';
      if ($asyncKeyword) out += '' + it.yieldAwait;

      out += def_callRuleValidate + '; ';
    } else
      out += $asyncKeyword
        ? ' var ' + ($ruleErrs = 'customErrors' + $lvl) + ' = null; try { ' +
          $valid + ' = ' + it.yieldAwait + def_callRuleValidate + '; } catch (e) { ' +
          $valid + ' = false; if (e instanceof ValidationError) ' +
          $ruleErrs + ' = e.errors; else throw e; } '
        : ' ' + $ruleErrs + ' = null; ' + $valid + ' = ' + def_callRuleValidate + '; ';
  }
  if ($rDef.modifying)
    out += ' if (' + $parentData + ') ' + $data + ' = ' + $parentData + '[' + $parentDataProperty + '];';

  out += '' + $closingBraces;
  if ($rDef.valid) {
    if ($breakOnError) out += ' if (true) { ';
  } else {
    out += ' if ( ';
    if ($rDef.valid === void 0) {
      out += ' !';
      out += $macro ? '' + $nextValid : '' + $valid;
    } else out += ' ' + !$rDef.valid + ' ';

    out += ') { ';
    $errorKeyword = $rule.keyword;
    var $$outStack;
    ($$outStack = $$outStack || []).push(out);
    out = '';
    ($$outStack = $$outStack || []).push(out);
    out = '';
    if (it.createErrors !== false) {
      out +=
        " { keyword: '" + ($errorKeyword || 'custom') +
        "' , dataPath: (dataPath || '') + " + it.errorPath +
        ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
        " , params: { keyword: '" + $rule.keyword + "' } ";
      if (it.opts.messages !== false)
        out += ' , message: \'should pass "' + $rule.keyword + '" keyword validation\' ';

      if (it.opts.verbose)
        out +=
          ' , schema: validate.schema' + $schemaPath +
          ' , parentSchema: validate.schema' + it.schemaPath +
          ' , data: ' + $data + ' ';

      out += ' } ';
    } else out += ' {} ';

    var __err = out;
    out = $$outStack.pop();
    !it.compositeRule && $breakOnError
      ? it.async
        ? (out += ' throw new ValidationError([' + __err + ']); ')
        : (out += ' validate.errors = [' + __err + ']; return false; ')
      : (out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ');

    var def_customError = out;
    out = $$outStack.pop();
    if ($inline)
      if ($rDef.errors) {
        if ($rDef.errors != 'full') {
          out +=
            '  for (var ' + $i + '=' + $errs + '; ' + $i + '<errors; ' + $i + '++) { var ' +
            $ruleErr + ' = vErrors[' + $i + ']; if (' + $ruleErr + '.dataPath === undefined) ' +
            $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath +
            '; if (' + $ruleErr + '.schemaPath === undefined) { ' +
            $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
          if (it.opts.verbose)
            out += ' ' + $ruleErr + '.schema = ' + $schemaValue + '; ' + $ruleErr + '.data = ' + $data + '; ';

          out += ' } ';
        }
      } else if ($rDef.errors === false) out += ' ' + def_customError + ' ';
      else {
        out +=
          ' if (' + $errs + ' == errors) { ' + def_customError +
          ' } else {  for (var ' + $i + '=' + $errs + '; ' + $i + '<errors; ' + $i + '++) { var ' +
          $ruleErr + ' = vErrors[' + $i + ']; if (' + $ruleErr + '.dataPath === undefined) ' +
          $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath +
          '; if (' + $ruleErr + '.schemaPath === undefined) { ' +
          $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
        if (it.opts.verbose)
          out += ' ' + $ruleErr + '.schema = ' + $schemaValue + '; ' + $ruleErr + '.data = ' + $data + '; ';

        out += ' } } ';
      }
    else if ($macro) {
      out += '   var err =   ';
      if (it.createErrors !== false) {
        out +=
          " { keyword: '" + ($errorKeyword || 'custom') +
          "' , dataPath: (dataPath || '') + " + it.errorPath +
          ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) +
          " , params: { keyword: '" + $rule.keyword + "' } ";
        if (it.opts.messages !== false)
          out += ' , message: \'should pass "' + $rule.keyword + '" keyword validation\' ';

        if (it.opts.verbose)
          out +=
            ' , schema: validate.schema' + $schemaPath +
            ' , parentSchema: validate.schema' + it.schemaPath +
            ' , data: ' + $data + ' ';

        out += ' } ';
      } else out += ' {} ';

      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      if (!it.compositeRule && $breakOnError)
        it.async
          ? (out += ' throw new ValidationError(vErrors); ')
          : (out += ' validate.errors = vErrors; return false; ');
    } else if ($rDef.errors === false) out += ' ' + def_customError + ' ';
    else {
      out +=
        ' if (Array.isArray(' + $ruleErrs + ')) { if (vErrors === null) vErrors = ' + $ruleErrs +
        '; else vErrors = vErrors.concat(' + $ruleErrs + '); errors = vErrors.length;  for (var ' +
        $i + '=' + $errs + '; ' + $i + '<errors; ' + $i + '++) { var ' +
        $ruleErr + ' = vErrors[' + $i + ']; if (' + $ruleErr + '.dataPath === undefined) ' +
        $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ';  ' +
        $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
      if (it.opts.verbose)
        out += ' ' + $ruleErr + '.schema = ' + $schemaValue + '; ' + $ruleErr + '.data = ' + $data + '; ';

      out += ' } } else { ' + def_customError + ' } ';
    }
    out += ' } ';
    if ($breakOnError) out += ' else { ';
  }
  return out;
};
//
},
'ajv/lib/refs/$data.json':
function(module) {
//
module.exports = JSON.parse(
  '{"$schema":"http://json-schema.org/draft-06/schema#","$id":"https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#","description":"Meta-schema for $data reference (JSON-schema extension proposal)","type":"object","required":["$data"],"properties":{"$data":{"type":"string","anyOf":[{"format":"relative-json-pointer"},{"format":"json-pointer"}]}},"additionalProperties":false}'
);
//
},
'ajv/lib/refs/json-schema-draft-06.json':
function(module) {
//
module.exports = JSON.parse(
  '{"$schema":"http://json-schema.org/draft-06/schema#","$id":"http://json-schema.org/draft-06/schema#","title":"Core schema meta-schema","definitions":{"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"allOf":[{"$ref":"#/definitions/nonNegativeInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}},"type":["object","boolean"],"properties":{"$id":{"type":"string","format":"uri-reference"},"$schema":{"type":"string","format":"uri"},"$ref":{"type":"string","format":"uri-reference"},"title":{"type":"string"},"description":{"type":"string"},"default":{},"examples":{"type":"array","items":{}},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/definitions/nonNegativeInteger"},"minLength":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"$ref":"#"},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":{}},"maxItems":{"$ref":"#/definitions/nonNegativeInteger"},"minItems":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"contains":{"$ref":"#"},"maxProperties":{"$ref":"#/definitions/nonNegativeInteger"},"minProperties":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"$ref":"#"},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"propertyNames":{"$ref":"#"},"const":{},"enum":{"type":"array","minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}},"default":{}}'
);
//
},
'har-validator/lib/error':
function(module) {
//
function HARError(errors) {
  var message = 'validation failed'

  this.name = 'HARError'
  this.message = message
  this.errors = errors

  typeof Error.captureStackTrace == 'function'
    ? Error.captureStackTrace(this, this.constructor)
    : (this.stack = new Error(message).stack)
}

HARError.prototype = Error.prototype

module.exports = HARError
//
},
'har-schema':
function(module, exports, __wpreq__) {
//
module.exports = {
  cookie: __wpreq__('har-schema/lib/cookie.json'),
  header: __wpreq__('har-schema/lib/header.json'),
  postData: __wpreq__('har-schema/lib/postData.json'),
  query: __wpreq__('har-schema/lib/query.json'),
  request: __wpreq__('har-schema/lib/request.json')
}
//
},
'har-schema/lib/cookie.json':
function(module) {
//
module.exports = JSON.parse(
  '{"$id":"cookie.json#","$schema":"http://json-schema.org/draft-06/schema#","type":"object","required":["name","value"],"properties":{"name":{"type":"string"},"value":{"type":"string"},"path":{"type":"string"},"domain":{"type":"string"},"expires":{"type":["string","null"],"format":"date-time"},"httpOnly":{"type":"boolean"},"secure":{"type":"boolean"},"comment":{"type":"string"}}}'
);
//
},
'har-schema/lib/header.json':
function(module) {
//
module.exports = JSON.parse(
  '{"$id":"header.json#","$schema":"http://json-schema.org/draft-06/schema#","type":"object","required":["name","value"],"properties":{"name":{"type":"string"},"value":{"type":"string"},"comment":{"type":"string"}}}'
);
//
},
'har-schema/lib/postData.json':
function(module) {
//
module.exports = JSON.parse(
  '{"$id":"postData.json#","$schema":"http://json-schema.org/draft-06/schema#","type":"object","optional":true,"required":["mimeType"],"properties":{"mimeType":{"type":"string"},"text":{"type":"string"},"params":{"type":"array","required":["name"],"properties":{"name":{"type":"string"},"value":{"type":"string"},"fileName":{"type":"string"},"contentType":{"type":"string"},"comment":{"type":"string"}}},"comment":{"type":"string"}}}'
);
//
},
'har-schema/lib/query.json':
function(module) {
//
module.exports = JSON.parse(
  '{"$id":"query.json#","$schema":"http://json-schema.org/draft-06/schema#","type":"object","required":["name","value"],"properties":{"name":{"type":"string"},"value":{"type":"string"},"comment":{"type":"string"}}}'
);
//
},
'har-schema/lib/request.json':
function(module) {
//
module.exports = JSON.parse(
  '{"$id":"request.json#","$schema":"http://json-schema.org/draft-06/schema#","type":"object","required":["method","url","httpVersion","cookies","headers","queryString","headersSize","bodySize"],"properties":{"method":{"type":"string"},"url":{"type":"string","format":"uri"},"httpVersion":{"type":"string"},"cookies":{"type":"array","items":{"$ref":"cookie.json#"}},"headers":{"type":"array","items":{"$ref":"header.json#"}},"queryString":{"type":"array","items":{"$ref":"query.json#"}},"postData":{"$ref":"postData.json#"},"headersSize":{"type":"integer"},"bodySize":{"type":"integer"},"comment":{"type":"string"}}}'
);
//
},
'request/lib/auth':
function(module, exports, __wpreq__) {
//
var caseless = __wpreq__('caseless'),
  uuid = __wpreq__('uuid/v4'),
  helpers = __wpreq__('request/lib/helpers'),

  md5 = helpers.md5,
  toBase64 = helpers.toBase64

function Auth(request) {
  this.request = request
  this.hasAuth = false
  this.sentAuth = false
  this.bearerToken = null
  this.user = null
  this.pass = null
}

Auth.prototype.basic = function(user, pass, sendImmediately) {
  var self = this
  if (typeof user != 'string' || (pass !== void 0 && typeof pass != 'string'))
    self.request.emit('error', new Error('auth() received invalid user or password'))

  self.user = user
  self.pass = pass
  self.hasAuth = true
  if (sendImmediately || sendImmediately === void 0) {
    var authHeader = 'Basic ' + toBase64(user + ':' + (pass || ''))
    self.sentAuth = true
    return authHeader
  }
}

Auth.prototype.bearer = function(bearer, sendImmediately) {
  var self = this
  self.bearerToken = bearer
  self.hasAuth = true
  if (sendImmediately || sendImmediately === void 0) {
    if (typeof bearer == 'function') bearer = bearer()

    var authHeader = 'Bearer ' + (bearer || '')
    self.sentAuth = true
    return authHeader
  }
}

Auth.prototype.digest = function(method, path, authHeader) {
  var self = this,

    challenge = {},
    re = /([a-z0-9_-]+)=(?:"([^"]+)"|([a-z0-9_-]+))/gi
  for (;;) {
    var match = re.exec(authHeader)
    if (!match) break

    challenge[match[1]] = match[2] || match[3]
  }

  var ha1Compute = function(algorithm, user, realm, pass, nonce, cnonce) {
    var ha1 = md5(user + ':' + realm + ':' + pass)
    return algorithm && algorithm.toLowerCase() === 'md5-sess' ? md5(ha1 + ':' + nonce + ':' + cnonce) : ha1
  }

  var qop = /(^|,)\s*auth\s*($|,)/.test(challenge.qop) && 'auth',
    nc = qop && '00000001',
    cnonce = qop && uuid().replace(/-/g, ''),
    ha1 = ha1Compute(challenge.algorithm, self.user, challenge.realm, self.pass, challenge.nonce, cnonce),
    ha2 = md5(method + ':' + path)
  var digestResponse = qop
    ? md5(ha1 + ':' + challenge.nonce + ':' + nc + ':' + cnonce + ':' + qop + ':' + ha2)
    : md5(ha1 + ':' + challenge.nonce + ':' + ha2)
  var authValues = {
    username: self.user,
    realm: challenge.realm,
    nonce: challenge.nonce,
    uri: path,
    qop: qop,
    response: digestResponse,
    nc: nc,
    cnonce: cnonce,
    algorithm: challenge.algorithm,
    opaque: challenge.opaque
  }

  authHeader = []
  for (var k in authValues)
    if (authValues[k])
      k === 'qop' || k === 'nc' || k === 'algorithm'
        ? authHeader.push(k + '=' + authValues[k])
        : authHeader.push(k + '="' + authValues[k] + '"')

  authHeader = 'Digest ' + authHeader.join(', ')
  self.sentAuth = true
  return authHeader
}

Auth.prototype.onRequest = function(user, pass, sendImmediately, bearer) {
  var authHeader,
    self = this,
    request = self.request

  bearer === void 0 && user === void 0
    ? self.request.emit('error', new Error('no auth mechanism defined'))
    : (authHeader = bearer !== void 0 ? self.bearer(bearer, sendImmediately) : self.basic(user, pass, sendImmediately))

  authHeader && request.setHeader('authorization', authHeader)
}

Auth.prototype.onResponse = function(response) {
  var self = this,
    request = self.request

  if (!self.hasAuth || self.sentAuth) return null

  var authHeader = caseless(response.headers).get('www-authenticate'),
    authVerb = authHeader && authHeader.split(' ')[0].toLowerCase()
  request.debug('reauth', authVerb)

  switch (authVerb) {
    case 'basic':
      return self.basic(self.user, self.pass, true)

    case 'bearer':
      return self.bearer(self.bearerToken, true)

    case 'digest':
      return self.digest(request.method, request.path, authHeader)
  }
}

exports.Auth = Auth
//
},
'request/lib/oauth':
function(module, exports, __wpreq__) {
//
var url = __wpreq__('url'),
  qs = __wpreq__('qs'),
  caseless = __wpreq__('caseless'),
  uuid = __wpreq__('uuid/v4'),
  oauth = __wpreq__('oauth-sign'),
  crypto = __wpreq__('crypto'),
  Buffer = __wpreq__('safe-buffer').Buffer

function OAuth(request) {
  this.request = request
  this.params = null
}

OAuth.prototype.buildParams = function(_oauth, uri, method, query, form, qsLib) {
  var oa = {}
  for (var i in _oauth) oa['oauth_' + i] = _oauth[i]

  oa.oauth_version || (oa.oauth_version = '1.0')
  oa.oauth_timestamp || (oa.oauth_timestamp = Math.floor(Date.now() / 1000).toString())
  oa.oauth_nonce || (oa.oauth_nonce = uuid().replace(/-/g, ''))
  oa.oauth_signature_method || (oa.oauth_signature_method = 'HMAC-SHA1')

  var consumer_secret_or_private_key = oa.oauth_consumer_secret || oa.oauth_private_key
  delete oa.oauth_consumer_secret
  delete oa.oauth_private_key

  var token_secret = oa.oauth_token_secret
  delete oa.oauth_token_secret

  var realm = oa.oauth_realm
  delete oa.oauth_realm
  delete oa.oauth_transport_method

  var baseurl = uri.protocol + '//' + uri.host + uri.pathname,
    params = qsLib.parse([].concat(query, form, qsLib.stringify(oa)).join('&'))

  oa.oauth_signature = oauth.sign(
    oa.oauth_signature_method,
    method,
    baseurl,
    params,
    consumer_secret_or_private_key,
    token_secret
  )

  if (realm) oa.realm = realm

  return oa
}

OAuth.prototype.buildBodyHash = function(_oauth, body) {
  ;['HMAC-SHA1', 'RSA-SHA1'].indexOf(_oauth.signature_method || 'HMAC-SHA1') < 0 &&
    this.request.emit('error',
      new Error('oauth: ' + _oauth.signature_method + ' signature_method not supported with body_hash signing.')
    )

  var shasum = crypto.createHash('sha1')
  shasum.update(body || '')
  var sha1 = shasum.digest('hex')

  return Buffer.from(sha1, 'hex').toString('base64')
}

OAuth.prototype.concatParams = function(oa, sep, wrap) {
  wrap = wrap || ''

  var params = Object.keys(oa).filter(function(i) {
    return i !== 'realm' && i !== 'oauth_signature'
  }).sort()

  oa.realm && params.splice(0, 0, 'realm')
  params.push('oauth_signature')

  return params.map(function(i) {
    return i + '=' + wrap + oauth.rfc3986(oa[i]) + wrap
  }).join(sep)
}

OAuth.prototype.onRequest = function(_oauth) {
  var self = this
  self.params = _oauth

  var form,
    query,
    uri = self.request.uri || {},
    method = self.request.method || '',
    headers = caseless(self.request.headers),
    body = self.request.body || '',
    qsLib = self.request.qsLib || qs,

    contentType = headers.get('content-type') || '',
    formContentType = 'application/x-www-form-urlencoded',
    /** @type {string} */
    transport = _oauth.transport_method || 'header'

  if (contentType.slice(0, formContentType.length) === formContentType) {
    contentType = formContentType
    form = body
  }
  if (uri.query) query = uri.query

  transport !== 'body' || (method === 'POST' && contentType === formContentType) ||
    self.request.emit('error',
      new Error('oauth: transport_method of body requires POST and content-type ' + formContentType)
    )

  form || typeof _oauth.body_hash != 'boolean' ||
    (_oauth.body_hash = self.buildBodyHash(_oauth, self.request.body.toString()))

  var oa = self.buildParams(_oauth, uri, method, query, form, qsLib)

  switch (transport) {
    case 'header':
      self.request.setHeader('Authorization', 'OAuth ' + self.concatParams(oa, ',', '"'))
      break

    case 'query':
      var href = (self.request.uri.href += (query ? '&' : '?') + self.concatParams(oa, '&'))
      self.request.uri = url.parse(href)
      self.request.path = self.request.uri.path
      break

    case 'body':
      self.request.body = (form ? form + '&' : '') + self.concatParams(oa, '&')
      break

    default:
      self.request.emit('error', new Error('oauth: transport_method invalid'))
  }
}

exports.OAuth = OAuth
//
},
'oauth-sign':
function(module, exports, __wpreq__) {
//
var crypto = __wpreq__('crypto');

function sha1(key, body) {
  return crypto.createHmac('sha1', key).update(body).digest('base64')
}

function rsa(key, body) {
  return crypto.createSign("RSA-SHA1").update(body).sign(key, 'base64');
}

function rfc3986(str) {
  return encodeURIComponent(str)
    .replace(/!/g, '%21')
    .replace(/\*/g, '%2A')
    .replace(/\(/g, '%28')
    .replace(/\)/g, '%29')
    .replace(/'/g, '%27');
}

function map(obj) {
  var arr = []
  for (var key in obj) {
    var val = obj[key]
    if (Array.isArray(val)) for (var i = 0; i < val.length; i++) arr.push([key, val[i]])
    else if (typeof val == "object") for (var prop in val) arr.push([key + '[' + prop + ']', val[prop]]);
    else arr.push([key, val])
  }
  return arr
}

function compare(a, b) {
  return a > b ? 1 : a < b ? -1 : 0
}

function generateBase(httpMethod, base_uri, params) {
  var normalized = map(params)
    .map(function(p) {
      return [rfc3986(p[0]), rfc3986(p[1] || '')]
    })
    .sort(function(a, b) {
      return compare(a[0], b[0]) || compare(a[1], b[1])
    })
    .map(function(p) { return p.join('=') })
    .join('&')

  return [rfc3986(httpMethod ? httpMethod.toUpperCase() : 'GET'), rfc3986(base_uri), rfc3986(normalized)].join('&')
}

function hmacsign(httpMethod, base_uri, params, consumer_secret, token_secret) {
  var base = generateBase(httpMethod, base_uri, params)

  return sha1([consumer_secret || '', token_secret || ''].map(rfc3986).join('&'), base)
}

function rsasign(httpMethod, base_uri, params, private_key, token_secret) {
  return rsa(private_key || '', generateBase(httpMethod, base_uri, params))
}

function plaintext(consumer_secret, token_secret) {
  return [consumer_secret || '', token_secret || ''].map(rfc3986).join('&')
}

function sign(signMethod, httpMethod, base_uri, params, consumer_secret, token_secret) {
  var method,
    skipArgs = 1

  switch (signMethod) {
    case 'RSA-SHA1':
      method = rsasign
      break
    case 'HMAC-SHA1':
      method = hmacsign
      break
    case 'PLAINTEXT':
      method = plaintext
      skipArgs = 4
      break
    default:
      throw new Error("Signature method not supported: " + signMethod)
  }

  return method.apply(null, [].slice.call(arguments, skipArgs))
}

exports.hmacsign = hmacsign
exports.rsasign = rsasign
exports.plaintext = plaintext
exports.sign = sign
exports.rfc3986 = rfc3986
exports.generateBase = generateBase
//
},
'request/lib/hawk':
function(module, exports, __wpreq__) {
//
var crypto = __wpreq__('crypto')

function randomString(size) {
  var bits = (size + 1) * 6
  return crypto.randomBytes(Math.ceil(bits / 8))
    .toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '')
    .slice(0, size)
}

function calculatePayloadHash(payload, algorithm, contentType) {
  var hash = crypto.createHash(algorithm)
  hash.update('hawk.1.payload\n')
  hash.update((contentType ? contentType.split(';')[0].trim().toLowerCase() : '') + '\n')
  hash.update(payload || '')
  hash.update('\n')
  return hash.digest('base64')
}

exports.calculateMac = function(credentials, opts) {
  var normalized = 'hawk.1.header\n' +
    opts.ts + '\n' +
    opts.nonce + '\n' +
    (opts.method || '').toUpperCase() + '\n' +
    opts.resource + '\n' +
    opts.host.toLowerCase() + '\n' +
    opts.port + '\n' +
    (opts.hash || '') + '\n'

  if (opts.ext) normalized += opts.ext.replace('\\', '\\\\').replace('\n', '\\n')

  normalized += '\n'

  if (opts.app) normalized = normalized + opts.app + '\n' + (opts.dlg || '') + '\n'

  return crypto.createHmac(credentials.algorithm, credentials.key).update(normalized).digest('base64')
}

exports.header = function(uri, method, opts) {
  var timestamp = opts.timestamp || Math.floor((Date.now() + (opts.localtimeOffsetMsec || 0)) / 1000),
    credentials = opts.credentials
  if (!(credentials && credentials.id && credentials.key && credentials.algorithm)) return ''

  if (['sha1', 'sha256'].indexOf(credentials.algorithm) < 0) return ''

  var artifacts = {
    ts: timestamp,
    nonce: opts.nonce || randomString(6),
    method: method,
    resource: uri.pathname + (uri.search || ''),
    host: uri.hostname,
    port: uri.port || (uri.protocol === 'http:' ? 80 : 443),
    hash: opts.hash,
    ext: opts.ext,
    app: opts.app,
    dlg: opts.dlg
  }

  artifacts.hash || (!opts.payload && opts.payload !== '') ||
    (artifacts.hash = calculatePayloadHash(opts.payload, credentials.algorithm, opts.contentType))

  var mac = exports.calculateMac(credentials, artifacts),

    hasExt = artifacts.ext !== null && artifacts.ext !== void 0 && artifacts.ext !== ''
  // noinspection JSObjectNullOrUndefined
  var header = 'Hawk id="' + credentials.id +
    '", ts="' + artifacts.ts +
    '", nonce="' + artifacts.nonce +
    (artifacts.hash ? '", hash="' + artifacts.hash : '') +
    (hasExt ? '", ext="' + artifacts.ext.replace(/\\/g, '\\\\').replace(/"/g, '\\"') : '') +
    '", mac="' + mac + '"'

  if (artifacts.app)
    header = header + ', app="' + artifacts.app + (artifacts.dlg ? '", dlg="' + artifacts.dlg : '') + '"'

  return header
}
//
},
'request/lib/multipart':
function(module, exports, __wpreq__) {
//
var uuid = __wpreq__('uuid/v4'),
  CombinedStream = __wpreq__('combined-stream'),
  isstream = __wpreq__('isstream'),
  Buffer = __wpreq__('safe-buffer').Buffer

function Multipart(request) {
  this.request = request
  this.boundary = uuid()
  this.chunked = false
  this.body = null
}

Multipart.prototype.isChunked = function(options) {
  var self = this,
    chunked = false,
    parts = options.data || options

  parts.forEach || self.request.emit('error', new Error('Argument error, options.multipart.'))

  if (options.chunked !== void 0) chunked = options.chunked

  if (self.request.getHeader('transfer-encoding') === 'chunked') chunked = true

  chunked ||
    parts.forEach(function(part) {
      part.body !== void 0 || self.request.emit('error', new Error('Body attribute missing in multipart.'))

      if (isstream(part.body)) chunked = true
    })

  return chunked
}

Multipart.prototype.setHeaders = function(chunked) {
  var self = this

  !chunked || self.request.hasHeader('transfer-encoding') || self.request.setHeader('transfer-encoding', 'chunked')

  var header = self.request.getHeader('content-type')

  !header || header.indexOf('multipart') < 0
    ? self.request.setHeader('content-type', 'multipart/related; boundary=' + self.boundary)
    : header.indexOf('boundary') > -1
    ? (self.boundary = header.replace(/.*boundary=([^\s;]+).*/, '$1'))
    : self.request.setHeader('content-type', header + '; boundary=' + self.boundary)
}

Multipart.prototype.build = function(parts, chunked) {
  var self = this,
    body = chunked ? new CombinedStream() : []

  function add(part) {
    if (typeof part == 'number') part = part.toString()

    return chunked ? body.append(part) : body.push(Buffer.from(part))
  }

  self.request.preambleCRLF && add('\r\n')

  parts.forEach(function(part) {
    var preamble = '--' + self.boundary + '\r\n'
    Object.keys(part).forEach(function(key) {
      if (key !== 'body') preamble += key + ': ' + part[key] + '\r\n'
    })
    add((preamble += '\r\n'))
    add(part.body)
    add('\r\n')
  })
  add('--' + self.boundary + '--')

  self.request.postambleCRLF && add('\r\n')

  return body
}

Multipart.prototype.onRequest = function(options) {
  var self = this,

    chunked = self.isChunked(options),
    parts = options.data || options

  self.setHeaders(chunked)
  self.chunked = chunked
  self.body = self.build(parts, chunked)
}

exports.Multipart = Multipart
//
},
'request/lib/redirect':
function(module, exports, __wpreq__) {
//
var url = __wpreq__('url'),
  isUrl = /^https?:/

function Redirect(request) {
  this.request = request
  this.followRedirect = true
  this.followRedirects = true
  this.followAllRedirects = false
  this.followOriginalHttpMethod = false
  this.allowRedirect = function() { return true }
  this.maxRedirects = 10
  this.redirects = []
  this.redirectsFollowed = 0
  this.removeRefererHeader = false
}

Redirect.prototype.onRequest = function(options) {
  var self = this

  if (options.maxRedirects !== void 0) self.maxRedirects = options.maxRedirects
  if (typeof options.followRedirect == 'function') self.allowRedirect = options.followRedirect
  if (options.followRedirect !== void 0) self.followRedirects = !!options.followRedirect
  if (options.followAllRedirects !== void 0) self.followAllRedirects = options.followAllRedirects
  if (self.followRedirects || self.followAllRedirects) self.redirects = self.redirects || []
  if (options.removeRefererHeader !== void 0) self.removeRefererHeader = options.removeRefererHeader
  if (options.followOriginalHttpMethod !== void 0) self.followOriginalHttpMethod = options.followOriginalHttpMethod
}

Redirect.prototype.redirectTo = function(response) {
  var self = this,
    request = self.request,

    redirectTo = null
  if (response.statusCode >= 300 && response.statusCode < 400 && response.caseless.has('location')) {
    var location = response.caseless.get('location')
    request.debug('redirect', location)

    if (self.followAllRedirects) redirectTo = location
    else if (self.followRedirects)
      switch (request.method) {
        case 'PATCH':
        case 'PUT':
        case 'POST':
        case 'DELETE':
          break
        default:
          redirectTo = location
          break
      }
  } else if (response.statusCode === 401) {
    var authHeader = request._auth.onResponse(response)
    if (authHeader) {
      request.setHeader('authorization', authHeader)
      redirectTo = request.uri
    }
  }
  return redirectTo
}

Redirect.prototype.onResponse = function(response) {
  var self = this,
    request = self.request,

    redirectTo = self.redirectTo(response)
  if (!redirectTo || !self.allowRedirect.call(request, response)) return false

  request.debug('redirect to', redirectTo)

  response.resume && response.resume()

  if (self.redirectsFollowed >= self.maxRedirects) {
    request.emit('error', new Error('Exceeded maxRedirects. Probably stuck in a redirect loop ' + request.uri.href))
    return false
  }
  self.redirectsFollowed += 1

  isUrl.test(redirectTo) || (redirectTo = url.resolve(request.uri.href, redirectTo))

  var uriPrev = request.uri
  request.uri = url.parse(redirectTo)

  request.uri.protocol === uriPrev.protocol || delete request.agent

  self.redirects.push({statusCode: response.statusCode, redirectUri: redirectTo})

  if (self.followAllRedirects && request.method !== 'HEAD' && response.statusCode !== 401 && response.statusCode !== 307)
    request.method = self.followOriginalHttpMethod ? request.method : 'GET'

  delete request.src
  delete request.req
  delete request._started
  if (response.statusCode !== 401 && response.statusCode !== 307) {
    delete request.body
    delete request._form
    if (request.headers) {
      request.removeHeader('host')
      request.removeHeader('content-type')
      request.removeHeader('content-length')
      request.uri.hostname === request.originalHost.split(':')[0] || request.removeHeader('authorization')
    }
  }

  self.removeRefererHeader || request.setHeader('referer', uriPrev.href)

  request.emit('redirect')

  request.init()

  return true
}

exports.Redirect = Redirect
//
},
'request/lib/tunnel':
function(module, exports, __wpreq__) {
//
var url = __wpreq__('url'),
  tunnel = __wpreq__('tunnel-agent')

var defaultProxyHeaderWhiteList = [
  'accept',
  'accept-charset',
  'accept-encoding',
  'accept-language',
  'accept-ranges',
  'cache-control',
  'content-encoding',
  'content-language',
  'content-location',
  'content-md5',
  'content-range',
  'content-type',
  'connection',
  'date',
  'expect',
  'max-forwards',
  'pragma',
  'referer',
  'te',
  'user-agent',
  'via'
]

var defaultProxyHeaderExclusiveList = ['proxy-authorization']

function constructProxyHost(uriObject) {
  var port = uriObject.port,
    protocol = uriObject.protocol

  return uriObject.hostname + ':' + (port || (protocol === 'https:' ? '443' : '80'))
}

function constructProxyHeaderWhiteList(headers, proxyHeaderWhiteList) {
  var whiteList = proxyHeaderWhiteList.reduce(function(set, header) {
    set[header.toLowerCase()] = true
    return set
  }, {})

  return Object.keys(headers)
    .filter(function(header) {
      return whiteList[header.toLowerCase()]
    })
    .reduce(function(set, header) {
      set[header] = headers[header]
      return set
    }, {})
}

function constructTunnelOptions(request, proxyHeaders) {
  var proxy = request.proxy

  return {
    proxy: {host: proxy.hostname, port: +proxy.port, proxyAuth: proxy.auth, headers: proxyHeaders},
    headers: request.headers,
    ca: request.ca,
    cert: request.cert,
    key: request.key,
    passphrase: request.passphrase,
    pfx: request.pfx,
    ciphers: request.ciphers,
    rejectUnauthorized: request.rejectUnauthorized,
    secureOptions: request.secureOptions,
    secureProtocol: request.secureProtocol
  }
}

function constructTunnelFnName(uri, proxy) {
  return [uri.protocol === 'https:' ? 'https' : 'http', proxy.protocol === 'https:' ? 'Https' : 'Http'].join('Over')
}

function getTunnelFn(request) {
  var tunnelFnName = constructTunnelFnName(request.uri, request.proxy)
  return tunnel[tunnelFnName]
}

function Tunnel(request) {
  this.request = request
  this.proxyHeaderWhiteList = defaultProxyHeaderWhiteList
  this.proxyHeaderExclusiveList = []
  if (request.tunnel !== void 0) this.tunnelOverride = request.tunnel
}

Tunnel.prototype.isEnabled = function() {
  var self = this,
    request = self.request

  return self.tunnelOverride !== void 0 ? self.tunnelOverride : request.uri.protocol === 'https:'
}

Tunnel.prototype.setup = function(options) {
  var self = this,
    request = self.request

  options = options || {}

  if (typeof request.proxy == 'string') request.proxy = url.parse(request.proxy)

  if (!request.proxy || !request.tunnel) return false

  if (options.proxyHeaderWhiteList) self.proxyHeaderWhiteList = options.proxyHeaderWhiteList
  if (options.proxyHeaderExclusiveList) self.proxyHeaderExclusiveList = options.proxyHeaderExclusiveList

  var proxyHeaderExclusiveList = self.proxyHeaderExclusiveList.concat(defaultProxyHeaderExclusiveList),
    proxyHeaderWhiteList = self.proxyHeaderWhiteList.concat(proxyHeaderExclusiveList),

    proxyHeaders = constructProxyHeaderWhiteList(request.headers, proxyHeaderWhiteList)
  proxyHeaders.host = constructProxyHost(request.uri)

  proxyHeaderExclusiveList.forEach(request.removeHeader, request)

  var tunnelFn = getTunnelFn(request),
    tunnelOptions = constructTunnelOptions(request, proxyHeaders)
  request.agent = tunnelFn(tunnelOptions)

  return true
}

Tunnel.defaultProxyHeaderWhiteList = defaultProxyHeaderWhiteList
Tunnel.defaultProxyHeaderExclusiveList = defaultProxyHeaderExclusiveList
exports.Tunnel = Tunnel
//
},
'tunnel-agent':
function(module, exports, __wpreq__) {
//
var tls = __wpreq__('tls'),
  http = __wpreq__('http'),
  https = __wpreq__('https'),
  events = __wpreq__('events'),
  assert = __wpreq__('assert'),
  util = __wpreq__('util'),
  Buffer = __wpreq__('safe-buffer').Buffer;

exports.httpOverHttp = httpOverHttp
exports.httpsOverHttp = httpsOverHttp
exports.httpOverHttps = httpOverHttps
exports.httpsOverHttps = httpsOverHttps

function httpOverHttp(options) {
  var agent = new TunnelingAgent(options)
  agent.request = http.request
  return agent
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options)
  agent.request = http.request
  agent.createSocket = createSecureSocket
  agent.defaultPort = 443
  return agent
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options)
  agent.request = https.request
  return agent
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options)
  agent.request = https.request
  agent.createSocket = createSecureSocket
  agent.defaultPort = 443
  return agent
}

function TunnelingAgent(options) {
  var self = this
  self.options = options || {}
  self.proxyOptions = self.options.proxy || {}
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets
  self.requests = []
  self.sockets = []

  self.on('free', function(socket, host, port) {
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i]
      if (pending.host === host && pending.port === port) {
        self.requests.splice(i, 1)
        pending.request.onSocket(socket)
        return
      }
    }
    socket.destroy()
    self.removeSocket(socket)
  })
}
util.inherits(TunnelingAgent, events.EventEmitter)

TunnelingAgent.prototype.addRequest = function(req, options) {
  var self = this

  if (typeof options == 'string') options = {host: options, port: arguments[2], path: arguments[3]};

  self.sockets.length >= this.maxSockets
    ? self.requests.push({host: options.host, port: options.port, request: req})
    : self.createConnection({host: options.host, port: options.port, request: req})
}

TunnelingAgent.prototype.createConnection = function(pending) {
  var self = this

  self.createSocket(pending, function(socket) {
    socket.on('free', onFree)
    socket.on('close', onCloseOrRemove)
    socket.on('agentRemove', onCloseOrRemove)
    pending.request.onSocket(socket)

    function onFree() {
      self.emit('free', socket, pending.host, pending.port)
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket)
      socket.removeListener('free', onFree)
      socket.removeListener('close', onCloseOrRemove)
      socket.removeListener('agentRemove', onCloseOrRemove)
    }
  })
}

TunnelingAgent.prototype.createSocket = function(options, cb) {
  var self = this,
    placeholder = {}
  self.sockets.push(placeholder)

  var connectOptions = mergeOptions({}, self.proxyOptions, {
    method: 'CONNECT',
    path: options.host + ':' + options.port,
    agent: false
  })
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {}
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' + Buffer.from(connectOptions.proxyAuth).toString('base64')
  }

  debug('making CONNECT request')
  var connectReq = self.request(connectOptions)
  connectReq.useChunkedEncodingByDefault = false
  connectReq.once('response', onResponse)
  connectReq.once('upgrade', onUpgrade)
  connectReq.once('connect', onConnect)
  connectReq.once('error', onError)
  connectReq.end()

  function onResponse(res) {
    res.upgrade = true
  }

  function onUpgrade(res, socket, head) {
    process.nextTick(function() {
      onConnect(res, socket, head)
    })
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners()
    socket.removeAllListeners()

    if (res.statusCode === 200) {
      assert.equal(head.length, 0)
      debug('tunneling connection has established')
      self.sockets[self.sockets.indexOf(placeholder)] = socket
      cb(socket)
    } else {
      debug('tunneling socket could not be established, statusCode=%d', res.statusCode)
      var error = new Error('tunneling socket could not be established, statusCode=' + res.statusCode)
      error.code = 'ECONNRESET'
      options.request.emit('error', error)
      self.removeSocket(placeholder)
    }
  }

  function onError(cause) {
    connectReq.removeAllListeners()

    debug('tunneling socket could not be established, cause=%s\n', cause.message, cause.stack)
    var error = new Error('tunneling socket could not be established, cause=' + cause.message)
    error.code = 'ECONNRESET'
    options.request.emit('error', error)
    self.removeSocket(placeholder)
  }
}

TunnelingAgent.prototype.removeSocket = function(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos < 0) return

  this.sockets.splice(pos, 1)

  var pending = this.requests.shift()
  pending && this.createConnection(pending)
}

function createSecureSocket(options, cb) {
  var self = this
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    var secureSocket = tls.connect(0, mergeOptions({}, self.options, {servername: options.host, socket: socket}))
    self.sockets[self.sockets.indexOf(socket)] = secureSocket
    cb(secureSocket)
  })
}

function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i]
    if (typeof overrides == 'object')
      for (var keys = Object.keys(overrides), j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j]
        if (overrides[k] !== void 0) target[k] = overrides[k]
      }
  }
  return target
}

// noinspection UnnecessaryLocalVariableJS
var debug =
  process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)
  ? function() {
      var args = Array.prototype.slice.call(arguments)
      typeof args[0] == 'string' ? (args[0] = 'TUNNEL: ' + args[0]) : args.unshift('TUNNEL:')

      console.error.apply(console, args)
    }
  : function() {}

exports.debug = debug
//
},
'performance-now':
function(module) {
//
var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

if (typeof performance != "undefined" && performance !== null && performance.now)
  module.exports = function() {
    return performance.now();
  };
else if (typeof process != "undefined" && process !== null && process.hrtime) {
  module.exports = function() {
    return (getNanoSeconds() - nodeLoadTime) / 1e6;
  };
  hrtime = process.hrtime;
  moduleLoadTime = (getNanoSeconds = function() {
    var hr = hrtime();
    return hr[0] * 1e9 + hr[1];
  })();
  upTime = process.uptime() * 1e9;
  nodeLoadTime = moduleLoadTime - upTime;
} else if (Date.now) {
  module.exports = function() {
    return Date.now() - loadTime;
  };
  loadTime = Date.now();
} else {
  module.exports = function() {
    return new Date().getTime() - loadTime;
  };
  loadTime = new Date().getTime();
}
//
}
});
