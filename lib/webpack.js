"use strict";

module.exports = (function(modules) {
	var installedModules = {};

	function __webpack_require__(moduleId) {
		var module = installedModules[moduleId];
		if (module) return module.exports;

		installedModules[moduleId] = module = { i: moduleId, l: false, exports: {} };
		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

		module.l = true;
		return module.exports;
	}

	__webpack_require__.m = modules;
	__webpack_require__.c = installedModules;
	return __webpack_require__(151);
})([
// 0
function(module) {

module.exports = require("./webpack-sources");

},
// 1
function(module, exports, __webpack_require__) {

const inspect = __webpack_require__(11).inspect.custom;

class WebpackError extends Error {
	constructor(message) {
		super(message);

		this.details = void 0;
		this.missing = void 0;
		this.origin = void 0;
		this.dependencies = void 0;
		this.module = void 0;

		Error.captureStackTrace(this, this.constructor);
	}

	[inspect]() {
		return this.stack + (this.details ? "\n" + this.details : "");
	}
}

module.exports = WebpackError;

},
// 2
function(module, exports, __webpack_require__) {

const { ConcatSource } = __webpack_require__(0),
	HotUpdateChunk = __webpack_require__(75),

	START_LOWERCASE_ALPHABET_CODE = "a".charCodeAt(0),
	START_UPPERCASE_ALPHABET_CODE = "A".charCodeAt(0),
	DELTA_A_TO_Z = "z".charCodeAt(0) - START_LOWERCASE_ALPHABET_CODE + 1,
	FUNCTION_CONTENT_REGEX = /^function\s?\(\)\s?\{\r?\n?|\r?\n?\}$/g,
	INDENT_MULTILINE_REGEX = /^\t/gm,
	LINE_SEPARATOR_REGEX = /\r?\n/g,
	IDENTIFIER_NAME_REPLACE_REGEX = /^([^a-zA-Z$_])/,
	IDENTIFIER_ALPHA_NUMERIC_NAME_REPLACE_REGEX = /[^a-zA-Z0-9$]+/g,
	COMMENT_END_REGEX = /\*\//g,
	PATH_NAME_NORMALIZE_REPLACE_REGEX = /[^a-zA-Z0-9_!§$()=\-^°]+/g,
	MATCH_PADDED_HYPHENS_REPLACE_REGEX = /^-|-$/g;

const stringifyIdSortPredicate = (a, b) => {
	const aId = a.id + "",
		bId = b.id + "";
	return aId < bId ? -1 : aId > bId ? 1 : 0;
};

class Template {
	static getFunctionContent(fn) {
		return fn
			.toString()
			.replace(FUNCTION_CONTENT_REGEX, "")
			.replace(INDENT_MULTILINE_REGEX, "")
			.replace(LINE_SEPARATOR_REGEX, "\n");
	}

	static toIdentifier(str) {
		return typeof str != "string" ? "" : str
			.replace(IDENTIFIER_NAME_REPLACE_REGEX, "_$1")
			.replace(IDENTIFIER_ALPHA_NUMERIC_NAME_REPLACE_REGEX, "_");
	}
	static toComment(str) {
		return str ? `/*! ${str.replace(COMMENT_END_REGEX, "* /")} */` : "";
	}

	static toNormalComment(str) {
		return str ? `/* ${str.replace(COMMENT_END_REGEX, "* /")} */` : "";
	}

	static toPath(str) {
		return typeof str != "string" ? "" : str
			.replace(PATH_NAME_NORMALIZE_REPLACE_REGEX, "-")
			.replace(MATCH_PADDED_HYPHENS_REPLACE_REGEX, "");
	}

	static numberToIdentifer(n) {
		return n < DELTA_A_TO_Z
			? String.fromCharCode(START_LOWERCASE_ALPHABET_CODE + n)

			: n < DELTA_A_TO_Z * 2
			? String.fromCharCode(START_UPPERCASE_ALPHABET_CODE + n - DELTA_A_TO_Z)

			: Template.numberToIdentifer(n % (2 * DELTA_A_TO_Z)) +
				Template.numberToIdentifer(Math.floor(n / (2 * DELTA_A_TO_Z)));
	}

	static indent(s) {
		if (Array.isArray(s)) return s.map(Template.indent).join("\n");

		const str = s.trimRight();
		return str ? (str[0] === "\n" ? "" : "\t") + str.replace(/\n([^\n])/g, "\n\t$1") : "";
	}

	static prefix(s, prefix) {
		const str = Template.asString(s).trim();
		return str ? (str[0] === "\n" ? "" : prefix) + str.replace(/\n([^\n])/g, "\n" + prefix + "$1") : "";
	}

	static asString(str) {
		return Array.isArray(str) ? str.join("\n") : str;
	}

	static getModulesArrayBounds(modules) {
		let maxId = -Infinity,
			minId = Infinity;
		for (const module of modules) {
			if (typeof module.id != "number") return false;
			if (maxId < module.id) maxId = module.id;
			if (minId > module.id) minId = module.id;
		}
		if (minId < 16 + ("" + minId).length) minId = 0;

		const objectOverhead =
				modules.map(module => (module.id + "").length + 2).reduce((a, b) => a + b, -1),
			arrayOverhead = minId === 0 ? maxId : 16 + ("" + minId).length + maxId;
		return arrayOverhead < objectOverhead ? [minId, maxId] : false;
	}

	static renderChunkModules(chunk, filterFn, moduleTemplate, dependencyTemplates, prefix = "") {
		const source = new ConcatSource(),
			modules = chunk.getModules().filter(filterFn);
		let removedModules;
		if (chunk instanceof HotUpdateChunk) removedModules = chunk.removedModules;

		if (modules.length === 0 && (!removedModules || removedModules.length === 0)) {
			source.add("[]");
			return source;
		}
		const allModules = modules.map(module => ({
			id: module.id,
			index: module.index,
			source: moduleTemplate.render(module, dependencyTemplates, { chunk })
		}));
		if (removedModules && removedModules.length > 0)
			for (const id of removedModules) allModules.push({ id, source: "false" });

		const bounds = Template.getModulesArrayBounds(allModules);
		if (bounds) {
			const minId = bounds[0],
				maxId = bounds[1];
			minId === 0 || source.add(`Array(${minId}).concat(`);

			source.add("[\n");
			const modules = new Map();
			for (const module of allModules) modules.set(module.id, module);

			for (let idx = minId; idx <= maxId; idx++) {
				const module = modules.get(idx);
				idx === minId || source.add(",\n");

				source.add(`/* ${idx} */`);
				if (module) {
					source.add("\n");
					source.add(module.source);
				}
			}
			source.add("\n" + prefix + "]");
			minId === 0 || source.add(")");
		} else {
			source.add("{\n");
			allModules.sort(
				removedModules && removedModules.length ? stringifyIdSortPredicate : (a, b) => a.index - b.index
			).forEach((module, idx) => {
				idx === 0 || source.add(",\n");

				source.add(`\n/***/ ${JSON.stringify(module.id)}:\n`);
				source.add(module.source);
			});
			source.add(`\n\n${prefix}}`);
		}
		return source;
	}
}

module.exports = Template;

},
// 3
function(module) {

module.exports = require("path");

},
// 4
function(module, exports, __webpack_require__) {

const Dependency = __webpack_require__(17);

class ModuleDependency extends Dependency {
	constructor(request) {
		super();
		this.request = request;
		this.userRequest = request;
	}

	getResourceIdentifier() {
		return "module" + this.request;
	}
}

module.exports = ModuleDependency;

},
// 5
function(module, exports, __webpack_require__) {

const NullDependency = __webpack_require__(7);

class ConstDependency extends NullDependency {
	constructor(expression, range, requireWebpackRequire) {
		super();
		this.expression = expression;
		this.range = range;
		this.requireWebpackRequire = requireWebpackRequire;
	}

	updateHash(hash) {
		hash.update(this.range + "");
		hash.update(this.expression + "");
	}
}

ConstDependency.Template = class {
	apply(dep, source) {
		if (typeof dep.range == "number") {
			source.insert(dep.range, dep.expression);
			return;
		}

		source.replace(dep.range[0], dep.range[1] - 1, dep.expression);
	}
};

module.exports = ConstDependency;

},
// 6
function(module) {

module.exports = require("./tapable");

},
// 7
function(module, exports, __webpack_require__) {

const Dependency = __webpack_require__(17);

class NullDependency extends Dependency {
	get type() {
		return "null";
	}

	updateHash() {}
}

NullDependency.Template = class {
	apply() {}
};

module.exports = NullDependency;

},
// 8
function(module) {

module.exports = require("./schema-utils");

},
// 9
function(module, exports, __webpack_require__) {

const path = __webpack_require__(3),

	BasicEvaluatedExpression = __webpack_require__(57),
	ConstDependency = __webpack_require__(5),
	UnsupportedFeatureWarning = __webpack_require__(62),

	ParserHelpers = exports;

ParserHelpers.addParsedVariableToModule = (parser, name, expression) => {
	if (!parser.state.current.addVariable) return false;
	var deps = [];
	parser.parse(expression, {
		current: {
			addDependency: dep => {
				dep.userRequest = name;
				deps.push(dep);
			}
		},
		module: parser.state.module
	});
	parser.state.current.addVariable(name, expression, deps);
	return true;
};

ParserHelpers.requireFileAsExpression = (context, pathToModule) => {
	var moduleJsPath = path.relative(context, pathToModule);
	if (!/^[A-Z]:/i.test(moduleJsPath))
		moduleJsPath = "./" + moduleJsPath.replace(/\\/g, "/");

	return "require(" + JSON.stringify(moduleJsPath) + ")";
};

ParserHelpers.toConstantDependency = (parser, value) => {
	return function(expr) {
		var dep = new ConstDependency(value, expr.range, false);
		dep.loc = expr.loc;
		parser.state.current.addDependency(dep);
		return true;
	};
};

ParserHelpers.toConstantDependencyWithWebpackRequire = (parser, value) => {
	return function(expr) {
		var dep = new ConstDependency(value, expr.range, true);
		dep.loc = expr.loc;
		parser.state.current.addDependency(dep);
		return true;
	};
};

ParserHelpers.evaluateToString = value => {
	return function(expr) {
		return new BasicEvaluatedExpression().setString(value).setRange(expr.range);
	};
};

ParserHelpers.evaluateToBoolean = value => {
	return function(expr) {
		return new BasicEvaluatedExpression()
			.setBoolean(value)
			.setRange(expr.range);
	};
};

ParserHelpers.evaluateToIdentifier = (identifier, truthy) => {
	return function(expr) {
		let evex = new BasicEvaluatedExpression()
			.setIdentifier(identifier)
			.setRange(expr.range);
		if (truthy === true) evex = evex.setTruthy();
		else if (truthy === false) evex = evex.setFalsy();

		return evex;
	};
};

ParserHelpers.expressionIsUnsupported = (parser, message) => {
	return function(expr) {
		var dep = new ConstDependency("(void 0)", expr.range, false);
		dep.loc = expr.loc;
		parser.state.current.addDependency(dep);
		if (!parser.state.module) return;
		parser.state.module.warnings.push(
			new UnsupportedFeatureWarning(parser.state.module, message, expr.loc)
		);
		return true;
	};
};

ParserHelpers.skipTraversal = function() {
	return true;
};

ParserHelpers.approve = function() {
	return true;
};

},
// 10
function(module) {

class NullFactory {
	create(data, callback) {
		return callback();
	}
}
module.exports = NullFactory;

},
// 11
function(module) {

module.exports = require("util");

},
// 12
function(module) {

module.exports = require("../vendor/neo-async");

},
// 13
function(module, exports, __webpack_require__) {

const path = __webpack_require__(3);

const requestToAbsolute = (context, relativePath) => {
	return relativePath.startsWith("./") || relativePath.startsWith("../")
		? path.join(context, relativePath)
		: relativePath;
};

const looksLikeAbsolutePath = maybeAbsolutePath => {
	return !/^\/.*\/$/.test(maybeAbsolutePath) &&
		/^(?:[a-z]:\\|\/)/i.test(maybeAbsolutePath);
};

const normalizePathSeparator = p => p.replace(/\\/g, "/");

const _makePathsRelative = (context, identifier) => {
	return identifier
		.split(/([|! ])/)
		.map(str =>
			looksLikeAbsolutePath(str)
				? normalizePathSeparator(path.relative(context, str))
				: str
		)
		.join("");
};

exports.makePathsRelative = (context, identifier, cache) => {
	if (!cache) return _makePathsRelative(context, identifier);

	const relativePaths = cache.relativePaths || (cache.relativePaths = new Map());

	let cachedResult,
		contextCache = relativePaths.get(context);
	contextCache === void 0
		? relativePaths.set(context, (contextCache = new Map()))
		: (cachedResult = contextCache.get(identifier));

	if (cachedResult !== void 0) return cachedResult;

	const relativePath = _makePathsRelative(context, identifier);
	contextCache.set(identifier, relativePath);
	return relativePath;
};

exports.contextify = (context, request) => {
	return request
		.split("!")
		.map(r => {
			const splitPath = r.split("?", 2);
			if (/^[a-zA-Z]:\\/.test(splitPath[0])) {
				splitPath[0] = path.win32.relative(context, splitPath[0]);
				/^[a-zA-Z]:\\/.test(splitPath[0]) ||
					(splitPath[0] = splitPath[0].replace(/\\/g, "/"));
			}
			if (/^\//.test(splitPath[0]))
				splitPath[0] = path.posix.relative(context, splitPath[0]);

			/^(\.\.\/|\/|[a-zA-Z]:\\)/.test(splitPath[0]) ||
				(splitPath[0] = "./" + splitPath[0]);

			return splitPath.join("?");
		})
		.join("!");
};

const _absolutify = (context, request) => {
	return request
		.split("!")
		.map(r => requestToAbsolute(context, r))
		.join("!");
};

exports.absolutify = _absolutify;

},
// 14
function(module) {

class DependencyReference {
	constructor(module, importedNames, weak = false, order = NaN) {
		this.module = module;
		this.importedNames = importedNames;
		this.weak = !!weak;
		this.order = order;
	}

	static sort(array) {
		const originalOrder = new WeakMap();
		let i = 0;
		for (const ref of array) originalOrder.set(ref, i++);

		return array.sort((a, b) => {
			const aOrder = a.order,
				bOrder = b.order;
			if (isNaN(aOrder)) {
				if (!isNaN(bOrder)) return 1;
			} else {
				if (isNaN(bOrder)) return -1;

				if (aOrder !== bOrder) return aOrder - bOrder;
			}
			return originalOrder.get(a) - originalOrder.get(b);
		});
	}
}

module.exports = DependencyReference;

},
// 15
function(module, exports, __webpack_require__) {

const AbstractMethodError = __webpack_require__(166),

	BULK_SIZE = 1000;

class Hash {
	update(data, inputEncoding) {
		throw new AbstractMethodError();
	}

	digest(encoding) {
		throw new AbstractMethodError();
	}
}

exports.Hash = Hash;

class BulkUpdateDecorator extends Hash {
	constructor(hash) {
		super();
		this.hash = hash;
		this.buffer = "";
	}

	update(data, inputEncoding) {
		if (
			inputEncoding !== void 0 ||
			typeof data != "string" ||
			data.length > BULK_SIZE
		) {
			if (this.buffer.length > 0) {
				this.hash.update(this.buffer);
				this.buffer = "";
			}
			this.hash.update(data, inputEncoding);
		} else {
			this.buffer += data;
			if (this.buffer.length > BULK_SIZE) {
				this.hash.update(this.buffer);
				this.buffer = "";
			}
		}
		return this;
	}

	digest(encoding) {
		if (this.buffer.length > 0) this.hash.update(this.buffer);

		var digestResult = this.hash.digest(encoding);
		return typeof digestResult == "string"
			? digestResult
			: digestResult.toString();
	}
}

class DebugHash extends Hash {
	constructor() {
		super();
		this.string = "";
	}

	update(data, inputEncoding) {
		if (typeof data != "string") data = data.toString("utf-8");
		this.string += data;
		return this;
	}

	digest(encoding) {
		return this.string.replace(/[^a-z0-9]+/gi, m =>
			Buffer.from(m).toString("hex")
		);
	}
}

module.exports = algorithm => {
	return typeof algorithm == "function"
		? new BulkUpdateDecorator(new algorithm())

		: algorithm === "debug"
		? new DebugHash()
		: new BulkUpdateDecorator(__webpack_require__(76).createHash(algorithm));
};

},
// 16
function(module, exports, __webpack_require__) {

const util = __webpack_require__(11),

	DependenciesBlock = __webpack_require__(78),
	ModuleReason = __webpack_require__(175),
	SortableSet = __webpack_require__(20),
	Template = __webpack_require__(2),

	EMPTY_RESOLVE_OPTIONS = {};

let debugId = 1000;

const sortById = (a, b) => a.id - b.id,

	sortByDebugId = (a, b) => a.debugId - b.debugId;

class Module extends DependenciesBlock {
	constructor(type, context = null) {
		super();
		this.type = type;
		this.context = context;

		this.debugId = debugId++;

		this.hash = void 0;
		this.renderedHash = void 0;

		this.resolveOptions = EMPTY_RESOLVE_OPTIONS;
		this.factoryMeta = {};

		this.warnings = [];
		this.errors = [];
		this.buildMeta = void 0;
		this.buildInfo = void 0;

		this.reasons = [];
		this._chunks = new SortableSet(void 0, sortById);

		this.id = null;
		this.index = null;
		this.index2 = null;
		this.depth = null;
		this.issuer = null;
		this.profile = void 0;
		this.prefetched = false;
		this.built = false;

		this.used = null;
		this.usedExports = null;
		this.optimizationBailout = [];

		this._rewriteChunkInReasons = void 0;

		this.useSourceMap = false;

		this._source = null;
	}

	get exportsArgument() {
		return (this.buildInfo && this.buildInfo.exportsArgument) || "exports";
	}

	get moduleArgument() {
		return (this.buildInfo && this.buildInfo.moduleArgument) || "module";
	}

	disconnect() {
		this.hash = void 0;
		this.renderedHash = void 0;

		this.reasons.length = 0;
		this._rewriteChunkInReasons = void 0;
		this._chunks.clear();

		this.id = null;
		this.index = null;
		this.index2 = null;
		this.depth = null;
		this.issuer = null;
		this.profile = void 0;
		this.prefetched = false;
		this.built = false;

		this.used = null;
		this.usedExports = null;
		this.optimizationBailout.length = 0;
		super.disconnect();
	}

	unseal() {
		this.id = null;
		this.index = null;
		this.index2 = null;
		this.depth = null;
		this._chunks.clear();
		super.unseal();
	}

	setChunks(chunks) {
		this._chunks = new SortableSet(chunks, sortById);
	}

	addChunk(chunk) {
		if (this._chunks.has(chunk)) return false;
		this._chunks.add(chunk);
		return true;
	}

	removeChunk(chunk) {
		if (this._chunks.delete(chunk)) {
			chunk.removeModule(this);
			return true;
		}
		return false;
	}

	isInChunk(chunk) {
		return this._chunks.has(chunk);
	}

	isEntryModule() {
		for (const chunk of this._chunks)
			if (chunk.entryModule === this) return true;

		return false;
	}

	get optional() {
		return (
			this.reasons.length > 0 &&
			this.reasons.every(r => r.dependency && r.dependency.optional)
		);
	}

	getChunks() {
		return Array.from(this._chunks);
	}

	getNumberOfChunks() {
		return this._chunks.size;
	}

	get chunksIterable() {
		return this._chunks;
	}

	hasEqualsChunks(otherModule) {
		if (this._chunks.size !== otherModule._chunks.size) return false;
		this._chunks.sortWith(sortByDebugId);
		otherModule._chunks.sortWith(sortByDebugId);
		const a = this._chunks[Symbol.iterator](),
			b = otherModule._chunks[Symbol.iterator]();
		while (1) {
			const aItem = a.next(),
				bItem = b.next();
			if (aItem.done) return true;
			if (aItem.value !== bItem.value) return false;
		}
	}

	addReason(module, dependency, explanation) {
		this.reasons.push(new ModuleReason(module, dependency, explanation));
	}

	removeReason(module, dependency) {
		for (let i = 0; i < this.reasons.length; i++) {
			let r = this.reasons[i];
			if (r.module === module && r.dependency === dependency) {
				this.reasons.splice(i, 1);
				return true;
			}
		}
		return false;
	}

	hasReasonForChunk(chunk) {
		if (this._rewriteChunkInReasons) {
			for (const operation of this._rewriteChunkInReasons)
				this._doRewriteChunkInReasons(operation.oldChunk, operation.newChunks);

			this._rewriteChunkInReasons = void 0;
		}
		for (let i = 0; i < this.reasons.length; i++)
			if (this.reasons[i].hasChunk(chunk)) return true;

		return false;
	}

	hasReasons() {
		return this.reasons.length > 0;
	}

	rewriteChunkInReasons(oldChunk, newChunks) {
		if (this._rewriteChunkInReasons === void 0) this._rewriteChunkInReasons = [];

		this._rewriteChunkInReasons.push({ oldChunk, newChunks });
	}

	_doRewriteChunkInReasons(oldChunk, newChunks) {
		for (let i = 0; i < this.reasons.length; i++)
			this.reasons[i].rewriteChunks(oldChunk, newChunks);
	}

	isUsed(exportName) {
		if (!exportName) return this.used !== false;
		if (this.used === null || this.usedExports === null) return exportName;
		if (!this.used || !this.usedExports) return false;
		if (this.usedExports === true) return exportName;
		let idx = this.usedExports.indexOf(exportName);
		if (idx < 0) return false;

		if (this.isProvided(exportName)) {
			if (this.buildMeta.exportsType === "namespace") return Template.numberToIdentifer(idx);

			if (this.buildMeta.exportsType === "named" && !this.usedExports.includes("default"))
				return Template.numberToIdentifer(idx);
		}
		return exportName;
	}

	isProvided(exportName) {
		return Array.isArray(this.buildMeta.providedExports)
			? this.buildMeta.providedExports.includes(exportName) : null;
	}

	toString() {
		return `Module[${this.id || this.debugId}]`;
	}

	needRebuild(fileTimestamps, contextTimestamps) {
		return true;
	}

	updateHash(hash) {
		hash.update("" + this.id);
		hash.update(JSON.stringify(this.usedExports));
		super.updateHash(hash);
	}

	sortItems(sortChunks) {
		super.sortItems();
		sortChunks && this._chunks.sort();
		this.reasons.sort((a, b) =>
			a.module === b.module ? 0
				: !a.module ? -1
				: !b.module ? 1
				: sortById(a.module, b.module)
		);
		Array.isArray(this.usedExports) && this.usedExports.sort();
	}

	unbuild() {
		this.dependencies.length = 0;
		this.blocks.length = 0;
		this.variables.length = 0;
		this.buildMeta = void 0;
		this.buildInfo = void 0;
		this.disconnect();
	}

	get arguments() {
		throw new Error("Module.arguments was removed, there is no replacement.");
	}

	set arguments(value) {
		throw new Error("Module.arguments was removed, there is no replacement.");
	}
}

Object.defineProperty(Module.prototype, "forEachChunk", {
	configurable: false,
	value: util.deprecate(
		function(fn) {
			this._chunks.forEach(fn);
		},
		"Module.forEachChunk: Use for(const chunk of module.chunksIterable) instead"
	)
});

Object.defineProperty(Module.prototype, "mapChunks", {
	configurable: false,
	value: util.deprecate(
		function(fn) {
			return Array.from(this._chunks, fn);
		},
		"Module.mapChunks: Use Array.from(module.chunksIterable, fn) instead"
	)
});

Object.defineProperty(Module.prototype, "entry", {
	configurable: false,
	get() {
		throw new Error("Module.entry was removed. Use Chunk.entryModule");
	},
	set() {
		throw new Error("Module.entry was removed. Use Chunk.entryModule");
	}
});

Object.defineProperty(Module.prototype, "meta", {
	configurable: false,
	get: util.deprecate(
		function() {
			return this.buildMeta;
		},
		"Module.meta was renamed to Module.buildMeta"
	),
	set: util.deprecate(
		function(value) {
			this.buildMeta = value;
		},
		"Module.meta was renamed to Module.buildMeta"
	)
});

Module.prototype.identifier = null;

Module.prototype.readableIdentifier = null;

Module.prototype.build = null;
Module.prototype.source = null;
Module.prototype.size = null;
Module.prototype.nameForCondition = null;
Module.prototype.chunkCondition = null;
Module.prototype.updateCacheModule = null;

module.exports = Module;

},
// 17
function(module, exports, __webpack_require__) {

const util = __webpack_require__(11),
	compareLocations = __webpack_require__(29),
	DependencyReference = __webpack_require__(14);

class Dependency {
	constructor() {
		this.module = null;
		this.weak = false;
		this.optional = false;
		this.loc = void 0;
	}

	getResourceIdentifier() {
		return null;
	}

	getReference() {
		return this.module ? new DependencyReference(this.module, true, this.weak) : null;
	}

	getExports() {
		return null;
	}

	getWarnings() {
		return null;
	}

	getErrors() {
		return null;
	}

	updateHash(hash) {
		hash.update((this.module && this.module.id) + "");
	}

	disconnect() {
		this.module = null;
	}
}

Dependency.compare = util.deprecate(
	(a, b) => compareLocations(a.loc, b.loc),
	"Dependency.compare is deprecated and will be removed in the next major version"
);

module.exports = Dependency;

},
// 18
function(module, exports, __webpack_require__) {

const createHash = __webpack_require__(15),

	ModuleFilenameHelpers = exports;

ModuleFilenameHelpers.ALL_LOADERS_RESOURCE = "[all-loaders][resource]";
ModuleFilenameHelpers.REGEXP_ALL_LOADERS_RESOURCE = /\[all-?loaders\]\[resource\]/gi;
ModuleFilenameHelpers.LOADERS_RESOURCE = "[loaders][resource]";
ModuleFilenameHelpers.REGEXP_LOADERS_RESOURCE = /\[loaders\]\[resource\]/gi;
ModuleFilenameHelpers.RESOURCE = "[resource]";
ModuleFilenameHelpers.REGEXP_RESOURCE = /\[resource\]/gi;
ModuleFilenameHelpers.ABSOLUTE_RESOURCE_PATH = "[absolute-resource-path]";
ModuleFilenameHelpers.REGEXP_ABSOLUTE_RESOURCE_PATH = /\[abs(olute)?-?resource-?path\]/gi;
ModuleFilenameHelpers.RESOURCE_PATH = "[resource-path]";
ModuleFilenameHelpers.REGEXP_RESOURCE_PATH = /\[resource-?path\]/gi;
ModuleFilenameHelpers.ALL_LOADERS = "[all-loaders]";
ModuleFilenameHelpers.REGEXP_ALL_LOADERS = /\[all-?loaders\]/gi;
ModuleFilenameHelpers.LOADERS = "[loaders]";
ModuleFilenameHelpers.REGEXP_LOADERS = /\[loaders\]/gi;
ModuleFilenameHelpers.QUERY = "[query]";
ModuleFilenameHelpers.REGEXP_QUERY = /\[query\]/gi;
ModuleFilenameHelpers.ID = "[id]";
ModuleFilenameHelpers.REGEXP_ID = /\[id\]/gi;
ModuleFilenameHelpers.HASH = "[hash]";
ModuleFilenameHelpers.REGEXP_HASH = /\[hash\]/gi;
ModuleFilenameHelpers.NAMESPACE = "[namespace]";
ModuleFilenameHelpers.REGEXP_NAMESPACE = /\[namespace\]/gi;

const getAfter = (str, token) => {
	const idx = str.indexOf(token);
	return idx < 0 ? "" : str.substr(idx);
};

const getBefore = (str, token) => {
	const idx = str.lastIndexOf(token);
	return idx < 0 ? "" : str.substr(0, idx);
};

const getHash = str => {
	const hash = createHash("md4");
	hash.update(str);
	return hash.digest("hex").substr(0, 4);
};

const asRegExp = test => {
	if (typeof test == "string")
		test = new RegExp("^" + test.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"));

	return test;
};

ModuleFilenameHelpers.createFilename = (module, options, requestShortener) => {
	const opts = Object.assign(
		{ namespace: "", moduleFilenameTemplate: "" },
		typeof options == "object"
			? options
			: { moduleFilenameTemplate: options }
	);

	let absoluteResourcePath, hash, identifier, moduleId, shortIdentifier;
	if (module === void 0) module = "";
	if (typeof module == "string") {
		shortIdentifier = requestShortener.shorten(module);
		identifier = shortIdentifier;
		moduleId = "";
		absoluteResourcePath = module.split("!").pop();
		hash = getHash(identifier);
	} else {
		shortIdentifier = module.readableIdentifier(requestShortener);
		identifier = requestShortener.shorten(module.identifier());
		moduleId = module.id;
		absoluteResourcePath = module.identifier().split("!").pop();
		hash = getHash(identifier);
	}
	const resource = shortIdentifier.split("!").pop(),
		loaders = getBefore(shortIdentifier, "!"),
		allLoaders = getBefore(identifier, "!"),
		query = getAfter(resource, "?"),
		resourcePath = resource.substr(0, resource.length - query.length);
	if (typeof opts.moduleFilenameTemplate == "function")
		return opts.moduleFilenameTemplate({
			identifier: identifier,
			shortIdentifier: shortIdentifier,
			resource: resource,
			resourcePath: resourcePath,
			absoluteResourcePath: absoluteResourcePath,
			allLoaders: allLoaders,
			query: query,
			moduleId: moduleId,
			hash: hash,
			namespace: opts.namespace
		});

	return opts.moduleFilenameTemplate
		.replace(ModuleFilenameHelpers.REGEXP_ALL_LOADERS_RESOURCE, identifier)
		.replace(ModuleFilenameHelpers.REGEXP_LOADERS_RESOURCE, shortIdentifier)
		.replace(ModuleFilenameHelpers.REGEXP_RESOURCE, resource)
		.replace(ModuleFilenameHelpers.REGEXP_RESOURCE_PATH, resourcePath)
		.replace(
			ModuleFilenameHelpers.REGEXP_ABSOLUTE_RESOURCE_PATH,
			absoluteResourcePath
		)
		.replace(ModuleFilenameHelpers.REGEXP_ALL_LOADERS, allLoaders)
		.replace(ModuleFilenameHelpers.REGEXP_LOADERS, loaders)
		.replace(ModuleFilenameHelpers.REGEXP_QUERY, query)
		.replace(ModuleFilenameHelpers.REGEXP_ID, moduleId)
		.replace(ModuleFilenameHelpers.REGEXP_HASH, hash)
		.replace(ModuleFilenameHelpers.REGEXP_NAMESPACE, opts.namespace);
};

ModuleFilenameHelpers.replaceDuplicates = (array, fn, comparator) => {
	const countMap = Object.create(null),
		posMap = Object.create(null);
	array.forEach((item, idx) => {
		countMap[item] = countMap[item] || [];
		countMap[item].push(idx);
		posMap[item] = 0;
	});
	comparator &&
		Object.keys(countMap).forEach(item => {
			countMap[item].sort(comparator);
		});

	return array.map((item, i) =>
		countMap[item].length > 1
			? comparator && countMap[item][0] === i ? item : fn(item, i, posMap[item]++)
			: item
	);
};

ModuleFilenameHelpers.matchPart = (str, test) => {
	if (!test) return true;
	test = asRegExp(test);
	return Array.isArray(test)
		? test.map(asRegExp).some(regExp => regExp.test(str))
		: test.test(str);
};

ModuleFilenameHelpers.matchObject = (obj, str) => {
	return !(
		(obj.test && !ModuleFilenameHelpers.matchPart(str, obj.test)) ||
		(obj.include && !ModuleFilenameHelpers.matchPart(str, obj.include)) ||
		(obj.exclude && ModuleFilenameHelpers.matchPart(str, obj.exclude))
	);
};

},
// 19
function(module, exports, __webpack_require__) {

const DependencyReference = __webpack_require__(14),
	ModuleDependency = __webpack_require__(4),
	Template = __webpack_require__(2);

class HarmonyImportDependency extends ModuleDependency {
	constructor(request, originModule, sourceOrder, parserScope) {
		super(request);
		this.redirectedModule = void 0;
		this.originModule = originModule;
		this.sourceOrder = sourceOrder;
		this.parserScope = parserScope;
	}

	get _module() {
		return this.redirectedModule || this.module;
	}

	getReference() {
		return this._module
			? new DependencyReference(this._module, false, this.weak, this.sourceOrder) : null;
	}

	getImportVar() {
		let importVarMap = this.parserScope.importVarMap;
		importVarMap || (this.parserScope.importVarMap = importVarMap = new Map());
		let importVar = importVarMap.get(this._module);
		if (importVar) return importVar;
		importVar = `${Template.toIdentifier(
			"" + this.userRequest
		)}__WEBPACK_IMPORTED_MODULE_${importVarMap.size}__`;
		importVarMap.set(this._module, importVar);
		return importVar;
	}

	getImportStatement(update, runtime) {
		return runtime.importStatement({
			update,
			module: this._module,
			importVar: this.getImportVar(),
			request: this.request,
			originModule: this.originModule
		});
	}

	updateHash(hash) {
		super.updateHash(hash);
		const importedModule = this._module;
		hash.update(
			(importedModule &&
				(!importedModule.buildMeta || importedModule.buildMeta.exportsType)) +
				""
		);
		hash.update((importedModule && importedModule.id) + "");
	}

	disconnect() {
		super.disconnect();
		this.redirectedModule = void 0;
	}
}

module.exports = HarmonyImportDependency;

const importEmittedMap = new WeakMap();

HarmonyImportDependency.Template = class {
	apply(dep, source, runtime) {}

	getHarmonyInitOrder(dep) {
		return dep.sourceOrder;
	}

	static isImportEmitted(dep, source) {
		let sourceInfo = importEmittedMap.get(source);
		if (!sourceInfo) return false;
		const key = dep._module || dep.request;
		return key && sourceInfo.emittedImports.get(key);
	}

	harmonyInit(dep, source, runtime, dependencyTemplates) {
		let sourceInfo = importEmittedMap.get(source);
		sourceInfo ||
			importEmittedMap.set(
				source,
				(sourceInfo = { emittedImports: new Map() })
			);

		const key = dep._module || dep.request;
		if (key && sourceInfo.emittedImports.get(key)) return;
		sourceInfo.emittedImports.set(key, true);
		const content = dep.getImportStatement(false, runtime);
		source.insert(-1, content);
	}
};

},
// 20
function(module) {

class SortableSet extends Set {
	constructor(initialIterable, defaultSort) {
		super(initialIterable);
		this._sortFn = defaultSort;
		this._lastActiveSortFn = null;
		this._cache = void 0;
		this._cacheOrderIndependent = void 0;
	}

	add(value) {
		this._lastActiveSortFn = null;
		this._invalidateCache();
		this._invalidateOrderedCache();
		super.add(value);
		return this;
	}

	delete(value) {
		this._invalidateCache();
		this._invalidateOrderedCache();
		return super.delete(value);
	}

	clear() {
		this._invalidateCache();
		this._invalidateOrderedCache();
		return super.clear();
	}

	sortWith(sortFn) {
		if (this.size <= 1 || sortFn === this._lastActiveSortFn) return;

		const sortedArray = Array.from(this).sort(sortFn);
		super.clear();
		for (let i = 0; i < sortedArray.length; i += 1) super.add(sortedArray[i]);

		this._lastActiveSortFn = sortFn;
		this._invalidateCache();
	}

	sort() {
		this.sortWith(this._sortFn);
	}

	getFromCache(fn) {
		if (this._cache === void 0) this._cache = new Map();
		else {
			const data = this._cache.get(fn);
			if (data !== void 0) return data;
		}
		const newData = fn(this);
		this._cache.set(fn, newData);
		return newData;
	}

	getFromUnorderedCache(fn) {
		if (this._cacheOrderIndependent === void 0) this._cacheOrderIndependent = new Map();
		else {
			const data = this._cacheOrderIndependent.get(fn);
			if (data !== void 0) return data;
		}
		const newData = fn(this);
		this._cacheOrderIndependent.set(fn, newData);
		return newData;
	}

	_invalidateCache() {
		this._cache === void 0 || this._cache.clear();
	}

	_invalidateOrderedCache() {
		this._cacheOrderIndependent === void 0 || this._cacheOrderIndependent.clear();
	}
}

module.exports = SortableSet;

},
// 21
function(module, exports, __webpack_require__) {

const ExternalModuleFactoryPlugin = __webpack_require__(121);

class ExternalsPlugin {
	constructor(type, externals) {
		this.type = type;
		this.externals = externals;
	}
	apply(compiler) {
		compiler.hooks.compile.tap("ExternalsPlugin", ({ normalModuleFactory }) => {
			new ExternalModuleFactoryPlugin(this.type, this.externals).apply(
				normalModuleFactory
			);
		});
	}
}

module.exports = ExternalsPlugin;

},
// 22
function(module, exports) {

const connectChunkGroupAndChunk = (chunkGroup, chunk) => {
	chunkGroup.pushChunk(chunk) && chunk.addGroup(chunkGroup);
};

const connectChunkGroupParentAndChild = (parent, child) => {
	parent.addChild(child) && child.addParent(parent);
};

const connectChunkAndModule = (chunk, module) => {
	module.addChunk(chunk) && chunk.addModule(module);
};

const disconnectChunkAndModule = (chunk, module) => {
	chunk.removeModule(module);
	module.removeChunk(chunk);
};

const connectDependenciesBlockAndChunkGroup = (depBlock, chunkGroup) => {
	if (chunkGroup.addBlock(depBlock)) depBlock.chunkGroup = chunkGroup;
};

exports.connectChunkGroupAndChunk = connectChunkGroupAndChunk;
exports.connectChunkGroupParentAndChild = connectChunkGroupParentAndChild;
exports.connectChunkAndModule = connectChunkAndModule;
exports.disconnectChunkAndModule = disconnectChunkAndModule;
exports.connectDependenciesBlockAndChunkGroup = connectDependenciesBlockAndChunkGroup;

},
// 23
function(module, exports, __webpack_require__) {

const RequestShortener = __webpack_require__(52),
	SizeFormatHelpers = __webpack_require__(31),
	formatLocation = __webpack_require__(164),
	identifierUtils = __webpack_require__(13),
	compareLocations = __webpack_require__(29),
	{ LogType } = __webpack_require__(32);

const optionsOrFallback = (...args) => {
	let optionValues = [];
	optionValues.push(...args);
	return optionValues.find(optionValue => optionValue !== void 0);
};

const compareId = (a, b) =>
	typeof a !== typeof b ? (typeof a < typeof b ? -1 : 1) : a < b ? -1 : a > b ? 1 : 0;

class Stats {
	constructor(compilation) {
		this.compilation = compilation;
		this.hash = compilation.hash;
		this.startTime = void 0;
		this.endTime = void 0;
	}

	static filterWarnings(warnings, warningsFilter) {
		if (!warningsFilter) return warnings;

		const normalizedWarningsFilters = [].concat(warningsFilter).map(filter => {
			if (typeof filter == "string") return warning => warning.includes(filter);

			if (filter instanceof RegExp) return warning => filter.test(warning);

			if (typeof filter == "function") return filter;

			throw new Error(
				`Can only filter warnings with Strings or RegExps. (Given: ${filter})`
			);
		});
		return warnings.filter(warning =>
			!normalizedWarningsFilters.some(check => check(warning))
		);
	}

	formatFilePath(filePath) {
		const OPTIONS_REGEXP = /^(\s|\S)*!/;
		return filePath.includes("!")
			? `${filePath.replace(OPTIONS_REGEXP, "")} (${filePath})`
			: "" + filePath;
	}

	hasWarnings() {
		return (
			this.compilation.warnings.length > 0 ||
			this.compilation.children.some(child => child.getStats().hasWarnings())
		);
	}

	hasErrors() {
		return (
			this.compilation.errors.length > 0 ||
			this.compilation.children.some(child => child.getStats().hasErrors())
		);
	}

	normalizeFieldKey(field) {
		return field[0] === "!" ? field.substr(1) : field;
	}

	sortOrderRegular(field) {
		return field[0] !== "!";
	}

	toJson(options, forToString) {
		typeof options == "boolean" || typeof options == "string"
			? (options = Stats.presetToOptions(options))
			: options || (options = {});

		const optionOrLocalFallback = (v, def) =>
			v !== void 0 ? v : options.all !== void 0 ? options.all : def;

		const testAgainstGivenOption = item => {
			if (typeof item == "string") {
				const regExp = new RegExp(
					`[\\\\/]${item.replace(/[-[\]{}()*+?.\\^$|]/g, "\\$&")}([\\\\/]|$|!|\\?)`
				);
				return ident => regExp.test(ident);
			}
			if (item && typeof item == "object" && typeof item.test == "function")
				return ident => item.test(ident);

			if (typeof item == "function") return item;
			if (typeof item == "boolean") return () => item;
		};

		const compilation = this.compilation,
			context = optionsOrFallback(options.context, compilation.compiler.context),
			requestShortener = compilation.compiler.context === context
				? compilation.requestShortener
				: new RequestShortener(context),
			showPerformance = optionOrLocalFallback(options.performance, true),
			showHash = optionOrLocalFallback(options.hash, true),
			showEnv = optionOrLocalFallback(options.env, false),
			showVersion = optionOrLocalFallback(options.version, true),
			showTimings = optionOrLocalFallback(options.timings, true),
			showBuiltAt = optionOrLocalFallback(options.builtAt, true),
			showAssets = optionOrLocalFallback(options.assets, true),
			showEntrypoints = optionOrLocalFallback(options.entrypoints, true),
			showChunkGroups = optionOrLocalFallback(options.chunkGroups, !forToString),
			showChunks = optionOrLocalFallback(options.chunks, !forToString),
			showChunkModules = optionOrLocalFallback(options.chunkModules, true),
			showChunkOrigins = optionOrLocalFallback(options.chunkOrigins, !forToString),
			showModules = optionOrLocalFallback(options.modules, true),
			showNestedModules = optionOrLocalFallback(options.nestedModules, true),
			showModuleAssets = optionOrLocalFallback(options.moduleAssets, !forToString),
			showDepth = optionOrLocalFallback(options.depth, !forToString),
			showCachedModules = optionOrLocalFallback(options.cached, true),
			showCachedAssets = optionOrLocalFallback(options.cachedAssets, true),
			showReasons = optionOrLocalFallback(options.reasons, !forToString),
			showUsedExports = optionOrLocalFallback(options.usedExports, !forToString),
			showProvidedExports = optionOrLocalFallback(options.providedExports, !forToString),
			showOptimizationBailout = optionOrLocalFallback(options.optimizationBailout, !forToString),
			showChildren = optionOrLocalFallback(options.children, true),
			showSource = optionOrLocalFallback(options.source, !forToString),
			showModuleTrace = optionOrLocalFallback(options.moduleTrace, true),
			showErrors = optionOrLocalFallback(options.errors, true),
			showErrorDetails = optionOrLocalFallback(options.errorDetails, !forToString),
			showWarnings = optionOrLocalFallback(options.warnings, true),
			warningsFilter = optionsOrFallback(options.warningsFilter, null),
			showPublicPath = optionOrLocalFallback(options.publicPath, !forToString),
			showLogging = optionOrLocalFallback(options.logging, !forToString || "info"),
			showLoggingTrace = optionOrLocalFallback(options.loggingTrace, !forToString),
			loggingDebug = []
				.concat(optionsOrFallback(options.loggingDebug, []))
				.map(testAgainstGivenOption),

			excludeModules = []
				.concat(optionsOrFallback(options.excludeModules, options.exclude, []))
				.map(testAgainstGivenOption),
			excludeAssets = []
				.concat(optionsOrFallback(options.excludeAssets, []))
				.map(testAgainstGivenOption),
			maxModules = optionsOrFallback(options.maxModules, forToString ? 15 : Infinity),
			sortModules = optionsOrFallback(options.modulesSort, "id"),
			sortChunks = optionsOrFallback(options.chunksSort, "id"),
			sortAssets = optionsOrFallback(options.assetsSort, ""),
			showOutputPath = optionOrLocalFallback(options.outputPath, !forToString);

		showCachedModules || excludeModules.push((ident, module) => !module.built);

		const createModuleFilter = () => {
			let i = 0;
			return module => {
				if (excludeModules.length > 0) {
					const ident = requestShortener.shorten(module.resource);
					if (excludeModules.some(fn => fn(ident, module))) return false;
				}
				const result = i < maxModules;
				i++;
				return result;
			};
		};

		const createAssetFilter = () => {
			return asset => {
				if (excludeAssets.length > 0) {
					const ident = asset.name;
					if (excludeAssets.some(fn => fn(ident, asset))) return false;
				}
				return showCachedAssets || asset.emitted;
			};
		};

		const sortByFieldAndOrder = (fieldKey, a, b) =>
			a[fieldKey] === null && b[fieldKey] === null ? 0
				: a[fieldKey] === null ? 1
				: b[fieldKey] === null ? -1
				: a[fieldKey] === b[fieldKey] ? 0
				: typeof a[fieldKey] !== typeof b[fieldKey]
				? typeof a[fieldKey] < typeof b[fieldKey] ? -1 : 1
				: a[fieldKey] < b[fieldKey] ? -1 : 1;

		const sortByField = (field, originalArray) => {
			const originalMap = originalArray.reduce((map, v, i) => {
				map.set(v, i);
				return map;
			}, new Map());
			return (a, b) => {
				if (field) {
					const fieldKey = this.normalizeFieldKey(field),
						sortIsRegular = this.sortOrderRegular(field),

						cmp = sortByFieldAndOrder(fieldKey, sortIsRegular ? a : b, sortIsRegular ? b : a);
					if (cmp) return cmp;
				}
				return originalMap.get(a) - originalMap.get(b);
			};
		};

		const formatError = e => {
			let text = "";
			if (typeof e == "string") e = { message: e };

			if (e.chunk)
				text += `chunk ${e.chunk.name || e.chunk.id}${
					e.chunk.hasRuntime() ? " [entry]" : e.chunk.canBeInitial() ? " [initial]" : ""
				}\n`;

			if (e.file) text += e.file + "\n";

			if (
				e.module &&
				e.module.readableIdentifier &&
				typeof e.module.readableIdentifier == "function"
			) {
				text += this.formatFilePath(e.module.readableIdentifier(requestShortener));
				if (typeof e.loc == "object") {
					const locInfo = formatLocation(e.loc);
					if (locInfo) text += " " + locInfo;
				}
				text += "\n";
			}
			text += e.message;
			if (showErrorDetails && e.details) text += "\n" + e.details;

			if (showErrorDetails && e.missing)
				text += e.missing.map(item => `\n[${item}]`).join("");

			if (showModuleTrace && e.origin) {
				text += "\n @ " + this.formatFilePath(e.origin.readableIdentifier(requestShortener));
				if (typeof e.originLoc == "object") {
					const locInfo = formatLocation(e.originLoc);
					if (locInfo) text += " " + locInfo;
				}
				if (e.dependencies)
					for (const dep of e.dependencies)
						if (dep.loc && typeof dep.loc != "string") {
							const locInfo = formatLocation(dep.loc);
							if (locInfo) text += " " + locInfo;
						}

				let current = e.origin;
				while (current.issuer) {
					current = current.issuer;
					text += "\n @ " + current.readableIdentifier(requestShortener);
				}
			}
			return text;
		};

		const obj = {
			errors: compilation.errors.map(formatError),
			warnings: Stats.filterWarnings(
				compilation.warnings.map(formatError),
				warningsFilter
			)
		};

		Object.defineProperty(obj, "_showWarnings", { value: showWarnings, enumerable: false });
		Object.defineProperty(obj, "_showErrors", { value: showErrors, enumerable: false });

		if (showVersion) obj.version = __webpack_require__(53).version;

		if (showHash) obj.hash = this.hash;
		if (showTimings && this.startTime && this.endTime)
			obj.time = this.endTime - this.startTime;

		if (showBuiltAt && this.endTime) obj.builtAt = this.endTime;

		if (showEnv && options._env) obj.env = options._env;

		if (compilation.needAdditionalPass) obj.needAdditionalPass = true;

		if (showPublicPath)
			obj.publicPath = this.compilation.mainTemplate.getPublicPath({ hash: this.compilation.hash });

		if (showOutputPath)
			obj.outputPath = this.compilation.mainTemplate.outputOptions.path;

		if (showAssets) {
			const assetsByFile = {},
				compilationAssets = compilation.getAssets().sort((a, b) => (a.name < b.name ? -1 : 1));
			obj.assetsByChunkName = {};
			obj.assets = compilationAssets
				.map(({ name, source, info }) => {
					const obj = {
						name,
						size: source.size(),
						chunks: [],
						chunkNames: [],
						info,
						emitted: source.emitted || compilation.emittedAssets.has(name)
					};

					if (showPerformance) obj.isOverSizeLimit = source.isOverSizeLimit;

					assetsByFile[name] = obj;
					return obj;
				})
				.filter(createAssetFilter());
			obj.filteredAssets = compilationAssets.length - obj.assets.length;

			for (const chunk of compilation.chunks)
				for (const asset of chunk.files)
					if (assetsByFile[asset]) {
						for (const id of chunk.ids) assetsByFile[asset].chunks.push(id);

						if (chunk.name) {
							assetsByFile[asset].chunkNames.push(chunk.name);
							if (obj.assetsByChunkName[chunk.name])
								obj.assetsByChunkName[chunk.name] = []
									.concat(obj.assetsByChunkName[chunk.name])
									.concat([asset]);
							else
								obj.assetsByChunkName[chunk.name] = asset;
						}
					}

			obj.assets.sort(sortByField(sortAssets, obj.assets));
		}

		const fnChunkGroup = groupMap => {
			const obj = {};
			for (const keyValuePair of groupMap) {
				const name = keyValuePair[0],
					cg = keyValuePair[1],
					children = cg.getChildrenByOrders();
				obj[name] = {
					chunks: cg.chunks.map(c => c.id),
					assets: cg.chunks.reduce((array, c) => array.concat(c.files || []), []),
					children: Object.keys(children).reduce((obj, key) => {
						const groups = children[key];
						obj[key] = groups.map(group => ({
							name: group.name,
							chunks: group.chunks.map(c => c.id),
							assets: group.chunks.reduce((array, c) => array.concat(c.files || []), [])
						}));
						return obj;
					}, Object.create(null)),
					childAssets: Object.keys(children).reduce((obj, key) => {
						const groups = children[key];
						obj[key] = Array.from(
							groups.reduce((set, group) => {
								for (const chunk of group.chunks)
									for (const asset of chunk.files) set.add(asset);

								return set;
							}, new Set())
						);
						return obj;
					}, Object.create(null))
				};
				if (showPerformance) obj[name].isOverSizeLimit = cg.isOverSizeLimit;
			}

			return obj;
		};

		if (showEntrypoints) obj.entrypoints = fnChunkGroup(compilation.entrypoints);

		if (showChunkGroups)
			obj.namedChunkGroups = fnChunkGroup(compilation.namedChunkGroups);

		const fnModule = module => {
			const path = [];
			let current = module;
			while (current.issuer) path.push((current = current.issuer));

			path.reverse();
			const obj = {
				id: module.id,
				identifier: module.identifier(),
				name: module.readableIdentifier(requestShortener),
				index: module.index,
				index2: module.index2,
				size: module.size(),
				cacheable: module.buildInfo.cacheable,
				built: !!module.built,
				optional: module.optional,
				prefetched: module.prefetched,
				chunks: Array.from(module.chunksIterable, chunk => chunk.id),
				issuer: module.issuer && module.issuer.identifier(),
				issuerId: module.issuer && module.issuer.id,
				issuerName:
					module.issuer && module.issuer.readableIdentifier(requestShortener),
				issuerPath:
					module.issuer &&
					path.map(module => ({
						id: module.id,
						identifier: module.identifier(),
						name: module.readableIdentifier(requestShortener),
						profile: module.profile
					})),
				profile: module.profile,
				failed: !!module.error,
				errors: module.errors ? module.errors.length : 0,
				warnings: module.warnings ? module.warnings.length : 0
			};
			if (showModuleAssets)
				obj.assets = Object.keys(module.buildInfo.assets || {});

			if (showReasons)
				obj.reasons = module.reasons
					.sort((a, b) => {
						if (a.module && !b.module) return -1;
						if (!a.module && b.module) return 1;
						if (a.module && b.module) {
							const cmp = compareId(a.module.id, b.module.id);
							if (cmp) return cmp;
						}
						if (a.dependency && !b.dependency) return -1;
						if (!a.dependency && b.dependency) return 1;
						if (a.dependency && b.dependency) {
							const cmp = compareLocations(a.dependency.loc, b.dependency.loc);
							if (cmp) return cmp;
							if (a.dependency.type < b.dependency.type) return -1;
							if (a.dependency.type > b.dependency.type) return 1;
						}
						return 0;
					})
					.map(reason => {
						const obj = {
							moduleId: reason.module ? reason.module.id : null,
							moduleIdentifier: reason.module
								? reason.module.identifier()
								: null,
							module: reason.module
								? reason.module.readableIdentifier(requestShortener)
								: null,
							moduleName: reason.module
								? reason.module.readableIdentifier(requestShortener)
								: null,
							type: reason.dependency ? reason.dependency.type : null,
							explanation: reason.explanation,
							userRequest: reason.dependency
								? reason.dependency.userRequest
								: null
						};
						if (reason.dependency) {
							const locInfo = formatLocation(reason.dependency.loc);
							if (locInfo) obj.loc = locInfo;
						}
						return obj;
					});

			if (showUsedExports) {
				if (module.used === true) obj.usedExports = module.usedExports;
				else if (module.used === false) obj.usedExports = false;
			}
			if (showProvidedExports)
				obj.providedExports = Array.isArray(module.buildMeta.providedExports)
					? module.buildMeta.providedExports
					: null;

			if (showOptimizationBailout)
				obj.optimizationBailout = module.optimizationBailout.map(item =>
					typeof item == "function" ? item(requestShortener) : item
				);

			if (showDepth) obj.depth = module.depth;

			if (showNestedModules && module.modules) {
				const modules = module.modules;
				obj.modules = modules
					.sort(sortByField("depth", modules))
					.filter(createModuleFilter())
					.map(fnModule);
				obj.filteredModules = modules.length - obj.modules.length;
				obj.modules.sort(sortByField(sortModules, obj.modules));
			}

			if (showSource && module._source) obj.source = module._source.source();

			return obj;
		};
		if (showChunks) {
			obj.chunks = compilation.chunks.map(chunk => {
				const parents = new Set(),
					children = new Set(),
					siblings = new Set(),
					childIdByOrder = chunk.getChildIdsByOrders();
				for (const chunkGroup of chunk.groupsIterable) {
					for (const parentGroup of chunkGroup.parentsIterable)
						for (const chunk of parentGroup.chunks) parents.add(chunk.id);

					for (const childGroup of chunkGroup.childrenIterable)
						for (const chunk of childGroup.chunks) children.add(chunk.id);

					for (const sibling of chunkGroup.chunks)
						sibling === chunk || siblings.add(sibling.id);
				}
				const obj = {
					id: chunk.id,
					rendered: chunk.rendered,
					initial: chunk.canBeInitial(),
					entry: chunk.hasRuntime(),
					recorded: chunk.recorded,
					reason: chunk.chunkReason,
					size: chunk.modulesSize(),
					names: chunk.name ? [chunk.name] : [],
					files: chunk.files.slice(),
					hash: chunk.renderedHash,
					siblings: Array.from(siblings).sort(compareId),
					parents: Array.from(parents).sort(compareId),
					children: Array.from(children).sort(compareId),
					childrenByOrder: childIdByOrder
				};
				if (showChunkModules) {
					const modules = chunk.getModules();
					obj.modules = modules
						.slice()
						.sort(sortByField("depth", modules))
						.filter(createModuleFilter())
						.map(fnModule);
					obj.filteredModules = chunk.getNumberOfModules() - obj.modules.length;
					obj.modules.sort(sortByField(sortModules, obj.modules));
				}
				if (showChunkOrigins)
					obj.origins = Array.from(chunk.groupsIterable, g => g.origins)
						.reduce((a, b) => a.concat(b), [])
						.map(origin => ({
							moduleId: origin.module ? origin.module.id : void 0,
							module: origin.module ? origin.module.identifier() : "",
							moduleIdentifier: origin.module ? origin.module.identifier() : "",
							moduleName: origin.module
								? origin.module.readableIdentifier(requestShortener)
								: "",
							loc: formatLocation(origin.loc),
							request: origin.request,
							reasons: origin.reasons || []
						}))
						.sort((a, b) => {
							const cmp1 = compareId(a.moduleId, b.moduleId);
							if (cmp1) return cmp1;
							const cmp2 = compareId(a.loc, b.loc);
							if (cmp2) return cmp2;
							const cmp3 = compareId(a.request, b.request);
							return cmp3 ? cmp3 : 0;
						});

				return obj;
			});
			obj.chunks.sort(sortByField(sortChunks, obj.chunks));
		}
		if (showModules) {
			obj.modules = compilation.modules
				.slice()
				.sort(sortByField("depth", compilation.modules))
				.filter(createModuleFilter())
				.map(fnModule);
			obj.filteredModules = compilation.modules.length - obj.modules.length;
			obj.modules.sort(sortByField(sortModules, obj.modules));
		}
		if (showLogging) {
			const util = __webpack_require__(11);
			obj.logging = {};
			let acceptedTypes,
				collapsedGroups = false;
			switch (showLogging) {
				case "none":
					acceptedTypes = new Set([]);
					break;
				case "error":
					acceptedTypes = new Set([LogType.error]);
					break;
				case "warn":
					acceptedTypes = new Set([LogType.error, LogType.warn]);
					break;
				case "info":
					acceptedTypes = new Set([LogType.error, LogType.warn, LogType.info]);
					break;
				case true:
				case "log":
					acceptedTypes = new Set([
						LogType.error,
						LogType.warn,
						LogType.info,
						LogType.log,
						LogType.group,
						LogType.groupEnd,
						LogType.groupCollapsed,
						LogType.clear
					]);
					break;
				case "verbose":
					acceptedTypes = new Set([
						LogType.error,
						LogType.warn,
						LogType.info,
						LogType.log,
						LogType.group,
						LogType.groupEnd,
						LogType.groupCollapsed,
						LogType.profile,
						LogType.profileEnd,
						LogType.time,
						LogType.status,
						LogType.clear
					]);
					collapsedGroups = true;
					break;
			}
			for (const [origin, logEntries] of compilation.logging) {
				const debugMode = loggingDebug.some(fn => fn(origin));
				let collapseCounter = 0,
					processedLogEntries = logEntries;
				debugMode ||
					(processedLogEntries = processedLogEntries.filter(entry => {
						if (!acceptedTypes.has(entry.type)) return false;
						if (collapsedGroups) return true;

						switch (entry.type) {
							case LogType.groupCollapsed:
								collapseCounter++;
								return collapseCounter === 1;
							case LogType.group:
								collapseCounter > 0 && collapseCounter++;
								return collapseCounter === 0;
							case LogType.groupEnd:
								if (collapseCounter > 0) {
									collapseCounter--;
									return false;
								}
								return true;
							default:
								return collapseCounter === 0;
						}
					}));

				processedLogEntries = processedLogEntries.map(entry => {
					let message =
						entry.type === LogType.time
							? `${entry.args[0]}: ${entry.args[1] * 1000 + entry.args[2] / 1000000}ms`
							: entry.args && entry.args.length > 0
							? util.format(entry.args[0], ...entry.args.slice(1))
							: void 0;

					return {
						type:
							(debugMode || collapsedGroups) &&
							entry.type === LogType.groupCollapsed ? LogType.group : entry.type,
						message,
						trace: showLoggingTrace && entry.trace ? entry.trace : void 0
					};
				});
				let name = identifierUtils
					.makePathsRelative(context, origin, compilation.cache)
					.replace(/\|/g, " ");
				if (name in obj.logging) {
					let i = 1;
					while (`${name}#${i}` in obj.logging) i++;

					name = `${name}#${i}`;
				}
				obj.logging[name] = {
					entries: processedLogEntries,
					filteredEntries: logEntries.length - processedLogEntries.length,
					debug: debugMode
				};
			}
		}
		if (showChildren)
			obj.children = compilation.children.map((child, idx) => {
				const childOptions = Stats.getChildOptions(options, idx),
					obj = new Stats(child).toJson(childOptions, forToString);
				delete obj.hash;
				delete obj.version;
				if (child.name)
					obj.name = identifierUtils.makePathsRelative(
						context,
						child.name,
						compilation.cache
					);

				return obj;
			});

		return obj;
	}

	toString(options) {
		typeof options == "boolean" || typeof options == "string"
			? (options = Stats.presetToOptions(options))
			: options || (options = {});

		const useColors = optionsOrFallback(options.colors, false),
			obj = this.toJson(options, true);

		return Stats.jsonToString(obj, useColors);
	}

	static jsonToString(obj, useColors) {
		const buf = [];

		const defaultColors = {
			bold: "\x1b[1m",
			yellow: "\x1b[1m\x1b[33m",
			red: "\x1b[1m\x1b[31m",
			green: "\x1b[1m\x1b[32m",
			cyan: "\x1b[1m\x1b[36m",
			magenta: "\x1b[1m\x1b[35m"
		};

		const colors = Object.keys(defaultColors).reduce(
			(obj, color) => {
				obj[color] = str => {
					useColors &&
						buf.push(
							useColors === true || useColors[color] === void 0
								? defaultColors[color]
								: useColors[color]
						);

					buf.push(str);
					useColors && buf.push("\x1b[39m\x1b[22m");
				};
				return obj;
			},
			{ normal: str => buf.push(str) }
		);

		const coloredTime = time => {
			let times = [800, 400, 200, 100];
			if (obj.time)
				times = [obj.time / 2, obj.time / 4, obj.time / 8, obj.time / 16];

			time < times[3] ? colors.normal(time + "ms")
				: time < times[2] ? colors.bold(time + "ms")
				: time < times[1] ? colors.green(time + "ms")
				: time < times[0] ? colors.yellow(time + "ms")
				: colors.red(time + "ms");
		};

		const newline = () => buf.push("\n"),

			getText = (arr, row, col) => arr[row][col].value;

		const table = (array, align, splitter) => {
			const rows = array.length,
				cols = array[0].length,
				colSizes = new Array(cols);
			for (let col = 0; col < cols; col++) colSizes[col] = 0;

			for (let row = 0; row < rows; row++)
				for (let col = 0; col < cols; col++) {
					const value = "" + getText(array, row, col);
					if (value.length > colSizes[col]) colSizes[col] = value.length;
				}

			for (let row = 0; row < rows; row++) {
				for (let col = 0; col < cols; col++) {
					const format = array[row][col].color,
						value = "" + getText(array, row, col);
					let l = value.length;
					align[col] !== "l" || format(value);

					for (; l < colSizes[col] && col !== cols - 1; l++) colors.normal(" ");

					align[col] !== "r" || format(value);

					col + 1 < cols && colSizes[col] !== 0 && colors.normal(splitter || "  ");
				}
				newline();
			}
		};

		const getAssetColor = (asset, defaultColor) =>
			asset.isOverSizeLimit ? colors.yellow : defaultColor;

		if (obj.hash) {
			colors.normal("Hash: ");
			colors.bold(obj.hash);
			newline();
		}
		if (obj.version) {
			colors.normal("Version: webpack ");
			colors.bold(obj.version);
			newline();
		}
		if (typeof obj.time == "number") {
			colors.normal("Time: ");
			colors.bold(obj.time);
			colors.normal("ms");
			newline();
		}
		if (typeof obj.builtAt == "number") {
			const builtAtDate = new Date(obj.builtAt);
			let timeZone = void 0;

			try {
				builtAtDate.toLocaleTimeString();
			} catch (_err) {
				timeZone = "UTC";
			}

			colors.normal("Built at: ");
			colors.normal(
				builtAtDate.toLocaleDateString(
					void 0,
					{ day: "2-digit", month: "2-digit", year: "numeric", timeZone }
				)
			);
			colors.normal(" ");
			colors.bold(builtAtDate.toLocaleTimeString(void 0, { timeZone }));
			newline();
		}
		if (obj.env) {
			colors.normal("Environment (--env): ");
			colors.bold(JSON.stringify(obj.env, null, 2));
			newline();
		}
		if (obj.publicPath) {
			colors.normal("PublicPath: ");
			colors.bold(obj.publicPath);
			newline();
		}

		if (obj.assets && obj.assets.length > 0) {
			const t = [
				[
					{ value: "Asset", color: colors.bold },
					{ value: "Size", color: colors.bold },
					{ value: "Chunks", color: colors.bold },
					{ value: "", color: colors.bold },
					{ value: "", color: colors.bold },
					{ value: "Chunk Names", color: colors.bold }
				]
			];
			for (const asset of obj.assets) {
				t.push([
					{ value: asset.name, color: getAssetColor(asset, colors.green) },
					{ value: SizeFormatHelpers.formatSize(asset.size), color: getAssetColor(asset, colors.normal) },
					{ value: asset.chunks.join(", "), color: colors.bold },
					{
						value: [
							asset.emitted && "[emitted]",
							asset.info.immutable && "[immutable]",
							asset.info.development && "[dev]",
							asset.info.hotModuleReplacement && "[hmr]"
						]
							.filter(Boolean)
							.join(" "),
						color: colors.green
					},
					{ value: asset.isOverSizeLimit ? "[big]" : "", color: getAssetColor(asset, colors.normal) },
					{ value: asset.chunkNames.join(", "), color: colors.normal }
				]);
			}
			table(t, "rrrlll");
		}
		if (obj.filteredAssets > 0) {
			colors.normal(" ");
			obj.assets.length > 0 && colors.normal("+ ");
			colors.normal(obj.filteredAssets);
			obj.assets.length > 0 && colors.normal(" hidden");
			colors.normal(obj.filteredAssets !== 1 ? " assets" : " asset");
			newline();
		}

		const processChunkGroups = (namedGroups, prefix) => {
			for (const name of Object.keys(namedGroups)) {
				const cg = namedGroups[name];
				colors.normal(prefix + " ");
				colors.bold(name);
				if (cg.isOverSizeLimit) {
					colors.normal(" ");
					colors.yellow("[big]");
				}
				colors.normal(" =");
				for (const asset of cg.assets) {
					colors.normal(" ");
					colors.green(asset);
				}
				for (const name of Object.keys(cg.childAssets)) {
					const assets = cg.childAssets[name];
					if (assets && assets.length > 0) {
						colors.normal(" ");
						colors.magenta(`(${name}:`);
						for (const asset of assets) {
							colors.normal(" ");
							colors.green(asset);
						}
						colors.magenta(")");
					}
				}
				newline();
			}
		};

		obj.entrypoints && processChunkGroups(obj.entrypoints, "Entrypoint");

		if (obj.namedChunkGroups) {
			let outputChunkGroups = obj.namedChunkGroups;
			if (obj.entrypoints)
				outputChunkGroups = Object.keys(outputChunkGroups)
					.filter(name => !obj.entrypoints[name])
					.reduce((result, name) => {
						result[name] = obj.namedChunkGroups[name];
						return result;
					}, {});

			processChunkGroups(outputChunkGroups, "Chunk Group");
		}

		const modulesByIdentifier = {};
		if (obj.modules)
			for (const module of obj.modules)
				modulesByIdentifier["$" + module.identifier] = module;
		else if (obj.chunks)
			for (const chunk of obj.chunks)
				if (chunk.modules)
					for (const module of chunk.modules)
						modulesByIdentifier["$" + module.identifier] = module;

		const processModuleAttributes = module => {
			colors.normal(" ");
			colors.normal(SizeFormatHelpers.formatSize(module.size));
			if (module.chunks)
				for (const chunk of module.chunks) {
					colors.normal(" {");
					colors.yellow(chunk);
					colors.normal("}");
				}

			typeof module.depth != "number" || colors.normal(` [depth ${module.depth}]`);

			module.cacheable !== false || colors.red(" [not cacheable]");

			module.optional && colors.yellow(" [optional]");
			module.built && colors.green(" [built]");

			module.assets && module.assets.length &&
				colors.magenta(
					` [${module.assets.length} asset${module.assets.length === 1 ? "" : "s"}]`
				);

			module.prefetched && colors.magenta(" [prefetched]");

			module.failed && colors.red(" [failed]");
			module.warnings &&
				colors.yellow(
					` [${module.warnings} warning${module.warnings === 1 ? "" : "s"}]`
				);

			module.errors &&
				colors.red(` [${module.errors} error${module.errors === 1 ? "" : "s"}]`);
		};

		const processModuleContent = (module, prefix) => {
			if (Array.isArray(module.providedExports)) {
				colors.normal(prefix);
				module.providedExports.length === 0
					? colors.cyan("[no exports]")
					: colors.cyan(`[exports: ${module.providedExports.join(", ")}]`);

				newline();
			}
			if (module.usedExports !== void 0 && module.usedExports !== true) {
				colors.normal(prefix);
				if (module.usedExports === null) colors.cyan("[used exports unknown]");
				else if (module.usedExports === false) colors.cyan("[no exports used]");
				else if (Array.isArray(module.usedExports) && module.usedExports.length === 0)
					colors.cyan("[no exports used]");
				else if (Array.isArray(module.usedExports)) {
					const providedExportsCount = Array.isArray(module.providedExports)
						? module.providedExports.length
						: null;
					providedExportsCount !== null && providedExportsCount === module.usedExports.length
						? colors.cyan("[all exports used]")
						: colors.cyan(`[only some exports used: ${module.usedExports.join(", ")}]`);
				}
				newline();
			}

			if (Array.isArray(module.optimizationBailout))
				for (const item of module.optimizationBailout) {
					colors.normal(prefix);
					colors.yellow(item);
					newline();
				}

			if (module.reasons)
				for (const reason of module.reasons) {
					colors.normal(prefix);
					if (reason.type) {
						colors.normal(reason.type);
						colors.normal(" ");
					}
					if (reason.userRequest) {
						colors.cyan(reason.userRequest);
						colors.normal(" ");
					}
					if (reason.moduleId !== null) {
						colors.normal("[");
						colors.normal(reason.moduleId);
						colors.normal("]");
					}
					if (reason.module && reason.module !== reason.moduleId) {
						colors.normal(" ");
						colors.magenta(reason.module);
					}
					if (reason.loc) {
						colors.normal(" ");
						colors.normal(reason.loc);
					}
					if (reason.explanation) {
						colors.normal(" ");
						colors.cyan(reason.explanation);
					}
					newline();
				}

			if (module.profile) {
				colors.normal(prefix);
				let sum = 0;
				if (module.issuerPath)
					for (const m of module.issuerPath) {
						colors.normal("[");
						colors.normal(m.id);
						colors.normal("] ");
						if (m.profile) {
							const time = (m.profile.factory || 0) + (m.profile.building || 0);
							coloredTime(time);
							sum += time;
							colors.normal(" ");
						}
						colors.normal("-> ");
					}

				for (const key of Object.keys(module.profile)) {
					colors.normal(key + ":");
					const time = module.profile[key];
					coloredTime(time);
					colors.normal(" ");
					sum += time;
				}
				colors.normal("= ");
				coloredTime(sum);
				newline();
			}
			module.modules && processModulesList(module, prefix + "| ");
		};

		const processModulesList = (obj, prefix) => {
			if (!obj.modules) return;

			let maxModuleId = 0;
			for (const module of obj.modules)
				if (typeof module.id == "number" && maxModuleId < module.id) maxModuleId = module.id;

			let contentPrefix = prefix + "    ";
			if (maxModuleId >= 10) contentPrefix += " ";
			if (maxModuleId >= 100) contentPrefix += " ";
			if (maxModuleId >= 1000) contentPrefix += " ";
			for (const module of obj.modules) {
				colors.normal(prefix);
				const name = module.name || module.identifier;
				if (typeof module.id == "string" || typeof module.id == "number") {
					if (typeof module.id == "number") {
						module.id >= 1000 || maxModuleId < 1000 || colors.normal(" ");
						module.id >= 100 || maxModuleId < 100 || colors.normal(" ");
						module.id >= 10 || maxModuleId < 10 || colors.normal(" ");
					} else {
						maxModuleId < 1000 || colors.normal(" ");
						maxModuleId < 100 || colors.normal(" ");
						maxModuleId < 10 || colors.normal(" ");
					}
					if (name !== module.id) {
						colors.normal("[");
						colors.normal(module.id);
						colors.normal("]");
						colors.normal(" ");
					} else {
						colors.normal("[");
						colors.bold(module.id);
						colors.normal("]");
					}
				}
				name === module.id || colors.bold(name);

				processModuleAttributes(module);
				newline();
				processModuleContent(module, contentPrefix);
			}
			if (obj.filteredModules > 0) {
				colors.normal(prefix);
				colors.normal("   ");
				obj.modules.length > 0 && colors.normal(" + ");
				colors.normal(obj.filteredModules);
				obj.modules.length > 0 && colors.normal(" hidden");
				colors.normal(obj.filteredModules !== 1 ? " modules" : " module");
				newline();
			}
		};

		if (obj.chunks)
			for (const chunk of obj.chunks) {
				colors.normal("chunk ");
				chunk.id < 1000 && colors.normal(" ");
				chunk.id < 100 && colors.normal(" ");
				chunk.id < 10 && colors.normal(" ");
				colors.normal("{");
				colors.yellow(chunk.id);
				colors.normal("} ");
				colors.green(chunk.files.join(", "));
				if (chunk.names && chunk.names.length > 0) {
					colors.normal(" (");
					colors.normal(chunk.names.join(", "));
					colors.normal(")");
				}
				colors.normal(" ");
				colors.normal(SizeFormatHelpers.formatSize(chunk.size));
				for (const id of chunk.parents) {
					colors.normal(" <{");
					colors.yellow(id);
					colors.normal("}>");
				}
				for (const id of chunk.siblings) {
					colors.normal(" ={");
					colors.yellow(id);
					colors.normal("}=");
				}
				for (const id of chunk.children) {
					colors.normal(" >{");
					colors.yellow(id);
					colors.normal("}<");
				}
				if (chunk.childrenByOrder)
					for (const name of Object.keys(chunk.childrenByOrder)) {
						const children = chunk.childrenByOrder[name];
						colors.normal(" ");
						colors.magenta(`(${name}:`);
						for (const id of children) {
							colors.normal(" {");
							colors.yellow(id);
							colors.normal("}");
						}
						colors.magenta(")");
					}

				chunk.entry
					? colors.yellow(" [entry]")
					: chunk.initial && colors.yellow(" [initial]");

				chunk.rendered && colors.green(" [rendered]");
				chunk.recorded && colors.green(" [recorded]");

				chunk.reason && colors.yellow(" " + chunk.reason);

				newline();
				if (chunk.origins)
					for (const origin of chunk.origins) {
						colors.normal("    > ");
						if (origin.reasons && origin.reasons.length) {
							colors.yellow(origin.reasons.join(" "));
							colors.normal(" ");
						}
						if (origin.request) {
							colors.normal(origin.request);
							colors.normal(" ");
						}
						if (origin.module) {
							colors.normal("[");
							colors.normal(origin.moduleId);
							colors.normal("] ");
							const module = modulesByIdentifier["$" + origin.module];
							if (module) {
								colors.bold(module.name);
								colors.normal(" ");
							}
						}
						origin.loc && colors.normal(origin.loc);

						newline();
					}

				processModulesList(chunk, " ");
			}

		processModulesList(obj, "");

		if (obj.logging)
			for (const origin of Object.keys(obj.logging)) {
				const logData = obj.logging[origin];
				if (logData.entries.length <= 0) continue;

				newline();
				logData.debug && colors.red("DEBUG ");

				colors.bold("LOG from " + origin);
				newline();
				let indent = "";
				for (const entry of logData.entries) {
					let color = colors.normal,
						prefix = "    ";
					switch (entry.type) {
						case LogType.clear:
							colors.normal(indent + "-------");
							newline();
							continue;
						case LogType.error:
							color = colors.red;
							prefix = "<e> ";
							break;
						case LogType.warn:
							color = colors.yellow;
							prefix = "<w> ";
							break;
						case LogType.info:
							color = colors.green;
							prefix = "<i> ";
							break;
						case LogType.log:
							color = colors.bold;
							break;
						case LogType.trace:
						case LogType.debug:
							color = colors.normal;
							break;
						case LogType.status:
							color = colors.magenta;
							prefix = "<s> ";
							break;
						case LogType.profile:
							color = colors.magenta;
							prefix = "<p> ";
							break;
						case LogType.profileEnd:
							color = colors.magenta;
							prefix = "</p> ";
							break;
						case LogType.time:
							color = colors.magenta;
							prefix = "<t> ";
							break;
						case LogType.group:
							color = colors.cyan;
							prefix = "<-> ";
							break;
						case LogType.groupCollapsed:
							color = colors.cyan;
							prefix = "<+> ";
							break;
						case LogType.groupEnd:
							if (indent.length >= 2) indent = indent.slice(0, indent.length - 2);
							continue;
					}
					if (entry.message)
						for (const line of entry.message.split("\n")) {
							colors.normal(`${indent}${prefix}`);
							color(line);
							newline();
						}

					if (entry.trace)
						for (const line of entry.trace) {
							colors.normal(`${indent}| ${line}`);
							newline();
						}

					if (entry.type === LogType.group) indent += "  ";
				}
				if (logData.filteredEntries) {
					colors.normal(`+ ${logData.filteredEntries} hidden lines`);
					newline();
				}
			}

		if (obj._showWarnings && obj.warnings)
			for (const warning of obj.warnings) {
				newline();
				colors.yellow("WARNING in " + warning);
				newline();
			}

		if (obj._showErrors && obj.errors)
			for (const error of obj.errors) {
				newline();
				colors.red("ERROR in " + error);
				newline();
			}

		if (obj.children)
			for (const child of obj.children) {
				const childString = Stats.jsonToString(child, useColors);
				if (childString) {
					if (child.name) {
						colors.normal("Child ");
						colors.bold(child.name);
						colors.normal(":");
					} else colors.normal("Child");

					newline();
					buf.push("    ");
					buf.push(childString.replace(/\n/g, "\n    "));
					newline();
				}
			}

		obj.needAdditionalPass &&
			colors.yellow("Compilation needs an additional pass and will compile again.");

		while (buf[buf.length - 1] === "\n") buf.pop();

		return buf.join("");
	}

	static presetToOptions(name) {
		switch ((typeof name == "string" && name.toLowerCase()) || name || "none") {
			case "none":
				return { all: false };
			case "verbose":
				return {
					entrypoints: true,
					chunkGroups: true,
					modules: false,
					chunks: true,
					chunkModules: true,
					chunkOrigins: true,
					depth: true,
					env: true,
					reasons: true,
					usedExports: true,
					providedExports: true,
					optimizationBailout: true,
					errorDetails: true,
					publicPath: true,
					logging: "verbose",
					exclude: false,
					maxModules: Infinity
				};
			case "detailed":
				return {
					entrypoints: true,
					chunkGroups: true,
					chunks: true,
					chunkModules: false,
					chunkOrigins: true,
					depth: true,
					usedExports: true,
					providedExports: true,
					optimizationBailout: true,
					errorDetails: true,
					publicPath: true,
					logging: true,
					exclude: false,
					maxModules: Infinity
				};
			case "minimal":
				return {
					all: false,
					modules: true,
					maxModules: 0,
					errors: true,
					warnings: true,
					logging: "warn"
				};
			case "errors-only":
				return { all: false, errors: true, moduleTrace: true, logging: "error" };
			case "errors-warnings":
				return { all: false, errors: true, warnings: true, logging: "warn" };
			default:
				return {};
		}
	}

	static getChildOptions(options, idx) {
		let innerOptions;
		if (Array.isArray(options.children))
			idx < options.children.length && (innerOptions = options.children[idx]);
		else if (typeof options.children == "object" && options.children)
			innerOptions = options.children;

		if (typeof innerOptions == "boolean" || typeof innerOptions == "string")
			innerOptions = Stats.presetToOptions(innerOptions);

		if (!innerOptions) return options;

		const childOptions = Object.assign({}, options);
		delete childOptions.children;
		return Object.assign(childOptions, innerOptions);
	}
}

module.exports = Stats;

},
// 24
function(module) {

module.exports = require("./enhanced-resolve");

},
// 25
function(module, exports, __webpack_require__) {

const ModuleDependency = __webpack_require__(4);

class SingleEntryDependency extends ModuleDependency {
	constructor(request) {
		super(request);
	}

	get type() {
		return "single entry";
	}
}

module.exports = SingleEntryDependency;

},
// 26
function(module, exports, __webpack_require__) {

const Dependency = __webpack_require__(17),
	CriticalDependencyWarning = __webpack_require__(235),

	regExpToString = r => (r ? r + "" : "");

class ContextDependency extends Dependency {
	constructor(options) {
		super();
		this.options = options;
		this.userRequest = this.options.request;
		this.critical = false;
		this.hadGlobalOrStickyRegExp = false;
		if (this.options.regExp.global || this.options.regExp.sticky) {
			this.options.regExp = null;
			this.hadGlobalOrStickyRegExp = true;
		}
	}

	getResourceIdentifier() {
		return (
			`context${this.options.request} ${this.options.recursive} ${regExpToString(this.options.regExp)} ${regExpToString(
				this.options.include
			)} ${regExpToString(this.options.exclude)} ${this.options.mode} ${this.options.chunkName} ${JSON.stringify(this.options.groupOptions)}`
		);
	}

	getWarnings() {
		let warnings = super.getWarnings() || [];
		this.critical && warnings.push(new CriticalDependencyWarning(this.critical));

		this.hadGlobalOrStickyRegExp &&
			warnings.push(
				new CriticalDependencyWarning(
					"Contexts can't use RegExps with the 'g' or 'y' flags."
				)
			);

		return warnings;
	}
}

Object.defineProperty(ContextDependency.prototype, "async", {
	configurable: false,
	get() {
		throw new Error(
			"ContextDependency.async was removed. Use ContextDependency.options.mode instead."
		);
	},
	set() {
		throw new Error(
			"ContextDependency.async was removed. Pass options.mode to constructor instead"
		);
	}
});

module.exports = ContextDependency;

},
// 27
function(module, exports) {

const ContextDependencyHelpers = exports,

	quotemeta = str => str.replace(/[-[\]\\/{}()*+?.^$|]/g, "\\$&");

const splitContextFromPrefix = prefix => {
	const idx = prefix.lastIndexOf("/");
	let context = ".";
	if (idx >= 0) {
		context = prefix.substr(0, idx);
		prefix = "." + prefix.substr(idx);
	}
	return { context, prefix };
};

const splitQueryFromPostfix = postfix => {
	const idx = postfix.indexOf("?");
	let query = "";
	if (idx >= 0) {
		query = postfix.substr(idx);
		postfix = postfix.substr(0, idx);
	}
	return { postfix, query };
};

ContextDependencyHelpers.create = (
	Dep,
	range,
	param,
	expr,
	options,
	contextOptions,
	parser = null
) => {
	if (param.isTemplateString()) {
		let prefixRaw = param.quasis[0].string,
			postfixRaw =
				param.quasis.length > 1 ? param.quasis[param.quasis.length - 1].string : "";

		const valueRange = param.range,
			{ context, prefix } = splitContextFromPrefix(prefixRaw),
			{ postfix, query } = splitQueryFromPostfix(postfixRaw),

			innerQuasis = param.quasis.slice(1, param.quasis.length - 1);
		const innerRegExp =
			options.wrappedContextRegExp.source +
			innerQuasis
				.map(q => quotemeta(q.string) + options.wrappedContextRegExp.source)
				.join("");

		const regExp = new RegExp(
			`^${quotemeta(prefix)}${innerRegExp}${quotemeta(postfix)}$`
		);
		const dep = new Dep(
			Object.assign(
				{ request: context + query, recursive: options.wrappedContextRecursive, regExp, mode: "sync" },
				contextOptions
			),
			range,
			valueRange
		);
		dep.loc = expr.loc;
		const replaces = [];

		param.parts.forEach((part, i) => {
			if (i % 2 == 0) {
				let range = part.range,
					value = part.string;
				if (param.templateStringKind === "cooked") {
					value = JSON.stringify(value);
					value = value.slice(1, value.length - 1);
				}
				if (i === 0) {
					value = prefix;
					range = [param.range[0], part.range[1]];
					value =
						(param.templateStringKind === "cooked" ? "`" : "String.raw`") +
						value;
				} else if (i === param.parts.length - 1) {
					value = postfix;
					range = [part.range[0], param.range[1]];
					value = value + "`";
				} else if (
					part.expression &&
					part.expression.type === "TemplateElement" &&
					part.expression.value.raw === value
				)
					return;

				replaces.push({ range, value });
			} else parser && parser.walkExpression(part.expression);
		});

		dep.replaces = replaces;
		dep.critical =
			options.wrappedContextCritical &&
			"a part of the request of a dependency is an expression";
		return dep;
	}
	if (
		param.isWrapped() &&
		((param.prefix && param.prefix.isString()) || (param.postfix && param.postfix.isString()))
	) {
		let prefixRaw = param.prefix && param.prefix.isString() ? param.prefix.string : "",
			postfixRaw = param.postfix && param.postfix.isString() ? param.postfix.string : "";
		const prefixRange = param.prefix && param.prefix.isString() ? param.prefix.range : null,
			postfixRange = param.postfix && param.postfix.isString() ? param.postfix.range : null,
			valueRange = param.range,
			{ context, prefix } = splitContextFromPrefix(prefixRaw),
			{ postfix, query } = splitQueryFromPostfix(postfixRaw),
			regExp = new RegExp(
				`^${quotemeta(prefix)}${options.wrappedContextRegExp.source}${quotemeta(postfix)}$`
			);
		const dep = new Dep(
			Object.assign(
				{ request: context + query, recursive: options.wrappedContextRecursive, regExp, mode: "sync" },
				contextOptions
			),
			range,
			valueRange
		);
		dep.loc = expr.loc;
		const replaces = [];
		prefixRange &&
			replaces.push({ range: prefixRange, value: JSON.stringify(prefix) });

		postfixRange &&
			replaces.push({ range: postfixRange, value: JSON.stringify(postfix) });

		dep.replaces = replaces;
		dep.critical =
			options.wrappedContextCritical &&
			"a part of the request of a dependency is an expression";

		if (parser && param.wrappedInnerExpressions)
			for (const part of param.wrappedInnerExpressions)
				part.expression && parser.walkExpression(part.expression);

		return dep;
	}
	const dep = new Dep(
		Object.assign(
			{
				request: options.exprContextRequest,
				recursive: options.exprContextRecursive,
				regExp: options.exprContextRegExp,
				mode: "sync"
			},
			contextOptions
		),
		range,
		param.range
	);
	dep.loc = expr.loc;
	dep.critical =
		options.exprContextCritical &&
		"the request of a dependency is an expression";

	parser && parser.walkExpression(param.expression);

	return dep;
};

},
// 28
function(module, exports, __webpack_require__) {

const HarmonyImportDependency = __webpack_require__(19);

class HarmonyImportSideEffectDependency extends HarmonyImportDependency {
	constructor(request, originModule, sourceOrder, parserScope) {
		super(request, originModule, sourceOrder, parserScope);
	}

	getReference() {
		return this._module && this._module.factoryMeta.sideEffectFree ? null
			: super.getReference();
	}

	get type() {
		return "harmony side effect evaluation";
	}
}

HarmonyImportSideEffectDependency.Template = class extends HarmonyImportDependency.Template {
	getHarmonyInitOrder(dep) {
		return dep._module && dep._module.factoryMeta.sideEffectFree ? NaN
			: super.getHarmonyInitOrder(dep);
	}
};

module.exports = HarmonyImportSideEffectDependency;

},
// 29
function(module) {

module.exports = (a, b) => {
	if (typeof a == "string")
		return typeof b == "string"
			? (a < b ? -1 : a > b ? 1 : 0)
			: typeof b == "object"
			? 1
			: 0;
	if (typeof a == "object") {
		if (typeof b == "string") return -1;
		if (typeof b == "object") {
			if ("start" in a && "start" in b) {
				const ap = a.start,
					bp = b.start;
				if (ap.line < bp.line) return -1;
				if (ap.line > bp.line) return 1;
				if (ap.column < bp.column) return -1;
				if (ap.column > bp.column) return 1;
			}
			if ("name" in a && "name" in b) {
				if (a.name < b.name) return -1;
				if (a.name > b.name) return 1;
			}
			if ("index" in a && "index" in b) {
				if (a.index < b.index) return -1;
				if (a.index > b.index) return 1;
			}
			return 0;
		}
		return 0;
	}
};

},
// 30
function(module, exports) {

const intersect = sets => {
	if (sets.length === 0) return new Set();
	if (sets.length === 1) return new Set(sets[0]);
	let minIndex = -1;
	for (let minSize = Infinity, i = 0; i < sets.length; i++) {
		const size = sets[i].size;
		if (size < minSize) {
			minIndex = i;
			minSize = size;
		}
	}
	const current = new Set(sets[minIndex]);
	for (let i = 0; i < sets.length; i++)
		if (i !== minIndex) {
			const set = sets[i];
			for (const item of current) set.has(item) || current.delete(item);
		}

	return current;
};

const isSubset = (bigSet, smallSet) => {
	if (bigSet.size < smallSet.size) return false;
	for (const item of smallSet) if (!bigSet.has(item)) return false;

	return true;
};

exports.intersect = intersect;
exports.isSubset = isSubset;

},
// 31
function(module, exports) {

const SizeFormatHelpers = exports;

SizeFormatHelpers.formatSize = size => {
	if (typeof size != "number" || Number.isNaN(size) === true) return "unknown size";

	if (size <= 0) return "0 bytes";

	const abbreviations = ["bytes", "KiB", "MiB", "GiB"],
		index = Math.floor(Math.log(size) / Math.log(1024));

	return `${+(size / Math.pow(1024, index)).toPrecision(3)} ${abbreviations[index]}`;
};

},
// 32
function(module, exports) {

const LogType = Object.freeze({
	error: "error",
	warn: "warn",
	info: "info",
	log: "log",
	debug: "debug",

	trace: "trace",

	group: "group",
	groupCollapsed: "groupCollapsed",
	groupEnd: "groupEnd",

	profile: "profile",
	profileEnd: "profileEnd",

	time: "time",

	clear: "clear",
	status: "status"
});

exports.LogType = LogType;

const LOG_SYMBOL = Symbol("webpack logger raw log method"),
	TIMERS_SYMBOL = Symbol("webpack logger times");

class WebpackLogger {
	constructor(log) {
		this[LOG_SYMBOL] = log;
	}

	error(...args) {
		this[LOG_SYMBOL](LogType.error, args);
	}

	warn(...args) {
		this[LOG_SYMBOL](LogType.warn, args);
	}

	info(...args) {
		this[LOG_SYMBOL](LogType.info, args);
	}

	log(...args) {
		this[LOG_SYMBOL](LogType.log, args);
	}

	debug(...args) {
		this[LOG_SYMBOL](LogType.debug, args);
	}

	assert(assertion, ...args) {
		assertion || this[LOG_SYMBOL](LogType.error, args);
	}

	trace() {
		this[LOG_SYMBOL](LogType.trace, ["Trace"]);
	}

	clear() {
		this[LOG_SYMBOL](LogType.clear);
	}

	status(...args) {
		this[LOG_SYMBOL](LogType.status, args);
	}

	group(...args) {
		this[LOG_SYMBOL](LogType.group, args);
	}

	groupCollapsed(...args) {
		this[LOG_SYMBOL](LogType.groupCollapsed, args);
	}

	groupEnd(...args) {
		this[LOG_SYMBOL](LogType.groupEnd, args);
	}

	profile(label) {
		this[LOG_SYMBOL](LogType.profile, [label]);
	}

	profileEnd(label) {
		this[LOG_SYMBOL](LogType.profileEnd, [label]);
	}

	time(label) {
		this[TIMERS_SYMBOL] = this[TIMERS_SYMBOL] || new Map();
		this[TIMERS_SYMBOL].set(label, process.hrtime());
	}

	timeLog(label) {
		const prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);
		if (!prev)
			throw new Error(`No such label '${label}' for WebpackLogger.timeLog()`);

		const time = process.hrtime(prev);
		this[LOG_SYMBOL](LogType.time, [label, ...time]);
	}

	timeEnd(label) {
		const prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);
		if (!prev)
			throw new Error(`No such label '${label}' for WebpackLogger.timeEnd()`);

		const time = process.hrtime(prev);
		this[TIMERS_SYMBOL].delete(label);
		this[LOG_SYMBOL](LogType.time, [label, ...time]);
	}
}

exports.Logger = WebpackLogger;

},
// 33
function(module, exports) {

const loaderFlag = "LOADER_EXECUTION",

	webpackOptionsFlag = "WEBPACK_OPTIONS";

exports.cutOffByFlag = (stack, flag) => {
	stack = stack.split("\n");
	for (let i = 0; i < stack.length; i++)
		if (stack[i].includes(flag)) stack.length = i;

	return stack.join("\n");
};

exports.cutOffLoaderExecution = stack =>
	exports.cutOffByFlag(stack, loaderFlag);

exports.cutOffWebpackOptions = stack =>
	exports.cutOffByFlag(stack, webpackOptionsFlag);

exports.cutOffMultilineMessage = (stack, message) => {
	stack = stack.split("\n");
	message = message.split("\n");

	return stack
		.reduce(
			(acc, line, idx) =>
				line.includes(message[idx]) ? acc : acc.concat(line),
			[]
		)
		.join("\n");
};

exports.cutOffMessage = (stack, message) => {
	const nextLine = stack.indexOf("\n");
	return nextLine < 0
		? (stack === message ? "" : stack)
		: stack.substr(0, nextLine) === message ? stack.substr(nextLine + 1) : stack;
};

exports.cleanUp = (stack, message) => {
	stack = exports.cutOffLoaderExecution(stack);
	stack = exports.cutOffMessage(stack, message);
	return stack;
};

exports.cleanUpWebpackOptions = (stack, message) => {
	stack = exports.cutOffWebpackOptions(stack);
	stack = exports.cutOffMultilineMessage(stack, message);
	return stack;
};

},
// 34
function(module) {

module.exports = require("fs");

},
// 35
function(module, exports, __webpack_require__) {

const DependenciesBlock = __webpack_require__(78);

module.exports = class extends DependenciesBlock {
	constructor(groupOptions, module, loc, request) {
		super();
		typeof groupOptions == "string"
			? (groupOptions = { name: groupOptions })
			: groupOptions || (groupOptions = { name: void 0 });

		this.groupOptions = groupOptions;
		this.chunkGroup = void 0;
		this.module = module;
		this.loc = loc;
		this.request = request;
		this.parent = void 0;
	}

	get chunkName() {
		return this.groupOptions.name;
	}

	set chunkName(value) {
		this.groupOptions.name = value;
	}

	get chunks() {
		throw new Error("Moved to AsyncDependenciesBlock.chunkGroup");
	}

	set chunks(value) {
		throw new Error("Moved to AsyncDependenciesBlock.chunkGroup");
	}

	updateHash(hash) {
		hash.update(JSON.stringify(this.groupOptions));
		hash.update(
			(this.chunkGroup &&
				this.chunkGroup.chunks
					.map(chunk => (chunk.id !== null ? chunk.id : ""))
					.join(",")) ||
				""
		);
		super.updateHash(hash);
	}

	disconnect() {
		this.chunkGroup = void 0;
		super.disconnect();
	}

	unseal() {
		this.chunkGroup = void 0;
		super.unseal();
	}

	sortItems() {
		super.sortItems();
	}
};

},
// 36
function(module, exports, __webpack_require__) {

const DependencyReference = __webpack_require__(14),
	ModuleDependency = __webpack_require__(4);

class WebAssemblyExportImportedDependency extends ModuleDependency {
	constructor(exportName, request, name, valueType) {
		super(request);
		this.exportName = exportName;
		this.name = name;
		this.valueType = valueType;
	}

	getReference() {
		return this.module ? new DependencyReference(this.module, [this.name], false) : null;
	}

	get type() {
		return "wasm export import";
	}
}

module.exports = WebAssemblyExportImportedDependency;

},
// 37
function(module, exports, __webpack_require__) {

const DependencyReference = __webpack_require__(14),
	ModuleDependency = __webpack_require__(4),
	UnsupportedWebAssemblyFeatureError = __webpack_require__(85);

class WebAssemblyImportDependency extends ModuleDependency {
	constructor(request, name, description, onlyDirectImport) {
		super(request);
		this.name = name;
		this.description = description;
		this.onlyDirectImport = onlyDirectImport;
	}

	getReference() {
		return this.module ? new DependencyReference(this.module, [this.name], false) : null;
	}

	getErrors() {
		if (
			this.onlyDirectImport &&
			this.module &&
			!this.module.type.startsWith("webassembly")
		)
			return [
				new UnsupportedWebAssemblyFeatureError(
					`Import "${this.name}" from "${this.request}" with ${this.onlyDirectImport} can only be used for direct wasm to wasm dependencies`
				)
			];
	}

	get type() {
		return "wasm import";
	}
}

module.exports = WebAssemblyImportDependency;

},
// 38
function(module, exports) {

const toErrorCode = err =>
	`var e = new Error(${JSON.stringify(err)}); e.code = 'MODULE_NOT_FOUND';`;

exports.module = request =>
	`!(function webpackMissingModule() { ${exports.moduleCode(request)} })()`;

exports.promise = request =>
	`Promise.reject((function webpackMissingModule() { ${toErrorCode(`Cannot find module '${request}'`)} return e; })())`;

exports.moduleCode = request =>
	toErrorCode(`Cannot find module '${request}'`) + " throw e;";

},
// 39
function(module) {

class ModuleDependencyTemplateAsId {
	apply(dep, source, runtime) {
		if (!dep.range) return;
		const content = runtime.moduleId({ module: dep.module, request: dep.request });
		source.replace(dep.range[0], dep.range[1] - 1, content);
	}
}
module.exports = ModuleDependencyTemplateAsId;

},
// 40
function(module, exports, __webpack_require__) {

const NullDependency = __webpack_require__(7);

class LocalModuleDependency extends NullDependency {
	constructor(localModule, range, callNew) {
		super();
		localModule.flagUsed();
		this.localModule = localModule;
		this.range = range;
		this.callNew = callNew;
	}
}

LocalModuleDependency.Template = class {
	apply(dep, source) {
		if (!dep.range) return;
		const moduleInstance = dep.callNew
			? `new (function () { return ${dep.localModule.variableName()}; })()`
			: dep.localModule.variableName();
		source.replace(dep.range[0], dep.range[1] - 1, moduleInstance);
	}
};

module.exports = LocalModuleDependency;

},
// 41
function(module, exports, __webpack_require__) {

const NullDependency = __webpack_require__(7);

class HarmonyCompatibilityDependency extends NullDependency {
	constructor(originModule) {
		super();
		this.originModule = originModule;
	}

	get type() {
		return "harmony export header";
	}
}

HarmonyCompatibilityDependency.Template = class {
	apply(dep, source, runtime) {
		const usedExports = dep.originModule.usedExports;
		if (usedExports !== false && !Array.isArray(usedExports)) {
			const content = runtime.defineEsModuleFlagStatement({
				exportsArgument: dep.originModule.exportsArgument
			});
			source.insert(-10, content);
		}
	}
};

module.exports = HarmonyCompatibilityDependency;

},
// 42
function(module, exports, __webpack_require__) {

const DependencyReference = __webpack_require__(14),
	HarmonyImportDependency = __webpack_require__(19),
	HarmonyLinkingError = __webpack_require__(103);

class HarmonyImportSpecifierDependency extends HarmonyImportDependency {
	constructor(
		request,
		originModule,
		sourceOrder,
		parserScope,
		id,
		name,
		range,
		strictExportPresence
	) {
		super(request, originModule, sourceOrder, parserScope);
		this.id = id === null ? null : "" + id;
		this.redirectedId = void 0;
		this.name = name;
		this.range = range;
		this.strictExportPresence = strictExportPresence;
		this.namespaceObjectAsContext = false;
		this.callArgs = void 0;
		this.call = void 0;
		this.directImport = void 0;
		this.shorthand = void 0;
	}

	get type() {
		return "harmony import specifier";
	}

	get _id() {
		return this.redirectedId || this.id;
	}

	getReference() {
		return !this._module ? null : new DependencyReference(
			this._module,
			this._id && !this.namespaceObjectAsContext ? [this._id] : true,
			false,
			this.sourceOrder
		);
	}

	getWarnings() {
		return this.strictExportPresence || this.originModule.buildMeta.strictHarmonyModule
			? []
			: this._getErrors();
	}

	getErrors() {
		return this.strictExportPresence || this.originModule.buildMeta.strictHarmonyModule
			? this._getErrors()
			: [];
	}

	_getErrors() {
		const importedModule = this._module;
		if (!importedModule) return;

		if (!importedModule.buildMeta || !importedModule.buildMeta.exportsType) {
			if (
				this.originModule.buildMeta.strictHarmonyModule &&
				this._id &&
				this._id !== "default"
			)
				return [
					new HarmonyLinkingError(
						`Can't import the named export '${this._id}' from non EcmaScript module (only default export is available)`
					)
				];

			return;
		}

		if (!this._id || importedModule.isProvided(this._id) !== false) return;

		const idIsNotNameMessage =
			this._id !== this.name ? ` (imported as '${this.name}')` : "";
		const errorMessage = `"export '${this._id}'${idIsNotNameMessage} was not found in '${this.userRequest}'`;
		return [new HarmonyLinkingError(errorMessage)];
	}

	getNumberOfIdOccurrences() {
		return 0;
	}

	updateHash(hash) {
		super.updateHash(hash);
		const importedModule = this._module;
		hash.update((importedModule && this._id) + "");
		hash.update(
			(importedModule && this._id && importedModule.isUsed(this._id)) + ""
		);
		hash.update(
			(importedModule &&
				(!importedModule.buildMeta || importedModule.buildMeta.exportsType)) +
				""
		);
		hash.update(
			(importedModule &&
				importedModule.used + JSON.stringify(importedModule.usedExports)) + ""
		);
	}

	disconnect() {
		super.disconnect();
		this.redirectedId = void 0;
	}
}

HarmonyImportSpecifierDependency.Template = class extends HarmonyImportDependency.Template {
	apply(dep, source, runtime) {
		super.apply(dep, source, runtime);
		const content = this.getContent(dep, runtime);
		source.replace(dep.range[0], dep.range[1] - 1, content);
	}

	getContent(dep, runtime) {
		const exportExpr = runtime.exportFromImport({
			module: dep._module,
			request: dep.request,
			exportName: dep._id,
			originModule: dep.originModule,
			asiSafe: dep.shorthand,
			isCall: dep.call,
			callContext: !dep.directImport,
			importVar: dep.getImportVar()
		});
		return dep.shorthand ? `${dep.name}: ${exportExpr}` : exportExpr;
	}
};

module.exports = HarmonyImportSpecifierDependency;

},
// 43
function(module, exports, __webpack_require__) {

const DependencyReference = __webpack_require__(14);// TODO
const HarmonyImportDependency = __webpack_require__(19);
const Template = __webpack_require__(2);
const HarmonyLinkingError = __webpack_require__(103);

const EMPTY_MAP = new Map();

class ExportMode {
	constructor(type) {
		this.type = type;
		this.name = null;
		this.map = EMPTY_MAP;
		this.ignored = null;
		this.module = null;
		this.userRequest = null;
	}
}

const EMPTY_STAR_MODE = new ExportMode("empty-star");

class HarmonyExportImportedSpecifierDependency extends HarmonyImportDependency {
	constructor(
		request,
		originModule,
		sourceOrder,
		parserScope,
		id,
		name,
		activeExports,
		otherStarExports,
		strictExportPresence
	) {
		super(request, originModule, sourceOrder, parserScope);
		this.id = id;
		this.redirectedId = void 0;
		this.name = name;
		this.activeExports = activeExports;
		this.otherStarExports = otherStarExports;
		this.strictExportPresence = strictExportPresence;
	}

	get type() {
		return "harmony export imported specifier";
	}

	get _id() {
		return this.redirectedId || this.id;
	}

	getMode(ignoreUnused) {
		const name = this.name;
		const id = this._id;
		const used = this.originModule.isUsed(name);
		const importedModule = this._module;

		if (!importedModule) {
			const mode = new ExportMode("missing");
			mode.userRequest = this.userRequest;
			return mode;
		}

		if (
			!ignoreUnused &&
			(name ? !used : this.originModule.usedExports === false)
		) {
			const mode = new ExportMode("unused");
			mode.name = name || "*";
			return mode;
		}

		const strictHarmonyModule = this.originModule.buildMeta.strictHarmonyModule;
		if (name && id === "default" && importedModule.buildMeta) {
			if (!importedModule.buildMeta.exportsType) {
				const mode = new ExportMode(
					strictHarmonyModule
						? "reexport-non-harmony-default-strict"
						: "reexport-non-harmony-default"
				);
				mode.name = name;
				mode.module = importedModule;
				return mode;
			} else if (importedModule.buildMeta.exportsType === "named") {
				const mode = new ExportMode("reexport-named-default");
				mode.name = name;
				mode.module = importedModule;
				return mode;
			}
		}

		const isNotAHarmonyModule =
			importedModule.buildMeta && !importedModule.buildMeta.exportsType;
		if (name) {
			let mode;
			if (id) {
				if (isNotAHarmonyModule && strictHarmonyModule) {
					mode = new ExportMode("rexport-non-harmony-undefined");
					mode.name = name;
				} else {
					mode = new ExportMode("safe-reexport");
					mode.map = new Map([[name, id]]);
				}
			} else {
				if (isNotAHarmonyModule && strictHarmonyModule) {
					mode = new ExportMode("reexport-fake-namespace-object");
					mode.name = name;
				} else {
					mode = new ExportMode("reexport-namespace-object");
					mode.name = name;
				}
			}
			mode.module = importedModule;
			return mode;
		}

		const hasUsedExports = Array.isArray(this.originModule.usedExports);
		const hasProvidedExports = Array.isArray(
			importedModule.buildMeta.providedExports
		);
		const activeFromOtherStarExports = this._discoverActiveExportsFromOtherStartExports();

		if (hasUsedExports) {
			if (hasProvidedExports) {
				const map = new Map(
					this.originModule.usedExports
						.filter(id => {
							if (id === "default") return false;
							if (this.activeExports.has(id)) return false;
							if (activeFromOtherStarExports.has(id)) return false;
							if (!importedModule.buildMeta.providedExports.includes(id))
								return false;
							return true;
						})
						.map(item => [item, item])
				);

				if (map.size === 0) {
					return EMPTY_STAR_MODE;
				}

				const mode = new ExportMode("safe-reexport");
				mode.module = importedModule;
				mode.map = map;
				return mode;
			}

			const map = new Map(
				this.originModule.usedExports
					.filter(id => {
						if (id === "default") return false;
						if (this.activeExports.has(id)) return false;
						if (activeFromOtherStarExports.has(id)) return false;

						return true;
					})
					.map(item => [item, item])
			);

			if (map.size === 0) {
				return EMPTY_STAR_MODE;
			}

			const mode = new ExportMode("checked-reexport");
			mode.module = importedModule;
			mode.map = map;
			return mode;
		}

		if (hasProvidedExports) {
			const map = new Map(
				importedModule.buildMeta.providedExports
					.filter(id => {
						if (id === "default") return false;
						if (this.activeExports.has(id)) return false;
						if (activeFromOtherStarExports.has(id)) return false;

						return true;
					})
					.map(item => [item, item])
			);

			if (map.size === 0) {
				return EMPTY_STAR_MODE;
			}

			const mode = new ExportMode("safe-reexport");
			mode.module = importedModule;
			mode.map = map;
			return mode;
		}

		const mode = new ExportMode("dynamic-reexport");
		mode.module = importedModule;
		mode.ignored = new Set([
			"default",
			...this.activeExports,
			...activeFromOtherStarExports
		]);
		return mode;
	}

	getReference() {
		const mode = this.getMode(false);

		switch (mode.type) {
			case "missing":
			case "unused":
			case "empty-star":
				return null;

			case "reexport-non-harmony-default":
			case "reexport-named-default":
				return new DependencyReference(
					mode.module,
					["default"],
					false,
					this.sourceOrder
				);

			case "reexport-namespace-object":
			case "reexport-non-harmony-default-strict":
			case "reexport-fake-namespace-object":
			case "rexport-non-harmony-undefined":
				return new DependencyReference(
					mode.module,
					true,
					false,
					this.sourceOrder
				);

			case "safe-reexport":
			case "checked-reexport":
				return new DependencyReference(
					mode.module,
					Array.from(mode.map.values()),
					false,
					this.sourceOrder
				);

			case "dynamic-reexport":
				return new DependencyReference(
					mode.module,
					true,
					false,
					this.sourceOrder
				);

			default:
				throw new Error(`Unknown mode ${mode.type}`);
		}
	}

	_discoverActiveExportsFromOtherStartExports() {
		if (!this.otherStarExports) return new Set();
		const result = new Set();
		for (const otherStarExport of this.otherStarExports) {
			const otherImportedModule = otherStarExport._module;
			if (
				otherImportedModule &&
				Array.isArray(otherImportedModule.buildMeta.providedExports)
			) {
				for (const exportName of otherImportedModule.buildMeta
					.providedExports) {
					result.add(exportName);
				}
			}
		}
		return result;
	}

	getExports() {
		if (this.name) {
			return {
				exports: [this.name],
				dependencies: void 0
			};
		}

		const importedModule = this._module;

		if (!importedModule) {
			return {
				exports: null,
				dependencies: void 0
			};
		}

		if (Array.isArray(importedModule.buildMeta.providedExports)) {
			const activeFromOtherStarExports = this._discoverActiveExportsFromOtherStartExports();
			return {
				exports: importedModule.buildMeta.providedExports.filter(
					id =>
						id !== "default" &&
						!activeFromOtherStarExports.has(id) &&
						!this.activeExports.has(id)
				),
				dependencies: [importedModule]
			};
		}

		if (importedModule.buildMeta.providedExports) {
			return {
				exports: true,
				dependencies: void 0
			};
		}

		return {
			exports: null,
			dependencies: [importedModule]
		};
	}

	getWarnings() {
		if (
			this.strictExportPresence ||
			this.originModule.buildMeta.strictHarmonyModule
		) {
			return [];
		}
		return this._getErrors();
	}

	getErrors() {
		if (
			this.strictExportPresence ||
			this.originModule.buildMeta.strictHarmonyModule
		) {
			return this._getErrors();
		}
		return [];
	}

	_getErrors() {
		const importedModule = this._module;
		if (!importedModule) {
			return;
		}

		if (!importedModule.buildMeta || !importedModule.buildMeta.exportsType) {
			if (
				this.originModule.buildMeta.strictHarmonyModule &&
				this._id &&
				this._id !== "default"
			) {
				return [
					new HarmonyLinkingError(
						`Can't reexport the named export '${this._id}' from non EcmaScript module (only default export is available)`
					)
				];
			}
			return;
		}

		if (!this._id) {
			return;
		}

		if (importedModule.isProvided(this._id) !== false) {
			return;
		}

		const idIsNotNameMessage =
			this._id !== this.name ? ` (reexported as '${this.name}')` : "";
		const errorMessage = `"export '${this._id}'${idIsNotNameMessage} was not found in '${this.userRequest}'`;
		return [new HarmonyLinkingError(errorMessage)];
	}

	updateHash(hash) {
		super.updateHash(hash);
		const hashValue = this.getHashValue(this._module);
		hash.update(hashValue);
	}

	getHashValue(importedModule) {
		if (!importedModule) {
			return "";
		}

		const stringifiedUsedExport = JSON.stringify(importedModule.usedExports);
		const stringifiedProvidedExport = JSON.stringify(
			importedModule.buildMeta.providedExports
		);
		return (
			importedModule.used + stringifiedUsedExport + stringifiedProvidedExport
		);
	}

	disconnect() {
		super.disconnect();
		this.redirectedId = void 0;
	}
}

module.exports = HarmonyExportImportedSpecifierDependency;

HarmonyExportImportedSpecifierDependency.Template = class extends HarmonyImportDependency.Template {
	harmonyInit(dep, source, runtime, dependencyTemplates) {
		super.harmonyInit(dep, source, runtime, dependencyTemplates);
		const content = this.getContent(dep);
		source.insert(-1, content);
	}

	getHarmonyInitOrder(dep) {
		if (dep.name) {
			const used = dep.originModule.isUsed(dep.name);
			if (!used) return NaN;
		} else {
			const importedModule = dep._module;

			const activeFromOtherStarExports = dep._discoverActiveExportsFromOtherStartExports();

			if (Array.isArray(dep.originModule.usedExports)) {
				const unused = dep.originModule.usedExports.every(id => {
					if (id === "default") return true;
					if (dep.activeExports.has(id)) return true;
					if (importedModule.isProvided(id) === false) return true;
					if (activeFromOtherStarExports.has(id)) return true;
					return false;
				});
				if (unused) return NaN;
			} else if (
				dep.originModule.usedExports &&
				importedModule &&
				Array.isArray(importedModule.buildMeta.providedExports)
			) {
				const unused = importedModule.buildMeta.providedExports.every(id => {
					if (id === "default") return true;
					if (dep.activeExports.has(id)) return true;
					if (activeFromOtherStarExports.has(id)) return true;
					return false;
				});
				if (unused) return NaN;
			}
		}
		return super.getHarmonyInitOrder(dep);
	}

	getContent(dep) {
		const mode = dep.getMode(false),
			module = dep.originModule,
			importedModule = dep._module,
			importVar = dep.getImportVar();

		switch (mode.type) {
			case "missing":
				return `throw new Error(${JSON.stringify(
					`Cannot find module '${mode.userRequest}'`
				)});\n`;

			case "unused":
				return Template.toNormalComment("unused harmony reexport " + mode.name) + "\n";

			case "reexport-non-harmony-default":
				return (
					"/* harmony reexport (default from non-harmony) */ " +
					this.getReexportStatement(
						module,
						module.isUsed(mode.name),
						importVar,
						null
					)
				);

			case "reexport-named-default":
				return (
					"/* harmony reexport (default from named exports) */ " +
					this.getReexportStatement(
						module,
						module.isUsed(mode.name),
						importVar,
						""
					)
				);

			case "reexport-fake-namespace-object":
				return (
					"/* harmony reexport (fake namespace object from non-harmony) */ " +
					this.getReexportFakeNamespaceObjectStatement(
						module,
						module.isUsed(mode.name),
						importVar
					)
				);

			case "rexport-non-harmony-undefined":
				return (
					"/* harmony reexport (non default export from non-harmony) */ " +
					this.getReexportStatement(
						module,
						module.isUsed(mode.name),
						"undefined",
						""
					)
				);

			case "reexport-non-harmony-default-strict":
				return (
					"/* harmony reexport (default from non-harmony) */ " +
					this.getReexportStatement(
						module,
						module.isUsed(mode.name),
						importVar,
						""
					)
				);

			case "reexport-namespace-object":
				return (
					"/* harmony reexport (module object) */ " +
					this.getReexportStatement(
						module,
						module.isUsed(mode.name),
						importVar,
						""
					)
				);

			case "empty-star":
				return "/* empty/unused harmony star reexport */";

			case "safe-reexport":
				return Array.from(mode.map.entries())
					.map(item => {
						return (
							"/* harmony reexport (safe) */ " +
							this.getReexportStatement(
								module,
								module.isUsed(item[0]),
								importVar,
								importedModule.isUsed(item[1])
							) +
							"\n"
						);
					})
					.join("");

			case "checked-reexport":
				return Array.from(mode.map.entries())
					.map(item => {
						return (
							"/* harmony reexport (checked) */ " +
							this.getConditionalReexportStatement(
								module,
								item[0],
								importVar,
								item[1]
							) +
							"\n"
						);
					})
					.join("");

			case "dynamic-reexport":
				const ignoredExports = mode.ignored;
				let content =
					"/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in " +
					importVar +
					") ";

				if (ignoredExports.size > 0) {
					content +=
						"if(" +
						JSON.stringify(Array.from(ignoredExports)) +
						".indexOf(__WEBPACK_IMPORT_KEY__) < 0) ";
				} else {
					content += "if(__WEBPACK_IMPORT_KEY__ !== 'default') ";
				}
				const exportsName = dep.originModule.exportsArgument;
				return (
					content +
					`(function(key) { __webpack_require__.d(${exportsName}, key, function() { return ${importVar}[key]; }) }(__WEBPACK_IMPORT_KEY__));\n`
				);

			default:
				throw new Error("Unknown mode " + mode.type);
		}
	}

	getReexportStatement(module, key, name, valueKey) {
		const exportsName = module.exportsArgument;
		const returnValue = this.getReturnValue(name, valueKey);
		return `__webpack_require__.d(${exportsName}, ${JSON.stringify(
			key
		)}, function() { return ${returnValue}; });\n`;
	}

	getReexportFakeNamespaceObjectStatement(module, key, name) {
		const exportsName = module.exportsArgument;
		return `__webpack_require__.d(${exportsName}, ${JSON.stringify(
			key
		)}, function() { return __webpack_require__.t(${name}); });\n`;
	}

	getConditionalReexportStatement(module, key, name, valueKey) {
		if (valueKey === false) {
			return "/* unused export */\n";
		}
		const exportsName = module.exportsArgument;
		const returnValue = this.getReturnValue(name, valueKey);
		return `if(__webpack_require__.o(${name}, ${JSON.stringify(
			valueKey
		)})) __webpack_require__.d(${exportsName}, ${JSON.stringify(
			key
		)}, function() { return ${returnValue}; });\n`;
	}

	getReturnValue(name, valueKey) {
		if (valueKey === null) {
			return `${name}_default.a`;
		}
		if (valueKey === "") {
			return name;
		}
		if (valueKey === false) {
			return "/* unused export */ undefined";
		}

		return `${name}[${JSON.stringify(valueKey)}]`;
	}
};

},
// 44
function(module, exports, __webpack_require__) {

const JsonpMainTemplatePlugin = __webpack_require__(257);
const JsonpChunkTemplatePlugin = __webpack_require__(259);
const JsonpHotUpdateChunkTemplatePlugin = __webpack_require__(260);

class JsonpTemplatePlugin {
	apply(compiler) {
		compiler.hooks.thisCompilation.tap("JsonpTemplatePlugin", compilation => {
			new JsonpMainTemplatePlugin().apply(compilation.mainTemplate);
			new JsonpChunkTemplatePlugin().apply(compilation.chunkTemplate);
			new JsonpHotUpdateChunkTemplatePlugin().apply(
				compilation.hotUpdateChunkTemplate
			);
		});
	}
}

module.exports = JsonpTemplatePlugin;

},
// 45
function(module, exports, __webpack_require__) {

const WasmMainTemplatePlugin = __webpack_require__(117);

class FetchCompileWasmTemplatePlugin {
	constructor(options) {
		this.options = options || {};
	}

	apply(compiler) {
		compiler.hooks.thisCompilation.tap(
			"FetchCompileWasmTemplatePlugin",
			compilation => {
				const mainTemplate = compilation.mainTemplate;
				const generateLoadBinaryCode = path =>
					`fetch(${mainTemplate.requireFn}.p + ${path})`;

				const plugin = new WasmMainTemplatePlugin(
					Object.assign(
						{
							generateLoadBinaryCode,
							supportsStreaming: true
						},
						this.options
					)
				);
				plugin.apply(mainTemplate);
			}
		);
	}
}

module.exports = FetchCompileWasmTemplatePlugin;

},
// 46
function(module, exports, __webpack_require__) {

const NodeMainTemplatePlugin = __webpack_require__(266);
const NodeChunkTemplatePlugin = __webpack_require__(269);
const NodeHotUpdateChunkTemplatePlugin = __webpack_require__(270);

class NodeTemplatePlugin {
	constructor(options) {
		options = options || {};
		this.asyncChunkLoading = options.asyncChunkLoading;
	}

	apply(compiler) {
		compiler.hooks.thisCompilation.tap("NodeTemplatePlugin", compilation => {
			new NodeMainTemplatePlugin(this.asyncChunkLoading).apply(
				compilation.mainTemplate
			);
			new NodeChunkTemplatePlugin().apply(compilation.chunkTemplate);
			new NodeHotUpdateChunkTemplatePlugin().apply(
				compilation.hotUpdateChunkTemplate
			);
		});
	}
}

module.exports = NodeTemplatePlugin;

},
// 47
function(module, exports, __webpack_require__) {

const ExternalsPlugin = __webpack_require__(21);

const builtins =
	__webpack_require__(77).builtinModules || Object.keys(process.binding("natives"));

class NodeTargetPlugin {
	apply(compiler) {
		new ExternalsPlugin("commonjs", builtins).apply(compiler);
	}
}

module.exports = NodeTargetPlugin;

},
// 48
function(module) {

module.exports = require("assert");

},
// 49
function(module, exports, __webpack_require__) {

var Syntax, VisitorKeys;

Syntax = {
	AssignmentExpression: 'AssignmentExpression',
	AssignmentPattern: 'AssignmentPattern',
	ArrayExpression: 'ArrayExpression',
	ArrayPattern: 'ArrayPattern',
	ArrowFunctionExpression: 'ArrowFunctionExpression',
	AwaitExpression: 'AwaitExpression',
	BlockStatement: 'BlockStatement',
	BinaryExpression: 'BinaryExpression',
	BreakStatement: 'BreakStatement',
	CallExpression: 'CallExpression',
	CatchClause: 'CatchClause',
	ClassBody: 'ClassBody',
	ClassDeclaration: 'ClassDeclaration',
	ClassExpression: 'ClassExpression',
	ComprehensionBlock: 'ComprehensionBlock',
	ComprehensionExpression: 'ComprehensionExpression',
	ConditionalExpression: 'ConditionalExpression',
	ContinueStatement: 'ContinueStatement',
	DebuggerStatement: 'DebuggerStatement',
	DirectiveStatement: 'DirectiveStatement',
	DoWhileStatement: 'DoWhileStatement',
	EmptyStatement: 'EmptyStatement',
	ExportAllDeclaration: 'ExportAllDeclaration',
	ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	ExportNamedDeclaration: 'ExportNamedDeclaration',
	ExportSpecifier: 'ExportSpecifier',
	ExpressionStatement: 'ExpressionStatement',
	ForStatement: 'ForStatement',
	ForInStatement: 'ForInStatement',
	ForOfStatement: 'ForOfStatement',
	FunctionDeclaration: 'FunctionDeclaration',
	FunctionExpression: 'FunctionExpression',
	GeneratorExpression: 'GeneratorExpression',
	Identifier: 'Identifier',
	IfStatement: 'IfStatement',
	ImportExpression: 'ImportExpression',
	ImportDeclaration: 'ImportDeclaration',
	ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	ImportSpecifier: 'ImportSpecifier',
	Literal: 'Literal',
	LabeledStatement: 'LabeledStatement',
	LogicalExpression: 'LogicalExpression',
	MemberExpression: 'MemberExpression',
	MetaProperty: 'MetaProperty',
	MethodDefinition: 'MethodDefinition',
	ModuleSpecifier: 'ModuleSpecifier',
	NewExpression: 'NewExpression',
	ObjectExpression: 'ObjectExpression',
	ObjectPattern: 'ObjectPattern',
	Program: 'Program',
	Property: 'Property',
	RestElement: 'RestElement',
	ReturnStatement: 'ReturnStatement',
	SequenceExpression: 'SequenceExpression',
	SpreadElement: 'SpreadElement',
	Super: 'Super',
	SwitchStatement: 'SwitchStatement',
	SwitchCase: 'SwitchCase',
	TaggedTemplateExpression: 'TaggedTemplateExpression',
	TemplateElement: 'TemplateElement',
	TemplateLiteral: 'TemplateLiteral',
	ThisExpression: 'ThisExpression',
	ThrowStatement: 'ThrowStatement',
	TryStatement: 'TryStatement',
	UnaryExpression: 'UnaryExpression',
	UpdateExpression: 'UpdateExpression',
	VariableDeclaration: 'VariableDeclaration',
	VariableDeclarator: 'VariableDeclarator',
	WhileStatement: 'WhileStatement',
	WithStatement: 'WithStatement',
	YieldExpression: 'YieldExpression'
};

VisitorKeys = {
	AssignmentExpression: ['left', 'right'],
	AssignmentPattern: ['left', 'right'],
	ArrayExpression: ['elements'],
	ArrayPattern: ['elements'],
	ArrowFunctionExpression: ['params', 'body'],
	AwaitExpression: ['argument'],
	BlockStatement: ['body'],
	BinaryExpression: ['left', 'right'],
	BreakStatement: ['label'],
	CallExpression: ['callee', 'arguments'],
	CatchClause: ['param', 'body'],
	ClassBody: ['body'],
	ClassDeclaration: ['id', 'superClass', 'body'],
	ClassExpression: ['id', 'superClass', 'body'],
	ComprehensionBlock: ['left', 'right'],
	ComprehensionExpression: ['blocks', 'filter', 'body'],
	ConditionalExpression: ['test', 'consequent', 'alternate'],
	ContinueStatement: ['label'],
	DebuggerStatement: [],
	DirectiveStatement: [],
	DoWhileStatement: ['body', 'test'],
	EmptyStatement: [],
	ExportAllDeclaration: ['source'],
	ExportDefaultDeclaration: ['declaration'],
	ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
	ExportSpecifier: ['exported', 'local'],
	ExpressionStatement: ['expression'],
	ForStatement: ['init', 'test', 'update', 'body'],
	ForInStatement: ['left', 'right', 'body'],
	ForOfStatement: ['left', 'right', 'body'],
	FunctionDeclaration: ['id', 'params', 'body'],
	FunctionExpression: ['id', 'params', 'body'],
	GeneratorExpression: ['blocks', 'filter', 'body'],
	Identifier: [],
	IfStatement: ['test', 'consequent', 'alternate'],
	ImportExpression: ['source'],
	ImportDeclaration: ['specifiers', 'source'],
	ImportDefaultSpecifier: ['local'],
	ImportNamespaceSpecifier: ['local'],
	ImportSpecifier: ['imported', 'local'],
	Literal: [],
	LabeledStatement: ['label', 'body'],
	LogicalExpression: ['left', 'right'],
	MemberExpression: ['object', 'property'],
	MetaProperty: ['meta', 'property'],
	MethodDefinition: ['key', 'value'],
	ModuleSpecifier: [],
	NewExpression: ['callee', 'arguments'],
	ObjectExpression: ['properties'],
	ObjectPattern: ['properties'],
	Program: ['body'],
	Property: ['key', 'value'],
	RestElement: [ 'argument' ],
	ReturnStatement: ['argument'],
	SequenceExpression: ['expressions'],
	SpreadElement: ['argument'],
	Super: [],
	SwitchStatement: ['discriminant', 'cases'],
	SwitchCase: ['test', 'consequent'],
	TaggedTemplateExpression: ['tag', 'quasi'],
	TemplateElement: [],
	TemplateLiteral: ['quasis', 'expressions'],
	ThisExpression: [],
	ThrowStatement: ['argument'],
	TryStatement: ['block', 'handler', 'finalizer'],
	UnaryExpression: ['argument'],
	UpdateExpression: ['argument'],
	VariableDeclaration: ['declarations'],
	VariableDeclarator: ['id', 'init'],
	WhileStatement: ['test', 'body'],
	WithStatement: ['object', 'body'],
	YieldExpression: ['argument']
};

exports.version = __webpack_require__(295).version;
exports.Syntax = Syntax;
exports.VisitorKeys = VisitorKeys;

},
// 50
function(module) {

class Variable {
	constructor(name, scope) {
		this.name = name;

		this.identifiers = [];
		this.references = [];
		this.defs = [];

		this.tainted = false;
		this.stack = true;

		this.scope = scope;
	}
}

Variable.CatchClause = "CatchClause";
Variable.Parameter = "Parameter";
Variable.FunctionName = "FunctionName";
Variable.ClassName = "ClassName";
Variable.Variable = "Variable";
Variable.ImportBinding = "ImportBinding";
Variable.ImplicitGlobalVariable = "ImplicitGlobalVariable";

module.exports = Variable;

},
// 51
function(module) {

module.exports = parseJson
function parseJson(txt, reviver, context) {
	context = context || 20
	try {
		return JSON.parse(txt, reviver)
	} catch (e) {
		if (typeof txt != 'string') {
			const isEmptyArray = Array.isArray(txt) && txt.length === 0,
				errorMessage = 'Cannot parse ' + (isEmptyArray ? 'an empty array' : String(txt))
			throw new TypeError(errorMessage)
		}
		const syntaxErr = e.message.match(/^Unexpected token.*position\s+(\d+)/i)
		const errIdx = syntaxErr
			? +syntaxErr[1]
			: e.message.match(/^Unexpected end of JSON.*/i)
			? txt.length - 1
			: null
		if (errIdx != null) {
			const start = errIdx <= context ? 0 : errIdx - context,
				end = errIdx + context >= txt.length ? txt.length : errIdx + context
			e.message += ` while parsing near '${start === 0 ? '' : '...'}${txt.slice(start, end)}${
				end === txt.length ? '' : '...'
			}'`
		} else e.message += ` while parsing '${txt.slice(0, context * 2)}'`

		throw e
	}
}

},
// 52
function(module, exports, __webpack_require__) {

const path = __webpack_require__(3);
const NORMALIZE_SLASH_DIRECTION_REGEXP = /\\/g;
const PATH_CHARS_REGEXP = /[-[\]{}()*+?.,\\^$|#\s]/g;
const SEPARATOR_REGEXP = /[/\\]$/;
const FRONT_OR_BACK_BANG_REGEXP = /^!|!$/g;
const INDEX_JS_REGEXP = /\/index.js(!|\?|\(query\))/g;
const MATCH_RESOURCE_REGEXP = /!=!/;

const normalizeBackSlashDirection = request => {
	return request.replace(NORMALIZE_SLASH_DIRECTION_REGEXP, "/");
};

const createRegExpForPath = path => {
	const regexpTypePartial = path.replace(PATH_CHARS_REGEXP, "\\$&");
	return new RegExp(`(^|!)${regexpTypePartial}`, "g");
};

class RequestShortener {
	constructor(directory) {
		directory = normalizeBackSlashDirection(directory);
		if (SEPARATOR_REGEXP.test(directory)) {
			directory = directory.substr(0, directory.length - 1);
		}

		if (directory) {
			this.currentDirectoryRegExp = createRegExpForPath(directory);
		}

		const dirname = path.dirname(directory);
		const endsWithSeparator = SEPARATOR_REGEXP.test(dirname);
		const parentDirectory = endsWithSeparator
			? dirname.substr(0, dirname.length - 1)
			: dirname;
		if (parentDirectory && parentDirectory !== directory) {
			this.parentDirectoryRegExp = createRegExpForPath(`${parentDirectory}/`);
		}

		if (__dirname.length >= 2) {
			const buildins = normalizeBackSlashDirection(path.join(__dirname, ".."));
			const buildinsAsModule =
				this.currentDirectoryRegExp &&
				this.currentDirectoryRegExp.test(buildins);
			this.buildinsAsModule = buildinsAsModule;
			this.buildinsRegExp = createRegExpForPath(buildins);
		}

		this.cache = new Map();
	}

	shorten(request) {
		if (!request) return request;
		const cacheEntry = this.cache.get(request);
		if (cacheEntry !== void 0) {
			return cacheEntry;
		}
		let result = normalizeBackSlashDirection(request);
		if (this.buildinsAsModule && this.buildinsRegExp) {
			result = result.replace(this.buildinsRegExp, "!(webpack)");
		}
		if (this.currentDirectoryRegExp) {
			result = result.replace(this.currentDirectoryRegExp, "!.");
		}
		if (this.parentDirectoryRegExp) {
			result = result.replace(this.parentDirectoryRegExp, "!../");
		}
		if (!this.buildinsAsModule && this.buildinsRegExp) {
			result = result.replace(this.buildinsRegExp, "!(webpack)");
		}
		result = result.replace(INDEX_JS_REGEXP, "$1");
		result = result.replace(FRONT_OR_BACK_BANG_REGEXP, "");
		result = result.replace(MATCH_RESOURCE_REGEXP, " = ");
		this.cache.set(request, result);
		return result;
	}
}

module.exports = RequestShortener;

},
// 53
function(module) {

module.exports = { name: "webpack", version: "4.46.0", license: "MIT" };

},
// 54
function(module, exports, __webpack_require__) {

const NativeModule = __webpack_require__(77);

const {
	CachedSource,
	LineToLineMappedSource,
	OriginalSource,
	RawSource,
	SourceMapSource
} = __webpack_require__(0);
const { getContext, runLoaders } = __webpack_require__(171);

const WebpackError = __webpack_require__(1);
const Module = __webpack_require__(16);
const ModuleParseError = __webpack_require__(176);
const ModuleBuildError = __webpack_require__(177);
const ModuleError = __webpack_require__(178);
const ModuleWarning = __webpack_require__(179);
const createHash = __webpack_require__(15);
const contextify = __webpack_require__(13).contextify;

const asString = buf => {
	if (Buffer.isBuffer(buf)) {
		return buf.toString("utf-8");
	}
	return buf;
};

const asBuffer = str => {
	if (!Buffer.isBuffer(str)) {
		return Buffer.from(str, "utf-8");
	}
	return str;
};

class NonErrorEmittedError extends WebpackError {
	constructor(error) {
		super();

		this.name = "NonErrorEmittedError";
		this.message = "(Emitted value instead of an instance of Error) " + error;

		Error.captureStackTrace(this, this.constructor);
	}
}

class NormalModule extends Module {
	constructor({
		type,
		request,
		userRequest,
		rawRequest,
		loaders,
		resource,
		matchResource,
		parser,
		generator,
		resolveOptions
	}) {
		super(type, getContext(resource));

		this.request = request;
		this.userRequest = userRequest;
		this.rawRequest = rawRequest;
		this.binary = type.startsWith("webassembly");
		this.parser = parser;
		this.generator = generator;
		this.resource = resource;
		this.matchResource = matchResource;
		this.loaders = loaders;
		if (resolveOptions !== void 0) this.resolveOptions = resolveOptions;

		this.error = null;
		this._source = null;
		this._sourceSize = null;
		this._buildHash = "";
		this.buildTimestamp = void 0;
		this._cachedSources = new Map();

		this.useSourceMap = false;
		this.lineToLine = false;

		this._lastSuccessfulBuildMeta = {};
	}

	identifier() {
		return this.request;
	}

	readableIdentifier(requestShortener) {
		return requestShortener.shorten(this.userRequest);
	}

	libIdent(options) {
		return contextify(options.context, this.userRequest);
	}

	nameForCondition() {
		const resource = this.matchResource || this.resource;
		const idx = resource.indexOf("?");
		if (idx >= 0) return resource.substr(0, idx);
		return resource;
	}

	updateCacheModule(module) {
		this.type = module.type;
		this.request = module.request;
		this.userRequest = module.userRequest;
		this.rawRequest = module.rawRequest;
		this.parser = module.parser;
		this.generator = module.generator;
		this.resource = module.resource;
		this.matchResource = module.matchResource;
		this.loaders = module.loaders;
		this.resolveOptions = module.resolveOptions;
	}

	createSourceForAsset(name, content, sourceMap) {
		if (!sourceMap) {
			return new RawSource(content);
		}

		if (typeof sourceMap == "string") {
			return new OriginalSource(content, sourceMap);
		}

		return new SourceMapSource(content, name, sourceMap);
	}

	createLoaderContext(resolver, options, compilation, fs) {
		const requestShortener = compilation.runtimeTemplate.requestShortener;
		const getCurrentLoaderName = () => {
			const currentLoader = this.getCurrentLoader(loaderContext);
			if (!currentLoader) return "(not in loader scope)";
			return requestShortener.shorten(currentLoader.loader);
		};
		const loaderContext = {
			version: 2,
			emitWarning: warning => {
				if (!(warning instanceof Error)) {
					warning = new NonErrorEmittedError(warning);
				}
				this.warnings.push(
					new ModuleWarning(this, warning, {
						from: getCurrentLoaderName()
					})
				);
			},
			emitError: error => {
				if (!(error instanceof Error)) {
					error = new NonErrorEmittedError(error);
				}
				this.errors.push(
					new ModuleError(this, error, {
						from: getCurrentLoaderName()
					})
				);
			},
			getLogger: name => {
				const currentLoader = this.getCurrentLoader(loaderContext);
				return compilation.getLogger(() =>
					[currentLoader && currentLoader.loader, name, this.identifier()]
						.filter(Boolean)
						.join("|")
				);
			},
			exec: (code, filename) => {
				const module = new NativeModule(filename, this);
				module.paths = NativeModule._nodeModulePaths(this.context);
				module.filename = filename;
				module._compile(code, filename);
				return module.exports;
			},
			resolve(context, request, callback) {
				resolver.resolve({}, context, request, {}, callback);
			},
			getResolve(options) {
				const child = options ? resolver.withOptions(options) : resolver;
				return (context, request, callback) => {
					if (callback) {
						child.resolve({}, context, request, {}, callback);
					} else {
						return new Promise((resolve, reject) => {
							child.resolve({}, context, request, {}, (err, result) => {
								if (err) reject(err);
								else resolve(result);
							});
						});
					}
				};
			},
			emitFile: (name, content, sourceMap, assetInfo) => {
				if (!this.buildInfo.assets) {
					this.buildInfo.assets = Object.create(null);
					this.buildInfo.assetsInfo = new Map();
				}
				this.buildInfo.assets[name] = this.createSourceForAsset(
					name,
					content,
					sourceMap
				);
				this.buildInfo.assetsInfo.set(name, assetInfo);
			},
			rootContext: options.context,
			webpack: true,
			sourceMap: !!this.useSourceMap,
			mode: options.mode || "production",
			_module: this,
			_compilation: compilation,
			_compiler: compilation.compiler,
			fs: fs
		};

		compilation.hooks.normalModuleLoader.call(loaderContext, this);
		if (options.loader) {
			Object.assign(loaderContext, options.loader);
		}

		return loaderContext;
	}

	getCurrentLoader(loaderContext, index = loaderContext.loaderIndex) {
		if (
			this.loaders &&
			this.loaders.length &&
			index < this.loaders.length &&
			index >= 0 &&
			this.loaders[index]
		) {
			return this.loaders[index];
		}
		return null;
	}

	createSource(source, resourceBuffer, sourceMap) {
		if (!this.identifier) {
			return new RawSource(source);
		}

		const identifier = this.identifier();

		if (this.lineToLine && resourceBuffer) {
			return new LineToLineMappedSource(
				source,
				identifier,
				asString(resourceBuffer)
			);
		}

		if (this.useSourceMap && sourceMap) {
			return new SourceMapSource(source, identifier, sourceMap);
		}

		if (Buffer.isBuffer(source)) {
			return new RawSource(source);
		}

		return new OriginalSource(source, identifier);
	}

	doBuild(options, compilation, resolver, fs, callback) {
		const loaderContext = this.createLoaderContext(
			resolver,
			options,
			compilation,
			fs
		);

		runLoaders(
			{
				resource: this.resource,
				loaders: this.loaders,
				context: loaderContext,
				readResource: fs.readFile.bind(fs)
			},
			(err, result) => {
				if (result) {
					this.buildInfo.cacheable = result.cacheable;
					this.buildInfo.fileDependencies = new Set(result.fileDependencies);
					this.buildInfo.contextDependencies = new Set(
						result.contextDependencies
					);
				}

				if (err) {
					if (!(err instanceof Error)) {
						err = new NonErrorEmittedError(err);
					}
					const currentLoader = this.getCurrentLoader(loaderContext);
					const error = new ModuleBuildError(this, err, {
						from:
							currentLoader &&
							compilation.runtimeTemplate.requestShortener.shorten(
								currentLoader.loader
							)
					});
					return callback(error);
				}

				const resourceBuffer = result.resourceBuffer;
				const source = result.result[0];
				const sourceMap = result.result.length >= 1 ? result.result[1] : null;
				const extraInfo = result.result.length >= 2 ? result.result[2] : null;

				if (!Buffer.isBuffer(source) && typeof source != "string") {
					const currentLoader = this.getCurrentLoader(loaderContext, 0);
					const err = new Error(
						`Final loader (${
							currentLoader
								? compilation.runtimeTemplate.requestShortener.shorten(
										currentLoader.loader
									)
								: "unknown"
						}) didn't return a Buffer or String`
					);
					const error = new ModuleBuildError(this, err);
					return callback(error);
				}

				this._source = this.createSource(
					this.binary ? asBuffer(source) : asString(source),
					resourceBuffer,
					sourceMap
				);
				this._sourceSize = null;
				this._ast =
					typeof extraInfo == "object" &&
					extraInfo !== null &&
					extraInfo.webpackAST !== void 0
						? extraInfo.webpackAST
						: null;
				return callback();
			}
		);
	}

	markModuleAsErrored(error) {
		this.buildMeta = Object.assign({}, this._lastSuccessfulBuildMeta);
		this.error = error;
		this.errors.push(this.error);
		this._source = new RawSource(
			"throw new Error(" + JSON.stringify(this.error.message) + ");"
		);
		this._sourceSize = null;
		this._ast = null;
	}

	applyNoParseRule(rule, content) {
		if (typeof rule == "string") {
			return content.indexOf(rule) === 0;
		}

		if (typeof rule == "function") {
			return rule(content);
		}
		return rule.test(content);
	}

	shouldPreventParsing(noParseRule, request) {
		if (!noParseRule) {
			return false;
		}

		if (!Array.isArray(noParseRule)) {
			return this.applyNoParseRule(noParseRule, request);
		}

		for (let i = 0; i < noParseRule.length; i++) {
			const rule = noParseRule[i];
			if (this.applyNoParseRule(rule, request)) {
				return true;
			}
		}
		return false;
	}

	_initBuildHash(compilation) {
		const hash = createHash(compilation.outputOptions.hashFunction);
		if (this._source) {
			hash.update("source");
			this._source.updateHash(hash);
		}
		hash.update("meta");
		hash.update(JSON.stringify(this.buildMeta));
		this._buildHash = (hash.digest("hex"));
	}

	build(options, compilation, resolver, fs, callback) {
		this.buildTimestamp = Date.now();
		this.built = true;
		this._source = null;
		this._sourceSize = null;
		this._ast = null;
		this._buildHash = "";
		this.error = null;
		this.errors.length = 0;
		this.warnings.length = 0;
		this.buildMeta = {};
		this.buildInfo = {
			cacheable: false,
			fileDependencies: new Set(),
			contextDependencies: new Set(),
			assets: void 0,
			assetsInfo: void 0
		};

		return this.doBuild(options, compilation, resolver, fs, err => {
			this._cachedSources.clear();

			if (err) {
				this.markModuleAsErrored(err);
				this._initBuildHash(compilation);
				return callback();
			}

			const noParseRule = options.module && options.module.noParse;
			if (this.shouldPreventParsing(noParseRule, this.request)) {
				this._initBuildHash(compilation);
				return callback();
			}

			const handleParseError = e => {
				const source = this._source.source();
				const loaders = this.loaders.map(item =>
					contextify(options.context, item.loader)
				);
				const error = new ModuleParseError(this, source, e, loaders);
				this.markModuleAsErrored(error);
				this._initBuildHash(compilation);
				return callback();
			};

			const handleParseResult = result => {
				this._lastSuccessfulBuildMeta = this.buildMeta;
				this._initBuildHash(compilation);
				return callback();
			};

			try {
				const result = this.parser.parse(
					this._ast || this._source.source(),
					{
						current: this,
						module: this,
						compilation: compilation,
						options: options
					},
					(err, result) => {
						if (err) {
							handleParseError(err);
						} else {
							handleParseResult(result);
						}
					}
				);
				if (result !== void 0) {
					handleParseResult(result);
				}
			} catch (e) {
				handleParseError(e);
			}
		});
	}

	getHashDigest(dependencyTemplates) {
		let dtHash = dependencyTemplates.get("hash");
		return `${this.hash}-${dtHash}`;
	}

	source(dependencyTemplates, runtimeTemplate, type = "javascript") {
		const hashDigest = this.getHashDigest(dependencyTemplates);
		const cacheEntry = this._cachedSources.get(type);
		if (cacheEntry !== void 0 && cacheEntry.hash === hashDigest) {
			return cacheEntry.source;
		}

		const source = this.generator.generate(
			this,
			dependencyTemplates,
			runtimeTemplate,
			type
		);

		const cachedSource = new CachedSource(source);
		this._cachedSources.set(type, {
			source: cachedSource,
			hash: hashDigest
		});
		return cachedSource;
	}

	originalSource() {
		return this._source;
	}

	needRebuild(fileTimestamps, contextTimestamps) {
		if (this.error) return true;

		if (!this.buildInfo.cacheable) return true;

		for (const file of this.buildInfo.fileDependencies) {
			const timestamp = fileTimestamps.get(file);
			if (!timestamp) return true;
			if (timestamp >= this.buildTimestamp) return true;
		}
		for (const file of this.buildInfo.contextDependencies) {
			const timestamp = contextTimestamps.get(file);
			if (!timestamp) return true;
			if (timestamp >= this.buildTimestamp) return true;
		}
		return false;
	}

	size() {
		if (this._sourceSize === null) {
			this._sourceSize = this._source ? this._source.size() : -1;
		}
		return this._sourceSize;
	}

	updateHash(hash) {
		hash.update(this._buildHash);
		super.updateHash(hash);
	}
}

module.exports = NormalModule;

},
// 55
function(module, exports, __webpack_require__) {

const mergeCache = new WeakMap();

const cachedCleverMerge = (first, second) => {
	let innerCache = mergeCache.get(first);
	if (innerCache === void 0) {
		innerCache = new WeakMap();
		mergeCache.set(first, innerCache);
	}
	const prevMerge = innerCache.get(second);
	if (prevMerge !== void 0) return prevMerge;
	const newMerge = cleverMerge(first, second);
	innerCache.set(second, newMerge);
	return newMerge;
};

const cleverMerge = (first, second) => {
	const newObject = Object.assign({}, first);
	for (const key of Object.keys(second)) {
		if (!(key in newObject)) {
			newObject[key] = second[key];
			continue;
		}
		const secondValue = second[key];
		if (!Array.isArray(secondValue)) {
			newObject[key] = secondValue;
			continue;
		}
		const firstValue = newObject[key];
		if (Array.isArray(firstValue)) {
			const newArray = [];
			for (const item of secondValue) {
				if (item === "...") {
					for (const item of firstValue) {
						newArray.push(item);
					}
				} else {
					newArray.push(item);
				}
			}
			newObject[key] = newArray;
		} else {
			newObject[key] = secondValue;
		}
	}
	return newObject;
};

exports.cachedCleverMerge = cachedCleverMerge;
exports.cleverMerge = cleverMerge;

},
// 56
function(module, exports, __webpack_require__) {

const ModuleDependency = __webpack_require__(4);

class ContextElementDependency extends ModuleDependency {
	constructor(request, userRequest) {
		super(request);
		if (userRequest) {
			this.userRequest = userRequest;
		}
	}

	get type() {
		return "context element";
	}
}

module.exports = ContextElementDependency;

},
// 57
function(module, exports, __webpack_require__) {

const TypeUnknown = 0;
const TypeNull = 1;
const TypeString = 2;
const TypeNumber = 3;
const TypeBoolean = 4;
const TypeRegExp = 5;
const TypeConditional = 6;
const TypeArray = 7;
const TypeConstArray = 8;
const TypeIdentifier = 9;
const TypeWrapped = 10;
const TypeTemplateString = 11;

class BasicEvaluatedExpression {
	constructor() {
		this.type = TypeUnknown;
		this.range = null;
		this.falsy = false;
		this.truthy = false;
		this.bool = null;
		this.number = null;
		this.regExp = null;
		this.string = null;
		this.quasis = null;
		this.parts = null;
		this.array = null;
		this.items = null;
		this.options = null;
		this.prefix = null;
		this.postfix = null;
		this.wrappedInnerExpressions = null;
		this.expression = null;
	}

	isNull() {
		return this.type === TypeNull;
	}

	isString() {
		return this.type === TypeString;
	}

	isNumber() {
		return this.type === TypeNumber;
	}

	isBoolean() {
		return this.type === TypeBoolean;
	}

	isRegExp() {
		return this.type === TypeRegExp;
	}

	isConditional() {
		return this.type === TypeConditional;
	}

	isArray() {
		return this.type === TypeArray;
	}

	isConstArray() {
		return this.type === TypeConstArray;
	}

	isIdentifier() {
		return this.type === TypeIdentifier;
	}

	isWrapped() {
		return this.type === TypeWrapped;
	}

	isTemplateString() {
		return this.type === TypeTemplateString;
	}

	isTruthy() {
		return this.truthy;
	}

	isFalsy() {
		return this.falsy;
	}

	asBool() {
		if (this.truthy) return true;
		if (this.falsy) return false;
		if (this.isBoolean()) return this.bool;
		if (this.isNull()) return false;
		if (this.isString()) return this.string !== "";
		if (this.isNumber()) return this.number !== 0;
		if (this.isRegExp()) return true;
		if (this.isArray()) return true;
		if (this.isConstArray()) return true;
		if (this.isWrapped()) {
			return (this.prefix && this.prefix.asBool()) ||
				(this.postfix && this.postfix.asBool())
				? true
				: void 0;
		}
		if (this.isTemplateString()) {
			const str = this.asString();
			if (typeof str == "string") return str !== "";
		}
		return void 0;
	}

	asString() {
		if (this.isBoolean()) return `${this.bool}`;
		if (this.isNull()) return "null";
		if (this.isString()) return this.string;
		if (this.isNumber()) return `${this.number}`;
		if (this.isRegExp()) return `${this.regExp}`;
		if (this.isArray()) {
			let array = [];
			for (const item of this.items) {
				const itemStr = item.asString();
				if (itemStr === void 0) return void 0;
				array.push(itemStr);
			}
			return `${array}`;
		}
		if (this.isConstArray()) return `${this.array}`;
		if (this.isTemplateString()) {
			let str = "";
			for (const part of this.parts) {
				const partStr = part.asString();
				if (partStr === void 0) return void 0;
				str += partStr;
			}
			return str;
		}
		return void 0;
	}

	setString(string) {
		this.type = TypeString;
		this.string = string;
		return this;
	}

	setNull() {
		this.type = TypeNull;
		return this;
	}

	setNumber(number) {
		this.type = TypeNumber;
		this.number = number;
		return this;
	}

	setBoolean(bool) {
		this.type = TypeBoolean;
		this.bool = bool;
		return this;
	}

	setRegExp(regExp) {
		this.type = TypeRegExp;
		this.regExp = regExp;
		return this;
	}

	setIdentifier(identifier) {
		this.type = TypeIdentifier;
		this.identifier = identifier;
		return this;
	}

	setWrapped(prefix, postfix, innerExpressions) {
		this.type = TypeWrapped;
		this.prefix = prefix;
		this.postfix = postfix;
		this.wrappedInnerExpressions = innerExpressions;
		return this;
	}

	setOptions(options) {
		this.type = TypeConditional;
		this.options = options;
		return this;
	}

	addOptions(options) {
		if (!this.options) {
			this.type = TypeConditional;
			this.options = [];
		}
		for (const item of options) {
			this.options.push(item);
		}
		return this;
	}

	setItems(items) {
		this.type = TypeArray;
		this.items = items;
		return this;
	}

	setArray(array) {
		this.type = TypeConstArray;
		this.array = array;
		return this;
	}

	setTemplateString(quasis, parts, kind) {
		this.type = TypeTemplateString;
		this.quasis = quasis;
		this.parts = parts;
		this.templateStringKind = kind;
		return this;
	}

	setTruthy() {
		this.falsy = false;
		this.truthy = true;
		return this;
	}

	setFalsy() {
		this.falsy = true;
		this.truthy = false;
		return this;
	}

	setRange(range) {
		this.range = range;
		return this;
	}

	setExpression(expression) {
		this.expression = expression;
		return this;
	}
}

module.exports = BasicEvaluatedExpression;

},
// 58
function(module, exports, __webpack_require__) {

class Generator {
	static byType(map) {
		return new ByTypeGenerator(map);
	}

	generate(module, dependencyTemplates, runtimeTemplate, type) {
		throw new Error("Generator.generate: must be overridden");
	}
}

class ByTypeGenerator extends Generator {
	constructor(map) {
		super();
		this.map = map;
	}

	generate(module, dependencyTemplates, runtimeTemplate, type) {
		const generator = this.map[type];
		if (!generator) {
			throw new Error(`Generator.byType: no generator specified for ${type}`);
		}
		return generator.generate(
			module,
			dependencyTemplates,
			runtimeTemplate,
			type
		);
	}
}

module.exports = Generator;

},
// 59
function(module) {

module.exports = require("../vendor/wasm-ast");

},
// 60
function(module, exports, __webpack_require__) {

const path = __webpack_require__(3);
const { ConcatSource, RawSource } = __webpack_require__(0);
const ModuleFilenameHelpers = __webpack_require__(18);
const SourceMapDevToolModuleOptionsPlugin = __webpack_require__(91);
const createHash = __webpack_require__(15);
const { absolutify } = __webpack_require__(13);

const validateOptions = __webpack_require__(8);
const schema = __webpack_require__(218);

const basename = name => {
	if (!name.includes("/")) return name;
	return name.substr(name.lastIndexOf("/") + 1);
};

const assetsCache = new WeakMap();

const getTaskForFile = (file, asset, chunk, options, compilation) => {
	let source, sourceMap;
	if (asset.sourceAndMap) {
		const sourceAndMap = asset.sourceAndMap(options);
		sourceMap = sourceAndMap.map;
		source = sourceAndMap.source;
	} else {
		sourceMap = asset.map(options);
		source = asset.source();
	}
	if (!sourceMap || typeof source != "string") return;
	const context = compilation.options.context;
	const modules = sourceMap.sources.map(source => {
		if (source.startsWith("webpack://")) {
			source = absolutify(context, source.slice(10));
		}
		const module = compilation.findModule(source);
		return module || source;
	});

	return {
		chunk,
		file,
		asset,
		source,
		sourceMap,
		modules
	};
};

class SourceMapDevToolPlugin {
	constructor(options) {
		if (arguments.length > 1) {
			throw new Error(
				"SourceMapDevToolPlugin only takes one argument (pass an options object)"
			);
		}

		if (!options) options = {};

		validateOptions(schema, options, "SourceMap DevTool Plugin");

		this.sourceMapFilename = options.filename;
		this.sourceMappingURLComment =
			options.append === false
				? false
				: options.append || "\n//# sourceMappingURL=[url]";
		this.moduleFilenameTemplate =
			options.moduleFilenameTemplate || "webpack://[namespace]/[resourcePath]";
		this.fallbackModuleFilenameTemplate =
			options.fallbackModuleFilenameTemplate ||
			"webpack://[namespace]/[resourcePath]?[hash]";
		this.namespace = options.namespace || "";
		this.options = options;
	}

	apply(compiler) {
		const sourceMapFilename = this.sourceMapFilename;
		const sourceMappingURLComment = this.sourceMappingURLComment;
		const moduleFilenameTemplate = this.moduleFilenameTemplate;
		const namespace = this.namespace;
		const fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;
		const requestShortener = compiler.requestShortener;
		const options = this.options;
		options.test = options.test || /\.(m?js|css)($|\?)/i;

		const matchObject = ModuleFilenameHelpers.matchObject.bind(
			void 0,
			options
		);

		compiler.hooks.compilation.tap("SourceMapDevToolPlugin", compilation => {
			new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);

			compilation.hooks.afterOptimizeChunkAssets.tap(
				({ name: "SourceMapDevToolPlugin", context: true }),
				(context, chunks) => {
					const moduleToSourceNameMapping = new Map();
					const reportProgress =
						context && context.reportProgress
							? context.reportProgress
							: () => {};

					const files = [];
					for (const chunk of chunks) {
						for (const file of chunk.files) {
							if (matchObject(file)) {
								files.push({
									file,
									chunk
								});
							}
						}
					}

					reportProgress(0.0);
					const tasks = [];
					files.forEach(({ file, chunk }, idx) => {
						const asset = compilation.getAsset(file).source;
						const cache = assetsCache.get(asset);
						if (cache && cache.file === file) {
							for (const cachedFile in cache.assets) {
								if (cachedFile === file) {
									compilation.updateAsset(cachedFile, cache.assets[cachedFile]);
								} else {
									compilation.emitAsset(cachedFile, cache.assets[cachedFile], {
										development: true
									});
								}
								if (cachedFile !== file) chunk.files.push(cachedFile);
							}
							return;
						}

						reportProgress(
							(0.5 * idx) / files.length,
							file,
							"generate SourceMap"
						);
						const task = getTaskForFile(
							file,
							asset,
							chunk,
							options,
							compilation
						);

						if (task) {
							const modules = task.modules;

							for (let idx = 0; idx < modules.length; idx++) {
								const module = modules[idx];
								if (!moduleToSourceNameMapping.get(module)) {
									moduleToSourceNameMapping.set(
										module,
										ModuleFilenameHelpers.createFilename(
											module,
											{
												moduleFilenameTemplate: moduleFilenameTemplate,
												namespace: namespace
											},
											requestShortener
										)
									);
								}
							}

							tasks.push(task);
						}
					});

					reportProgress(0.5, "resolve sources");
					const usedNamesSet = new Set(moduleToSourceNameMapping.values());
					const conflictDetectionSet = new Set();

					const allModules = Array.from(moduleToSourceNameMapping.keys()).sort(
						(a, b) => {
							const ai = typeof a == "string" ? a : a.identifier();
							const bi = typeof b == "string" ? b : b.identifier();
							return ai.length - bi.length;
						}
					);

					for (let idx = 0; idx < allModules.length; idx++) {
						const module = allModules[idx];
						let sourceName = moduleToSourceNameMapping.get(module);
						let hasName = conflictDetectionSet.has(sourceName);
						if (!hasName) {
							conflictDetectionSet.add(sourceName);
							continue;
						}

						sourceName = ModuleFilenameHelpers.createFilename(
							module,
							{
								moduleFilenameTemplate: fallbackModuleFilenameTemplate,
								namespace: namespace
							},
							requestShortener
						);
						hasName = usedNamesSet.has(sourceName);
						if (!hasName) {
							moduleToSourceNameMapping.set(module, sourceName);
							usedNamesSet.add(sourceName);
							continue;
						}

						while (hasName) {
							sourceName += "*";
							hasName = usedNamesSet.has(sourceName);
						}
						moduleToSourceNameMapping.set(module, sourceName);
						usedNamesSet.add(sourceName);
					}
					tasks.forEach((task, index) => {
						reportProgress(
							0.5 + (0.5 * index) / tasks.length,
							task.file,
							"attach SourceMap"
						);
						const assets = Object.create(null);
						const chunk = task.chunk;
						const file = task.file;
						const asset = task.asset;
						const sourceMap = task.sourceMap;
						const source = task.source;
						const modules = task.modules;
						const moduleFilenames = modules.map(m =>
							moduleToSourceNameMapping.get(m)
						);
						sourceMap.sources = moduleFilenames;
						if (options.noSources) {
							sourceMap.sourcesContent = void 0;
						}
						sourceMap.sourceRoot = options.sourceRoot || "";
						sourceMap.file = file;
						assetsCache.set(asset, { file, assets });
						let currentSourceMappingURLComment = sourceMappingURLComment;
						if (
							currentSourceMappingURLComment !== false &&
							/\.css($|\?)/i.test(file)
						) {
							currentSourceMappingURLComment = currentSourceMappingURLComment.replace(
								/^\n\/\/(.*)$/,
								"\n/*$1*/"
							);
						}
						const sourceMapString = JSON.stringify(sourceMap);
						if (sourceMapFilename) {
							let filename = file;
							let query = "";
							const idx = filename.indexOf("?");
							if (idx >= 0) {
								query = filename.substr(idx);
								filename = filename.substr(0, idx);
							}
							const pathParams = {
								chunk,
								filename: options.fileContext
									? path.relative(options.fileContext, filename)
									: filename,
								query,
								basename: basename(filename),
								contentHash: createHash("md4")
									.update(sourceMapString)
									.digest("hex")
							};
							let sourceMapFile = compilation.getPath(
								sourceMapFilename,
								pathParams
							);
							const sourceMapUrl = options.publicPath
								? options.publicPath + sourceMapFile.replace(/\\/g, "/")
								: path
										.relative(path.dirname(file), sourceMapFile)
										.replace(/\\/g, "/");
							if (currentSourceMappingURLComment !== false) {
								const asset = new ConcatSource(
									new RawSource(source),
									compilation.getPath(
										currentSourceMappingURLComment,
										Object.assign({ url: sourceMapUrl }, pathParams)
									)
								);
								assets[file] = asset;
								compilation.updateAsset(file, asset);
							}
							const asset = new RawSource(sourceMapString);
							assets[sourceMapFile] = asset;
							compilation.emitAsset(sourceMapFile, asset, {
								development: true
							});
							chunk.files.push(sourceMapFile);
						} else {
							if (currentSourceMappingURLComment === false) {
								throw new Error(
									"SourceMapDevToolPlugin: append can't be false when no filename is provided"
								);
							}
							const asset = new ConcatSource(
								new RawSource(source),
								currentSourceMappingURLComment
									.replace(/\[map\]/g, () => sourceMapString)
									.replace(
										/\[url\]/g,
										() =>
											`data:application/json;charset=utf-8;base64,${Buffer.from(
												sourceMapString,
												"utf-8"
											).toString("base64")}`
									)
							);
							assets[file] = asset;
							compilation.updateAsset(file, asset);
						}
					});
					reportProgress(1.0);
				}
			);
		});
	}
}

module.exports = SourceMapDevToolPlugin;

},
// 61
function(module, exports, __webpack_require__) {

const SingleEntryDependency = __webpack_require__(25);

class SingleEntryPlugin {
	constructor(context, entry, name) {
		this.context = context;
		this.entry = entry;
		this.name = name;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap(
			"SingleEntryPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					SingleEntryDependency,
					normalModuleFactory
				);
			}
		);

		compiler.hooks.make.tapAsync(
			"SingleEntryPlugin",
			(compilation, callback) => {
				const { entry, name, context } = this;

				const dep = SingleEntryPlugin.createDependency(entry, name);
				compilation.addEntry(context, dep, name, callback);
			}
		);
	}

	static createDependency(entry, name) {
		const dep = new SingleEntryDependency(entry);
		dep.loc = { name };
		return dep;
	}
}

module.exports = SingleEntryPlugin;

},
// 62
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);

class UnsupportedFeatureWarning extends WebpackError {
	constructor(module, message, loc) {
		super(message);

		this.name = "UnsupportedFeatureWarning";
		this.module = module;
		this.loc = loc;
		this.hideStack = true;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = UnsupportedFeatureWarning;

},
// 63
function(module, exports, __webpack_require__) {

class ContextDependencyTemplateAsRequireCall {
	apply(dep, source, runtime) {
		const moduleExports = runtime.moduleExports({
			module: dep.module,
			request: dep.request
		});

		if (dep.module) {
			if (dep.valueRange) {
				if (Array.isArray(dep.replaces)) {
					for (let i = 0; i < dep.replaces.length; i++) {
						const rep = dep.replaces[i];
						source.replace(rep.range[0], rep.range[1] - 1, rep.value);
					}
				}
				source.replace(dep.valueRange[1], dep.range[1] - 1, ")");
				source.replace(
					dep.range[0],
					dep.valueRange[0] - 1,
					`${moduleExports}(${
						typeof dep.prepend == "string" ? JSON.stringify(dep.prepend) : ""
					}`
				);
			} else {
				source.replace(dep.range[0], dep.range[1] - 1, moduleExports);
			}
		} else {
			source.replace(dep.range[0], dep.range[1] - 1, moduleExports);
		}
	}
}
module.exports = ContextDependencyTemplateAsRequireCall;

},
// 64
function(module, exports, __webpack_require__) {

const LocalModule = __webpack_require__(239);
const LocalModulesHelpers = exports;

const lookup = (parent, mod) => {
	if (mod.charAt(0) !== ".") return mod;

	var path = parent.split("/");
	var segs = mod.split("/");
	path.pop();

	for (let i = 0; i < segs.length; i++) {
		const seg = segs[i];
		if (seg === "..") {
			path.pop();
		} else if (seg !== ".") {
			path.push(seg);
		}
	}

	return path.join("/");
};

LocalModulesHelpers.addLocalModule = (state, name) => {
	if (!state.localModules) {
		state.localModules = [];
	}
	const m = new LocalModule(state.module, name, state.localModules.length);
	state.localModules.push(m);
	return m;
};

LocalModulesHelpers.getLocalModule = (state, name, namedModule) => {
	if (!state.localModules) return null;
	if (namedModule) {
		name = lookup(namedModule, name);
	}
	for (let i = 0; i < state.localModules.length; i++) {
		if (state.localModules[i].name === name) {
			return state.localModules[i];
		}
	}
	return null;
};

module.exports = LocalModulesHelpers;

},
// 65
function(module, exports, __webpack_require__) {

const NullDependency = __webpack_require__(7);

class HarmonyExportExpressionDependency extends NullDependency {
	constructor(originModule, range, rangeStatement, prefix) {
		super();
		this.originModule = originModule;
		this.range = range;
		this.rangeStatement = rangeStatement;
		this.prefix = prefix;
	}

	get type() {
		return "harmony export expression";
	}

	getExports() {
		return {
			exports: ["default"],
			dependencies: void 0
		};
	}
}

HarmonyExportExpressionDependency.Template = class {
	apply(dep, source) {
		const used = dep.originModule.isUsed("default");
		const content = this.getContent(dep.originModule, used);

		if (dep.range) {
			source.replace(
				dep.rangeStatement[0],
				dep.range[0] - 1,
				content + "(" + dep.prefix
			);
			source.replace(dep.range[1], dep.rangeStatement[1] - 1, ");");
			return;
		}

		source.replace(dep.rangeStatement[0], dep.rangeStatement[1] - 1, content);
	}

	getContent(module, used) {
		const exportsName = module.exportsArgument;
		if (used) {
			return `/* harmony default export */ ${exportsName}[${JSON.stringify(
				used
			)}] = `;
		}
		return "/* unused harmony default export */ var _unused_webpack_default_export = ";
	}
};

module.exports = HarmonyExportExpressionDependency;

},
// 66
function(module, exports, __webpack_require__) {

const NullDependency = __webpack_require__(7);

class HarmonyExportSpecifierDependency extends NullDependency {
	constructor(originModule, id, name) {
		super();
		this.originModule = originModule;
		this.id = id;
		this.name = name;
	}

	get type() {
		return "harmony export specifier";
	}

	getExports() {
		return {
			exports: [this.name],
			dependencies: void 0
		};
	}
}

HarmonyExportSpecifierDependency.Template = class {
	apply(dep, source) {}

	getHarmonyInitOrder(dep) {
		return 0;
	}

	harmonyInit(dep, source, runtime) {
		const content = this.getContent(dep);
		source.insert(-1, content);
	}

	getContent(dep) {
		const used = dep.originModule.isUsed(dep.name);
		if (!used) {
			return `/* unused harmony export ${dep.name || "namespace"} */\n`;
		}

		const exportsName = dep.originModule.exportsArgument;

		return `/* harmony export (binding) */ __webpack_require__.d(${exportsName}, ${JSON.stringify(
			used
		)}, function() { return ${dep.id}; });\n`;
	}
};

module.exports = HarmonyExportSpecifierDependency;

},
// 67
function(module, exports, __webpack_require__) {

const ModuleDependency = __webpack_require__(4);
const ModuleDependencyTemplateAsRequireId = __webpack_require__(112);

class AMDRequireItemDependency extends ModuleDependency {
	constructor(request, range) {
		super(request);
		this.range = range;
	}

	get type() {
		return "amd require";
	}
}

AMDRequireItemDependency.Template = ModuleDependencyTemplateAsRequireId;

module.exports = AMDRequireItemDependency;

},
// 68
function(module, exports, __webpack_require__) {

const Dependency = __webpack_require__(17);

class AMDRequireArrayDependency extends Dependency {
	constructor(depsArray, range) {
		super();
		this.depsArray = depsArray;
		this.range = range;
	}

	get type() {
		return "amd require array";
	}
}

AMDRequireArrayDependency.Template = class {
	apply(dep, source, runtime) {
		const content = this.getContent(dep, runtime);
		source.replace(dep.range[0], dep.range[1] - 1, content);
	}

	getContent(dep, runtime) {
		const requires = dep.depsArray.map(dependency => {
			return this.contentForDependency(dependency, runtime);
		});
		return `[${requires.join(", ")}]`;
	}

	contentForDependency(dep, runtime) {
		if (typeof dep == "string") {
			return dep;
		}

		if (dep.localModule) {
			return dep.localModule.variableName();
		} else {
			return runtime.moduleExports({
				module: dep.module,
				request: dep.request
			});
		}
	}
};

module.exports = AMDRequireArrayDependency;

},
// 69
function(module, exports, __webpack_require__) {

const ContextDependency = __webpack_require__(26);
class AMDRequireContextDependency extends ContextDependency {
	constructor(options, range, valueRange) {
		super(options);
		this.range = range;
		this.valueRange = valueRange;
	}

	get type() {
		return "amd require context";
	}
}
AMDRequireContextDependency.Template = __webpack_require__(63);
module.exports = AMDRequireContextDependency;

},
// 70
function(module) {

const READ = 0x1,
	WRITE = 0x2,
	RW = READ | WRITE;

class Reference {
	constructor(ident, scope, flag, writeExpr, maybeImplicitGlobal, partial, init) {
		this.identifier = ident;
		this.from = scope;

		this.tainted = false;
		this.resolved = null;

		this.flag = flag;
		if (this.isWrite()) {
			this.writeExpr = writeExpr;

			this.partial = partial;
			this.init = init;
		}
		this.__maybeImplicitGlobal = maybeImplicitGlobal;
	}

	isStatic() {
		return !this.tainted && this.resolved && this.resolved.scope.isStatic();
	}

	isWrite() {
		return !!(this.flag & Reference.WRITE);
	}

	isRead() {
		return !!(this.flag & Reference.READ);
	}

	isReadOnly() {
		return this.flag === Reference.READ;
	}

	isWriteOnly() {
		return this.flag === Reference.WRITE;
	}

	isReadWrite() {
		return this.flag === Reference.RW;
	}
}

Reference.READ = READ;
Reference.WRITE = WRITE;
Reference.RW = RW;

module.exports = Reference;

},
// 71
function(module, exports, __webpack_require__) {

const ConstDependency = __webpack_require__(5);
const BasicEvaluatedExpression = __webpack_require__(57);
const ParserHelpers = __webpack_require__(9);
const NullFactory = __webpack_require__(10);

class RuntimeValue {
	constructor(fn, fileDependencies) {
		this.fn = fn;
		this.fileDependencies = fileDependencies || [];
	}

	exec(parser) {
		if (this.fileDependencies === true) {
			parser.state.module.buildInfo.cacheable = false;
		} else {
			for (const fileDependency of this.fileDependencies) {
				parser.state.module.buildInfo.fileDependencies.add(fileDependency);
			}
		}

		return this.fn({ module: parser.state.module });
	}
}

const stringifyObj = (obj, parser) => {
	return (
		"Object({" +
		Object.keys(obj)
			.map(key => {
				const code = obj[key];
				return JSON.stringify(key) + ":" + toCode(code, parser);
			})
			.join(",") +
		"})"
	);
};

const toCode = (code, parser) => {
	if (code === null) {
		return "null";
	}
	if (code === void 0) {
		return "undefined";
	}
	if (code instanceof RuntimeValue) {
		return toCode(code.exec(parser), parser);
	}
	if (code instanceof RegExp && code.toString) {
		return code.toString();
	}
	if (typeof code == "function" && code.toString) {
		return "(" + code.toString() + ")";
	}
	if (typeof code == "object") {
		return stringifyObj(code, parser);
	}
	return code + "";
};

class DefinePlugin {
	constructor(definitions) {
		this.definitions = definitions;
	}

	static runtimeValue(fn, fileDependencies) {
		return new RuntimeValue(fn, fileDependencies);
	}

	apply(compiler) {
		const definitions = this.definitions;
		compiler.hooks.compilation.tap(
			"DefinePlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(ConstDependency, new NullFactory());
				compilation.dependencyTemplates.set(
					ConstDependency,
					new ConstDependency.Template()
				);

				const handler = parser => {
					const walkDefinitions = (definitions, prefix) => {
						Object.keys(definitions).forEach(key => {
							const code = definitions[key];
							if (
								code &&
								typeof code == "object" &&
								!(code instanceof RuntimeValue) &&
								!(code instanceof RegExp)
							) {
								walkDefinitions(code, prefix + key + ".");
								applyObjectDefine(prefix + key, code);
								return;
							}
							applyDefineKey(prefix, key);
							applyDefine(prefix + key, code);
						});
					};

					const applyDefineKey = (prefix, key) => {
						const splittedKey = key.split(".");
						splittedKey.slice(1).forEach((_, i) => {
							const fullKey = prefix + splittedKey.slice(0, i + 1).join(".");
							parser.hooks.canRename
								.for(fullKey)
								.tap("DefinePlugin", ParserHelpers.approve);
						});
					};

					const applyDefine = (key, code) => {
						const isTypeof = /^typeof\s+/.test(key);
						if (isTypeof) key = key.replace(/^typeof\s+/, "");
						let recurse = false;
						let recurseTypeof = false;
						if (!isTypeof) {
							parser.hooks.canRename
								.for(key)
								.tap("DefinePlugin", ParserHelpers.approve);
							parser.hooks.evaluateIdentifier
								.for(key)
								.tap("DefinePlugin", expr => {
									if (recurse) return;
									recurse = true;
									const res = parser.evaluate(toCode(code, parser));
									recurse = false;
									res.setRange(expr.range);
									return res;
								});
							parser.hooks.expression.for(key).tap("DefinePlugin", expr => {
								const strCode = toCode(code, parser);
								if (/__webpack_require__/.test(strCode)) {
									return ParserHelpers.toConstantDependencyWithWebpackRequire(
										parser,
										strCode
									)(expr);
								} else {
									return ParserHelpers.toConstantDependency(
										parser,
										strCode
									)(expr);
								}
							});
						}
						parser.hooks.evaluateTypeof.for(key).tap("DefinePlugin", expr => {
							if (recurseTypeof) return;
							recurseTypeof = true;
							const typeofCode = isTypeof
								? toCode(code, parser)
								: "typeof (" + toCode(code, parser) + ")";
							const res = parser.evaluate(typeofCode);
							recurseTypeof = false;
							res.setRange(expr.range);
							return res;
						});
						parser.hooks.typeof.for(key).tap("DefinePlugin", expr => {
							const typeofCode = isTypeof
								? toCode(code, parser)
								: "typeof (" + toCode(code, parser) + ")";
							const res = parser.evaluate(typeofCode);
							if (!res.isString()) return;
							return ParserHelpers.toConstantDependency(
								parser,
								JSON.stringify(res.string)
							).bind(parser)(expr);
						});
					};

					const applyObjectDefine = (key, obj) => {
						parser.hooks.canRename
							.for(key)
							.tap("DefinePlugin", ParserHelpers.approve);
						parser.hooks.evaluateIdentifier
							.for(key)
							.tap("DefinePlugin", expr =>
								new BasicEvaluatedExpression().setTruthy().setRange(expr.range)
							);
						parser.hooks.evaluateTypeof.for(key).tap("DefinePlugin", expr => {
							return ParserHelpers.evaluateToString("object")(expr);
						});
						parser.hooks.expression.for(key).tap("DefinePlugin", expr => {
							const strCode = stringifyObj(obj, parser);

							if (/__webpack_require__/.test(strCode)) {
								return ParserHelpers.toConstantDependencyWithWebpackRequire(
									parser,
									strCode
								)(expr);
							} else {
								return ParserHelpers.toConstantDependency(
									parser,
									strCode
								)(expr);
							}
						});
						parser.hooks.typeof.for(key).tap("DefinePlugin", expr => {
							return ParserHelpers.toConstantDependency(
								parser,
								JSON.stringify("object")
							)(expr);
						});
					};

					walkDefinitions(definitions, "");
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("DefinePlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("DefinePlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/esm")
					.tap("DefinePlugin", handler);
			}
		);
	}
}
module.exports = DefinePlugin;

},
// 72
function(module, exports, __webpack_require__) {

const SortableSet = __webpack_require__(20);
const compareLocations = __webpack_require__(29);

let debugId = 5000;

const getArray = set => Array.from(set);

const sortById = (a, b) => {
	if (a.id < b.id) return -1;
	if (b.id < a.id) return 1;
	return 0;
};

const sortOrigin = (a, b) => {
	const aIdent = a.module ? a.module.identifier() : "";
	const bIdent = b.module ? b.module.identifier() : "";
	if (aIdent < bIdent) return -1;
	if (aIdent > bIdent) return 1;
	return compareLocations(a.loc, b.loc);
};

class ChunkGroup {
	constructor(options) {
		if (typeof options == "string") {
			options = { name: options };
		} else if (!options) {
			options = { name: void 0 };
		}
		this.groupDebugId = debugId++;
		this.options = options;
		this._children = new SortableSet(void 0, sortById);
		this._parents = new SortableSet(void 0, sortById);
		this._blocks = new SortableSet();
		this.chunks = [];
		this.origins = [];
		this._moduleIndices = new Map();
		this._moduleIndices2 = new Map();
	}

	addOptions(options) {
		for (const key of Object.keys(options)) {
			if (this.options[key] === void 0) {
				this.options[key] = options[key];
			} else if (this.options[key] !== options[key]) {
				if (key.endsWith("Order")) {
					this.options[key] = Math.max(this.options[key], options[key]);
				} else {
					throw new Error(
						`ChunkGroup.addOptions: No option merge strategy for ${key}`
					);
				}
			}
		}
	}

	get name() {
		return this.options.name;
	}

	set name(value) {
		this.options.name = value;
	}

	get debugId() {
		return Array.from(this.chunks, x => x.debugId).join("+");
	}

	get id() {
		return Array.from(this.chunks, x => x.id).join("+");
	}

	unshiftChunk(chunk) {
		const oldIdx = this.chunks.indexOf(chunk);
		if (oldIdx > 0) {
			this.chunks.splice(oldIdx, 1);
			this.chunks.unshift(chunk);
		} else if (oldIdx < 0) {
			this.chunks.unshift(chunk);
			return true;
		}
		return false;
	}

	insertChunk(chunk, before) {
		const oldIdx = this.chunks.indexOf(chunk);
		const idx = this.chunks.indexOf(before);
		if (idx < 0) {
			throw new Error("before chunk not found");
		}
		if (oldIdx >= 0 && oldIdx > idx) {
			this.chunks.splice(oldIdx, 1);
			this.chunks.splice(idx, 0, chunk);
		} else if (oldIdx < 0) {
			this.chunks.splice(idx, 0, chunk);
			return true;
		}
		return false;
	}

	pushChunk(chunk) {
		const oldIdx = this.chunks.indexOf(chunk);
		if (oldIdx >= 0) {
			return false;
		}
		this.chunks.push(chunk);
		return true;
	}

	replaceChunk(oldChunk, newChunk) {
		const oldIdx = this.chunks.indexOf(oldChunk);
		if (oldIdx < 0) return false;
		const newIdx = this.chunks.indexOf(newChunk);
		if (newIdx < 0) {
			this.chunks[oldIdx] = newChunk;
			return true;
		}
		if (newIdx < oldIdx) {
			this.chunks.splice(oldIdx, 1);
			return true;
		} else if (newIdx !== oldIdx) {
			this.chunks[oldIdx] = newChunk;
			this.chunks.splice(newIdx, 1);
			return true;
		}
	}

	removeChunk(chunk) {
		const idx = this.chunks.indexOf(chunk);
		if (idx >= 0) {
			this.chunks.splice(idx, 1);
			return true;
		}
		return false;
	}

	isInitial() {
		return false;
	}

	addChild(chunk) {
		if (this._children.has(chunk)) {
			return false;
		}
		this._children.add(chunk);
		return true;
	}

	getChildren() {
		return this._children.getFromCache(getArray);
	}

	getNumberOfChildren() {
		return this._children.size;
	}

	get childrenIterable() {
		return this._children;
	}

	removeChild(chunk) {
		if (!this._children.has(chunk)) {
			return false;
		}

		this._children.delete(chunk);
		chunk.removeParent(this);
		return true;
	}

	addParent(parentChunk) {
		if (!this._parents.has(parentChunk)) {
			this._parents.add(parentChunk);
			return true;
		}
		return false;
	}

	getParents() {
		return this._parents.getFromCache(getArray);
	}

	setParents(newParents) {
		this._parents.clear();
		for (const p of newParents) {
			this._parents.add(p);
		}
	}

	getNumberOfParents() {
		return this._parents.size;
	}

	hasParent(parent) {
		return this._parents.has(parent);
	}

	get parentsIterable() {
		return this._parents;
	}

	removeParent(chunk) {
		if (this._parents.delete(chunk)) {
			chunk.removeChunk(this);
			return true;
		}
		return false;
	}

	getBlocks() {
		return this._blocks.getFromCache(getArray);
	}

	getNumberOfBlocks() {
		return this._blocks.size;
	}

	hasBlock(block) {
		return this._blocks.has(block);
	}

	get blocksIterable() {
		return this._blocks;
	}

	addBlock(block) {
		if (!this._blocks.has(block)) {
			this._blocks.add(block);
			return true;
		}
		return false;
	}

	addOrigin(module, loc, request) {
		this.origins.push({
			module,
			loc,
			request
		});
	}

	containsModule(module) {
		for (const chunk of this.chunks) {
			if (chunk.containsModule(module)) return true;
		}
		return false;
	}

	getFiles() {
		const files = new Set();

		for (const chunk of this.chunks) {
			for (const file of chunk.files) {
				files.add(file);
			}
		}

		return Array.from(files);
	}

	remove(reason) {
		for (const parentChunkGroup of this._parents) {
			parentChunkGroup._children.delete(this);

			for (const chunkGroup of this._children) {
				chunkGroup.addParent(parentChunkGroup);
				parentChunkGroup.addChild(chunkGroup);
			}
		}

		for (const chunkGroup of this._children) {
			chunkGroup._parents.delete(this);
		}

		for (const block of this._blocks) {
			block.chunkGroup = null;
		}

		for (const chunk of this.chunks) {
			chunk.removeGroup(this);
		}
	}

	sortItems() {
		this.origins.sort(sortOrigin);
		this._parents.sort();
		this._children.sort();
	}

	compareTo(otherGroup) {
		if (this.chunks.length > otherGroup.chunks.length) return -1;
		if (this.chunks.length < otherGroup.chunks.length) return 1;
		const a = this.chunks[Symbol.iterator]();
		const b = otherGroup.chunks[Symbol.iterator]();
		while (true) {
			const aItem = a.next();
			const bItem = b.next();
			if (aItem.done) return 0;
			const cmp = aItem.value.compareTo(bItem.value);
			if (cmp !== 0) return cmp;
		}
	}

	getChildrenByOrders() {
		const lists = new Map();
		for (const childGroup of this._children) {
			if (typeof childGroup.options == "object") {
				for (const key of Object.keys(childGroup.options)) {
					if (key.endsWith("Order")) {
						const name = key.substr(0, key.length - "Order".length);
						let list = lists.get(name);
						if (list === void 0) {
							lists.set(name, (list = []));
						}
						list.push({
							order: childGroup.options[key],
							group: childGroup
						});
					}
				}
			}
		}
		const result = Object.create(null);
		for (const [name, list] of lists) {
			list.sort((a, b) => {
				const cmp = b.order - a.order;
				if (cmp !== 0) return cmp;
				if (a.group.compareTo) {
					return a.group.compareTo(b.group);
				}
				return 0;
			});
			result[name] = list.map(i => i.group);
		}
		return result;
	}

	setModuleIndex(module, index) {
		this._moduleIndices.set(module, index);
	}

	getModuleIndex(module) {
		return this._moduleIndices.get(module);
	}

	setModuleIndex2(module, index) {
		this._moduleIndices2.set(module, index);
	}

	getModuleIndex2(module) {
		return this._moduleIndices2.get(module);
	}

	checkConstraints() {
		const chunk = this;
		for (const child of chunk._children) {
			if (!child._parents.has(chunk)) {
				throw new Error(
					`checkConstraints: child missing parent ${chunk.debugId} -> ${child.debugId}`
				);
			}
		}
		for (const parentChunk of chunk._parents) {
			if (!parentChunk._children.has(chunk)) {
				throw new Error(
					`checkConstraints: parent missing child ${parentChunk.debugId} <- ${chunk.debugId}`
				);
			}
		}
	}
}

module.exports = ChunkGroup;

},
// 73
function(module, exports, __webpack_require__) {

const util = __webpack_require__(11);
const SortableSet = __webpack_require__(20);
const intersect = __webpack_require__(30).intersect;
const GraphHelpers = __webpack_require__(22);
const Entrypoint = __webpack_require__(74);
let debugId = 1000;
const ERR_CHUNK_ENTRY = "Chunk.entry was removed. Use hasRuntime()";
const ERR_CHUNK_INITIAL =
	"Chunk.initial was removed. Use canBeInitial/isOnlyInitial()";

const sortModuleById = (a, b) => {
	if (a.id < b.id) return -1;
	if (b.id < a.id) return 1;
	return 0;
};

const sortChunkGroupById = (a, b) => {
	if (a.id < b.id) return -1;
	if (b.id < a.id) return 1;
	return 0;
};

const sortByIdentifier = (a, b) => {
	if (a.identifier() > b.identifier()) return 1;
	if (a.identifier() < b.identifier()) return -1;
	return 0;
};

const getModulesIdent = set => {
	set.sort();
	let str = "";
	for (const m of set) {
		str += m.identifier() + "#";
	}
	return str;
};

const getArray = set => Array.from(set);

const getModulesSize = set => {
	let size = 0;
	for (const module of set) {
		size += module.size();
	}
	return size;
};

class Chunk {
	constructor(name) {
		this.id = null;
		this.ids = null;
		this.debugId = debugId++;
		this.name = name;
		this.preventIntegration = false;
		this.entryModule = void 0;
		this._modules = new SortableSet(void 0, sortByIdentifier);
		this.filenameTemplate = void 0;
		this._groups = new SortableSet(void 0, sortChunkGroupById);
		this.files = [];
		this.rendered = false;
		this.hash = void 0;
		this.contentHash = Object.create(null);
		this.renderedHash = void 0;
		this.chunkReason = void 0;
		this.extraAsync = false;
		this.removedModules = void 0;
	}

	get entry() {
		throw new Error(ERR_CHUNK_ENTRY);
	}

	set entry(data) {
		throw new Error(ERR_CHUNK_ENTRY);
	}

	get initial() {
		throw new Error(ERR_CHUNK_INITIAL);
	}

	set initial(data) {
		throw new Error(ERR_CHUNK_INITIAL);
	}

	hasRuntime() {
		for (const chunkGroup of this._groups) {
			if (
				chunkGroup.isInitial() &&
				chunkGroup instanceof Entrypoint &&
				chunkGroup.getRuntimeChunk() === this
			) {
				return true;
			}
		}
		return false;
	}

	canBeInitial() {
		for (const chunkGroup of this._groups) {
			if (chunkGroup.isInitial()) return true;
		}
		return false;
	}

	isOnlyInitial() {
		if (this._groups.size <= 0) return false;
		for (const chunkGroup of this._groups) {
			if (!chunkGroup.isInitial()) return false;
		}
		return true;
	}

	hasEntryModule() {
		return !!this.entryModule;
	}

	addModule(module) {
		if (!this._modules.has(module)) {
			this._modules.add(module);
			return true;
		}
		return false;
	}

	removeModule(module) {
		if (this._modules.delete(module)) {
			module.removeChunk(this);
			return true;
		}
		return false;
	}

	setModules(modules) {
		this._modules = new SortableSet(modules, sortByIdentifier);
	}

	getNumberOfModules() {
		return this._modules.size;
	}

	get modulesIterable() {
		return this._modules;
	}

	addGroup(chunkGroup) {
		if (this._groups.has(chunkGroup)) return false;
		this._groups.add(chunkGroup);
		return true;
	}

	removeGroup(chunkGroup) {
		if (!this._groups.has(chunkGroup)) return false;
		this._groups.delete(chunkGroup);
		return true;
	}

	isInGroup(chunkGroup) {
		return this._groups.has(chunkGroup);
	}

	getNumberOfGroups() {
		return this._groups.size;
	}

	get groupsIterable() {
		return this._groups;
	}

	compareTo(otherChunk) {
		if (this.name && !otherChunk.name) return -1;
		if (!this.name && otherChunk.name) return 1;
		if (this.name < otherChunk.name) return -1;
		if (this.name > otherChunk.name) return 1;
		if (this._modules.size > otherChunk._modules.size) return -1;
		if (this._modules.size < otherChunk._modules.size) return 1;
		this._modules.sort();
		otherChunk._modules.sort();
		const a = this._modules[Symbol.iterator]();
		const b = otherChunk._modules[Symbol.iterator]();
		while (true) {
			const aItem = a.next();
			if (aItem.done) return 0;
			const bItem = b.next();
			const aModuleIdentifier = aItem.value.identifier();
			const bModuleIdentifier = bItem.value.identifier();
			if (aModuleIdentifier < bModuleIdentifier) return -1;
			if (aModuleIdentifier > bModuleIdentifier) return 1;
		}
	}

	containsModule(module) {
		return this._modules.has(module);
	}

	getModules() {
		return this._modules.getFromCache(getArray);
	}

	getModulesIdent() {
		return this._modules.getFromUnorderedCache(getModulesIdent);
	}

	remove(reason) {
		for (const module of Array.from(this._modules)) {
			module.removeChunk(this);
		}
		for (const chunkGroup of this._groups) {
			chunkGroup.removeChunk(this);
		}
	}

	moveModule(module, otherChunk) {
		GraphHelpers.disconnectChunkAndModule(this, module);
		GraphHelpers.connectChunkAndModule(otherChunk, module);
		module.rewriteChunkInReasons(this, [otherChunk]);
	}

	integrate(otherChunk, reason) {
		if (!this.canBeIntegrated(otherChunk)) {
			return false;
		}

		if (this.name && otherChunk.name) {
			if (this.hasEntryModule() === otherChunk.hasEntryModule()) {
				if (this.name.length !== otherChunk.name.length) {
					this.name =
						this.name.length < otherChunk.name.length
							? this.name
							: otherChunk.name;
				} else {
					this.name = this.name < otherChunk.name ? this.name : otherChunk.name;
				}
			} else if (otherChunk.hasEntryModule()) {
				this.name = otherChunk.name;
			}
		} else if (otherChunk.name) {
			this.name = otherChunk.name;
		}

		for (const module of Array.from(otherChunk._modules)) {
			otherChunk.moveModule(module, this);
		}
		otherChunk._modules.clear();

		if (otherChunk.entryModule) {
			this.entryModule = otherChunk.entryModule;
		}

		for (const chunkGroup of otherChunk._groups) {
			chunkGroup.replaceChunk(otherChunk, this);
			this.addGroup(chunkGroup);
		}
		otherChunk._groups.clear();

		return true;
	}

	split(newChunk) {
		for (const chunkGroup of this._groups) {
			chunkGroup.insertChunk(newChunk, this);
			newChunk.addGroup(chunkGroup);
		}
	}

	isEmpty() {
		return this._modules.size === 0;
	}

	updateHash(hash) {
		hash.update(`${this.id} `);
		hash.update(this.ids ? this.ids.join(",") : "");
		hash.update(`${this.name || ""} `);
		for (const m of this._modules) {
			hash.update(m.hash);
		}
	}

	canBeIntegrated(otherChunk) {
		if (this.preventIntegration || otherChunk.preventIntegration) {
			return false;
		}

		const isAvailable = (a, b) => {
			const queue = new Set(b.groupsIterable);
			for (const chunkGroup of queue) {
				if (a.isInGroup(chunkGroup)) continue;
				if (chunkGroup.isInitial()) return false;
				for (const parent of chunkGroup.parentsIterable) {
					queue.add(parent);
				}
			}
			return true;
		};

		const selfHasRuntime = this.hasRuntime();
		const otherChunkHasRuntime = otherChunk.hasRuntime();

		if (selfHasRuntime !== otherChunkHasRuntime) {
			if (selfHasRuntime) {
				return isAvailable(this, otherChunk);
			} else if (otherChunkHasRuntime) {
				return isAvailable(otherChunk, this);
			} else {
				return false;
			}
		}

		if (this.hasEntryModule() || otherChunk.hasEntryModule()) {
			return false;
		}

		return true;
	}

	addMultiplierAndOverhead(size, options) {
		const overhead =
			typeof options.chunkOverhead == "number" ? options.chunkOverhead : 10000;
		const multiplicator = this.canBeInitial()
			? options.entryChunkMultiplicator || 10
			: 1;

		return size * multiplicator + overhead;
	}

	modulesSize() {
		return this._modules.getFromUnorderedCache(getModulesSize);
	}

	size(options = {}) {
		return this.addMultiplierAndOverhead(this.modulesSize(), options);
	}

	integratedSize(otherChunk, options) {
		if (!this.canBeIntegrated(otherChunk)) {
			return false;
		}

		let integratedModulesSize = this.modulesSize();
		for (const otherModule of otherChunk._modules) {
			if (!this._modules.has(otherModule)) {
				integratedModulesSize += otherModule.size();
			}
		}

		return this.addMultiplierAndOverhead(integratedModulesSize, options);
	}

	sortModules(sortByFn) {
		this._modules.sortWith(sortByFn || sortModuleById);
	}

	sortItems() {
		this.sortModules();
	}

	getAllAsyncChunks() {
		const queue = new Set();
		const chunks = new Set();

		const initialChunks = intersect(
			Array.from(this.groupsIterable, g => new Set(g.chunks))
		);

		for (const chunkGroup of this.groupsIterable) {
			for (const child of chunkGroup.childrenIterable) {
				queue.add(child);
			}
		}

		for (const chunkGroup of queue) {
			for (const chunk of chunkGroup.chunks) {
				if (!initialChunks.has(chunk)) {
					chunks.add(chunk);
				}
			}
			for (const child of chunkGroup.childrenIterable) {
				queue.add(child);
			}
		}

		return chunks;
	}

	getChunkMaps(realHash) {
		const chunkHashMap = Object.create(null);
		const chunkContentHashMap = Object.create(null);
		const chunkNameMap = Object.create(null);

		for (const chunk of this.getAllAsyncChunks()) {
			chunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;
			for (const key of Object.keys(chunk.contentHash)) {
				if (!chunkContentHashMap[key]) {
					chunkContentHashMap[key] = Object.create(null);
				}
				chunkContentHashMap[key][chunk.id] = chunk.contentHash[key];
			}
			if (chunk.name) {
				chunkNameMap[chunk.id] = chunk.name;
			}
		}

		return {
			hash: chunkHashMap,
			contentHash: chunkContentHashMap,
			name: chunkNameMap
		};
	}

	getChildIdsByOrders() {
		const lists = new Map();
		for (const group of this.groupsIterable) {
			if (group.chunks[group.chunks.length - 1] === this) {
				for (const childGroup of group.childrenIterable) {
					if (typeof childGroup.options == "object") {
						for (const key of Object.keys(childGroup.options)) {
							if (key.endsWith("Order")) {
								const name = key.substr(0, key.length - "Order".length);
								let list = lists.get(name);
								if (list === void 0) lists.set(name, (list = []));
								list.push({
									order: childGroup.options[key],
									group: childGroup
								});
							}
						}
					}
				}
			}
		}
		const result = Object.create(null);
		for (const [name, list] of lists) {
			list.sort((a, b) => {
				const cmp = b.order - a.order;
				if (cmp !== 0) return cmp;
				if (a.group.compareTo) {
					return a.group.compareTo(b.group);
				}
				return 0;
			});
			result[name] = Array.from(
				list.reduce((set, item) => {
					for (const chunk of item.group.chunks) {
						set.add(chunk.id);
					}
					return set;
				}, new Set())
			);
		}
		return result;
	}

	getChildIdsByOrdersMap(includeDirectChildren) {
		const chunkMaps = Object.create(null);

		const addChildIdsByOrdersToMap = chunk => {
			const data = chunk.getChildIdsByOrders();
			for (const key of Object.keys(data)) {
				let chunkMap = chunkMaps[key];
				if (chunkMap === void 0) {
					chunkMaps[key] = chunkMap = Object.create(null);
				}
				chunkMap[chunk.id] = data[key];
			}
		};

		if (includeDirectChildren) {
			const chunks = new Set();
			for (const chunkGroup of this.groupsIterable) {
				for (const chunk of chunkGroup.chunks) {
					chunks.add(chunk);
				}
			}
			for (const chunk of chunks) {
				addChildIdsByOrdersToMap(chunk);
			}
		}

		for (const chunk of this.getAllAsyncChunks()) {
			addChildIdsByOrdersToMap(chunk);
		}

		return chunkMaps;
	}

	getChunkModuleMaps(filterFn) {
		const chunkModuleIdMap = Object.create(null);
		const chunkModuleHashMap = Object.create(null);

		for (const chunk of this.getAllAsyncChunks()) {
			let array;
			for (const module of chunk.modulesIterable) {
				if (filterFn(module)) {
					if (array === void 0) {
						array = [];
						chunkModuleIdMap[chunk.id] = array;
					}
					array.push(module.id);
					chunkModuleHashMap[module.id] = module.renderedHash;
				}
			}
			if (array !== void 0) {
				array.sort();
			}
		}

		return {
			id: chunkModuleIdMap,
			hash: chunkModuleHashMap
		};
	}

	hasModuleInGraph(filterFn, filterChunkFn) {
		const queue = new Set(this.groupsIterable);
		const chunksProcessed = new Set();

		for (const chunkGroup of queue) {
			for (const chunk of chunkGroup.chunks) {
				if (!chunksProcessed.has(chunk)) {
					chunksProcessed.add(chunk);
					if (!filterChunkFn || filterChunkFn(chunk)) {
						for (const module of chunk.modulesIterable) {
							if (filterFn(module)) {
								return true;
							}
						}
					}
				}
			}
			for (const child of chunkGroup.childrenIterable) {
				queue.add(child);
			}
		}
		return false;
	}

	toString() {
		return `Chunk[${Array.from(this._modules).join()}]`;
	}
}

Object.defineProperty(Chunk.prototype, "forEachModule", {
	configurable: false,
	value: util.deprecate(
		function(fn) {
			this._modules.forEach(fn);
		},
		"Chunk.forEachModule: Use for(const module of chunk.modulesIterable) instead"
	)
});

Object.defineProperty(Chunk.prototype, "mapModules", {
	configurable: false,
	value: util.deprecate(
		function(fn) {
			return Array.from(this._modules, fn);
		},
		"Chunk.mapModules: Use Array.from(chunk.modulesIterable, fn) instead"
	)
});

Object.defineProperty(Chunk.prototype, "chunks", {
	configurable: false,
	get() {
		throw new Error("Chunk.chunks: Use ChunkGroup.getChildren() instead");
	},
	set() {
		throw new Error("Chunk.chunks: Use ChunkGroup.add/removeChild() instead");
	}
});

Object.defineProperty(Chunk.prototype, "parents", {
	configurable: false,
	get() {
		throw new Error("Chunk.parents: Use ChunkGroup.getParents() instead");
	},
	set() {
		throw new Error("Chunk.parents: Use ChunkGroup.add/removeParent() instead");
	}
});

Object.defineProperty(Chunk.prototype, "blocks", {
	configurable: false,
	get() {
		throw new Error("Chunk.blocks: Use ChunkGroup.getBlocks() instead");
	},
	set() {
		throw new Error("Chunk.blocks: Use ChunkGroup.add/removeBlock() instead");
	}
});

Object.defineProperty(Chunk.prototype, "entrypoints", {
	configurable: false,
	get() {
		throw new Error(
			"Chunk.entrypoints: Use Chunks.groupsIterable and filter by instanceof Entrypoint instead"
		);
	},
	set() {
		throw new Error("Chunk.entrypoints: Use Chunks.addGroup instead");
	}
});

module.exports = Chunk;

},
// 74
function(module, exports, __webpack_require__) {

const ChunkGroup = __webpack_require__(72);

class Entrypoint extends ChunkGroup {
	constructor(name) {
		super(name);
		this.runtimeChunk = void 0;
	}

	isInitial() {
		return true;
	}

	setRuntimeChunk(chunk) {
		this.runtimeChunk = chunk;
	}

	getRuntimeChunk() {
		return this.runtimeChunk || this.chunks[0];
	}

	replaceChunk(oldChunk, newChunk) {
		if (this.runtimeChunk === oldChunk) this.runtimeChunk = newChunk;
		return super.replaceChunk(oldChunk, newChunk);
	}
}

module.exports = Entrypoint;

},
// 75
function(module, exports, __webpack_require__) {

const Chunk = __webpack_require__(73);

class HotUpdateChunk extends Chunk {
	constructor() {
		super();
		this.removedModules = void 0;
	}
}

module.exports = HotUpdateChunk;

},
// 76
function(module) {

module.exports = require("crypto");

},
// 77
function(module) {

module.exports = require("module");

},
// 78
function(module, exports, __webpack_require__) {

const DependenciesBlockVariable = __webpack_require__(174);

class DependenciesBlock {
	constructor() {
		this.dependencies = [];
		this.blocks = [];
		this.variables = [];
	}

	addBlock(block) {
		this.blocks.push(block);
		block.parent = this;
	}

	addVariable(name, expression, dependencies) {
		for (let v of this.variables) {
			if (v.name === name && v.expression === expression) {
				return;
			}
		}
		this.variables.push(
			new DependenciesBlockVariable(name, expression, dependencies)
		);
	}

	addDependency(dependency) {
		this.dependencies.push(dependency);
	}

	removeDependency(dependency) {
		const idx = this.dependencies.indexOf(dependency);
		if (idx >= 0) {
			this.dependencies.splice(idx, 1);
		}
	}

	updateHash(hash) {
		for (const dep of this.dependencies) dep.updateHash(hash);
		for (const block of this.blocks) block.updateHash(hash);
		for (const variable of this.variables) variable.updateHash(hash);
	}

	disconnect() {
		for (const dep of this.dependencies) dep.disconnect();
		for (const block of this.blocks) block.disconnect();
		for (const variable of this.variables) variable.disconnect();
	}

	unseal() {
		for (const block of this.blocks) block.unseal();
	}

	hasDependencies(filter) {
		if (filter) {
			for (const dep of this.dependencies) {
				if (filter(dep)) return true;
			}
		} else {
			if (this.dependencies.length > 0) {
				return true;
			}
		}

		for (const block of this.blocks) {
			if (block.hasDependencies(filter)) return true;
		}
		for (const variable of this.variables) {
			if (variable.hasDependencies(filter)) return true;
		}
		return false;
	}

	sortItems() {
		for (const block of this.blocks) block.sortItems();
	}
}

module.exports = DependenciesBlock;

},
// 79
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);

module.exports = class extends WebpackError {
	constructor() {
		super();

		this.name = "ConcurrentCompilationError";
		this.message =
			"You ran Webpack twice. Each instance only supports a single concurrent compilation at a time.";

		Error.captureStackTrace(this, this.constructor);
	}
};

},
// 80
function(module, exports, __webpack_require__) {

var path = __webpack_require__(3);

function WatcherManager() {
	this.directoryWatchers = {};
}

WatcherManager.prototype.getDirectoryWatcher = function(directory, options) {
	var DirectoryWatcher = __webpack_require__(191);
	options = options || {};
	var key = directory + " " + JSON.stringify(options);
	if (!this.directoryWatchers[key]) {
		this.directoryWatchers[key] = new DirectoryWatcher(directory, options);
		this.directoryWatchers[key].on("closed", function() {
			delete this.directoryWatchers[key];
		}.bind(this));
	}
	return this.directoryWatchers[key];
};

WatcherManager.prototype.watchFile = function(p, options, startTime) {
	var directory = path.dirname(p);
	return this.getDirectoryWatcher(directory, options).watch(p, startTime);
};

WatcherManager.prototype.watchDirectory = function(directory, options, startTime) {
	return this.getDirectoryWatcher(directory, options).watch(directory, startTime);
};

module.exports = new WatcherManager();

},
// 81
function(module) {

module.exports = require("events");

},
// 82
function(module, exports, __webpack_require__) {

var path = __webpack_require__(3),
	fs = __webpack_require__(34),
	_0777 = parseInt('0777', 8);

module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

function mkdirP(p, opts, f, made) {
	if (typeof opts == 'function') {
		f = opts;
		opts = {};
	} else if (!opts || typeof opts != 'object') opts = { mode: opts };

	var mode = opts.mode,
		xfs = opts.fs || fs;

	if (mode === void 0) mode = _0777

	made || (made = null);

	var cb = f || function() {};
	p = path.resolve(p);

	xfs.mkdir(p, mode, function(er) {
		if (!er) {
			made = made || p;
			return cb(null, made);
		}
		switch (er.code) {
			case 'ENOENT':
				var d = path.dirname(p);
				if (d === p) return cb(er);
				mkdirP(d, opts, function(er, made) {
					er ? cb(er, made) : mkdirP(p, opts, cb, made);
				});
				break;

			default:
				xfs.stat(p, function(er2, stat) {
					er2 || !stat.isDirectory() ? cb(er, made) : cb(null, made);
				});
				break;
		}
	});
}

mkdirP.sync = function sync(p, opts, made) {
	if (!opts || typeof opts != 'object') opts = { mode: opts };

	var mode = opts.mode,
		xfs = opts.fs || fs;

	if (mode === void 0) mode = _0777

	made || (made = null);

	p = path.resolve(p);

	try {
		xfs.mkdirSync(p, mode);
		made = made || p;
	} catch (err0) {
		switch (err0.code) {
			case 'ENOENT':
				var d = path.dirname(p);
				if (d === p) throw err0;
				made = sync(d, opts, made);
				sync(p, opts, made);
				break;

			default:
				var stat;
				try {
					stat = xfs.statSync(p);
				} catch (_err1) {
					throw err0;
				}
				if (!stat.isDirectory()) throw err0;
				break;
		}
	}

	return made;
};

},
// 83
function(module, exports, __webpack_require__) {

const acorn = __webpack_require__(202);
const { Tapable, SyncBailHook, HookMap } = __webpack_require__(6);
const util = __webpack_require__(11);
const vm = __webpack_require__(203);
const BasicEvaluatedExpression = __webpack_require__(57);
const StackedSetMap = __webpack_require__(84);

const acornParser = acorn.Parser;

const joinRanges = (startRange, endRange) => {
	if (!endRange) return startRange;
	if (!startRange) return endRange;
	return [startRange[0], endRange[1]];
};

const defaultParserOptions = {
	ranges: true,
	locations: true,
	ecmaVersion: 11,
	sourceType: "module",
	onComment: null
};

const webpackCommentRegExp = new RegExp(/(^|\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);

const EMPTY_COMMENT_OPTIONS = {
	options: null,
	errors: null
};

class Parser extends Tapable {
	constructor(options, sourceType = "auto") {
		super();
		this.hooks = {
			evaluateTypeof: new HookMap(() => new SyncBailHook(["expression"])),
			evaluate: new HookMap(() => new SyncBailHook(["expression"])),
			evaluateIdentifier: new HookMap(() => new SyncBailHook(["expression"])),
			evaluateDefinedIdentifier: new HookMap(
				() => new SyncBailHook(["expression"])
			),
			evaluateCallExpressionMember: new HookMap(
				() => new SyncBailHook(["expression", "param"])
			),
			statement: new SyncBailHook(["statement"]),
			statementIf: new SyncBailHook(["statement"]),
			label: new HookMap(() => new SyncBailHook(["statement"])),
			import: new SyncBailHook(["statement", "source"]),
			importSpecifier: new SyncBailHook([
				"statement",
				"source",
				"exportName",
				"identifierName"
			]),
			export: new SyncBailHook(["statement"]),
			exportImport: new SyncBailHook(["statement", "source"]),
			exportDeclaration: new SyncBailHook(["statement", "declaration"]),
			exportExpression: new SyncBailHook(["statement", "declaration"]),
			exportSpecifier: new SyncBailHook([
				"statement",
				"identifierName",
				"exportName",
				"index"
			]),
			exportImportSpecifier: new SyncBailHook([
				"statement",
				"source",
				"identifierName",
				"exportName",
				"index"
			]),
			varDeclaration: new HookMap(() => new SyncBailHook(["declaration"])),
			varDeclarationLet: new HookMap(() => new SyncBailHook(["declaration"])),
			varDeclarationConst: new HookMap(() => new SyncBailHook(["declaration"])),
			varDeclarationVar: new HookMap(() => new SyncBailHook(["declaration"])),
			canRename: new HookMap(() => new SyncBailHook(["initExpression"])),
			rename: new HookMap(() => new SyncBailHook(["initExpression"])),
			assigned: new HookMap(() => new SyncBailHook(["expression"])),
			assign: new HookMap(() => new SyncBailHook(["expression"])),
			typeof: new HookMap(() => new SyncBailHook(["expression"])),
			importCall: new SyncBailHook(["expression"]),
			call: new HookMap(() => new SyncBailHook(["expression"])),
			callAnyMember: new HookMap(() => new SyncBailHook(["expression"])),
			new: new HookMap(() => new SyncBailHook(["expression"])),
			expression: new HookMap(() => new SyncBailHook(["expression"])),
			expressionAnyMember: new HookMap(() => new SyncBailHook(["expression"])),
			expressionConditionalOperator: new SyncBailHook(["expression"]),
			expressionLogicalOperator: new SyncBailHook(["expression"]),
			program: new SyncBailHook(["ast", "comments"])
		};
		const HOOK_MAP_COMPAT_CONFIG = {
			evaluateTypeof: /^evaluate typeof (.+)$/,
			evaluateIdentifier: /^evaluate Identifier (.+)$/,
			evaluateDefinedIdentifier: /^evaluate defined Identifier (.+)$/,
			evaluateCallExpressionMember: /^evaluate CallExpression .(.+)$/,
			evaluate: /^evaluate (.+)$/,
			label: /^label (.+)$/,
			varDeclarationLet: /^var-let (.+)$/,
			varDeclarationConst: /^var-const (.+)$/,
			varDeclarationVar: /^var-var (.+)$/,
			varDeclaration: /^var (.+)$/,
			canRename: /^can-rename (.+)$/,
			rename: /^rename (.+)$/,
			typeof: /^typeof (.+)$/,
			assigned: /^assigned (.+)$/,
			assign: /^assign (.+)$/,
			callAnyMember: /^call (.+)\.\*$/,
			call: /^call (.+)$/,
			new: /^new (.+)$/,
			expressionConditionalOperator: /^expression \?:$/,
			expressionAnyMember: /^expression (.+)\.\*$/,
			expression: /^expression (.+)$/
		};
		this._pluginCompat.tap("Parser", options => {
			for (const name of Object.keys(HOOK_MAP_COMPAT_CONFIG)) {
				const regexp = HOOK_MAP_COMPAT_CONFIG[name];
				const match = regexp.exec(options.name);
				if (match) {
					if (match[1]) {
						this.hooks[name].tap(
							match[1],
							options.fn.name || "unnamed compat plugin",
							options.fn.bind(this)
						);
					} else {
						this.hooks[name].tap(
							options.fn.name || "unnamed compat plugin",
							options.fn.bind(this)
						);
					}
					return true;
				}
			}
		});
		this.options = options;
		this.sourceType = sourceType;
		this.scope = void 0;
		this.state = void 0;
		this.comments = void 0;
		this.initializeEvaluating();
	}

	initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap("Parser", expr => {
			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(expr.range);
			}
			if (expr.value === null) {
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			}
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("LogicalExpression").tap("Parser", expr => {
			let left;
			let leftAsBool;
			let right;
			if (expr.operator === "&&") {
				left = this.evaluateExpression(expr.left);
				leftAsBool = left && left.asBool();
				if (leftAsBool === false) return left.setRange(expr.range);
				if (leftAsBool !== true) return;
				right = this.evaluateExpression(expr.right);
				return right.setRange(expr.range);
			} else if (expr.operator === "||") {
				left = this.evaluateExpression(expr.left);
				leftAsBool = left && left.asBool();
				if (leftAsBool === true) return left.setRange(expr.range);
				if (leftAsBool !== false) return;
				right = this.evaluateExpression(expr.right);
				return right.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("BinaryExpression").tap("Parser", expr => {
			let left;
			let right;
			let res;
			if (expr.operator === "+") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				res = new BasicEvaluatedExpression();
				if (left.isString()) {
					if (right.isString()) {
						res.setString(left.string + right.string);
					} else if (right.isNumber()) {
						res.setString(left.string + right.number);
					} else if (
						right.isWrapped() &&
						right.prefix &&
						right.prefix.isString()
					) {
						res.setWrapped(
							new BasicEvaluatedExpression()
								.setString(left.string + right.prefix.string)
								.setRange(joinRanges(left.range, right.prefix.range)),
							right.postfix,
							right.wrappedInnerExpressions
						);
					} else if (right.isWrapped()) {
						res.setWrapped(left, right.postfix, right.wrappedInnerExpressions);
					} else {
						res.setWrapped(left, null, [right]);
					}
				} else if (left.isNumber()) {
					if (right.isString()) {
						res.setString(left.number + right.string);
					} else if (right.isNumber()) {
						res.setNumber(left.number + right.number);
					} else {
						return;
					}
				} else if (left.isWrapped()) {
					if (left.postfix && left.postfix.isString() && right.isString()) {
						res.setWrapped(
							left.prefix,
							new BasicEvaluatedExpression()
								.setString(left.postfix.string + right.string)
								.setRange(joinRanges(left.postfix.range, right.range)),
							left.wrappedInnerExpressions
						);
					} else if (
						left.postfix &&
						left.postfix.isString() &&
						right.isNumber()
					) {
						res.setWrapped(
							left.prefix,
							new BasicEvaluatedExpression()
								.setString(left.postfix.string + right.number)
								.setRange(joinRanges(left.postfix.range, right.range)),
							left.wrappedInnerExpressions
						);
					} else if (right.isString()) {
						res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
					} else if (right.isNumber()) {
						res.setWrapped(
							left.prefix,
							new BasicEvaluatedExpression()
								.setString(right.number + "")
								.setRange(right.range),
							left.wrappedInnerExpressions
						);
					} else if (right.isWrapped()) {
						res.setWrapped(
							left.prefix,
							right.postfix,
							left.wrappedInnerExpressions &&
								right.wrappedInnerExpressions &&
								left.wrappedInnerExpressions
									.concat(left.postfix ? [left.postfix] : [])
									.concat(right.prefix ? [right.prefix] : [])
									.concat(right.wrappedInnerExpressions)
						);
					} else {
						res.setWrapped(
							left.prefix,
							null,
							left.wrappedInnerExpressions &&
								left.wrappedInnerExpressions.concat(
									left.postfix ? [left.postfix, right] : [right]
								)
						);
					}
				} else {
					if (right.isString()) {
						res.setWrapped(null, right, [left]);
					} else if (right.isWrapped()) {
						res.setWrapped(
							null,
							right.postfix,
							right.wrappedInnerExpressions &&
								(right.prefix ? [left, right.prefix] : [left]).concat(
									right.wrappedInnerExpressions
								)
						);
					} else {
						return;
					}
				}
				res.setRange(expr.range);
				return res;
			} else if (expr.operator === "-") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				if (!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number - right.number);
				res.setRange(expr.range);
				return res;
			} else if (expr.operator === "*") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				if (!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number * right.number);
				res.setRange(expr.range);
				return res;
			} else if (expr.operator === "/") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				if (!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number / right.number);
				res.setRange(expr.range);
				return res;
			} else if (expr.operator === "**") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				if (!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(Math.pow(left.number, right.number));
				res.setRange(expr.range);
				return res;
			} else if (expr.operator === "==" || expr.operator === "===") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				res = new BasicEvaluatedExpression();
				res.setRange(expr.range);
				if (left.isString() && right.isString()) {
					return res.setBoolean(left.string === right.string);
				} else if (left.isNumber() && right.isNumber()) {
					return res.setBoolean(left.number === right.number);
				} else if (left.isBoolean() && right.isBoolean()) {
					return res.setBoolean(left.bool === right.bool);
				}
			} else if (expr.operator === "!=" || expr.operator === "!==") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				res = new BasicEvaluatedExpression();
				res.setRange(expr.range);
				if (left.isString() && right.isString()) {
					return res.setBoolean(left.string !== right.string);
				} else if (left.isNumber() && right.isNumber()) {
					return res.setBoolean(left.number !== right.number);
				} else if (left.isBoolean() && right.isBoolean()) {
					return res.setBoolean(left.bool !== right.bool);
				}
			} else if (expr.operator === "&") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				if (!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number & right.number);
				res.setRange(expr.range);
				return res;
			} else if (expr.operator === "|") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				if (!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number | right.number);
				res.setRange(expr.range);
				return res;
			} else if (expr.operator === "^") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				if (!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number ^ right.number);
				res.setRange(expr.range);
				return res;
			} else if (expr.operator === ">>>") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				if (!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number >>> right.number);
				res.setRange(expr.range);
				return res;
			} else if (expr.operator === ">>") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				if (!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number >> right.number);
				res.setRange(expr.range);
				return res;
			} else if (expr.operator === "<<") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if (!left || !right) return;
				if (!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number << right.number);
				res.setRange(expr.range);
				return res;
			}
		});
		this.hooks.evaluate.for("UnaryExpression").tap("Parser", expr => {
			if (expr.operator === "typeof") {
				let res;
				let name;
				if (expr.argument.type === "Identifier") {
					name =
						this.scope.renames.get(expr.argument.name) || expr.argument.name;
					if (!this.scope.definitions.has(name)) {
						const hook = this.hooks.evaluateTypeof.get(name);
						if (hook !== void 0) {
							res = hook.call(expr);
							if (res !== void 0) return res;
						}
					}
				}
				if (expr.argument.type === "MemberExpression") {
					const exprName = this.getNameForExpression(expr.argument);
					if (exprName && exprName.free) {
						const hook = this.hooks.evaluateTypeof.get(exprName.name);
						if (hook !== void 0) {
							res = hook.call(expr);
							if (res !== void 0) return res;
						}
					}
				}
				if (expr.argument.type === "FunctionExpression") {
					return new BasicEvaluatedExpression()
						.setString("function")
						.setRange(expr.range);
				}
				const arg = this.evaluateExpression(expr.argument);
				if (arg.isString() || arg.isWrapped()) {
					return new BasicEvaluatedExpression()
						.setString("string")
						.setRange(expr.range);
				}
				if (arg.isNumber()) {
					return new BasicEvaluatedExpression()
						.setString("number")
						.setRange(expr.range);
				}
				if (arg.isBoolean()) {
					return new BasicEvaluatedExpression()
						.setString("boolean")
						.setRange(expr.range);
				}
				if (arg.isArray() || arg.isConstArray() || arg.isRegExp()) {
					return new BasicEvaluatedExpression()
						.setString("object")
						.setRange(expr.range);
				}
			} else if (expr.operator === "!") {
				const argument = this.evaluateExpression(expr.argument);
				if (!argument) return;
				if (argument.isBoolean()) {
					return new BasicEvaluatedExpression()
						.setBoolean(!argument.bool)
						.setRange(expr.range);
				}
				if (argument.isTruthy()) {
					return new BasicEvaluatedExpression()
						.setBoolean(false)
						.setRange(expr.range);
				}
				if (argument.isFalsy()) {
					return new BasicEvaluatedExpression()
						.setBoolean(true)
						.setRange(expr.range);
				}
				if (argument.isString()) {
					return new BasicEvaluatedExpression()
						.setBoolean(!argument.string)
						.setRange(expr.range);
				}
				if (argument.isNumber()) {
					return new BasicEvaluatedExpression()
						.setBoolean(!argument.number)
						.setRange(expr.range);
				}
			} else if (expr.operator === "~") {
				const argument = this.evaluateExpression(expr.argument);
				if (!argument) return;
				if (!argument.isNumber()) return;
				const res = new BasicEvaluatedExpression();
				res.setNumber(~argument.number);
				res.setRange(expr.range);
				return res;
			}
		});
		this.hooks.evaluateTypeof.for("undefined").tap("Parser", expr => {
			return new BasicEvaluatedExpression()
				.setString("undefined")
				.setRange(expr.range);
		});
		this.hooks.evaluate.for("Identifier").tap("Parser", expr => {
			const name = this.scope.renames.get(expr.name) || expr.name;
			if (!this.scope.definitions.has(expr.name)) {
				const hook = this.hooks.evaluateIdentifier.get(name);
				if (hook !== void 0) {
					const result = hook.call(expr);
					if (result) return result;
				}
				return new BasicEvaluatedExpression()
					.setIdentifier(name)
					.setRange(expr.range);
			} else {
				const hook = this.hooks.evaluateDefinedIdentifier.get(name);
				if (hook !== void 0) {
					return hook.call(expr);
				}
			}
		});
		this.hooks.evaluate.for("ThisExpression").tap("Parser", expr => {
			const name = this.scope.renames.get("this");
			if (name) {
				const hook = this.hooks.evaluateIdentifier.get(name);
				if (hook !== void 0) {
					const result = hook.call(expr);
					if (result) return result;
				}
				return new BasicEvaluatedExpression()
					.setIdentifier(name)
					.setRange(expr.range);
			}
		});
		this.hooks.evaluate.for("MemberExpression").tap("Parser", expression => {
			let exprName = this.getNameForExpression(expression);
			if (exprName) {
				if (exprName.free) {
					const hook = this.hooks.evaluateIdentifier.get(exprName.name);
					if (hook !== void 0) {
						const result = hook.call(expression);
						if (result) return result;
					}
					return new BasicEvaluatedExpression()
						.setIdentifier(exprName.name)
						.setRange(expression.range);
				} else {
					const hook = this.hooks.evaluateDefinedIdentifier.get(exprName.name);
					if (hook !== void 0) {
						return hook.call(expression);
					}
				}
			}
		});
		this.hooks.evaluate.for("CallExpression").tap("Parser", expr => {
			if (expr.callee.type !== "MemberExpression") return;
			if (
				expr.callee.property.type !==
				(expr.callee.computed ? "Literal" : "Identifier")
			)
				return;
			const param = this.evaluateExpression(expr.callee.object);
			if (!param) return;
			const property = expr.callee.property.name || expr.callee.property.value;
			const hook = this.hooks.evaluateCallExpressionMember.get(property);
			if (hook !== void 0) {
				return hook.call(expr, param);
			}
		});
		this.hooks.evaluateCallExpressionMember
			.for("replace")
			.tap("Parser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 2) return;
				let arg1 = this.evaluateExpression(expr.arguments[0]);
				let arg2 = this.evaluateExpression(expr.arguments[1]);
				if (!arg1.isString() && !arg1.isRegExp()) return;
				arg1 = arg1.regExp || arg1.string;
				if (!arg2.isString()) return;
				arg2 = arg2.string;
				return new BasicEvaluatedExpression()
					.setString(param.string.replace(arg1, arg2))
					.setRange(expr.range);
			});
		["substr", "substring"].forEach(fn => {
			this.hooks.evaluateCallExpressionMember
				.for(fn)
				.tap("Parser", (expr, param) => {
					if (!param.isString()) return;
					let arg1,
						result,
						str = param.string;
					switch (expr.arguments.length) {
						case 1:
							arg1 = this.evaluateExpression(expr.arguments[0]);
							if (!arg1.isNumber()) return;
							result = str[fn](arg1.number);
							break;
						case 2:
							arg1 = this.evaluateExpression(expr.arguments[0]);
							const arg2 = this.evaluateExpression(expr.arguments[1]);
							if (!arg1.isNumber() || !arg2.isNumber()) return;
							result = str[fn](arg1.number, arg2.number);
							break;

						default:
							return;
					}
					return new BasicEvaluatedExpression()
						.setString(result)
						.setRange(expr.range);
				});
		});

		const getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {
			const quasis = [];
			const parts = [];

			for (let i = 0; i < templateLiteralExpr.quasis.length; i++) {
				const quasiExpr = templateLiteralExpr.quasis[i];
				const quasi = quasiExpr.value[kind];

				if (i > 0) {
					const prevExpr = parts[parts.length - 1];
					const expr = this.evaluateExpression(
						templateLiteralExpr.expressions[i - 1]
					);
					const exprAsString = expr.asString();
					if (typeof exprAsString == "string") {
						prevExpr.setString(prevExpr.string + exprAsString + quasi);
						prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);
						prevExpr.setExpression(void 0);
						continue;
					}
					parts.push(expr);
				}

				const part = new BasicEvaluatedExpression()
					.setString(quasi)
					.setRange(quasiExpr.range)
					.setExpression(quasiExpr);
				quasis.push(part);
				parts.push(part);
			}
			return {
				quasis,
				parts
			};
		};

		this.hooks.evaluate.for("TemplateLiteral").tap("Parser", node => {
			const { quasis, parts } = getSimplifiedTemplateResult("cooked", node);
			if (parts.length === 1) {
				return parts[0].setRange(node.range);
			}
			return new BasicEvaluatedExpression()
				.setTemplateString(quasis, parts, "cooked")
				.setRange(node.range);
		});
		this.hooks.evaluate.for("TaggedTemplateExpression").tap("Parser", node => {
			if (this.evaluateExpression(node.tag).identifier !== "String.raw") return;
			const { quasis, parts } = getSimplifiedTemplateResult("raw", node.quasi);
			if (parts.length === 1) {
				return parts[0].setRange(node.range);
			}
			return new BasicEvaluatedExpression()
				.setTemplateString(quasis, parts, "raw")
				.setRange(node.range);
		});

		this.hooks.evaluateCallExpressionMember
			.for("concat")
			.tap("Parser", (expr, param) => {
				if (!param.isString() && !param.isWrapped()) return;

				let stringSuffix = null;
				let hasUnknownParams = false;
				for (let i = expr.arguments.length - 1; i >= 0; i--) {
					const argExpr = this.evaluateExpression(expr.arguments[i]);
					if (!argExpr.isString() && !argExpr.isNumber()) {
						hasUnknownParams = true;
						break;
					}

					const value = argExpr.isString()
						? argExpr.string
						: "" + argExpr.number;

					const newString = value + (stringSuffix ? stringSuffix.string : "");
					const newRange = [
						argExpr.range[0],
						(stringSuffix || argExpr).range[1]
					];
					stringSuffix = new BasicEvaluatedExpression()
						.setString(newString)
						.setRange(newRange);
				}

				if (hasUnknownParams) {
					const prefix = param.isString() ? param : param.prefix;
					return new BasicEvaluatedExpression()
						.setWrapped(prefix, stringSuffix)
						.setRange(expr.range);
				} else if (param.isWrapped()) {
					const postfix = stringSuffix || param.postfix;
					return new BasicEvaluatedExpression()
						.setWrapped(param.prefix, postfix)
						.setRange(expr.range);
				} else {
					const newString =
						param.string + (stringSuffix ? stringSuffix.string : "");
					return new BasicEvaluatedExpression()
						.setString(newString)
						.setRange(expr.range);
				}
			});
		this.hooks.evaluateCallExpressionMember
			.for("split")
			.tap("Parser", (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 1) return;
				let result;
				const arg = this.evaluateExpression(expr.arguments[0]);
				if (arg.isString()) {
					result = param.string.split(arg.string);
				} else if (arg.isRegExp()) {
					result = param.string.split(arg.regExp);
				} else {
					return;
				}
				return new BasicEvaluatedExpression()
					.setArray(result)
					.setRange(expr.range);
			});
		this.hooks.evaluate.for("ConditionalExpression").tap("Parser", expr => {
			const condition = this.evaluateExpression(expr.test);
			const conditionValue = condition.asBool();
			let res;
			if (conditionValue === void 0) {
				const consequent = this.evaluateExpression(expr.consequent);
				const alternate = this.evaluateExpression(expr.alternate);
				if (!consequent || !alternate) return;
				res = new BasicEvaluatedExpression();
				if (consequent.isConditional()) {
					res.setOptions(consequent.options);
				} else {
					res.setOptions([consequent]);
				}
				if (alternate.isConditional()) {
					res.addOptions(alternate.options);
				} else {
					res.addOptions([alternate]);
				}
			} else {
				res = this.evaluateExpression(
					conditionValue ? expr.consequent : expr.alternate
				);
			}
			res.setRange(expr.range);
			return res;
		});
		this.hooks.evaluate.for("ArrayExpression").tap("Parser", expr => {
			const items = expr.elements.map(element => {
				return element !== null && this.evaluateExpression(element);
			});
			if (!items.every(Boolean)) return;
			return new BasicEvaluatedExpression()
				.setItems(items)
				.setRange(expr.range);
		});
	}

	getRenameIdentifier(expr) {
		const result = this.evaluateExpression(expr);
		if (result && result.isIdentifier()) {
			return result.identifier;
		}
	}

	walkClass(classy) {
		if (classy.superClass) this.walkExpression(classy.superClass);
		if (classy.body && classy.body.type === "ClassBody") {
			const wasTopLevel = this.scope.topLevelScope;
			this.scope.topLevelScope = false;
			for (const methodDefinition of classy.body.body) {
				if (methodDefinition.type === "MethodDefinition") {
					this.walkMethodDefinition(methodDefinition);
				}
			}
			this.scope.topLevelScope = wasTopLevel;
		}
	}

	walkMethodDefinition(methodDefinition) {
		if (methodDefinition.computed && methodDefinition.key) {
			this.walkExpression(methodDefinition.key);
		}
		if (methodDefinition.value) {
			this.walkExpression(methodDefinition.value);
		}
	}

	prewalkStatements(statements) {
		for (let index = 0, len = statements.length; index < len; index++) {
			const statement = statements[index];
			this.prewalkStatement(statement);
		}
	}

	blockPrewalkStatements(statements) {
		for (let index = 0, len = statements.length; index < len; index++) {
			const statement = statements[index];
			this.blockPrewalkStatement(statement);
		}
	}

	walkStatements(statements) {
		for (let index = 0, len = statements.length; index < len; index++) {
			const statement = statements[index];
			this.walkStatement(statement);
		}
	}

	prewalkStatement(statement) {
		switch (statement.type) {
			case "BlockStatement":
				this.prewalkBlockStatement(statement);
				break;
			case "DoWhileStatement":
				this.prewalkDoWhileStatement(statement);
				break;
			case "ExportAllDeclaration":
				this.prewalkExportAllDeclaration(statement);
				break;
			case "ExportDefaultDeclaration":
				this.prewalkExportDefaultDeclaration(statement);
				break;
			case "ExportNamedDeclaration":
				this.prewalkExportNamedDeclaration(statement);
				break;
			case "ForInStatement":
				this.prewalkForInStatement(statement);
				break;
			case "ForOfStatement":
				this.prewalkForOfStatement(statement);
				break;
			case "ForStatement":
				this.prewalkForStatement(statement);
				break;
			case "FunctionDeclaration":
				this.prewalkFunctionDeclaration(statement);
				break;
			case "IfStatement":
				this.prewalkIfStatement(statement);
				break;
			case "ImportDeclaration":
				this.prewalkImportDeclaration(statement);
				break;
			case "LabeledStatement":
				this.prewalkLabeledStatement(statement);
				break;
			case "SwitchStatement":
				this.prewalkSwitchStatement(statement);
				break;
			case "TryStatement":
				this.prewalkTryStatement(statement);
				break;
			case "VariableDeclaration":
				this.prewalkVariableDeclaration(statement);
				break;
			case "WhileStatement":
				this.prewalkWhileStatement(statement);
				break;
			case "WithStatement":
				this.prewalkWithStatement(statement);
				break;
		}
	}

	blockPrewalkStatement(statement) {
		switch (statement.type) {
			case "VariableDeclaration":
				this.blockPrewalkVariableDeclaration(statement);
				break;
			case "ExportDefaultDeclaration":
				this.blockPrewalkExportDefaultDeclaration(statement);
				break;
			case "ExportNamedDeclaration":
				this.blockPrewalkExportNamedDeclaration(statement);
				break;
			case "ClassDeclaration":
				this.blockPrewalkClassDeclaration(statement);
				break;
		}
	}

	walkStatement(statement) {
		if (this.hooks.statement.call(statement) !== void 0) return;
		switch (statement.type) {
			case "BlockStatement":
				this.walkBlockStatement(statement);
				break;
			case "ClassDeclaration":
				this.walkClassDeclaration(statement);
				break;
			case "DoWhileStatement":
				this.walkDoWhileStatement(statement);
				break;
			case "ExportDefaultDeclaration":
				this.walkExportDefaultDeclaration(statement);
				break;
			case "ExportNamedDeclaration":
				this.walkExportNamedDeclaration(statement);
				break;
			case "ExpressionStatement":
				this.walkExpressionStatement(statement);
				break;
			case "ForInStatement":
				this.walkForInStatement(statement);
				break;
			case "ForOfStatement":
				this.walkForOfStatement(statement);
				break;
			case "ForStatement":
				this.walkForStatement(statement);
				break;
			case "FunctionDeclaration":
				this.walkFunctionDeclaration(statement);
				break;
			case "IfStatement":
				this.walkIfStatement(statement);
				break;
			case "LabeledStatement":
				this.walkLabeledStatement(statement);
				break;
			case "ReturnStatement":
				this.walkReturnStatement(statement);
				break;
			case "SwitchStatement":
				this.walkSwitchStatement(statement);
				break;
			case "ThrowStatement":
				this.walkThrowStatement(statement);
				break;
			case "TryStatement":
				this.walkTryStatement(statement);
				break;
			case "VariableDeclaration":
				this.walkVariableDeclaration(statement);
				break;
			case "WhileStatement":
				this.walkWhileStatement(statement);
				break;
			case "WithStatement":
				this.walkWithStatement(statement);
				break;
		}
	}

	prewalkBlockStatement(statement) {
		this.prewalkStatements(statement.body);
	}

	walkBlockStatement(statement) {
		this.inBlockScope(() => {
			const body = statement.body;
			this.blockPrewalkStatements(body);
			this.walkStatements(body);
		});
	}

	walkExpressionStatement(statement) {
		this.walkExpression(statement.expression);
	}

	prewalkIfStatement(statement) {
		this.prewalkStatement(statement.consequent);
		if (statement.alternate) {
			this.prewalkStatement(statement.alternate);
		}
	}

	walkIfStatement(statement) {
		const result = this.hooks.statementIf.call(statement);
		if (result === void 0) {
			this.walkExpression(statement.test);
			this.walkStatement(statement.consequent);
			if (statement.alternate) {
				this.walkStatement(statement.alternate);
			}
		} else {
			if (result) {
				this.walkStatement(statement.consequent);
			} else if (statement.alternate) {
				this.walkStatement(statement.alternate);
			}
		}
	}

	prewalkLabeledStatement(statement) {
		this.prewalkStatement(statement.body);
	}

	walkLabeledStatement(statement) {
		const hook = this.hooks.label.get(statement.label.name);
		if (hook !== void 0) {
			const result = hook.call(statement);
			if (result === true) return;
		}
		this.walkStatement(statement.body);
	}

	prewalkWithStatement(statement) {
		this.prewalkStatement(statement.body);
	}

	walkWithStatement(statement) {
		this.walkExpression(statement.object);
		this.walkStatement(statement.body);
	}

	prewalkSwitchStatement(statement) {
		this.prewalkSwitchCases(statement.cases);
	}

	walkSwitchStatement(statement) {
		this.walkExpression(statement.discriminant);
		this.walkSwitchCases(statement.cases);
	}

	walkTerminatingStatement(statement) {
		if (statement.argument) this.walkExpression(statement.argument);
	}

	walkReturnStatement(statement) {
		this.walkTerminatingStatement(statement);
	}

	walkThrowStatement(statement) {
		this.walkTerminatingStatement(statement);
	}

	prewalkTryStatement(statement) {
		this.prewalkStatement(statement.block);
	}

	walkTryStatement(statement) {
		if (this.scope.inTry) {
			this.walkStatement(statement.block);
		} else {
			this.scope.inTry = true;
			this.walkStatement(statement.block);
			this.scope.inTry = false;
		}
		if (statement.handler) this.walkCatchClause(statement.handler);
		if (statement.finalizer) this.walkStatement(statement.finalizer);
	}

	prewalkWhileStatement(statement) {
		this.prewalkStatement(statement.body);
	}

	walkWhileStatement(statement) {
		this.walkExpression(statement.test);
		this.walkStatement(statement.body);
	}

	prewalkDoWhileStatement(statement) {
		this.prewalkStatement(statement.body);
	}

	walkDoWhileStatement(statement) {
		this.walkStatement(statement.body);
		this.walkExpression(statement.test);
	}

	prewalkForStatement(statement) {
		if (statement.init) {
			if (statement.init.type === "VariableDeclaration") {
				this.prewalkStatement(statement.init);
			}
		}
		this.prewalkStatement(statement.body);
	}

	walkForStatement(statement) {
		this.inBlockScope(() => {
			if (statement.init) {
				if (statement.init.type === "VariableDeclaration") {
					this.blockPrewalkVariableDeclaration(statement.init);
					this.walkStatement(statement.init);
				} else {
					this.walkExpression(statement.init);
				}
			}
			if (statement.test) {
				this.walkExpression(statement.test);
			}
			if (statement.update) {
				this.walkExpression(statement.update);
			}
			const body = statement.body;
			if (body.type === "BlockStatement") {
				this.blockPrewalkStatements(body.body);
				this.walkStatements(body.body);
			} else {
				this.walkStatement(body);
			}
		});
	}

	prewalkForInStatement(statement) {
		if (statement.left.type === "VariableDeclaration") {
			this.prewalkVariableDeclaration(statement.left);
		}
		this.prewalkStatement(statement.body);
	}

	walkForInStatement(statement) {
		this.inBlockScope(() => {
			if (statement.left.type === "VariableDeclaration") {
				this.blockPrewalkVariableDeclaration(statement.left);
				this.walkVariableDeclaration(statement.left);
			} else {
				this.walkPattern(statement.left);
			}
			this.walkExpression(statement.right);
			const body = statement.body;
			if (body.type === "BlockStatement") {
				this.blockPrewalkStatements(body.body);
				this.walkStatements(body.body);
			} else {
				this.walkStatement(body);
			}
		});
	}

	prewalkForOfStatement(statement) {
		if (statement.left.type === "VariableDeclaration") {
			this.prewalkVariableDeclaration(statement.left);
		}
		this.prewalkStatement(statement.body);
	}

	walkForOfStatement(statement) {
		this.inBlockScope(() => {
			if (statement.left.type === "VariableDeclaration") {
				this.blockPrewalkVariableDeclaration(statement.left);
				this.walkVariableDeclaration(statement.left);
			} else {
				this.walkPattern(statement.left);
			}
			this.walkExpression(statement.right);
			const body = statement.body;
			if (body.type === "BlockStatement") {
				this.blockPrewalkStatements(body.body);
				this.walkStatements(body.body);
			} else {
				this.walkStatement(body);
			}
		});
	}

	prewalkFunctionDeclaration(statement) {
		if (statement.id) {
			this.scope.renames.set(statement.id.name, null);
			this.scope.definitions.add(statement.id.name);
		}
	}

	walkFunctionDeclaration(statement) {
		const wasTopLevel = this.scope.topLevelScope;
		this.scope.topLevelScope = false;
		this.inFunctionScope(true, statement.params, () => {
			for (const param of statement.params) {
				this.walkPattern(param);
			}
			if (statement.body.type === "BlockStatement") {
				this.detectMode(statement.body.body);
				this.prewalkStatement(statement.body);
				this.walkStatement(statement.body);
			} else {
				this.walkExpression(statement.body);
			}
		});
		this.scope.topLevelScope = wasTopLevel;
	}

	prewalkImportDeclaration(statement) {
		const source = statement.source.value;
		this.hooks.import.call(statement, source);
		for (const specifier of statement.specifiers) {
			const name = specifier.local.name;
			this.scope.renames.set(name, null);
			this.scope.definitions.add(name);
			switch (specifier.type) {
				case "ImportDefaultSpecifier":
					this.hooks.importSpecifier.call(statement, source, "default", name);
					break;
				case "ImportSpecifier":
					this.hooks.importSpecifier.call(
						statement,
						source,
						specifier.imported.name,
						name
					);
					break;
				case "ImportNamespaceSpecifier":
					this.hooks.importSpecifier.call(statement, source, null, name);
					break;
			}
		}
	}

	enterDeclaration(declaration, onIdent) {
		switch (declaration.type) {
			case "VariableDeclaration":
				for (const declarator of declaration.declarations)
					switch (declarator.type) {
						case "VariableDeclarator":
							this.enterPattern(declarator.id, onIdent);
							break;
					}

				break;
			case "FunctionDeclaration":
				this.enterPattern(declaration.id, onIdent);
				break;
			case "ClassDeclaration":
				this.enterPattern(declaration.id, onIdent);
				break;
		}
	}

	blockPrewalkExportNamedDeclaration(statement) {
		if (statement.declaration) {
			this.blockPrewalkStatement(statement.declaration);
		}
	}

	prewalkExportNamedDeclaration(statement) {
		let source;
		if (statement.source) {
			source = statement.source.value;
			this.hooks.exportImport.call(statement, source);
		} else {
			this.hooks.export.call(statement);
		}
		if (statement.declaration) {
			if (
				!this.hooks.exportDeclaration.call(statement, statement.declaration)
			) {
				this.prewalkStatement(statement.declaration);
				let index = 0;
				this.enterDeclaration(statement.declaration, def => {
					this.hooks.exportSpecifier.call(statement, def, def, index++);
				});
			}
		}
		if (statement.specifiers)
			for (
				let specifierIndex = 0;
				specifierIndex < statement.specifiers.length;
				specifierIndex++
			) {
				const specifier = statement.specifiers[specifierIndex];
				switch (specifier.type) {
					case "ExportSpecifier":
						const name = specifier.exported.name;
						if (source) {
							this.hooks.exportImportSpecifier.call(
								statement,
								source,
								specifier.local.name,
								name,
								specifierIndex
							);
						} else {
							this.hooks.exportSpecifier.call(
								statement,
								specifier.local.name,
								name,
								specifierIndex
							);
						}
						break;
				}
			}
	}

	walkExportNamedDeclaration(statement) {
		statement.declaration && this.walkStatement(statement.declaration);
	}

	blockPrewalkExportDefaultDeclaration(statement) {
		if (statement.declaration.type === "ClassDeclaration") {
			this.blockPrewalkClassDeclaration(statement.declaration);
		}
	}

	prewalkExportDefaultDeclaration(statement) {
		this.prewalkStatement(statement.declaration);
		if (
			statement.declaration.id &&
			statement.declaration.type !== "FunctionExpression" &&
			statement.declaration.type !== "ClassExpression"
		) {
			this.hooks.exportSpecifier.call(
				statement,
				statement.declaration.id.name,
				"default"
			);
		}
	}

	walkExportDefaultDeclaration(statement) {
		this.hooks.export.call(statement);
		if (
			statement.declaration.id &&
			statement.declaration.type !== "FunctionExpression" &&
			statement.declaration.type !== "ClassExpression"
		) {
			if (
				!this.hooks.exportDeclaration.call(statement, statement.declaration)
			) {
				this.walkStatement(statement.declaration);
			}
		} else {
			if (statement.declaration.type === "FunctionDeclaration") {
				this.walkFunctionDeclaration(statement.declaration);
			} else if (statement.declaration.type === "ClassDeclaration") {
				this.walkClassDeclaration(statement.declaration);
			} else {
				this.walkExpression(statement.declaration);
			}
			if (!this.hooks.exportExpression.call(statement, statement.declaration)) {
				this.hooks.exportSpecifier.call(
					statement,
					statement.declaration,
					"default"
				);
			}
		}
	}

	prewalkExportAllDeclaration(statement) {
		const source = statement.source.value;
		this.hooks.exportImport.call(statement, source);
		this.hooks.exportImportSpecifier.call(statement, source, null, null, 0);
	}

	prewalkVariableDeclaration(statement) {
		if (statement.kind !== "var") return;
		this._prewalkVariableDeclaration(statement, this.hooks.varDeclarationVar);
	}

	blockPrewalkVariableDeclaration(statement) {
		if (statement.kind === "var") return;
		const hookMap =
			statement.kind === "const"
				? this.hooks.varDeclarationConst
				: this.hooks.varDeclarationLet;
		this._prewalkVariableDeclaration(statement, hookMap);
	}

	_prewalkVariableDeclaration(statement, hookMap) {
		for (const declarator of statement.declarations)
			switch (declarator.type) {
				case "VariableDeclarator":
					this.enterPattern(declarator.id, (name, decl) => {
						let hook = hookMap.get(name);
						if (hook === void 0 || !hook.call(decl)) {
							hook = this.hooks.varDeclaration.get(name);
							if (hook === void 0 || !hook.call(decl)) {
								this.scope.renames.set(name, null);
								this.scope.definitions.add(name);
							}
						}
					});
					break;
			}
	}

	walkVariableDeclaration(statement) {
		for (const declarator of statement.declarations)
			switch (declarator.type) {
				case "VariableDeclarator":
					const renameIdentifier =
						declarator.init && this.getRenameIdentifier(declarator.init);
					if (renameIdentifier && declarator.id.type === "Identifier") {
						const hook = this.hooks.canRename.get(renameIdentifier);
						if (hook !== void 0 && hook.call(declarator.init)) {
							const hook = this.hooks.rename.get(renameIdentifier);
							if (hook === void 0 || !hook.call(declarator.init)) {
								this.scope.renames.set(
									declarator.id.name,
									this.scope.renames.get(renameIdentifier) || renameIdentifier
								);
								this.scope.definitions.delete(declarator.id.name);
							}
							break;
						}
					}
					this.walkPattern(declarator.id);
					if (declarator.init) this.walkExpression(declarator.init);
					break;
			}
	}

	blockPrewalkClassDeclaration(statement) {
		if (statement.id) {
			this.scope.renames.set(statement.id.name, null);
			this.scope.definitions.add(statement.id.name);
		}
	}

	walkClassDeclaration(statement) {
		this.walkClass(statement);
	}

	prewalkSwitchCases(switchCases) {
		for (let index = 0, len = switchCases.length; index < len; index++) {
			const switchCase = switchCases[index];
			this.prewalkStatements(switchCase.consequent);
		}
	}

	walkSwitchCases(switchCases) {
		for (let index = 0, len = switchCases.length; index < len; index++) {
			const switchCase = switchCases[index];

			if (switchCase.test) {
				this.walkExpression(switchCase.test);
			}
			this.walkStatements(switchCase.consequent);
		}
	}

	walkCatchClause(catchClause) {
		this.inBlockScope(() => {
			if (catchClause.param !== null) {
				this.enterPattern(catchClause.param, ident => {
					this.scope.renames.set(ident, null);
					this.scope.definitions.add(ident);
				});
				this.walkPattern(catchClause.param);
			}
			this.prewalkStatement(catchClause.body);
			this.walkStatement(catchClause.body);
		});
	}

	walkPattern(pattern) {
		switch (pattern.type) {
			case "ArrayPattern":
				this.walkArrayPattern(pattern);
				break;
			case "AssignmentPattern":
				this.walkAssignmentPattern(pattern);
				break;
			case "MemberExpression":
				this.walkMemberExpression(pattern);
				break;
			case "ObjectPattern":
				this.walkObjectPattern(pattern);
				break;
			case "RestElement":
				this.walkRestElement(pattern);
				break;
		}
	}

	walkAssignmentPattern(pattern) {
		this.walkExpression(pattern.right);
		this.walkPattern(pattern.left);
	}

	walkObjectPattern(pattern) {
		for (let i = 0, len = pattern.properties.length; i < len; i++) {
			const prop = pattern.properties[i];
			if (prop) {
				if (prop.computed) this.walkExpression(prop.key);
				if (prop.value) this.walkPattern(prop.value);
			}
		}
	}

	walkArrayPattern(pattern) {
		for (let i = 0, len = pattern.elements.length; i < len; i++) {
			const element = pattern.elements[i];
			if (element) this.walkPattern(element);
		}
	}

	walkRestElement(pattern) {
		this.walkPattern(pattern.argument);
	}

	walkExpressions(expressions) {
		for (const expression of expressions) {
			if (expression) {
				this.walkExpression(expression);
			}
		}
	}

	walkExpression(expression) {
		switch (expression.type) {
			case "ArrayExpression":
				this.walkArrayExpression(expression);
				break;
			case "ArrowFunctionExpression":
				this.walkArrowFunctionExpression(expression);
				break;
			case "AssignmentExpression":
				this.walkAssignmentExpression(expression);
				break;
			case "AwaitExpression":
				this.walkAwaitExpression(expression);
				break;
			case "BinaryExpression":
				this.walkBinaryExpression(expression);
				break;
			case "CallExpression":
				this.walkCallExpression(expression);
				break;
			case "ClassExpression":
				this.walkClassExpression(expression);
				break;
			case "ConditionalExpression":
				this.walkConditionalExpression(expression);
				break;
			case "FunctionExpression":
				this.walkFunctionExpression(expression);
				break;
			case "Identifier":
				this.walkIdentifier(expression);
				break;
			case "LogicalExpression":
				this.walkLogicalExpression(expression);
				break;
			case "MemberExpression":
				this.walkMemberExpression(expression);
				break;
			case "NewExpression":
				this.walkNewExpression(expression);
				break;
			case "ObjectExpression":
				this.walkObjectExpression(expression);
				break;
			case "SequenceExpression":
				this.walkSequenceExpression(expression);
				break;
			case "SpreadElement":
				this.walkSpreadElement(expression);
				break;
			case "TaggedTemplateExpression":
				this.walkTaggedTemplateExpression(expression);
				break;
			case "TemplateLiteral":
				this.walkTemplateLiteral(expression);
				break;
			case "ThisExpression":
				this.walkThisExpression(expression);
				break;
			case "UnaryExpression":
				this.walkUnaryExpression(expression);
				break;
			case "UpdateExpression":
				this.walkUpdateExpression(expression);
				break;
			case "YieldExpression":
				this.walkYieldExpression(expression);
				break;
		}
	}

	walkAwaitExpression(expression) {
		this.walkExpression(expression.argument);
	}

	walkArrayExpression(expression) {
		if (expression.elements) {
			this.walkExpressions(expression.elements);
		}
	}

	walkSpreadElement(expression) {
		if (expression.argument) {
			this.walkExpression(expression.argument);
		}
	}

	walkObjectExpression(expression) {
		for (
			let propIndex = 0, len = expression.properties.length;
			propIndex < len;
			propIndex++
		) {
			const prop = expression.properties[propIndex];
			if (prop.type === "SpreadElement") {
				this.walkExpression(prop.argument);
				continue;
			}
			if (prop.computed) {
				this.walkExpression(prop.key);
			}
			if (prop.shorthand) {
				this.scope.inShorthand = true;
			}
			this.walkExpression(prop.value);
			if (prop.shorthand) {
				this.scope.inShorthand = false;
			}
		}
	}

	walkFunctionExpression(expression) {
		const wasTopLevel = this.scope.topLevelScope;
		this.scope.topLevelScope = false;
		const scopeParams = expression.params;

		if (expression.id) {
			scopeParams.push(expression.id.name);
		}

		this.inFunctionScope(true, scopeParams, () => {
			for (const param of expression.params) {
				this.walkPattern(param);
			}
			if (expression.body.type === "BlockStatement") {
				this.detectMode(expression.body.body);
				this.prewalkStatement(expression.body);
				this.walkStatement(expression.body);
			} else {
				this.walkExpression(expression.body);
			}
		});
		this.scope.topLevelScope = wasTopLevel;
	}

	walkArrowFunctionExpression(expression) {
		this.inFunctionScope(false, expression.params, () => {
			for (const param of expression.params) {
				this.walkPattern(param);
			}
			if (expression.body.type === "BlockStatement") {
				this.detectMode(expression.body.body);
				this.prewalkStatement(expression.body);
				this.walkStatement(expression.body);
			} else {
				this.walkExpression(expression.body);
			}
		});
	}

	walkSequenceExpression(expression) {
		if (expression.expressions) this.walkExpressions(expression.expressions);
	}

	walkUpdateExpression(expression) {
		this.walkExpression(expression.argument);
	}

	walkUnaryExpression(expression) {
		if (expression.operator === "typeof") {
			const exprName = this.getNameForExpression(expression.argument);
			if (exprName && exprName.free) {
				const hook = this.hooks.typeof.get(exprName.name);
				if (hook !== void 0) {
					const result = hook.call(expression);
					if (result === true) return;
				}
			}
		}
		this.walkExpression(expression.argument);
	}

	walkLeftRightExpression(expression) {
		this.walkExpression(expression.left);
		this.walkExpression(expression.right);
	}

	walkBinaryExpression(expression) {
		this.walkLeftRightExpression(expression);
	}

	walkLogicalExpression(expression) {
		const result = this.hooks.expressionLogicalOperator.call(expression);
		if (result === void 0) {
			this.walkLeftRightExpression(expression);
		} else {
			if (result) {
				this.walkExpression(expression.right);
			}
		}
	}

	walkAssignmentExpression(expression) {
		const renameIdentifier = this.getRenameIdentifier(expression.right);
		if (expression.left.type === "Identifier" && renameIdentifier) {
			const hook = this.hooks.canRename.get(renameIdentifier);
			if (hook !== void 0 && hook.call(expression.right)) {
				const hook = this.hooks.rename.get(renameIdentifier);
				if (hook === void 0 || !hook.call(expression.right)) {
					this.scope.renames.set(expression.left.name, renameIdentifier);
					this.scope.definitions.delete(expression.left.name);
				}
				return;
			}
		}
		if (expression.left.type === "Identifier") {
			const assignedHook = this.hooks.assigned.get(expression.left.name);
			if (assignedHook === void 0 || !assignedHook.call(expression)) {
				this.walkExpression(expression.right);
			}
			this.scope.renames.set(expression.left.name, null);
			const assignHook = this.hooks.assign.get(expression.left.name);
			if (assignHook === void 0 || !assignHook.call(expression)) {
				this.walkExpression(expression.left);
			}
			return;
		}
		this.walkExpression(expression.right);
		this.walkPattern(expression.left);
		this.enterPattern(expression.left, (name, decl) => {
			this.scope.renames.set(name, null);
		});
	}

	walkConditionalExpression(expression) {
		const result = this.hooks.expressionConditionalOperator.call(expression);
		if (result === void 0) {
			this.walkExpression(expression.test);
			this.walkExpression(expression.consequent);
			if (expression.alternate) {
				this.walkExpression(expression.alternate);
			}
		} else {
			if (result) {
				this.walkExpression(expression.consequent);
			} else if (expression.alternate) {
				this.walkExpression(expression.alternate);
			}
		}
	}

	walkNewExpression(expression) {
		const callee = this.evaluateExpression(expression.callee);
		if (callee.isIdentifier()) {
			const hook = this.hooks.new.get(callee.identifier);
			if (hook !== void 0) {
				const result = hook.call(expression);
				if (result === true) {
					return;
				}
			}
		}

		this.walkExpression(expression.callee);
		if (expression.arguments) {
			this.walkExpressions(expression.arguments);
		}
	}

	walkYieldExpression(expression) {
		if (expression.argument) {
			this.walkExpression(expression.argument);
		}
	}

	walkTemplateLiteral(expression) {
		if (expression.expressions) {
			this.walkExpressions(expression.expressions);
		}
	}

	walkTaggedTemplateExpression(expression) {
		if (expression.tag) {
			this.walkExpression(expression.tag);
		}
		if (expression.quasi && expression.quasi.expressions) {
			this.walkExpressions(expression.quasi.expressions);
		}
	}

	walkClassExpression(expression) {
		this.walkClass(expression);
	}

	_walkIIFE(functionExpression, options, currentThis) {
		const renameArgOrThis = argOrThis => {
			const renameIdentifier = this.getRenameIdentifier(argOrThis);
			if (renameIdentifier) {
				const hook = this.hooks.canRename.get(renameIdentifier);
				if (hook !== void 0 && hook.call(argOrThis)) {
					const hook = this.hooks.rename.get(renameIdentifier);
					if (hook === void 0 || !hook.call(argOrThis)) {
						return renameIdentifier;
					}
				}
			}
			this.walkExpression(argOrThis);
		};
		const params = functionExpression.params;
		const renameThis = currentThis ? renameArgOrThis(currentThis) : null;
		const args = options.map(renameArgOrThis);
		const wasTopLevel = this.scope.topLevelScope;
		this.scope.topLevelScope = false;
		const scopeParams = params.filter((identifier, idx) => !args[idx]);

		if (functionExpression.id) {
			scopeParams.push(functionExpression.id.name);
		}

		this.inFunctionScope(true, scopeParams, () => {
			if (renameThis) {
				this.scope.renames.set("this", renameThis);
			}
			for (let i = 0; i < args.length; i++) {
				const param = args[i];
				if (!param) continue;
				if (!params[i] || params[i].type !== "Identifier") continue;
				this.scope.renames.set(params[i].name, param);
			}
			if (functionExpression.body.type === "BlockStatement") {
				this.detectMode(functionExpression.body.body);
				this.prewalkStatement(functionExpression.body);
				this.walkStatement(functionExpression.body);
			} else {
				this.walkExpression(functionExpression.body);
			}
		});
		this.scope.topLevelScope = wasTopLevel;
	}

	walkCallExpression(expression) {
		if (
			expression.callee.type === "MemberExpression" &&
			expression.callee.object.type === "FunctionExpression" &&
			!expression.callee.computed &&
			(expression.callee.property.name === "call" ||
				expression.callee.property.name === "bind") &&
			expression.arguments.length > 0
		) {
			this._walkIIFE(
				expression.callee.object,
				expression.arguments.slice(1),
				expression.arguments[0]
			);
		} else if (expression.callee.type === "FunctionExpression") {
			this._walkIIFE(expression.callee, expression.arguments, null);
		} else if (expression.callee.type === "Import") {
			let result = this.hooks.importCall.call(expression);
			if (result === true) return;

			if (expression.arguments) this.walkExpressions(expression.arguments);
		} else {
			const callee = this.evaluateExpression(expression.callee);
			if (callee.isIdentifier()) {
				const callHook = this.hooks.call.get(callee.identifier);
				if (callHook !== void 0) {
					let result = callHook.call(expression);
					if (result === true) return;
				}
				let identifier = callee.identifier.replace(/\.[^.]+$/, "");
				if (identifier !== callee.identifier) {
					const callAnyHook = this.hooks.callAnyMember.get(identifier);
					if (callAnyHook !== void 0) {
						let result = callAnyHook.call(expression);
						if (result === true) return;
					}
				}
			}

			if (expression.callee) this.walkExpression(expression.callee);
			if (expression.arguments) this.walkExpressions(expression.arguments);
		}
	}

	walkMemberExpression(expression) {
		const exprName = this.getNameForExpression(expression);
		if (exprName && exprName.free) {
			const expressionHook = this.hooks.expression.get(exprName.name);
			if (expressionHook !== void 0) {
				const result = expressionHook.call(expression);
				if (result === true) return;
			}
			const expressionAnyMemberHook = this.hooks.expressionAnyMember.get(
				exprName.nameGeneral
			);
			if (expressionAnyMemberHook !== void 0) {
				const result = expressionAnyMemberHook.call(expression);
				if (result === true) return;
			}
		}
		this.walkExpression(expression.object);
		if (expression.computed === true) this.walkExpression(expression.property);
	}

	walkThisExpression(expression) {
		const expressionHook = this.hooks.expression.get("this");
		if (expressionHook !== void 0) {
			expressionHook.call(expression);
		}
	}

	walkIdentifier(expression) {
		if (!this.scope.definitions.has(expression.name)) {
			const hook = this.hooks.expression.get(
				this.scope.renames.get(expression.name) || expression.name
			);
			if (hook !== void 0) {
				const result = hook.call(expression);
				if (result === true) return;
			}
		}
	}

	inScope(params, fn) {
		const oldScope = this.scope;
		this.scope = {
			topLevelScope: oldScope.topLevelScope,
			inTry: false,
			inShorthand: false,
			isStrict: oldScope.isStrict,
			isAsmJs: oldScope.isAsmJs,
			definitions: oldScope.definitions.createChild(),
			renames: oldScope.renames.createChild()
		};

		this.scope.renames.set("this", null);

		this.enterPatterns(params, ident => {
			this.scope.renames.set(ident, null);
			this.scope.definitions.add(ident);
		});

		fn();

		this.scope = oldScope;
	}

	inFunctionScope(hasThis, params, fn) {
		const oldScope = this.scope;
		this.scope = {
			topLevelScope: oldScope.topLevelScope,
			inTry: false,
			inShorthand: false,
			isStrict: oldScope.isStrict,
			isAsmJs: oldScope.isAsmJs,
			definitions: oldScope.definitions.createChild(),
			renames: oldScope.renames.createChild()
		};

		if (hasThis) {
			this.scope.renames.set("this", null);
		}

		this.enterPatterns(params, ident => {
			this.scope.renames.set(ident, null);
			this.scope.definitions.add(ident);
		});

		fn();

		this.scope = oldScope;
	}

	inBlockScope(fn) {
		const oldScope = this.scope;
		this.scope = {
			topLevelScope: oldScope.topLevelScope,
			inTry: oldScope.inTry,
			inShorthand: false,
			isStrict: oldScope.isStrict,
			isAsmJs: oldScope.isAsmJs,
			definitions: oldScope.definitions.createChild(),
			renames: oldScope.renames.createChild()
		};

		fn();

		this.scope = oldScope;
	}

	detectStrictMode(statements) {
		this.detectMode(statements);
	}

	detectMode(statements) {
		const isLiteral =
			statements.length >= 1 &&
			statements[0].type === "ExpressionStatement" &&
			statements[0].expression.type === "Literal";
		if (isLiteral && statements[0].expression.value === "use strict") {
			this.scope.isStrict = true;
		}
		if (isLiteral && statements[0].expression.value === "use asm") {
			this.scope.isAsmJs = true;
		}
	}

	enterPatterns(patterns, onIdent) {
		for (const pattern of patterns) {
			if (typeof pattern != "string") {
				this.enterPattern(pattern, onIdent);
			} else if (pattern) {
				onIdent(pattern);
			}
		}
	}

	enterPattern(pattern, onIdent) {
		if (!pattern) return;
		switch (pattern.type) {
			case "ArrayPattern":
				this.enterArrayPattern(pattern, onIdent);
				break;
			case "AssignmentPattern":
				this.enterAssignmentPattern(pattern, onIdent);
				break;
			case "Identifier":
				this.enterIdentifier(pattern, onIdent);
				break;
			case "ObjectPattern":
				this.enterObjectPattern(pattern, onIdent);
				break;
			case "RestElement":
				this.enterRestElement(pattern, onIdent);
				break;
			case "Property":
				this.enterPattern(pattern.value, onIdent);
				break;
		}
	}

	enterIdentifier(pattern, onIdent) {
		onIdent(pattern.name, pattern);
	}

	enterObjectPattern(pattern, onIdent) {
		for (
			let propIndex = 0, len = pattern.properties.length;
			propIndex < len;
			propIndex++
		) {
			const prop = pattern.properties[propIndex];
			this.enterPattern(prop, onIdent);
		}
	}

	enterArrayPattern(pattern, onIdent) {
		for (
			let elementIndex = 0, len = pattern.elements.length;
			elementIndex < len;
			elementIndex++
		) {
			const element = pattern.elements[elementIndex];
			this.enterPattern(element, onIdent);
		}
	}

	enterRestElement(pattern, onIdent) {
		this.enterPattern(pattern.argument, onIdent);
	}

	enterAssignmentPattern(pattern, onIdent) {
		this.enterPattern(pattern.left, onIdent);
	}

	evaluateExpression(expression) {
		try {
			const hook = this.hooks.evaluate.get(expression.type);
			if (hook !== void 0) {
				const result = hook.call(expression);
				if (result !== void 0) {
					if (result) {
						result.setExpression(expression);
					}
					return result;
				}
			}
		} catch (e) {
			console.warn(e);
		}
		return new BasicEvaluatedExpression()
			.setRange(expression.range)
			.setExpression(expression);
	}

	parseString(expression) {
		switch (expression.type) {
			case "BinaryExpression":
				if (expression.operator === "+") {
					return (
						this.parseString(expression.left) +
						this.parseString(expression.right)
					);
				}
				break;
			case "Literal":
				return expression.value + "";
		}
		throw new Error(
			expression.type + " is not supported as parameter for require"
		);
	}

	parseCalculatedString(expression) {
		switch (expression.type) {
			case "BinaryExpression":
				if (expression.operator === "+") {
					const left = this.parseCalculatedString(expression.left),
						right = this.parseCalculatedString(expression.right);
					if (left.code)
						return {
							range: left.range,
							value: left.value,
							code: true,
							conditional: false
						};
					if (right.code)
						return {
							range: [
								left.range[0],
								right.range ? right.range[1] : left.range[1]
							],
							value: left.value + right.value,
							code: true,
							conditional: false
						};

					return {
						range: [left.range[0], right.range[1]],
						value: left.value + right.value,
						code: false,
						conditional: false
					};
				}
				break;
			case "ConditionalExpression":
				const consequent = this.parseCalculatedString(expression.consequent),
					alternate = this.parseCalculatedString(expression.alternate),
					items = [];
				if (consequent.conditional) items.push(...consequent.conditional);
				else if (!consequent.code) items.push(consequent);
				else break;

				if (alternate.conditional) items.push(...alternate.conditional);
				else if (!alternate.code) items.push(alternate);
				else break;

				return { range: void 0, value: "", code: true, conditional: items };

			case "Literal":
				return {
					range: expression.range,
					value: expression.value + "",
					code: false,
					conditional: false
				};
		}
		return { range: void 0, value: "", code: true, conditional: false };
	}

	parse(source, initialState) {
		let ast;
		let comments;
		if (typeof source == "object" && source !== null) {
			ast = source;
			comments = source.comments;
		} else {
			comments = [];
			ast = Parser.parse(source, {
				sourceType: this.sourceType,
				onComment: comments
			});
		}

		const oldScope = this.scope;
		const oldState = this.state;
		const oldComments = this.comments;
		this.scope = {
			topLevelScope: true,
			inTry: false,
			inShorthand: false,
			isStrict: false,
			isAsmJs: false,
			definitions: new StackedSetMap(),
			renames: new StackedSetMap()
		};
		const state = (this.state = initialState || {});
		this.comments = comments;
		if (this.hooks.program.call(ast, comments) === void 0) {
			this.detectMode(ast.body);
			this.prewalkStatements(ast.body);
			this.blockPrewalkStatements(ast.body);
			this.walkStatements(ast.body);
		}
		this.scope = oldScope;
		this.state = oldState;
		this.comments = oldComments;
		return state;
	}

	evaluate(source) {
		const ast = Parser.parse("(" + source + ")", {
			sourceType: this.sourceType,
			locations: false
		});
		if (ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement") {
			throw new Error("evaluate: Source is not a expression");
		}
		return this.evaluateExpression(ast.body[0].expression);
	}

	getComments(range) {
		return this.comments.filter(
			comment => comment.range[0] >= range[0] && comment.range[1] <= range[1]
		);
	}

	parseCommentOptions(range) {
		const comments = this.getComments(range);
		if (comments.length === 0) {
			return EMPTY_COMMENT_OPTIONS;
		}
		let options = {};
		let errors = [];
		for (const comment of comments) {
			const { value } = comment;
			if (value && webpackCommentRegExp.test(value)) {
				try {
					const val = vm.runInNewContext(`(function(){return {${value}};})()`);
					Object.assign(options, val);
				} catch (e) {
					e.comment = comment;
					errors.push(e);
				}
			}
		}
		return { options, errors };
	}

	getNameForExpression(expression) {
		let expr = expression;
		const exprName = [];
		while (
			expr.type === "MemberExpression" &&
			expr.property.type === (expr.computed ? "Literal" : "Identifier")
		) {
			exprName.push(expr.computed ? expr.property.value : expr.property.name);
			expr = expr.object;
		}
		let free;
		if (expr.type === "Identifier") {
			free = !this.scope.definitions.has(expr.name);
			exprName.push(this.scope.renames.get(expr.name) || expr.name);
		} else if (
			expr.type === "ThisExpression" &&
			this.scope.renames.get("this")
		) {
			free = true;
			exprName.push(this.scope.renames.get("this"));
		} else if (expr.type === "ThisExpression") {
			free = this.scope.topLevelScope;
			exprName.push("this");
		} else {
			return null;
		}
		let prefix = "";
		for (let i = exprName.length - 1; i >= 2; i--) {
			prefix += exprName[i] + ".";
		}
		if (exprName.length > 1) {
			prefix += exprName[1];
		}
		const name = prefix ? prefix + "." + exprName[0] : exprName[0];
		const nameGeneral = prefix;
		return {
			name,
			nameGeneral,
			free
		};
	}

	static parse(code, options) {
		const type = options ? options.sourceType : "module";
		const parserOptions = Object.assign(
			Object.create(null),
			defaultParserOptions,
			options
		);

		if (type === "auto") {
			parserOptions.sourceType = "module";
		} else if (parserOptions.sourceType === "script") {
			parserOptions.allowReturnOutsideFunction = true;
		}

		let ast;
		let error;
		let threw = false;
		try {
			ast = acornParser.parse(code, parserOptions);
		} catch (e) {
			error = e;
			threw = true;
		}

		if (threw && type === "auto") {
			parserOptions.sourceType = "script";
			parserOptions.allowReturnOutsideFunction = true;
			if (Array.isArray(parserOptions.onComment)) {
				parserOptions.onComment.length = 0;
			}
			try {
				ast = acornParser.parse(code, parserOptions);
				threw = false;
			} catch (e) {
				threw = true;
			}
		}

		if (threw) {
			throw error;
		}

		return ast;
	}
}

Object.defineProperty(Parser.prototype, "getCommentOptions", {
	configurable: false,
	value: util.deprecate(
		function(range) {
			return this.parseCommentOptions(range).options;
		},
		"Parser.getCommentOptions: Use Parser.parseCommentOptions(range) instead"
	)
});

module.exports = Parser;

},
// 84
function(module, exports, __webpack_require__) {

const util = __webpack_require__(11);

const TOMBSTONE = {};
const UNDEFINED_MARKER = {};

class StackedSetMap {
	constructor(parentStack) {
		this.stack = parentStack === void 0 ? [] : parentStack.slice();
		this.map = new Map();
		this.stack.push(this.map);
	}

	add(item) {
		this.map.set(item, true);
	}

	set(item, value) {
		this.map.set(item, value === void 0 ? UNDEFINED_MARKER : value);
	}

	delete(item) {
		if (this.stack.length > 1) {
			this.map.set(item, TOMBSTONE);
		} else {
			this.map.delete(item);
		}
	}

	has(item) {
		const topValue = this.map.get(item);
		if (topValue !== void 0) return topValue !== TOMBSTONE;
		if (this.stack.length > 1) {
			for (var i = this.stack.length - 2; i >= 0; i--) {
				const value = this.stack[i].get(item);
				if (value !== void 0) {
					this.map.set(item, value);
					return value !== TOMBSTONE;
				}
			}
			this.map.set(item, TOMBSTONE);
		}
		return false;
	}

	get(item) {
		const topValue = this.map.get(item);
		if (topValue !== void 0) {
			return topValue === TOMBSTONE || topValue === UNDEFINED_MARKER
				? void 0
				: topValue;
		}
		if (this.stack.length > 1) {
			for (var i = this.stack.length - 2; i >= 0; i--) {
				const value = this.stack[i].get(item);
				if (value !== void 0) {
					this.map.set(item, value);
					return value === TOMBSTONE || value === UNDEFINED_MARKER
						? void 0
						: value;
				}
			}
			this.map.set(item, TOMBSTONE);
		}
		return void 0;
	}

	_compress() {
		if (this.stack.length === 1) return;
		this.map = new Map();
		for (const data of this.stack) {
			for (const pair of data) {
				if (pair[1] === TOMBSTONE) {
					this.map.delete(pair[0]);
				} else {
					this.map.set(pair[0], pair[1]);
				}
			}
		}
		this.stack = [this.map];
	}

	asArray() {
		this._compress();
		return Array.from(this.map.entries(), pair => pair[0]);
	}

	asSet() {
		return new Set(this.asArray());
	}

	asPairArray() {
		this._compress();
		return Array.from(this.map.entries(), pair =>
			(pair[1] === UNDEFINED_MARKER
				? [pair[0], void 0]
				: pair)
		);
	}

	asMap() {
		return new Map(this.asPairArray());
	}

	get size() {
		this._compress();
		return this.map.size;
	}

	createChild() {
		return new StackedSetMap(this.stack);
	}

	get length() {
		throw new Error("This is no longer an Array");
	}

	set length(value) {
		throw new Error("This is no longer an Array");
	}
}

StackedSetMap.prototype.push = util.deprecate(
	function(item) {
		this.add(item);
	},
	"This is no longer an Array: Use add instead."
);

module.exports = StackedSetMap;

},
// 85
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);

module.exports = class extends WebpackError {
	constructor(message) {
		super(message);
		this.name = "UnsupportedWebAssemblyFeatureError";
		this.hideStack = true;

		Error.captureStackTrace(this, this.constructor);
	}
};

},
// 86
function(module) {

module.exports = require("../vendor/wasm-parser");

},
// 87
function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
exports.moduleContextFromModuleAST = moduleContextFromModuleAST;
exports.ModuleContext = void 0;

var _ast = __webpack_require__(59);

function moduleContextFromModuleAST(m) {
	var moduleContext = new ModuleContext();

	if (m.type !== "Module") throw new Error('m.type === "Module" error: unknown');

	m.fields.forEach(function(field) {
		switch (field.type) {
			case "Start":
				moduleContext.setStart(field.index);
				break;

			case "TypeInstruction":
				moduleContext.addType(field);
				break;

			case "Func":
				moduleContext.addFunction(field);
				break;

			case "Global":
				moduleContext.defineGlobal(field);
				break;

			case "ModuleImport":
				switch (field.descr.type) {
					case "GlobalType":
						moduleContext.importGlobal(field.descr.valtype, field.descr.mutability);
						break;

					case "Memory":
						moduleContext.addMemory(field.descr.limits.min, field.descr.limits.max);
						break;

					case "FuncImportDescr":
						moduleContext.importFunction(field.descr);
						break;

					case "Table":
						break;

					default:
						throw new Error("Unsupported ModuleImport of type " + JSON.stringify(field.descr.type));
				}

				break;

			case "Memory":
				moduleContext.addMemory(field.limits.min, field.limits.max);
				break;
		}
	});
	return moduleContext;
}

class ModuleContext {
	constructor() {
		this.funcs = [];
		this.funcsOffsetByIdentifier = [];
		this.types = [];
		this.globals = [];
		this.globalsOffsetByIdentifier = [];
		this.mems = [];

		this.locals = [];
		this.labels = [];
		this.return = [];
		this.debugName = "unknown";
		this.start = null;
	}

	setStart(index) {
		this.start = index.value;
	}

	getStart() {
		return this.start;
	}

	newContext(debugName, expectedResult) {
		this.locals = [];
		this.labels = [expectedResult];
		this.return = expectedResult;
		this.debugName = debugName;
	}

	addFunction(func) {
		var _ref = func.signature || {},
			_ref$params = _ref.params,
			args = _ref$params === void 0 ? [] : _ref$params,
			_ref$results = _ref.results,
			result = _ref$results === void 0 ? [] : _ref$results;

		args = args.map(function(arg) {
			return arg.valtype;
		});
		this.funcs.push({ args: args, result: result });

		if (func.name !== void 0)
			this.funcsOffsetByIdentifier[func.name.value] = this.funcs.length - 1;
	}

	importFunction(funcimport) {
		if (_ast.isSignature(funcimport.signature)) {
			var _funcimport$signature = funcimport.signature,
				args = _funcimport$signature.params,
				result = _funcimport$signature.results;
			args = args.map(function(arg) {
				return arg.valtype;
			});
			this.funcs.push({ args: args, result: result });
		} else {
			if (!_ast.isNumberLiteral(funcimport.signature))
				throw new Error("isNumberLiteral(funcimport.signature) error: unknown");

			var typeId = funcimport.signature.value;

			if (!this.hasType(typeId)) throw new Error("this.hasType(typeId) error: unknown");

			var signature = this.getType(typeId);
			this.funcs.push({
				args: signature.params.map(function(arg) {
					return arg.valtype;
				}),
				result: signature.results
			});
		}

		if (funcimport.id !== void 0)
			this.funcsOffsetByIdentifier[funcimport.id.value] = this.funcs.length - 1;
	}

	hasFunction(index) {
		return this.getFunction(index) !== void 0;
	}

	getFunction(index) {
		if (typeof index != "number")
			throw new Error("getFunction only supported for number index");

		return this.funcs[index];
	}

	getFunctionOffsetByIdentifier(name) {
		if (typeof name != "string")
			throw new Error('typeof name === "string" error: unknown');

		return this.funcsOffsetByIdentifier[name];
	}

	addLabel(result) {
		this.labels.unshift(result);
	}

	hasLabel(index) {
		return this.labels.length > index && index >= 0;
	}

	getLabel(index) {
		return this.labels[index];
	}

	popLabel() {
		this.labels.shift();
	}

	hasLocal(index) {
		return this.getLocal(index) !== void 0;
	}

	getLocal(index) {
		return this.locals[index];
	}

	addLocal(type) {
		this.locals.push(type);
	}

	addType(type) {
		if (type.functype.type !== "Signature")
			throw new Error('type.functype.type === "Signature" error: unknown');

		this.types.push(type.functype);
	}

	hasType(index) {
		return this.types[index] !== void 0;
	}

	getType(index) {
		return this.types[index];
	}

	hasGlobal(index) {
		return this.globals.length > index && index >= 0;
	}

	getGlobal(index) {
		return this.globals[index].type;
	}

	getGlobalOffsetByIdentifier(name) {
		if (typeof name != "string")
			throw new Error('typeof name === "string" error: unknown');

		return this.globalsOffsetByIdentifier[name];
	}

	defineGlobal(global) {
		var type = global.globalType.valtype,
			mutability = global.globalType.mutability;
		this.globals.push({ type: type, mutability: mutability });

		if (global.name !== void 0)
			this.globalsOffsetByIdentifier[global.name.value] = this.globals.length - 1;
	}

	importGlobal(type, mutability) {
		this.globals.push({ type: type, mutability: mutability });
	}

	isMutableGlobal(index) {
		return this.globals[index].mutability === "var";
	}

	isImmutableGlobal(index) {
		return this.globals[index].mutability === "const";
	}

	hasMemory(index) {
		return this.mems.length > index && index >= 0;
	}

	addMemory(min, max) {
		this.mems.push({ min: min, max: max });
	}

	getMemory(index) {
		return this.mems[index];
	}
}

exports.ModuleContext = ModuleContext;

},
// 88
function(module, exports, __webpack_require__) {

const Template = __webpack_require__(2);
const WebAssemblyImportDependency = __webpack_require__(37);

const MANGLED_MODULE = "a";

const getUsedDependencies = (module, mangle) => {
	const array = [];
	let importIndex = 0;
	for (const dep of module.dependencies) {
		if (dep instanceof WebAssemblyImportDependency) {
			if (dep.description.type === "GlobalType" || dep.module === null) {
				continue;
			}

			const exportName = dep.name;
			if (mangle) {
				array.push({
					dependency: dep,
					name: Template.numberToIdentifer(importIndex++),
					module: MANGLED_MODULE
				});
			} else {
				array.push({
					dependency: dep,
					name: exportName,
					module: dep.request
				});
			}
		}
	}
	return array;
};

exports.getUsedDependencies = getUsedDependencies;
exports.MANGLED_MODULE = MANGLED_MODULE;

},
// 89
function(module, exports, __webpack_require__) {

class LoaderTargetPlugin {
	constructor(target) {
		this.target = target;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap("LoaderTargetPlugin", compilation => {
			compilation.hooks.normalModuleLoader.tap(
				"LoaderTargetPlugin",
				loaderContext => {
					loaderContext.target = this.target;
				}
			);
		});
	}
}

module.exports = LoaderTargetPlugin;

},
// 90
function(module, exports, __webpack_require__) {

const EvalDevToolModuleTemplatePlugin = __webpack_require__(217);

class EvalDevToolModulePlugin {
	constructor(options) {
		this.sourceUrlComment = options.sourceUrlComment;
		this.moduleFilenameTemplate = options.moduleFilenameTemplate;
		this.namespace = options.namespace;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap("EvalDevToolModulePlugin", compilation => {
			new EvalDevToolModuleTemplatePlugin({
				sourceUrlComment: this.sourceUrlComment,
				moduleFilenameTemplate: this.moduleFilenameTemplate,
				namespace: this.namespace
			}).apply(compilation.moduleTemplates.javascript);
		});
	}
}

module.exports = EvalDevToolModulePlugin;

},
// 91
function(module, exports, __webpack_require__) {

const ModuleFilenameHelpers = __webpack_require__(18);

class SourceMapDevToolModuleOptionsPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(compilation) {
		const options = this.options;
		if (options.module !== false) {
			compilation.hooks.buildModule.tap(
				"SourceMapDevToolModuleOptionsPlugin",
				module => {
					module.useSourceMap = true;
				}
			);
		}
		if (options.lineToLine === true) {
			compilation.hooks.buildModule.tap(
				"SourceMapDevToolModuleOptionsPlugin",
				module => {
					module.lineToLine = true;
				}
			);
		} else if (options.lineToLine) {
			compilation.hooks.buildModule.tap(
				"SourceMapDevToolModuleOptionsPlugin",
				module => {
					if (!module.resource) return;
					let resourcePath = module.resource;
					const idx = resourcePath.indexOf("?");
					if (idx >= 0) resourcePath = resourcePath.substr(0, idx);
					module.lineToLine = ModuleFilenameHelpers.matchObject(
						options.lineToLine,
						resourcePath
					);
				}
			);
		}
	}
}

module.exports = SourceMapDevToolModuleOptionsPlugin;

},
// 92
function(module, exports, __webpack_require__) {

const EvalSourceMapDevToolModuleTemplatePlugin = __webpack_require__(219);
const SourceMapDevToolModuleOptionsPlugin = __webpack_require__(91);

class EvalSourceMapDevToolPlugin {
	constructor(options) {
		if (arguments.length > 1) {
			throw new Error(
				"EvalSourceMapDevToolPlugin only takes one argument (pass an options object)"
			);
		}
		if (typeof options == "string") {
			options = {
				append: options
			};
		}
		if (!options) options = {};
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		compiler.hooks.compilation.tap(
			"EvalSourceMapDevToolPlugin",
			compilation => {
				new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);
				new EvalSourceMapDevToolModuleTemplatePlugin(
					compilation,
					options
				).apply(compilation.moduleTemplates.javascript);
			}
		);
	}
}

module.exports = EvalSourceMapDevToolPlugin;

},
// 93
function(module, exports, __webpack_require__) {

const MultiEntryDependency = __webpack_require__(94);
const SingleEntryDependency = __webpack_require__(25);
const MultiModuleFactory = __webpack_require__(95);

class MultiEntryPlugin {
	constructor(context, entries, name) {
		this.context = context;
		this.entries = entries;
		this.name = name;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap(
			"MultiEntryPlugin",
			(compilation, { normalModuleFactory }) => {
				const multiModuleFactory = new MultiModuleFactory();

				compilation.dependencyFactories.set(
					MultiEntryDependency,
					multiModuleFactory
				);
				compilation.dependencyFactories.set(
					SingleEntryDependency,
					normalModuleFactory
				);
			}
		);

		compiler.hooks.make.tapAsync(
			"MultiEntryPlugin",
			(compilation, callback) => {
				const { context, entries, name } = this;

				const dep = MultiEntryPlugin.createDependency(entries, name);
				compilation.addEntry(context, dep, name, callback);
			}
		);
	}

	static createDependency(entries, name) {
		return new MultiEntryDependency(
			entries.map((e, idx) => {
				const dep = new SingleEntryDependency(e);
				dep.loc = {
					name,
					index: idx
				};
				return dep;
			}),
			name
		);
	}
}

module.exports = MultiEntryPlugin;

},
// 94
function(module, exports, __webpack_require__) {

const Dependency = __webpack_require__(17);

class MultiEntryDependency extends Dependency {
	constructor(dependencies, name) {
		super();
		this.dependencies = dependencies;
		this.name = name;
	}

	get type() {
		return "multi entry";
	}
}

module.exports = MultiEntryDependency;

},
// 95
function(module, exports, __webpack_require__) {

const { Tapable } = __webpack_require__(6);
const MultiModule = __webpack_require__(221);

module.exports = class extends Tapable {
	constructor() {
		super();
		this.hooks = {};
	}

	create(data, callback) {
		const dependency = data.dependencies[0];
		callback(
			null,
			new MultiModule(data.context, dependency.dependencies, dependency.name)
		);
	}
};

},
// 96
function(module, exports, __webpack_require__) {

const ModuleDependency = __webpack_require__(4);
const ModuleDependencyTemplateAsId = __webpack_require__(39);

class CommonJsRequireDependency extends ModuleDependency {
	constructor(request, range) {
		super(request);
		this.range = range;
	}

	get type() {
		return "cjs require";
	}
}

CommonJsRequireDependency.Template = ModuleDependencyTemplateAsId;

module.exports = CommonJsRequireDependency;

},
// 97
function(module, exports, __webpack_require__) {

const ContextDependency = __webpack_require__(26);
const ContextDependencyTemplateAsRequireCall = __webpack_require__(63);

class CommonJsRequireContextDependency extends ContextDependency {
	constructor(options, range, valueRange) {
		super(options);
		this.range = range;
		this.valueRange = valueRange;
	}

	get type() {
		return "cjs require context";
	}
}

CommonJsRequireContextDependency.Template = ContextDependencyTemplateAsRequireCall;

module.exports = CommonJsRequireContextDependency;

},
// 98
function(module, exports, __webpack_require__) {

const ModuleDependency = __webpack_require__(4);
const ModuleDependencyAsId = __webpack_require__(39);

class RequireResolveDependency extends ModuleDependency {
	constructor(request, range) {
		super(request);
		this.range = range;
	}

	get type() {
		return "require.resolve";
	}
}

RequireResolveDependency.Template = ModuleDependencyAsId;

module.exports = RequireResolveDependency;

},
// 99
function(module, exports, __webpack_require__) {

const ContextDependency = __webpack_require__(26);
const ContextDependencyTemplateAsId = __webpack_require__(236);

class RequireResolveContextDependency extends ContextDependency {
	constructor(options, range, valueRange) {
		super(options);
		this.range = range;
		this.valueRange = valueRange;
	}

	get type() {
		return "amd require context";
	}
}

RequireResolveContextDependency.Template = ContextDependencyTemplateAsId;

module.exports = RequireResolveContextDependency;

},
// 100
function(module, exports, __webpack_require__) {

const NullDependency = __webpack_require__(7);

class RequireResolveHeaderDependency extends NullDependency {
	constructor(range) {
		super();
		if (!Array.isArray(range)) throw new Error("range must be valid");
		this.range = range;
	}
}

RequireResolveHeaderDependency.Template = class {
	apply(dep, source) {
		source.replace(dep.range[0], dep.range[1] - 1, "/*require.resolve*/");
	}

	applyAsTemplateArgument(name, dep, source) {
		source.replace(dep.range[0], dep.range[1] - 1, "/*require.resolve*/");
	}
};

module.exports = RequireResolveHeaderDependency;

},
// 101
function(module, exports, __webpack_require__) {

const NullDependency = __webpack_require__(7);

class RequireHeaderDependency extends NullDependency {
	constructor(range) {
		super();
		if (!Array.isArray(range)) throw new Error("range must be valid");
		this.range = range;
	}
}

RequireHeaderDependency.Template = class {
	apply(dep, source) {
		source.replace(dep.range[0], dep.range[1] - 1, "__webpack_require__");
	}

	applyAsTemplateArgument(name, dep, source) {
		source.replace(dep.range[0], dep.range[1] - 1, "require");
	}
};

module.exports = RequireHeaderDependency;

},
// 102
function(module, exports, __webpack_require__) {

const NullDependency = __webpack_require__(7);

class HarmonyInitDependency extends NullDependency {
	constructor(originModule) {
		super();
		this.originModule = originModule;
	}

	get type() {
		return "harmony init";
	}
}

module.exports = HarmonyInitDependency;

HarmonyInitDependency.Template = class {
	apply(dep, source, runtime, dependencyTemplates) {
		const module = dep.originModule;
		const list = [];
		for (const dependency of module.dependencies) {
			const template = dependencyTemplates.get(dependency.constructor);
			if (
				template &&
				typeof template.harmonyInit == "function" &&
				typeof template.getHarmonyInitOrder == "function"
			) {
				const order = template.getHarmonyInitOrder(dependency);
				if (!isNaN(order)) {
					list.push({
						order,
						listOrder: list.length,
						dependency,
						template
					});
				}
			}
		}

		list.sort((a, b) => {
			const x = a.order - b.order;
			if (x) return x;
			return a.listOrder - b.listOrder;
		});

		for (const item of list) {
			item.template.harmonyInit(
				item.dependency,
				source,
				runtime,
				dependencyTemplates
			);
		}
	}
};

},
// 103
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);

module.exports = class extends WebpackError {
	constructor(message) {
		super(message);
		this.name = "HarmonyLinkingError";
		this.hideStack = true;

		Error.captureStackTrace(this, this.constructor);
	}
};

},
// 104
function(module, exports, __webpack_require__) {

const NullDependency = __webpack_require__(7);

class HarmonyExportHeaderDependency extends NullDependency {
	constructor(range, rangeStatement) {
		super();
		this.range = range;
		this.rangeStatement = rangeStatement;
	}

	get type() {
		return "harmony export header";
	}
}

HarmonyExportHeaderDependency.Template = class {
	apply(dep, source) {
		const content = "";
		const replaceUntil = dep.range
			? dep.range[0] - 1
			: dep.rangeStatement[1] - 1;
		source.replace(dep.rangeStatement[0], replaceUntil, content);
	}
};

module.exports = HarmonyExportHeaderDependency;

},
// 105
function(module, exports, __webpack_require__) {

const NullDependency = __webpack_require__(7);
const HarmonyImportDependency = __webpack_require__(19);

class HarmonyAcceptDependency extends NullDependency {
	constructor(range, dependencies, hasCallback) {
		super();
		this.range = range;
		this.dependencies = dependencies;
		this.hasCallback = hasCallback;
	}

	get type() {
		return "accepted harmony modules";
	}
}

HarmonyAcceptDependency.Template = class {
	apply(dep, source, runtime) {
		const content = dep.dependencies
			.filter(dependency =>
				HarmonyImportDependency.Template.isImportEmitted(dependency, source)
			)
			.map(dependency => dependency.getImportStatement(true, runtime))
			.join("");

		if (dep.hasCallback) {
			source.insert(
				dep.range[0],
				`function(__WEBPACK_OUTDATED_DEPENDENCIES__) { ${content}(`
			);
			source.insert(
				dep.range[1],
				")(__WEBPACK_OUTDATED_DEPENDENCIES__); }.bind(this)"
			);
			return;
		}

		source.insert(dep.range[1] - 0.5, `, function() { ${content} }`);
	}
};

module.exports = HarmonyAcceptDependency;

},
// 106
function(module, exports, __webpack_require__) {

const HarmonyImportDependency = __webpack_require__(19);

class HarmonyAcceptImportDependency extends HarmonyImportDependency {
	constructor(request, originModule, parserScope) {
		super(request, originModule, NaN, parserScope);
		this.weak = true;
	}

	get type() {
		return "harmony accept";
	}
}

HarmonyAcceptImportDependency.Template = class extends HarmonyImportDependency.Template {
	apply(dep, source, runtime) {}
};

module.exports = HarmonyAcceptImportDependency;

},
// 107
function(module, exports, __webpack_require__) {

const ModuleDependency = __webpack_require__(4);

class ImportDependency extends ModuleDependency {
	constructor(request, originModule, block) {
		super(request);
		this.originModule = originModule;
		this.block = block;
	}

	get type() {
		return "import()";
	}
}

ImportDependency.Template = class {
	apply(dep, source, runtime) {
		const content = runtime.moduleNamespacePromise({
			block: dep.block,
			module: dep.module,
			request: dep.request,
			strict: dep.originModule.buildMeta.strictHarmonyModule,
			message: "import()"
		});

		source.replace(dep.block.range[0], dep.block.range[1] - 1, content);
	}
};

module.exports = ImportDependency;

},
// 108
function(module, exports, __webpack_require__) {

const ModuleDependency = __webpack_require__(4);

class ImportEagerDependency extends ModuleDependency {
	constructor(request, originModule, range) {
		super(request);
		this.originModule = originModule;
		this.range = range;
	}

	get type() {
		return "import() eager";
	}
}

ImportEagerDependency.Template = class {
	apply(dep, source, runtime) {
		const content = runtime.moduleNamespacePromise({
			module: dep.module,
			request: dep.request,
			strict: dep.originModule.buildMeta.strictHarmonyModule,
			message: "import() eager"
		});
		source.replace(dep.range[0], dep.range[1] - 1, content);
	}
};

module.exports = ImportEagerDependency;

},
// 109
function(module, exports, __webpack_require__) {

const ModuleDependency = __webpack_require__(4);

class ImportWeakDependency extends ModuleDependency {
	constructor(request, originModule, range) {
		super(request);
		this.originModule = originModule;
		this.range = range;
		this.weak = true;
	}

	get type() {
		return "import() weak";
	}
}

ImportWeakDependency.Template = class {
	apply(dep, source, runtime) {
		const content = runtime.moduleNamespacePromise({
			module: dep.module,
			request: dep.request,
			strict: dep.originModule.buildMeta.strictHarmonyModule,
			message: "import() weak",
			weak: true
		});
		source.replace(dep.range[0], dep.range[1] - 1, content);
	}
};

module.exports = ImportWeakDependency;

},
// 110
function(module, exports, __webpack_require__) {

const ContextDependency = __webpack_require__(26);
const ContextDependencyTemplateAsRequireCall = __webpack_require__(63);

class ImportContextDependency extends ContextDependency {
	constructor(options, range, valueRange) {
		super(options);
		this.range = range;
		this.valueRange = valueRange;
	}

	get type() {
		return `import() context ${this.options.mode}`;
	}
}

ImportContextDependency.Template = ContextDependencyTemplateAsRequireCall;

module.exports = ImportContextDependency;

},
// 111
function(module, exports, __webpack_require__) {

const ContextDependency = __webpack_require__(26);
const ModuleDependencyTemplateAsRequireId = __webpack_require__(112);

class RequireContextDependency extends ContextDependency {
	constructor(options, range) {
		super(options);
		this.range = range;
	}

	get type() {
		return "require.context";
	}
}

RequireContextDependency.Template = ModuleDependencyTemplateAsRequireId;

module.exports = RequireContextDependency;

},
// 112
function(module, exports, __webpack_require__) {

class ModuleDependencyTemplateAsRequireId {
	apply(dep, source, runtime) {
		if (!dep.range) return;
		const content = runtime.moduleExports({
			module: dep.module,
			request: dep.request
		});
		source.replace(dep.range[0], dep.range[1] - 1, content);
	}
}
module.exports = ModuleDependencyTemplateAsRequireId;

},
// 113
function(module, exports, __webpack_require__) {

const ModuleDependency = __webpack_require__(4);
const NullDependency = __webpack_require__(7);

class RequireEnsureItemDependency extends ModuleDependency {
	constructor(request) {
		super(request);
	}

	get type() {
		return "require.ensure item";
	}
}

RequireEnsureItemDependency.Template = NullDependency.Template;

module.exports = RequireEnsureItemDependency;

},
// 114
function(module, exports, __webpack_require__) {

const NullDependency = __webpack_require__(7);

class RequireEnsureDependency extends NullDependency {
	constructor(block) {
		super();
		this.block = block;
	}

	get type() {
		return "require.ensure";
	}
}

RequireEnsureDependency.Template = class {
	apply(dep, source, runtime) {
		const depBlock = dep.block;
		const promise = runtime.blockPromise({
			block: depBlock,
			message: "require.ensure"
		});
		const errorCallbackExists =
			depBlock.expr.arguments.length === 4 ||
			(!depBlock.chunkName && depBlock.expr.arguments.length === 3);
		const startBlock = `${promise}.then((`;
		const middleBlock = ").bind(null, __webpack_require__)).catch(";
		const endBlock = `).bind(null, __webpack_require__)).catch(${runtime.onError()})`;
		source.replace(
			depBlock.expr.range[0],
			depBlock.expr.arguments[1].range[0] - 1,
			startBlock
		);
		if (errorCallbackExists) {
			source.replace(
				depBlock.expr.arguments[1].range[1],
				depBlock.expr.arguments[2].range[0] - 1,
				middleBlock
			);
			source.replace(
				depBlock.expr.arguments[2].range[1],
				depBlock.expr.range[1] - 1,
				")"
			);
		} else {
			source.replace(
				depBlock.expr.arguments[1].range[1],
				depBlock.expr.range[1] - 1,
				endBlock
			);
		}
	}
};

module.exports = RequireEnsureDependency;

},
// 115
function(module, exports) {

module.exports = expr => {
	if (
		expr.type === "FunctionExpression" ||
		expr.type === "ArrowFunctionExpression"
	) {
		return {
			fn: expr,
			expressions: [],
			needThis: false
		};
	}

	if (
		expr.type === "CallExpression" &&
		expr.callee.type === "MemberExpression" &&
		expr.callee.object.type === "FunctionExpression" &&
		expr.callee.property.type === "Identifier" &&
		expr.callee.property.name === "bind" &&
		expr.arguments.length === 1
	) {
		return {
			fn: expr.callee.object,
			expressions: [expr.arguments[0]],
			needThis: void 0
		};
	}
	if (
		expr.type === "CallExpression" &&
		expr.callee.type === "FunctionExpression" &&
		expr.callee.body.type === "BlockStatement" &&
		expr.arguments.length === 1 &&
		expr.arguments[0].type === "ThisExpression" &&
		expr.callee.body.body &&
		expr.callee.body.body.length === 1 &&
		expr.callee.body.body[0].type === "ReturnStatement" &&
		expr.callee.body.body[0].argument &&
		expr.callee.body.body[0].argument.type === "FunctionExpression"
	) {
		return {
			fn: expr.callee.body.body[0].argument,
			expressions: [],
			needThis: true
		};
	}
};

},
// 116
function(module, exports, __webpack_require__) {

const DependencyReference = __webpack_require__(14);
const ModuleDependency = __webpack_require__(4);
const Template = __webpack_require__(2);

class RequireIncludeDependency extends ModuleDependency {
	constructor(request, range) {
		super(request);
		this.range = range;
	}

	getReference() {
		if (!this.module) return null;
		return new DependencyReference(this.module, [], false);
	}

	get type() {
		return "require.include";
	}
}

RequireIncludeDependency.Template = class {
	apply(dep, source, runtime) {
		const comment = runtime.outputOptions.pathinfo
			? Template.toComment(
					`require.include ${runtime.requestShortener.shorten(dep.request)}`
				)
			: "";
		source.replace(dep.range[0], dep.range[1] - 1, `undefined${comment}`);
	}
};

module.exports = RequireIncludeDependency;

},
// 117
function(module, exports, __webpack_require__) {

const Template = __webpack_require__(2);
const WebAssemblyUtils = __webpack_require__(88);

const getAllWasmModules = chunk => {
	const wasmModules = chunk.getAllAsyncChunks();
	const array = [];
	for (const chunk of wasmModules) {
		for (const m of chunk.modulesIterable) {
			if (m.type.startsWith("webassembly")) {
				array.push(m);
			}
		}
	}

	return array;
};

const generateImportObject = (module, mangle) => {
	const waitForInstances = new Map();
	const properties = [];
	const usedWasmDependencies = WebAssemblyUtils.getUsedDependencies(
		module,
		mangle
	);
	for (const usedDep of usedWasmDependencies) {
		const dep = usedDep.dependency;
		const importedModule = dep.module;
		const exportName = dep.name;
		const usedName = importedModule && importedModule.isUsed(exportName);
		const description = dep.description;
		const direct = dep.onlyDirectImport;

		const module = usedDep.module;
		const name = usedDep.name;

		if (direct) {
			const instanceVar = `m${waitForInstances.size}`;
			waitForInstances.set(instanceVar, importedModule.id);
			properties.push({
				module,
				name,
				value: `${instanceVar}[${JSON.stringify(usedName)}]`
			});
		} else {
			const params = description.signature.params.map(
				(param, k) => "p" + k + param.valtype
			);

			const mod = `installedModules[${JSON.stringify(importedModule.id)}]`;
			const func = `${mod}.exports[${JSON.stringify(usedName)}]`;

			properties.push({
				module,
				name,
				value: Template.asString([
					(importedModule.type.startsWith("webassembly")
						? `${mod} ? ${func} : `
						: "") + `function(${params}) {`,
					Template.indent([`return ${func}(${params});`]),
					"}"
				])
			});
		}
	}

	let importObject;
	if (mangle) {
		importObject = [
			"return {",
			Template.indent([
				properties.map(p => `${JSON.stringify(p.name)}: ${p.value}`).join(",\n")
			]),
			"};"
		];
	} else {
		const propertiesByModule = new Map();
		for (const p of properties) {
			let list = propertiesByModule.get(p.module);
			if (list === void 0) {
				propertiesByModule.set(p.module, (list = []));
			}
			list.push(p);
		}
		importObject = [
			"return {",
			Template.indent([
				Array.from(propertiesByModule, ([module, list]) => {
					return Template.asString([
						`${JSON.stringify(module)}: {`,
						Template.indent([
							list.map(p => `${JSON.stringify(p.name)}: ${p.value}`).join(",\n")
						]),
						"}"
					]);
				}).join(",\n")
			]),
			"};"
		];
	}

	if (waitForInstances.size === 1) {
		const moduleId = Array.from(waitForInstances.values())[0];
		const promise = `installedWasmModules[${JSON.stringify(moduleId)}]`;
		const variable = Array.from(waitForInstances.keys())[0];
		return Template.asString([
			`${JSON.stringify(module.id)}: function() {`,
			Template.indent([
				`return promiseResolve().then(function() { return ${promise}; }).then(function(${variable}) {`,
				Template.indent(importObject),
				"});"
			]),
			"},"
		]);
	} else if (waitForInstances.size > 0) {
		const promises = Array.from(
			waitForInstances.values(),
			id => `installedWasmModules[${JSON.stringify(id)}]`
		).join(", ");
		const variables = Array.from(
			waitForInstances.keys(),
			(name, i) => `${name} = array[${i}]`
		).join(", ");
		return Template.asString([
			`${JSON.stringify(module.id)}: function() {`,
			Template.indent([
				`return promiseResolve().then(function() { return Promise.all([${promises}]); }).then(function(array) {`,
				Template.indent([`var ${variables};`, ...importObject]),
				"});"
			]),
			"},"
		]);
	} else {
		return Template.asString([
			`${JSON.stringify(module.id)}: function() {`,
			Template.indent(importObject),
			"},"
		]);
	}
};

class WasmMainTemplatePlugin {
	constructor({ generateLoadBinaryCode, supportsStreaming, mangleImports }) {
		this.generateLoadBinaryCode = generateLoadBinaryCode;
		this.supportsStreaming = supportsStreaming;
		this.mangleImports = mangleImports;
	}

	apply(mainTemplate) {
		mainTemplate.hooks.localVars.tap(
			"WasmMainTemplatePlugin",
			(source, chunk) => {
				const wasmModules = getAllWasmModules(chunk);
				if (wasmModules.length === 0) return source;
				const importObjects = wasmModules.map(module => {
					return generateImportObject(module, this.mangleImports);
				});
				return Template.asString([
					source,
					"",
					"// object to store loaded and loading wasm modules",
					"var installedWasmModules = {};",
					"",
					"function promiseResolve() { return Promise.resolve(); }",
					"",
					"var wasmImportObjects = {",
					Template.indent(importObjects),
					"};"
				]);
			}
		);
		mainTemplate.hooks.requireEnsure.tap(
			"WasmMainTemplatePlugin",
			(source, chunk, hash) => {
				const webassemblyModuleFilename =
					mainTemplate.outputOptions.webassemblyModuleFilename;

				const chunkModuleMaps = chunk.getChunkModuleMaps(m =>
					m.type.startsWith("webassembly")
				);
				if (Object.keys(chunkModuleMaps.id).length === 0) return source;
				const wasmModuleSrcPath = mainTemplate.getAssetPath(
					JSON.stringify(webassemblyModuleFilename),
					{
						hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
						hashWithLength: length =>
							`" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`,
						module: {
							id: '" + wasmModuleId + "',
							hash: `" + ${JSON.stringify(
								chunkModuleMaps.hash
							)}[wasmModuleId] + "`,
							hashWithLength(length) {
								const shortChunkHashMap = Object.create(null);
								for (const wasmModuleId of Object.keys(chunkModuleMaps.hash)) {
									if (typeof chunkModuleMaps.hash[wasmModuleId] == "string") {
										shortChunkHashMap[wasmModuleId] = chunkModuleMaps.hash[
											wasmModuleId
										].substr(0, length);
									}
								}
								return `" + ${JSON.stringify(
									shortChunkHashMap
								)}[wasmModuleId] + "`;
							}
						}
					}
				);
				const createImportObject = content =>
					this.mangleImports
						? `{ ${JSON.stringify(
								WebAssemblyUtils.MANGLED_MODULE
							)}: ${content} }`
						: content;
				return Template.asString([
					source,
					"",
					"// Fetch + compile chunk loading for webassembly",
					"",
					`var wasmModules = ${JSON.stringify(
						chunkModuleMaps.id
					)}[chunkId] || [];`,
					"",
					"wasmModules.forEach(function(wasmModuleId) {",
					Template.indent([
						"var installedWasmModuleData = installedWasmModules[wasmModuleId];",
						"",
						'// a Promise means "currently loading" or "already loaded".',
						"if(installedWasmModuleData)",
						Template.indent(["promises.push(installedWasmModuleData);"]),
						"else {",
						Template.indent([
							`var importObject = wasmImportObjects[wasmModuleId]();`,
							`var req = ${this.generateLoadBinaryCode(wasmModuleSrcPath)};`,
							"var promise;",
							this.supportsStreaming
								? Template.asString([
										"if(importObject instanceof Promise && typeof WebAssembly.compileStreaming === 'function') {",
										Template.indent([
											"promise = Promise.all([WebAssembly.compileStreaming(req), importObject]).then(function(items) {",
											Template.indent([
												`return WebAssembly.instantiate(items[0], ${createImportObject(
													"items[1]"
												)});`
											]),
											"});"
										]),
										"} else if(typeof WebAssembly.instantiateStreaming === 'function') {",
										Template.indent([
											`promise = WebAssembly.instantiateStreaming(req, ${createImportObject(
												"importObject"
											)});`
										])
									])
								: Template.asString([
										"if(importObject instanceof Promise) {",
										Template.indent([
											"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });",
											"promise = Promise.all([",
											Template.indent([
												"bytesPromise.then(function(bytes) { return WebAssembly.compile(bytes); }),",
												"importObject"
											]),
											"]).then(function(items) {",
											Template.indent([
												`return WebAssembly.instantiate(items[0], ${createImportObject(
													"items[1]"
												)});`
											]),
											"});"
										])
									]),
							"} else {",
							Template.indent([
								"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });",
								"promise = bytesPromise.then(function(bytes) {",
								Template.indent([
									`return WebAssembly.instantiate(bytes, ${createImportObject(
										"importObject"
									)});`
								]),
								"});"
							]),
							"}",
							"promises.push(installedWasmModules[wasmModuleId] = promise.then(function(res) {",
							Template.indent([
								`return ${mainTemplate.requireFn}.w[wasmModuleId] = (res.instance || res).exports;`
							]),
							"}));"
						]),
						"}"
					]),
					"});"
				]);
			}
		);
		mainTemplate.hooks.requireExtensions.tap(
			"WasmMainTemplatePlugin",
			(source, chunk) => {
				if (!chunk.hasModuleInGraph(m => m.type.startsWith("webassembly"))) {
					return source;
				}
				return Template.asString([
					source,
					"",
					"// object with all WebAssembly.instance exports",
					`${mainTemplate.requireFn}.w = {};`
				]);
			}
		);
		mainTemplate.hooks.hash.tap("WasmMainTemplatePlugin", hash => {
			hash.update("WasmMainTemplatePlugin");
			hash.update("2");
		});
	}
}

module.exports = WasmMainTemplatePlugin;

},
// 118
function(module, exports, __webpack_require__) {

const AliasPlugin = __webpack_require__(24).AliasPlugin;
const ParserHelpers = __webpack_require__(9);
const nodeLibsBrowser = __webpack_require__(261);

module.exports = class {
	constructor(options) {
		this.options = options;
	}
	apply(compiler) {
		const options = this.options;
		if (options === false) {
			return;
		}

		const getPathToModule = (module, type) => {
			if (type === true || (type === void 0 && nodeLibsBrowser[module])) {
				if (!nodeLibsBrowser[module]) {
					throw new Error(
						`No browser version for node.js core module ${module} available`
					);
				}
				return nodeLibsBrowser[module];
			} else if (type === "mock") {
				return require.resolve(`../web_modules/mock/${module}`);
			} else if (type === "empty") {
				return require.resolve("../web_modules/mock/empty");
			} else {
				return module;
			}
		};

		const addExpression = (parser, name, module, type, suffix) => {
			suffix = suffix || "";
			parser.hooks.expression.for(name).tap("NodeSourcePlugin", () => {
				if (
					parser.state.module &&
					parser.state.module.resource === getPathToModule(module, type)
				)
					return;
				const mockModule = ParserHelpers.requireFileAsExpression(
					parser.state.module.context,
					getPathToModule(module, type)
				);
				return ParserHelpers.addParsedVariableToModule(
					parser,
					name,
					mockModule + suffix
				);
			});
		};

		compiler.hooks.compilation.tap(
			"NodeSourcePlugin",
			(compilation, { normalModuleFactory }) => {
				const handler = (parser, parserOptions) => {
					if (parserOptions.node === false) return;

					let localOptions = options;
					if (parserOptions.node) {
						localOptions = Object.assign({}, localOptions, parserOptions.node);
					}
					if (localOptions.global) {
						parser.hooks.expression
							.for("global")
							.tap("NodeSourcePlugin", () => {
								const retrieveGlobalModule = ParserHelpers.requireFileAsExpression(
									parser.state.module.context,
									require.resolve("../buildin/global")
								);
								return ParserHelpers.addParsedVariableToModule(
									parser,
									"global",
									retrieveGlobalModule
								);
							});
					}
					if (localOptions.process) {
						const processType = localOptions.process;
						addExpression(parser, "process", "process", processType);
					}
					if (localOptions.console) {
						const consoleType = localOptions.console;
						addExpression(parser, "console", "console", consoleType);
					}
					const bufferType = localOptions.Buffer;
					if (bufferType) {
						addExpression(parser, "Buffer", "buffer", bufferType, ".Buffer");
					}
					if (localOptions.setImmediate) {
						const setImmediateType = localOptions.setImmediate;
						addExpression(
							parser,
							"setImmediate",
							"timers",
							setImmediateType,
							".setImmediate"
						);
						addExpression(
							parser,
							"clearImmediate",
							"timers",
							setImmediateType,
							".clearImmediate"
						);
					}
				};
				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("NodeSourcePlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("NodeSourcePlugin", handler);
			}
		);
		compiler.hooks.afterResolvers.tap("NodeSourcePlugin", compiler => {
			for (const lib of Object.keys(nodeLibsBrowser)) {
				if (options[lib] !== false) {
					compiler.resolverFactory.hooks.resolver
						.for("normal")
						.tap("NodeSourcePlugin", resolver => {
							new AliasPlugin(
								"described-resolve",
								{
									name: lib,
									onlyModule: true,
									alias: getPathToModule(lib, options[lib])
								},
								"resolve"
							).apply(resolver);
						});
				}
			}
		});
	}
};

},
// 119
function(module, exports, __webpack_require__) {

const WebWorkerMainTemplatePlugin = __webpack_require__(262);
const WebWorkerChunkTemplatePlugin = __webpack_require__(264);
const WebWorkerHotUpdateChunkTemplatePlugin = __webpack_require__(265);

class WebWorkerTemplatePlugin {
	apply(compiler) {
		compiler.hooks.thisCompilation.tap(
			"WebWorkerTemplatePlugin",
			compilation => {
				new WebWorkerMainTemplatePlugin().apply(compilation.mainTemplate);
				new WebWorkerChunkTemplatePlugin().apply(compilation.chunkTemplate);
				new WebWorkerHotUpdateChunkTemplatePlugin().apply(
					compilation.hotUpdateChunkTemplate
				);
			}
		);
	}
}
module.exports = WebWorkerTemplatePlugin;

},
// 120
function(module, exports, __webpack_require__) {

const Template = __webpack_require__(2);
const WasmMainTemplatePlugin = __webpack_require__(117);

class ReadFileCompileWasmTemplatePlugin {
	constructor(options) {
		this.options = options || {};
	}

	apply(compiler) {
		compiler.hooks.thisCompilation.tap(
			"ReadFileCompileWasmTemplatePlugin",
			compilation => {
				const generateLoadBinaryCode = path =>
					Template.asString([
						"new Promise(function (resolve, reject) {",
						Template.indent([
							"var { readFile } = require('fs');",
							"var { join } = require('path');",
							"",
							"try {",
							Template.indent([
								`readFile(join(__dirname, ${path}), function(err, buffer){`,
								Template.indent([
									"if (err) return reject(err);",
									"",
									"// Fake fetch response",
									"resolve({",
									Template.indent([
										"arrayBuffer() { return Promise.resolve(buffer); }"
									]),
									"});"
								]),
								"});"
							]),
							"} catch (err) { reject(err); }"
						]),
						"})"
					]);

				const plugin = new WasmMainTemplatePlugin(
					Object.assign(
						{
							generateLoadBinaryCode,
							supportsStreaming: false
						},
						this.options
					)
				);
				plugin.apply(compilation.mainTemplate);
			}
		);
	}
}

module.exports = ReadFileCompileWasmTemplatePlugin;

},
// 121
function(module, exports, __webpack_require__) {

const ExternalModule = __webpack_require__(271);

class ExternalModuleFactoryPlugin {
	constructor(type, externals) {
		this.type = type;
		this.externals = externals;
	}

	apply(normalModuleFactory) {
		const globalType = this.type;
		normalModuleFactory.hooks.factory.tap(
			"ExternalModuleFactoryPlugin",
			factory => (data, callback) => {
				const context = data.context;
				const dependency = data.dependencies[0];

				const handleExternal = (value, type, callback) => {
					if (typeof type == "function") {
						callback = type;
						type = void 0;
					}
					if (value === false) return factory(data, callback);
					if (value === true) value = dependency.request;
					if (type === void 0 && /^[a-z0-9]+ /.test(value)) {
						const idx = value.indexOf(" ");
						type = value.substr(0, idx);
						value = value.substr(idx + 1);
					}
					callback(
						null,
						new ExternalModule(value, type || globalType, dependency.request)
					);
					return true;
				};

				const handleExternals = (externals, callback) => {
					if (typeof externals == "string") {
						if (externals === dependency.request) {
							return handleExternal(dependency.request, callback);
						}
					} else if (Array.isArray(externals)) {
						let i = 0;
						const next = () => {
							let asyncFlag;
							const handleExternalsAndCallback = (err, module) => {
								if (err) return callback(err);
								if (!module) {
									if (asyncFlag) {
										asyncFlag = false;
										return;
									}
									return next();
								}
								callback(null, module);
							};

							do {
								asyncFlag = true;
								if (i >= externals.length) return callback();
								handleExternals(externals[i++], handleExternalsAndCallback);
							} while (!asyncFlag);
							asyncFlag = false;
						};

						next();
						return;
					} else if (externals instanceof RegExp) {
						if (externals.test(dependency.request)) {
							return handleExternal(dependency.request, callback);
						}
					} else if (typeof externals == "function") {
						externals.call(
							null,
							context,
							dependency.request,
							(err, value, type) => {
								if (err) return callback(err);
								if (value !== void 0) {
									handleExternal(value, type, callback);
								} else {
									callback();
								}
							}
						);
						return;
					} else if (
						typeof externals == "object" &&
						Object.prototype.hasOwnProperty.call(externals, dependency.request)
					) {
						return handleExternal(externals[dependency.request], callback);
					}
					callback();
				};

				handleExternals(this.externals, (err, module) => {
					if (err) return callback(err);
					if (!module) return handleExternal(false, callback);
					return callback(null, module);
				});
			}
		);
	}
}
module.exports = ExternalModuleFactoryPlugin;

},
// 122
function(module, exports, __webpack_require__) {

const SetVarMainTemplatePlugin = __webpack_require__(123);

const accessorToObjectAccess = accessor => {
	return accessor.map(a => `[${JSON.stringify(a)}]`).join("");
};

const accessorAccess = (base, accessor, umdProperty, joinWith = "; ") => {
	const normalizedAccessor =
		typeof accessor == "object" && !Array.isArray(accessor)
			? accessor[umdProperty]
			: accessor;
	const accessors = Array.isArray(normalizedAccessor)
		? normalizedAccessor
		: [normalizedAccessor];
	return accessors
		.map((_, idx) => {
			const a = base
				? base + accessorToObjectAccess(accessors.slice(0, idx + 1))
				: accessors[0] + accessorToObjectAccess(accessors.slice(1, idx + 1));
			if (idx === accessors.length - 1) return a;
			if (idx === 0 && base === void 0) {
				return `${a} = typeof ${a} === "object" ? ${a} : {}`;
			}
			return `${a} = ${a} || {}`;
		})
		.join(joinWith);
};

class LibraryTemplatePlugin {
	constructor(name, target, umdNamedDefine, auxiliaryComment, exportProperty) {
		this.name = name;
		this.target = target;
		this.umdNamedDefine = umdNamedDefine;
		this.auxiliaryComment = auxiliaryComment;
		this.exportProperty = exportProperty;
	}

	apply(compiler) {
		compiler.hooks.thisCompilation.tap("LibraryTemplatePlugin", compilation => {
			if (this.exportProperty) {
				const ExportPropertyMainTemplatePlugin = __webpack_require__(272);
				new ExportPropertyMainTemplatePlugin(this.exportProperty).apply(
					compilation
				);
			}
			switch (this.target) {
				case "var":
					if (
						!this.name ||
						(typeof this.name == "object" && !Array.isArray(this.name))
					) {
						throw new Error(
							"library name must be set and not an UMD custom object for non-UMD target"
						);
					}
					new SetVarMainTemplatePlugin(
						`var ${accessorAccess(undefined, this.name, "root")}`,
						false
					).apply(compilation);
					break;
				case "assign":
					new SetVarMainTemplatePlugin(
						accessorAccess(void 0, this.name, "root"),
						false
					).apply(compilation);
					break;
				case "this":
				case "self":
				case "window":
					if (this.name) {
						new SetVarMainTemplatePlugin(
							accessorAccess(this.target, this.name, "root"),
							false
						).apply(compilation);
					} else {
						new SetVarMainTemplatePlugin(this.target, true).apply(compilation);
					}
					break;
				case "global":
					if (this.name) {
						new SetVarMainTemplatePlugin(
							accessorAccess(
								compilation.runtimeTemplate.outputOptions.globalObject,
								this.name,
								"root"
							),
							false
						).apply(compilation);
					} else {
						new SetVarMainTemplatePlugin(
							compilation.runtimeTemplate.outputOptions.globalObject,
							true
						).apply(compilation);
					}
					break;
				case "commonjs":
					if (this.name) {
						new SetVarMainTemplatePlugin(
							accessorAccess("exports", this.name, "commonjs"),
							false
						).apply(compilation);
					} else {
						new SetVarMainTemplatePlugin("exports", true).apply(compilation);
					}
					break;
				case "commonjs2":
				case "commonjs-module":
					new SetVarMainTemplatePlugin("module.exports", false).apply(
						compilation
					);
					break;
				case "amd":
				case "amd-require": {
					const AmdMainTemplatePlugin = __webpack_require__(273);
					if (this.name && typeof this.name != "string") {
						throw new Error("library name must be a string for amd target");
					}
					new AmdMainTemplatePlugin({
						name: this.name,
						requireAsWrapper: this.target === "amd-require"
					}).apply(compilation);
					break;
				}
				case "umd":
				case "umd2": {
					const UmdMainTemplatePlugin = __webpack_require__(124);
					new UmdMainTemplatePlugin(this.name, {
						optionalAmdExternalAsGlobal: this.target === "umd2",
						namedDefine: this.umdNamedDefine,
						auxiliaryComment: this.auxiliaryComment
					}).apply(compilation);
					break;
				}
				case "jsonp": {
					const JsonpExportMainTemplatePlugin = __webpack_require__(274);
					if (typeof this.name != "string")
						throw new Error("library name must be a string for jsonp target");
					new JsonpExportMainTemplatePlugin(this.name).apply(compilation);
					break;
				}
				case "system": {
					const SystemMainTemplatePlugin = __webpack_require__(275);
					new SystemMainTemplatePlugin({
						name: this.name
					}).apply(compilation);
					break;
				}
				default:
					throw new Error(`${this.target} is not a valid Library target`);
			}
		});
	}
}

module.exports = LibraryTemplatePlugin;

},
// 123
function(module, exports, __webpack_require__) {

const { ConcatSource } = __webpack_require__(0);

class SetVarMainTemplatePlugin {
	constructor(varExpression, copyObject) {
		this.varExpression = varExpression;
		this.copyObject = copyObject;
	}

	apply(compilation) {
		const { mainTemplate, chunkTemplate } = compilation;

		const onRenderWithEntry = (source, chunk, hash) => {
			const varExpression = mainTemplate.getAssetPath(this.varExpression, {
				hash,
				chunk
			});
			if (this.copyObject) {
				return new ConcatSource(
					`(function(e, a) { for(var i in a) e[i] = a[i]; if(a.__esModule) Object.defineProperty(e, '__esModule', {value: true}); }(${varExpression},\n`,
					source,
					"))"
				);
			} else {
				const prefix = `${varExpression} =\n`;
				return new ConcatSource(prefix, source);
			}
		};

		for (const template of [mainTemplate, chunkTemplate]) {
			template.hooks.renderWithEntry.tap(
				"SetVarMainTemplatePlugin",
				onRenderWithEntry
			);
		}

		mainTemplate.hooks.globalHashPaths.tap(
			"SetVarMainTemplatePlugin",
			paths => {
				if (this.varExpression) paths.push(this.varExpression);
				return paths;
			}
		);
		mainTemplate.hooks.hash.tap("SetVarMainTemplatePlugin", hash => {
			hash.update("set var");
			hash.update(`${this.varExpression}`);
			hash.update(`${this.copyObject}`);
		});
	}
}

module.exports = SetVarMainTemplatePlugin;

},
// 124
function(module, exports, __webpack_require__) {

const { ConcatSource, OriginalSource } = __webpack_require__(0);
const Template = __webpack_require__(2);

const accessorToObjectAccess = accessor => {
	return accessor.map(a => `[${JSON.stringify(a)}]`).join("");
};

const accessorAccess = (base, accessor, joinWith = ", ") => {
	const accessors = Array.isArray(accessor) ? accessor : [accessor];
	return accessors
		.map((_, idx) => {
			const a = base
				? base + accessorToObjectAccess(accessors.slice(0, idx + 1))
				: accessors[0] + accessorToObjectAccess(accessors.slice(1, idx + 1));
			if (idx === accessors.length - 1) return a;
			if (idx === 0 && base === void 0)
				return `${a} = typeof ${a} === "object" ? ${a} : {}`;
			return `${a} = ${a} || {}`;
		})
		.join(joinWith);
};

class UmdMainTemplatePlugin {
	constructor(name, options) {
		if (typeof name == "object" && !Array.isArray(name)) {
			this.name = name.root || name.amd || name.commonjs;
			this.names = name;
		} else {
			this.name = name;
			this.names = {
				commonjs: name,
				root: name,
				amd: name
			};
		}
		this.optionalAmdExternalAsGlobal = options.optionalAmdExternalAsGlobal;
		this.namedDefine = options.namedDefine;
		this.auxiliaryComment = options.auxiliaryComment;
	}

	apply(compilation) {
		const { mainTemplate, chunkTemplate, runtimeTemplate } = compilation;

		const onRenderWithEntry = (source, chunk, hash) => {
			let externals = chunk
				.getModules()
				.filter(
					m =>
						m.external &&
						(m.externalType === "umd" || m.externalType === "umd2")
				);
			const optionalExternals = [];
			let requiredExternals = [];
			if (this.optionalAmdExternalAsGlobal) {
				for (const m of externals) {
					if (m.optional) {
						optionalExternals.push(m);
					} else {
						requiredExternals.push(m);
					}
				}
				externals = requiredExternals.concat(optionalExternals);
			} else {
				requiredExternals = externals;
			}

			const replaceKeys = str => {
				return mainTemplate.getAssetPath(str, {
					hash,
					chunk
				});
			};

			const externalsDepsArray = modules => {
				return `[${replaceKeys(
					modules
						.map(m =>
							JSON.stringify(
								typeof m.request == "object" ? m.request.amd : m.request
							)
						)
						.join(", ")
				)}]`;
			};

			const externalsRootArray = modules => {
				return replaceKeys(
					modules
						.map(m => {
							let request = m.request;
							if (typeof request == "object") request = request.root;
							return `root${accessorToObjectAccess([].concat(request))}`;
						})
						.join(", ")
				);
			};

			const externalsRequireArray = type => {
				return replaceKeys(
					externals
						.map(m => {
							let expr;
							let request = m.request;
							if (typeof request == "object") {
								request = request[type];
							}
							if (request === void 0) {
								throw new Error(
									"Missing external configuration for type:" + type
								);
							}
							if (Array.isArray(request)) {
								expr = `require(${JSON.stringify(
									request[0]
								)})${accessorToObjectAccess(request.slice(1))}`;
							} else {
								expr = `require(${JSON.stringify(request)})`;
							}
							if (m.optional) {
								expr = `(function webpackLoadOptionalExternalModule() { try { return ${expr}; } catch(e) {} }())`;
							}
							return expr;
						})
						.join(", ")
				);
			};

			const externalsArguments = modules => {
				return modules
					.map(
						m =>
							`__WEBPACK_EXTERNAL_MODULE_${Template.toIdentifier(`${m.id}`)}__`
					)
					.join(", ");
			};

			const libraryName = library => {
				return JSON.stringify(replaceKeys([].concat(library).pop()));
			};

			let amdFactory;
			if (optionalExternals.length > 0) {
				const wrapperArguments = externalsArguments(requiredExternals);
				const factoryArguments =
					requiredExternals.length > 0
						? externalsArguments(requiredExternals) +
							", " +
							externalsRootArray(optionalExternals)
						: externalsRootArray(optionalExternals);
				amdFactory =
					`function webpackLoadOptionalExternalModuleAmd(${wrapperArguments}) {\n\t\t\treturn factory(${factoryArguments});\n\t\t}`;
			} else {
				amdFactory = "factory";
			}

			const auxiliaryComment = this.auxiliaryComment;

			const getAuxilaryComment = type => {
				if (auxiliaryComment) {
					if (typeof auxiliaryComment == "string")
						return "\t//" + auxiliaryComment + "\n";
					if (auxiliaryComment[type])
						return "\t//" + auxiliaryComment[type] + "\n";
				}
				return "";
			};

			return new ConcatSource(
				new OriginalSource(
					"(function webpackUniversalModuleDefinition(root, factory) {\n" +
						getAuxilaryComment("commonjs2") +
						"\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(" +
						externalsRequireArray("commonjs2") +
						");\n" +
						getAuxilaryComment("amd") +
						"\telse if(typeof define === 'function' && define.amd)\n" +
						(requiredExternals.length > 0
							? this.names.amd && this.namedDefine === true
								? "\t\tdefine(" +
									libraryName(this.names.amd) +
									", " +
									externalsDepsArray(requiredExternals) +
									", " +
									amdFactory +
									");\n"
								: "\t\tdefine(" +
									externalsDepsArray(requiredExternals) +
									", " +
									amdFactory +
									");\n"
							: this.names.amd && this.namedDefine === true
							? "\t\tdefine(" +
								libraryName(this.names.amd) +
								", [], " +
								amdFactory +
								");\n"
							: "\t\tdefine([], " + amdFactory + ");\n") +
						(this.names.root || this.names.commonjs
							? getAuxilaryComment("commonjs") +
								"\telse if(typeof exports === 'object')\n\t\texports[" +
								libraryName(this.names.commonjs || this.names.root) +
								"] = factory(" +
								externalsRequireArray("commonjs") +
								");\n" +
								getAuxilaryComment("root") +
								"\telse\n\t\t" +
								replaceKeys(
									accessorAccess("root", this.names.root || this.names.commonjs)
								) +
								" = factory(" +
								externalsRootArray(externals) +
								");\n"
							: "\telse {\n" +
								(externals.length > 0
									? "\t\tvar a = typeof exports === 'object' ? factory(" +
										externalsRequireArray("commonjs") +
										") : factory(" +
										externalsRootArray(externals) +
										");\n"
									: "\t\tvar a = factory();\n") +
								"\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n") +
						`})(${
							runtimeTemplate.outputOptions.globalObject
						}, function(${externalsArguments(externals)}) {\nreturn `,
					"webpack/universalModuleDefinition"
				),
				source,
				";\n})"
			);
		};

		for (const template of [mainTemplate, chunkTemplate]) {
			template.hooks.renderWithEntry.tap(
				"UmdMainTemplatePlugin",
				onRenderWithEntry
			);
		}

		mainTemplate.hooks.globalHashPaths.tap("UmdMainTemplatePlugin", paths => {
			if (this.names.root) paths = paths.concat(this.names.root);
			if (this.names.amd) paths = paths.concat(this.names.amd);
			if (this.names.commonjs) paths = paths.concat(this.names.commonjs);
			return paths;
		});

		mainTemplate.hooks.hash.tap("UmdMainTemplatePlugin", hash => {
			hash.update("umd");
			hash.update(`${this.names.root}`);
			hash.update(`${this.names.amd}`);
			hash.update(`${this.names.commonjs}`);
		});
	}
}

module.exports = UmdMainTemplatePlugin;

},
// 125
function(module, exports, __webpack_require__) {

const NullDependency = __webpack_require__(7);

class AMDRequireDependency extends NullDependency {
	constructor(block) {
		super();
		this.block = block;
	}
}

AMDRequireDependency.Template = class {
	apply(dep, source, runtime) {
		const depBlock = dep.block;
		const promise = runtime.blockPromise({
			block: depBlock,
			message: "AMD require"
		});

		if (depBlock.arrayRange && !depBlock.functionRange) {
			const startBlock = `${promise}.then(function() {`;
			const endBlock = `;}).catch(${runtime.onError()})`;
			source.replace(
				depBlock.outerRange[0],
				depBlock.arrayRange[0] - 1,
				startBlock
			);
			source.replace(
				depBlock.arrayRange[1],
				depBlock.outerRange[1] - 1,
				endBlock
			);
			return;
		}

		if (depBlock.functionRange && !depBlock.arrayRange) {
			const startBlock = `${promise}.then((`;
			const endBlock = `).bind(exports, __webpack_require__, exports, module)).catch(${runtime.onError()})`;
			source.replace(
				depBlock.outerRange[0],
				depBlock.functionRange[0] - 1,
				startBlock
			);
			source.replace(
				depBlock.functionRange[1],
				depBlock.outerRange[1] - 1,
				endBlock
			);
			return;
		}

		if (
			depBlock.arrayRange &&
			depBlock.functionRange &&
			depBlock.errorCallbackRange
		) {
			const startBlock = `${promise}.then(function() { `;
			const errorRangeBlock = `}${
				depBlock.functionBindThis ? ".bind(this)" : ""
			}).catch(`;
			const endBlock = `${
				depBlock.errorCallbackBindThis ? ".bind(this)" : ""
			})`;

			source.replace(
				depBlock.outerRange[0],
				depBlock.arrayRange[0] - 1,
				startBlock
			);
			source.insert(
				depBlock.arrayRange[0] + 0.9,
				"var __WEBPACK_AMD_REQUIRE_ARRAY__ = "
			);
			source.replace(
				depBlock.arrayRange[1],
				depBlock.functionRange[0] - 1,
				"; ("
			);
			source.insert(
				depBlock.functionRange[1],
				").apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__);"
			);
			source.replace(
				depBlock.functionRange[1],
				depBlock.errorCallbackRange[0] - 1,
				errorRangeBlock
			);
			source.replace(
				depBlock.errorCallbackRange[1],
				depBlock.outerRange[1] - 1,
				endBlock
			);
			return;
		}

		if (depBlock.arrayRange && depBlock.functionRange) {
			const startBlock = `${promise}.then(function() { `;
			const endBlock = `}${
				depBlock.functionBindThis ? ".bind(this)" : ""
			}).catch(${runtime.onError()})`;
			source.replace(
				depBlock.outerRange[0],
				depBlock.arrayRange[0] - 1,
				startBlock
			);
			source.insert(
				depBlock.arrayRange[0] + 0.9,
				"var __WEBPACK_AMD_REQUIRE_ARRAY__ = "
			);
			source.replace(
				depBlock.arrayRange[1],
				depBlock.functionRange[0] - 1,
				"; ("
			);
			source.insert(
				depBlock.functionRange[1],
				").apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__);"
			);
			source.replace(
				depBlock.functionRange[1],
				depBlock.outerRange[1] - 1,
				endBlock
			);
		}
	}
};

module.exports = AMDRequireDependency;

},
// 126
function(module, exports, __webpack_require__) {

const NullDependency = __webpack_require__(7);

class AMDDefineDependency extends NullDependency {
	constructor(range, arrayRange, functionRange, objectRange, namedModule) {
		super();
		this.range = range;
		this.arrayRange = arrayRange;
		this.functionRange = functionRange;
		this.objectRange = objectRange;
		this.namedModule = namedModule;
		this.localModule = null;
	}

	get type() {
		return "amd define";
	}
}

AMDDefineDependency.Template = class {
	get definitions() {
		return {
			f: [
				"var __WEBPACK_AMD_DEFINE_RESULT__;",
				`!(__WEBPACK_AMD_DEFINE_RESULT__ = (#).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))`
			],
			o: ["", "!(module.exports = #)"],
			of: [
				"var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;",
				`!(__WEBPACK_AMD_DEFINE_FACTORY__ = (#),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))`
			],
			af: [
				"var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;",
				`!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, __WEBPACK_AMD_DEFINE_RESULT__ = (#).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))`
			],
			ao: ["", "!(#, module.exports = #)"],
			aof: [
				"var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;",
				`!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, __WEBPACK_AMD_DEFINE_FACTORY__ = (#),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))`
			],
			lf: [
				"var XXX, XXXmodule;",
				"!(XXXmodule = { id: YYY, exports: {}, loaded: false }, XXX = #.call(XXXmodule.exports, __webpack_require__, XXXmodule.exports, XXXmodule), XXXmodule.loaded = true, XXX === undefined && (XXX = XXXmodule.exports))"
			],
			lo: ["var XXX;", "!(XXX = #)"],
			lof: [
				"var XXX, XXXfactory, XXXmodule;",
				"!(XXXfactory = (#), (XXXmodule = { id: YYY, exports: {}, loaded: false }), XXX = (typeof XXXfactory === 'function' ? (XXXfactory.call(XXXmodule.exports, __webpack_require__, XXXmodule.exports, XXXmodule)) : XXXfactory), (XXXmodule.loaded = true), XXX === undefined && (XXX = XXXmodule.exports))"
			],
			laf: [
				"var __WEBPACK_AMD_DEFINE_ARRAY__, XXX;",
				"!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, XXX = ((#).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)))"
			],
			lao: ["var XXX;", "!(#, XXX = #)"],
			laof: [
				"var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, XXX;",
				`!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, __WEBPACK_AMD_DEFINE_FACTORY__ = (#),
				XXX = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__))`
			]
		};
	}

	apply(dependency, source) {
		const branch = this.branch(dependency);
		const defAndText = this.definitions[branch];
		const definitions = defAndText[0];
		const text = defAndText[1];
		this.replace(dependency, source, definitions, text);
	}

	localModuleVar(dependency) {
		return (
			dependency.localModule &&
			dependency.localModule.used &&
			dependency.localModule.variableName()
		);
	}

	branch(dependency) {
		const localModuleVar = this.localModuleVar(dependency) ? "l" : "";
		const arrayRange = dependency.arrayRange ? "a" : "";
		const objectRange = dependency.objectRange ? "o" : "";
		const functionRange = dependency.functionRange ? "f" : "";
		return localModuleVar + arrayRange + objectRange + functionRange;
	}

	replace(dependency, source, definition, text) {
		const localModuleVar = this.localModuleVar(dependency);
		if (localModuleVar) {
			text = text.replace(/XXX/g, localModuleVar.replace(/\$/g, "$$$$"));
			definition = definition.replace(
				/XXX/g,
				localModuleVar.replace(/\$/g, "$$$$")
			);
		}

		if (dependency.namedModule) {
			text = text.replace(/YYY/g, JSON.stringify(dependency.namedModule));
		}

		const texts = text.split("#");

		if (definition) source.insert(0, definition);

		let current = dependency.range[0];
		if (dependency.arrayRange) {
			source.replace(current, dependency.arrayRange[0] - 1, texts.shift());
			current = dependency.arrayRange[1];
		}

		if (dependency.objectRange) {
			source.replace(current, dependency.objectRange[0] - 1, texts.shift());
			current = dependency.objectRange[1];
		} else if (dependency.functionRange) {
			source.replace(current, dependency.functionRange[0] - 1, texts.shift());
			current = dependency.functionRange[1];
		}
		source.replace(current, dependency.range[1] - 1, texts.shift());
		if (texts.length > 0) throw new Error("Implementation error");
	}
};

module.exports = AMDDefineDependency;

},
// 127
function(module, exports, __webpack_require__) {

const NullDependency = __webpack_require__(7);
const webpackMissingModule = __webpack_require__(38).module;

class UnsupportedDependency extends NullDependency {
	constructor(request, range) {
		super();
		this.request = request;
		this.range = range;
	}
}

UnsupportedDependency.Template = class {
	apply(dep, source, runtime) {
		source.replace(
			dep.range[0],
			dep.range[1],
			webpackMissingModule(dep.request)
		);
	}
};

module.exports = UnsupportedDependency;

},
// 128
function(module, exports, __webpack_require__) {

class Queue {
	constructor(items) {
		this.set = new Set(items);
		this.iterator = this.set[Symbol.iterator]();
	}

	get length() {
		return this.set.size;
	}

	enqueue(item) {
		this.set.add(item);
	}

	dequeue() {
		const result = this.iterator.next();
		if (result.done) return void 0;
		this.set.delete(result.value);
		return result.value;
	}
}

module.exports = Queue;

},
// 129
function(module, exports, __webpack_require__) {

const mm = __webpack_require__(289);
const HarmonyExportImportedSpecifierDependency = __webpack_require__(43);
const HarmonyImportSideEffectDependency = __webpack_require__(28);
const HarmonyImportSpecifierDependency = __webpack_require__(42);

const getMappingFromInfo = (info, exportName) => {
	const staticMappings = info.static.get(exportName);
	if (staticMappings !== void 0) {
		if (staticMappings.length === 1) return staticMappings[0];
		return void 0;
	}
	const dynamicMappings = Array.from(info.dynamic).filter(
		([_, ignored]) => !ignored.has(exportName)
	);
	if (dynamicMappings.length === 1)
		return {
			module: dynamicMappings[0][0],
			exportName,
			checked: true
		};

	return void 0;
};

const addStaticReexport = (
	info,
	exportName,
	module,
	innerExportName,
	checked
) => {
	let mappings = info.static.get(exportName);
	if (mappings !== void 0) {
		for (const mapping of mappings) {
			if (mapping.module === module && mapping.exportName === innerExportName) {
				mapping.checked = mapping.checked && checked;
				return;
			}
		}
	} else {
		mappings = [];
		info.static.set(exportName, mappings);
	}
	mappings.push({
		module,
		exportName: innerExportName,
		checked
	});
};

const addDynamicReexport = (info, module, ignored) => {
	const existingList = info.dynamic.get(module);
	if (existingList !== void 0) {
		for (const key of existingList) {
			if (!ignored.has(key)) existingList.delete(key);
		}
	} else {
		info.dynamic.set(module, new Set(ignored));
	}
};

class SideEffectsFlagPlugin {
	apply(compiler) {
		compiler.hooks.normalModuleFactory.tap("SideEffectsFlagPlugin", nmf => {
			nmf.hooks.module.tap("SideEffectsFlagPlugin", (module, data) => {
				const resolveData = data.resourceResolveData;
				if (
					resolveData &&
					resolveData.descriptionFileData &&
					resolveData.relativePath
				) {
					const sideEffects = resolveData.descriptionFileData.sideEffects;
					const hasSideEffects = SideEffectsFlagPlugin.moduleHasSideEffects(
						resolveData.relativePath,
						sideEffects
					);
					if (!hasSideEffects) {
						module.factoryMeta.sideEffectFree = true;
					}
				}

				return module;
			});
			nmf.hooks.module.tap("SideEffectsFlagPlugin", (module, data) => {
				if (data.settings.sideEffects === false) {
					module.factoryMeta.sideEffectFree = true;
				} else if (data.settings.sideEffects === true) {
					module.factoryMeta.sideEffectFree = false;
				}
			});
		});
		compiler.hooks.compilation.tap("SideEffectsFlagPlugin", compilation => {
			compilation.hooks.optimizeDependencies.tap(
				"SideEffectsFlagPlugin",
				modules => {
					const reexportMaps = new Map();

					for (const module of modules) {
						const removeDependencies = [];
						for (const dep of module.dependencies) {
							if (dep instanceof HarmonyImportSideEffectDependency) {
								if (dep.module && dep.module.factoryMeta.sideEffectFree) {
									removeDependencies.push(dep);
								}
							} else if (
								dep instanceof HarmonyExportImportedSpecifierDependency
							) {
								if (module.factoryMeta.sideEffectFree) {
									const mode = dep.getMode(true);
									if (
										mode.type === "safe-reexport" ||
										mode.type === "checked-reexport" ||
										mode.type === "dynamic-reexport" ||
										mode.type === "reexport-non-harmony-default" ||
										mode.type === "reexport-non-harmony-default-strict" ||
										mode.type === "reexport-named-default"
									) {
										let info = reexportMaps.get(module);
										if (!info) {
											reexportMaps.set(
												module,
												(info = {
													static: new Map(),
													dynamic: new Map()
												})
											);
										}
										const targetModule = dep._module;
										switch (mode.type) {
											case "safe-reexport":
												for (const [key, id] of mode.map) {
													if (id) {
														addStaticReexport(
															info,
															key,
															targetModule,
															id,
															false
														);
													}
												}
												break;
											case "checked-reexport":
												for (const [key, id] of mode.map) {
													if (id) {
														addStaticReexport(
															info,
															key,
															targetModule,
															id,
															true
														);
													}
												}
												break;
											case "dynamic-reexport":
												addDynamicReexport(info, targetModule, mode.ignored);
												break;
											case "reexport-non-harmony-default":
											case "reexport-non-harmony-default-strict":
											case "reexport-named-default":
												addStaticReexport(
													info,
													mode.name,
													targetModule,
													"default",
													false
												);
												break;
										}
									}
								}
							}
						}
					}

					for (const info of reexportMaps.values()) {
						const dynamicReexports = info.dynamic;
						info.dynamic = new Map();
						for (const reexport of dynamicReexports) {
							let [targetModule, ignored] = reexport;
							for (;;) {
								const innerInfo = reexportMaps.get(targetModule);
								if (!innerInfo) break;

								for (const [key, reexports] of innerInfo.static) {
									if (ignored.has(key)) continue;
									for (const { module, exportName, checked } of reexports) {
										addStaticReexport(info, key, module, exportName, checked);
									}
								}

								if (innerInfo.dynamic.size !== 1) {
									break;
								}

								ignored = new Set(ignored);
								for (const [innerModule, innerIgnored] of innerInfo.dynamic) {
									for (const key of innerIgnored) {
										if (ignored.has(key)) continue;
										addStaticReexport(info, key, targetModule, key, true);
										ignored.add(key);
									}
									targetModule = innerModule;
								}
							}

							addDynamicReexport(info, targetModule, ignored);
						}
					}

					for (const info of reexportMaps.values()) {
						const staticReexports = info.static;
						info.static = new Map();
						for (const [key, reexports] of staticReexports) {
							for (let mapping of reexports) {
								for (;;) {
									const innerInfo = reexportMaps.get(mapping.module);
									if (!innerInfo) break;

									const newMapping = getMappingFromInfo(
										innerInfo,
										mapping.exportName
									);
									if (!newMapping) break;
									mapping = newMapping;
								}
								addStaticReexport(
									info,
									key,
									mapping.module,
									mapping.exportName,
									mapping.checked
								);
							}
						}
					}

					for (const pair of reexportMaps) {
						const module = pair[0];
						const info = pair[1];
						let newReasons = void 0;
						for (let i = 0; i < module.reasons.length; i++) {
							const reason = module.reasons[i];
							const dep = reason.dependency;
							if (
								(dep instanceof HarmonyExportImportedSpecifierDependency ||
									(dep instanceof HarmonyImportSpecifierDependency &&
										!dep.namespaceObjectAsContext)) &&
								dep._id
							) {
								const mapping = getMappingFromInfo(info, dep._id);
								if (mapping) {
									dep.redirectedModule = mapping.module;
									dep.redirectedId = mapping.exportName;
									mapping.module.addReason(
										reason.module,
										dep,
										reason.explanation
											? reason.explanation +
													" (skipped side-effect-free modules)"
											: "(skipped side-effect-free modules)"
									);
									if (newReasons === void 0) {
										newReasons = i === 0 ? [] : module.reasons.slice(0, i);
									}
									continue;
								}
							}
							if (newReasons !== void 0) newReasons.push(reason);
						}
						if (newReasons !== void 0) {
							module.reasons = newReasons;
						}
					}
				}
			);
		});
	}

	static moduleHasSideEffects(moduleName, flagValue) {
		switch (typeof flagValue) {
			case "undefined":
				return true;
			case "boolean":
				return flagValue;
			case "string":
				if (process.platform === "win32") {
					flagValue = flagValue.replace(/\\/g, "/");
				}
				return mm.isMatch(moduleName, flagValue, {
					matchBase: true
				});
			case "object":
				return flagValue.some(glob =>
					SideEffectsFlagPlugin.moduleHasSideEffects(moduleName, glob)
				);
		}
	}
}
module.exports = SideEffectsFlagPlugin;

},
// 130
function(module, exports, __webpack_require__) {

const HarmonyImportDependency = __webpack_require__(19);
const ModuleHotAcceptDependency = __webpack_require__(131);
const ModuleHotDeclineDependency = __webpack_require__(132);
const ConcatenatedModule = __webpack_require__(292);
const HarmonyCompatibilityDependency = __webpack_require__(41);
const StackedSetMap = __webpack_require__(84);

const formatBailoutReason = msg => {
	return "ModuleConcatenation bailout: " + msg;
};

class ModuleConcatenationPlugin {
	constructor(options) {
		if (typeof options != "object") options = {};
		this.options = options;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap(
			"ModuleConcatenationPlugin",
			(compilation, { normalModuleFactory }) => {
				const handler = (parser, parserOptions) => {
					parser.hooks.call.for("eval").tap("ModuleConcatenationPlugin", () => {
						parser.state.module.buildMeta.moduleConcatenationBailout = "eval()";
					});
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("ModuleConcatenationPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("ModuleConcatenationPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/esm")
					.tap("ModuleConcatenationPlugin", handler);

				const bailoutReasonMap = new Map();

				const setBailoutReason = (module, reason) => {
					bailoutReasonMap.set(module, reason);
					module.optimizationBailout.push(
						typeof reason == "function"
							? rs => formatBailoutReason(reason(rs))
							: formatBailoutReason(reason)
					);
				};

				const getBailoutReason = (module, requestShortener) => {
					const reason = bailoutReasonMap.get(module);
					if (typeof reason == "function") return reason(requestShortener);
					return reason;
				};

				compilation.hooks.optimizeChunkModules.tap(
					"ModuleConcatenationPlugin",
					(allChunks, modules) => {
						const relevantModules = [];
						const possibleInners = new Set();
						for (const module of modules) {
							if (
								!module.buildMeta ||
								module.buildMeta.exportsType !== "namespace" ||
								!module.dependencies.some(
									d => d instanceof HarmonyCompatibilityDependency
								)
							) {
								setBailoutReason(module, "Module is not an ECMAScript module");
								continue;
							}

							if (
								module.buildMeta &&
								module.buildMeta.moduleConcatenationBailout
							) {
								setBailoutReason(
									module,
									`Module uses ${module.buildMeta.moduleConcatenationBailout}`
								);
								continue;
							}

							if (!Array.isArray(module.buildMeta.providedExports)) {
								setBailoutReason(module, "Module exports are unknown");
								continue;
							}

							if (module.variables.length > 0) {
								setBailoutReason(
									module,
									`Module uses injected variables (${module.variables
										.map(v => v.name)
										.join(", ")})`
								);
								continue;
							}

							if (
								module.dependencies.some(
									dep =>
										dep instanceof ModuleHotAcceptDependency ||
										dep instanceof ModuleHotDeclineDependency
								)
							) {
								setBailoutReason(module, "Module uses Hot Module Replacement");
								continue;
							}

							relevantModules.push(module);

							if (module.isEntryModule()) {
								setBailoutReason(module, "Module is an entry point");
								continue;
							}

							if (module.getNumberOfChunks() === 0) {
								setBailoutReason(module, "Module is not in any chunk");
								continue;
							}

							const nonHarmonyReasons = module.reasons.filter(
								reason =>
									!reason.dependency ||
									!(reason.dependency instanceof HarmonyImportDependency)
							);
							if (nonHarmonyReasons.length > 0) {
								const importingModules = new Set(
									nonHarmonyReasons.map(r => r.module).filter(Boolean)
								);
								const importingExplanations = new Set(
									nonHarmonyReasons.map(r => r.explanation).filter(Boolean)
								);
								const importingModuleTypes = new Map(
									Array.from(importingModules).map(
										m => ([
											m,
											new Set(
												nonHarmonyReasons
													.filter(r => r.module === m)
													.map(r => r.dependency.type)
													.sort()
											)
										])
									)
								);
								setBailoutReason(module, requestShortener => {
									const names = Array.from(importingModules)
										.map(
											m =>
												`${m.readableIdentifier(
													requestShortener
												)} (referenced with ${Array.from(
													importingModuleTypes.get(m)
												).join(", ")})`
										)
										.sort();
									const explanations = Array.from(importingExplanations).sort();
									if (names.length > 0 && explanations.length === 0) {
										return `Module is referenced from these modules with unsupported syntax: ${names.join(
											", "
										)}`;
									} else if (names.length === 0 && explanations.length > 0) {
										return `Module is referenced by: ${explanations.join(
											", "
										)}`;
									} else if (names.length > 0 && explanations.length > 0) {
										return `Module is referenced from these modules with unsupported syntax: ${names.join(
											", "
										)} and by: ${explanations.join(", ")}`;
									} else {
										return "Module is referenced in a unsupported way";
									}
								});
								continue;
							}

							possibleInners.add(module);
						}
						relevantModules.sort((a, b) => {
							return a.depth - b.depth;
						});
						const concatConfigurations = [];
						const usedAsInner = new Set();
						for (const currentRoot of relevantModules) {
							if (usedAsInner.has(currentRoot)) continue;

							const currentConfiguration = new ConcatConfiguration(currentRoot);

							const failureCache = new Map();

							for (const imp of this._getImports(compilation, currentRoot)) {
								const problem = this._tryToAdd(
									compilation,
									currentConfiguration,
									imp,
									possibleInners,
									failureCache
								);
								if (problem) {
									failureCache.set(imp, problem);
									currentConfiguration.addWarning(imp, problem);
								}
							}
							if (!currentConfiguration.isEmpty()) {
								concatConfigurations.push(currentConfiguration);
								for (const module of currentConfiguration.getModules()) {
									if (module !== currentConfiguration.rootModule) {
										usedAsInner.add(module);
									}
								}
							}
						}
						concatConfigurations.sort((a, b) => {
							return b.modules.size - a.modules.size;
						});
						const usedModules = new Set();
						for (const concatConfiguration of concatConfigurations) {
							if (usedModules.has(concatConfiguration.rootModule)) continue;
							const modules = concatConfiguration.getModules();
							const rootModule = concatConfiguration.rootModule;
							const newModule = new ConcatenatedModule(
								rootModule,
								Array.from(modules),
								ConcatenatedModule.createConcatenationList(
									rootModule,
									modules,
									compilation
								)
							);
							for (const warning of concatConfiguration.getWarningsSorted()) {
								newModule.optimizationBailout.push(requestShortener => {
									const reason = getBailoutReason(warning[0], requestShortener);
									const reasonWithPrefix = reason ? ` (<- ${reason})` : "";
									if (warning[0] === warning[1]) {
										return formatBailoutReason(
											`Cannot concat with ${warning[0].readableIdentifier(
												requestShortener
											)}${reasonWithPrefix}`
										);
									} else {
										return formatBailoutReason(
											`Cannot concat with ${warning[0].readableIdentifier(
												requestShortener
											)} because of ${warning[1].readableIdentifier(
												requestShortener
											)}${reasonWithPrefix}`
										);
									}
								});
							}
							const chunks = concatConfiguration.rootModule.getChunks();
							for (const m of modules) {
								usedModules.add(m);
								for (const chunk of chunks) {
									chunk.removeModule(m);
								}
							}
							for (const chunk of chunks) {
								chunk.addModule(newModule);
								newModule.addChunk(chunk);
							}
							for (const chunk of allChunks) {
								if (chunk.entryModule === concatConfiguration.rootModule) {
									chunk.entryModule = newModule;
								}
							}
							compilation.modules.push(newModule);
							for (const reason of newModule.reasons) {
								if (reason.dependency.module === concatConfiguration.rootModule)
									reason.dependency.module = newModule;
								if (
									reason.dependency.redirectedModule ===
									concatConfiguration.rootModule
								)
									reason.dependency.redirectedModule = newModule;
							}
							for (let i = 0; i < newModule.dependencies.length; i++) {
								let dep = newModule.dependencies[i];
								if (dep.module) {
									let reasons = dep.module.reasons;
									for (let j = 0; j < reasons.length; j++) {
										let reason = reasons[j];
										if (reason.dependency === dep) {
											reason.module = newModule;
										}
									}
								}
							}
						}
						compilation.modules = compilation.modules.filter(
							m => !usedModules.has(m)
						);
					}
				);
			}
		);
	}

	_getImports(compilation, module) {
		return new Set(
			module.dependencies

				.map(dep => {
					if (!(dep instanceof HarmonyImportDependency)) return null;
					if (!compilation) return dep.getReference();
					return compilation.getDependencyReference(module, dep);
				})

				.filter(
					ref =>
						ref &&
						ref.module &&
						(Array.isArray(ref.importedNames) ||
							Array.isArray(ref.module.buildMeta.providedExports))
				)

				.map(ref => ref.module)
		);
	}

	_tryToAdd(compilation, config, module, possibleModules, failureCache) {
		const cacheEntry = failureCache.get(module);
		if (cacheEntry) {
			return cacheEntry;
		}

		if (config.has(module)) {
			return null;
		}

		if (!possibleModules.has(module)) {
			failureCache.set(module, module);
			return module;
		}

		if (!config.rootModule.hasEqualsChunks(module)) {
			failureCache.set(module, module);
			return module;
		}

		const testConfig = config.clone();

		testConfig.add(module);

		for (const reason of module.reasons) {
			if (
				reason.module.factoryMeta.sideEffectFree &&
				reason.module.used === false
			)
				continue;

			const problem = this._tryToAdd(
				compilation,
				testConfig,
				reason.module,
				possibleModules,
				failureCache
			);
			if (problem) {
				failureCache.set(module, problem);
				return problem;
			}
		}

		config.set(testConfig);

		for (const imp of this._getImports(compilation, module)) {
			const problem = this._tryToAdd(
				compilation,
				config,
				imp,
				possibleModules,
				failureCache
			);
			if (problem) {
				config.addWarning(imp, problem);
			}
		}
		return null;
	}
}

class ConcatConfiguration {
	constructor(rootModule, cloneFrom) {
		this.rootModule = rootModule;
		if (cloneFrom) {
			this.modules = cloneFrom.modules.createChild(5);
			this.warnings = cloneFrom.warnings.createChild(5);
		} else {
			this.modules = new StackedSetMap();
			this.modules.add(rootModule);
			this.warnings = new StackedSetMap();
		}
	}

	add(module) {
		this.modules.add(module);
	}

	has(module) {
		return this.modules.has(module);
	}

	isEmpty() {
		return this.modules.size === 1;
	}

	addWarning(module, problem) {
		this.warnings.set(module, problem);
	}

	getWarningsSorted() {
		return new Map(
			this.warnings.asPairArray().sort((a, b) => {
				const ai = a[0].identifier();
				const bi = b[0].identifier();
				if (ai < bi) return -1;
				if (ai > bi) return 1;
				return 0;
			})
		);
	}

	getModules() {
		return this.modules.asSet();
	}

	clone() {
		return new ConcatConfiguration(this.rootModule, this);
	}

	set(config) {
		this.rootModule = config.rootModule;
		this.modules = config.modules;
		this.warnings = config.warnings;
	}
}

module.exports = ModuleConcatenationPlugin;

},
// 131
function(module, exports, __webpack_require__) {

const ModuleDependency = __webpack_require__(4);
const ModuleDependencyTemplateAsId = __webpack_require__(39);

class ModuleHotAcceptDependency extends ModuleDependency {
	constructor(request, range) {
		super(request);
		this.range = range;
		this.weak = true;
	}

	get type() {
		return "module.hot.accept";
	}
}

ModuleHotAcceptDependency.Template = ModuleDependencyTemplateAsId;

module.exports = ModuleHotAcceptDependency;

},
// 132
function(module, exports, __webpack_require__) {

const ModuleDependency = __webpack_require__(4);
const ModuleDependencyTemplateAsId = __webpack_require__(39);

class ModuleHotDeclineDependency extends ModuleDependency {
	constructor(request, range) {
		super(request);
		this.range = range;
		this.weak = true;
	}

	get type() {
		return "module.hot.decline";
	}
}

ModuleHotDeclineDependency.Template = ModuleDependencyTemplateAsId;

module.exports = ModuleHotDeclineDependency;

},
// 133
function(module, exports, __webpack_require__) {

const Syntax = __webpack_require__(49).Syntax,

	Reference = __webpack_require__(70),
	Variable = __webpack_require__(50),
	Definition = __webpack_require__(134).Definition,
	assert = __webpack_require__(48);

function isStrictScope(scope, block, isMethodDefinition, useDirective) {
	let body;

	if (
		(scope.upper && scope.upper.isStrict) ||
		isMethodDefinition ||
		scope.type === "class" || scope.type === "module"
	)
		return true;

	if (scope.type === "block" || scope.type === "switch") return false;

	if (scope.type === "function") {
		if (block.type === Syntax.ArrowFunctionExpression && block.body.type !== Syntax.BlockStatement)
			return false;

		body = block.type === Syntax.Program ? block : block.body;

		if (!body) return false;
	} else if (scope.type === "global") body = block;
	else return false;

	if (useDirective)
		for (let i = 0, iz = body.body.length; i < iz; ++i) {
			const stmt = body.body[i];

			if (stmt.type !== Syntax.DirectiveStatement) break;

			if (stmt.raw === "\"use strict\"" || stmt.raw === "'use strict'") return true;
		}
	else
		for (let i = 0, iz = body.body.length; i < iz; ++i) {
			const stmt = body.body[i];

			if (stmt.type !== Syntax.ExpressionStatement) break;

			const expr = stmt.expression;

			if (expr.type !== Syntax.Literal || typeof expr.value != "string") break;

			if (expr.raw !== null && expr.raw !== void 0) {
				if (expr.raw === "\"use strict\"" || expr.raw === "'use strict'") return true;
			} else if (expr.value === "use strict") return true;
		}

	return false;
}

function registerScope(scopeManager, scope) {
	scopeManager.scopes.push(scope);

	const scopes = scopeManager.__nodeToScope.get(scope.block);

	scopes ? scopes.push(scope) : scopeManager.__nodeToScope.set(scope.block, [scope]);
}

function shouldBeStatically(def) {
	return (
		def.type === Variable.ClassName ||
		(def.type === Variable.Variable && def.parent.kind !== "var")
	);
}

class Scope {
	constructor(scopeManager, type, upperScope, block, isMethodDefinition) {
		this.type = type;

		this.set = new Map();
		this.taints = new Map();

		this.dynamic = this.type === "global" || this.type === "with";

		this.block = block;

		this.through = [];
		this.variables = [];
		this.references = [];

		this.variableScope =
			this.type === "global" || this.type === "function" || this.type === "module"
				? this
				: upperScope.variableScope;

		this.functionExpressionScope = false;
		this.directCallToEvalScope = false;
		this.thisFound = false;

		this.__left = [];

		this.upper = upperScope;

		this.isStrict = isStrictScope(this, block, isMethodDefinition, scopeManager.__useDirective());

		this.childScopes = [];
		this.upper && this.upper.childScopes.push(this);

		this.__declaredVariables = scopeManager.__declaredVariables;

		registerScope(scopeManager, this);
	}

	__shouldStaticallyClose(scopeManager) {
		return !this.dynamic || scopeManager.__isOptimistic();
	}

	__shouldStaticallyCloseForGlobal(ref) {
		const name = ref.identifier.name;

		if (!this.set.has(name)) return false;

		const defs = this.set.get(name).defs;

		return defs.length > 0 && defs.every(shouldBeStatically);
	}

	__staticCloseRef(ref) {
		this.__resolve(ref) || this.__delegateToUpperScope(ref);
	}

	__dynamicCloseRef(ref) {
		let current = this;

		do {
			current.through.push(ref);
			current = current.upper;
		} while (current);
	}

	__globalCloseRef(ref) {
		this.__shouldStaticallyCloseForGlobal(ref)
			? this.__staticCloseRef(ref)
			: this.__dynamicCloseRef(ref);
	}

	__close(scopeManager) {
		let closeRef = this.__shouldStaticallyClose(scopeManager)
			? this.__staticCloseRef
			: this.type !== "global"
			? this.__dynamicCloseRef
			: this.__globalCloseRef;

		for (let i = 0, iz = this.__left.length; i < iz; ++i) {
			const ref = this.__left[i];

			closeRef.call(this, ref);
		}
		this.__left = null;

		return this.upper;
	}

	__isValidResolution(ref, variable) {
		return true;
	}

	__resolve(ref) {
		const name = ref.identifier.name;

		if (!this.set.has(name)) return false;

		const variable = this.set.get(name);

		if (!this.__isValidResolution(ref, variable)) return false;

		variable.references.push(ref);
		variable.stack = variable.stack && ref.from.variableScope === this.variableScope;
		if (ref.tainted) {
			variable.tainted = true;
			this.taints.set(variable.name, true);
		}
		ref.resolved = variable;

		return true;
	}

	__delegateToUpperScope(ref) {
		this.upper && this.upper.__left.push(ref);

		this.through.push(ref);
	}

	__addDeclaredVariablesOfNode(variable, node) {
		if (node === null || node === void 0) return;

		let variables = this.__declaredVariables.get(node);

		if (variables === null || variables === void 0) {
			variables = [];
			this.__declaredVariables.set(node, variables);
		}
		variables.indexOf(variable) > -1 || variables.push(variable);
	}

	__defineGeneric(name, set, variables, node, def) {
		let variable = set.get(name);

		if (!variable) {
			variable = new Variable(name, this);
			set.set(name, variable);
			variables.push(variable);
		}

		if (def) {
			variable.defs.push(def);
			this.__addDeclaredVariablesOfNode(variable, def.node);
			this.__addDeclaredVariablesOfNode(variable, def.parent);
		}
		node && variable.identifiers.push(node);
	}

	__define(node, def) {
		node && node.type === Syntax.Identifier &&
			this.__defineGeneric(node.name, this.set, this.variables, node, def);
	}

	__referencing(node, assign, writeExpr, maybeImplicitGlobal, partial, init) {
		if (!node || node.type !== Syntax.Identifier || node.name === "super") return;

		const ref = new Reference(node, this, assign || Reference.READ, writeExpr, maybeImplicitGlobal, !!partial, !!init);

		this.references.push(ref);
		this.__left.push(ref);
	}

	__detectEval() {
		let current = this;

		this.directCallToEvalScope = true;
		do {
			current.dynamic = true;
			current = current.upper;
		} while (current);
	}

	__detectThis() {
		this.thisFound = true;
	}

	__isClosed() {
		return this.__left === null;
	}

	resolve(ident) {
		let ref, i, iz;

		assert(this.__isClosed(), "Scope should be closed.");
		assert(ident.type === Syntax.Identifier, "Target should be identifier.");
		for (i = 0, iz = this.references.length; i < iz; ++i)
			if ((ref = this.references[i]).identifier === ident) return ref;

		return null;
	}

	isStatic() {
		return !this.dynamic;
	}

	isArgumentsMaterialized() {
		return true;
	}

	isThisMaterialized() {
		return true;
	}

	isUsedName(name) {
		if (this.set.has(name)) return true;

		for (let i = 0, iz = this.through.length; i < iz; ++i)
			if (this.through[i].identifier.name === name) return true;

		return false;
	}
}

class GlobalScope extends Scope {
	constructor(scopeManager, block) {
		super(scopeManager, "global", null, block, false);
		this.implicit = { set: new Map(), variables: [], left: [] };
	}

	__close(scopeManager) {
		const implicit = [];

		for (let i = 0, iz = this.__left.length; i < iz; ++i) {
			const ref = this.__left[i];

			!ref.__maybeImplicitGlobal || this.set.has(ref.identifier.name) ||
				implicit.push(ref.__maybeImplicitGlobal);
		}

		for (let i = 0, iz = implicit.length; i < iz; ++i) {
			const info = implicit[i];

			this.__defineImplicit(
				info.pattern,
				new Definition(Variable.ImplicitGlobalVariable, info.pattern, info.node, null, null, null)
			);
		}

		this.implicit.left = this.__left;

		return super.__close(scopeManager);
	}

	__defineImplicit(node, def) {
		node && node.type === Syntax.Identifier &&
			this.__defineGeneric(node.name, this.implicit.set, this.implicit.variables, node, def);
	}
}

class ModuleScope extends Scope {
	constructor(scopeManager, upperScope, block) {
		super(scopeManager, "module", upperScope, block, false);
	}
}

class FunctionExpressionNameScope extends Scope {
	constructor(scopeManager, upperScope, block) {
		super(scopeManager, "function-expression-name", upperScope, block, false);
		this.__define(
			block.id,
			new Definition(Variable.FunctionName, block.id, block, null, null, null)
		);
		this.functionExpressionScope = true;
	}
}

class CatchScope extends Scope {
	constructor(scopeManager, upperScope, block) {
		super(scopeManager, "catch", upperScope, block, false);
	}
}

class WithScope extends Scope {
	constructor(scopeManager, upperScope, block) {
		super(scopeManager, "with", upperScope, block, false);
	}

	__close(scopeManager) {
		if (this.__shouldStaticallyClose(scopeManager)) return super.__close(scopeManager);

		for (let i = 0, iz = this.__left.length; i < iz; ++i) {
			const ref = this.__left[i];

			ref.tainted = true;
			this.__delegateToUpperScope(ref);
		}
		this.__left = null;

		return this.upper;
	}
}

class BlockScope extends Scope {
	constructor(scopeManager, upperScope, block) {
		super(scopeManager, "block", upperScope, block, false);
	}
}

class SwitchScope extends Scope {
	constructor(scopeManager, upperScope, block) {
		super(scopeManager, "switch", upperScope, block, false);
	}
}

class FunctionScope extends Scope {
	constructor(scopeManager, upperScope, block, isMethodDefinition) {
		super(scopeManager, "function", upperScope, block, isMethodDefinition);

		this.block.type === Syntax.ArrowFunctionExpression || this.__defineArguments();
	}

	isArgumentsMaterialized() {
		if (this.block.type === Syntax.ArrowFunctionExpression) return false;

		if (!this.isStatic()) return true;

		const variable = this.set.get("arguments");

		assert(variable, "Always have arguments variable.");
		return variable.tainted || variable.references.length !== 0;
	}

	isThisMaterialized() {
		return !this.isStatic() || this.thisFound;
	}

	__defineArguments() {
		this.__defineGeneric("arguments", this.set, this.variables, null, null);
		this.taints.set("arguments", true);
	}

	__isValidResolution(ref, variable) {
		if (this.block.type === "Program") return true;

		const bodyStart = this.block.body.range[0];

		return !(
			variable.scope === this &&
			ref.identifier.range[0] < bodyStart &&
			variable.defs.every(d => d.name.range[0] >= bodyStart)
		);
	}
}

class ForScope extends Scope {
	constructor(scopeManager, upperScope, block) {
		super(scopeManager, "for", upperScope, block, false);
	}
}

class ClassScope extends Scope {
	constructor(scopeManager, upperScope, block) {
		super(scopeManager, "class", upperScope, block, false);
	}
}

module.exports = {
	Scope,
	GlobalScope,
	ModuleScope,
	FunctionExpressionNameScope,
	CatchScope,
	WithScope,
	BlockScope,
	SwitchScope,
	FunctionScope,
	ForScope,
	ClassScope
};

},
// 134
function(module, exports, __webpack_require__) {

const Variable = __webpack_require__(50);

class Definition {
	constructor(type, name, node, parent, index, kind) {
		this.type = type;
		this.name = name;
		this.node = node;
		this.parent = parent;
		this.index = index;
		this.kind = kind;
	}
}

class ParameterDefinition extends Definition {
	constructor(name, node, index, rest) {
		super(Variable.Parameter, name, node, null, index, null);

		this.rest = rest;
	}
}

module.exports = { ParameterDefinition, Definition };

},
// 135
function(module, exports, __webpack_require__) {

var estraverse = __webpack_require__(49);

function isNode(node) {
	return node != null && typeof node == 'object' && typeof node.type == 'string';
}

function isProperty(nodeType, key) {
	return (
		nodeType === estraverse.Syntax.ObjectExpression ||
		nodeType === estraverse.Syntax.ObjectPattern
	) && key === 'properties';
}

function Visitor(visitor, options) {
	options = options || {};

	this.__visitor = visitor ||  this;
	this.__childVisitorKeys = options.childVisitorKeys
		? Object.assign({}, estraverse.VisitorKeys, options.childVisitorKeys)
		: estraverse.VisitorKeys;
	if (options.fallback === 'iteration') this.__fallback = Object.keys;
	else if (typeof options.fallback == 'function') this.__fallback = options.fallback;
}

Visitor.prototype.visitChildren = function(node) {
	var type, children, i, iz, j, jz, child;

	if (node == null) return;

	type = node.type || estraverse.Syntax.Property;

	if (!(children = this.__childVisitorKeys[type])) {
		if (!this.__fallback) throw new Error('Unknown node type ' + type + '.');

		children = this.__fallback(node);
	}

	for (i = 0, iz = children.length; i < iz; ++i)
		if ((child = node[children[i]]))
			if (Array.isArray(child))
				for (j = 0, jz = child.length; j < jz; ++j)
					child[j] &&
						(isNode(child[j]) || isProperty(type, children[i])) &&
						this.visit(child[j]);
			else isNode(child) && this.visit(child);
};

Visitor.prototype.visit = function(node) {
	var type;

	if (node == null) return;

	type = node.type || estraverse.Syntax.Property;
	this.__visitor[type]
		? this.__visitor[type].call(this, node)
		: this.visitChildren(node);
};

exports.version = __webpack_require__(297).version;
exports.Visitor = Visitor;
exports.visit = function(node, visitor, options) {
	new Visitor(visitor, options).visit(node);
};

},
// 136
function(module, exports, __webpack_require__) {

const crypto = __webpack_require__(76);
const SortableSet = __webpack_require__(20);
const GraphHelpers = __webpack_require__(22);
const { isSubset } = __webpack_require__(30);
const deterministicGrouping = __webpack_require__(300);
const MinMaxSizeWarning = __webpack_require__(301);
const contextify = __webpack_require__(13).contextify;

const deterministicGroupingForModules = (deterministicGrouping);

const hashFilename = name => {
	return crypto
		.createHash("md4")
		.update(name)
		.digest("hex")
		.slice(0, 8);
};

const sortByIdentifier = (a, b) => {
	if (a.identifier() > b.identifier()) return 1;
	if (a.identifier() < b.identifier()) return -1;
	return 0;
};

const getRequests = chunk => {
	let requests = 0;
	for (const chunkGroup of chunk.groupsIterable) {
		requests = Math.max(requests, chunkGroup.chunks.length);
	}
	return requests;
};

const getModulesSize = modules => {
	let sum = 0;
	for (const m of modules) {
		sum += m.size();
	}
	return sum;
};

const isOverlap = (a, b) => {
	for (const item of a) {
		if (b.has(item)) return true;
	}
	return false;
};

const compareEntries = (a, b) => {
	const diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;
	if (diffPriority) return diffPriority;
	const diffCount = a.chunks.size - b.chunks.size;
	if (diffCount) return diffCount;
	const aSizeReduce = a.size * (a.chunks.size - 1);
	const bSizeReduce = b.size * (b.chunks.size - 1);
	const diffSizeReduce = aSizeReduce - bSizeReduce;
	if (diffSizeReduce) return diffSizeReduce;
	const indexDiff = b.cacheGroupIndex - a.cacheGroupIndex;
	if (indexDiff) return indexDiff;
	const modulesA = a.modules;
	const modulesB = b.modules;
	const diff = modulesA.size - modulesB.size;
	if (diff) return diff;
	modulesA.sort();
	modulesB.sort();
	const aI = modulesA[Symbol.iterator]();
	const bI = modulesB[Symbol.iterator]();
	while (true) {
		const aItem = aI.next();
		const bItem = bI.next();
		if (aItem.done) return 0;
		const aModuleIdentifier = aItem.value.identifier();
		const bModuleIdentifier = bItem.value.identifier();
		if (aModuleIdentifier > bModuleIdentifier) return -1;
		if (aModuleIdentifier < bModuleIdentifier) return 1;
	}
};

const compareNumbers = (a, b) => a - b;

const INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial();
const ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial();
const ALL_CHUNK_FILTER = chunk => true;

module.exports = class {
	constructor(options) {
		this.options = SplitChunksPlugin.normalizeOptions(options);
	}

	static normalizeOptions(options = {}) {
		return {
			chunksFilter: SplitChunksPlugin.normalizeChunksFilter(
				options.chunks || "all"
			),
			minSize: options.minSize || 0,
			enforceSizeThreshold: options.enforceSizeThreshold || 0,
			maxSize: options.maxSize || 0,
			minChunks: options.minChunks || 1,
			maxAsyncRequests: options.maxAsyncRequests || 1,
			maxInitialRequests: options.maxInitialRequests || 1,
			hidePathInfo: options.hidePathInfo || false,
			filename: options.filename || void 0,
			getCacheGroups: SplitChunksPlugin.normalizeCacheGroups({
				cacheGroups: options.cacheGroups,
				name: options.name,
				automaticNameDelimiter: options.automaticNameDelimiter,
				automaticNameMaxLength: options.automaticNameMaxLength
			}),
			automaticNameDelimiter: options.automaticNameDelimiter,
			automaticNameMaxLength: options.automaticNameMaxLength || 109,
			fallbackCacheGroup: SplitChunksPlugin.normalizeFallbackCacheGroup(
				options.fallbackCacheGroup || {},
				options
			)
		};
	}

	static normalizeName({
		name,
		automaticNameDelimiter,
		automaticNamePrefix,
		automaticNameMaxLength
	}) {
		if (name === true) {
			const cache = new WeakMap();
			const fn = (module, chunks, cacheGroup) => {
				let cacheEntry = cache.get(chunks);
				if (cacheEntry === void 0) {
					cacheEntry = {};
					cache.set(chunks, cacheEntry);
				} else if (cacheGroup in cacheEntry) {
					return cacheEntry[cacheGroup];
				}
				const names = chunks.map(c => c.name);
				if (!names.every(Boolean)) {
					cacheEntry[cacheGroup] = void 0;
					return;
				}
				names.sort();
				const prefix =
					typeof automaticNamePrefix == "string"
						? automaticNamePrefix
						: cacheGroup;
				const namePrefix = prefix ? prefix + automaticNameDelimiter : "";
				let name = namePrefix + names.join(automaticNameDelimiter);
				if (name.length > automaticNameMaxLength) {
					const hashedFilename = hashFilename(name);
					const sliceLength =
						automaticNameMaxLength -
						(automaticNameDelimiter.length + hashedFilename.length);
					name =
						name.slice(0, sliceLength) +
						automaticNameDelimiter +
						hashedFilename;
				}
				cacheEntry[cacheGroup] = name;
				return name;
			};
			return fn;
		}
		if (typeof name == "string") {
			const fn = () => {
				return name;
			};
			return fn;
		}
		if (typeof name == "function") return name;
	}

	static normalizeChunksFilter(chunks) {
		if (chunks === "initial") {
			return INITIAL_CHUNK_FILTER;
		}
		if (chunks === "async") {
			return ASYNC_CHUNK_FILTER;
		}
		if (chunks === "all") {
			return ALL_CHUNK_FILTER;
		}
		if (typeof chunks == "function") return chunks;
	}

	static normalizeFallbackCacheGroup(
		{
			minSize = void 0,
			maxSize = void 0,
			automaticNameDelimiter = void 0
		},
		{
			minSize: defaultMinSize = void 0,
			maxSize: defaultMaxSize = void 0,
			automaticNameDelimiter: defaultAutomaticNameDelimiter = void 0
		}
	) {
		return {
			minSize: typeof minSize == "number" ? minSize : defaultMinSize || 0,
			maxSize: typeof maxSize == "number" ? maxSize : defaultMaxSize || 0,
			automaticNameDelimiter:
				automaticNameDelimiter || defaultAutomaticNameDelimiter || "~"
		};
	}

	static normalizeCacheGroups({
		cacheGroups,
		name,
		automaticNameDelimiter,
		automaticNameMaxLength
	}) {
		if (typeof cacheGroups == "function") {
			if (cacheGroups.length !== 1) {
				return module => cacheGroups(module, module.getChunks());
			}
			return cacheGroups;
		}
		if (cacheGroups && typeof cacheGroups == "object") {
			const fn = module => {
				let results;
				for (const key of Object.keys(cacheGroups)) {
					let option = cacheGroups[key];
					if (option === false) continue;
					if (option instanceof RegExp || typeof option == "string") {
						option = {
							test: option
						};
					}
					if (typeof option == "function") {
						let result = option(module);
						if (result) {
							if (results === void 0) results = [];
							for (const r of Array.isArray(result) ? result : [result]) {
								const result = Object.assign({ key }, r);
								if (result.name) result.getName = () => result.name;
								if (result.chunks) {
									result.chunksFilter = SplitChunksPlugin.normalizeChunksFilter(
										result.chunks
									);
								}
								results.push(result);
							}
						}
					} else if (SplitChunksPlugin.checkTest(option.test, module)) {
						if (results === void 0) results = [];
						results.push({
							key: key,
							priority: option.priority,
							getName:
								SplitChunksPlugin.normalizeName({
									name: option.name || name,
									automaticNameDelimiter:
										typeof option.automaticNameDelimiter == "string"
											? option.automaticNameDelimiter
											: automaticNameDelimiter,
									automaticNamePrefix: option.automaticNamePrefix,
									automaticNameMaxLength:
										option.automaticNameMaxLength || automaticNameMaxLength
								}) || (() => {}),
							chunksFilter: SplitChunksPlugin.normalizeChunksFilter(
								option.chunks
							),
							enforce: option.enforce,
							minSize: option.minSize,
							enforceSizeThreshold: option.enforceSizeThreshold,
							maxSize: option.maxSize,
							minChunks: option.minChunks,
							maxAsyncRequests: option.maxAsyncRequests,
							maxInitialRequests: option.maxInitialRequests,
							filename: option.filename,
							reuseExistingChunk: option.reuseExistingChunk
						});
					}
				}
				return results;
			};
			return fn;
		}
		const fn = () => {};
		return fn;
	}

	static checkTest(test, module) {
		if (test === void 0) return true;
		if (typeof test == "function") {
			if (test.length !== 1) {
				return test(module, module.getChunks());
			}
			return test(module);
		}
		if (typeof test == "boolean") return test;
		if (typeof test == "string") {
			if (
				module.nameForCondition &&
				module.nameForCondition().startsWith(test)
			) {
				return true;
			}
			for (const chunk of module.chunksIterable) {
				if (chunk.name && chunk.name.startsWith(test)) {
					return true;
				}
			}
			return false;
		}
		if (test instanceof RegExp) {
			if (module.nameForCondition && test.test(module.nameForCondition())) {
				return true;
			}
			for (const chunk of module.chunksIterable) {
				if (chunk.name && test.test(chunk.name)) {
					return true;
				}
			}
			return false;
		}
		return false;
	}

	apply(compiler) {
		compiler.hooks.thisCompilation.tap("SplitChunksPlugin", compilation => {
			let alreadyOptimized = false;
			compilation.hooks.unseal.tap("SplitChunksPlugin", () => {
				alreadyOptimized = false;
			});
			compilation.hooks.optimizeChunksAdvanced.tap(
				"SplitChunksPlugin",
				chunks => {
					if (alreadyOptimized) return;
					alreadyOptimized = true;
					const indexMap = new Map();
					let index = 1;
					for (const chunk of chunks) {
						indexMap.set(chunk, index++);
					}
					const getKey = chunks => {
						return Array.from(chunks, c => indexMap.get(c))
							.sort(compareNumbers)
							.join();
					};
					const chunkSetsInGraph = new Map();
					for (const module of compilation.modules) {
						const chunksKey = getKey(module.chunksIterable);
						if (!chunkSetsInGraph.has(chunksKey)) {
							chunkSetsInGraph.set(chunksKey, new Set(module.chunksIterable));
						}
					}

					const chunkSetsByCount = new Map();
					for (const chunksSet of chunkSetsInGraph.values()) {
						const count = chunksSet.size;
						let array = chunkSetsByCount.get(count);
						if (array === void 0) {
							array = [];
							chunkSetsByCount.set(count, array);
						}
						array.push(chunksSet);
					}

					const combinationsCache = new Map();

					const getCombinations = key => {
						const chunksSet = chunkSetsInGraph.get(key);
						var array = [chunksSet];
						if (chunksSet.size > 1) {
							for (const [count, setArray] of chunkSetsByCount) {
								if (count < chunksSet.size) {
									for (const set of setArray) {
										if (isSubset(chunksSet, set)) {
											array.push(set);
										}
									}
								}
							}
						}
						return array;
					};

					const selectedChunksCacheByChunksSet = new WeakMap();

					const getSelectedChunks = (chunks, chunkFilter) => {
						let entry = selectedChunksCacheByChunksSet.get(chunks);
						if (entry === void 0) {
							entry = new WeakMap();
							selectedChunksCacheByChunksSet.set(chunks, entry);
						}
						let entry2 = entry.get(chunkFilter);
						if (entry2 === void 0) {
							const selectedChunks = [];
							for (const chunk of chunks) {
								if (chunkFilter(chunk)) selectedChunks.push(chunk);
							}
							entry2 = {
								chunks: selectedChunks,
								key: getKey(selectedChunks)
							};
							entry.set(chunkFilter, entry2);
						}
						return entry2;
					};

					const chunksInfoMap = new Map();

					const addModuleToChunksInfoMap = (
						cacheGroup,
						cacheGroupIndex,
						selectedChunks,
						selectedChunksKey,
						module
					) => {
						if (selectedChunks.length < cacheGroup.minChunks) return;
						const name = cacheGroup.getName(
							module,
							selectedChunks,
							cacheGroup.key
						);
						const key =
							cacheGroup.key +
							(name ? ` name:${name}` : ` chunks:${selectedChunksKey}`);
						let info = chunksInfoMap.get(key);
						if (info === void 0) {
							chunksInfoMap.set(
								key,
								(info = {
									modules: new SortableSet(void 0, sortByIdentifier),
									cacheGroup,
									cacheGroupIndex,
									name,
									size: 0,
									chunks: new Set(),
									reuseableChunks: new Set(),
									chunksKeys: new Set()
								})
							);
						}
						const oldSize = info.modules.size;
						info.modules.add(module);
						if (info.modules.size !== oldSize) {
							info.size += module.size();
						}
						const oldChunksKeysSize = info.chunksKeys.size;
						info.chunksKeys.add(selectedChunksKey);
						if (oldChunksKeysSize !== info.chunksKeys.size) {
							for (const chunk of selectedChunks) {
								info.chunks.add(chunk);
							}
						}
					};

					for (const module of compilation.modules) {
						let cacheGroups = this.options.getCacheGroups(module);
						if (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {
							continue;
						}

						const chunksKey = getKey(module.chunksIterable);
						let combs = combinationsCache.get(chunksKey);
						if (combs === void 0) {
							combs = getCombinations(chunksKey);
							combinationsCache.set(chunksKey, combs);
						}

						let cacheGroupIndex = 0;
						for (const cacheGroupSource of cacheGroups) {
							const minSize =
								cacheGroupSource.minSize !== void 0
									? cacheGroupSource.minSize
									: cacheGroupSource.enforce
									? 0
									: this.options.minSize;
							const enforceSizeThreshold =
								cacheGroupSource.enforceSizeThreshold !== void 0
									? cacheGroupSource.enforceSizeThreshold
									: cacheGroupSource.enforce
									? 0
									: this.options.enforceSizeThreshold;
							const cacheGroup = {
								key: cacheGroupSource.key,
								priority: cacheGroupSource.priority || 0,
								chunksFilter:
									cacheGroupSource.chunksFilter || this.options.chunksFilter,
								minSize,
								minSizeForMaxSize:
									cacheGroupSource.minSize !== void 0
										? cacheGroupSource.minSize
										: this.options.minSize,
								enforceSizeThreshold,
								maxSize:
									cacheGroupSource.maxSize !== void 0
										? cacheGroupSource.maxSize
										: cacheGroupSource.enforce
										? 0
										: this.options.maxSize,
								minChunks:
									cacheGroupSource.minChunks !== void 0
										? cacheGroupSource.minChunks
										: cacheGroupSource.enforce
										? 1
										: this.options.minChunks,
								maxAsyncRequests:
									cacheGroupSource.maxAsyncRequests !== void 0
										? cacheGroupSource.maxAsyncRequests
										: cacheGroupSource.enforce
										? Infinity
										: this.options.maxAsyncRequests,
								maxInitialRequests:
									cacheGroupSource.maxInitialRequests !== void 0
										? cacheGroupSource.maxInitialRequests
										: cacheGroupSource.enforce
										? Infinity
										: this.options.maxInitialRequests,
								getName:
									cacheGroupSource.getName !== void 0
										? cacheGroupSource.getName
										: this.options.getName,
								filename:
									cacheGroupSource.filename !== void 0
										? cacheGroupSource.filename
										: this.options.filename,
								automaticNameDelimiter:
									cacheGroupSource.automaticNameDelimiter !== void 0
										? cacheGroupSource.automaticNameDelimiter
										: this.options.automaticNameDelimiter,
								reuseExistingChunk: cacheGroupSource.reuseExistingChunk,
								_validateSize: minSize > 0,
								_conditionalEnforce: enforceSizeThreshold > 0
							};
							for (const chunkCombination of combs) {
								if (chunkCombination.size < cacheGroup.minChunks) continue;
								const {
									chunks: selectedChunks,
									key: selectedChunksKey
								} = getSelectedChunks(
									chunkCombination,
									cacheGroup.chunksFilter
								);

								addModuleToChunksInfoMap(
									cacheGroup,
									cacheGroupIndex,
									selectedChunks,
									selectedChunksKey,
									module
								);
							}
							cacheGroupIndex++;
						}
					}

					for (const pair of chunksInfoMap) {
						const info = pair[1];
						if (
							info.cacheGroup._validateSize &&
							info.size < info.cacheGroup.minSize
						) {
							chunksInfoMap.delete(pair[0]);
						}
					}

					const maxSizeQueueMap = new Map();

					while (chunksInfoMap.size > 0) {
						let bestEntryKey;
						let bestEntry;
						for (const pair of chunksInfoMap) {
							const key = pair[0];
							const info = pair[1];
							if (bestEntry === void 0) {
								bestEntry = info;
								bestEntryKey = key;
							} else if (compareEntries(bestEntry, info) < 0) {
								bestEntry = info;
								bestEntryKey = key;
							}
						}

						const item = bestEntry;
						chunksInfoMap.delete(bestEntryKey);

						let chunkName = item.name;
						let newChunk;
						let isReused = false;
						if (item.cacheGroup.reuseExistingChunk) {
							outer: for (const chunk of item.chunks) {
								if (chunk.getNumberOfModules() !== item.modules.size) continue;
								if (chunk.hasEntryModule()) continue;
								for (const module of item.modules) {
									if (!chunk.containsModule(module)) continue outer;
								}
								if (!newChunk || !newChunk.name) {
									newChunk = chunk;
								} else if (
									chunk.name &&
									chunk.name.length < newChunk.name.length
								) {
									newChunk = chunk;
								} else if (
									chunk.name &&
									chunk.name.length === newChunk.name.length &&
									chunk.name < newChunk.name
								) {
									newChunk = chunk;
								}
								chunkName = void 0;
								isReused = true;
							}
						}

						const selectedChunks = Array.from(item.chunks).filter(chunk => {
							return (
								(!chunkName || chunk.name !== chunkName) && chunk !== newChunk
							);
						});

						const enforced =
							item.cacheGroup._conditionalEnforce &&
							item.size >= item.cacheGroup.enforceSizeThreshold;

						if (selectedChunks.length === 0) continue;

						const usedChunks = new Set(selectedChunks);

						if (
							!enforced &&
							(Number.isFinite(item.cacheGroup.maxInitialRequests) ||
								Number.isFinite(item.cacheGroup.maxAsyncRequests))
						) {
							for (const chunk of usedChunks) {
								const maxRequests = chunk.isOnlyInitial()
									? item.cacheGroup.maxInitialRequests
									: chunk.canBeInitial()
									? Math.min(
											item.cacheGroup.maxInitialRequests,
											item.cacheGroup.maxAsyncRequests
										)
									: item.cacheGroup.maxAsyncRequests;
								if (
									isFinite(maxRequests) &&
									getRequests(chunk) >= maxRequests
								) {
									usedChunks.delete(chunk);
								}
							}
						}

						outer: for (const chunk of usedChunks) {
							for (const module of item.modules) {
								if (chunk.containsModule(module)) continue outer;
							}
							usedChunks.delete(chunk);
						}

						if (usedChunks.size < selectedChunks.length) {
							if (usedChunks.size >= item.cacheGroup.minChunks) {
								const chunksArr = Array.from(usedChunks);
								for (const module of item.modules) {
									addModuleToChunksInfoMap(
										item.cacheGroup,
										item.cacheGroupIndex,
										chunksArr,
										getKey(usedChunks),
										module
									);
								}
							}
							continue;
						}

						if (!isReused) {
							newChunk = compilation.addChunk(chunkName);
						}
						for (const chunk of usedChunks) {
							chunk.split(newChunk);
						}

						newChunk.chunkReason = isReused
							? "reused as split chunk"
							: "split chunk";
						if (item.cacheGroup.key) {
							newChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;
						}
						if (chunkName) {
							newChunk.chunkReason += ` (name: ${chunkName})`;
							const entrypoint = compilation.entrypoints.get(chunkName);
							if (entrypoint) {
								compilation.entrypoints.delete(chunkName);
								entrypoint.remove();
								newChunk.entryModule = void 0;
							}
						}
						if (item.cacheGroup.filename) {
							if (!newChunk.isOnlyInitial())
								throw new Error(
									`SplitChunksPlugin: You are trying to set a filename for a chunk which is (also) loaded on demand. The runtime can only handle loading of chunks which match the chunkFilename schema. Using a custom filename would fail at runtime. (cache group: ${item.cacheGroup.key})`
								);

							newChunk.filenameTemplate = item.cacheGroup.filename;
						}
						if (!isReused) {
							for (const module of item.modules) {
								if (typeof module.chunkCondition == "function") {
									if (!module.chunkCondition(newChunk)) continue;
								}
								GraphHelpers.connectChunkAndModule(newChunk, module);
								for (const chunk of usedChunks) {
									chunk.removeModule(module);
									module.rewriteChunkInReasons(chunk, [newChunk]);
								}
							}
						} else {
							for (const module of item.modules) {
								for (const chunk of usedChunks) {
									chunk.removeModule(module);
									module.rewriteChunkInReasons(chunk, [newChunk]);
								}
							}
						}

						if (item.cacheGroup.maxSize > 0) {
							const oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);
							maxSizeQueueMap.set(newChunk, {
								minSize: Math.max(
									oldMaxSizeSettings ? oldMaxSizeSettings.minSize : 0,
									item.cacheGroup.minSizeForMaxSize
								),
								maxSize: Math.min(
									oldMaxSizeSettings ? oldMaxSizeSettings.maxSize : Infinity,
									item.cacheGroup.maxSize
								),
								automaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,
								keys: oldMaxSizeSettings
									? oldMaxSizeSettings.keys.concat(item.cacheGroup.key)
									: [item.cacheGroup.key]
							});
						}

						for (const [key, info] of chunksInfoMap) {
							if (isOverlap(info.chunks, usedChunks)) {
								const oldSize = info.modules.size;
								for (const module of item.modules) {
									info.modules.delete(module);
								}
								if (info.modules.size !== oldSize) {
									if (info.modules.size === 0) {
										chunksInfoMap.delete(key);
										continue;
									}
									info.size = getModulesSize(info.modules);
									if (
										info.cacheGroup._validateSize &&
										info.size < info.cacheGroup.minSize
									) {
										chunksInfoMap.delete(key);
									}
									if (info.modules.size === 0) {
										chunksInfoMap.delete(key);
									}
								}
							}
						}
					}

					const incorrectMinMaxSizeSet = new Set();

					for (const chunk of compilation.chunks.slice()) {
						const { minSize, maxSize, automaticNameDelimiter, keys } =
							maxSizeQueueMap.get(chunk) || this.options.fallbackCacheGroup;
						if (!maxSize) continue;
						if (minSize > maxSize) {
							const warningKey = `${keys && keys.join()} ${minSize} ${maxSize}`;
							if (!incorrectMinMaxSizeSet.has(warningKey)) {
								incorrectMinMaxSizeSet.add(warningKey);
								compilation.warnings.push(
									new MinMaxSizeWarning(keys, minSize, maxSize)
								);
							}
						}
						const results = deterministicGroupingForModules({
							maxSize: Math.max(minSize, maxSize),
							minSize,
							items: chunk.modulesIterable,
							getKey(module) {
								const ident = contextify(
									compilation.options.context,
									module.identifier()
								);
								const name = module.nameForCondition
									? contextify(
											compilation.options.context,
											module.nameForCondition()
										)
									: ident.replace(/^.*!|\?[^?!]*$/g, "");
								const fullKey =
									name + automaticNameDelimiter + hashFilename(ident);
								return fullKey.replace(/[\\/?]/g, "_");
							},
							getSize(module) {
								return module.size();
							}
						});
						results.sort((a, b) => {
							if (a.key < b.key) return -1;
							if (a.key > b.key) return 1;
							return 0;
						});
						for (let i = 0; i < results.length; i++) {
							const group = results[i];
							const key = this.options.hidePathInfo
								? hashFilename(group.key)
								: group.key;
							let name = chunk.name
								? chunk.name + automaticNameDelimiter + key
								: null;
							if (name && name.length > 100) {
								name =
									name.slice(0, 100) +
									automaticNameDelimiter +
									hashFilename(name);
							}
							let newPart;
							if (i !== results.length - 1) {
								newPart = compilation.addChunk(name);
								chunk.split(newPart);
								newPart.chunkReason = chunk.chunkReason;
								for (const module of group.items) {
									if (typeof module.chunkCondition == "function") {
										if (!module.chunkCondition(newPart)) continue;
									}
									GraphHelpers.connectChunkAndModule(newPart, module);
									chunk.removeModule(module);
									module.rewriteChunkInReasons(chunk, [newPart]);
								}
							} else {
								newPart = chunk;
								chunk.name = name;
							}
						}
					}
				}
			);
		});
	}
};

},
// 137
function(module, exports, __webpack_require__) {

module.exports = class {
	constructor(options) {
		this.options = Object.assign(
			{
				name: entrypoint => `runtime~${entrypoint.name}`
			},
			options
		);
	}

	apply(compiler) {
		compiler.hooks.thisCompilation.tap("RuntimeChunkPlugin", compilation => {
			compilation.hooks.optimizeChunksAdvanced.tap("RuntimeChunkPlugin", () => {
				for (const entrypoint of compilation.entrypoints.values()) {
					const chunk = entrypoint.getRuntimeChunk();
					let name = this.options.name;
					if (typeof name == "function") {
						name = name(entrypoint);
					}
					if (
						chunk.getNumberOfModules() > 0 ||
						!chunk.preventIntegration ||
						chunk.name !== name
					) {
						const newChunk = compilation.addChunk(name);
						newChunk.preventIntegration = true;
						entrypoint.unshiftChunk(newChunk);
						newChunk.addGroup(entrypoint);
						entrypoint.setRuntimeChunk(newChunk);
					}
				}
			});
		});
	}
};

},
// 138
function(module, exports, __webpack_require__) {

class NoEmitOnErrorsPlugin {
	apply(compiler) {
		compiler.hooks.shouldEmit.tap("NoEmitOnErrorsPlugin", compilation => {
			if (compilation.getStats().hasErrors()) return false;
		});
		compiler.hooks.compilation.tap("NoEmitOnErrorsPlugin", compilation => {
			compilation.hooks.shouldRecord.tap("NoEmitOnErrorsPlugin", () => {
				if (compilation.getStats().hasErrors()) return false;
			});
		});
	}
}

module.exports = NoEmitOnErrorsPlugin;

},
// 139
function(module, exports, __webpack_require__) {

const createHash = __webpack_require__(15);
const RequestShortener = __webpack_require__(52);

const getHash = str => {
	const hash = createHash("md4");
	hash.update(str);
	const digest = (hash.digest("hex"));
	return digest.substr(0, 4);
};

class NamedModulesPlugin {
	constructor(options) {
		this.options = options || {};
	}

	apply(compiler) {
		compiler.hooks.compilation.tap("NamedModulesPlugin", compilation => {
			compilation.hooks.beforeModuleIds.tap("NamedModulesPlugin", modules => {
				const namedModules = new Map();
				const context = this.options.context || compiler.options.context;

				for (const module of modules) {
					if (module.id === null && module.libIdent) {
						module.id = module.libIdent({ context });
					}

					if (module.id !== null) {
						const namedModule = namedModules.get(module.id);
						if (namedModule !== void 0) {
							namedModule.push(module);
						} else {
							namedModules.set(module.id, [module]);
						}
					}
				}

				for (const namedModule of namedModules.values()) {
					if (namedModule.length > 1) {
						for (const module of namedModule) {
							const requestShortener = new RequestShortener(context);
							module.id = `${module.id}?${getHash(
								requestShortener.shorten(module.identifier())
							)}`;
						}
					}
				}
			});
		});
	}
}

module.exports = NamedModulesPlugin;

},
// 140
function(module, exports, __webpack_require__) {

const createHash = __webpack_require__(15);

const validateOptions = __webpack_require__(8);
const schema = __webpack_require__(303);

class HashedModuleIdsPlugin {
	constructor(options) {
		if (!options) options = {};

		validateOptions(schema, options, "Hashed Module Ids Plugin");

		this.options = Object.assign(
			{
				context: null,
				hashFunction: "md4",
				hashDigest: "base64",
				hashDigestLength: 4
			},
			options
		);
	}

	apply(compiler) {
		const options = this.options;
		compiler.hooks.compilation.tap("HashedModuleIdsPlugin", compilation => {
			const usedIds = new Set();
			compilation.hooks.beforeModuleIds.tap(
				"HashedModuleIdsPlugin",
				modules => {
					for (const module of modules) {
						if (module.id === null && module.libIdent) {
							const id = module.libIdent({
								context: this.options.context || compiler.options.context
							});
							const hash = createHash(options.hashFunction);
							hash.update(id);
							const hashId = (hash.digest(
								options.hashDigest
							));
							let len = options.hashDigestLength;
							while (usedIds.has(hashId.substr(0, len))) len++;
							module.id = hashId.substr(0, len);
							usedIds.add(module.id);
						}
					}
				}
			);
		});
	}
}

module.exports = HashedModuleIdsPlugin;

},
// 141
function(module, exports, __webpack_require__) {

const validateOptions = __webpack_require__(8);
const schema = __webpack_require__(304);

class OccurrenceOrderModuleIdsPlugin {
	constructor(options = {}) {
		validateOptions(schema, options, "Occurrence Order Module Ids Plugin");
		this.options = options;
	}

	apply(compiler) {
		const prioritiseInitial = this.options.prioritiseInitial;
		compiler.hooks.compilation.tap(
			"OccurrenceOrderModuleIdsPlugin",
			compilation => {
				compilation.hooks.optimizeModuleOrder.tap(
					"OccurrenceOrderModuleIdsPlugin",
					modules => {
						const occursInInitialChunksMap = new Map();
						const occursInAllChunksMap = new Map();

						const initialChunkChunkMap = new Map();
						const entryCountMap = new Map();
						for (const m of modules) {
							let initial = 0;
							let entry = 0;
							for (const c of m.chunksIterable) {
								if (c.canBeInitial()) initial++;
								if (c.entryModule === m) entry++;
							}
							initialChunkChunkMap.set(m, initial);
							entryCountMap.set(m, entry);
						}

						const countOccursInEntry = (sum, r) => {
							if (!r.module) {
								return sum;
							}
							const count = initialChunkChunkMap.get(r.module);
							if (!count) {
								return sum;
							}
							return sum + count;
						};
						const countOccurs = (sum, r) => {
							if (!r.module) {
								return sum;
							}
							let factor = 1;
							if (typeof r.dependency.getNumberOfIdOccurrences == "function") {
								factor = r.dependency.getNumberOfIdOccurrences();
							}
							if (factor === 0) {
								return sum;
							}
							return sum + factor * r.module.getNumberOfChunks();
						};

						if (prioritiseInitial) {
							for (const m of modules) {
								const result =
									m.reasons.reduce(countOccursInEntry, 0) +
									initialChunkChunkMap.get(m) +
									entryCountMap.get(m);
								occursInInitialChunksMap.set(m, result);
							}
						}

						const originalOrder = new Map();
						let i = 0;
						for (const m of modules) {
							const result =
								m.reasons.reduce(countOccurs, 0) +
								m.getNumberOfChunks() +
								entryCountMap.get(m);
							occursInAllChunksMap.set(m, result);
							originalOrder.set(m, i++);
						}

						modules.sort((a, b) => {
							if (prioritiseInitial) {
								const aEntryOccurs = occursInInitialChunksMap.get(a);
								const bEntryOccurs = occursInInitialChunksMap.get(b);
								if (aEntryOccurs > bEntryOccurs) return -1;
								if (aEntryOccurs < bEntryOccurs) return 1;
							}
							const aOccurs = occursInAllChunksMap.get(a);
							const bOccurs = occursInAllChunksMap.get(b);
							if (aOccurs > bOccurs) return -1;
							if (aOccurs < bOccurs) return 1;
							const orgA = originalOrder.get(a);
							const orgB = originalOrder.get(b);
							return orgA - orgB;
						});
					}
				);
			}
		);
	}
}

module.exports = OccurrenceOrderModuleIdsPlugin;

},
// 142
function(module, exports, __webpack_require__) {

class NamedChunksPlugin {
	static defaultNameResolver(chunk) {
		return chunk.name || null;
	}

	constructor(nameResolver) {
		this.nameResolver = nameResolver || NamedChunksPlugin.defaultNameResolver;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap("NamedChunksPlugin", compilation => {
			compilation.hooks.beforeChunkIds.tap("NamedChunksPlugin", chunks => {
				for (const chunk of chunks) {
					if (chunk.id === null) {
						chunk.id = this.nameResolver(chunk);
					}
				}
			});
		});
	}
}

module.exports = NamedChunksPlugin;

},
// 143
function(module, exports, __webpack_require__) {

const validateOptions = __webpack_require__(8);
const schema = __webpack_require__(306);

class OccurrenceOrderChunkIdsPlugin {
	constructor(options = {}) {
		validateOptions(schema, options, "Occurrence Order Chunk Ids Plugin");
		this.options = options;
	}

	apply(compiler) {
		const prioritiseInitial = this.options.prioritiseInitial;
		compiler.hooks.compilation.tap(
			"OccurrenceOrderChunkIdsPlugin",
			compilation => {
				compilation.hooks.optimizeChunkOrder.tap(
					"OccurrenceOrderChunkIdsPlugin",
					chunks => {
						const occursInInitialChunksMap = new Map();
						const originalOrder = new Map();

						let i = 0;
						for (const c of chunks) {
							let occurs = 0;
							for (const chunkGroup of c.groupsIterable) {
								for (const parent of chunkGroup.parentsIterable) {
									if (parent.isInitial()) occurs++;
								}
							}
							occursInInitialChunksMap.set(c, occurs);
							originalOrder.set(c, i++);
						}

						chunks.sort((a, b) => {
							if (prioritiseInitial) {
								const aEntryOccurs = occursInInitialChunksMap.get(a);
								const bEntryOccurs = occursInInitialChunksMap.get(b);
								if (aEntryOccurs > bEntryOccurs) return -1;
								if (aEntryOccurs < bEntryOccurs) return 1;
							}
							const aOccurs = a.getNumberOfGroups();
							const bOccurs = b.getNumberOfGroups();
							if (aOccurs > bOccurs) return -1;
							if (aOccurs < bOccurs) return 1;
							const orgA = originalOrder.get(a);
							const orgB = originalOrder.get(b);
							return orgA - orgB;
						});
					}
				);
			}
		);
	}
}

module.exports = OccurrenceOrderChunkIdsPlugin;

},
// 144
function(module, exports, __webpack_require__) {

const asyncLib = __webpack_require__(12);

class CachePlugin {
	constructor(cache) {
		this.cache = cache || {};
		this.FS_ACCURACY = 2000;
	}

	apply(compiler) {
		if (Array.isArray(compiler.compilers)) {
			compiler.compilers.forEach((c, idx) => {
				new CachePlugin((this.cache[idx] = this.cache[idx] || {})).apply(c);
			});
		} else {
			const registerCacheToCompiler = (compiler, cache) => {
				compiler.hooks.thisCompilation.tap("CachePlugin", compilation => {
					compilation.cache = cache;
					compilation.hooks.childCompiler.tap(
						"CachePlugin",
						(childCompiler, compilerName, compilerIndex) => {
							let childCache;
							if (!cache.children) {
								cache.children = {};
							}
							if (!cache.children[compilerName]) {
								cache.children[compilerName] = [];
							}
							if (cache.children[compilerName][compilerIndex]) {
								childCache = cache.children[compilerName][compilerIndex];
							} else {
								cache.children[compilerName].push((childCache = {}));
							}
							registerCacheToCompiler(childCompiler, childCache);
						}
					);
				});
			};
			registerCacheToCompiler(compiler, this.cache);
			compiler.hooks.watchRun.tap("CachePlugin", () => {
				this.watching = true;
			});
			compiler.hooks.run.tapAsync("CachePlugin", (compiler, callback) => {
				if (!compiler._lastCompilationFileDependencies) {
					return callback();
				}
				const fs = compiler.inputFileSystem;
				const fileTs = (compiler.fileTimestamps = new Map());
				asyncLib.forEach(
					compiler._lastCompilationFileDependencies,
					(file, callback) => {
						fs.stat(file, (err, stat) => {
							if (err) {
								if (err.code === "ENOENT") return callback();
								return callback(err);
							}

							if (stat.mtime) this.applyMtime(+stat.mtime);

							fileTs.set(file, +stat.mtime || Infinity);

							callback();
						});
					},
					err => {
						if (err) return callback(err);

						for (const [file, ts] of fileTs) {
							fileTs.set(file, ts + this.FS_ACCURACY);
						}

						callback();
					}
				);
			});
			compiler.hooks.afterCompile.tap("CachePlugin", compilation => {
				compilation.compiler._lastCompilationFileDependencies =
					compilation.fileDependencies;
				compilation.compiler._lastCompilationContextDependencies =
					compilation.contextDependencies;
			});
		}
	}

	applyMtime(mtime) {
		if (this.FS_ACCURACY > 1 && mtime % 2 !== 0) this.FS_ACCURACY = 1;
		else if (this.FS_ACCURACY > 10 && mtime % 20 !== 0) this.FS_ACCURACY = 10;
		else if (this.FS_ACCURACY > 100 && mtime % 200 !== 0)
			this.FS_ACCURACY = 100;
		else if (this.FS_ACCURACY > 1000 && mtime % 2000 !== 0)
			this.FS_ACCURACY = 1000;
	}
}
module.exports = CachePlugin;

},
// 145
function(module) {

module.exports = require("./terser-plugin");

},
// 146
function(module) {

module.exports = require("../schemas/WebpackOptions.json");

},
// 147
function(module, exports, __webpack_require__) {

const ModuleDependency = __webpack_require__(4);

class PrefetchDependency extends ModuleDependency {
	constructor(request) {
		super(request);
	}

	get type() {
		return "prefetch";
	}
}

module.exports = PrefetchDependency;

},
// 148
function(module, exports, __webpack_require__) {

const ModuleDependency = __webpack_require__(4);

class DelegatedSourceDependency extends ModuleDependency {
	constructor(request) {
		super(request);
	}

	get type() {
		return "delegated source";
	}
}

module.exports = DelegatedSourceDependency;

},
// 149
function(module, exports, __webpack_require__) {

const DependencyReference = __webpack_require__(14);
const NullDependency = __webpack_require__(7);

class DelegatedExportsDependency extends NullDependency {
	constructor(originModule, exports) {
		super();
		this.originModule = originModule;
		this.exports = exports;
	}

	get type() {
		return "delegated exports";
	}

	getReference() {
		return new DependencyReference(this.originModule, true, false);
	}

	getExports() {
		return {
			exports: this.exports,
			dependencies: void 0
		};
	}
}

module.exports = DelegatedExportsDependency;

},
// 150
function(module) {

module.exports = function(path) {
	var parts = path.split(/(\\+|\/+)/);
	if (parts.length === 1) return path;
	var result = [];
	for (var absolutePathStart = 0, i = 0, sep = false; i < parts.length; i += 1, sep = !sep) {
		var part = parts[i];
		if (i === 0 && /^([A-Z]:)?$/i.test(part)) {
			result.push(part);
			absolutePathStart = 2;
		} else if (sep)
			i === 1 && parts[0].length === 0 && part === "\\\\"
				? result.push(part)
				: result.push(part[0]);
		else if (part === "..")
			switch (result.length) {
				case 0:
					result.push(part);
					break;
				case 2:
					if (result[0] !== ".") {
						i += 1;
						sep = !sep;
						result.length = absolutePathStart;
					} else {
						result.length = 0;
						result.push(part);
					}
					break;
				case 4:
					if (absolutePathStart === 0) result.length -= 3;
					else {
						i += 1;
						sep = !sep;
						result.length = 2;
					}
					break;
				default:
					result.length -= 3;
					break;
			}
		else if (part === ".")
			switch (result.length) {
				case 0:
					result.push(part);
					break;
				case 2:
					if (absolutePathStart === 0) result.length -= 1;
					else {
						i += 1;
						sep = !sep;
					}
					break;
				default:
					result.length -= 1;
					break;
			}
		else part && result.push(part);
	}
	return result.length === 1 && /^[A-Za-z]:$/.test(result[0])
		? result[0] + "\\"
		: result.join("");
};

},
// 151
function(module, exports, __webpack_require__) {

const Compiler = __webpack_require__(152);
const MultiCompiler = __webpack_require__(185);
const NodeEnvironmentPlugin = __webpack_require__(188);
const WebpackOptionsApply = __webpack_require__(199);
const WebpackOptionsDefaulter = __webpack_require__(311);
const validateSchema = __webpack_require__(313);
const WebpackOptionsValidationError = __webpack_require__(317);
const webpackOptionsSchema = __webpack_require__(146);
const RemovedPluginError = __webpack_require__(318);
const version = __webpack_require__(53).version;

const webpack = (options, callback) => {
	const webpackOptionsValidationErrors = validateSchema(
		webpackOptionsSchema,
		options
	);
	if (webpackOptionsValidationErrors.length) {
		throw new WebpackOptionsValidationError(webpackOptionsValidationErrors);
	}
	let compiler;
	if (Array.isArray(options)) {
		compiler = new MultiCompiler(
			Array.from(options).map(options => webpack(options))
		);
	} else if (typeof options == "object") {
		options = new WebpackOptionsDefaulter().process(options);

		compiler = new Compiler(options.context);
		compiler.options = options;
		new NodeEnvironmentPlugin({
			infrastructureLogging: options.infrastructureLogging
		}).apply(compiler);
		if (options.plugins && Array.isArray(options.plugins)) {
			for (const plugin of options.plugins) {
				if (typeof plugin == "function") {
					plugin.call(compiler, compiler);
				} else {
					plugin.apply(compiler);
				}
			}
		}
		compiler.hooks.environment.call();
		compiler.hooks.afterEnvironment.call();
		compiler.options = new WebpackOptionsApply().process(options, compiler);
	} else {
		throw new Error("Invalid argument: options");
	}
	if (callback) {
		if (typeof callback != "function") {
			throw new Error("Invalid argument: callback");
		}
		if (
			options.watch === true ||
			(Array.isArray(options) && options.some(o => o.watch))
		) {
			const watchOptions = Array.isArray(options)
				? options.map(o => o.watchOptions || {})
				: options.watchOptions || {};
			return compiler.watch(watchOptions, callback);
		}
		compiler.run(callback);
	}
	return compiler;
};

exports = module.exports = webpack;
exports.version = version;

webpack.WebpackOptionsDefaulter = WebpackOptionsDefaulter;
webpack.WebpackOptionsApply = WebpackOptionsApply;
webpack.Compiler = Compiler;
webpack.MultiCompiler = MultiCompiler;
webpack.NodeEnvironmentPlugin = NodeEnvironmentPlugin;
webpack.validate = validateSchema.bind(this, webpackOptionsSchema);
webpack.validateSchema = validateSchema;
webpack.WebpackOptionsValidationError = WebpackOptionsValidationError;

const exportPlugins = (obj, mappings) => {
	for (const name of Object.keys(mappings)) {
		Object.defineProperty(obj, name, {
			configurable: false,
			enumerable: true,
			get: mappings[name]
		});
	}
};

exportPlugins(exports, {
	AutomaticPrefetchPlugin: () => __webpack_require__(319),
	BannerPlugin: () => __webpack_require__(320),
	CachePlugin: () => __webpack_require__(144),
	ContextExclusionPlugin: () => __webpack_require__(322),
	ContextReplacementPlugin: () => __webpack_require__(323),
	DefinePlugin: () => __webpack_require__(71),
	Dependency: () => __webpack_require__(17),
	DllPlugin: () => __webpack_require__(324),
	DllReferencePlugin: () => __webpack_require__(332),
	EnvironmentPlugin: () => __webpack_require__(336),
	EvalDevToolModulePlugin: () => __webpack_require__(90),
	EvalSourceMapDevToolPlugin: () => __webpack_require__(92),
	ExtendedAPIPlugin: () => __webpack_require__(338),
	ExternalsPlugin: () => __webpack_require__(21),
	HashedModuleIdsPlugin: () => __webpack_require__(140),
	HotModuleReplacementPlugin: () => __webpack_require__(339),
	IgnorePlugin: () => __webpack_require__(341),
	LibraryTemplatePlugin: () => __webpack_require__(122),
	LoaderOptionsPlugin: () => __webpack_require__(343),
	LoaderTargetPlugin: () => __webpack_require__(89),
	MemoryOutputFileSystem: () => __webpack_require__(345),
	Module: () => __webpack_require__(16),
	ModuleFilenameHelpers: () => __webpack_require__(18),
	NamedChunksPlugin: () => __webpack_require__(142),
	NamedModulesPlugin: () => __webpack_require__(139),
	NoEmitOnErrorsPlugin: () => __webpack_require__(138),
	NormalModuleReplacementPlugin: () =>
		__webpack_require__(353),
	PrefetchPlugin: () => __webpack_require__(354),
	ProgressPlugin: () => __webpack_require__(355),
	ProvidePlugin: () => __webpack_require__(357),
	SetVarMainTemplatePlugin: () => __webpack_require__(123),
	SingleEntryPlugin: () => __webpack_require__(61),
	SourceMapDevToolPlugin: () => __webpack_require__(60),
	Stats: () => __webpack_require__(23),
	Template: () => __webpack_require__(2),
	UmdMainTemplatePlugin: () => __webpack_require__(124),
	TerserPlugin: () => __webpack_require__(145),
	I18nPlugin: () => __webpack_require__(358),
	CopyPlugin: () => __webpack_require__(361),
	ReplaceCodePlugin: () => __webpack_require__(362),
	WatchIgnorePlugin: () => __webpack_require__(363)
});
exportPlugins((exports.dependencies = {}), {
	DependencyReference: () => __webpack_require__(14)
});
exportPlugins((exports.optimize = {}), {
	AggressiveMergingPlugin: () => __webpack_require__(365),
	AggressiveSplittingPlugin: () =>
		__webpack_require__(366),
	ChunkModuleIdRangePlugin: () =>
		__webpack_require__(368),
	LimitChunkCountPlugin: () => __webpack_require__(369),
	MinChunkSizePlugin: () => __webpack_require__(372),
	ModuleConcatenationPlugin: () =>
		__webpack_require__(130),
	OccurrenceOrderPlugin: () => __webpack_require__(374),
	OccurrenceModuleOrderPlugin: () =>
		__webpack_require__(141),
	OccurrenceChunkOrderPlugin: () =>
		__webpack_require__(143),
	RuntimeChunkPlugin: () => __webpack_require__(137),
	SideEffectsFlagPlugin: () => __webpack_require__(129),
	SplitChunksPlugin: () => __webpack_require__(136)
});
exportPlugins((exports.web = {}), {
	FetchCompileWasmTemplatePlugin: () =>
		__webpack_require__(45),
	JsonpTemplatePlugin: () => __webpack_require__(44)
});
exportPlugins((exports.webworker = {}), {
	WebWorkerTemplatePlugin: () => __webpack_require__(119)
});
exportPlugins((exports.node = {}), {
	NodeTemplatePlugin: () => __webpack_require__(46),
	ReadFileCompileWasmTemplatePlugin: () =>
		__webpack_require__(120)
});
exportPlugins((exports.debug = {}), {
	ProfilingPlugin: () => __webpack_require__(375)
});
exportPlugins((exports.util = {}), {
	createHash: () => __webpack_require__(15)
});

const defineMissingPluginError = (namespace, pluginName, errorMessage) => {
	Object.defineProperty(namespace, pluginName, {
		configurable: false,
		enumerable: true,
		get() {
			throw new RemovedPluginError(errorMessage);
		}
	});
};

defineMissingPluginError(
	exports.optimize,
	"UglifyJsPlugin",
	"webpack.optimize.UglifyJsPlugin has been removed, please use config.optimization.minimize instead."
);

defineMissingPluginError(
	exports.optimize,
	"CommonsChunkPlugin",
	"webpack.optimize.CommonsChunkPlugin has been removed, please use config.optimization.splitChunks instead."
);

},
// 152
function(module, exports, __webpack_require__) {

const parseJson = __webpack_require__(51);
const asyncLib = __webpack_require__(12);
const path = __webpack_require__(3);
const { Source } = __webpack_require__(0);
const util = __webpack_require__(11);
const {
	Tapable,
	SyncHook,
	SyncBailHook,
	AsyncParallelHook,
	AsyncSeriesHook
} = __webpack_require__(6);

const Compilation = __webpack_require__(153);
const Stats = __webpack_require__(23);
const Watching = __webpack_require__(169);
const NormalModuleFactory = __webpack_require__(170);
const ContextModuleFactory = __webpack_require__(182);
const ResolverFactory = __webpack_require__(184);

const RequestShortener = __webpack_require__(52);
const { makePathsRelative } = __webpack_require__(13);
const ConcurrentCompilationError = __webpack_require__(79);
const { Logger } = __webpack_require__(32);

class Compiler extends Tapable {
	constructor(context) {
		super();
		this.hooks = {
			shouldEmit: new SyncBailHook(["compilation"]),
			done: new AsyncSeriesHook(["stats"]),
			additionalPass: new AsyncSeriesHook([]),
			beforeRun: new AsyncSeriesHook(["compiler"]),
			run: new AsyncSeriesHook(["compiler"]),
			emit: new AsyncSeriesHook(["compilation"]),
			assetEmitted: new AsyncSeriesHook(["file", "content"]),
			afterEmit: new AsyncSeriesHook(["compilation"]),

			thisCompilation: new SyncHook(["compilation", "params"]),
			compilation: new SyncHook(["compilation", "params"]),
			normalModuleFactory: new SyncHook(["normalModuleFactory"]),
			contextModuleFactory: new SyncHook(["contextModulefactory"]),

			beforeCompile: new AsyncSeriesHook(["params"]),
			compile: new SyncHook(["params"]),
			make: new AsyncParallelHook(["compilation"]),
			afterCompile: new AsyncSeriesHook(["compilation"]),

			watchRun: new AsyncSeriesHook(["compiler"]),
			failed: new SyncHook(["error"]),
			invalid: new SyncHook(["filename", "changeTime"]),
			watchClose: new SyncHook([]),

			infrastructureLog: new SyncBailHook(["origin", "type", "args"]),

			environment: new SyncHook([]),
			afterEnvironment: new SyncHook([]),
			afterPlugins: new SyncHook(["compiler"]),
			afterResolvers: new SyncHook(["compiler"]),
			entryOption: new SyncBailHook(["context", "entry"])
		};
		this.hooks.infrastructurelog = this.hooks.infrastructureLog;

		this._pluginCompat.tap("Compiler", options => {
			switch (options.name) {
				case "additional-pass":
				case "before-run":
				case "run":
				case "emit":
				case "after-emit":
				case "before-compile":
				case "make":
				case "after-compile":
				case "watch-run":
					options.async = true;
					break;
			}
		});

		this.name = void 0;
		this.parentCompilation = void 0;
		this.outputPath = "";

		this.outputFileSystem = null;
		this.inputFileSystem = null;

		this.recordsInputPath = null;
		this.recordsOutputPath = null;
		this.records = {};
		this.removedFiles = new Set();
		this.fileTimestamps = new Map();
		this.contextTimestamps = new Map();
		this.resolverFactory = new ResolverFactory();

		this.infrastructureLogger = void 0;

		this.resolvers = {
			normal: {
				plugins: util.deprecate((hook, fn) => {
					this.resolverFactory.plugin("resolver normal", resolver => {
						resolver.plugin(hook, fn);
					});
				}, 'webpack: Using compiler.resolvers.normal is deprecated.\nUse compiler.resolverFactory.plugin("resolver normal", resolver => {\n  resolver.plugin(/* … */);\n}); instead.'),
				apply: util.deprecate((...args) => {
					this.resolverFactory.plugin("resolver normal", resolver => {
						resolver.apply(...args);
					});
				}, 'webpack: Using compiler.resolvers.normal is deprecated.\nUse compiler.resolverFactory.plugin("resolver normal", resolver => {\n  resolver.apply(/* … */);\n}); instead.')
			},
			loader: {
				plugins: util.deprecate((hook, fn) => {
					this.resolverFactory.plugin("resolver loader", resolver => {
						resolver.plugin(hook, fn);
					});
				}, 'webpack: Using compiler.resolvers.loader is deprecated.\nUse compiler.resolverFactory.plugin("resolver loader", resolver => {\n  resolver.plugin(/* … */);\n}); instead.'),
				apply: util.deprecate((...args) => {
					this.resolverFactory.plugin("resolver loader", resolver => {
						resolver.apply(...args);
					});
				}, 'webpack: Using compiler.resolvers.loader is deprecated.\nUse compiler.resolverFactory.plugin("resolver loader", resolver => {\n  resolver.apply(/* … */);\n}); instead.')
			},
			context: {
				plugins: util.deprecate((hook, fn) => {
					this.resolverFactory.plugin("resolver context", resolver => {
						resolver.plugin(hook, fn);
					});
				}, 'webpack: Using compiler.resolvers.context is deprecated.\nUse compiler.resolverFactory.plugin("resolver context", resolver => {\n  resolver.plugin(/* … */);\n}); instead.'),
				apply: util.deprecate((...args) => {
					this.resolverFactory.plugin("resolver context", resolver => {
						resolver.apply(...args);
					});
				}, 'webpack: Using compiler.resolvers.context is deprecated.\nUse compiler.resolverFactory.plugin("resolver context", resolver => {\n  resolver.apply(/* … */);\n}); instead.')
			}
		};

		this.options = ({});

		this.context = context;

		this.requestShortener = new RequestShortener(context);

		this.running = false;

		this.watchMode = false;

		this._assetEmittingSourceCache = new WeakMap();
		this._assetEmittingWrittenFiles = new Map();
	}

	getInfrastructureLogger(name) {
		if (!name) {
			throw new TypeError(
				"Compiler.getInfrastructureLogger(name) called without a name"
			);
		}
		return new Logger((type, args) => {
			if (typeof name == "function") {
				name = name();
				if (!name) {
					throw new TypeError(
						"Compiler.getInfrastructureLogger(name) called with a function not returning a name"
					);
				}
			}
			if (this.hooks.infrastructureLog.call(name, type, args) === void 0) {
				if (this.infrastructureLogger !== void 0) {
					this.infrastructureLogger(name, type, args);
				}
			}
		});
	}

	watch(watchOptions, handler) {
		if (this.running) return handler(new ConcurrentCompilationError());

		this.running = true;
		this.watchMode = true;
		this.fileTimestamps = new Map();
		this.contextTimestamps = new Map();
		this.removedFiles = new Set();
		return new Watching(this, watchOptions, handler);
	}

	run(callback) {
		if (this.running) return callback(new ConcurrentCompilationError());

		const finalCallback = (err, stats) => {
			this.running = false;

			if (err) {
				this.hooks.failed.call(err);
			}

			if (callback !== void 0) return callback(err, stats);
		};

		const startTime = Date.now();

		this.running = true;

		const onCompiled = (err, compilation) => {
			if (err) return finalCallback(err);

			if (this.hooks.shouldEmit.call(compilation) === false) {
				const stats = new Stats(compilation);
				stats.startTime = startTime;
				stats.endTime = Date.now();
				this.hooks.done.callAsync(stats, err => {
					if (err) return finalCallback(err);
					return finalCallback(null, stats);
				});
				return;
			}

			this.emitAssets(compilation, err => {
				if (err) return finalCallback(err);

				if (compilation.hooks.needAdditionalPass.call()) {
					compilation.needAdditionalPass = true;

					const stats = new Stats(compilation);
					stats.startTime = startTime;
					stats.endTime = Date.now();
					this.hooks.done.callAsync(stats, err => {
						if (err) return finalCallback(err);

						this.hooks.additionalPass.callAsync(err => {
							if (err) return finalCallback(err);
							this.compile(onCompiled);
						});
					});
					return;
				}

				this.emitRecords(err => {
					if (err) return finalCallback(err);

					const stats = new Stats(compilation);
					stats.startTime = startTime;
					stats.endTime = Date.now();
					this.hooks.done.callAsync(stats, err => {
						if (err) return finalCallback(err);
						return finalCallback(null, stats);
					});
				});
			});
		};

		this.hooks.beforeRun.callAsync(this, err => {
			if (err) return finalCallback(err);

			this.hooks.run.callAsync(this, err => {
				if (err) return finalCallback(err);

				this.readRecords(err => {
					if (err) return finalCallback(err);

					this.compile(onCompiled);
				});
			});
		});
	}

	runAsChild(callback) {
		this.compile((err, compilation) => {
			if (err) return callback(err);

			this.parentCompilation.children.push(compilation);
			for (const { name, source, info } of compilation.getAssets()) {
				this.parentCompilation.emitAsset(name, source, info);
			}

			const entries = Array.from(
				compilation.entrypoints.values(),
				ep => ep.chunks
			).reduce((array, chunks) => {
				return array.concat(chunks);
			}, []);

			return callback(null, entries, compilation);
		});
	}

	purgeInputFileSystem() {
		if (this.inputFileSystem && this.inputFileSystem.purge) {
			this.inputFileSystem.purge();
		}
	}

	emitAssets(compilation, callback) {
		let outputPath;
		const emitFiles = err => {
			if (err) return callback(err);

			asyncLib.forEachLimit(
				compilation.getAssets(),
				15,
				({ name: file, source }, callback) => {
					let targetFile = file;
					const queryStringIdx = targetFile.indexOf("?");
					if (queryStringIdx >= 0) {
						targetFile = targetFile.substr(0, queryStringIdx);
					}

					const writeOut = err => {
						if (err) return callback(err);
						const targetPath = this.outputFileSystem.join(
							outputPath,
							targetFile
						);
						if (this.options.output.futureEmitAssets) {
							const targetFileGeneration = this._assetEmittingWrittenFiles.get(
								targetPath
							);

							let cacheEntry = this._assetEmittingSourceCache.get(source);
							if (cacheEntry === void 0) {
								cacheEntry = {
									sizeOnlySource: void 0,
									writtenTo: new Map()
								};
								this._assetEmittingSourceCache.set(source, cacheEntry);
							}

							if (targetFileGeneration !== void 0) {
								const writtenGeneration = cacheEntry.writtenTo.get(targetPath);
								if (writtenGeneration === targetFileGeneration) {
									compilation.updateAsset(file, cacheEntry.sizeOnlySource, {
										size: cacheEntry.sizeOnlySource.size()
									});

									return callback();
								}
							}

							let content;
							if (typeof source.buffer == "function") {
								content = source.buffer();
							} else {
								const bufferOrString = source.source();
								if (Buffer.isBuffer(bufferOrString)) {
									content = bufferOrString;
								} else {
									content = Buffer.from(bufferOrString, "utf8");
								}
							}

							cacheEntry.sizeOnlySource = new SizeOnlySource(content.length);
							compilation.updateAsset(file, cacheEntry.sizeOnlySource, {
								size: content.length
							});

							this.outputFileSystem.writeFile(targetPath, content, err => {
								if (err) return callback(err);

								compilation.emittedAssets.add(file);

								const newGeneration =
									targetFileGeneration === void 0
										? 1
										: targetFileGeneration + 1;
								cacheEntry.writtenTo.set(targetPath, newGeneration);
								this._assetEmittingWrittenFiles.set(targetPath, newGeneration);
								this.hooks.assetEmitted.callAsync(file, content, callback);
							});
						} else {
							if (source.existsAt === targetPath) {
								source.emitted = false;
								return callback();
							}
							let content = source.source();

							if (!Buffer.isBuffer(content)) {
								content = Buffer.from(content, "utf8");
							}

							source.existsAt = targetPath;
							source.emitted = true;
							this.outputFileSystem.writeFile(targetPath, content, err => {
								if (err) return callback(err);
								this.hooks.assetEmitted.callAsync(file, content, callback);
							});
						}
					};

					if (targetFile.match(/\/|\\/)) {
						const dir = path.dirname(targetFile);
						this.outputFileSystem.mkdirp(
							this.outputFileSystem.join(outputPath, dir),
							writeOut
						);
					} else {
						writeOut();
					}
				},
				err => {
					if (err) return callback(err);

					this.hooks.afterEmit.callAsync(compilation, err => {
						if (err) return callback(err);

						return callback();
					});
				}
			);
		};

		this.hooks.emit.callAsync(compilation, err => {
			if (err) return callback(err);
			outputPath = compilation.getPath(this.outputPath);
			this.outputFileSystem.mkdirp(outputPath, emitFiles);
		});
	}

	emitRecords(callback) {
		if (!this.recordsOutputPath) return callback();
		const idx1 = this.recordsOutputPath.lastIndexOf("/");
		const idx2 = this.recordsOutputPath.lastIndexOf("\\");
		let recordsOutputPathDirectory = null;
		if (idx1 > idx2) {
			recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx1);
		} else if (idx1 < idx2) {
			recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx2);
		}

		const writeFile = () => {
			this.outputFileSystem.writeFile(
				this.recordsOutputPath,
				JSON.stringify(this.records, void 0, 2),
				callback
			);
		};

		if (!recordsOutputPathDirectory) {
			return writeFile();
		}
		this.outputFileSystem.mkdirp(recordsOutputPathDirectory, err => {
			if (err) return callback(err);
			writeFile();
		});
	}

	readRecords(callback) {
		if (!this.recordsInputPath) {
			this.records = {};
			return callback();
		}
		this.inputFileSystem.stat(this.recordsInputPath, err => {
			if (err) return callback();

			this.inputFileSystem.readFile(this.recordsInputPath, (err, content) => {
				if (err) return callback(err);

				try {
					this.records = parseJson(content.toString("utf-8"));
				} catch (e) {
					e.message = "Cannot parse records: " + e.message;
					return callback(e);
				}

				return callback();
			});
		});
	}

	createChildCompiler(
		compilation,
		compilerName,
		compilerIndex,
		outputOptions,
		plugins
	) {
		const childCompiler = new Compiler(this.context);
		if (Array.isArray(plugins)) {
			for (const plugin of plugins) {
				plugin.apply(childCompiler);
			}
		}
		for (const name in this.hooks) {
			if (
				![
					"make",
					"compile",
					"emit",
					"afterEmit",
					"invalid",
					"done",
					"thisCompilation"
				].includes(name)
			) {
				if (childCompiler.hooks[name]) {
					childCompiler.hooks[name].taps = this.hooks[name].taps.slice();
				}
			}
		}
		childCompiler.name = compilerName;
		childCompiler.outputPath = this.outputPath;
		childCompiler.inputFileSystem = this.inputFileSystem;
		childCompiler.outputFileSystem = null;
		childCompiler.resolverFactory = this.resolverFactory;
		childCompiler.fileTimestamps = this.fileTimestamps;
		childCompiler.contextTimestamps = this.contextTimestamps;

		const relativeCompilerName = makePathsRelative(this.context, compilerName);
		if (!this.records[relativeCompilerName]) {
			this.records[relativeCompilerName] = [];
		}
		if (this.records[relativeCompilerName][compilerIndex]) {
			childCompiler.records = this.records[relativeCompilerName][compilerIndex];
		} else {
			this.records[relativeCompilerName].push((childCompiler.records = {}));
		}

		childCompiler.options = Object.create(this.options);
		childCompiler.options.output = Object.create(childCompiler.options.output);
		for (const name in outputOptions) {
			childCompiler.options.output[name] = outputOptions[name];
		}
		childCompiler.parentCompilation = compilation;

		compilation.hooks.childCompiler.call(
			childCompiler,
			compilerName,
			compilerIndex
		);

		return childCompiler;
	}

	isChild() {
		return !!this.parentCompilation;
	}

	createCompilation() {
		return new Compilation(this);
	}

	newCompilation(params) {
		const compilation = this.createCompilation();
		compilation.fileTimestamps = this.fileTimestamps;
		compilation.contextTimestamps = this.contextTimestamps;
		compilation.name = this.name;
		compilation.records = this.records;
		compilation.compilationDependencies = params.compilationDependencies;
		this.hooks.thisCompilation.call(compilation, params);
		this.hooks.compilation.call(compilation, params);
		return compilation;
	}

	createNormalModuleFactory() {
		const normalModuleFactory = new NormalModuleFactory(
			this.options.context,
			this.resolverFactory,
			this.options.module || {}
		);
		this.hooks.normalModuleFactory.call(normalModuleFactory);
		return normalModuleFactory;
	}

	createContextModuleFactory() {
		const contextModuleFactory = new ContextModuleFactory(this.resolverFactory);
		this.hooks.contextModuleFactory.call(contextModuleFactory);
		return contextModuleFactory;
	}

	newCompilationParams() {
		const params = {
			normalModuleFactory: this.createNormalModuleFactory(),
			contextModuleFactory: this.createContextModuleFactory(),
			compilationDependencies: new Set()
		};
		return params;
	}

	compile(callback) {
		const params = this.newCompilationParams();
		this.hooks.beforeCompile.callAsync(params, err => {
			if (err) return callback(err);

			this.hooks.compile.call(params);

			const compilation = this.newCompilation(params);

			this.hooks.make.callAsync(compilation, err => {
				if (err) return callback(err);

				compilation.finish(err => {
					if (err) return callback(err);

					compilation.seal(err => {
						if (err) return callback(err);

						this.hooks.afterCompile.callAsync(compilation, err => {
							if (err) return callback(err);

							return callback(null, compilation);
						});
					});
				});
			});
		});
	}
}

module.exports = Compiler;

class SizeOnlySource extends Source {
	constructor(size) {
		super();
		this._size = size;
	}

	_error() {
		return new Error(
			"Content and Map of this Source is no longer available (only size() is supported)"
		);
	}

	size() {
		return this._size;
	}

	source(options) {
		throw this._error();
	}

	node() {
		throw this._error();
	}

	listMap() {
		throw this._error();
	}

	map() {
		throw this._error();
	}

	listNode() {
		throw this._error();
	}

	updateHash() {
		throw this._error();
	}
}

},
// 153
function(module, exports, __webpack_require__) {

const asyncLib = __webpack_require__(12);
const util = __webpack_require__(11);
const { CachedSource } = __webpack_require__(0);
const {
	Tapable,
	SyncHook,
	SyncBailHook,
	SyncWaterfallHook,
	AsyncSeriesHook
} = __webpack_require__(6);
const EntryModuleNotFoundError = __webpack_require__(154);
const ModuleNotFoundError = __webpack_require__(155);
const ModuleDependencyWarning = __webpack_require__(156);
const ModuleDependencyError = __webpack_require__(157);
const ChunkGroup = __webpack_require__(72);
const Chunk = __webpack_require__(73);
const Entrypoint = __webpack_require__(74);
const MainTemplate = __webpack_require__(158);
const ChunkTemplate = __webpack_require__(159);
const HotUpdateChunkTemplate = __webpack_require__(160);
const ModuleTemplate = __webpack_require__(161);
const RuntimeTemplate = __webpack_require__(162);
const ChunkRenderError = __webpack_require__(163);
const Stats = __webpack_require__(23);
const Semaphore = __webpack_require__(165);
const createHash = __webpack_require__(15);
const SortableSet = __webpack_require__(20);
const GraphHelpers = __webpack_require__(22);
const ModuleDependency = __webpack_require__(4);
const compareLocations = __webpack_require__(29);
const { Logger, LogType } = __webpack_require__(32);
const ErrorHelpers = __webpack_require__(33);
const buildChunkGraph = __webpack_require__(167);
const WebpackError = __webpack_require__(1);

const byId = (a, b) => {
	if (typeof a.id !== typeof b.id) {
		return typeof a.id < typeof b.id ? -1 : 1;
	}
	if (a.id < b.id) return -1;
	if (a.id > b.id) return 1;
	return 0;
};

const byIdOrIdentifier = (a, b) => {
	if (typeof a.id !== typeof b.id) {
		return typeof a.id < typeof b.id ? -1 : 1;
	}
	if (a.id < b.id) return -1;
	if (a.id > b.id) return 1;
	const identA = a.identifier();
	const identB = b.identifier();
	if (identA < identB) return -1;
	if (identA > identB) return 1;
	return 0;
};

const byIndexOrIdentifier = (a, b) => {
	if (a.index < b.index) return -1;
	if (a.index > b.index) return 1;
	const identA = a.identifier();
	const identB = b.identifier();
	if (identA < identB) return -1;
	if (identA > identB) return 1;
	return 0;
};

const byNameOrHash = (a, b) => {
	if (a.name < b.name) return -1;
	if (a.name > b.name) return 1;
	if (a.fullHash < b.fullHash) return -1;
	if (a.fullHash > b.fullHash) return 1;
	return 0;
};

const iterationBlockVariable = (variables, fn) => {
	for (
		let indexVariable = 0;
		indexVariable < variables.length;
		indexVariable++
	) {
		const varDep = variables[indexVariable].dependencies;
		for (let indexVDep = 0; indexVDep < varDep.length; indexVDep++) {
			fn(varDep[indexVDep]);
		}
	}
};

const iterationOfArrayCallback = (arr, fn) => {
	for (let index = 0; index < arr.length; index++) {
		fn(arr[index]);
	}
};

const addAllToSet = (set, otherSet) => {
	for (const item of otherSet) {
		set.add(item);
	}
};

const isSourceEqual = (a, b) => {
	if (a === b) return true;
	let aSource = a.source();
	let bSource = b.source();
	if (aSource === bSource) return true;
	if (typeof aSource == "string" && typeof bSource == "string") return false;
	if (!Buffer.isBuffer(aSource)) aSource = Buffer.from(aSource, "utf-8");
	if (!Buffer.isBuffer(bSource)) bSource = Buffer.from(bSource, "utf-8");
	return aSource.equals(bSource);
};

class Compilation extends Tapable {
	constructor(compiler) {
		super();
		this.hooks = {
			buildModule: new SyncHook(["module"]),
			rebuildModule: new SyncHook(["module"]),
			failedModule: new SyncHook(["module", "error"]),
			succeedModule: new SyncHook(["module"]),

			addEntry: new SyncHook(["entry", "name"]),
			failedEntry: new SyncHook(["entry", "name", "error"]),
			succeedEntry: new SyncHook(["entry", "name", "module"]),

			dependencyReference: new SyncWaterfallHook([
				"dependencyReference",
				"dependency",
				"module"
			]),

			finishModules: new AsyncSeriesHook(["modules"]),
			finishRebuildingModule: new SyncHook(["module"]),
			unseal: new SyncHook([]),
			seal: new SyncHook([]),

			beforeChunks: new SyncHook([]),
			afterChunks: new SyncHook(["chunks"]),

			optimizeDependenciesBasic: new SyncBailHook(["modules"]),
			optimizeDependencies: new SyncBailHook(["modules"]),
			optimizeDependenciesAdvanced: new SyncBailHook(["modules"]),
			afterOptimizeDependencies: new SyncHook(["modules"]),

			optimize: new SyncHook([]),
			optimizeModulesBasic: new SyncBailHook(["modules"]),
			optimizeModules: new SyncBailHook(["modules"]),
			optimizeModulesAdvanced: new SyncBailHook(["modules"]),
			afterOptimizeModules: new SyncHook(["modules"]),

			optimizeChunksBasic: new SyncBailHook(["chunks", "chunkGroups"]),
			optimizeChunks: new SyncBailHook(["chunks", "chunkGroups"]),
			optimizeChunksAdvanced: new SyncBailHook(["chunks", "chunkGroups"]),
			afterOptimizeChunks: new SyncHook(["chunks", "chunkGroups"]),

			optimizeTree: new AsyncSeriesHook(["chunks", "modules"]),
			afterOptimizeTree: new SyncHook(["chunks", "modules"]),

			optimizeChunkModulesBasic: new SyncBailHook(["chunks", "modules"]),
			optimizeChunkModules: new SyncBailHook(["chunks", "modules"]),
			optimizeChunkModulesAdvanced: new SyncBailHook(["chunks", "modules"]),
			afterOptimizeChunkModules: new SyncHook(["chunks", "modules"]),
			shouldRecord: new SyncBailHook([]),

			reviveModules: new SyncHook(["modules", "records"]),
			optimizeModuleOrder: new SyncHook(["modules"]),
			advancedOptimizeModuleOrder: new SyncHook(["modules"]),
			beforeModuleIds: new SyncHook(["modules"]),
			moduleIds: new SyncHook(["modules"]),
			optimizeModuleIds: new SyncHook(["modules"]),
			afterOptimizeModuleIds: new SyncHook(["modules"]),

			reviveChunks: new SyncHook(["chunks", "records"]),
			optimizeChunkOrder: new SyncHook(["chunks"]),
			beforeChunkIds: new SyncHook(["chunks"]),
			optimizeChunkIds: new SyncHook(["chunks"]),
			afterOptimizeChunkIds: new SyncHook(["chunks"]),

			recordModules: new SyncHook(["modules", "records"]),
			recordChunks: new SyncHook(["chunks", "records"]),

			beforeHash: new SyncHook([]),
			contentHash: new SyncHook(["chunk"]),
			afterHash: new SyncHook([]),
			recordHash: new SyncHook(["records"]),
			record: new SyncHook(["compilation", "records"]),

			beforeModuleAssets: new SyncHook([]),
			shouldGenerateChunkAssets: new SyncBailHook([]),
			beforeChunkAssets: new SyncHook([]),
			additionalChunkAssets: new SyncHook(["chunks"]),

			additionalAssets: new AsyncSeriesHook([]),
			optimizeChunkAssets: new AsyncSeriesHook(["chunks"]),
			afterOptimizeChunkAssets: new SyncHook(["chunks"]),
			optimizeAssets: new AsyncSeriesHook(["assets"]),
			afterOptimizeAssets: new SyncHook(["assets"]),

			needAdditionalSeal: new SyncBailHook([]),
			afterSeal: new AsyncSeriesHook([]),

			chunkHash: new SyncHook(["chunk", "chunkHash"]),
			moduleAsset: new SyncHook(["module", "filename"]),
			chunkAsset: new SyncHook(["chunk", "filename"]),

			assetPath: new SyncWaterfallHook(["filename", "data"]),

			needAdditionalPass: new SyncBailHook([]),

			childCompiler: new SyncHook([
				"childCompiler",
				"compilerName",
				"compilerIndex"
			]),

			log: new SyncBailHook(["origin", "logEntry"]),

			normalModuleLoader: new SyncHook(["loaderContext", "module"]),

			optimizeExtractedChunksBasic: new SyncBailHook(["chunks"]),
			optimizeExtractedChunks: new SyncBailHook(["chunks"]),
			optimizeExtractedChunksAdvanced: new SyncBailHook(["chunks"]),
			afterOptimizeExtractedChunks: new SyncHook(["chunks"])
		};
		this._pluginCompat.tap("Compilation", options => {
			switch (options.name) {
				case "optimize-tree":
				case "additional-assets":
				case "optimize-chunk-assets":
				case "optimize-assets":
				case "after-seal":
					options.async = true;
					break;
			}
		});
		this.name = void 0;
		this.compiler = compiler;
		this.resolverFactory = compiler.resolverFactory;
		this.inputFileSystem = compiler.inputFileSystem;
		this.requestShortener = compiler.requestShortener;

		const options = compiler.options;
		this.options = options;
		this.outputOptions = options && options.output;
		this.bail = options && options.bail;
		this.profile = options && options.profile;
		this.performance = options && options.performance;

		this.mainTemplate = new MainTemplate(this.outputOptions);
		this.chunkTemplate = new ChunkTemplate(this.outputOptions);
		this.hotUpdateChunkTemplate = new HotUpdateChunkTemplate(
			this.outputOptions
		);
		this.runtimeTemplate = new RuntimeTemplate(
			this.outputOptions,
			this.requestShortener
		);
		this.moduleTemplates = {
			javascript: new ModuleTemplate(this.runtimeTemplate, "javascript"),
			webassembly: new ModuleTemplate(this.runtimeTemplate, "webassembly")
		};

		this.semaphore = new Semaphore(options.parallelism || 100);

		this.entries = [];
		this._preparedEntrypoints = [];
		this.entrypoints = new Map();
		this.chunks = [];
		this.chunkGroups = [];
		this.namedChunkGroups = new Map();
		this.namedChunks = new Map();
		this.modules = [];
		this._modules = new Map();
		this.cache = null;
		this.records = null;
		this.additionalChunkAssets = [];
		this.assets = {};
		this.assetsInfo = new Map();
		this.errors = [];
		this.warnings = [];
		this.children = [];
		this.logging = new Map();
		this.dependencyFactories = new Map();
		this.dependencyTemplates = new Map();
		this.dependencyTemplates.set("hash", "");
		this.childrenCounters = {};
		this.usedChunkIds = null;
		this.usedModuleIds = null;
		this.fileTimestamps = void 0;
		this.contextTimestamps = void 0;
		this.compilationDependencies = void 0;
		this._buildingModules = new Map();
		this._rebuildingModules = new Map();
		this.emittedAssets = new Set();
	}

	getStats() {
		return new Stats(this);
	}

	getLogger(name) {
		if (!name) {
			throw new TypeError("Compilation.getLogger(name) called without a name");
		}
		let logEntries;
		return new Logger((type, args) => {
			if (typeof name == "function") {
				name = name();
				if (!name) {
					throw new TypeError(
						"Compilation.getLogger(name) called with a function not returning a name"
					);
				}
			}
			let trace;
			switch (type) {
				case LogType.warn:
				case LogType.error:
				case LogType.trace:
					trace = ErrorHelpers.cutOffLoaderExecution(new Error("Trace").stack)
						.split("\n")
						.slice(3);
					break;
			}
			const logEntry = {
				time: Date.now(),
				type,
				args,
				trace
			};
			if (this.hooks.log.call(name, logEntry) === void 0) {
				if (logEntry.type === LogType.profileEnd) {
					if (typeof console.profileEnd == "function") {
						console.profileEnd(`[${name}] ${logEntry.args[0]}`);
					}
				}
				if (logEntries === void 0) {
					logEntries = this.logging.get(name);
					if (logEntries === void 0) {
						logEntries = [];
						this.logging.set(name, logEntries);
					}
				}
				logEntries.push(logEntry);
				if (logEntry.type === LogType.profile) {
					if (typeof console.profile == "function") {
						console.profile(`[${name}] ${logEntry.args[0]}`);
					}
				}
			}
		});
	}

	addModule(module, cacheGroup) {
		const identifier = module.identifier();
		const alreadyAddedModule = this._modules.get(identifier);
		if (alreadyAddedModule) {
			return {
				module: alreadyAddedModule,
				issuer: false,
				build: false,
				dependencies: false
			};
		}
		const cacheName = (cacheGroup || "m") + identifier;
		if (this.cache && this.cache[cacheName]) {
			const cacheModule = this.cache[cacheName];

			if (typeof cacheModule.updateCacheModule == "function") {
				cacheModule.updateCacheModule(module);
			}

			let rebuild = true;
			if (this.fileTimestamps && this.contextTimestamps) {
				rebuild = cacheModule.needRebuild(
					this.fileTimestamps,
					this.contextTimestamps
				);
			}

			if (!rebuild) {
				cacheModule.disconnect();
				this._modules.set(identifier, cacheModule);
				this.modules.push(cacheModule);
				for (const err of cacheModule.errors) {
					this.errors.push(err);
				}
				for (const err of cacheModule.warnings) {
					this.warnings.push(err);
				}
				return {
					module: cacheModule,
					issuer: true,
					build: false,
					dependencies: true
				};
			}
			cacheModule.unbuild();
			module = cacheModule;
		}
		this._modules.set(identifier, module);
		if (this.cache) {
			this.cache[cacheName] = module;
		}
		this.modules.push(module);
		return {
			module: module,
			issuer: true,
			build: true,
			dependencies: true
		};
	}

	getModule(module) {
		const identifier = module.identifier();
		return this._modules.get(identifier);
	}

	findModule(identifier) {
		return this._modules.get(identifier);
	}

	waitForBuildingFinished(module, callback) {
		let callbackList = this._buildingModules.get(module);
		if (callbackList) {
			callbackList.push(() => callback());
		} else {
			process.nextTick(callback);
		}
	}

	buildModule(module, optional, origin, dependencies, thisCallback) {
		let callbackList = this._buildingModules.get(module);
		if (callbackList) {
			callbackList.push(thisCallback);
			return;
		}
		this._buildingModules.set(module, (callbackList = [thisCallback]));

		const callback = err => {
			this._buildingModules.delete(module);
			for (const cb of callbackList) {
				cb(err);
			}
		};

		this.hooks.buildModule.call(module);
		module.build(
			this.options,
			this,
			this.resolverFactory.get("normal", module.resolveOptions),
			this.inputFileSystem,
			error => {
				const errors = module.errors;
				for (let indexError = 0; indexError < errors.length; indexError++) {
					const err = errors[indexError];
					err.origin = origin;
					err.dependencies = dependencies;
					if (optional) {
						this.warnings.push(err);
					} else {
						this.errors.push(err);
					}
				}

				const warnings = module.warnings;
				for (
					let indexWarning = 0;
					indexWarning < warnings.length;
					indexWarning++
				) {
					const war = warnings[indexWarning];
					war.origin = origin;
					war.dependencies = dependencies;
					this.warnings.push(war);
				}
				const originalMap = module.dependencies.reduce((map, v, i) => {
					map.set(v, i);
					return map;
				}, new Map());
				module.dependencies.sort((a, b) => {
					const cmp = compareLocations(a.loc, b.loc);
					if (cmp) return cmp;
					return originalMap.get(a) - originalMap.get(b);
				});
				if (error) {
					this.hooks.failedModule.call(module, error);
					return callback(error);
				}
				this.hooks.succeedModule.call(module);
				return callback();
			}
		);
	}

	processModuleDependencies(module, callback) {
		const dependencies = new Map();

		const addDependency = dep => {
			const resourceIdent = dep.getResourceIdentifier();
			if (resourceIdent) {
				const factory = this.dependencyFactories.get(dep.constructor);
				if (factory === void 0) {
					throw new Error(
						`No module factory available for dependency type: ${dep.constructor.name}`
					);
				}
				let innerMap = dependencies.get(factory);
				if (innerMap === void 0) {
					dependencies.set(factory, (innerMap = new Map()));
				}
				let list = innerMap.get(resourceIdent);
				if (list === void 0) innerMap.set(resourceIdent, (list = []));
				list.push(dep);
			}
		};

		const addDependenciesBlock = block => {
			if (block.dependencies) {
				iterationOfArrayCallback(block.dependencies, addDependency);
			}
			if (block.blocks) {
				iterationOfArrayCallback(block.blocks, addDependenciesBlock);
			}
			if (block.variables) {
				iterationBlockVariable(block.variables, addDependency);
			}
		};

		try {
			addDependenciesBlock(module);
		} catch (e) {
			callback(e);
		}

		const sortedDependencies = [];

		for (const pair1 of dependencies) {
			for (const pair2 of pair1[1]) {
				sortedDependencies.push({
					factory: pair1[0],
					dependencies: pair2[1]
				});
			}
		}

		this.addModuleDependencies(
			module,
			sortedDependencies,
			this.bail,
			null,
			true,
			callback
		);
	}

	addModuleDependencies(
		module,
		dependencies,
		bail,
		cacheGroup,
		recursive,
		callback
	) {
		const start = this.profile && Date.now();
		const currentProfile = this.profile && {};

		asyncLib.forEach(
			dependencies,
			(item, callback) => {
				const dependencies = item.dependencies;

				const errorAndCallback = err => {
					err.origin = module;
					err.dependencies = dependencies;
					this.errors.push(err);
					if (bail) {
						callback(err);
					} else {
						callback();
					}
				};
				const warningAndCallback = err => {
					err.origin = module;
					this.warnings.push(err);
					callback();
				};

				const semaphore = this.semaphore;
				semaphore.acquire(() => {
					const factory = item.factory;
					factory.create(
						{
							contextInfo: {
								issuer: module.nameForCondition && module.nameForCondition(),
								compiler: this.compiler.name
							},
							resolveOptions: module.resolveOptions,
							context: module.context,
							dependencies: dependencies
						},
						(err, dependentModule) => {
							let afterFactory;

							const isOptional = () => {
								return dependencies.every(d => d.optional);
							};

							const errorOrWarningAndCallback = err => {
								if (isOptional()) {
									return warningAndCallback(err);
								} else {
									return errorAndCallback(err);
								}
							};

							if (err) {
								semaphore.release();
								return errorOrWarningAndCallback(
									new ModuleNotFoundError(module, err)
								);
							}
							if (!dependentModule) {
								semaphore.release();
								return process.nextTick(callback);
							}
							if (currentProfile) {
								afterFactory = Date.now();
								currentProfile.factory = afterFactory - start;
							}

							const iterationDependencies = depend => {
								for (let index = 0; index < depend.length; index++) {
									const dep = depend[index];
									dep.module = dependentModule;
									dependentModule.addReason(module, dep);
								}
							};

							const addModuleResult = this.addModule(
								dependentModule,
								cacheGroup
							);
							dependentModule = addModuleResult.module;
							iterationDependencies(dependencies);

							const afterBuild = () => {
								if (recursive && addModuleResult.dependencies) {
									this.processModuleDependencies(dependentModule, callback);
								} else {
									return callback();
								}
							};

							if (addModuleResult.issuer) {
								if (currentProfile) {
									dependentModule.profile = currentProfile;
								}

								dependentModule.issuer = module;
							} else {
								if (this.profile) {
									if (module.profile) {
										const time = Date.now() - start;
										if (
											!module.profile.dependencies ||
											time > module.profile.dependencies
										) {
											module.profile.dependencies = time;
										}
									}
								}
							}

							if (addModuleResult.build) {
								this.buildModule(
									dependentModule,
									isOptional(),
									module,
									dependencies,
									err => {
										if (err) {
											semaphore.release();
											return errorOrWarningAndCallback(err);
										}

										if (currentProfile) {
											const afterBuilding = Date.now();
											currentProfile.building = afterBuilding - afterFactory;
										}

										semaphore.release();
										afterBuild();
									}
								);
							} else {
								semaphore.release();
								this.waitForBuildingFinished(dependentModule, afterBuild);
							}
						}
					);
				});
			},
			err => {
				if (err) {
					err.stack = err.stack;
					return callback(err);
				}

				return process.nextTick(callback);
			}
		);
	}

	_addModuleChain(context, dependency, onModule, callback) {
		const start = this.profile && Date.now();
		const currentProfile = this.profile && {};

		const errorAndCallback = this.bail
			? err => {
					callback(err);
				}
			: err => {
					err.dependencies = [dependency];
					this.errors.push(err);
					callback();
				};

		if (
			typeof dependency != "object" ||
			dependency === null ||
			!dependency.constructor
		) {
			throw new Error("Parameter 'dependency' must be a Dependency");
		}
		const Dep = (dependency.constructor);
		const moduleFactory = this.dependencyFactories.get(Dep);
		if (!moduleFactory) {
			throw new Error(
				`No dependency factory available for this dependency type: ${dependency.constructor.name}`
			);
		}

		this.semaphore.acquire(() => {
			moduleFactory.create(
				{
					contextInfo: {
						issuer: "",
						compiler: this.compiler.name
					},
					context: context,
					dependencies: [dependency]
				},
				(err, module) => {
					if (err) {
						this.semaphore.release();
						return errorAndCallback(new EntryModuleNotFoundError(err));
					}

					let afterFactory;

					if (currentProfile) {
						afterFactory = Date.now();
						currentProfile.factory = afterFactory - start;
					}

					const addModuleResult = this.addModule(module);
					module = addModuleResult.module;

					onModule(module);

					dependency.module = module;
					module.addReason(null, dependency);

					const afterBuild = () => {
						if (addModuleResult.dependencies) {
							this.processModuleDependencies(module, err => {
								if (err) return callback(err);
								callback(null, module);
							});
						} else {
							return callback(null, module);
						}
					};

					if (addModuleResult.issuer) {
						if (currentProfile) {
							module.profile = currentProfile;
						}
					}

					if (addModuleResult.build) {
						this.buildModule(module, false, null, null, err => {
							if (err) {
								this.semaphore.release();
								return errorAndCallback(err);
							}

							if (currentProfile) {
								const afterBuilding = Date.now();
								currentProfile.building = afterBuilding - afterFactory;
							}

							this.semaphore.release();
							afterBuild();
						});
					} else {
						this.semaphore.release();
						this.waitForBuildingFinished(module, afterBuild);
					}
				}
			);
		});
	}

	addEntry(context, entry, name, callback) {
		this.hooks.addEntry.call(entry, name);

		const slot = {
			name: name,
			request: null,
			module: null
		};

		if (entry instanceof ModuleDependency) {
			slot.request = entry.request;
		}

		const idx = this._preparedEntrypoints.findIndex(slot => slot.name === name);
		if (idx >= 0) {
			this._preparedEntrypoints[idx] = slot;
		} else {
			this._preparedEntrypoints.push(slot);
		}
		this._addModuleChain(
			context,
			entry,
			module => {
				this.entries.push(module);
			},
			(err, module) => {
				if (err) {
					this.hooks.failedEntry.call(entry, name, err);
					return callback(err);
				}

				if (module) {
					slot.module = module;
				} else {
					const idx = this._preparedEntrypoints.indexOf(slot);
					if (idx >= 0) {
						this._preparedEntrypoints.splice(idx, 1);
					}
				}
				this.hooks.succeedEntry.call(entry, name, module);
				return callback(null, module);
			}
		);
	}

	prefetch(context, dependency, callback) {
		this._addModuleChain(
			context,
			dependency,
			module => {
				module.prefetched = true;
			},
			callback
		);
	}

	rebuildModule(module, thisCallback) {
		let callbackList = this._rebuildingModules.get(module);
		if (callbackList) {
			callbackList.push(thisCallback);
			return;
		}
		this._rebuildingModules.set(module, (callbackList = [thisCallback]));

		const callback = err => {
			this._rebuildingModules.delete(module);
			for (const cb of callbackList) {
				cb(err);
			}
		};

		this.hooks.rebuildModule.call(module);
		const oldDependencies = module.dependencies.slice();
		const oldVariables = module.variables.slice();
		const oldBlocks = module.blocks.slice();
		module.unbuild();
		this.buildModule(module, false, module, null, err => {
			if (err) {
				this.hooks.finishRebuildingModule.call(module);
				return callback(err);
			}

			this.processModuleDependencies(module, err => {
				if (err) return callback(err);
				this.removeReasonsOfDependencyBlock(module, {
					dependencies: oldDependencies,
					variables: oldVariables,
					blocks: oldBlocks
				});
				this.hooks.finishRebuildingModule.call(module);
				callback();
			});
		});
	}

	finish(callback) {
		const modules = this.modules;
		this.hooks.finishModules.callAsync(modules, err => {
			if (err) return callback(err);

			for (let index = 0; index < modules.length; index++) {
				const module = modules[index];
				this.reportDependencyErrorsAndWarnings(module, [module]);
			}

			callback();
		});
	}

	unseal() {
		this.hooks.unseal.call();
		this.chunks.length = 0;
		this.chunkGroups.length = 0;
		this.namedChunks.clear();
		this.namedChunkGroups.clear();
		this.additionalChunkAssets.length = 0;
		this.assets = {};
		this.assetsInfo.clear();
		for (const module of this.modules) {
			module.unseal();
		}
	}

	seal(callback) {
		this.hooks.seal.call();

		while (
			this.hooks.optimizeDependenciesBasic.call(this.modules) ||
			this.hooks.optimizeDependencies.call(this.modules) ||
			this.hooks.optimizeDependenciesAdvanced.call(this.modules)
		);
		this.hooks.afterOptimizeDependencies.call(this.modules);

		this.hooks.beforeChunks.call();
		for (const preparedEntrypoint of this._preparedEntrypoints) {
			const module = preparedEntrypoint.module;
			const name = preparedEntrypoint.name;
			const chunk = this.addChunk(name);
			const entrypoint = new Entrypoint(name);
			entrypoint.setRuntimeChunk(chunk);
			entrypoint.addOrigin(null, name, preparedEntrypoint.request);
			this.namedChunkGroups.set(name, entrypoint);
			this.entrypoints.set(name, entrypoint);
			this.chunkGroups.push(entrypoint);

			GraphHelpers.connectChunkGroupAndChunk(entrypoint, chunk);
			GraphHelpers.connectChunkAndModule(chunk, module);

			chunk.entryModule = module;
			chunk.name = name;

			this.assignDepth(module);
		}
		buildChunkGraph(
			this,
			(this.chunkGroups.slice())
		);
		this.sortModules(this.modules);
		this.hooks.afterChunks.call(this.chunks);

		this.hooks.optimize.call();

		while (
			this.hooks.optimizeModulesBasic.call(this.modules) ||
			this.hooks.optimizeModules.call(this.modules) ||
			this.hooks.optimizeModulesAdvanced.call(this.modules)
		);
		this.hooks.afterOptimizeModules.call(this.modules);

		while (
			this.hooks.optimizeChunksBasic.call(this.chunks, this.chunkGroups) ||
			this.hooks.optimizeChunks.call(this.chunks, this.chunkGroups) ||
			this.hooks.optimizeChunksAdvanced.call(this.chunks, this.chunkGroups)
		);
		this.hooks.afterOptimizeChunks.call(this.chunks, this.chunkGroups);

		this.hooks.optimizeTree.callAsync(this.chunks, this.modules, err => {
			if (err) {
				return callback(err);
			}

			this.hooks.afterOptimizeTree.call(this.chunks, this.modules);

			while (
				this.hooks.optimizeChunkModulesBasic.call(this.chunks, this.modules) ||
				this.hooks.optimizeChunkModules.call(this.chunks, this.modules) ||
				this.hooks.optimizeChunkModulesAdvanced.call(this.chunks, this.modules)
			);
			this.hooks.afterOptimizeChunkModules.call(this.chunks, this.modules);

			const shouldRecord = this.hooks.shouldRecord.call() !== false;

			this.hooks.reviveModules.call(this.modules, this.records);
			this.hooks.optimizeModuleOrder.call(this.modules);
			this.hooks.advancedOptimizeModuleOrder.call(this.modules);
			this.hooks.beforeModuleIds.call(this.modules);
			this.hooks.moduleIds.call(this.modules);
			this.applyModuleIds();
			this.hooks.optimizeModuleIds.call(this.modules);
			this.hooks.afterOptimizeModuleIds.call(this.modules);

			this.sortItemsWithModuleIds();

			this.hooks.reviveChunks.call(this.chunks, this.records);
			this.hooks.optimizeChunkOrder.call(this.chunks);
			this.hooks.beforeChunkIds.call(this.chunks);
			this.applyChunkIds();
			this.hooks.optimizeChunkIds.call(this.chunks);
			this.hooks.afterOptimizeChunkIds.call(this.chunks);

			this.sortItemsWithChunkIds();

			if (shouldRecord) {
				this.hooks.recordModules.call(this.modules, this.records);
				this.hooks.recordChunks.call(this.chunks, this.records);
			}

			this.hooks.beforeHash.call();
			this.createHash();
			this.hooks.afterHash.call();

			if (shouldRecord) {
				this.hooks.recordHash.call(this.records);
			}

			this.hooks.beforeModuleAssets.call();
			this.createModuleAssets();
			if (this.hooks.shouldGenerateChunkAssets.call() !== false) {
				this.hooks.beforeChunkAssets.call();
				this.createChunkAssets();
			}
			this.hooks.additionalChunkAssets.call(this.chunks);
			this.summarizeDependencies();
			if (shouldRecord) {
				this.hooks.record.call(this, this.records);
			}

			this.hooks.additionalAssets.callAsync(err => {
				if (err) {
					return callback(err);
				}
				this.hooks.optimizeChunkAssets.callAsync(this.chunks, err => {
					if (err) {
						return callback(err);
					}
					this.hooks.afterOptimizeChunkAssets.call(this.chunks);
					this.hooks.optimizeAssets.callAsync(this.assets, err => {
						if (err) {
							return callback(err);
						}
						this.hooks.afterOptimizeAssets.call(this.assets);
						if (this.hooks.needAdditionalSeal.call()) {
							this.unseal();
							return this.seal(callback);
						}
						return this.hooks.afterSeal.callAsync(callback);
					});
				});
			});
		});
	}

	sortModules(modules) {
		modules.sort(byIndexOrIdentifier);
	}

	reportDependencyErrorsAndWarnings(module, blocks) {
		for (let indexBlock = 0; indexBlock < blocks.length; indexBlock++) {
			const block = blocks[indexBlock];
			const dependencies = block.dependencies;

			for (let indexDep = 0; indexDep < dependencies.length; indexDep++) {
				const d = dependencies[indexDep];

				const warnings = d.getWarnings();
				if (warnings) {
					for (let indexWar = 0; indexWar < warnings.length; indexWar++) {
						const w = warnings[indexWar];

						const warning = new ModuleDependencyWarning(module, w, d.loc);
						this.warnings.push(warning);
					}
				}
				const errors = d.getErrors();
				if (errors) {
					for (let indexErr = 0; indexErr < errors.length; indexErr++) {
						const e = errors[indexErr];

						const error = new ModuleDependencyError(module, e, d.loc);
						this.errors.push(error);
					}
				}
			}

			this.reportDependencyErrorsAndWarnings(module, block.blocks);
		}
	}

	addChunkInGroup(groupOptions, module, loc, request) {
		if (typeof groupOptions == "string") {
			groupOptions = { name: groupOptions };
		}
		const name = groupOptions.name;
		if (name) {
			const chunkGroup = this.namedChunkGroups.get(name);
			if (chunkGroup !== void 0) {
				chunkGroup.addOptions(groupOptions);
				if (module) {
					chunkGroup.addOrigin(module, loc, request);
				}
				return chunkGroup;
			}
		}
		const chunkGroup = new ChunkGroup(groupOptions);
		if (module) chunkGroup.addOrigin(module, loc, request);
		const chunk = this.addChunk(name);

		GraphHelpers.connectChunkGroupAndChunk(chunkGroup, chunk);

		this.chunkGroups.push(chunkGroup);
		if (name) {
			this.namedChunkGroups.set(name, chunkGroup);
		}
		return chunkGroup;
	}

	addChunk(name) {
		if (name) {
			const chunk = this.namedChunks.get(name);
			if (chunk !== void 0) {
				return chunk;
			}
		}
		const chunk = new Chunk(name);
		this.chunks.push(chunk);
		if (name) {
			this.namedChunks.set(name, chunk);
		}
		return chunk;
	}

	assignDepth(module) {
		const queue = new Set([module]);
		let depth;

		module.depth = 0;

		const enqueueJob = module => {
			const d = module.depth;
			if (typeof d == "number" && d <= depth) return;
			queue.add(module);
			module.depth = depth;
		};

		const assignDepthToDependency = dependency => {
			if (dependency.module) {
				enqueueJob(dependency.module);
			}
		};

		const assignDepthToDependencyBlock = block => {
			if (block.variables) {
				iterationBlockVariable(block.variables, assignDepthToDependency);
			}

			if (block.dependencies) {
				iterationOfArrayCallback(block.dependencies, assignDepthToDependency);
			}

			if (block.blocks) {
				iterationOfArrayCallback(block.blocks, assignDepthToDependencyBlock);
			}
		};

		for (module of queue) {
			queue.delete(module);
			depth = module.depth;

			depth++;
			assignDepthToDependencyBlock(module);
		}
	}

	getDependencyReference(module, dependency) {
		if (typeof dependency.getReference != "function") return null;
		const ref = dependency.getReference();
		if (!ref) return null;
		return this.hooks.dependencyReference.call(ref, dependency, module);
	}

	removeReasonsOfDependencyBlock(module, block) {
		const iteratorDependency = d => {
			if (!d.module) {
				return;
			}
			if (d.module.removeReason(module, d)) {
				for (const chunk of d.module.chunksIterable) {
					this.patchChunksAfterReasonRemoval(d.module, chunk);
				}
			}
		};

		if (block.blocks) {
			iterationOfArrayCallback(block.blocks, block =>
				this.removeReasonsOfDependencyBlock(module, block)
			);
		}

		if (block.dependencies) {
			iterationOfArrayCallback(block.dependencies, iteratorDependency);
		}

		if (block.variables) {
			iterationBlockVariable(block.variables, iteratorDependency);
		}
	}

	patchChunksAfterReasonRemoval(module, chunk) {
		if (!module.hasReasons()) {
			this.removeReasonsOfDependencyBlock(module, module);
		}
		if (!module.hasReasonForChunk(chunk)) {
			if (module.removeChunk(chunk)) {
				this.removeChunkFromDependencies(module, chunk);
			}
		}
	}

	removeChunkFromDependencies(block, chunk) {
		const iteratorDependency = d => {
			if (!d.module) {
				return;
			}
			this.patchChunksAfterReasonRemoval(d.module, chunk);
		};

		const blocks = block.blocks;
		for (let indexBlock = 0; indexBlock < blocks.length; indexBlock++) {
			const asyncBlock = blocks[indexBlock];
			const chunks = asyncBlock.chunkGroup.chunks;
			for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
				const iteratedChunk = chunks[indexChunk];
				asyncBlock.chunkGroup.removeChunk(iteratedChunk);
				asyncBlock.chunkGroup.removeParent(iteratedChunk);
				this.removeChunkFromDependencies(block, iteratedChunk);
			}
		}

		if (block.dependencies) {
			iterationOfArrayCallback(block.dependencies, iteratorDependency);
		}

		if (block.variables) {
			iterationBlockVariable(block.variables, iteratorDependency);
		}
	}

	applyModuleIds() {
		const unusedIds = [];
		let nextFreeModuleId = 0;
		const usedIds = new Set();
		if (this.usedModuleIds) {
			for (const id of this.usedModuleIds) {
				usedIds.add(id);
			}
		}

		const modules1 = this.modules;
		for (let indexModule1 = 0; indexModule1 < modules1.length; indexModule1++) {
			const module1 = modules1[indexModule1];
			if (module1.id !== null) {
				usedIds.add(module1.id);
			}
		}

		if (usedIds.size > 0) {
			let usedIdMax = -1;
			for (const usedIdKey of usedIds) {
				if (typeof usedIdKey != "number") {
					continue;
				}

				usedIdMax = Math.max(usedIdMax, usedIdKey);
			}

			let lengthFreeModules = (nextFreeModuleId = usedIdMax + 1);

			while (lengthFreeModules--) {
				if (!usedIds.has(lengthFreeModules)) {
					unusedIds.push(lengthFreeModules);
				}
			}
		}

		const modules2 = this.modules;
		for (let indexModule2 = 0; indexModule2 < modules2.length; indexModule2++) {
			const module2 = modules2[indexModule2];
			if (module2.id === null) {
				if (unusedIds.length > 0) {
					module2.id = unusedIds.pop();
				} else {
					module2.id = nextFreeModuleId++;
				}
			}
		}
	}

	applyChunkIds() {
		const usedIds = new Set();

		if (this.usedChunkIds) {
			for (const id of this.usedChunkIds) {
				if (typeof id != "number") {
					continue;
				}

				usedIds.add(id);
			}
		}

		const chunks = this.chunks;
		for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
			const chunk = chunks[indexChunk];
			const usedIdValue = chunk.id;

			if (typeof usedIdValue != "number") {
				continue;
			}

			usedIds.add(usedIdValue);
		}

		let nextFreeChunkId = -1;
		for (const id of usedIds) {
			nextFreeChunkId = Math.max(nextFreeChunkId, id);
		}
		nextFreeChunkId++;

		const unusedIds = [];
		if (nextFreeChunkId > 0) {
			let index = nextFreeChunkId;
			while (index--) {
				if (!usedIds.has(index)) {
					unusedIds.push(index);
				}
			}
		}

		for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
			const chunk = chunks[indexChunk];
			if (chunk.id === null) {
				if (unusedIds.length > 0) {
					chunk.id = unusedIds.pop();
				} else {
					chunk.id = nextFreeChunkId++;
				}
			}
			if (!chunk.ids) {
				chunk.ids = [chunk.id];
			}
		}
	}

	sortItemsWithModuleIds() {
		this.modules.sort(byIdOrIdentifier);

		const modules = this.modules;
		for (let indexModule = 0; indexModule < modules.length; indexModule++) {
			modules[indexModule].sortItems(false);
		}

		const chunks = this.chunks;
		for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
			chunks[indexChunk].sortItems();
		}

		chunks.sort((a, b) => a.compareTo(b));
	}

	sortItemsWithChunkIds() {
		for (const chunkGroup of this.chunkGroups) {
			chunkGroup.sortItems();
		}

		this.chunks.sort(byId);

		for (
			let indexModule = 0;
			indexModule < this.modules.length;
			indexModule++
		) {
			this.modules[indexModule].sortItems(true);
		}

		const chunks = this.chunks;
		for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
			chunks[indexChunk].sortItems();
		}

		const byMessage = (a, b) => {
			const ma = `${a.message}`;
			const mb = `${b.message}`;
			if (ma < mb) return -1;
			if (mb < ma) return 1;
			return 0;
		};

		this.errors.sort(byMessage);
		this.warnings.sort(byMessage);
		this.children.sort(byNameOrHash);
	}

	summarizeDependencies() {
		this.fileDependencies = new SortableSet(this.compilationDependencies);
		this.contextDependencies = new SortableSet();
		this.missingDependencies = new SortableSet();

		for (
			let indexChildren = 0;
			indexChildren < this.children.length;
			indexChildren++
		) {
			const child = this.children[indexChildren];

			addAllToSet(this.fileDependencies, child.fileDependencies);
			addAllToSet(this.contextDependencies, child.contextDependencies);
			addAllToSet(this.missingDependencies, child.missingDependencies);
		}

		for (
			let indexModule = 0;
			indexModule < this.modules.length;
			indexModule++
		) {
			const module = this.modules[indexModule];

			if (module.buildInfo.fileDependencies) {
				addAllToSet(this.fileDependencies, module.buildInfo.fileDependencies);
			}
			if (module.buildInfo.contextDependencies) {
				addAllToSet(
					this.contextDependencies,
					module.buildInfo.contextDependencies
				);
			}
		}
		for (const error of this.errors) {
			if (
				typeof error.missing == "object" &&
				error.missing &&
				error.missing[Symbol.iterator]
			) {
				addAllToSet(this.missingDependencies, error.missing);
			}
		}
		this.fileDependencies.sort();
		this.contextDependencies.sort();
		this.missingDependencies.sort();
	}

	createHash() {
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		if (outputOptions.hashSalt) {
			hash.update(outputOptions.hashSalt);
		}
		this.mainTemplate.updateHash(hash);
		this.chunkTemplate.updateHash(hash);
		for (const key of Object.keys(this.moduleTemplates).sort()) {
			this.moduleTemplates[key].updateHash(hash);
		}
		for (const child of this.children) {
			hash.update(child.hash);
		}
		for (const warning of this.warnings) {
			hash.update(`${warning.message}`);
		}
		for (const error of this.errors) {
			hash.update(`${error.message}`);
		}
		const modules = this.modules;
		for (let i = 0; i < modules.length; i++) {
			const module = modules[i];
			const moduleHash = createHash(hashFunction);
			module.updateHash(moduleHash);
			module.hash = (moduleHash.digest(hashDigest));
			module.renderedHash = module.hash.substr(0, hashDigestLength);
		}
		const chunks = this.chunks.slice();
		chunks.sort((a, b) => {
			const aEntry = a.hasRuntime();
			const bEntry = b.hasRuntime();
			if (aEntry && !bEntry) return 1;
			if (!aEntry && bEntry) return -1;
			return byId(a, b);
		});
		for (let i = 0; i < chunks.length; i++) {
			const chunk = chunks[i];
			const chunkHash = createHash(hashFunction);
			try {
				if (outputOptions.hashSalt) {
					chunkHash.update(outputOptions.hashSalt);
				}
				chunk.updateHash(chunkHash);
				const template = chunk.hasRuntime()
					? this.mainTemplate
					: this.chunkTemplate;
				template.updateHashForChunk(
					chunkHash,
					chunk,
					this.moduleTemplates.javascript,
					this.dependencyTemplates
				);
				this.hooks.chunkHash.call(chunk, chunkHash);
				chunk.hash = (chunkHash.digest(hashDigest));
				hash.update(chunk.hash);
				chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
				this.hooks.contentHash.call(chunk);
			} catch (err) {
				this.errors.push(new ChunkRenderError(chunk, "", err));
			}
		}
		this.fullHash = (hash.digest(hashDigest));
		this.hash = this.fullHash.substr(0, hashDigestLength);
	}

	modifyHash(update) {
		const outputOptions = this.outputOptions;
		const hashFunction = outputOptions.hashFunction;
		const hashDigest = outputOptions.hashDigest;
		const hashDigestLength = outputOptions.hashDigestLength;
		const hash = createHash(hashFunction);
		hash.update(this.fullHash);
		hash.update(update);
		this.fullHash = (hash.digest(hashDigest));
		this.hash = this.fullHash.substr(0, hashDigestLength);
	}

	emitAsset(file, source, assetInfo = {}) {
		if (this.assets[file]) {
			if (!isSourceEqual(this.assets[file], source)) {
				this.warnings.push(
					new WebpackError(
						`Conflict: Multiple assets emit different content to the same filename ${file}`
					)
				);
				this.assets[file] = source;
				this.assetsInfo.set(file, assetInfo);
				return;
			}
			const oldInfo = this.assetsInfo.get(file);
			this.assetsInfo.set(file, Object.assign({}, oldInfo, assetInfo));
			return;
		}
		this.assets[file] = source;
		this.assetsInfo.set(file, assetInfo);
	}

	updateAsset(
		file,
		newSourceOrFunction,
		assetInfoUpdateOrFunction = void 0
	) {
		if (!this.assets[file]) {
			throw new Error(
				`Called Compilation.updateAsset for not existing filename ${file}`
			);
		}
		if (typeof newSourceOrFunction == "function") {
			this.assets[file] = newSourceOrFunction(this.assets[file]);
		} else {
			this.assets[file] = newSourceOrFunction;
		}
		if (assetInfoUpdateOrFunction !== void 0) {
			const oldInfo = this.assetsInfo.get(file);
			if (typeof assetInfoUpdateOrFunction == "function") {
				this.assetsInfo.set(file, assetInfoUpdateOrFunction(oldInfo || {}));
			} else {
				this.assetsInfo.set(
					file,
					Object.assign({}, oldInfo, assetInfoUpdateOrFunction)
				);
			}
		}
	}

	getAssets() {
		const array = [];
		for (const assetName of Object.keys(this.assets)) {
			if (Object.prototype.hasOwnProperty.call(this.assets, assetName)) {
				array.push({
					name: assetName,
					source: this.assets[assetName],
					info: this.assetsInfo.get(assetName) || {}
				});
			}
		}
		return array;
	}

	getAsset(name) {
		if (!Object.prototype.hasOwnProperty.call(this.assets, name))
			return void 0;
		return {
			name,
			source: this.assets[name],
			info: this.assetsInfo.get(name) || {}
		};
	}

	createModuleAssets() {
		for (let i = 0; i < this.modules.length; i++) {
			const module = this.modules[i];
			if (module.buildInfo.assets) {
				const assetsInfo = module.buildInfo.assetsInfo;
				for (const assetName of Object.keys(module.buildInfo.assets)) {
					const fileName = this.getPath(assetName);
					this.emitAsset(
						fileName,
						module.buildInfo.assets[assetName],
						assetsInfo ? assetsInfo.get(assetName) : void 0
					);
					this.hooks.moduleAsset.call(module, fileName);
				}
			}
		}
	}

	createChunkAssets() {
		const outputOptions = this.outputOptions;
		const cachedSourceMap = new Map();
		const alreadyWrittenFiles = new Map();
		for (let i = 0; i < this.chunks.length; i++) {
			const chunk = this.chunks[i];
			chunk.files = [];
			let source;
			let file;
			let filenameTemplate;
			try {
				const template = chunk.hasRuntime()
					? this.mainTemplate
					: this.chunkTemplate;
				const manifest = template.getRenderManifest({
					chunk,
					hash: this.hash,
					fullHash: this.fullHash,
					outputOptions,
					moduleTemplates: this.moduleTemplates,
					dependencyTemplates: this.dependencyTemplates
				});
				for (const fileManifest of manifest) {
					const cacheName = fileManifest.identifier;
					const usedHash = fileManifest.hash;
					filenameTemplate = fileManifest.filenameTemplate;
					const pathAndInfo = this.getPathWithInfo(
						filenameTemplate,
						fileManifest.pathOptions
					);
					file = pathAndInfo.path;
					const assetInfo = pathAndInfo.info;

					const alreadyWritten = alreadyWrittenFiles.get(file);
					if (alreadyWritten !== void 0) {
						if (alreadyWritten.hash === usedHash) {
							if (this.cache) {
								this.cache[cacheName] = {
									hash: usedHash,
									source: alreadyWritten.source
								};
							}
							chunk.files.push(file);
							this.hooks.chunkAsset.call(chunk, file);
							continue;
						} else {
							throw new Error(
								`Conflict: Multiple chunks emit assets to the same filename ${file} (chunks ${alreadyWritten.chunk.id} and ${chunk.id})`
							);
						}
					}
					if (
						this.cache &&
						this.cache[cacheName] &&
						this.cache[cacheName].hash === usedHash
					) {
						source = this.cache[cacheName].source;
					} else {
						source = fileManifest.render();
						if (!(source instanceof CachedSource)) {
							const cacheEntry = cachedSourceMap.get(source);
							if (cacheEntry) {
								source = cacheEntry;
							} else {
								const cachedSource = new CachedSource(source);
								cachedSourceMap.set(source, cachedSource);
								source = cachedSource;
							}
						}
						if (this.cache) {
							this.cache[cacheName] = {
								hash: usedHash,
								source
							};
						}
					}
					this.emitAsset(file, source, assetInfo);
					chunk.files.push(file);
					this.hooks.chunkAsset.call(chunk, file);
					alreadyWrittenFiles.set(file, {
						hash: usedHash,
						source,
						chunk
					});
				}
			} catch (err) {
				this.errors.push(
					new ChunkRenderError(chunk, file || filenameTemplate, err)
				);
			}
		}
	}

	getPath(filename, data) {
		data = data || {};
		data.hash = data.hash || this.hash;
		return this.mainTemplate.getAssetPath(filename, data);
	}

	getPathWithInfo(filename, data) {
		data = data || {};
		data.hash = data.hash || this.hash;
		return this.mainTemplate.getAssetPathWithInfo(filename, data);
	}

	createChildCompiler(name, outputOptions, plugins) {
		const idx = this.childrenCounters[name] || 0;
		this.childrenCounters[name] = idx + 1;
		return this.compiler.createChildCompiler(
			this,
			name,
			idx,
			outputOptions,
			plugins
		);
	}

	checkConstraints() {
		const usedIds = new Set();

		const modules = this.modules;
		for (let indexModule = 0; indexModule < modules.length; indexModule++) {
			const moduleId = modules[indexModule].id;
			if (moduleId === null) continue;
			if (usedIds.has(moduleId)) {
				throw new Error(`checkConstraints: duplicate module id ${moduleId}`);
			}
			usedIds.add(moduleId);
		}

		const chunks = this.chunks;
		for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
			const chunk = chunks[indexChunk];
			if (chunks.indexOf(chunk) !== indexChunk) {
				throw new Error(
					`checkConstraints: duplicate chunk in compilation ${chunk.debugId}`
				);
			}
		}

		for (const chunkGroup of this.chunkGroups) {
			chunkGroup.checkConstraints();
		}
	}
}

Compilation.prototype.applyPlugins = util.deprecate(
	function(name, ...args) {
		this.hooks[
			name.replace(/[- ]([a-z])/g, match => match[1].toUpperCase())
		].call(...args);
	},
	"Compilation.applyPlugins is deprecated. Use new API on `.hooks` instead"
);

Object.defineProperty(Compilation.prototype, "moduleTemplate", {
	configurable: false,
	get: util.deprecate(
		function() {
			return this.moduleTemplates.javascript;
		},
		"Compilation.moduleTemplate: Use Compilation.moduleTemplates.javascript instead"
	),
	set: util.deprecate(
		function(value) {
			this.moduleTemplates.javascript = value;
		},
		"Compilation.moduleTemplate: Use Compilation.moduleTemplates.javascript instead."
	)
});

module.exports = Compilation;

},
// 154
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);

class EntryModuleNotFoundError extends WebpackError {
	constructor(err) {
		super("Entry module not found: " + err);

		this.name = "EntryModuleNotFoundError";
		this.details = err.details;
		this.error = err;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = EntryModuleNotFoundError;

},
// 155
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);

class ModuleNotFoundError extends WebpackError {
	constructor(module, err) {
		super("Module not found: " + err);

		this.name = "ModuleNotFoundError";
		this.details = err.details;
		this.missing = err.missing;
		this.module = module;
		this.error = err;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = ModuleNotFoundError;

},
// 156
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);

module.exports = class extends WebpackError {
	constructor(module, err, loc) {
		super(err.message);

		this.name = "ModuleDependencyWarning";
		this.details = err.stack
			.split("\n")
			.slice(1)
			.join("\n");
		this.module = module;
		this.loc = loc;
		this.error = err;
		this.origin = module.issuer;

		Error.captureStackTrace(this, this.constructor);
	}
};

},
// 157
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);

class ModuleDependencyError extends WebpackError {
	constructor(module, err, loc) {
		super(err.message);

		this.name = "ModuleDependencyError";
		this.details = err.stack
			.split("\n")
			.slice(1)
			.join("\n");
		this.module = module;
		this.loc = loc;
		this.error = err;
		this.origin = module.issuer;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = ModuleDependencyError;

},
// 158
function(module, exports, __webpack_require__) {

const {
	ConcatSource,
	OriginalSource,
	PrefixSource,
	RawSource
} = __webpack_require__(0);
const {
	Tapable,
	SyncWaterfallHook,
	SyncHook,
	SyncBailHook
} = __webpack_require__(6);
const Template = __webpack_require__(2);

module.exports = class extends Tapable {
	constructor(outputOptions) {
		super();
		this.outputOptions = outputOptions || {};
		this.hooks = {
			renderManifest: new SyncWaterfallHook(["result", "options"]),
			modules: new SyncWaterfallHook([
				"modules",
				"chunk",
				"hash",
				"moduleTemplate",
				"dependencyTemplates"
			]),
			moduleObj: new SyncWaterfallHook([
				"source",
				"chunk",
				"hash",
				"moduleIdExpression"
			]),
			requireEnsure: new SyncWaterfallHook([
				"source",
				"chunk",
				"hash",
				"chunkIdExpression"
			]),
			bootstrap: new SyncWaterfallHook([
				"source",
				"chunk",
				"hash",
				"moduleTemplate",
				"dependencyTemplates"
			]),
			localVars: new SyncWaterfallHook(["source", "chunk", "hash"]),
			require: new SyncWaterfallHook(["source", "chunk", "hash"]),
			requireExtensions: new SyncWaterfallHook(["source", "chunk", "hash"]),
			beforeStartup: new SyncWaterfallHook(["source", "chunk", "hash"]),
			startup: new SyncWaterfallHook(["source", "chunk", "hash"]),
			afterStartup: new SyncWaterfallHook(["source", "chunk", "hash"]),
			render: new SyncWaterfallHook([
				"source",
				"chunk",
				"hash",
				"moduleTemplate",
				"dependencyTemplates"
			]),
			renderWithEntry: new SyncWaterfallHook(["source", "chunk", "hash"]),
			moduleRequire: new SyncWaterfallHook([
				"source",
				"chunk",
				"hash",
				"moduleIdExpression"
			]),
			addModule: new SyncWaterfallHook([
				"source",
				"chunk",
				"hash",
				"moduleIdExpression",
				"moduleExpression"
			]),
			currentHash: new SyncWaterfallHook(["source", "requestedLength"]),
			assetPath: new SyncWaterfallHook(["path", "options", "assetInfo"]),
			hash: new SyncHook(["hash"]),
			hashForChunk: new SyncHook(["hash", "chunk"]),
			globalHashPaths: new SyncWaterfallHook(["paths"]),
			globalHash: new SyncBailHook(["chunk", "paths"]),

			hotBootstrap: new SyncWaterfallHook(["source", "chunk", "hash"])
		};
		this.hooks.startup.tap("MainTemplate", (source, chunk, hash) => {
			const buf = [];
			if (chunk.entryModule) {
				buf.push("// Load entry module and return exports");
				buf.push(
					`return ${this.renderRequireFunctionForModule(
						hash,
						chunk,
						JSON.stringify(chunk.entryModule.id)
					)}(${this.requireFn}.s = ${JSON.stringify(chunk.entryModule.id)});`
				);
			}
			return Template.asString(buf);
		});
		this.hooks.render.tap(
			"MainTemplate",
			(bootstrapSource, chunk, hash, moduleTemplate, dependencyTemplates) => {
				const source = new ConcatSource();
				source.add("/******/ (function(modules) { // webpackBootstrap\n");
				source.add(new PrefixSource("/******/", bootstrapSource));
				source.add("/******/ })\n");
				source.add(
					"/************************************************************************/\n"
				);
				source.add("/******/ (");
				source.add(
					this.hooks.modules.call(
						new RawSource(""),
						chunk,
						hash,
						moduleTemplate,
						dependencyTemplates
					)
				);
				source.add(")");
				return source;
			}
		);
		this.hooks.localVars.tap("MainTemplate", (source, chunk, hash) => {
			return Template.asString([
				source,
				"// The module cache",
				"var installedModules = {};"
			]);
		});
		this.hooks.require.tap("MainTemplate", (source, chunk, hash) => {
			return Template.asString([
				source,
				"// Check if module is in cache",
				"var module = installedModules[moduleId]; if(module) {",
				Template.indent("return module.exports;"),
				"}",
				"// Create a new module (and put it into the cache)",
				"installedModules[moduleId] = module = {",
				Template.indent(this.hooks.moduleObj.call("", chunk, hash, "moduleId")),
				"};",
				"",
				Template.asString(
					outputOptions.strictModuleExceptionHandling
						? [
								"// Execute the module function",
								"var threw = true;",
								"try {",
								Template.indent([
									`modules[moduleId].call(module.exports, module, module.exports, ${this.renderRequireFunctionForModule(
										hash,
										chunk,
										"moduleId"
									)});`,
									"threw = false;"
								]),
								"} finally {",
								Template.indent([
									"if(threw) delete installedModules[moduleId];"
								]),
								"}"
							]
						: [
								"// Execute the module function",
								`modules[moduleId].call(module.exports, module, module.exports, ${this.renderRequireFunctionForModule(
									hash,
									chunk,
									"moduleId"
								)});`
							]
				),
				"",
				"// Flag the module as loaded",
				"module.l = true;",
				"",
				"// Return the exports of the module",
				"return module.exports;"
			]);
		});
		this.hooks.moduleObj.tap(
			"MainTemplate",
			(source, chunk, hash, varModuleId) => {
				return Template.asString(["i: moduleId,", "l: false,", "exports: {}"]);
			}
		);
		this.hooks.requireExtensions.tap("MainTemplate", (source, chunk, hash) => {
			const buf = [];
			const chunkMaps = chunk.getChunkMaps();
			if (Object.keys(chunkMaps.hash).length) {
				buf.push("// This file contains only the entry chunk.");
				buf.push("// The chunk loading function for additional chunks");
				buf.push(`${this.requireFn}.e = function requireEnsure(chunkId) {`);
				buf.push(Template.indent("var promises = [];"));
				buf.push(
					Template.indent(
						this.hooks.requireEnsure.call("", chunk, hash, "chunkId")
					)
				);
				buf.push(Template.indent("return Promise.all(promises);"));
				buf.push("};");
			} else if (
				chunk.hasModuleInGraph(m =>
					m.blocks.some(b => b.chunkGroup && b.chunkGroup.chunks.length > 0)
				)
			) {
				buf.push("// The chunk loading function for additional chunks");
				buf.push("// Since all referenced chunks are already included");
				buf.push("// in this file, this function is empty here.");
				buf.push(`${this.requireFn}.e = function requireEnsure() {`);
				buf.push(Template.indent("return Promise.resolve();"));
				buf.push("};");
			}
			buf.push("");
			buf.push("// expose the modules object (__webpack_modules__)");
			buf.push(`${this.requireFn}.m = modules;`);

			buf.push("");
			buf.push("// expose the module cache");
			buf.push(`${this.requireFn}.c = installedModules;`);

			buf.push("");
			buf.push("// define getter function for harmony exports");
			buf.push(`${this.requireFn}.d = function(exports, name, getter) {`);
			buf.push(
				Template.indent([
					`if(!${this.requireFn}.o(exports, name)) {`,
					Template.indent([
						"Object.defineProperty(exports, name, { enumerable: true, get: getter });"
					]),
					"}"
				])
			);
			buf.push("};");

			buf.push("");
			buf.push("// define __esModule on exports");
			buf.push(`${this.requireFn}.r = function(exports) {`);
			buf.push(
				Template.indent([
					"if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {",
					Template.indent([
						"Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });"
					]),
					"}",
					"Object.defineProperty(exports, '__esModule', { value: true });"
				])
			);
			buf.push("};");

			buf.push("");
			buf.push("// create a fake namespace object");
			buf.push("// mode & 1: value is a module id, require it");
			buf.push("// mode & 2: merge all properties of value into the ns");
			buf.push("// mode & 4: return value when already ns object");
			buf.push("// mode & 8|1: behave like require");
			buf.push(`${this.requireFn}.t = function(value, mode) {`);
			buf.push(
				Template.indent([
					`if(mode & 1) value = ${this.requireFn}(value);`,
					`if(mode & 8) return value;`,
					"if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;",
					"var ns = Object.create(null);",
					this.requireFn + ".r(ns);",
					"Object.defineProperty(ns, 'default', { enumerable: true, value: value });",
					`if(mode & 2 && typeof value != 'string') for(var key in value) ${this.requireFn}.d(ns, key, function(key) { return value[key]; }.bind(null, key));`,
					"return ns;"
				])
			);
			buf.push("};");

			buf.push("");
			buf.push(
				"// getDefaultExport function for compatibility with non-harmony modules"
			);
			buf.push(this.requireFn + ".n = function(module) {");
			buf.push(
				Template.indent([
					"var getter = module && module.__esModule ?",
					Template.indent([
						"function getDefault() { return module['default']; } :",
						"function getModuleExports() { return module; };"
					]),
					`${this.requireFn}.d(getter, 'a', getter);`,
					"return getter;"
				])
			);
			buf.push("};");

			buf.push("");
			buf.push("// Object.prototype.hasOwnProperty.call");
			buf.push(
				`${this.requireFn}.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };`
			);

			const publicPath = this.getPublicPath({
				hash: hash
			});
			buf.push("");
			buf.push("// __webpack_public_path__");
			buf.push(`${this.requireFn}.p = ${JSON.stringify(publicPath)};`);
			return Template.asString(buf);
		});

		this.requireFn = "__webpack_require__";
	}

	getRenderManifest(options) {
		const result = [];

		this.hooks.renderManifest.call(result, options);

		return result;
	}

	renderBootstrap(hash, chunk, moduleTemplate, dependencyTemplates) {
		const buf = [];
		buf.push(
			this.hooks.bootstrap.call(
				"",
				chunk,
				hash,
				moduleTemplate,
				dependencyTemplates
			)
		);
		buf.push(this.hooks.localVars.call("", chunk, hash));
		buf.push("");
		buf.push("// The require function");
		buf.push(`function ${this.requireFn}(moduleId) {`);
		buf.push(Template.indent(this.hooks.require.call("", chunk, hash)));
		buf.push("}");
		buf.push("");
		buf.push(
			Template.asString(this.hooks.requireExtensions.call("", chunk, hash))
		);
		buf.push("");
		buf.push(Template.asString(this.hooks.beforeStartup.call("", chunk, hash)));
		const afterStartupCode = Template.asString(
			this.hooks.afterStartup.call("", chunk, hash)
		);
		if (afterStartupCode) {
			buf.push("var startupResult = (function() {");
		}
		buf.push(Template.asString(this.hooks.startup.call("", chunk, hash)));
		if (afterStartupCode) {
			buf.push("})();");
			buf.push(afterStartupCode);
			buf.push("return startupResult;");
		}
		return buf;
	}

	render(hash, chunk, moduleTemplate, dependencyTemplates) {
		const buf = this.renderBootstrap(
			hash,
			chunk,
			moduleTemplate,
			dependencyTemplates
		);
		let source = this.hooks.render.call(
			new OriginalSource(
				Template.prefix(buf, " \t") + "\n",
				"webpack/bootstrap"
			),
			chunk,
			hash,
			moduleTemplate,
			dependencyTemplates
		);
		if (chunk.hasEntryModule()) {
			source = this.hooks.renderWithEntry.call(source, chunk, hash);
		}
		if (!source) {
			throw new Error(
				"Compiler error: MainTemplate plugin 'render' should return something"
			);
		}
		chunk.rendered = true;
		return new ConcatSource(source, ";");
	}

	renderRequireFunctionForModule(hash, chunk, varModuleId) {
		return this.hooks.moduleRequire.call(
			this.requireFn,
			chunk,
			hash,
			varModuleId
		);
	}

	renderAddModule(hash, chunk, varModuleId, varModule) {
		return this.hooks.addModule.call(
			`modules[${varModuleId}] = ${varModule};`,
			chunk,
			hash,
			varModuleId,
			varModule
		);
	}

	renderCurrentHashCode(hash, length) {
		length = length || Infinity;
		return this.hooks.currentHash.call(
			JSON.stringify(hash.substr(0, length)),
			length
		);
	}

	getPublicPath(options) {
		return this.hooks.assetPath.call(
			this.outputOptions.publicPath || "",
			options
		);
	}

	getAssetPath(path, options) {
		return this.hooks.assetPath.call(path, options);
	}

	getAssetPathWithInfo(path, options) {
		const assetInfo = {};
		const newPath = this.hooks.assetPath.call(path, options, assetInfo);
		return { path: newPath, info: assetInfo };
	}

	updateHash(hash) {
		hash.update("maintemplate");
		hash.update("3");
		this.hooks.hash.call(hash);
	}

	updateHashForChunk(hash, chunk, moduleTemplate, dependencyTemplates) {
		this.updateHash(hash);
		this.hooks.hashForChunk.call(hash, chunk);
		for (const line of this.renderBootstrap(
			"0000",
			chunk,
			moduleTemplate,
			dependencyTemplates
		)) {
			hash.update(line);
		}
	}

	useChunkHash(chunk) {
		const paths = this.hooks.globalHashPaths.call([]);
		return !this.hooks.globalHash.call(chunk, paths);
	}
};

},
// 159
function(module, exports, __webpack_require__) {

const { Tapable, SyncWaterfallHook, SyncHook } = __webpack_require__(6);

module.exports = class extends Tapable {
	constructor(outputOptions) {
		super();
		this.outputOptions = outputOptions || {};
		this.hooks = {
			renderManifest: new SyncWaterfallHook(["result", "options"]),
			modules: new SyncWaterfallHook([
				"source",
				"chunk",
				"moduleTemplate",
				"dependencyTemplates"
			]),
			render: new SyncWaterfallHook([
				"source",
				"chunk",
				"moduleTemplate",
				"dependencyTemplates"
			]),
			renderWithEntry: new SyncWaterfallHook(["source", "chunk"]),
			hash: new SyncHook(["hash"]),
			hashForChunk: new SyncHook(["hash", "chunk"])
		};
	}

	getRenderManifest(options) {
		const result = [];

		this.hooks.renderManifest.call(result, options);

		return result;
	}

	updateHash(hash) {
		hash.update("ChunkTemplate");
		hash.update("2");
		this.hooks.hash.call(hash);
	}

	updateHashForChunk(hash, chunk, moduleTemplate, dependencyTemplates) {
		this.updateHash(hash);
		this.hooks.hashForChunk.call(hash, chunk);
	}
};

},
// 160
function(module, exports, __webpack_require__) {

const Template = __webpack_require__(2);
const HotUpdateChunk = __webpack_require__(75);
const { Tapable, SyncWaterfallHook, SyncHook } = __webpack_require__(6);

module.exports = class extends Tapable {
	constructor(outputOptions) {
		super();
		this.outputOptions = outputOptions || {};
		this.hooks = {
			modules: new SyncWaterfallHook([
				"source",
				"modules",
				"removedModules",
				"moduleTemplate",
				"dependencyTemplates"
			]),
			render: new SyncWaterfallHook([
				"source",
				"modules",
				"removedModules",
				"hash",
				"id",
				"moduleTemplate",
				"dependencyTemplates"
			]),
			hash: new SyncHook(["hash"])
		};
	}

	render(
		id,
		modules,
		removedModules,
		hash,
		moduleTemplate,
		dependencyTemplates
	) {
		const hotUpdateChunk = new HotUpdateChunk();
		hotUpdateChunk.id = id;
		hotUpdateChunk.setModules(modules);
		hotUpdateChunk.removedModules = removedModules;
		const modulesSource = Template.renderChunkModules(
			hotUpdateChunk,
			m => typeof m.source == "function",
			moduleTemplate,
			dependencyTemplates
		);
		const core = this.hooks.modules.call(
			modulesSource,
			modules,
			removedModules,
			moduleTemplate,
			dependencyTemplates
		);
		const source = this.hooks.render.call(
			core,
			modules,
			removedModules,
			hash,
			id,
			moduleTemplate,
			dependencyTemplates
		);
		return source;
	}

	updateHash(hash) {
		hash.update("HotUpdateChunkTemplate");
		hash.update("1");
		this.hooks.hash.call(hash);
	}
};

},
// 161
function(module, exports, __webpack_require__) {

const { Tapable, SyncWaterfallHook, SyncHook } = __webpack_require__(6);

module.exports = class extends Tapable {
	constructor(runtimeTemplate, type) {
		super();
		this.runtimeTemplate = runtimeTemplate;
		this.type = type;
		this.hooks = {
			content: new SyncWaterfallHook([
				"source",
				"module",
				"options",
				"dependencyTemplates"
			]),
			module: new SyncWaterfallHook([
				"source",
				"module",
				"options",
				"dependencyTemplates"
			]),
			render: new SyncWaterfallHook([
				"source",
				"module",
				"options",
				"dependencyTemplates"
			]),
			package: new SyncWaterfallHook([
				"source",
				"module",
				"options",
				"dependencyTemplates"
			]),
			hash: new SyncHook(["hash"])
		};
	}

	render(module, dependencyTemplates, options) {
		try {
			const moduleSource = module.source(
				dependencyTemplates,
				this.runtimeTemplate,
				this.type
			);
			const moduleSourcePostContent = this.hooks.content.call(
				moduleSource,
				module,
				options,
				dependencyTemplates
			);
			const moduleSourcePostModule = this.hooks.module.call(
				moduleSourcePostContent,
				module,
				options,
				dependencyTemplates
			);
			const moduleSourcePostRender = this.hooks.render.call(
				moduleSourcePostModule,
				module,
				options,
				dependencyTemplates
			);
			return this.hooks.package.call(
				moduleSourcePostRender,
				module,
				options,
				dependencyTemplates
			);
		} catch (e) {
			e.message = `${module.identifier()}\n${e.message}`;
			throw e;
		}
	}

	updateHash(hash) {
		hash.update("1");
		this.hooks.hash.call(hash);
	}
};

},
// 162
function(module, exports, __webpack_require__) {

const Template = __webpack_require__(2);

module.exports = class {
	constructor(outputOptions, requestShortener) {
		this.outputOptions = outputOptions || {};
		this.requestShortener = requestShortener;
	}

	comment({ request, chunkName, chunkReason, message, exportName }) {
		let content;
		if (this.outputOptions.pathinfo) {
			content = [message, request, chunkName, chunkReason]
				.filter(Boolean)
				.map(item => this.requestShortener.shorten(item))
				.join(" | ");
		} else {
			content = [message, chunkName, chunkReason]
				.filter(Boolean)
				.map(item => this.requestShortener.shorten(item))
				.join(" | ");
		}
		if (!content) return "";
		if (this.outputOptions.pathinfo) {
			return Template.toComment(content) + " ";
		} else {
			return Template.toNormalComment(content) + " ";
		}
	}

	throwMissingModuleErrorFunction({ request }) {
		const err = `Cannot find module '${request}'`;
		return `function webpackMissingModule() { var e = new Error(${JSON.stringify(
			err
		)}); e.code = 'MODULE_NOT_FOUND'; throw e; }`;
	}

	missingModule({ request }) {
		return `!(${this.throwMissingModuleErrorFunction({ request })}())`;
	}

	missingModuleStatement({ request }) {
		return `${this.missingModule({ request })};\n`;
	}

	missingModulePromise({ request }) {
		return `Promise.resolve().then(${this.throwMissingModuleErrorFunction({
			request
		})})`;
	}

	moduleId({ module, request }) {
		if (!module) {
			return this.missingModule({
				request
			});
		}
		if (module.id === null) {
			throw new Error(
				`RuntimeTemplate.moduleId(): Module ${module.identifier()} has no id. This should not happen.`
			);
		}
		return `${this.comment({ request })}${JSON.stringify(module.id)}`;
	}

	moduleRaw({ module, request }) {
		if (!module) {
			return this.missingModule({
				request
			});
		}
		return `__webpack_require__(${this.moduleId({ module, request })})`;
	}

	moduleExports({ module, request }) {
		return this.moduleRaw({
			module,
			request
		});
	}

	moduleNamespace({ module, request, strict }) {
		if (!module) {
			return this.missingModule({
				request
			});
		}
		const moduleId = this.moduleId({
			module,
			request
		});
		const exportsType = module.buildMeta && module.buildMeta.exportsType;
		if (exportsType === "namespace") {
			const rawModule = this.moduleRaw({
				module,
				request
			});
			return rawModule;
		} else if (exportsType === "named") {
			return `__webpack_require__.t(${moduleId}, 3)`;
		} else if (strict) {
			return `__webpack_require__.t(${moduleId}, 1)`;
		} else {
			return `__webpack_require__.t(${moduleId}, 7)`;
		}
	}

	moduleNamespacePromise({ block, module, request, message, strict, weak }) {
		if (!module) {
			return this.missingModulePromise({
				request
			});
		}
		if (module.id === null) {
			throw new Error(
				`RuntimeTemplate.moduleNamespacePromise(): Module ${module.identifier()} has no id. This should not happen.`
			);
		}
		const promise = this.blockPromise({
			block,
			message
		});

		let getModuleFunction;
		let idExpr = JSON.stringify(module.id);
		const comment = this.comment({
			request
		});
		let header = "";
		if (weak) {
			if (idExpr.length > 8) {
				header += `var id = ${idExpr}; `;
				idExpr = "id";
			}
			header += `if(!__webpack_require__.m[${idExpr}]) { var e = new Error("Module '" + ${idExpr} + "' is not available (weak dependency)"); e.code = 'MODULE_NOT_FOUND'; throw e; } `;
		}
		const moduleId = this.moduleId({
			module,
			request
		});
		const exportsType = module.buildMeta && module.buildMeta.exportsType;
		if (exportsType === "namespace") {
			if (header) {
				const rawModule = this.moduleRaw({
					module,
					request
				});
				getModuleFunction = `function() { ${header}return ${rawModule}; }`;
			} else {
				getModuleFunction = `__webpack_require__.bind(null, ${comment}${idExpr})`;
			}
		} else if (exportsType === "named") {
			if (header) {
				getModuleFunction = `function() { ${header}return __webpack_require__.t(${moduleId}, 3); }`;
			} else {
				getModuleFunction = `__webpack_require__.t.bind(null, ${comment}${idExpr}, 3)`;
			}
		} else if (strict) {
			if (header) {
				getModuleFunction = `function() { ${header}return __webpack_require__.t(${moduleId}, 1); }`;
			} else {
				getModuleFunction = `__webpack_require__.t.bind(null, ${comment}${idExpr}, 1)`;
			}
		} else {
			if (header) {
				getModuleFunction = `function() { ${header}return __webpack_require__.t(${moduleId}, 7); }`;
			} else {
				getModuleFunction = `__webpack_require__.t.bind(null, ${comment}${idExpr}, 7)`;
			}
		}

		return `${promise || "Promise.resolve()"}.then(${getModuleFunction})`;
	}

	importStatement({ update, module, request, importVar, originModule }) {
		if (!module) {
			return this.missingModuleStatement({
				request
			});
		}
		const moduleId = this.moduleId({
			module,
			request
		});
		const optDeclaration = update ? "" : "var ";

		const exportsType = module.buildMeta && module.buildMeta.exportsType;
		let content = `/* harmony import */ ${optDeclaration}${importVar} = __webpack_require__(${moduleId});\n`;

		if (!exportsType && !originModule.buildMeta.strictHarmonyModule) {
			content += `/* harmony import */ ${optDeclaration}${importVar}_default = /*#__PURE__*/__webpack_require__.n(${importVar});\n`;
		}
		if (exportsType === "named") {
			if (Array.isArray(module.buildMeta.providedExports)) {
				content += `${optDeclaration}${importVar}_namespace = /*#__PURE__*/__webpack_require__.t(${moduleId}, 1);\n`;
			} else {
				content += `${optDeclaration}${importVar}_namespace = /*#__PURE__*/__webpack_require__.t(${moduleId});\n`;
			}
		}
		return content;
	}

	exportFromImport({
		module,
		request,
		exportName,
		originModule,
		asiSafe,
		isCall,
		callContext,
		importVar
	}) {
		if (!module) {
			return this.missingModule({
				request
			});
		}
		const exportsType = module.buildMeta && module.buildMeta.exportsType;

		if (!exportsType) {
			if (exportName === "default") {
				if (!originModule.buildMeta.strictHarmonyModule) {
					if (isCall) {
						return `${importVar}_default()`;
					} else if (asiSafe) {
						return `(${importVar}_default())`;
					} else {
						return `${importVar}_default.a`;
					}
				} else {
					return importVar;
				}
			} else if (originModule.buildMeta.strictHarmonyModule) {
				if (exportName) {
					return "/* non-default import from non-esm module */undefined";
				} else {
					return `/*#__PURE__*/__webpack_require__.t(${importVar})`;
				}
			}
		}

		if (exportsType === "named") {
			if (exportName === "default") {
				return importVar;
			} else if (!exportName) {
				return `${importVar}_namespace`;
			}
		}

		if (exportName) {
			const used = module.isUsed(exportName);
			if (!used) {
				const comment = Template.toNormalComment(`unused export ${exportName}`);
				return `${comment} undefined`;
			}
			const comment =
				used !== exportName ? Template.toNormalComment(exportName) + " " : "";
			const access = `${importVar}[${comment}${JSON.stringify(used)}]`;
			if (isCall) {
				if (callContext === false && asiSafe) {
					return `(0,${access})`;
				} else if (callContext === false) {
					return `Object(${access})`;
				}
			}
			return access;
		} else {
			return importVar;
		}
	}

	blockPromise({ block, message }) {
		if (!block || !block.chunkGroup || block.chunkGroup.chunks.length === 0) {
			const comment = this.comment({
				message
			});
			return `Promise.resolve(${comment.trim()})`;
		}
		const chunks = block.chunkGroup.chunks.filter(
			chunk => !chunk.hasRuntime() && chunk.id !== null
		);
		const comment = this.comment({
			message,
			chunkName: block.chunkName,
			chunkReason: block.chunkReason
		});
		if (chunks.length === 1) {
			const chunkId = JSON.stringify(chunks[0].id);
			return `__webpack_require__.e(${comment}${chunkId})`;
		} else if (chunks.length > 0) {
			const requireChunkId = chunk =>
				`__webpack_require__.e(${JSON.stringify(chunk.id)})`;
			return `Promise.all(${comment.trim()}[${chunks
				.map(requireChunkId)
				.join(", ")}])`;
		} else {
			return `Promise.resolve(${comment.trim()})`;
		}
	}

	onError() {
		return "__webpack_require__.oe";
	}

	defineEsModuleFlagStatement({ exportsArgument }) {
		return `__webpack_require__.r(${exportsArgument});\n`;
	}
};

},
// 163
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);

class ChunkRenderError extends WebpackError {
	constructor(chunk, file, error) {
		super();

		this.name = "ChunkRenderError";
		this.error = error;
		this.message = error.message;
		this.details = error.stack;
		this.file = file;
		this.chunk = chunk;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = ChunkRenderError;

},
// 164
function(module, exports, __webpack_require__) {

const formatPosition = pos => {
	if (pos === null) return "";
	if (typeof pos == "string") return pos;
	if (typeof pos == "number") return `${pos}`;
	if (typeof pos == "object") {
		if ("line" in pos && "column" in pos) {
			return `${pos.line}:${pos.column}`;
		} else if ("line" in pos) {
			return `${pos.line}:?`;
		} else if ("index" in pos) {
			return `+${pos.index}`;
		} else {
			return "";
		}
	}
	return "";
};

const formatLocation = loc => {
	if (loc === null) return "";
	if (typeof loc == "string") return loc;
	if (typeof loc == "number") return `${loc}`;
	if (typeof loc == "object") {
		if ("start" in loc && loc.start && "end" in loc && loc.end) {
			if (
				typeof loc.start == "object" &&
				typeof loc.start.line == "number" &&
				typeof loc.end == "object" &&
				typeof loc.end.line == "number" &&
				typeof loc.end.column == "number" &&
				loc.start.line === loc.end.line
			) {
				return `${formatPosition(loc.start)}-${loc.end.column}`;
			} else {
				return `${formatPosition(loc.start)}-${formatPosition(loc.end)}`;
			}
		}
		if ("start" in loc && loc.start) {
			return formatPosition(loc.start);
		}
		if ("name" in loc && "index" in loc) {
			return `${loc.name}[${loc.index}]`;
		}
		if ("name" in loc) {
			return loc.name;
		}
		return formatPosition(loc);
	}
	return "";
};

module.exports = formatLocation;

},
// 165
function(module, exports, __webpack_require__) {

class Semaphore {
	constructor(available) {
		this.available = available;
		this.waiters = [];
		this._continue = this._continue.bind(this);
	}

	acquire(callback) {
		if (this.available > 0) {
			this.available--;
			callback();
		} else {
			this.waiters.push(callback);
		}
	}

	release() {
		this.available++;
		if (this.waiters.length > 0) {
			process.nextTick(this._continue);
		}
	}

	_continue() {
		if (this.available > 0) {
			if (this.waiters.length > 0) {
				this.available--;
				const callback = this.waiters.pop();
				callback();
			}
		}
	}
}

module.exports = Semaphore;

},
// 166
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);
const CURRENT_METHOD_REGEXP = /at ([a-zA-Z0-9_.]*)/;

function createMessage(method) {
	return `Abstract method${method ? " " + method : ""}. Must be overridden.`;
}

function Message() {
	this.stack = void 0;
	Error.captureStackTrace(this);
	const match = this.stack.split("\n")[3].match(CURRENT_METHOD_REGEXP);

	this.message = match && match[1] ? createMessage(match[1]) : createMessage();
}

class AbstractMethodError extends WebpackError {
	constructor() {
		super(new Message().message);
		this.name = "AbstractMethodError";
	}
}

module.exports = AbstractMethodError;

},
// 167
function(module, exports, __webpack_require__) {

const AsyncDependencyToInitialChunkError = __webpack_require__(168);
const GraphHelpers = __webpack_require__(22);

const bySetSize = (a, b) => {
	return b.size - a.size;
};

const extraceBlockInfoMap = compilation => {
	const blockInfoMap = new Map();

	const iteratorDependency = d => {
		const ref = compilation.getDependencyReference(currentModule, d);
		if (!ref) {
			return;
		}
		const refModule = ref.module;
		if (!refModule) {
			return;
		}
		if (ref.weak) {
			return;
		}

		blockInfoModules.add(refModule);
	};

	const iteratorBlockPrepare = b => {
		blockInfoBlocks.push(b);
		blockQueue.push(b);
	};

	let currentModule;
	let block;
	let blockQueue;
	let blockInfoModules;
	let blockInfoBlocks;

	for (const module of compilation.modules) {
		blockQueue = [module];
		currentModule = module;
		while (blockQueue.length > 0) {
			block = blockQueue.pop();
			blockInfoModules = new Set();
			blockInfoBlocks = [];

			if (block.variables) {
				for (const variable of block.variables) {
					for (const dep of variable.dependencies) iteratorDependency(dep);
				}
			}

			if (block.dependencies) {
				for (const dep of block.dependencies) iteratorDependency(dep);
			}

			if (block.blocks) {
				for (const b of block.blocks) iteratorBlockPrepare(b);
			}

			const blockInfo = {
				modules: blockInfoModules,
				blocks: blockInfoBlocks
			};
			blockInfoMap.set(block, blockInfo);
		}
	}

	return blockInfoMap;
};

const visitModules = (
	compilation,
	inputChunkGroups,
	chunkGroupInfoMap,
	blockConnections,
	blocksWithNestedBlocks,
	allCreatedChunkGroups
) => {
	const logger = compilation.getLogger("webpack.buildChunkGraph.visitModules");
	const { namedChunkGroups } = compilation;

	logger.time("prepare");
	const blockInfoMap = extraceBlockInfoMap(compilation);

	const chunkGroupCounters = new Map();
	for (const chunkGroup of inputChunkGroups) {
		chunkGroupCounters.set(chunkGroup, {
			index: 0,
			index2: 0
		});
	}

	let nextFreeModuleIndex = 0;
	let nextFreeModuleIndex2 = 0;

	const blockChunkGroups = new Map();

	const ADD_AND_ENTER_MODULE = 0;
	const ENTER_MODULE = 1;
	const PROCESS_BLOCK = 2;
	const LEAVE_MODULE = 3;

	const reduceChunkGroupToQueueItem = (queue, chunkGroup) => {
		for (const chunk of chunkGroup.chunks) {
			const module = chunk.entryModule;
			queue.push({
				action: ENTER_MODULE,
				block: module,
				module,
				chunk,
				chunkGroup
			});
		}
		chunkGroupInfoMap.set(chunkGroup, {
			chunkGroup,
			minAvailableModules: new Set(),
			minAvailableModulesOwned: true,
			availableModulesToBeMerged: [],
			skippedItems: [],
			resultingAvailableModules: void 0,
			children: void 0
		});
		return queue;
	};

	let queue = inputChunkGroups
		.reduce(reduceChunkGroupToQueueItem, [])
		.reverse();
	const queueConnect = new Map();
	const outdatedChunkGroupInfo = new Set();
	let queueDelayed = [];

	logger.timeEnd("prepare");

	let module;
	let chunk;
	let chunkGroup;
	let chunkGroupInfo;
	let block;
	let minAvailableModules;
	let skippedItems;

	const iteratorBlock = b => {
		let c = blockChunkGroups.get(b);
		if (c === void 0) {
			c = namedChunkGroups.get(b.chunkName);
			if (c && c.isInitial()) {
				compilation.errors.push(
					new AsyncDependencyToInitialChunkError(b.chunkName, module, b.loc)
				);
				c = chunkGroup;
			} else {
				c = compilation.addChunkInGroup(
					b.groupOptions || b.chunkName,
					module,
					b.loc,
					b.request
				);
				chunkGroupCounters.set(c, { index: 0, index2: 0 });
				blockChunkGroups.set(b, c);
				allCreatedChunkGroups.add(c);
			}
			blockConnections.set(b, []);
		} else {
			if (c.addOptions) c.addOptions(b.groupOptions);
			c.addOrigin(module, b.loc, b.request);
		}

		blockConnections.get(b).push({
			originChunkGroupInfo: chunkGroupInfo,
			chunkGroup: c
		});

		let connectList = queueConnect.get(chunkGroup);
		if (connectList === void 0) {
			connectList = new Set();
			queueConnect.set(chunkGroup, connectList);
		}
		connectList.add(c);

		queueDelayed.push({
			action: PROCESS_BLOCK,
			block: b,
			module: module,
			chunk: c.chunks[0],
			chunkGroup: c
		});
	};

	while (queue.length) {
		logger.time("visiting");
		while (queue.length) {
			const queueItem = queue.pop();
			module = queueItem.module;
			block = queueItem.block;
			chunk = queueItem.chunk;
			if (chunkGroup !== queueItem.chunkGroup) {
				chunkGroup = queueItem.chunkGroup;
				chunkGroupInfo = chunkGroupInfoMap.get(chunkGroup);
				minAvailableModules = chunkGroupInfo.minAvailableModules;
				skippedItems = chunkGroupInfo.skippedItems;
			}

			switch (queueItem.action) {
				case ADD_AND_ENTER_MODULE: {
					if (minAvailableModules.has(module)) {
						skippedItems.push(queueItem);
						break;
					}
					if (chunk.addModule(module)) {
						module.addChunk(chunk);
					} else {
						break;
					}
				}
				case ENTER_MODULE: {
					if (chunkGroup !== void 0) {
						const index = chunkGroup.getModuleIndex(module);
						if (index === void 0) {
							chunkGroup.setModuleIndex(
								module,
								chunkGroupCounters.get(chunkGroup).index++
							);
						}
					}

					if (module.index === null) {
						module.index = nextFreeModuleIndex++;
					}

					queue.push({
						action: LEAVE_MODULE,
						block,
						module,
						chunk,
						chunkGroup
					});
				}
				case PROCESS_BLOCK: {
					const blockInfo = blockInfoMap.get(block);

					const skipBuffer = [];
					const queueBuffer = [];
					for (const refModule of blockInfo.modules) {
						if (chunk.containsModule(refModule)) {
							continue;
						}
						if (minAvailableModules.has(refModule)) {
							skipBuffer.push({
								action: ADD_AND_ENTER_MODULE,
								block: refModule,
								module: refModule,
								chunk,
								chunkGroup
							});
							continue;
						}
						queueBuffer.push({
							action: ADD_AND_ENTER_MODULE,
							block: refModule,
							module: refModule,
							chunk,
							chunkGroup
						});
					}
					for (let i = skipBuffer.length - 1; i >= 0; i--) {
						skippedItems.push(skipBuffer[i]);
					}
					for (let i = queueBuffer.length - 1; i >= 0; i--) {
						queue.push(queueBuffer[i]);
					}

					for (const block of blockInfo.blocks) iteratorBlock(block);

					if (blockInfo.blocks.length > 0 && module !== block) {
						blocksWithNestedBlocks.add(block);
					}
					break;
				}
				case LEAVE_MODULE: {
					if (chunkGroup !== void 0) {
						const index = chunkGroup.getModuleIndex2(module);
						if (index === void 0) {
							chunkGroup.setModuleIndex2(
								module,
								chunkGroupCounters.get(chunkGroup).index2++
							);
						}
					}

					if (module.index2 === null) {
						module.index2 = nextFreeModuleIndex2++;
					}
					break;
				}
			}
		}
		logger.timeEnd("visiting");

		while (queueConnect.size > 0) {
			logger.time("calculating available modules");

			for (const [chunkGroup, targets] of queueConnect) {
				const info = chunkGroupInfoMap.get(chunkGroup);
				let minAvailableModules = info.minAvailableModules;

				const resultingAvailableModules = new Set(minAvailableModules);
				for (const chunk of chunkGroup.chunks) {
					for (const m of chunk.modulesIterable) {
						resultingAvailableModules.add(m);
					}
				}
				info.resultingAvailableModules = resultingAvailableModules;
				if (info.children === void 0) {
					info.children = targets;
				} else {
					for (const target of targets) {
						info.children.add(target);
					}
				}

				for (const target of targets) {
					let chunkGroupInfo = chunkGroupInfoMap.get(target);
					if (chunkGroupInfo === void 0) {
						chunkGroupInfo = {
							chunkGroup: target,
							minAvailableModules: void 0,
							minAvailableModulesOwned: void 0,
							availableModulesToBeMerged: [],
							skippedItems: [],
							resultingAvailableModules: void 0,
							children: void 0
						};
						chunkGroupInfoMap.set(target, chunkGroupInfo);
					}
					chunkGroupInfo.availableModulesToBeMerged.push(
						resultingAvailableModules
					);
					outdatedChunkGroupInfo.add(chunkGroupInfo);
				}
			}
			queueConnect.clear();
			logger.timeEnd("calculating available modules");

			if (outdatedChunkGroupInfo.size > 0) {
				logger.time("merging available modules");
				for (const info of outdatedChunkGroupInfo) {
					const availableModulesToBeMerged = info.availableModulesToBeMerged;
					let cachedMinAvailableModules = info.minAvailableModules;

					if (availableModulesToBeMerged.length > 1) {
						availableModulesToBeMerged.sort(bySetSize);
					}
					let changed = false;
					for (const availableModules of availableModulesToBeMerged) {
						if (cachedMinAvailableModules === void 0) {
							cachedMinAvailableModules = availableModules;
							info.minAvailableModules = cachedMinAvailableModules;
							info.minAvailableModulesOwned = false;
							changed = true;
						} else {
							if (info.minAvailableModulesOwned) {
								for (const m of cachedMinAvailableModules) {
									if (!availableModules.has(m)) {
										cachedMinAvailableModules.delete(m);
										changed = true;
									}
								}
							} else {
								for (const m of cachedMinAvailableModules) {
									if (!availableModules.has(m)) {
										const newSet = new Set();
										const iterator = cachedMinAvailableModules[
											Symbol.iterator
										]();
										let it;
										while (!(it = iterator.next()).done) {
											const module = it.value;
											if (module === m) break;
											newSet.add(module);
										}
										while (!(it = iterator.next()).done) {
											const module = it.value;
											if (availableModules.has(module)) {
												newSet.add(module);
											}
										}
										cachedMinAvailableModules = newSet;
										info.minAvailableModulesOwned = true;
										info.minAvailableModules = newSet;

										if (chunkGroup === info.chunkGroup) {
											minAvailableModules = cachedMinAvailableModules;
										}

										changed = true;
										break;
									}
								}
							}
						}
					}
					availableModulesToBeMerged.length = 0;
					if (!changed) continue;

					for (const queueItem of info.skippedItems) {
						queue.push(queueItem);
					}
					info.skippedItems.length = 0;

					if (info.children !== void 0) {
						const chunkGroup = info.chunkGroup;
						for (const c of info.children) {
							let connectList = queueConnect.get(chunkGroup);
							if (connectList === void 0) {
								connectList = new Set();
								queueConnect.set(chunkGroup, connectList);
							}
							connectList.add(c);
						}
					}
				}
				outdatedChunkGroupInfo.clear();
				logger.timeEnd("merging available modules");
			}
		}

		if (queue.length === 0) {
			const tempQueue = queue;
			queue = queueDelayed.reverse();
			queueDelayed = tempQueue;
		}
	}
};

const connectChunkGroups = (
	blocksWithNestedBlocks,
	blockConnections,
	chunkGroupInfoMap
) => {
	const areModulesAvailable = (chunkGroup, availableModules) => {
		for (const chunk of chunkGroup.chunks) {
			for (const module of chunk.modulesIterable) {
				if (!availableModules.has(module)) return false;
			}
		}
		return true;
	};

	for (const [block, connections] of blockConnections) {
		if (
			!blocksWithNestedBlocks.has(block) &&
			connections.every(({ chunkGroup, originChunkGroupInfo }) =>
				areModulesAvailable(
					chunkGroup,
					originChunkGroupInfo.resultingAvailableModules
				)
			)
		) {
			continue;
		}

		for (let i = 0; i < connections.length; i++) {
			const { chunkGroup, originChunkGroupInfo } = connections[i];

			GraphHelpers.connectDependenciesBlockAndChunkGroup(block, chunkGroup);

			GraphHelpers.connectChunkGroupParentAndChild(
				originChunkGroupInfo.chunkGroup,
				chunkGroup
			);
		}
	}
};

const cleanupUnconnectedGroups = (compilation, allCreatedChunkGroups) => {
	for (const chunkGroup of allCreatedChunkGroups) {
		if (chunkGroup.getNumberOfParents() === 0) {
			for (const chunk of chunkGroup.chunks) {
				const idx = compilation.chunks.indexOf(chunk);
				if (idx >= 0) compilation.chunks.splice(idx, 1);
				chunk.remove("unconnected");
			}
			chunkGroup.remove("unconnected");
		}
	}
};

const buildChunkGraph = (compilation, inputChunkGroups) => {

	const blockConnections = new Map();

	const allCreatedChunkGroups = new Set();

	const chunkGroupInfoMap = new Map();

	const blocksWithNestedBlocks = new Set();

	visitModules(
		compilation,
		inputChunkGroups,
		chunkGroupInfoMap,
		blockConnections,
		blocksWithNestedBlocks,
		allCreatedChunkGroups
	);

	connectChunkGroups(
		blocksWithNestedBlocks,
		blockConnections,
		chunkGroupInfoMap
	);

	cleanupUnconnectedGroups(compilation, allCreatedChunkGroups);
};

module.exports = buildChunkGraph;

},
// 168
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);

class AsyncDependencyToInitialChunkError extends WebpackError {
	constructor(chunkName, module, loc) {
		super(
			`It's not allowed to load an initial chunk on demand. The chunk name "${chunkName}" is already used by an entrypoint.`
		);

		this.name = "AsyncDependencyToInitialChunkError";
		this.module = module;
		this.loc = loc;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = AsyncDependencyToInitialChunkError;

},
// 169
function(module, exports, __webpack_require__) {

const Stats = __webpack_require__(23);

class Watching {
	constructor(compiler, watchOptions, handler) {
		this.startTime = null;
		this.invalid = false;
		this.handler = handler;
		this.callbacks = [];
		this.closed = false;
		this.suspended = false;
		if (typeof watchOptions == "number") {
			this.watchOptions = {
				aggregateTimeout: watchOptions
			};
		} else if (watchOptions && typeof watchOptions == "object") {
			this.watchOptions = Object.assign({}, watchOptions);
		} else {
			this.watchOptions = {};
		}
		this.watchOptions.aggregateTimeout =
			this.watchOptions.aggregateTimeout || 200;
		this.compiler = compiler;
		this.running = true;
		this.compiler.readRecords(err => {
			if (err) return this._done(err);

			this._go();
		});
	}

	_go() {
		this.startTime = Date.now();
		this.running = true;
		this.invalid = false;
		this.compiler.hooks.watchRun.callAsync(this.compiler, err => {
			if (err) return this._done(err);
			const onCompiled = (err, compilation) => {
				if (err) return this._done(err);
				if (this.invalid) return this._done();

				if (this.compiler.hooks.shouldEmit.call(compilation) === false) {
					return this._done(null, compilation);
				}

				this.compiler.emitAssets(compilation, err => {
					if (err) return this._done(err);
					if (this.invalid) return this._done();
					this.compiler.emitRecords(err => {
						if (err) return this._done(err);

						if (compilation.hooks.needAdditionalPass.call()) {
							compilation.needAdditionalPass = true;

							const stats = new Stats(compilation);
							stats.startTime = this.startTime;
							stats.endTime = Date.now();
							this.compiler.hooks.done.callAsync(stats, err => {
								if (err) return this._done(err);

								this.compiler.hooks.additionalPass.callAsync(err => {
									if (err) return this._done(err);
									this.compiler.compile(onCompiled);
								});
							});
							return;
						}
						return this._done(null, compilation);
					});
				});
			};
			this.compiler.compile(onCompiled);
		});
	}

	_getStats(compilation) {
		const stats = new Stats(compilation);
		stats.startTime = this.startTime;
		stats.endTime = Date.now();
		return stats;
	}

	_done(err, compilation) {
		this.running = false;
		if (this.invalid) return this._go();

		const stats = compilation ? this._getStats(compilation) : null;
		if (err) {
			this.compiler.hooks.failed.call(err);
			this.handler(err, stats);
			return;
		}
		this.compiler.hooks.done.callAsync(stats, () => {
			this.handler(null, stats);
			if (!this.closed) {
				this.watch(
					Array.from(compilation.fileDependencies),
					Array.from(compilation.contextDependencies),
					Array.from(compilation.missingDependencies)
				);
			}
			for (const cb of this.callbacks) cb();
			this.callbacks.length = 0;
		});
	}

	watch(files, dirs, missing) {
		this.pausedWatcher = null;
		this.watcher = this.compiler.watchFileSystem.watch(
			files,
			dirs,
			missing,
			this.startTime,
			this.watchOptions,
			(
				err,
				filesModified,
				contextModified,
				missingModified,
				fileTimestamps,
				contextTimestamps,
				removedFiles
			) => {
				this.pausedWatcher = this.watcher;
				this.watcher = null;
				if (err) {
					return this.handler(err);
				}
				this.compiler.fileTimestamps = fileTimestamps;
				this.compiler.contextTimestamps = contextTimestamps;
				this.compiler.removedFiles = removedFiles;
				if (!this.suspended) {
					this._invalidate();
				}
			},
			(fileName, changeTime) => {
				this.compiler.hooks.invalid.call(fileName, changeTime);
			}
		);
	}

	invalidate(callback) {
		if (callback) {
			this.callbacks.push(callback);
		}
		if (this.watcher) {
			this.compiler.fileTimestamps = this.watcher.getFileTimestamps();
			this.compiler.contextTimestamps = this.watcher.getContextTimestamps();
		}
		return this._invalidate();
	}

	_invalidate() {
		if (this.watcher) {
			this.pausedWatcher = this.watcher;
			this.watcher.pause();
			this.watcher = null;
		}

		if (this.running) {
			this.invalid = true;
			return false;
		} else {
			this._go();
		}
	}

	suspend() {
		this.suspended = true;
		this.invalid = false;
	}

	resume() {
		if (this.suspended) {
			this.suspended = false;
			this._invalidate();
		}
	}

	close(callback) {
		const finalCallback = () => {
			this.compiler.hooks.watchClose.call();
			this.compiler.running = false;
			this.compiler.watchMode = false;
			if (callback !== void 0) callback();
		};

		this.closed = true;
		if (this.watcher) {
			this.watcher.close();
			this.watcher = null;
		}
		if (this.pausedWatcher) {
			this.pausedWatcher.close();
			this.pausedWatcher = null;
		}
		if (this.running) {
			this.invalid = true;
			this._done = finalCallback;
		} else {
			finalCallback();
		}
	}
}

module.exports = Watching;

},
// 170
function(module, exports, __webpack_require__) {

const path = __webpack_require__(3);
const asyncLib = __webpack_require__(12);
const {
	Tapable,
	AsyncSeriesWaterfallHook,
	SyncWaterfallHook,
	SyncBailHook,
	SyncHook,
	HookMap
} = __webpack_require__(6);
const NormalModule = __webpack_require__(54);
const RawModule = __webpack_require__(180);
const RuleSet = __webpack_require__(181);
const { cachedCleverMerge } = __webpack_require__(55);

const EMPTY_RESOLVE_OPTIONS = {};

const MATCH_RESOURCE_REGEX = /^([^!]+)!=!/;

const loaderToIdent = data => {
	if (!data.options) {
		return data.loader;
	}
	if (typeof data.options == "string") {
		return data.loader + "?" + data.options;
	}
	if (typeof data.options != "object") {
		throw new Error("loader options must be string or object");
	}
	if (data.ident) {
		return data.loader + "??" + data.ident;
	}
	return data.loader + "?" + JSON.stringify(data.options);
};

const identToLoaderRequest = resultString => {
	const idx = resultString.indexOf("?");
	if (idx >= 0) {
		const loader = resultString.substr(0, idx);
		const options = resultString.substr(idx + 1);
		return {
			loader,
			options
		};
	} else {
		return {
			loader: resultString,
			options: void 0
		};
	}
};

const dependencyCache = new WeakMap();

class NormalModuleFactory extends Tapable {
	constructor(context, resolverFactory, options) {
		super();
		this.hooks = {
			resolver: new SyncWaterfallHook(["resolver"]),
			factory: new SyncWaterfallHook(["factory"]),
			beforeResolve: new AsyncSeriesWaterfallHook(["data"]),
			afterResolve: new AsyncSeriesWaterfallHook(["data"]),
			createModule: new SyncBailHook(["data"]),
			module: new SyncWaterfallHook(["module", "data"]),
			createParser: new HookMap(() => new SyncBailHook(["parserOptions"])),
			parser: new HookMap(() => new SyncHook(["parser", "parserOptions"])),
			createGenerator: new HookMap(
				() => new SyncBailHook(["generatorOptions"])
			),
			generator: new HookMap(
				() => new SyncHook(["generator", "generatorOptions"])
			)
		};
		this._pluginCompat.tap("NormalModuleFactory", options => {
			switch (options.name) {
				case "before-resolve":
				case "after-resolve":
					options.async = true;
					break;
				case "parser":
					this.hooks.parser
						.for("javascript/auto")
						.tap(options.fn.name || "unnamed compat plugin", options.fn);
					return true;
			}
			let match;
			match = /^parser (.+)$/.exec(options.name);
			if (match) {
				this.hooks.parser
					.for(match[1])
					.tap(
						options.fn.name || "unnamed compat plugin",
						options.fn.bind(this)
					);
				return true;
			}
			match = /^create-parser (.+)$/.exec(options.name);
			if (match) {
				this.hooks.createParser
					.for(match[1])
					.tap(
						options.fn.name || "unnamed compat plugin",
						options.fn.bind(this)
					);
				return true;
			}
		});
		this.resolverFactory = resolverFactory;
		this.ruleSet = new RuleSet(options.defaultRules.concat(options.rules));
		this.cachePredicate =
			typeof options.unsafeCache == "function"
				? options.unsafeCache
				: Boolean.bind(null, options.unsafeCache);
		this.context = context || "";
		this.parserCache = Object.create(null);
		this.generatorCache = Object.create(null);
		this.hooks.factory.tap("NormalModuleFactory", () => (result, callback) => {
			let resolver = this.hooks.resolver.call(null);

			if (!resolver) return callback();

			resolver(result, (err, data) => {
				if (err) return callback(err);

				if (!data) return callback();

				if (typeof data.source == "function") return callback(null, data);

				this.hooks.afterResolve.callAsync(data, (err, result) => {
					if (err) return callback(err);

					if (!result) return callback();

					let createdModule = this.hooks.createModule.call(result);
					if (!createdModule) {
						if (!result.request) {
							return callback(new Error("Empty dependency (no request)"));
						}

						createdModule = new NormalModule(result);
					}

					createdModule = this.hooks.module.call(createdModule, result);

					return callback(null, createdModule);
				});
			});
		});
		this.hooks.resolver.tap("NormalModuleFactory", () => (data, callback) => {
			const contextInfo = data.contextInfo;
			const context = data.context;
			const request = data.request;

			const loaderResolver = this.getResolver("loader");
			const normalResolver = this.getResolver("normal", data.resolveOptions);

			let matchResource = void 0;
			let requestWithoutMatchResource = request;
			const matchResourceMatch = MATCH_RESOURCE_REGEX.exec(request);
			if (matchResourceMatch) {
				matchResource = matchResourceMatch[1];
				if (/^\.\.?\//.test(matchResource)) {
					matchResource = path.join(context, matchResource);
				}
				requestWithoutMatchResource = request.substr(
					matchResourceMatch[0].length
				);
			}

			const noPreAutoLoaders = requestWithoutMatchResource.startsWith("-!");
			const noAutoLoaders =
				noPreAutoLoaders || requestWithoutMatchResource.startsWith("!");
			const noPrePostAutoLoaders = requestWithoutMatchResource.startsWith("!!");
			let elements = requestWithoutMatchResource
				.replace(/^-?!+/, "")
				.replace(/!!+/g, "!")
				.split("!");
			let resource = elements.pop();
			elements = elements.map(identToLoaderRequest);

			asyncLib.parallel(
				[
					callback =>
						this.resolveRequestArray(
							contextInfo,
							context,
							elements,
							loaderResolver,
							callback
						),
					callback => {
						if (resource === "" || resource[0] === "?") {
							return callback(null, {
								resource
							});
						}

						normalResolver.resolve(
							contextInfo,
							context,
							resource,
							{},
							(err, resource, resourceResolveData) => {
								if (err) return callback(err);
								callback(null, {
									resourceResolveData,
									resource
								});
							}
						);
					}
				],
				(err, results) => {
					if (err) return callback(err);
					let loaders = results[0];
					const resourceResolveData = results[1].resourceResolveData;
					resource = results[1].resource;

					try {
						for (const item of loaders) {
							if (typeof item.options == "string" && item.options[0] === "?") {
								const ident = item.options.substr(1);
								item.options = this.ruleSet.findOptionsByIdent(ident);
								item.ident = ident;
							}
						}
					} catch (e) {
						return callback(e);
					}

					if (resource === false) {
						return callback(
							null,
							new RawModule(
								"/* (ignored) */",
								`ignored ${context} ${request}`,
								`${request} (ignored)`
							)
						);
					}

					const userRequest =
						(matchResource !== void 0 ? `${matchResource}!=!` : "") +
						loaders
							.map(loaderToIdent)
							.concat([resource])
							.join("!");

					let resourcePath =
						matchResource !== void 0 ? matchResource : resource;
					let resourceQuery = "";
					const queryIndex = resourcePath.indexOf("?");
					if (queryIndex >= 0) {
						resourceQuery = resourcePath.substr(queryIndex);
						resourcePath = resourcePath.substr(0, queryIndex);
					}

					const result = this.ruleSet.exec({
						resource: resourcePath,
						realResource:
							matchResource !== void 0
								? resource.replace(/\?.*/, "")
								: resourcePath,
						resourceQuery,
						issuer: contextInfo.issuer,
						compiler: contextInfo.compiler
					});
					const settings = {};
					const useLoadersPost = [];
					const useLoaders = [];
					const useLoadersPre = [];
					for (const r of result) {
						if (r.type === "use") {
							if (r.enforce === "post" && !noPrePostAutoLoaders) {
								useLoadersPost.push(r.value);
							} else if (
								r.enforce === "pre" &&
								!noPreAutoLoaders &&
								!noPrePostAutoLoaders
							) {
								useLoadersPre.push(r.value);
							} else if (
								!r.enforce &&
								!noAutoLoaders &&
								!noPrePostAutoLoaders
							) {
								useLoaders.push(r.value);
							}
						} else if (
							typeof r.value == "object" &&
							r.value !== null &&
							typeof settings[r.type] == "object" &&
							settings[r.type] !== null
						) {
							settings[r.type] = cachedCleverMerge(settings[r.type], r.value);
						} else {
							settings[r.type] = r.value;
						}
					}
					asyncLib.parallel(
						[
							this.resolveRequestArray.bind(
								this,
								contextInfo,
								this.context,
								useLoadersPost,
								loaderResolver
							),
							this.resolveRequestArray.bind(
								this,
								contextInfo,
								this.context,
								useLoaders,
								loaderResolver
							),
							this.resolveRequestArray.bind(
								this,
								contextInfo,
								this.context,
								useLoadersPre,
								loaderResolver
							)
						],
						(err, results) => {
							if (err) return callback(err);
							if (matchResource === void 0) {
								loaders = results[0].concat(loaders, results[1], results[2]);
							} else {
								loaders = results[0].concat(results[1], loaders, results[2]);
							}
							process.nextTick(() => {
								const type = settings.type;
								const resolveOptions = settings.resolve;
								callback(null, {
									context: context,
									request: loaders
										.map(loaderToIdent)
										.concat([resource])
										.join("!"),
									dependencies: data.dependencies,
									userRequest,
									rawRequest: request,
									loaders,
									resource,
									matchResource,
									resourceResolveData,
									settings,
									type,
									parser: this.getParser(type, settings.parser),
									generator: this.getGenerator(type, settings.generator),
									resolveOptions
								});
							});
						}
					);
				}
			);
		});
	}

	create(data, callback) {
		const dependencies = data.dependencies;
		const cacheEntry = dependencyCache.get(dependencies[0]);
		if (cacheEntry) return callback(null, cacheEntry);
		const context = data.context || this.context;
		const resolveOptions = data.resolveOptions || EMPTY_RESOLVE_OPTIONS;
		const request = dependencies[0].request;
		const contextInfo = data.contextInfo || {};
		this.hooks.beforeResolve.callAsync(
			{
				contextInfo,
				resolveOptions,
				context,
				request,
				dependencies
			},
			(err, result) => {
				if (err) return callback(err);

				if (!result) return callback();

				const factory = this.hooks.factory.call(null);

				if (!factory) return callback();

				factory(result, (err, module) => {
					if (err) return callback(err);

					if (module && this.cachePredicate(module)) {
						for (const d of dependencies) {
							dependencyCache.set(d, module);
						}
					}

					callback(null, module);
				});
			}
		);
	}

	resolveRequestArray(contextInfo, context, array, resolver, callback) {
		if (array.length === 0) return callback(null, []);
		asyncLib.map(
			array,
			(item, callback) => {
				resolver.resolve(
					contextInfo,
					context,
					item.loader,
					{},
					(err, result) => {
						if (
							err &&
							/^[^/]*$/.test(item.loader) &&
							!/-loader$/.test(item.loader)
						) {
							return resolver.resolve(
								contextInfo,
								context,
								item.loader + "-loader",
								{},
								err2 => {
									if (!err2)
										err.message +=
											`\nBREAKING CHANGE: It's no longer allowed to omit the '-loader' suffix when using loaders.\n                 You need to specify '${item.loader}-loader' instead of '${item.loader}',\n                 see https://webpack.js.org/migrate/3/#automatic-loader-module-name-extension-removed`;

									callback(err);
								}
							);
						}
						if (err) return callback(err);

						const optionsOnly = item.options
							? {
									options: item.options
								}
							: void 0;
						return callback(
							null,
							Object.assign({}, item, identToLoaderRequest(result), optionsOnly)
						);
					}
				);
			},
			callback
		);
	}

	getParser(type, parserOptions) {
		let ident = type;
		if (parserOptions) {
			if (parserOptions.ident) {
				ident = `${type}|${parserOptions.ident}`;
			} else {
				ident = JSON.stringify([type, parserOptions]);
			}
		}
		if (ident in this.parserCache) {
			return this.parserCache[ident];
		}
		return (this.parserCache[ident] = this.createParser(type, parserOptions));
	}

	createParser(type, parserOptions = {}) {
		const parser = this.hooks.createParser.for(type).call(parserOptions);
		if (!parser) {
			throw new Error(`No parser registered for ${type}`);
		}
		this.hooks.parser.for(type).call(parser, parserOptions);
		return parser;
	}

	getGenerator(type, generatorOptions) {
		let ident = type;
		if (generatorOptions) {
			if (generatorOptions.ident) {
				ident = `${type}|${generatorOptions.ident}`;
			} else {
				ident = JSON.stringify([type, generatorOptions]);
			}
		}
		if (ident in this.generatorCache) {
			return this.generatorCache[ident];
		}
		return (this.generatorCache[ident] = this.createGenerator(
			type,
			generatorOptions
		));
	}

	createGenerator(type, generatorOptions = {}) {
		const generator = this.hooks.createGenerator
			.for(type)
			.call(generatorOptions);
		if (!generator) {
			throw new Error(`No generator registered for ${type}`);
		}
		this.hooks.generator.for(type).call(generator, generatorOptions);
		return generator;
	}

	getResolver(type, resolveOptions) {
		return this.resolverFactory.get(
			type,
			resolveOptions || EMPTY_RESOLVE_OPTIONS
		);
	}
}

module.exports = NormalModuleFactory;

},
// 171
function(module, exports, __webpack_require__) {

var fs = __webpack_require__(34),
	readFile = fs.readFile.bind(fs),
	loadLoader = __webpack_require__(172);

function utf8BufferToString(buf) {
	var str = buf.toString("utf-8");
	return str.charCodeAt(0) === 0xFEFF ? str.substr(1) : str;
}

function splitQuery(req) {
	var i = req.indexOf("?");
	return i < 0 ? [req, ""] : [req.substr(0, i), req.substr(i)];
}

function dirname(path) {
	if (path === "/") return "/";
	var i = path.lastIndexOf("/"),
		j = path.lastIndexOf("\\"),
		i2 = path.indexOf("/"),
		j2 = path.indexOf("\\"),
		idx = i > j ? i : j,
		idx2 = i > j ? i2 : j2;
	return idx < 0 ? path : idx === idx2 ? path.substr(0, idx + 1) : path.substr(0, idx);
}

function createLoaderObject(loader) {
	var obj = {
		path: null,
		query: null,
		options: null,
		ident: null,
		normal: null,
		pitch: null,
		raw: null,
		data: null,
		pitchExecuted: false,
		normalExecuted: false
	};
	Object.defineProperty(obj, "request", {
		enumerable: true,
		get: function() {
			return obj.path + obj.query;
		},
		set: function(value) {
			if (typeof value == "string") {
				var splittedRequest = splitQuery(value);
				obj.path = splittedRequest[0];
				obj.query = splittedRequest[1];
				obj.options = void 0;
				obj.ident = void 0;
			} else {
				if (!value.loader)
					throw new Error(
						"request should be a string or object with loader and object (" + JSON.stringify(value) + ")"
					);
				obj.path = value.loader;
				obj.options = value.options;
				obj.ident = value.ident;
				obj.query = obj.options === null || obj.options === void 0
					? ""
					: typeof obj.options == "string"
					? "?" + obj.options
					: obj.ident
					? "??" + obj.ident
					: typeof obj.options == "object" && obj.options.ident
					? "??" + obj.options.ident
					: "?" + JSON.stringify(obj.options);
			}
		}
	});
	obj.request = loader;
	Object.preventExtensions && Object.preventExtensions(obj);

	return obj;
}

function runSyncOrAsync(fn, context, args, callback) {
	var isSync = true,
		isDone = false,
		isError = false,
		reportedError = false;
	context.async = function() {
		if (isDone) {
			if (reportedError) return;
			throw new Error("async(): The callback was already called.");
		}
		isSync = false;
		return innerCallback;
	};
	var innerCallback = (context.callback = function() {
		if (isDone) {
			if (reportedError) return;
			throw new Error("callback(): The callback was already called.");
		}
		isDone = true;
		isSync = false;
		try {
			callback.apply(null, arguments);
		} catch (e) {
			isError = true;
			throw e;
		}
	});
	try {
		var result = (function() {
			return fn.apply(context, args);
		})();
		if (isSync) {
			isDone = true;
			return result === void 0
				? callback()
				: result && typeof result == "object" && typeof result.then == "function"
				? result.then(function(r) {
						callback(null, r);
					}, callback)
				: callback(null, result);
		}
	} catch (e) {
		if (isError) throw e;
		if (isDone) {
			typeof e == "object" && e.stack ? console.error(e.stack) : console.error(e);
			return;
		}
		isDone = true;
		reportedError = true;
		callback(e);
	}
}

function convertArgs(args, raw) {
	if (!raw && Buffer.isBuffer(args[0])) args[0] = utf8BufferToString(args[0]);
	else if (raw && typeof args[0] == "string") args[0] = new Buffer(args[0], "utf-8");
}

function iteratePitchingLoaders(options, loaderContext, callback) {
	if (loaderContext.loaderIndex >= loaderContext.loaders.length)
		return processResource(options, loaderContext, callback);

	var currentLoaderObject = loaderContext.loaders[loaderContext.loaderIndex];

	if (currentLoaderObject.pitchExecuted) {
		loaderContext.loaderIndex++;
		return iteratePitchingLoaders(options, loaderContext, callback);
	}

	loadLoader(currentLoaderObject, function(err) {
		if (err) {
			loaderContext.cacheable(false);
			return callback(err);
		}
		var fn = currentLoaderObject.pitch;
		currentLoaderObject.pitchExecuted = true;
		if (!fn) return iteratePitchingLoaders(options, loaderContext, callback);

		runSyncOrAsync(
			fn,
			loaderContext,
			[loaderContext.remainingRequest, loaderContext.previousRequest, (currentLoaderObject.data = {})],
			function(err) {
				if (err) return callback(err);
				var args = Array.prototype.slice.call(arguments, 1);
				if (args.length > 0) {
					loaderContext.loaderIndex--;
					iterateNormalLoaders(options, loaderContext, args, callback);
				} else iteratePitchingLoaders(options, loaderContext, callback);
			}
		);
	});
}

function processResource(options, loaderContext, callback) {
	loaderContext.loaderIndex = loaderContext.loaders.length - 1;

	var resourcePath = loaderContext.resourcePath;
	if (resourcePath) {
		loaderContext.addDependency(resourcePath);
		options.readResource(resourcePath, function(err, buffer) {
			if (err) return callback(err);
			options.resourceBuffer = buffer;
			iterateNormalLoaders(options, loaderContext, [buffer], callback);
		});
	} else iterateNormalLoaders(options, loaderContext, [null], callback);
}

function iterateNormalLoaders(options, loaderContext, args, callback) {
	if (loaderContext.loaderIndex < 0) return callback(null, args);

	var currentLoaderObject = loaderContext.loaders[loaderContext.loaderIndex];

	if (currentLoaderObject.normalExecuted) {
		loaderContext.loaderIndex--;
		return iterateNormalLoaders(options, loaderContext, args, callback);
	}

	var fn = currentLoaderObject.normal;
	currentLoaderObject.normalExecuted = true;
	if (!fn) return iterateNormalLoaders(options, loaderContext, args, callback);

	convertArgs(args, currentLoaderObject.raw);

	runSyncOrAsync(fn, loaderContext, args, function(err) {
		if (err) return callback(err);

		var args = Array.prototype.slice.call(arguments, 1);
		iterateNormalLoaders(options, loaderContext, args, callback);
	});
}

exports.getContext = function(resource) {
	return dirname(splitQuery(resource)[0]);
};

exports.runLoaders = function(options, callback) {
	var resource = options.resource || "",
		loaders = options.loaders || [],
		loaderContext = options.context || {},
		readResource = options.readResource || readFile,

		splittedResource = resource && splitQuery(resource),
		resourcePath = splittedResource ? splittedResource[0] : void 0,
		resourceQuery = splittedResource ? splittedResource[1] : void 0,
		contextDirectory = resourcePath ? dirname(resourcePath) : null,

		requestCacheable = true,
		fileDependencies = [],
		contextDependencies = [];

	loaders = loaders.map(createLoaderObject);

	loaderContext.context = contextDirectory;
	loaderContext.loaderIndex = 0;
	loaderContext.loaders = loaders;
	loaderContext.resourcePath = resourcePath;
	loaderContext.resourceQuery = resourceQuery;
	loaderContext.async = null;
	loaderContext.callback = null;
	loaderContext.cacheable = function(flag) {
		if (flag === false) requestCacheable = false;
	};
	loaderContext.dependency = loaderContext.addDependency = function(file) {
		fileDependencies.push(file);
	};
	loaderContext.addContextDependency = function(context) {
		contextDependencies.push(context);
	};
	loaderContext.getDependencies = function() {
		return fileDependencies.slice();
	};
	loaderContext.getContextDependencies = function() {
		return contextDependencies.slice();
	};
	loaderContext.clearDependencies = function() {
		fileDependencies.length = 0;
		contextDependencies.length = 0;
		requestCacheable = true;
	};
	Object.defineProperty(loaderContext, "resource", {
		enumerable: true,
		get: function() {
			return loaderContext.resourcePath === void 0
				? void 0
				: loaderContext.resourcePath + loaderContext.resourceQuery;
		},
		set: function(value) {
			var splittedResource = value && splitQuery(value);
			loaderContext.resourcePath = splittedResource ? splittedResource[0] : void 0;
			loaderContext.resourceQuery = splittedResource ? splittedResource[1] : void 0;
		}
	});
	Object.defineProperty(loaderContext, "request", {
		enumerable: true,
		get: function() {
			return loaderContext.loaders.map(function(o) {
				return o.request;
			}).concat(loaderContext.resource || "").join("!");
		}
	});
	Object.defineProperty(loaderContext, "remainingRequest", {
		enumerable: true,
		get: function() {
			if (loaderContext.loaderIndex >= loaderContext.loaders.length - 1 && !loaderContext.resource)
				return "";
			return loaderContext.loaders.slice(loaderContext.loaderIndex + 1).map(function(o) {
				return o.request;
			}).concat(loaderContext.resource || "").join("!");
		}
	});
	Object.defineProperty(loaderContext, "currentRequest", {
		enumerable: true,
		get: function() {
			return loaderContext.loaders.slice(loaderContext.loaderIndex).map(function(o) {
				return o.request;
			}).concat(loaderContext.resource || "").join("!");
		}
	});
	Object.defineProperty(loaderContext, "previousRequest", {
		enumerable: true,
		get: function() {
			return loaderContext.loaders.slice(0, loaderContext.loaderIndex).map(function(o) {
				return o.request;
			}).join("!");
		}
	});
	Object.defineProperty(loaderContext, "query", {
		enumerable: true,
		get: function() {
			var entry = loaderContext.loaders[loaderContext.loaderIndex];
			return entry.options && typeof entry.options == "object" ? entry.options : entry.query;
		}
	});
	Object.defineProperty(loaderContext, "data", {
		enumerable: true,
		get: function() {
			return loaderContext.loaders[loaderContext.loaderIndex].data;
		}
	});

	Object.preventExtensions && Object.preventExtensions(loaderContext);

	var processOptions = { resourceBuffer: null, readResource: readResource };
	iteratePitchingLoaders(processOptions, loaderContext, function(err, result) {
		if (err)
			return callback(err, {
				cacheable: requestCacheable,
				fileDependencies: fileDependencies,
				contextDependencies: contextDependencies
			});

		callback(null, {
			result: result,
			resourceBuffer: processOptions.resourceBuffer,
			cacheable: requestCacheable,
			fileDependencies: fileDependencies,
			contextDependencies: contextDependencies
		});
	});
};

},
// 172
function(module, exports, __webpack_require__) {

var LoaderLoadingError = __webpack_require__(173);

module.exports = function loadLoader(loader, callback) {
	if (typeof System == "object" && typeof System.import == "function")
		System.import(loader.path).catch(callback).then(function(module) {
			loader.normal = typeof module == "function" ? module : module.default;
			loader.pitch = module.pitch;
			loader.raw = module.raw;
			if (typeof loader.normal != "function" && typeof loader.pitch != "function")
				return callback(new LoaderLoadingError(
					"Module '" + loader.path + "' is not a loader (must have normal or pitch function)"
				));

			callback();
		});
	else {
		try {
			var module = require(loader.path);
		} catch (e) {
			if (e instanceof Error && e.code === "EMFILE") {
				var retry = loadLoader.bind(null, loader, callback);
				return typeof setImmediate == "function"
					? setImmediate(retry)
					: process.nextTick(retry);
			}
			return callback(e);
		}
		if (typeof module != "function" && typeof module != "object")
			return callback(new LoaderLoadingError(
				"Module '" + loader.path + "' is not a loader (export function or es6 module)"
			));

		loader.normal = typeof module == "function" ? module : module.default;
		loader.pitch = module.pitch;
		loader.raw = module.raw;
		if (typeof loader.normal != "function" && typeof loader.pitch != "function")
			return callback(new LoaderLoadingError(
				"Module '" + loader.path + "' is not a loader (must have normal or pitch function)"
			));

		callback();
	}
};

},
// 173
function(module) {

class LoadingLoaderError extends Error {
	constructor(message) {
		super(message);
		this.name = "LoaderRunnerError";
		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = LoadingLoaderError;

},
// 174
function(module, exports, __webpack_require__) {

const { RawSource, ReplaceSource } = __webpack_require__(0);

class DependenciesBlockVariable {
	constructor(name, expression, dependencies) {
		this.name = name;
		this.expression = expression;
		this.dependencies = dependencies || [];
	}

	updateHash(hash) {
		hash.update(this.name);
		hash.update(this.expression);
		for (const d of this.dependencies) {
			d.updateHash(hash);
		}
	}

	expressionSource(dependencyTemplates, runtimeTemplate) {
		const source = new ReplaceSource(new RawSource(this.expression));
		for (const dep of this.dependencies) {
			const template = dependencyTemplates.get(dep.constructor);
			if (!template) {
				throw new Error(`No template for dependency: ${dep.constructor.name}`);
			}
			template.apply(dep, source, runtimeTemplate, dependencyTemplates);
		}
		return source;
	}

	disconnect() {
		for (const d of this.dependencies) {
			d.disconnect();
		}
	}

	hasDependencies(filter) {
		if (filter) {
			return this.dependencies.some(filter);
		}
		return this.dependencies.length > 0;
	}
}

module.exports = DependenciesBlockVariable;

},
// 175
function(module, exports, __webpack_require__) {

class ModuleReason {
	constructor(module, dependency, explanation) {
		this.module = module;
		this.dependency = dependency;
		this.explanation = explanation;
		this._chunks = null;
	}

	hasChunk(chunk) {
		if (this._chunks) {
			if (this._chunks.has(chunk)) return true;
		} else if (this.module && this.module._chunks.has(chunk)) return true;
		return false;
	}

	rewriteChunks(oldChunk, newChunks) {
		if (!this._chunks) {
			if (this.module) {
				if (!this.module._chunks.has(oldChunk)) return;
				this._chunks = new Set(this.module._chunks);
			} else {
				this._chunks = new Set();
			}
		}
		if (this._chunks.has(oldChunk)) {
			this._chunks.delete(oldChunk);
			for (let i = 0; i < newChunks.length; i++) {
				this._chunks.add(newChunks[i]);
			}
		}
	}
}

module.exports = ModuleReason;

},
// 176
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);

class ModuleParseError extends WebpackError {
	constructor(module, source, err, loaders) {
		let message = "Module parse failed: " + err.message;
		let loc = void 0;
		if (loaders.length >= 1) {
			message += `\nFile was processed with these loaders:${loaders
				.map(loader => `\n * ${loader}`)
				.join("")}`;
			message +=
				"\nYou may need an additional loader to handle the result of these loaders.";
		} else
			message +=
				"\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders";

		if (
			err.loc &&
			typeof err.loc == "object" &&
			typeof err.loc.line == "number"
		) {
			var lineNumber = err.loc.line;
			if (/[\0\u0001\u0002\u0003\u0004\u0005\u0006\u0007]/.test(source))
				message += "\n(Source code omitted for this binary file)";
			else {
				const sourceLines = source.split(/\r?\n/);
				const start = Math.max(0, lineNumber - 3);
				const linesBefore = sourceLines.slice(start, lineNumber - 1);
				const theLine = sourceLines[lineNumber - 1];
				const linesAfter = sourceLines.slice(lineNumber, lineNumber + 2);
				message +=
					linesBefore.map(l => `\n| ${l}`).join("") +
					`\n> ${theLine}` +
					linesAfter.map(l => `\n| ${l}`).join("");
			}
			loc = err.loc;
		} else {
			message += "\n" + err.stack;
		}

		super(message);

		this.name = "ModuleParseError";
		this.module = module;
		this.loc = loc;
		this.error = err;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = ModuleParseError;

},
// 177
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);
const { cutOffLoaderExecution } = __webpack_require__(33);

class ModuleBuildError extends WebpackError {
	constructor(module, err, { from = null } = {}) {
		let message = "Module build failed";
		let details = void 0;
		if (from) {
			message += ` (from ${from}):\n`;
		} else {
			message += ": ";
		}
		if (err !== null && typeof err == "object") {
			if (typeof err.stack == "string" && err.stack) {
				const stack = cutOffLoaderExecution(err.stack);
				if (!err.hideStack) {
					message += stack;
				} else {
					details = stack;
					if (typeof err.message == "string" && err.message) {
						message += err.message;
					} else {
						message += err;
					}
				}
			} else if (typeof err.message == "string" && err.message) {
				message += err.message;
			} else {
				message += err;
			}
		} else {
			message = err;
		}

		super(message);

		this.name = "ModuleBuildError";
		this.details = details;
		this.module = module;
		this.error = err;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = ModuleBuildError;

},
// 178
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);
const { cleanUp } = __webpack_require__(33);

class ModuleError extends WebpackError {
	constructor(module, err, { from = null } = {}) {
		let message = "Module Error";
		if (from) {
			message += ` (from ${from}):\n`;
		} else {
			message += ": ";
		}
		if (err && typeof err == "object" && err.message) {
			message += err.message;
		} else if (err) {
			message += err;
		}
		super(message);
		this.name = "ModuleError";
		this.module = module;
		this.error = err;
		this.details =
			err && typeof err == "object" && err.stack
				? cleanUp(err.stack, this.message)
				: void 0;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = ModuleError;

},
// 179
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);
const { cleanUp } = __webpack_require__(33);

class ModuleWarning extends WebpackError {
	constructor(module, warning, { from = null } = {}) {
		let message = "Module Warning";
		if (from) {
			message += ` (from ${from}):\n`;
		} else {
			message += ": ";
		}
		if (warning && typeof warning == "object" && warning.message) {
			message += warning.message;
		} else if (warning) {
			message += warning;
		}
		super(message);
		this.name = "ModuleWarning";
		this.module = module;
		this.warning = warning;
		this.details =
			warning && typeof warning == "object" && warning.stack
				? cleanUp(warning.stack, this.message)
				: void 0;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = ModuleWarning;

},
// 180
function(module, exports, __webpack_require__) {

const Module = __webpack_require__(16);
const { OriginalSource, RawSource } = __webpack_require__(0);

module.exports = class extends Module {
	constructor(source, identifier, readableIdentifier) {
		super("javascript/dynamic", null);
		this.sourceStr = source;
		this.identifierStr = identifier || this.sourceStr;
		this.readableIdentifierStr = readableIdentifier || this.identifierStr;
		this.built = false;
	}

	identifier() {
		return this.identifierStr;
	}

	size() {
		return this.sourceStr.length;
	}

	readableIdentifier(requestShortener) {
		return requestShortener.shorten(this.readableIdentifierStr);
	}

	needRebuild() {
		return false;
	}

	build(options, compilations, resolver, fs, callback) {
		this.built = true;
		this.buildMeta = {};
		this.buildInfo = {
			cacheable: true
		};
		callback();
	}

	source() {
		if (this.useSourceMap) {
			return new OriginalSource(this.sourceStr, this.identifier());
		} else {
			return new RawSource(this.sourceStr);
		}
	}

	updateHash(hash) {
		hash.update(this.sourceStr);
		super.updateHash(hash);
	}
};

},
// 181
function(module, exports, __webpack_require__) {

const notMatcher = matcher => {
	return str => {
		return !matcher(str);
	};
};

const orMatcher = items => {
	return str => {
		for (let i = 0; i < items.length; i++) {
			if (items[i](str)) return true;
		}
		return false;
	};
};

const andMatcher = items => {
	return str => {
		for (let i = 0; i < items.length; i++) {
			if (!items[i](str)) return false;
		}
		return true;
	};
};

module.exports = class {
	constructor(rules) {
		this.references = Object.create(null);
		this.rules = RuleSet.normalizeRules(rules, this.references, "ref-");
	}

	static normalizeRules(rules, refs, ident) {
		if (Array.isArray(rules)) {
			return rules.map((rule, idx) => {
				return RuleSet.normalizeRule(rule, refs, `${ident}-${idx}`);
			});
		} else if (rules) {
			return [RuleSet.normalizeRule(rules, refs, ident)];
		} else {
			return [];
		}
	}

	static normalizeRule(rule, refs, ident) {
		if (typeof rule == "string") {
			return {
				use: [
					{
						loader: rule
					}
				]
			};
		}
		if (!rule) {
			throw new Error("Unexcepted null when object was expected as rule");
		}
		if (typeof rule != "object") {
			throw new Error(
				"Unexcepted " +
					typeof rule +
					" when object was expected as rule (" +
					rule +
					")"
			);
		}

		const newRule = {};
		let useSource;
		let resourceSource;
		let condition;

		const checkUseSource = newSource => {
			if (useSource && useSource !== newSource) {
				throw new Error(
					RuleSet.buildErrorMessage(
						rule,
						new Error(
							"Rule can only have one result source (provided " +
								newSource +
								" and " +
								useSource +
								")"
						)
					)
				);
			}
			useSource = newSource;
		};

		const checkResourceSource = newSource => {
			if (resourceSource && resourceSource !== newSource) {
				throw new Error(
					RuleSet.buildErrorMessage(
						rule,
						new Error(
							"Rule can only have one resource source (provided " +
								newSource +
								" and " +
								resourceSource +
								")"
						)
					)
				);
			}
			resourceSource = newSource;
		};

		if (rule.test || rule.include || rule.exclude) {
			checkResourceSource("test + include + exclude");
			condition = {
				test: rule.test,
				include: rule.include,
				exclude: rule.exclude
			};
			try {
				newRule.resource = RuleSet.normalizeCondition(condition);
			} catch (error) {
				throw new Error(RuleSet.buildErrorMessage(condition, error));
			}
		}

		if (rule.resource) {
			checkResourceSource("resource");
			try {
				newRule.resource = RuleSet.normalizeCondition(rule.resource);
			} catch (error) {
				throw new Error(RuleSet.buildErrorMessage(rule.resource, error));
			}
		}

		if (rule.realResource) {
			try {
				newRule.realResource = RuleSet.normalizeCondition(rule.realResource);
			} catch (error) {
				throw new Error(RuleSet.buildErrorMessage(rule.realResource, error));
			}
		}

		if (rule.resourceQuery) {
			try {
				newRule.resourceQuery = RuleSet.normalizeCondition(rule.resourceQuery);
			} catch (error) {
				throw new Error(RuleSet.buildErrorMessage(rule.resourceQuery, error));
			}
		}

		if (rule.compiler) {
			try {
				newRule.compiler = RuleSet.normalizeCondition(rule.compiler);
			} catch (error) {
				throw new Error(RuleSet.buildErrorMessage(rule.compiler, error));
			}
		}

		if (rule.issuer) {
			try {
				newRule.issuer = RuleSet.normalizeCondition(rule.issuer);
			} catch (error) {
				throw new Error(RuleSet.buildErrorMessage(rule.issuer, error));
			}
		}

		if (rule.loader && rule.loaders) {
			throw new Error(
				RuleSet.buildErrorMessage(
					rule,
					new Error(
						"Provided loader and loaders for rule (use only one of them)"
					)
				)
			);
		}

		const loader = rule.loaders || rule.loader;
		if (typeof loader == "string" && !rule.options && !rule.query) {
			checkUseSource("loader");
			newRule.use = RuleSet.normalizeUse(loader.split("!"), ident);
		} else if (typeof loader == "string" && (rule.options || rule.query)) {
			checkUseSource("loader + options/query");
			newRule.use = RuleSet.normalizeUse(
				{
					loader: loader,
					options: rule.options,
					query: rule.query
				},
				ident
			);
		} else if (loader && (rule.options || rule.query)) {
			throw new Error(
				RuleSet.buildErrorMessage(
					rule,
					new Error(
						"options/query cannot be used with loaders (use options for each array item)"
					)
				)
			);
		} else if (loader) {
			checkUseSource("loaders");
			newRule.use = RuleSet.normalizeUse(loader, ident);
		} else if (rule.options || rule.query) {
			throw new Error(
				RuleSet.buildErrorMessage(
					rule,
					new Error(
						"options/query provided without loader (use loader + options)"
					)
				)
			);
		}

		if (rule.use) {
			checkUseSource("use");
			newRule.use = RuleSet.normalizeUse(rule.use, ident);
		}

		if (rule.rules) {
			newRule.rules = RuleSet.normalizeRules(
				rule.rules,
				refs,
				`${ident}-rules`
			);
		}

		if (rule.oneOf) {
			newRule.oneOf = RuleSet.normalizeRules(
				rule.oneOf,
				refs,
				`${ident}-oneOf`
			);
		}

		const keys = Object.keys(rule).filter(key => {
			return ![
				"resource",
				"resourceQuery",
				"compiler",
				"test",
				"include",
				"exclude",
				"issuer",
				"loader",
				"options",
				"query",
				"loaders",
				"use",
				"rules",
				"oneOf"
			].includes(key);
		});
		for (const key of keys) {
			newRule[key] = rule[key];
		}

		if (Array.isArray(newRule.use)) {
			for (const item of newRule.use) {
				if (item.ident) {
					refs[item.ident] = item.options;
				}
			}
		}

		return newRule;
	}

	static buildErrorMessage(condition, error) {
		const conditionAsText = JSON.stringify(
			condition,
			(key, value) => {
				return value === void 0 ? "undefined" : value;
			},
			2
		);
		return error.message + " in " + conditionAsText;
	}

	static normalizeUse(use, ident) {
		if (typeof use == "function") {
			return data => RuleSet.normalizeUse(use(data), ident);
		}
		if (Array.isArray(use)) {
			return use
				.map((item, idx) => RuleSet.normalizeUse(item, `${ident}-${idx}`))
				.reduce((arr, items) => arr.concat(items), []);
		}
		return [RuleSet.normalizeUseItem(use, ident)];
	}

	static normalizeUseItemString(useItemString) {
		const idx = useItemString.indexOf("?");
		if (idx >= 0) {
			return {
				loader: useItemString.substr(0, idx),
				options: useItemString.substr(idx + 1)
			};
		}
		return {
			loader: useItemString,
			options: void 0
		};
	}

	static normalizeUseItem(item, ident) {
		if (typeof item == "string") {
			return RuleSet.normalizeUseItemString(item);
		}

		const newItem = {};

		if (item.options && item.query) {
			throw new Error("Provided options and query in use");
		}

		if (!item.loader) {
			throw new Error("No loader specified");
		}

		newItem.options = item.options || item.query;

		if (typeof newItem.options == "object" && newItem.options) {
			if (newItem.options.ident) {
				newItem.ident = newItem.options.ident;
			} else {
				newItem.ident = ident;
			}
		}

		const keys = Object.keys(item).filter(function(key) {
			return !["options", "query"].includes(key);
		});

		for (const key of keys) {
			newItem[key] = item[key];
		}

		return newItem;
	}

	static normalizeCondition(condition) {
		if (!condition) throw new Error("Expected condition but got falsy value");
		if (typeof condition == "string") {
			return str => str.indexOf(condition) === 0;
		}
		if (typeof condition == "function") {
			return condition;
		}
		if (condition instanceof RegExp) {
			return condition.test.bind(condition);
		}
		if (Array.isArray(condition)) {
			const items = condition.map(c => RuleSet.normalizeCondition(c));
			return orMatcher(items);
		}
		if (typeof condition != "object") {
			throw Error(
				"Unexcepted " +
					typeof condition +
					" when condition was expected (" +
					condition +
					")"
			);
		}

		const matchers = [];
		Object.keys(condition).forEach(key => {
			const value = condition[key];
			switch (key) {
				case "or":
				case "include":
				case "test":
					if (value) matchers.push(RuleSet.normalizeCondition(value));
					break;
				case "and":
					if (value) {
						const items = value.map(c => RuleSet.normalizeCondition(c));
						matchers.push(andMatcher(items));
					}
					break;
				case "not":
				case "exclude":
					if (value) {
						const matcher = RuleSet.normalizeCondition(value);
						matchers.push(notMatcher(matcher));
					}
					break;
				default:
					throw new Error("Unexcepted property " + key + " in condition");
			}
		});
		if (matchers.length === 0) {
			throw new Error("Excepted condition but got " + condition);
		}
		if (matchers.length === 1) {
			return matchers[0];
		}
		return andMatcher(matchers);
	}

	exec(data) {
		const result = [];
		this._run(
			data,
			{
				rules: this.rules
			},
			result
		);
		return result;
	}

	_run(data, rule, result) {
		if (rule.resource && !data.resource) return false;
		if (rule.realResource && !data.realResource) return false;
		if (rule.resourceQuery && !data.resourceQuery) return false;
		if (rule.compiler && !data.compiler) return false;
		if (rule.issuer && !data.issuer) return false;
		if (rule.resource && !rule.resource(data.resource)) return false;
		if (rule.realResource && !rule.realResource(data.realResource))
			return false;
		if (data.issuer && rule.issuer && !rule.issuer(data.issuer)) return false;
		if (
			data.resourceQuery &&
			rule.resourceQuery &&
			!rule.resourceQuery(data.resourceQuery)
		) {
			return false;
		}
		if (data.compiler && rule.compiler && !rule.compiler(data.compiler)) {
			return false;
		}

		const keys = Object.keys(rule).filter(key => {
			return ![
				"resource",
				"realResource",
				"resourceQuery",
				"compiler",
				"issuer",
				"rules",
				"oneOf",
				"use",
				"enforce"
			].includes(key);
		});
		for (const key of keys) {
			result.push({
				type: key,
				value: rule[key]
			});
		}

		if (rule.use) {
			const process = use => {
				if (typeof use == "function") {
					process(use(data));
				} else if (Array.isArray(use)) {
					use.forEach(process);
				} else {
					result.push({
						type: "use",
						value: use,
						enforce: rule.enforce
					});
				}
			};
			process(rule.use);
		}

		if (rule.rules) {
			for (let i = 0; i < rule.rules.length; i++) {
				this._run(data, rule.rules[i], result);
			}
		}

		if (rule.oneOf) {
			for (let i = 0; i < rule.oneOf.length; i++) {
				if (this._run(data, rule.oneOf[i], result)) break;
			}
		}

		return true;
	}

	findOptionsByIdent(ident) {
		const options = this.references[ident];
		if (!options) {
			throw new Error("Can't find options with ident '" + ident + "'");
		}
		return options;
	}
};

},
// 182
function(module, exports, __webpack_require__) {

const asyncLib = __webpack_require__(12);
const path = __webpack_require__(3);

const {
	Tapable,
	AsyncSeriesWaterfallHook,
	SyncWaterfallHook
} = __webpack_require__(6);
const ContextModule = __webpack_require__(183);
const ContextElementDependency = __webpack_require__(56);

const EMPTY_RESOLVE_OPTIONS = {};

module.exports = class extends Tapable {
	constructor(resolverFactory) {
		super();
		this.hooks = {
			beforeResolve: new AsyncSeriesWaterfallHook(["data"]),
			afterResolve: new AsyncSeriesWaterfallHook(["data"]),
			contextModuleFiles: new SyncWaterfallHook(["files"]),
			alternatives: new AsyncSeriesWaterfallHook(["modules"])
		};
		this._pluginCompat.tap("ContextModuleFactory", options => {
			switch (options.name) {
				case "before-resolve":
				case "after-resolve":
				case "alternatives":
					options.async = true;
					break;
			}
		});
		this.resolverFactory = resolverFactory;
	}

	create(data, callback) {
		const context = data.context;
		const dependencies = data.dependencies;
		const resolveOptions = data.resolveOptions;
		const dependency = dependencies[0];
		this.hooks.beforeResolve.callAsync(
			Object.assign(
				{
					context: context,
					dependencies: dependencies,
					resolveOptions
				},
				dependency.options
			),
			(err, beforeResolveResult) => {
				if (err) return callback(err);

				if (!beforeResolveResult) return callback();

				const context = beforeResolveResult.context;
				const request = beforeResolveResult.request;
				const resolveOptions = beforeResolveResult.resolveOptions;

				let loaders,
					resource,
					loadersPrefix = "";
				const idx = request.lastIndexOf("!");
				if (idx >= 0) {
					let loadersRequest = request.substr(0, idx + 1);
					let i;
					for (
						i = 0;
						i < loadersRequest.length && loadersRequest[i] === "!";
						i++
					) {
						loadersPrefix += "!";
					}
					loadersRequest = loadersRequest
						.substr(i)
						.replace(/!+$/, "")
						.replace(/!!+/g, "!");
					if (loadersRequest === "") {
						loaders = [];
					} else {
						loaders = loadersRequest.split("!");
					}
					resource = request.substr(idx + 1);
				} else {
					loaders = [];
					resource = request;
				}

				const contextResolver = this.resolverFactory.get(
					"context",
					resolveOptions || EMPTY_RESOLVE_OPTIONS
				);
				const loaderResolver = this.resolverFactory.get(
					"loader",
					EMPTY_RESOLVE_OPTIONS
				);

				asyncLib.parallel(
					[
						callback => {
							contextResolver.resolve(
								{},
								context,
								resource,
								{},
								(err, result) => {
									if (err) return callback(err);
									callback(null, result);
								}
							);
						},
						callback => {
							asyncLib.map(
								loaders,
								(loader, callback) => {
									loaderResolver.resolve(
										{},
										context,
										loader,
										{},
										(err, result) => {
											if (err) return callback(err);
											callback(null, result);
										}
									);
								},
								callback
							);
						}
					],
					(err, result) => {
						if (err) return callback(err);

						this.hooks.afterResolve.callAsync(
							Object.assign(
								{
									addon:
										loadersPrefix +
										result[1].join("!") +
										(result[1].length > 0 ? "!" : ""),
									resource: result[0],
									resolveDependencies: this.resolveDependencies.bind(this)
								},
								beforeResolveResult
							),
							(err, result) => {
								if (err) return callback(err);

								if (!result) return callback();

								return callback(
									null,
									new ContextModule(result.resolveDependencies, result)
								);
							}
						);
					}
				);
			}
		);
	}

	resolveDependencies(fs, options, callback) {
		const cmf = this;
		let resource = options.resource;
		let resourceQuery = options.resourceQuery;
		let recursive = options.recursive;
		let regExp = options.regExp;
		let include = options.include;
		let exclude = options.exclude;
		if (!regExp || !resource) return callback(null, []);

		const addDirectory = (directory, callback) => {
			fs.readdir(directory, (err, files) => {
				if (err) return callback(err);
				files = cmf.hooks.contextModuleFiles.call(files);
				if (!files || files.length === 0) return callback(null, []);
				asyncLib.map(
					files.filter(p => p.indexOf(".") !== 0),
					(segment, callback) => {
						const subResource = path.join(directory, segment);

						if (!exclude || !subResource.match(exclude)) {
							fs.stat(subResource, (err, stat) => {
								if (err) {
									if (err.code === "ENOENT") {
										return callback();
									} else {
										return callback(err);
									}
								}

								if (stat.isDirectory()) {
									if (!recursive) return callback();
									addDirectory.call(this, subResource, callback);
								} else if (
									stat.isFile() &&
									(!include || subResource.match(include))
								) {
									const obj = {
										context: resource,
										request:
											"." +
											subResource.substr(resource.length).replace(/\\/g, "/")
									};

									this.hooks.alternatives.callAsync(
										[obj],
										(err, alternatives) => {
											if (err) return callback(err);
											alternatives = alternatives
												.filter(obj => regExp.test(obj.request))
												.map(obj => {
													const dep = new ContextElementDependency(
														obj.request + resourceQuery,
														obj.request
													);
													dep.optional = true;
													return dep;
												});
											callback(null, alternatives);
										}
									);
								} else {
									callback();
								}
							});
						} else {
							callback();
						}
					},
					(err, result) => {
						if (err) return callback(err);

						if (!result) return callback(null, []);

						callback(
							null,
							result.filter(Boolean).reduce((a, i) => a.concat(i), [])
						);
					}
				);
			});
		};

		addDirectory(resource, callback);
	}
};

},
// 183
function(module, exports, __webpack_require__) {

const util = __webpack_require__(11);
const { OriginalSource, RawSource } = __webpack_require__(0);
const Module = __webpack_require__(16);
const AsyncDependenciesBlock = __webpack_require__(35);
const Template = __webpack_require__(2);
const contextify = __webpack_require__(13).contextify;

class ContextModule extends Module {
	constructor(resolveDependencies, options) {
		let resource;
		let resourceQuery;
		const queryIdx = options.resource.indexOf("?");
		if (queryIdx >= 0) {
			resource = options.resource.substr(0, queryIdx);
			resourceQuery = options.resource.substr(queryIdx);
		} else {
			resource = options.resource;
			resourceQuery = "";
		}

		super("javascript/dynamic", resource);

		this.resolveDependencies = resolveDependencies;
		this.options = Object.assign({}, options, {
			resource: resource,
			resourceQuery: resourceQuery
		});
		if (options.resolveOptions !== void 0) {
			this.resolveOptions = options.resolveOptions;
		}

		this._contextDependencies = new Set([this.context]);

		if (typeof options.mode != "string") {
			throw new Error("options.mode is a required option");
		}

		this._identifier = this._createIdentifier();
	}

	updateCacheModule(module) {
		this.resolveDependencies = module.resolveDependencies;
		this.options = module.options;
		this.resolveOptions = module.resolveOptions;
	}

	prettyRegExp(regexString) {
		return regexString.substring(1, regexString.length - 1);
	}

	_createIdentifier() {
		let identifier = this.context;
		if (this.options.resourceQuery) {
			identifier += ` ${this.options.resourceQuery}`;
		}
		if (this.options.mode) {
			identifier += ` ${this.options.mode}`;
		}
		if (!this.options.recursive) {
			identifier += " nonrecursive";
		}
		if (this.options.addon) {
			identifier += ` ${this.options.addon}`;
		}
		if (this.options.regExp) {
			identifier += ` ${this.options.regExp}`;
		}
		if (this.options.include) {
			identifier += ` include: ${this.options.include}`;
		}
		if (this.options.exclude) {
			identifier += ` exclude: ${this.options.exclude}`;
		}
		if (this.options.groupOptions) {
			identifier += ` groupOptions: ${JSON.stringify(
				this.options.groupOptions
			)}`;
		}
		if (this.options.namespaceObject === "strict") {
			identifier += " strict namespace object";
		} else if (this.options.namespaceObject) {
			identifier += " namespace object";
		}

		return identifier;
	}

	identifier() {
		return this._identifier;
	}

	readableIdentifier(requestShortener) {
		let identifier = requestShortener.shorten(this.context);
		if (this.options.resourceQuery) {
			identifier += ` ${this.options.resourceQuery}`;
		}
		if (this.options.mode) {
			identifier += ` ${this.options.mode}`;
		}
		if (!this.options.recursive) {
			identifier += " nonrecursive";
		}
		if (this.options.addon) {
			identifier += ` ${requestShortener.shorten(this.options.addon)}`;
		}
		if (this.options.regExp) {
			identifier += ` ${this.prettyRegExp(this.options.regExp + "")}`;
		}
		if (this.options.include) {
			identifier += ` include: ${this.prettyRegExp(this.options.include + "")}`;
		}
		if (this.options.exclude) {
			identifier += ` exclude: ${this.prettyRegExp(this.options.exclude + "")}`;
		}
		if (this.options.groupOptions) {
			const groupOptions = this.options.groupOptions;
			for (const key of Object.keys(groupOptions)) {
				identifier += ` ${key}: ${groupOptions[key]}`;
			}
		}
		if (this.options.namespaceObject === "strict") {
			identifier += " strict namespace object";
		} else if (this.options.namespaceObject) {
			identifier += " namespace object";
		}

		return identifier;
	}

	libIdent(options) {
		let identifier = contextify(options.context, this.context);
		if (this.options.mode) {
			identifier += ` ${this.options.mode}`;
		}
		if (this.options.recursive) {
			identifier += " recursive";
		}
		if (this.options.addon) {
			identifier += ` ${contextify(options.context, this.options.addon)}`;
		}
		if (this.options.regExp) {
			identifier += ` ${this.prettyRegExp(this.options.regExp + "")}`;
		}
		if (this.options.include) {
			identifier += ` include: ${this.prettyRegExp(this.options.include + "")}`;
		}
		if (this.options.exclude) {
			identifier += ` exclude: ${this.prettyRegExp(this.options.exclude + "")}`;
		}

		return identifier;
	}

	needRebuild(fileTimestamps, contextTimestamps) {
		const ts = contextTimestamps.get(this.context);
		if (!ts) {
			return true;
		}

		return ts >= this.buildInfo.builtTime;
	}

	build(options, compilation, resolver, fs, callback) {
		this.built = true;
		this.buildMeta = {};
		this.buildInfo = {
			builtTime: Date.now(),
			contextDependencies: this._contextDependencies
		};
		this.resolveDependencies(fs, this.options, (err, dependencies) => {
			if (err) return callback(err);

			if (!dependencies) {
				callback();
				return;
			}

			for (const dep of dependencies) {
				dep.loc = {
					name: dep.userRequest
				};
				dep.request = this.options.addon + dep.request;
			}

			if (this.options.mode === "sync" || this.options.mode === "eager") {
				this.dependencies = dependencies;
			} else if (this.options.mode === "lazy-once") {
				if (dependencies.length > 0) {
					const block = new AsyncDependenciesBlock(
						Object.assign({}, this.options.groupOptions, {
							name: this.options.chunkName
						}),
						this
					);
					for (const dep of dependencies) {
						block.addDependency(dep);
					}
					this.addBlock(block);
				}
			} else if (
				this.options.mode === "weak" ||
				this.options.mode === "async-weak"
			) {
				for (const dep of dependencies) {
					dep.weak = true;
				}
				this.dependencies = dependencies;
			} else if (this.options.mode === "lazy") {
				let index = 0;
				for (const dep of dependencies) {
					let chunkName = this.options.chunkName;
					if (chunkName) {
						if (!/\[(index|request)\]/.test(chunkName)) {
							chunkName += "[index]";
						}
						chunkName = chunkName.replace(/\[index\]/g, index++);
						chunkName = chunkName.replace(
							/\[request\]/g,
							Template.toPath(dep.userRequest)
						);
					}
					const block = new AsyncDependenciesBlock(
						Object.assign({}, this.options.groupOptions, {
							name: chunkName
						}),
						dep.module,
						dep.loc,
						dep.userRequest
					);
					block.addDependency(dep);
					this.addBlock(block);
				}
			} else {
				callback(
					new Error(`Unsupported mode "${this.options.mode}" in context`)
				);
				return;
			}
			callback();
		});
	}

	getUserRequestMap(dependencies) {
		return dependencies
			.filter(dependency => dependency.module)
			.sort((a, b) => {
				if (a.userRequest === b.userRequest) {
					return 0;
				}
				return a.userRequest < b.userRequest ? -1 : 1;
			})
			.reduce((map, dep) => {
				map[dep.userRequest] = dep.module.id;
				return map;
			}, Object.create(null));
	}

	getFakeMap(dependencies) {
		if (!this.options.namespaceObject) {
			return 9;
		}
		let hasNonHarmony = false;
		let hasNamespace = false;
		let hasNamed = false;
		const fakeMap = dependencies
			.filter(dependency => dependency.module)
			.sort((a, b) => {
				return b.module.id - a.module.id;
			})
			.reduce((map, dep) => {
				const exportsType =
					dep.module.buildMeta && dep.module.buildMeta.exportsType;
				const id = dep.module.id;
				if (!exportsType) {
					map[id] = this.options.namespaceObject === "strict" ? 1 : 7;
					hasNonHarmony = true;
				} else if (exportsType === "namespace") {
					map[id] = 9;
					hasNamespace = true;
				} else if (exportsType === "named") {
					map[id] = 3;
					hasNamed = true;
				}
				return map;
			}, Object.create(null));
		if (!hasNamespace && hasNonHarmony && !hasNamed) {
			return this.options.namespaceObject === "strict" ? 1 : 7;
		}
		if (hasNamespace && !hasNonHarmony && !hasNamed) {
			return 9;
		}
		if (!hasNamespace && !hasNonHarmony && hasNamed) {
			return 3;
		}
		if (!hasNamespace && !hasNonHarmony && !hasNamed) {
			return 9;
		}
		return fakeMap;
	}

	getFakeMapInitStatement(fakeMap) {
		return typeof fakeMap == "object"
			? `var fakeMap = ${JSON.stringify(fakeMap, null, "\t")};`
			: "";
	}

	getReturn(type) {
		if (type === 9) {
			return "__webpack_require__(id)";
		}
		return `__webpack_require__.t(id, ${type})`;
	}

	getReturnModuleObjectSource(fakeMap, fakeMapDataExpression = "fakeMap[id]") {
		if (typeof fakeMap == "number") {
			return `return ${this.getReturn(fakeMap)};`;
		}
		return `return __webpack_require__.t(id, ${fakeMapDataExpression})`;
	}

	getSyncSource(dependencies, id) {
		const map = this.getUserRequestMap(dependencies);
		const fakeMap = this.getFakeMap(dependencies);
		const returnModuleObject = this.getReturnModuleObjectSource(fakeMap);

		return `var map = ${JSON.stringify(map, null, "\t")};
${this.getFakeMapInitStatement(fakeMap)}

function webpackContext(req) {
	var id = webpackContextResolve(req);
	${returnModuleObject}
}
function webpackContextResolve(req) {
	if(__webpack_require__.o(map, req)) return map[req];

	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = ${JSON.stringify(id)};`;
	}

	getWeakSyncSource(dependencies, id) {
		const map = this.getUserRequestMap(dependencies);
		const fakeMap = this.getFakeMap(dependencies);
		const returnModuleObject = this.getReturnModuleObjectSource(fakeMap);

		return `var map = ${JSON.stringify(map, null, "\t")};
${this.getFakeMapInitStatement(fakeMap)}

function webpackContext(req) {
	var id = webpackContextResolve(req);
	if(!__webpack_require__.m[id]) {
		var e = new Error("Module '" + req + "' ('" + id + "') is not available (weak dependency)");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	${returnModuleObject}
}
function webpackContextResolve(req) {
	if(__webpack_require__.o(map, req)) return map[req];

	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
webpackContext.id = ${JSON.stringify(id)};
module.exports = webpackContext;`;
	}

	getAsyncWeakSource(dependencies, id) {
		const map = this.getUserRequestMap(dependencies);
		const fakeMap = this.getFakeMap(dependencies);
		const returnModuleObject = this.getReturnModuleObjectSource(fakeMap);

		return `var map = ${JSON.stringify(map, null, "\t")};
${this.getFakeMapInitStatement(fakeMap)}

function webpackAsyncContext(req) {
	return webpackAsyncContextResolve(req).then(function(id) {
		if(!__webpack_require__.m[id]) {
			var e = new Error("Module '" + req + "' ('" + id + "') is not available (weak dependency)");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		}
		${returnModuleObject}
	});
}
function webpackAsyncContextResolve(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(function() {
		if(!__webpack_require__.o(map, req)) {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		}
		return map[req];
	});
}
webpackAsyncContext.keys = function webpackAsyncContextKeys() {
	return Object.keys(map);
};
webpackAsyncContext.resolve = webpackAsyncContextResolve;
webpackAsyncContext.id = ${JSON.stringify(id)};
module.exports = webpackAsyncContext;`;
	}

	getEagerSource(dependencies, id) {
		const map = this.getUserRequestMap(dependencies);
		const fakeMap = this.getFakeMap(dependencies);
		const thenFunction =
			fakeMap !== 9
				? `function(id) {
		${this.getReturnModuleObjectSource(fakeMap)}
	}`
				: "__webpack_require__";
		return `var map = ${JSON.stringify(map, null, "\t")};
${this.getFakeMapInitStatement(fakeMap)}

function webpackAsyncContext(req) {
	return webpackAsyncContextResolve(req).then(${thenFunction});
}
function webpackAsyncContextResolve(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(function() {
		if(!__webpack_require__.o(map, req)) {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		}
		return map[req];
	});
}
webpackAsyncContext.keys = function webpackAsyncContextKeys() {
	return Object.keys(map);
};
webpackAsyncContext.resolve = webpackAsyncContextResolve;
webpackAsyncContext.id = ${JSON.stringify(id)};
module.exports = webpackAsyncContext;`;
	}

	getLazyOnceSource(block, dependencies, id, runtimeTemplate) {
		const promise = runtimeTemplate.blockPromise({
			block,
			message: "lazy-once context"
		});
		const map = this.getUserRequestMap(dependencies);
		const fakeMap = this.getFakeMap(dependencies);
		const thenFunction =
			fakeMap !== 9
				? `function(id) {
		${this.getReturnModuleObjectSource(fakeMap)};
	}`
				: "__webpack_require__";

		return `var map = ${JSON.stringify(map, null, "\t")};
${this.getFakeMapInitStatement(fakeMap)}

function webpackAsyncContext(req) {
	return webpackAsyncContextResolve(req).then(${thenFunction});
}
function webpackAsyncContextResolve(req) {
	return ${promise}.then(function() {
		if(!__webpack_require__.o(map, req)) {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		}
		return map[req];
	});
}
webpackAsyncContext.keys = function webpackAsyncContextKeys() {
	return Object.keys(map);
};
webpackAsyncContext.resolve = webpackAsyncContextResolve;
webpackAsyncContext.id = ${JSON.stringify(id)};
module.exports = webpackAsyncContext;`;
	}

	getLazySource(blocks, id) {
		let hasMultipleOrNoChunks = false;
		let hasNoChunk = true;
		const fakeMap = this.getFakeMap(blocks.map(b => b.dependencies[0]));
		const hasFakeMap = typeof fakeMap == "object";
		const map = blocks
			.filter(block => block.dependencies[0].module)
			.map(block => {
				const chunks = block.chunkGroup ? block.chunkGroup.chunks : [];
				if (chunks.length > 0) {
					hasNoChunk = false;
				}
				if (chunks.length !== 1) {
					hasMultipleOrNoChunks = true;
				}
				return {
					dependency: block.dependencies[0],
					block: block,
					userRequest: block.dependencies[0].userRequest,
					chunks
				};
			})
			.sort((a, b) => {
				if (a.userRequest === b.userRequest) return 0;
				return a.userRequest < b.userRequest ? -1 : 1;
			})
			.reduce((map, item) => {
				const chunks = item.chunks;

				if (hasNoChunk && !hasFakeMap) {
					map[item.userRequest] = item.dependency.module.id;
				} else {
					const arrayStart = [item.dependency.module.id];
					if (typeof fakeMap == "object") {
						arrayStart.push(fakeMap[item.dependency.module.id]);
					}
					map[item.userRequest] = arrayStart.concat(
						chunks.map(chunk => chunk.id)
					);
				}

				return map;
			}, Object.create(null));

		const shortMode = hasNoChunk && !hasFakeMap;
		const chunksStartPosition = hasFakeMap ? 2 : 1;
		const requestPrefix = hasNoChunk
			? "Promise.resolve()"
			: hasMultipleOrNoChunks
			? `Promise.all(ids.slice(${chunksStartPosition}).map(__webpack_require__.e))`
			: `__webpack_require__.e(ids[${chunksStartPosition}])`;
		const returnModuleObject = this.getReturnModuleObjectSource(
			fakeMap,
			shortMode ? "invalid" : "ids[1]"
		);

		const webpackAsyncContext =
			requestPrefix === "Promise.resolve()"
				? `${shortMode ? "" : ""}
function webpackAsyncContext(req) {
	return Promise.resolve().then(function() {
		if(!__webpack_require__.o(map, req)) {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		}

		${shortMode ? "var id = map[req];" : "var ids = map[req], id = ids[0];"}
		${returnModuleObject}
	});
}`
				: `function webpackAsyncContext(req) {
	if(!__webpack_require__.o(map, req)) {
		return Promise.resolve().then(function() {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}

	var ids = map[req], id = ids[0];
	return ${requestPrefix}.then(function() {
		${returnModuleObject}
	});
}`;

		return `var map = ${JSON.stringify(map, null, "\t")};
${webpackAsyncContext}
webpackAsyncContext.keys = function webpackAsyncContextKeys() {
	return Object.keys(map);
};
webpackAsyncContext.id = ${JSON.stringify(id)};
module.exports = webpackAsyncContext;`;
	}

	getSourceForEmptyContext(id) {
		return `function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = ${JSON.stringify(id)};`;
	}

	getSourceForEmptyAsyncContext(id) {
		return `function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(function() {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	});
}
webpackEmptyAsyncContext.keys = function() { return []; };
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
module.exports = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = ${JSON.stringify(id)};`;
	}

	getSourceString(asyncMode, runtimeTemplate) {
		if (asyncMode === "lazy") {
			if (this.blocks && this.blocks.length > 0) {
				return this.getLazySource(this.blocks, this.id);
			}
			return this.getSourceForEmptyAsyncContext(this.id);
		}
		if (asyncMode === "eager") {
			if (this.dependencies && this.dependencies.length > 0) {
				return this.getEagerSource(this.dependencies, this.id);
			}
			return this.getSourceForEmptyAsyncContext(this.id);
		}
		if (asyncMode === "lazy-once") {
			const block = this.blocks[0];
			if (block) {
				return this.getLazyOnceSource(
					block,
					block.dependencies,
					this.id,
					runtimeTemplate
				);
			}
			return this.getSourceForEmptyAsyncContext(this.id);
		}
		if (asyncMode === "async-weak") {
			if (this.dependencies && this.dependencies.length > 0) {
				return this.getAsyncWeakSource(this.dependencies, this.id);
			}
			return this.getSourceForEmptyAsyncContext(this.id);
		}
		if (asyncMode === "weak") {
			if (this.dependencies && this.dependencies.length > 0) {
				return this.getWeakSyncSource(this.dependencies, this.id);
			}
		}
		if (this.dependencies && this.dependencies.length > 0) {
			return this.getSyncSource(this.dependencies, this.id);
		}
		return this.getSourceForEmptyContext(this.id);
	}

	getSource(sourceString) {
		if (this.useSourceMap) {
			return new OriginalSource(sourceString, this.identifier());
		}
		return new RawSource(sourceString);
	}

	source(dependencyTemplates, runtimeTemplate) {
		return this.getSource(
			this.getSourceString(this.options.mode, runtimeTemplate)
		);
	}

	size() {
		const initialSize = 160;

		return this.dependencies.reduce((size, dependency) => {
			const element = (dependency);
			return size + 5 + element.userRequest.length;
		}, initialSize);
	}
}

Object.defineProperty(ContextModule.prototype, "recursive", {
	configurable: false,
	get: util.deprecate(
		function() {
			return this.options.recursive;
		},
		"ContextModule.recursive has been moved to ContextModule.options.recursive"
	),
	set: util.deprecate(
		function(value) {
			this.options.recursive = value;
		},
		"ContextModule.recursive has been moved to ContextModule.options.recursive"
	)
});

Object.defineProperty(ContextModule.prototype, "regExp", {
	configurable: false,
	get: util.deprecate(
		function() {
			return this.options.regExp;
		},
		"ContextModule.regExp has been moved to ContextModule.options.regExp"
	),
	set: util.deprecate(
		function(value) {
			this.options.regExp = value;
		},
		"ContextModule.regExp has been moved to ContextModule.options.regExp"
	)
});

Object.defineProperty(ContextModule.prototype, "addon", {
	configurable: false,
	get: util.deprecate(
		function() {
			return this.options.addon;
		},
		"ContextModule.addon has been moved to ContextModule.options.addon"
	),
	set: util.deprecate(
		function(value) {
			this.options.addon = value;
		},
		"ContextModule.addon has been moved to ContextModule.options.addon"
	)
});

Object.defineProperty(ContextModule.prototype, "async", {
	configurable: false,
	get: util.deprecate(
		function() {
			return this.options.mode;
		},
		"ContextModule.async has been moved to ContextModule.options.mode"
	),
	set: util.deprecate(
		function(value) {
			this.options.mode = value;
		},
		"ContextModule.async has been moved to ContextModule.options.mode"
	)
});

Object.defineProperty(ContextModule.prototype, "chunkName", {
	configurable: false,
	get: util.deprecate(
		function() {
			return this.options.chunkName;
		},
		"ContextModule.chunkName has been moved to ContextModule.options.chunkName"
	),
	set: util.deprecate(
		function(value) {
			this.options.chunkName = value;
		},
		"ContextModule.chunkName has been moved to ContextModule.options.chunkName"
	)
});

module.exports = ContextModule;

},
// 184
function(module, exports, __webpack_require__) {

const { Tapable, HookMap, SyncHook, SyncWaterfallHook } = __webpack_require__(6);
const Factory = __webpack_require__(24).ResolverFactory;
const { cachedCleverMerge } = __webpack_require__(55);

const EMTPY_RESOLVE_OPTIONS = {};

module.exports = class extends Tapable {
	constructor() {
		super();
		this.hooks = {
			resolveOptions: new HookMap(
				() => new SyncWaterfallHook(["resolveOptions"])
			),
			resolver: new HookMap(() => new SyncHook(["resolver", "resolveOptions"]))
		};
		this._pluginCompat.tap("ResolverFactory", options => {
			let match;
			match = /^resolve-options (.+)$/.exec(options.name);
			if (match) {
				this.hooks.resolveOptions
					.for(match[1])
					.tap(options.fn.name || "unnamed compat plugin", options.fn);
				return true;
			}
			match = /^resolver (.+)$/.exec(options.name);
			if (match) {
				this.hooks.resolver
					.for(match[1])
					.tap(options.fn.name || "unnamed compat plugin", options.fn);
				return true;
			}
		});
		this.cache2 = new Map();
	}

	get(type, resolveOptions) {
		resolveOptions = resolveOptions || EMTPY_RESOLVE_OPTIONS;
		const ident = `${type}|${JSON.stringify(resolveOptions)}`;
		const resolver = this.cache2.get(ident);
		if (resolver) return resolver;
		const newResolver = this._create(type, resolveOptions);
		this.cache2.set(ident, newResolver);
		return newResolver;
	}

	_create(type, resolveOptions) {
		const originalResolveOptions = Object.assign({}, resolveOptions);
		resolveOptions = this.hooks.resolveOptions.for(type).call(resolveOptions);
		const resolver = Factory.createResolver(resolveOptions);
		if (!resolver) {
			throw new Error("No resolver created");
		}
		const childCache = new Map();
		resolver.withOptions = options => {
			const cacheEntry = childCache.get(options);
			if (cacheEntry !== void 0) return cacheEntry;
			const mergedOptions = cachedCleverMerge(originalResolveOptions, options);
			const resolver = this.get(type, mergedOptions);
			childCache.set(options, resolver);
			return resolver;
		};
		this.hooks.resolver.for(type).call(resolver, resolveOptions);
		return resolver;
	}
};

},
// 185
function(module, exports, __webpack_require__) {

const { Tapable, SyncHook, MultiHook } = __webpack_require__(6);
const asyncLib = __webpack_require__(12);
const MultiWatching = __webpack_require__(186);
const MultiStats = __webpack_require__(187);
const ConcurrentCompilationError = __webpack_require__(79);

module.exports = class extends Tapable {
	constructor(compilers) {
		super();
		this.hooks = {
			done: new SyncHook(["stats"]),
			invalid: new MultiHook(compilers.map(c => c.hooks.invalid)),
			run: new MultiHook(compilers.map(c => c.hooks.run)),
			watchClose: new SyncHook([]),
			watchRun: new MultiHook(compilers.map(c => c.hooks.watchRun)),
			infrastructureLog: new MultiHook(
				compilers.map(c => c.hooks.infrastructureLog)
			)
		};
		if (!Array.isArray(compilers)) {
			compilers = Object.keys(compilers).map(name => {
				compilers[name].name = name;
				return compilers[name];
			});
		}
		this.compilers = compilers;
		let doneCompilers = 0;
		let compilerStats = [];
		let index = 0;
		for (const compiler of this.compilers) {
			let compilerDone = false;
			const compilerIndex = index++;
			compiler.hooks.done.tap("MultiCompiler", stats => {
				if (!compilerDone) {
					compilerDone = true;
					doneCompilers++;
				}
				compilerStats[compilerIndex] = stats;
				if (doneCompilers === this.compilers.length) {
					this.hooks.done.call(new MultiStats(compilerStats));
				}
			});
			compiler.hooks.invalid.tap("MultiCompiler", () => {
				if (compilerDone) {
					compilerDone = false;
					doneCompilers--;
				}
			});
		}
		this.running = false;
	}

	get outputPath() {
		let commonPath = this.compilers[0].outputPath;
		for (const compiler of this.compilers) {
			while (
				compiler.outputPath.indexOf(commonPath) !== 0 &&
				/[/\\]/.test(commonPath)
			) {
				commonPath = commonPath.replace(/[/\\][^/\\]*$/, "");
			}
		}

		if (!commonPath && this.compilers[0].outputPath[0] === "/") return "/";
		return commonPath;
	}

	get inputFileSystem() {
		throw new Error("Cannot read inputFileSystem of a MultiCompiler");
	}

	get outputFileSystem() {
		throw new Error("Cannot read outputFileSystem of a MultiCompiler");
	}

	set inputFileSystem(value) {
		for (const compiler of this.compilers) {
			compiler.inputFileSystem = value;
		}
	}

	set outputFileSystem(value) {
		for (const compiler of this.compilers) {
			compiler.outputFileSystem = value;
		}
	}

	getInfrastructureLogger(name) {
		return this.compilers[0].getInfrastructureLogger(name);
	}

	validateDependencies(callback) {
		const edges = new Set();
		const missing = [];
		const targetFound = compiler => {
			for (const edge of edges) {
				if (edge.target === compiler) {
					return true;
				}
			}
			return false;
		};
		const sortEdges = (e1, e2) => {
			return (
				e1.source.name.localeCompare(e2.source.name) ||
				e1.target.name.localeCompare(e2.target.name)
			);
		};
		for (const source of this.compilers) {
			if (source.dependencies) {
				for (const dep of source.dependencies) {
					const target = this.compilers.find(c => c.name === dep);
					if (!target) {
						missing.push(dep);
					} else {
						edges.add({
							source,
							target
						});
					}
				}
			}
		}
		const errors = missing.map(m => `Compiler dependency \`${m}\` not found.`);
		const stack = this.compilers.filter(c => !targetFound(c));
		while (stack.length > 0) {
			const current = stack.pop();
			for (const edge of edges) {
				if (edge.source === current) {
					edges.delete(edge);
					const target = edge.target;
					if (!targetFound(target)) {
						stack.push(target);
					}
				}
			}
		}
		if (edges.size > 0) {
			const lines = Array.from(edges)
				.sort(sortEdges)
				.map(edge => `${edge.source.name} -> ${edge.target.name}`);
			lines.unshift("Circular dependency found in compiler dependencies.");
			errors.unshift(lines.join("\n"));
		}
		if (errors.length > 0) {
			const message = errors.join("\n");
			callback(new Error(message));
			return false;
		}
		return true;
	}

	runWithDependencies(compilers, fn, callback) {
		const fulfilledNames = new Set();
		let remainingCompilers = compilers;
		const isDependencyFulfilled = d => fulfilledNames.has(d);
		const getReadyCompilers = () => {
			let readyCompilers = [];
			let list = remainingCompilers;
			remainingCompilers = [];
			for (const c of list) {
				const ready =
					!c.dependencies || c.dependencies.every(isDependencyFulfilled);
				if (ready) {
					readyCompilers.push(c);
				} else {
					remainingCompilers.push(c);
				}
			}
			return readyCompilers;
		};
		const runCompilers = callback => {
			if (remainingCompilers.length === 0) return callback();
			asyncLib.map(
				getReadyCompilers(),
				(compiler, callback) => {
					fn(compiler, err => {
						if (err) return callback(err);
						fulfilledNames.add(compiler.name);
						runCompilers(callback);
					});
				},
				callback
			);
		};
		runCompilers(callback);
	}

	watch(watchOptions, handler) {
		if (this.running) return handler(new ConcurrentCompilationError());

		let watchings = [];
		let allStats = this.compilers.map(() => null);
		let compilerStatus = this.compilers.map(() => false);
		if (this.validateDependencies(handler)) {
			this.running = true;
			this.runWithDependencies(
				this.compilers,
				(compiler, callback) => {
					const compilerIdx = this.compilers.indexOf(compiler);
					let firstRun = true;
					let watching = compiler.watch(
						Array.isArray(watchOptions)
							? watchOptions[compilerIdx]
							: watchOptions,
						(err, stats) => {
							if (err) handler(err);
							if (stats) {
								allStats[compilerIdx] = stats;
								compilerStatus[compilerIdx] = "new";
								if (compilerStatus.every(Boolean)) {
									const freshStats = allStats.filter((s, idx) => {
										return compilerStatus[idx] === "new";
									});
									compilerStatus.fill(true);
									const multiStats = new MultiStats(freshStats);
									handler(null, multiStats);
								}
							}
							if (firstRun && !err) {
								firstRun = false;
								callback();
							}
						}
					);
					watchings.push(watching);
				},
				() => {}
			);
		}

		return new MultiWatching(watchings, this);
	}

	run(callback) {
		if (this.running) {
			return callback(new ConcurrentCompilationError());
		}

		const finalCallback = (err, stats) => {
			this.running = false;

			if (callback !== void 0) {
				return callback(err, stats);
			}
		};

		const allStats = this.compilers.map(() => null);
		if (this.validateDependencies(callback)) {
			this.running = true;
			this.runWithDependencies(
				this.compilers,
				(compiler, callback) => {
					const compilerIdx = this.compilers.indexOf(compiler);
					compiler.run((err, stats) => {
						if (err) {
							return callback(err);
						}
						allStats[compilerIdx] = stats;
						callback();
					});
				},
				err => {
					if (err) {
						return finalCallback(err);
					}
					finalCallback(null, new MultiStats(allStats));
				}
			);
		}
	}

	purgeInputFileSystem() {
		for (const compiler of this.compilers) {
			if (compiler.inputFileSystem && compiler.inputFileSystem.purge) {
				compiler.inputFileSystem.purge();
			}
		}
	}
};

},
// 186
function(module, exports, __webpack_require__) {

const asyncLib = __webpack_require__(12);

class MultiWatching {
	constructor(watchings, compiler) {
		this.watchings = watchings;
		this.compiler = compiler;
	}

	invalidate() {
		for (const watching of this.watchings) {
			watching.invalidate();
		}
	}

	suspend() {
		for (const watching of this.watchings) {
			watching.suspend();
		}
	}

	resume() {
		for (const watching of this.watchings) {
			watching.resume();
		}
	}

	close(callback) {
		asyncLib.forEach(
			this.watchings,
			(watching, finishedCallback) => {
				watching.close(finishedCallback);
			},
			err => {
				this.compiler.hooks.watchClose.call();
				if (typeof callback == "function") {
					this.compiler.running = false;
					callback(err);
				}
			}
		);
	}
}

module.exports = MultiWatching;

},
// 187
function(module, exports, __webpack_require__) {

const Stats = __webpack_require__(23);

const optionOrFallback = (optionValue, fallbackValue) =>
	optionValue !== void 0 ? optionValue : fallbackValue;

class MultiStats {
	constructor(stats) {
		this.stats = stats;
		this.hash = stats.map(stat => stat.hash).join("");
	}

	hasErrors() {
		return this.stats
			.map(stat => stat.hasErrors())
			.reduce((a, b) => a || b, false);
	}

	hasWarnings() {
		return this.stats
			.map(stat => stat.hasWarnings())
			.reduce((a, b) => a || b, false);
	}

	toJson(options, forToString) {
		if (typeof options == "boolean" || typeof options == "string") {
			options = Stats.presetToOptions(options);
		} else if (!options) {
			options = {};
		}
		const jsons = this.stats.map((stat, idx) => {
			const childOptions = Stats.getChildOptions(options, idx);
			const obj = stat.toJson(childOptions, forToString);
			obj.name = stat.compilation && stat.compilation.name;
			return obj;
		});
		const showVersion =
			options.version === void 0
				? jsons.every(j => j.version)
				: options.version !== false;
		const showHash =
			options.hash === void 0
				? jsons.every(j => j.hash)
				: options.hash !== false;
		if (showVersion) {
			for (const j of jsons) {
				delete j.version;
			}
		}
		const obj = {
			errors: jsons.reduce((arr, j) => {
				return arr.concat(
					j.errors.map(msg => {
						return `(${j.name}) ${msg}`;
					})
				);
			}, []),
			warnings: jsons.reduce((arr, j) => {
				return arr.concat(
					j.warnings.map(msg => {
						return `(${j.name}) ${msg}`;
					})
				);
			}, [])
		};
		if (showVersion) obj.version = __webpack_require__(53).version;
		if (showHash) obj.hash = this.hash;
		if (options.children !== false) obj.children = jsons;
		return obj;
	}

	toString(options) {
		if (typeof options == "boolean" || typeof options == "string") {
			options = Stats.presetToOptions(options);
		} else if (!options) {
			options = {};
		}

		const useColors = optionOrFallback(options.colors, false);

		const obj = this.toJson(options, true);

		return Stats.jsonToString(obj, useColors);
	}
}

module.exports = MultiStats;

},
// 188
function(module, exports, __webpack_require__) {

const NodeWatchFileSystem = __webpack_require__(189);
const NodeOutputFileSystem = __webpack_require__(195);
const NodeJsInputFileSystem = __webpack_require__(24).NodeJsInputFileSystem;
const CachedInputFileSystem = __webpack_require__(24).CachedInputFileSystem;
const createConsoleLogger = __webpack_require__(196);
const nodeConsole = __webpack_require__(197);

class NodeEnvironmentPlugin {
	constructor(options) {
		this.options = options || {};
	}

	apply(compiler) {
		compiler.infrastructureLogger = createConsoleLogger(
			Object.assign(
				{
					level: "info",
					debug: false,
					console: nodeConsole
				},
				this.options.infrastructureLogging
			)
		);
		compiler.inputFileSystem = new CachedInputFileSystem(
			new NodeJsInputFileSystem(),
			60000
		);
		const inputFileSystem = compiler.inputFileSystem;
		compiler.outputFileSystem = new NodeOutputFileSystem();
		compiler.watchFileSystem = new NodeWatchFileSystem(
			compiler.inputFileSystem
		);
		compiler.hooks.beforeRun.tap("NodeEnvironmentPlugin", compiler => {
			if (compiler.inputFileSystem === inputFileSystem) inputFileSystem.purge();
		});
	}
}
module.exports = NodeEnvironmentPlugin;

},
// 189
function(module, exports, __webpack_require__) {

const Watchpack = __webpack_require__(190);
const objectToMap = __webpack_require__(194);

class NodeWatchFileSystem {
	constructor(inputFileSystem) {
		this.inputFileSystem = inputFileSystem;
		this.watcherOptions = {
			aggregateTimeout: 0
		};
		this.watcher = new Watchpack(this.watcherOptions);
	}

	watch(files, dirs, missing, startTime, options, callback, callbackUndelayed) {
		if (!Array.isArray(files)) {
			throw new Error("Invalid arguments: 'files'");
		}
		if (!Array.isArray(dirs)) {
			throw new Error("Invalid arguments: 'dirs'");
		}
		if (!Array.isArray(missing)) {
			throw new Error("Invalid arguments: 'missing'");
		}
		if (typeof callback != "function") {
			throw new Error("Invalid arguments: 'callback'");
		}
		if (typeof startTime != "number" && startTime) {
			throw new Error("Invalid arguments: 'startTime'");
		}
		if (typeof options != "object") {
			throw new Error("Invalid arguments: 'options'");
		}
		if (typeof callbackUndelayed != "function" && callbackUndelayed) {
			throw new Error("Invalid arguments: 'callbackUndelayed'");
		}
		const oldWatcher = this.watcher;
		this.watcher = new Watchpack(options);

		if (callbackUndelayed) {
			this.watcher.once("change", callbackUndelayed);
		}
		const cachedFiles = files;
		const cachedDirs = dirs;
		this.watcher.once("aggregated", (changes, removals) => {
			changes = changes.concat(removals);
			if (this.inputFileSystem && this.inputFileSystem.purge) {
				this.inputFileSystem.purge(changes);
			}
			const times = objectToMap(this.watcher.getTimes());
			files = new Set(files);
			dirs = new Set(dirs);
			missing = new Set(missing);
			removals = new Set(removals.filter(file => files.has(file)));
			callback(
				null,
				changes.filter(file => files.has(file)).sort(),
				changes.filter(file => dirs.has(file)).sort(),
				changes.filter(file => missing.has(file)).sort(),
				times,
				times,
				removals
			);
		});

		this.watcher.watch(
			cachedFiles.concat(missing),
			cachedDirs.concat(missing),
			startTime
		);

		if (oldWatcher) {
			oldWatcher.close();
		}
		return {
			close: () => {
				if (this.watcher) {
					this.watcher.close();
					this.watcher = null;
				}
			},
			pause: () => {
				if (this.watcher) {
					this.watcher.pause();
				}
			},
			getFileTimestamps: () => {
				if (this.watcher) {
					return objectToMap(this.watcher.getTimes());
				} else {
					return new Map();
				}
			},
			getContextTimestamps: () => {
				if (this.watcher) {
					return objectToMap(this.watcher.getTimes());
				} else {
					return new Map();
				}
			}
		};
	}
}

module.exports = NodeWatchFileSystem;

},
// 190
function(module, exports, __webpack_require__) {

var watcherManager = __webpack_require__(80),
	EventEmitter = __webpack_require__(81).EventEmitter;

function Watchpack(options) {
	EventEmitter.call(this);
	options || (options = {});
	options.aggregateTimeout || (options.aggregateTimeout = 200);
	this.options = options;
	this.watcherOptions = { ignored: options.ignored, poll: options.poll };
	this.fileWatchers = [];
	this.dirWatchers = [];
	this.mtimes = Object.create(null);
	this.paused = false;
	this.aggregatedChanges = [];
	this.aggregatedRemovals = [];
	this.aggregateTimeout = 0;
	this._onTimeout = this._onTimeout.bind(this);
}

module.exports = Watchpack;

Watchpack.prototype = Object.create(EventEmitter.prototype);

Watchpack.prototype.watch = function(files, directories, startTime) {
	this.paused = false;
	var oldFileWatchers = this.fileWatchers,
		oldDirWatchers = this.dirWatchers;
	this.fileWatchers = files.map(function(file) {
		return this._fileWatcher(file, watcherManager.watchFile(file, this.watcherOptions, startTime));
	}, this);
	this.dirWatchers = directories.map(function(dir) {
		return this._dirWatcher(dir, watcherManager.watchDirectory(dir, this.watcherOptions, startTime));
	}, this);
	oldFileWatchers.forEach(function(w) {
		w.close();
	}, this);
	oldDirWatchers.forEach(function(w) {
		w.close();
	}, this);
};

Watchpack.prototype.close = function() {
	this.paused = true;
	this.aggregateTimeout && clearTimeout(this.aggregateTimeout);
	this.fileWatchers.forEach(function(w) {
		w.close();
	}, this);
	this.dirWatchers.forEach(function(w) {
		w.close();
	}, this);
	this.fileWatchers.length = 0;
	this.dirWatchers.length = 0;
};

Watchpack.prototype.pause = function() {
	this.paused = true;
	this.aggregateTimeout && clearTimeout(this.aggregateTimeout);
};

function addWatchersToArray(watchers, array) {
	watchers.forEach(function(w) {
		if (array.indexOf(w.directoryWatcher) < 0) {
			array.push(w.directoryWatcher);
			addWatchersToArray(Object.keys(w.directoryWatcher.directories).reduce(function(a, dir) {
				w.directoryWatcher.directories[dir] === true ||
					a.push(w.directoryWatcher.directories[dir]);
				return a;
			}, []), array);
		}
	});
}

Watchpack.prototype.getTimes = function() {
	var directoryWatchers = [];
	addWatchersToArray(this.fileWatchers.concat(this.dirWatchers), directoryWatchers);
	var obj = Object.create(null);
	directoryWatchers.forEach(function(w) {
		var times = w.getTimes();
		Object.keys(times).forEach(function(file) {
			obj[file] = times[file];
		});
	});
	return obj;
};

Watchpack.prototype._fileWatcher = function(file, watcher) {
	watcher.on("change", function(mtime, type) {
		this._onChange(file, mtime, file, type);
	}.bind(this));
	watcher.on("remove", function(type) {
		this._onRemove(file, file, type);
	}.bind(this));
	return watcher;
};

Watchpack.prototype._dirWatcher = function(item, watcher) {
	watcher.on("change", function(file, mtime, type) {
		this._onChange(item, mtime, file, type);
	}.bind(this));
	return watcher;
};

Watchpack.prototype._onChange = function(item, mtime, file) {
	file = file || item;
	this.mtimes[file] = mtime;
	if (this.paused) return;
	this.emit("change", file, mtime);
	this.aggregateTimeout && clearTimeout(this.aggregateTimeout);
	this.aggregatedChanges.indexOf(item) < 0 && this.aggregatedChanges.push(item);
	this.aggregateTimeout = setTimeout(this._onTimeout, this.options.aggregateTimeout);
};

Watchpack.prototype._onRemove = function(item, file) {
	file = file || item;
	delete this.mtimes[item];
	if (this.paused) return;
	this.emit("remove", item);
	this.aggregateTimeout && clearTimeout(this.aggregateTimeout);
	this.aggregatedRemovals.indexOf(item) < 0 && this.aggregatedRemovals.push(item);
	this.aggregateTimeout = setTimeout(this._onTimeout, this.options.aggregateTimeout);
};

Watchpack.prototype._onTimeout = function() {
	this.aggregateTimeout = 0;
	var changes = this.aggregatedChanges,
		removals = this.aggregatedRemovals;
	this.aggregatedChanges = [];
	this.aggregatedRemovals = [];
	this.emit("aggregated", changes, removals);
};

},
// 191
function(module, exports, __webpack_require__) {

var EventEmitter = __webpack_require__(81).EventEmitter,
	async = __webpack_require__(12),
	chokidar = __webpack_require__(192),
	fs = __webpack_require__(193),
	path = __webpack_require__(3),

	watcherManager = __webpack_require__(80),

	FS_ACCURACY = 1000;

function withoutCase(str) {
	return str.toLowerCase();
}

function Watcher(directoryWatcher, filePath, startTime) {
	EventEmitter.call(this);
	this.directoryWatcher = directoryWatcher;
	this.path = filePath;
	this.startTime = startTime && +startTime;
	this.data = 0;
}

Watcher.prototype = Object.create(EventEmitter.prototype);
Watcher.prototype.constructor = Watcher;

Watcher.prototype.checkStartTime = function(mtime, initial) {
	return typeof this.startTime != "number" ? !initial : this.startTime <= mtime;
};

Watcher.prototype.close = function() {
	this.emit("closed");
};

function DirectoryWatcher(directoryPath, options) {
	EventEmitter.call(this);
	this.options = options;
	this.path = directoryPath;
	this.files = Object.create(null);
	this.directories = Object.create(null);
	var interval = typeof options.poll == "number" ? options.poll : void 0;
	this.watcher = chokidar.watch(directoryPath, {
		ignoreInitial: true,
		persistent: true,
		followSymlinks: false,
		depth: 0,
		atomic: false,
		alwaysStat: true,
		ignorePermissionErrors: true,
		ignored: options.ignored,
		usePolling: options.poll ? true : void 0,
		interval: interval,
		binaryInterval: interval,
		disableGlobbing: true
	});
	this.watcher.on("add", this.onFileAdded.bind(this));
	this.watcher.on("addDir", this.onDirectoryAdded.bind(this));
	this.watcher.on("change", this.onChange.bind(this));
	this.watcher.on("unlink", this.onFileUnlinked.bind(this));
	this.watcher.on("unlinkDir", this.onDirectoryUnlinked.bind(this));
	this.watcher.on("error", this.onWatcherError.bind(this));
	this.initialScan = true;
	this.nestedWatching = false;
	this.initialScanRemoved = [];
	this.doInitialScan();
	this.watchers = Object.create(null);
	this.parentWatcher = null;
	this.refs = 0;
}
module.exports = DirectoryWatcher;

DirectoryWatcher.prototype = Object.create(EventEmitter.prototype);
DirectoryWatcher.prototype.constructor = DirectoryWatcher;

DirectoryWatcher.prototype.setFileTime = function(filePath, mtime, initial, type) {
	var now = Date.now(),
		old = this.files[filePath];

	this.files[filePath] = [initial ? Math.min(now, mtime) : now, mtime];

	if (mtime) mtime += FS_ACCURACY;

	!old
		? mtime && this.watchers[withoutCase(filePath)] &&
			this.watchers[withoutCase(filePath)].forEach(function(w) {
				(initial && !w.checkStartTime(mtime, initial)) ||
					w.emit("change", mtime, initial ? "initial" : type);
			})
		: !initial && mtime
		? this.watchers[withoutCase(filePath)] &&
			this.watchers[withoutCase(filePath)].forEach(function(w) {
				w.emit("change", mtime, type);
			})
		: initial || mtime || !this.watchers[withoutCase(filePath)] ||
			this.watchers[withoutCase(filePath)].forEach(function(w) {
				w.emit("remove", type);
			});

	this.watchers[withoutCase(this.path)] &&
		this.watchers[withoutCase(this.path)].forEach(function(w) {
			(initial && !w.checkStartTime(mtime, initial)) ||
				w.emit("change", filePath, mtime, initial ? "initial" : type);
		});
};

DirectoryWatcher.prototype.setDirectory = function(directoryPath, exist, initial, type) {
	if (directoryPath === this.path)
		initial || !this.watchers[withoutCase(this.path)] ||
			this.watchers[withoutCase(this.path)].forEach(function(w) {
				w.emit("change", directoryPath, w.data, initial ? "initial" : type);
			});
	else if (!this.directories[directoryPath]) {
		if (exist) {
			this.nestedWatching
				? this.createNestedWatcher(directoryPath)
				: (this.directories[directoryPath] = true);

			initial || !this.watchers[withoutCase(this.path)] ||
				this.watchers[withoutCase(this.path)].forEach(function(w) {
					w.emit("change", directoryPath, w.data, initial ? "initial" : type);
				});

			this.watchers[withoutCase(directoryPath) + "#directory"] &&
				this.watchers[withoutCase(directoryPath) + "#directory"].forEach(function(w) {
					w.emit("change", w.data, initial ? "initial" : type);
				});
		}
	} else if (!exist) {
		this.nestedWatching && this.directories[directoryPath].close();
		delete this.directories[directoryPath];
		initial || !this.watchers[withoutCase(this.path)] ||
			this.watchers[withoutCase(this.path)].forEach(function(w) {
				w.emit("change", directoryPath, w.data, initial ? "initial" : type);
			});

		this.watchers[withoutCase(directoryPath) + "#directory"] &&
			this.watchers[withoutCase(directoryPath) + "#directory"].forEach(function(w) {
				w.emit("change", directoryPath, w.data, initial ? "initial" : type);
			});
	}
};

DirectoryWatcher.prototype.createNestedWatcher = function(directoryPath) {
	this.directories[directoryPath] = watcherManager.watchDirectory(directoryPath, this.options, 1);
	this.directories[directoryPath].on("change", function(filePath, mtime, type) {
		this.watchers[withoutCase(this.path)] &&
			this.watchers[withoutCase(this.path)].forEach(function(w) {
				w.checkStartTime(mtime, false) && w.emit("change", filePath, mtime, type);
			});
	}.bind(this));
};

DirectoryWatcher.prototype.setNestedWatching = function(flag) {
	if (this.nestedWatching !== !!flag) {
		this.nestedWatching = !!flag;
		if (this.nestedWatching)
			Object.keys(this.directories).forEach(function(directory) {
				this.createNestedWatcher(directory);
			}, this);
		else
			Object.keys(this.directories).forEach(function(directory) {
				this.directories[directory].close();
				this.directories[directory] = true;
			}, this);
	}
};

DirectoryWatcher.prototype.watch = function(filePath, startTime) {
	this.watchers[withoutCase(filePath)] = this.watchers[withoutCase(filePath)] || [];
	this.refs++;
	var watcher = new Watcher(this, filePath, startTime);
	watcher.on("closed", function() {
		var idx = this.watchers[withoutCase(filePath)].indexOf(watcher);
		this.watchers[withoutCase(filePath)].splice(idx, 1);
		if (this.watchers[withoutCase(filePath)].length === 0) {
			delete this.watchers[withoutCase(filePath)];
			this.path !== filePath || this.setNestedWatching(false);
		}
		--this.refs > 0 || this.close();
	}.bind(this));
	this.watchers[withoutCase(filePath)].push(watcher);
	var data;
	if (filePath === this.path) {
		this.setNestedWatching(true);
		data = false;
		Object.keys(this.files).forEach(function(file) {
			var d = this.files[file];
			data ? (data = [Math.max(data[0], d[0]), Math.max(data[1], d[1])]) : (data = d);
		}, this);
	} else data = this.files[filePath];

	process.nextTick(function() {
		data
			? (data[0] === data[1] ? data[0] + FS_ACCURACY : data[0]) >= startTime &&
				watcher.emit("change", data[1])
			: this.initialScan && this.initialScanRemoved.indexOf(filePath) >= 0 &&
				watcher.emit("remove");
	}.bind(this));
	return watcher;
};

DirectoryWatcher.prototype.onFileAdded = function(filePath, stat) {
	filePath.indexOf(this.path) !== 0 ||
		/[\\\/]/.test(filePath.substr(this.path.length + 1)) ||
		this.setFileTime(filePath, +stat.mtime || +stat.ctime || 1, false, "add");
};

DirectoryWatcher.prototype.onDirectoryAdded = function(directoryPath) {
	directoryPath.indexOf(this.path) !== 0 ||
		/[\\\/]/.test(directoryPath.substr(this.path.length + 1)) ||
		this.setDirectory(directoryPath, true, false, "add");
};

DirectoryWatcher.prototype.onChange = function(filePath, stat) {
	if (filePath.indexOf(this.path) !== 0 || /[\\\/]/.test(filePath.substr(this.path.length + 1)))
		return;
	var mtime = +stat.mtime || +stat.ctime || 1;
	ensureFsAccuracy(mtime);
	this.setFileTime(filePath, mtime, false, "change");
};

DirectoryWatcher.prototype.onFileUnlinked = function(filePath) {
	if (filePath.indexOf(this.path) !== 0 || /[\\\/]/.test(filePath.substr(this.path.length + 1)))
		return;
	this.setFileTime(filePath, null, false, "unlink");
	this.initialScan && this.initialScanRemoved.push(filePath);
};

DirectoryWatcher.prototype.onDirectoryUnlinked = function(directoryPath) {
	if (directoryPath.indexOf(this.path) !== 0 || /[\\\/]/.test(directoryPath.substr(this.path.length + 1)))
		return;
	this.setDirectory(directoryPath, false, false, "unlink");
	this.initialScan && this.initialScanRemoved.push(directoryPath);
};

DirectoryWatcher.prototype.onWatcherError = function(err) {
	console.warn("Error from chokidar (" + this.path + "): " + err);
};

DirectoryWatcher.prototype.doInitialScan = function() {
	fs.readdir(this.path, function(err, items) {
		if (err) {
			this.parentWatcher = watcherManager.watchFile(this.path + "#directory", this.options, 1);
			this.parentWatcher.on("change", function(mtime, type) {
				this.watchers[withoutCase(this.path)] &&
					this.watchers[withoutCase(this.path)].forEach(function(w) {
						w.emit("change", this.path, mtime, type);
					}, this);
			}.bind(this));
			this.initialScan = false;
			return;
		}
		async.forEach(items, function(item, callback) {
			var itemPath = path.join(this.path, item);
			fs.stat(itemPath, function(err2, stat) {
				if (!this.initialScan) return;
				if (err2) {
					callback();
					return;
				}
				stat.isFile()
					? this.files[itemPath] ||
						this.setFileTime(itemPath, +stat.mtime || +stat.ctime || 1, true)
					: !stat.isDirectory() ||
						this.directories[itemPath] || this.setDirectory(itemPath, true, true);

				callback();
			}.bind(this));
		}.bind(this), function() {
			this.initialScan = false;
			this.initialScanRemoved = null;
		}.bind(this));
	}.bind(this));
};

DirectoryWatcher.prototype.getTimes = function() {
	var obj = Object.create(null),
		selfTime = 0;
	Object.keys(this.files).forEach(function(file) {
		var data = this.files[file],
			time = data[1] ? Math.max(data[0], data[1] + FS_ACCURACY) : data[0];

		obj[file] = time;
		if (time > selfTime) selfTime = time;
	}, this);
	if (this.nestedWatching) {
		Object.keys(this.directories).forEach(function(dir) {
			var times = this.directories[dir].directoryWatcher.getTimes();
			Object.keys(times).forEach(function(file) {
				var time = times[file];
				obj[file] = time;
				if (time > selfTime) selfTime = time;
			});
		}, this);
		obj[this.path] = selfTime;
	}
	return obj;
};

DirectoryWatcher.prototype.close = function() {
	this.initialScan = false;
	var p = this.watcher.close();
	p && p.catch && p.catch(this.onWatcherError.bind(this));
	this.nestedWatching &&
		Object.keys(this.directories).forEach(function(dir) {
			this.directories[dir].close();
		}, this);

	this.parentWatcher && this.parentWatcher.close();
	this.emit("closed");
};

function ensureFsAccuracy(mtime) {
	if (!mtime) return;
	if (FS_ACCURACY > 1 && mtime % 1 != 0) FS_ACCURACY = 1;
	else if (FS_ACCURACY > 10 && mtime % 10 != 0) FS_ACCURACY = 10;
	else if (FS_ACCURACY > 100 && mtime % 100 != 0) FS_ACCURACY = 100;
}

},
// 192
function(module) {

module.exports = require("../vendor/chokidar");

},
// 193
function(module) {

module.exports = require("../vendor/graceful-fs");

},
// 194
function(module) {

module.exports = function(obj) {
	return new Map(Object.keys(obj).map(key => [key, obj[key]]));
};

},
// 195
function(module, exports, __webpack_require__) {

const fs = __webpack_require__(34);
const path = __webpack_require__(3);
const mkdirp = __webpack_require__(82);

class NodeOutputFileSystem {
	constructor() {
		this.mkdirp = mkdirp;
		this.mkdir = fs.mkdir.bind(fs);
		this.rmdir = fs.rmdir.bind(fs);
		this.unlink = fs.unlink.bind(fs);
		this.writeFile = fs.writeFile.bind(fs);
		this.join = path.join.bind(path);
	}
}

module.exports = NodeOutputFileSystem;

},
// 196
function(module, exports, __webpack_require__) {

const { LogType } = __webpack_require__(32);

const filterToFunction = item => {
	if (typeof item == "string") {
		const regExp = new RegExp(
			`[\\\\/]${item.replace(
				/[-[\]{}()*+?.\\^$|]/g,
				"\\$&"
			)}([\\\\/]|$|!|\\?)`
		);
		return ident => regExp.test(ident);
	}
	if (item && typeof item == "object" && typeof item.test == "function") {
		return ident => item.test(ident);
	}
	if (typeof item == "function") {
		return item;
	}
	if (typeof item == "boolean") {
		return () => item;
	}
};

const LogLevel = {
	none: 6,
	false: 6,
	error: 5,
	warn: 4,
	info: 3,
	log: 2,
	true: 2,
	verbose: 1
};

module.exports = ({ level = "info", debug = false, console }) => {
	const debugFilters =
		typeof debug == "boolean"
			? [() => debug]
			: [].concat(debug).map(filterToFunction);
	const loglevel = LogLevel["" + level] || 0;

	const logger = (name, type, args) => {
		const labeledArgs = () => {
			if (Array.isArray(args)) {
				if (args.length > 0 && typeof args[0] == "string") {
					return [`[${name}] ${args[0]}`, ...args.slice(1)];
				} else {
					return [`[${name}]`, ...args];
				}
			} else {
				return [];
			}
		};
		const debug = debugFilters.some(f => f(name));
		switch (type) {
			case LogType.debug:
				if (!debug) return;
				if (typeof console.debug == "function") {
					console.debug(...labeledArgs());
				} else {
					console.log(...labeledArgs());
				}
				break;
			case LogType.log:
				if (!debug && loglevel > LogLevel.log) return;
				console.log(...labeledArgs());
				break;
			case LogType.info:
				if (!debug && loglevel > LogLevel.info) return;
				console.info(...labeledArgs());
				break;
			case LogType.warn:
				if (!debug && loglevel > LogLevel.warn) return;
				console.warn(...labeledArgs());
				break;
			case LogType.error:
				if (!debug && loglevel > LogLevel.error) return;
				console.error(...labeledArgs());
				break;
			case LogType.trace:
				if (!debug) return;
				console.trace();
				break;
			case LogType.groupCollapsed:
				if (!debug && loglevel > LogLevel.log) return;
				if (!debug && loglevel > LogLevel.verbose) {
					if (typeof console.groupCollapsed == "function") {
						console.groupCollapsed(...labeledArgs());
					} else {
						console.log(...labeledArgs());
					}
					break;
				}
			case LogType.group:
				if (!debug && loglevel > LogLevel.log) return;
				if (typeof console.group == "function") {
					console.group(...labeledArgs());
				} else {
					console.log(...labeledArgs());
				}
				break;
			case LogType.groupEnd:
				if (!debug && loglevel > LogLevel.log) return;
				if (typeof console.groupEnd == "function") {
					console.groupEnd();
				}
				break;
			case LogType.time:
				if (!debug && loglevel > LogLevel.log) return;
				const ms = args[1] * 1000 + args[2] / 1000000;
				const msg = `[${name}] ${args[0]}: ${ms}ms`;
				if (typeof console.logTime == "function") {
					console.logTime(msg);
				} else {
					console.log(msg);
				}
				break;

			case LogType.profile:
				if (typeof console.profile == "function") {
					console.profile(...labeledArgs());
				}
				break;
			case LogType.profileEnd:
				if (typeof console.profileEnd == "function") {
					console.profileEnd(...labeledArgs());
				}
				break;
			case LogType.clear:
				if (!debug && loglevel > LogLevel.log) return;
				if (typeof console.clear == "function") {
					console.clear();
				}
				break;
			case LogType.status:
				if (!debug && loglevel > LogLevel.info) return;
				if (typeof console.status == "function") {
					if (args.length === 0) {
						console.status();
					} else {
						console.status(...labeledArgs());
					}
				} else {
					if (args.length !== 0) {
						console.info(...labeledArgs());
					}
				}
				break;
			default:
				throw new Error(`Unexpected LogType ${type}`);
		}
	};
	return logger;
};

},
// 197
function(module, exports, __webpack_require__) {

const truncateArgs = __webpack_require__(198);
const util = __webpack_require__(11);

const tty = process.stderr.isTTY && process.env.TERM !== "dumb";

let currentStatusMessage = void 0;
let hasStatusMessage = false;
let currentIndent = "";
let currentCollapsed = 0;

const indent = (str, prefix, colorPrefix, colorSuffix) => {
	if (str === "") return str;
	prefix = currentIndent + prefix;
	if (tty) {
		return (
			prefix +
			colorPrefix +
			str.replace(/\n/g, colorSuffix + "\n" + prefix + colorPrefix) +
			colorSuffix
		);
	} else {
		return prefix + str.replace(/\n/g, "\n" + prefix);
	}
};

const clearStatusMessage = () => {
	if (hasStatusMessage) {
		process.stderr.write("\x1b[2K\r");
		hasStatusMessage = false;
	}
};

const writeStatusMessage = () => {
	if (!currentStatusMessage) return;
	const l = process.stderr.columns;
	const args = l
		? truncateArgs(currentStatusMessage, l - 1)
		: currentStatusMessage;
	const str = args.join(" ");
	const coloredStr = `\x1b[1m${str}\x1b[39m\x1b[22m`;
	process.stderr.write(`\x1b[2K\r${coloredStr}`);
	hasStatusMessage = true;
};

const writeColored = (prefix, colorPrefix, colorSuffix) => {
	return (...args) => {
		if (currentCollapsed > 0) return;
		clearStatusMessage();
		const str = indent(util.format(...args), prefix, colorPrefix, colorSuffix);
		process.stderr.write(str + "\n");
		writeStatusMessage();
	};
};

const writeGroupMessage = writeColored(
	"<-> ",
	"\x1b[1m\x1b[36m",
	"\x1b[39m\x1b[22m"
);

const writeGroupCollapsedMessage = writeColored(
	"<+> ",
	"\x1b[1m\x1b[36m",
	"\x1b[39m\x1b[22m"
);

module.exports = {
	log: writeColored("    ", "\x1b[1m", "\x1b[22m"),
	debug: writeColored("    ", "", ""),
	trace: writeColored("    ", "", ""),
	info: writeColored("<i> ", "\x1b[1m\x1b[32m", "\x1b[39m\x1b[22m"),
	warn: writeColored("<w> ", "\x1b[1m\x1b[33m", "\x1b[39m\x1b[22m"),
	error: writeColored("<e> ", "\x1b[1m\x1b[31m", "\x1b[39m\x1b[22m"),
	logTime: writeColored("<t> ", "\x1b[1m\x1b[35m", "\x1b[39m\x1b[22m"),
	group: (...args) => {
		writeGroupMessage(...args);
		if (currentCollapsed > 0) {
			currentCollapsed++;
		} else {
			currentIndent += "  ";
		}
	},
	groupCollapsed: (...args) => {
		writeGroupCollapsedMessage(...args);
		currentCollapsed++;
	},
	groupEnd: () => {
		if (currentCollapsed > 0) currentCollapsed--;
		else if (currentIndent.length >= 2)
			currentIndent = currentIndent.slice(0, currentIndent.length - 2);
	},
	profile: console.profile && (name => console.profile(name)),
	profileEnd: console.profileEnd && (name => console.profileEnd(name)),
	clear:
		tty &&
		console.clear &&
		(() => {
			clearStatusMessage();
			console.clear();
			writeStatusMessage();
		}),
	status: tty
		? (name, ...args) => {
				args = args.filter(Boolean);
				if (name === void 0 && args.length === 0) {
					clearStatusMessage();
					currentStatusMessage = void 0;
				} else if (
					typeof name == "string" &&
					name.startsWith("[webpack.Progress] ")
				) {
					currentStatusMessage = [name.slice(19), ...args];
					writeStatusMessage();
				} else if (name === "[webpack.Progress]") {
					currentStatusMessage = [...args];
					writeStatusMessage();
				} else {
					currentStatusMessage = [name, ...args];
					writeStatusMessage();
				}
			}
		: writeColored("<s> ", "", "")
};

},
// 198
function(module, exports, __webpack_require__) {

const truncateArgs = (args, maxLength) => {
	const lengths = args.map(a => `${a}`.length);
	const availableLength = maxLength - lengths.length + 1;

	if (availableLength > 0 && args.length === 1) {
		if (availableLength >= args[0].length) {
			return args;
		} else if (availableLength > 3) {
			return ["..." + args[0].slice(-availableLength + 3)];
		} else {
			return [args[0].slice(-availableLength)];
		}
	}

	if (availableLength < lengths.reduce((s, i) => s + Math.min(i, 6), 0)) {
		if (args.length > 1)
			return truncateArgs(args.slice(0, args.length - 1), maxLength);
		return [];
	}

	let currentLength = lengths.reduce((a, b) => a + b, 0);

	if (currentLength <= availableLength) return args;

	while (currentLength > availableLength) {
		const maxLength = Math.max(...lengths);
		const shorterItems = lengths.filter(l => l !== maxLength);
		const nextToMaxLength =
			shorterItems.length > 0 ? Math.max(...shorterItems) : 0;
		const maxReduce = maxLength - nextToMaxLength;
		let maxItems = lengths.length - shorterItems.length;
		let overrun = currentLength - availableLength;
		for (let i = 0; i < lengths.length; i++) {
			if (lengths[i] === maxLength) {
				const reduce = Math.min(Math.floor(overrun / maxItems), maxReduce);
				lengths[i] -= reduce;
				currentLength -= reduce;
				overrun -= reduce;
				maxItems--;
			}
		}
	}

	return args.map((a, i) => {
		const str = `${a}`;
		const length = lengths[i];
		if (str.length === length) {
			return str;
		} else if (length > 5) {
			return "..." + str.slice(-length + 3);
		} else if (length > 0) {
			return str.slice(-length);
		} else {
			return "";
		}
	});
};

module.exports = truncateArgs;

},
// 199
function(module, exports, __webpack_require__) {

const OptionsApply = __webpack_require__(200);

const JavascriptModulesPlugin = __webpack_require__(201);
const JsonModulesPlugin = __webpack_require__(205);
const WebAssemblyModulesPlugin = __webpack_require__(209);

const LoaderTargetPlugin = __webpack_require__(89);
const FunctionModulePlugin = __webpack_require__(215);
const EvalDevToolModulePlugin = __webpack_require__(90);
const SourceMapDevToolPlugin = __webpack_require__(60);
const EvalSourceMapDevToolPlugin = __webpack_require__(92);

const EntryOptionPlugin = __webpack_require__(220);
const RecordIdsPlugin = __webpack_require__(223);

const APIPlugin = __webpack_require__(224);
const ConstPlugin = __webpack_require__(225);
const CommonJsStuffPlugin = __webpack_require__(226);
const CompatibilityPlugin = __webpack_require__(227);

const TemplatedPathPlugin = __webpack_require__(228);
const WarnCaseSensitiveModulesPlugin = __webpack_require__(229);
const UseStrictPlugin = __webpack_require__(231);

const LoaderPlugin = __webpack_require__(232);
const CommonJsPlugin = __webpack_require__(234);
const HarmonyModulesPlugin = __webpack_require__(240);
const SystemPlugin = __webpack_require__(245);
const ImportPlugin = __webpack_require__(246);
const RequireContextPlugin = __webpack_require__(250);
const RequireEnsurePlugin = __webpack_require__(252);
const RequireIncludePlugin = __webpack_require__(255);

const { cachedCleverMerge } = __webpack_require__(55);

class WebpackOptionsApply extends OptionsApply {
	constructor() {
		super();
	}

	process(options, compiler) {
		let ExternalsPlugin;
		compiler.outputPath = options.output.path;
		compiler.recordsInputPath = options.recordsInputPath || options.recordsPath;
		compiler.recordsOutputPath =
			options.recordsOutputPath || options.recordsPath;
		compiler.name = options.name;
		compiler.dependencies = options.dependencies;
		if (typeof options.target == "string") {
			let JsonpTemplatePlugin;
			let FetchCompileWasmTemplatePlugin;
			let ReadFileCompileWasmTemplatePlugin;
			let NodeSourcePlugin;
			let NodeTargetPlugin;
			let NodeTemplatePlugin;

			switch (options.target) {
				case "web":
					JsonpTemplatePlugin = __webpack_require__(44);
					FetchCompileWasmTemplatePlugin = __webpack_require__(45);
					NodeSourcePlugin = __webpack_require__(118);
					new JsonpTemplatePlugin().apply(compiler);
					new FetchCompileWasmTemplatePlugin({
						mangleImports: options.optimization.mangleWasmImports
					}).apply(compiler);
					new FunctionModulePlugin().apply(compiler);
					new NodeSourcePlugin(options.node).apply(compiler);
					new LoaderTargetPlugin(options.target).apply(compiler);
					break;
				case "webworker":
					let WebWorkerTemplatePlugin = __webpack_require__(119);
					FetchCompileWasmTemplatePlugin = __webpack_require__(45);
					NodeSourcePlugin = __webpack_require__(118);
					new WebWorkerTemplatePlugin().apply(compiler);
					new FetchCompileWasmTemplatePlugin({
						mangleImports: options.optimization.mangleWasmImports
					}).apply(compiler);
					new FunctionModulePlugin().apply(compiler);
					new NodeSourcePlugin(options.node).apply(compiler);
					new LoaderTargetPlugin(options.target).apply(compiler);
					break;

				case "node":
				case "async-node":
					NodeTemplatePlugin = __webpack_require__(46);
					ReadFileCompileWasmTemplatePlugin = __webpack_require__(120);
					NodeTargetPlugin = __webpack_require__(47);
					new NodeTemplatePlugin({
						asyncChunkLoading: options.target === "async-node"
					}).apply(compiler);
					new ReadFileCompileWasmTemplatePlugin({
						mangleImports: options.optimization.mangleWasmImports
					}).apply(compiler);
					new FunctionModulePlugin().apply(compiler);
					new NodeTargetPlugin().apply(compiler);
					new LoaderTargetPlugin("node").apply(compiler);
					break;
				case "node-webkit":
					JsonpTemplatePlugin = __webpack_require__(44);
					NodeTargetPlugin = __webpack_require__(47);
					ExternalsPlugin = __webpack_require__(21);
					new JsonpTemplatePlugin().apply(compiler);
					new FunctionModulePlugin().apply(compiler);
					new NodeTargetPlugin().apply(compiler);
					new ExternalsPlugin("commonjs", "nw.gui").apply(compiler);
					new LoaderTargetPlugin(options.target).apply(compiler);
					break;
				case "electron-main":
					NodeTemplatePlugin = __webpack_require__(46);
					NodeTargetPlugin = __webpack_require__(47);
					ExternalsPlugin = __webpack_require__(21);
					new NodeTemplatePlugin({
						asyncChunkLoading: true
					}).apply(compiler);
					new FunctionModulePlugin().apply(compiler);
					new NodeTargetPlugin().apply(compiler);
					new ExternalsPlugin("commonjs", [
						"app",
						"auto-updater",
						"browser-window",
						"clipboard",
						"content-tracing",
						"crash-reporter",
						"dialog",
						"electron",
						"global-shortcut",
						"ipc",
						"ipc-main",
						"menu",
						"menu-item",
						"native-image",
						"original-fs",
						"power-monitor",
						"power-save-blocker",
						"protocol",
						"screen",
						"session",
						"shell",
						"tray",
						"web-contents"
					]).apply(compiler);
					new LoaderTargetPlugin(options.target).apply(compiler);
					break;
				case "electron-renderer":
				case "electron-preload":
					FetchCompileWasmTemplatePlugin = __webpack_require__(45);
					NodeTargetPlugin = __webpack_require__(47);
					ExternalsPlugin = __webpack_require__(21);
					if (options.target === "electron-renderer") {
						JsonpTemplatePlugin = __webpack_require__(44);
						new JsonpTemplatePlugin().apply(compiler);
					} else if (options.target === "electron-preload") {
						NodeTemplatePlugin = __webpack_require__(46);
						new NodeTemplatePlugin({
							asyncChunkLoading: true
						}).apply(compiler);
					}
					new FetchCompileWasmTemplatePlugin({
						mangleImports: options.optimization.mangleWasmImports
					}).apply(compiler);
					new FunctionModulePlugin().apply(compiler);
					new NodeTargetPlugin().apply(compiler);
					new ExternalsPlugin("commonjs", [
						"clipboard",
						"crash-reporter",
						"desktop-capturer",
						"electron",
						"ipc",
						"ipc-renderer",
						"native-image",
						"original-fs",
						"remote",
						"screen",
						"shell",
						"web-frame"
					]).apply(compiler);
					new LoaderTargetPlugin(options.target).apply(compiler);
					break;
				default:
					throw new Error("Unsupported target '" + options.target + "'.");
			}
		}
		else if (options.target !== false) {
			options.target(compiler);
		} else {
			throw new Error("Unsupported target '" + options.target + "'.");
		}

		if (options.output.library || options.output.libraryTarget !== "var") {
			const LibraryTemplatePlugin = __webpack_require__(122);
			new LibraryTemplatePlugin(
				options.output.library,
				options.output.libraryTarget,
				options.output.umdNamedDefine,
				options.output.auxiliaryComment || "",
				options.output.libraryExport
			).apply(compiler);
		}
		if (options.externals) {
			ExternalsPlugin = __webpack_require__(21);
			new ExternalsPlugin(
				options.output.libraryTarget,
				options.externals
			).apply(compiler);
		}

		let noSources;
		let legacy;
		let modern;
		let comment;
		if (
			options.devtool &&
			(options.devtool.includes("sourcemap") ||
				options.devtool.includes("source-map"))
		) {
			const hidden = options.devtool.includes("hidden");
			const inline = options.devtool.includes("inline");
			const evalWrapped = options.devtool.includes("eval");
			const cheap = options.devtool.includes("cheap");
			const moduleMaps = options.devtool.includes("module");
			noSources = options.devtool.includes("nosources");
			legacy = options.devtool.includes("@");
			modern = options.devtool.includes("#");
			comment =
				legacy && modern
					? "\n/*\n//@ sourceMappingURL=[url]\n//# sourceMappingURL=[url]\n*/"
					: legacy
					? "\n/*\n//@ sourceMappingURL=[url]\n*/"
					: modern
					? "\n//# sourceMappingURL=[url]"
					: null;
			const Plugin = evalWrapped
				? EvalSourceMapDevToolPlugin
				: SourceMapDevToolPlugin;
			new Plugin({
				filename: inline ? null : options.output.sourceMapFilename,
				moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,
				fallbackModuleFilenameTemplate:
					options.output.devtoolFallbackModuleFilenameTemplate,
				append: hidden ? false : comment,
				module: moduleMaps ? true : cheap ? false : true,
				columns: cheap ? false : true,
				lineToLine: options.output.devtoolLineToLine,
				noSources: noSources,
				namespace: options.output.devtoolNamespace
			}).apply(compiler);
		} else if (options.devtool && options.devtool.includes("eval")) {
			legacy = options.devtool.includes("@");
			modern = options.devtool.includes("#");
			comment =
				legacy && modern
					? "\n//@ sourceURL=[url]\n//# sourceURL=[url]"
					: legacy
					? "\n//@ sourceURL=[url]"
					: modern
					? "\n//# sourceURL=[url]"
					: null;
			new EvalDevToolModulePlugin({
				sourceUrlComment: comment,
				moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,
				namespace: options.output.devtoolNamespace
			}).apply(compiler);
		}

		new JavascriptModulesPlugin().apply(compiler);
		new JsonModulesPlugin().apply(compiler);
		new WebAssemblyModulesPlugin({
			mangleImports: options.optimization.mangleWasmImports
		}).apply(compiler);

		new EntryOptionPlugin().apply(compiler);
		compiler.hooks.entryOption.call(options.context, options.entry);

		new CompatibilityPlugin().apply(compiler);
		new HarmonyModulesPlugin(options.module).apply(compiler);
		if (options.amd !== false) {
			const AMDPlugin = __webpack_require__(276);
			const RequireJsStuffPlugin = __webpack_require__(280);
			new AMDPlugin(options.module, options.amd || {}).apply(compiler);
			new RequireJsStuffPlugin().apply(compiler);
		}
		new CommonJsPlugin(options.module).apply(compiler);
		new LoaderPlugin().apply(compiler);
		if (options.node !== false) {
			const NodeStuffPlugin = __webpack_require__(281);
			new NodeStuffPlugin(options.node).apply(compiler);
		}
		new CommonJsStuffPlugin().apply(compiler);
		new APIPlugin().apply(compiler);
		new ConstPlugin().apply(compiler);
		new UseStrictPlugin().apply(compiler);
		new RequireIncludePlugin().apply(compiler);
		new RequireEnsurePlugin().apply(compiler);
		new RequireContextPlugin(
			options.resolve.modules,
			options.resolve.extensions,
			options.resolve.mainFiles
		).apply(compiler);
		new ImportPlugin(options.module).apply(compiler);
		new SystemPlugin(options.module).apply(compiler);

		if (typeof options.mode != "string") {
			const WarnNoModeSetPlugin = __webpack_require__(282);
			new WarnNoModeSetPlugin().apply(compiler);
		}

		const EnsureChunkConditionsPlugin = __webpack_require__(284);
		new EnsureChunkConditionsPlugin().apply(compiler);
		if (options.optimization.removeAvailableModules) {
			const RemoveParentModulesPlugin = __webpack_require__(285);
			new RemoveParentModulesPlugin().apply(compiler);
		}
		if (options.optimization.removeEmptyChunks) {
			const RemoveEmptyChunksPlugin = __webpack_require__(286);
			new RemoveEmptyChunksPlugin().apply(compiler);
		}
		if (options.optimization.mergeDuplicateChunks) {
			const MergeDuplicateChunksPlugin = __webpack_require__(287);
			new MergeDuplicateChunksPlugin().apply(compiler);
		}
		if (options.optimization.flagIncludedChunks) {
			const FlagIncludedChunksPlugin = __webpack_require__(288);
			new FlagIncludedChunksPlugin().apply(compiler);
		}
		if (options.optimization.sideEffects) {
			const SideEffectsFlagPlugin = __webpack_require__(129);
			new SideEffectsFlagPlugin().apply(compiler);
		}
		if (options.optimization.providedExports) {
			const FlagDependencyExportsPlugin = __webpack_require__(290);
			new FlagDependencyExportsPlugin().apply(compiler);
		}
		if (options.optimization.usedExports) {
			const FlagDependencyUsagePlugin = __webpack_require__(291);
			new FlagDependencyUsagePlugin().apply(compiler);
		}
		if (options.optimization.concatenateModules) {
			const ModuleConcatenationPlugin = __webpack_require__(130);
			new ModuleConcatenationPlugin().apply(compiler);
		}
		if (options.optimization.splitChunks) {
			const SplitChunksPlugin = __webpack_require__(136);
			new SplitChunksPlugin(options.optimization.splitChunks).apply(compiler);
		}
		if (options.optimization.runtimeChunk) {
			const RuntimeChunkPlugin = __webpack_require__(137);
			new RuntimeChunkPlugin(options.optimization.runtimeChunk).apply(compiler);
		}
		if (options.optimization.noEmitOnErrors) {
			const NoEmitOnErrorsPlugin = __webpack_require__(138);
			new NoEmitOnErrorsPlugin().apply(compiler);
		}
		if (options.optimization.checkWasmTypes) {
			const WasmFinalizeExportsPlugin = __webpack_require__(302);
			new WasmFinalizeExportsPlugin().apply(compiler);
		}
		let moduleIds = options.optimization.moduleIds;
		if (moduleIds === void 0) {
			if (options.optimization.occurrenceOrder) {
				moduleIds = "size";
			}
			if (options.optimization.namedModules) {
				moduleIds = "named";
			}
			if (options.optimization.hashedModuleIds) {
				moduleIds = "hashed";
			}
			if (moduleIds === void 0) {
				moduleIds = "natural";
			}
		}
		if (moduleIds) {
			const NamedModulesPlugin = __webpack_require__(139);
			const HashedModuleIdsPlugin = __webpack_require__(140);
			const OccurrenceModuleOrderPlugin = __webpack_require__(141);
			switch (moduleIds) {
				case "natural":
					break;
				case "named":
					new NamedModulesPlugin().apply(compiler);
					break;
				case "hashed":
					new HashedModuleIdsPlugin().apply(compiler);
					break;
				case "size":
					new OccurrenceModuleOrderPlugin({
						prioritiseInitial: true
					}).apply(compiler);
					break;
				case "total-size":
					new OccurrenceModuleOrderPlugin({
						prioritiseInitial: false
					}).apply(compiler);
					break;
				default:
					throw new Error(
						`webpack bug: moduleIds: ${moduleIds} is not implemented`
					);
			}
		}
		let chunkIds = options.optimization.chunkIds;
		if (chunkIds === void 0) {
			if (options.optimization.occurrenceOrder) {
				chunkIds = "total-size";
			}
			if (options.optimization.namedChunks) {
				chunkIds = "named";
			}
			if (chunkIds === void 0) {
				chunkIds = "natural";
			}
		}
		if (chunkIds) {
			const NaturalChunkOrderPlugin = __webpack_require__(305);
			const NamedChunksPlugin = __webpack_require__(142);
			const OccurrenceChunkOrderPlugin = __webpack_require__(143);
			switch (chunkIds) {
				case "natural":
					new NaturalChunkOrderPlugin().apply(compiler);
					break;
				case "named":
					new OccurrenceChunkOrderPlugin({
						prioritiseInitial: false
					}).apply(compiler);
					new NamedChunksPlugin().apply(compiler);
					break;
				case "size":
					new OccurrenceChunkOrderPlugin({
						prioritiseInitial: true
					}).apply(compiler);
					break;
				case "total-size":
					new OccurrenceChunkOrderPlugin({
						prioritiseInitial: false
					}).apply(compiler);
					break;
				default:
					throw new Error(
						`webpack bug: chunkIds: ${chunkIds} is not implemented`
					);
			}
		}
		if (options.optimization.nodeEnv) {
			const DefinePlugin = __webpack_require__(71);
			new DefinePlugin({
				"process.env.NODE_ENV": JSON.stringify(options.optimization.nodeEnv)
			}).apply(compiler);
		}
		if (options.optimization.minimize) {
			for (const minimizer of options.optimization.minimizer) {
				if (typeof minimizer == "function") {
					minimizer.call(compiler, compiler);
				} else {
					minimizer.apply(compiler);
				}
			}
		}

		if (options.performance) {
			const SizeLimitsPlugin = __webpack_require__(307);
			new SizeLimitsPlugin(options.performance).apply(compiler);
		}

		new TemplatedPathPlugin().apply(compiler);

		new RecordIdsPlugin({
			portableIds: options.optimization.portableRecords
		}).apply(compiler);

		new WarnCaseSensitiveModulesPlugin().apply(compiler);

		if (options.cache) {
			const CachePlugin = __webpack_require__(144);
			new CachePlugin(
				typeof options.cache == "object" ? options.cache : null
			).apply(compiler);
		}

		compiler.hooks.afterPlugins.call(compiler);
		if (!compiler.inputFileSystem) {
			throw new Error("No input filesystem provided");
		}
		compiler.resolverFactory.hooks.resolveOptions
			.for("normal")
			.tap("WebpackOptionsApply", resolveOptions => {
				return Object.assign(
					{
						fileSystem: compiler.inputFileSystem
					},
					cachedCleverMerge(options.resolve, resolveOptions)
				);
			});
		compiler.resolverFactory.hooks.resolveOptions
			.for("context")
			.tap("WebpackOptionsApply", resolveOptions => {
				return Object.assign(
					{
						fileSystem: compiler.inputFileSystem,
						resolveToContext: true
					},
					cachedCleverMerge(options.resolve, resolveOptions)
				);
			});
		compiler.resolverFactory.hooks.resolveOptions
			.for("loader")
			.tap("WebpackOptionsApply", resolveOptions => {
				return Object.assign(
					{
						fileSystem: compiler.inputFileSystem
					},
					cachedCleverMerge(options.resolveLoader, resolveOptions)
				);
			});
		compiler.hooks.afterResolvers.call(compiler);
		return options;
	}
}

module.exports = WebpackOptionsApply;

},
// 200
function(module, exports, __webpack_require__) {

class OptionsApply {
	process(options, compiler) {}
}
module.exports = OptionsApply;

},
// 201
function(module, exports, __webpack_require__) {

const Parser = __webpack_require__(83);
const Template = __webpack_require__(2);
const { ConcatSource } = __webpack_require__(0);
const JavascriptGenerator = __webpack_require__(204);
const createHash = __webpack_require__(15);

class JavascriptModulesPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"JavascriptModulesPlugin",
			(compilation, { normalModuleFactory }) => {
				normalModuleFactory.hooks.createParser
					.for("javascript/auto")
					.tap("JavascriptModulesPlugin", options => {
						return new Parser(options, "auto");
					});
				normalModuleFactory.hooks.createParser
					.for("javascript/dynamic")
					.tap("JavascriptModulesPlugin", options => {
						return new Parser(options, "script");
					});
				normalModuleFactory.hooks.createParser
					.for("javascript/esm")
					.tap("JavascriptModulesPlugin", options => {
						return new Parser(options, "module");
					});
				normalModuleFactory.hooks.createGenerator
					.for("javascript/auto")
					.tap("JavascriptModulesPlugin", () => {
						return new JavascriptGenerator();
					});
				normalModuleFactory.hooks.createGenerator
					.for("javascript/dynamic")
					.tap("JavascriptModulesPlugin", () => {
						return new JavascriptGenerator();
					});
				normalModuleFactory.hooks.createGenerator
					.for("javascript/esm")
					.tap("JavascriptModulesPlugin", () => {
						return new JavascriptGenerator();
					});
				compilation.mainTemplate.hooks.renderManifest.tap(
					"JavascriptModulesPlugin",
					(result, options) => {
						const chunk = options.chunk;
						const hash = options.hash;
						const fullHash = options.fullHash;
						const outputOptions = options.outputOptions;
						const moduleTemplates = options.moduleTemplates;
						const dependencyTemplates = options.dependencyTemplates;

						const filenameTemplate =
							chunk.filenameTemplate || outputOptions.filename;

						const useChunkHash = compilation.mainTemplate.useChunkHash(chunk);

						result.push({
							render: () =>
								compilation.mainTemplate.render(
									hash,
									chunk,
									moduleTemplates.javascript,
									dependencyTemplates
								),
							filenameTemplate,
							pathOptions: {
								noChunkHash: !useChunkHash,
								contentHashType: "javascript",
								chunk
							},
							identifier: `chunk${chunk.id}`,
							hash: useChunkHash ? chunk.hash : fullHash
						});
						return result;
					}
				);
				compilation.mainTemplate.hooks.modules.tap(
					"JavascriptModulesPlugin",
					(source, chunk, hash, moduleTemplate, dependencyTemplates) => {
						return Template.renderChunkModules(
							chunk,
							m => typeof m.source == "function",
							moduleTemplate,
							dependencyTemplates,
							"/******/ "
						);
					}
				);
				compilation.chunkTemplate.hooks.renderManifest.tap(
					"JavascriptModulesPlugin",
					(result, options) => {
						const chunk = options.chunk;
						const outputOptions = options.outputOptions;
						const moduleTemplates = options.moduleTemplates;
						const dependencyTemplates = options.dependencyTemplates;
						const filenameTemplate =
							chunk.filenameTemplate || outputOptions.chunkFilename;

						result.push({
							render: () =>
								this.renderJavascript(
									compilation.chunkTemplate,
									chunk,
									moduleTemplates.javascript,
									dependencyTemplates
								),
							filenameTemplate,
							pathOptions: {
								chunk,
								contentHashType: "javascript"
							},
							identifier: `chunk${chunk.id}`,
							hash: chunk.hash
						});

						return result;
					}
				);
				compilation.hooks.contentHash.tap("JavascriptModulesPlugin", chunk => {
					const outputOptions = compilation.outputOptions;
					const {
						hashSalt,
						hashDigest,
						hashDigestLength,
						hashFunction
					} = outputOptions;
					const hash = createHash(hashFunction);
					if (hashSalt) hash.update(hashSalt);
					const template = chunk.hasRuntime()
						? compilation.mainTemplate
						: compilation.chunkTemplate;
					hash.update(`${chunk.id} `);
					hash.update(chunk.ids ? chunk.ids.join(",") : "");
					template.updateHashForChunk(
						hash,
						chunk,
						compilation.moduleTemplates.javascript,
						compilation.dependencyTemplates
					);
					for (const m of chunk.modulesIterable) {
						if (typeof m.source == "function") {
							hash.update(m.hash);
						}
					}
					const digest = (hash.digest(hashDigest));
					chunk.contentHash.javascript = digest.substr(0, hashDigestLength);
				});
			}
		);
	}

	renderJavascript(chunkTemplate, chunk, moduleTemplate, dependencyTemplates) {
		const moduleSources = Template.renderChunkModules(
			chunk,
			m => typeof m.source == "function",
			moduleTemplate,
			dependencyTemplates
		);
		const core = chunkTemplate.hooks.modules.call(
			moduleSources,
			chunk,
			moduleTemplate,
			dependencyTemplates
		);
		let source = chunkTemplate.hooks.render.call(
			core,
			chunk,
			moduleTemplate,
			dependencyTemplates
		);
		if (chunk.hasEntryModule()) {
			source = chunkTemplate.hooks.renderWithEntry.call(source, chunk);
		}
		chunk.rendered = true;
		return new ConcatSource(source, ";");
	}
}

module.exports = JavascriptModulesPlugin;

},
// 202
function(module) {

module.exports = require("../vendor/acorn");

},
// 203
function(module) {

module.exports = require("vm");

},
// 204
function(module, exports, __webpack_require__) {

const { RawSource, ReplaceSource } = __webpack_require__(0);

class JavascriptGenerator {
	generate(module, dependencyTemplates, runtimeTemplate) {
		const originalSource = module.originalSource();
		if (!originalSource) {
			return new RawSource("throw new Error('No source available');");
		}

		const source = new ReplaceSource(originalSource);

		this.sourceBlock(
			module,
			module,
			[],
			dependencyTemplates,
			source,
			runtimeTemplate
		);

		return source;
	}

	sourceBlock(
		module,
		block,
		availableVars,
		dependencyTemplates,
		source,
		runtimeTemplate
	) {
		for (const dependency of block.dependencies) {
			this.sourceDependency(
				dependency,
				dependencyTemplates,
				source,
				runtimeTemplate
			);
		}

		const vars = block.variables.reduce((result, value) => {
			const variable = this.sourceVariables(
				value,
				availableVars,
				dependencyTemplates,
				runtimeTemplate
			);

			if (variable) {
				result.push(variable);
			}

			return result;
		}, []);

		if (vars.length > 0) {
			const injectionVariableChunks = this.splitVariablesInUniqueNamedChunks(
				vars
			);

			const functionWrapperStarts = injectionVariableChunks.map(
				variableChunk => {
					return this.variableInjectionFunctionWrapperStartCode(
						variableChunk.map(variable => variable.name)
					);
				}
			);

			const functionWrapperEnds = injectionVariableChunks.map(variableChunk => {
				return this.variableInjectionFunctionWrapperEndCode(
					module,
					variableChunk.map(variable => variable.expression),
					block
				);
			});

			const varStartCode = functionWrapperStarts.join("");

			const varEndCode = functionWrapperEnds.reverse().join("");

			if (varStartCode && varEndCode) {
				const start = block.range ? block.range[0] : -10;
				const end = block.range
					? block.range[1]
					: module.originalSource().size() + 1;
				source.insert(start + 0.5, varStartCode);
				source.insert(end + 0.5, "\n/* WEBPACK VAR INJECTION */" + varEndCode);
			}
		}

		for (const childBlock of block.blocks) {
			this.sourceBlock(
				module,
				childBlock,
				availableVars.concat(vars),
				dependencyTemplates,
				source,
				runtimeTemplate
			);
		}
	}

	sourceDependency(dependency, dependencyTemplates, source, runtimeTemplate) {
		const template = dependencyTemplates.get(dependency.constructor);
		if (!template) {
			throw new Error(
				"No template for dependency: " + dependency.constructor.name
			);
		}
		template.apply(dependency, source, runtimeTemplate, dependencyTemplates);
	}

	sourceVariables(
		variable,
		availableVars,
		dependencyTemplates,
		runtimeTemplate
	) {
		const name = variable.name;
		const expr = variable.expressionSource(
			dependencyTemplates,
			runtimeTemplate
		);

		if (
			availableVars.some(
				v => v.name === name && v.expression.source() === expr.source()
			)
		) {
			return;
		}
		return {
			name: name,
			expression: expr
		};
	}

	variableInjectionFunctionWrapperStartCode(varNames) {
		const args = varNames.join(", ");
		return `/* WEBPACK VAR INJECTION */(function(${args}) {`;
	}

	contextArgument(module, block) {
		if (this === block) {
			return module.exportsArgument;
		}
		return "this";
	}

	variableInjectionFunctionWrapperEndCode(module, varExpressions, block) {
		const firstParam = this.contextArgument(module, block);
		const furtherParams = varExpressions.map(e => e.source()).join(", ");
		return `}.call(${firstParam}, ${furtherParams}))`;
	}

	splitVariablesInUniqueNamedChunks(vars) {
		const startState = [[]];
		return vars.reduce((chunks, variable) => {
			const current = chunks[chunks.length - 1];
			const variableNameAlreadyExists = current.some(
				v => v.name === variable.name
			);

			if (variableNameAlreadyExists) {
				chunks.push([variable]);
			} else {
				current.push(variable);
			}
			return chunks;
		}, startState);
	}
}

module.exports = JavascriptGenerator;

},
// 205
function(module, exports, __webpack_require__) {

const JsonParser = __webpack_require__(206);
const JsonGenerator = __webpack_require__(208);

class JsonModulesPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"JsonModulesPlugin",
			(compilation, { normalModuleFactory }) => {
				normalModuleFactory.hooks.createParser
					.for("json")
					.tap("JsonModulesPlugin", () => {
						return new JsonParser();
					});
				normalModuleFactory.hooks.createGenerator
					.for("json")
					.tap("JsonModulesPlugin", () => {
						return new JsonGenerator();
					});
			}
		);
	}
}

module.exports = JsonModulesPlugin;

},
// 206
function(module, exports, __webpack_require__) {

const parseJson = __webpack_require__(51);
const JsonExportsDependency = __webpack_require__(207);

class JsonParser {
	constructor(options) {
		this.options = options;
	}

	parse(source, state) {
		const data = parseJson(source[0] === "\ufeff" ? source.slice(1) : source);
		state.module.buildInfo.jsonData = data;
		state.module.buildMeta.exportsType = "named";
		if (typeof data == "object" && data) {
			state.module.addDependency(new JsonExportsDependency(Object.keys(data)));
		}
		state.module.addDependency(new JsonExportsDependency(["default"]));
		return state;
	}
}

module.exports = JsonParser;

},
// 207
function(module, exports, __webpack_require__) {

const NullDependency = __webpack_require__(7);

class JsonExportsDependency extends NullDependency {
	constructor(exports) {
		super();
		this.exports = exports;
	}

	get type() {
		return "json exports";
	}

	getExports() {
		return {
			exports: this.exports,
			dependencies: void 0
		};
	}
}

module.exports = JsonExportsDependency;

},
// 208
function(module, exports, __webpack_require__) {

const { ConcatSource, RawSource } = __webpack_require__(0);

const stringifySafe = data => {
	const stringified = JSON.stringify(data);
	if (!stringified) {
		return void 0;
	}

	return stringified.replace(/\u2028|\u2029/g, str =>
		str === "\u2029" ? "\\u2029" : "\\u2028"
	);
};

class JsonGenerator {
	generate(module, dependencyTemplates, runtimeTemplate) {
		const source = new ConcatSource();
		const data = module.buildInfo.jsonData;
		if (data === void 0) {
			return new RawSource(
				runtimeTemplate.missingModuleStatement({
					request: module.rawRequest
				})
			);
		}
		let finalJson;
		if (
			Array.isArray(module.buildMeta.providedExports) &&
			!module.isUsed("default")
		) {
			const reducedJson = {};
			for (const exportName of module.buildMeta.providedExports) {
				if (exportName === "default") continue;
				const used = module.isUsed(exportName);
				if (used) {
					reducedJson[used] = data[exportName];
				}
			}
			finalJson = reducedJson;
		} else {
			finalJson = data;
		}
		const jsonSource = JSON.stringify(stringifySafe(finalJson));
		const jsonExpr = `JSON.parse(${jsonSource})`;
		source.add(`${module.moduleArgument}.exports = ${jsonExpr};`);
		return source;
	}
}

module.exports = JsonGenerator;

},
// 209
function(module, exports, __webpack_require__) {

const Generator = __webpack_require__(58);
const WebAssemblyExportImportedDependency = __webpack_require__(36);
const WebAssemblyImportDependency = __webpack_require__(37);
const WebAssemblyInInitialChunkError = __webpack_require__(210);

let WebAssemblyGenerator;
let WebAssemblyJavascriptGenerator;
let WebAssemblyParser;

class WebAssemblyModulesPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap(
			"WebAssemblyModulesPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					WebAssemblyImportDependency,
					normalModuleFactory
				);

				compilation.dependencyFactories.set(
					WebAssemblyExportImportedDependency,
					normalModuleFactory
				);

				normalModuleFactory.hooks.createParser
					.for("webassembly/experimental")
					.tap("WebAssemblyModulesPlugin", () => {
						if (WebAssemblyParser === void 0) {
							WebAssemblyParser = __webpack_require__(211);
						}
						return new WebAssemblyParser();
					});

				normalModuleFactory.hooks.createGenerator
					.for("webassembly/experimental")
					.tap("WebAssemblyModulesPlugin", () => {
						if (WebAssemblyGenerator === void 0) {
							WebAssemblyGenerator = __webpack_require__(212);
						}
						if (WebAssemblyJavascriptGenerator === void 0) {
							WebAssemblyJavascriptGenerator = __webpack_require__(214);
						}
						return Generator.byType({
							javascript: new WebAssemblyJavascriptGenerator(),
							webassembly: new WebAssemblyGenerator(this.options)
						});
					});

				compilation.chunkTemplate.hooks.renderManifest.tap(
					"WebAssemblyModulesPlugin",
					(result, options) => {
						const chunk = options.chunk;
						const outputOptions = options.outputOptions;
						const moduleTemplates = options.moduleTemplates;
						const dependencyTemplates = options.dependencyTemplates;

						for (const module of chunk.modulesIterable) {
							if (module.type && module.type.startsWith("webassembly")) {
								const filenameTemplate =
									outputOptions.webassemblyModuleFilename;

								result.push({
									render: () =>
										this.renderWebAssembly(
											module,
											moduleTemplates.webassembly,
											dependencyTemplates
										),
									filenameTemplate,
									pathOptions: {
										module
									},
									identifier: `webassemblyModule${module.id}`,
									hash: module.hash
								});
							}
						}

						return result;
					}
				);

				compilation.hooks.afterChunks.tap("WebAssemblyModulesPlugin", () => {
					const initialWasmModules = new Set();
					for (const chunk of compilation.chunks) {
						if (chunk.canBeInitial()) {
							for (const module of chunk.modulesIterable) {
								if (module.type.startsWith("webassembly")) {
									initialWasmModules.add(module);
								}
							}
						}
					}
					for (const module of initialWasmModules) {
						compilation.errors.push(
							new WebAssemblyInInitialChunkError(
								module,
								compilation.requestShortener
							)
						);
					}
				});
			}
		);
	}

	renderWebAssembly(module, moduleTemplate, dependencyTemplates) {
		return moduleTemplate.render(module, dependencyTemplates, {});
	}
}

module.exports = WebAssemblyModulesPlugin;

},
// 210
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);

const getInitialModuleChains = (module, requestShortener) => {
	const queue = [
		{ head: module, message: module.readableIdentifier(requestShortener) }
	];
	const results = new Set();
	const incompleteResults = new Set();
	const visitedModules = new Set();

	for (const chain of queue) {
		const { head, message } = chain;
		let final = true;
		const alreadyReferencedModules = new Set();
		for (const reason of head.reasons) {
			const newHead = reason.module;
			if (newHead) {
				if (!newHead.getChunks().some(c => c.canBeInitial())) continue;
				final = false;
				if (alreadyReferencedModules.has(newHead)) continue;
				alreadyReferencedModules.add(newHead);
				const moduleName = newHead.readableIdentifier(requestShortener);
				const detail = reason.explanation ? ` (${reason.explanation})` : "";
				const newMessage = `${moduleName}${detail} --> ${message}`;
				if (visitedModules.has(newHead)) {
					incompleteResults.add(`... --> ${newMessage}`);
					continue;
				}
				visitedModules.add(newHead);
				queue.push({
					head: newHead,
					message: newMessage
				});
			} else {
				final = false;
				const newMessage = reason.explanation
					? `(${reason.explanation}) --> ${message}`
					: message;
				results.add(newMessage);
			}
		}
		if (final) {
			results.add(message);
		}
	}
	for (const result of incompleteResults) {
		results.add(result);
	}
	return Array.from(results);
};

module.exports = class extends WebpackError {
	constructor(module, requestShortener) {
		const moduleChains = getInitialModuleChains(module, requestShortener);
		const message = `WebAssembly module is included in initial chunk.
This is not allowed, because WebAssembly download and compilation must happen asynchronous.
Add an async splitpoint (i. e. import()) somewhere between your entrypoint and the WebAssembly module:
${moduleChains.map(s => `* ${s}`).join("\n")}`;

		super(message);
		this.name = "WebAssemblyInInitialChunkError";
		this.hideStack = true;
		this.module = module;

		Error.captureStackTrace(this, this.constructor);
	}
};

},
// 211
function(module, exports, __webpack_require__) {

const t = __webpack_require__(59);
const { decode } = __webpack_require__(86);
const {
	moduleContextFromModuleAST
} = __webpack_require__(87);

const { Tapable } = __webpack_require__(6);
const WebAssemblyImportDependency = __webpack_require__(37);
const WebAssemblyExportImportedDependency = __webpack_require__(36);

const JS_COMPAT_TYPES = new Set(["i32", "f32", "f64"]);

const getJsIncompatibleType = signature => {
	for (const param of signature.params) {
		if (!JS_COMPAT_TYPES.has(param.valtype)) {
			return `${param.valtype} as parameter`;
		}
	}
	for (const type of signature.results) {
		if (!JS_COMPAT_TYPES.has(type)) return `${type} as result`;
	}
	return null;
};

const getJsIncompatibleTypeOfFuncSignature = signature => {
	for (const param of signature.args) {
		if (!JS_COMPAT_TYPES.has(param)) {
			return `${param} as parameter`;
		}
	}
	for (const type of signature.result) {
		if (!JS_COMPAT_TYPES.has(type)) return `${type} as result`;
	}
	return null;
};

const decoderOpts = {
	ignoreCodeSection: true,
	ignoreDataSection: true,

	ignoreCustomNameSection: true
};

class WebAssemblyParser extends Tapable {
	constructor(options) {
		super();
		this.hooks = {};
		this.options = options;
	}

	parse(binary, state) {
		state.module.buildMeta.exportsType = "namespace";

		const program = decode(binary, decoderOpts);
		const module = program.body[0];

		const moduleContext = moduleContextFromModuleAST(module);

		const exports = (state.module.buildMeta.providedExports = []);
		const jsIncompatibleExports = (state.module.buildMeta.jsIncompatibleExports = []);

		const importedGlobals = [];
		t.traverse(module, {
			ModuleExport({ node }) {
				const descriptor = node.descr;

				if (descriptor.exportType === "Func") {
					const funcidx = descriptor.id.value;

					const funcSignature = moduleContext.getFunction(funcidx);

					const incompatibleType = getJsIncompatibleTypeOfFuncSignature(
						funcSignature
					);

					if (incompatibleType) {
						jsIncompatibleExports[node.name] = incompatibleType;
					}
				}

				exports.push(node.name);

				if (node.descr && node.descr.exportType === "Global") {
					const refNode = importedGlobals[node.descr.id.value];
					if (refNode) {
						const dep = new WebAssemblyExportImportedDependency(
							node.name,
							refNode.module,
							refNode.name,
							refNode.descr.valtype
						);

						state.module.addDependency(dep);
					}
				}
			},

			Global({ node }) {
				const init = node.init[0];

				let importNode = null;

				if (init.id === "get_global") {
					const globalIdx = init.args[0].value;

					if (globalIdx < importedGlobals.length) {
						importNode = importedGlobals[globalIdx];
					}
				}

				importedGlobals.push(importNode);
			},

			ModuleImport({ node }) {
				let onlyDirectImport = false;

				if (t.isMemory(node.descr) === true) {
					onlyDirectImport = "Memory";
				} else if (t.isTable(node.descr) === true) {
					onlyDirectImport = "Table";
				} else if (t.isFuncImportDescr(node.descr) === true) {
					const incompatibleType = getJsIncompatibleType(node.descr.signature);
					if (incompatibleType) {
						onlyDirectImport = `Non-JS-compatible Func Sigurature (${incompatibleType})`;
					}
				} else if (t.isGlobalType(node.descr) === true) {
					const type = node.descr.valtype;
					if (!JS_COMPAT_TYPES.has(type)) {
						onlyDirectImport = `Non-JS-compatible Global Type (${type})`;
					}
				}

				const dep = new WebAssemblyImportDependency(
					node.module,
					node.name,
					node.descr,
					onlyDirectImport
				);

				state.module.addDependency(dep);

				if (t.isGlobalType(node.descr)) {
					importedGlobals.push(node);
				}
			}
		});

		return state;
	}
}

module.exports = WebAssemblyParser;

},
// 212
function(module, exports, __webpack_require__) {

const Generator = __webpack_require__(58);
const Template = __webpack_require__(2);
const WebAssemblyUtils = __webpack_require__(88);
const { RawSource } = __webpack_require__(0);

const { editWithAST, addWithAST } = __webpack_require__(213);
const { decode } = __webpack_require__(86);
const t = __webpack_require__(59);
const {
	moduleContextFromModuleAST
} = __webpack_require__(87);

const WebAssemblyExportImportedDependency = __webpack_require__(36);

const compose = (...fns) => {
	return fns.reduce(
		(prevFn, nextFn) => {
			return value => nextFn(prevFn(value));
		},
		value => value
	);
};

const removeStartFunc = state => bin => {
	return editWithAST(state.ast, bin, {
		Start(path) {
			path.remove();
		}
	});
};

const getImportedGlobals = ast => {
	const importedGlobals = [];

	t.traverse(ast, {
		ModuleImport({ node }) {
			if (t.isGlobalType(node.descr)) {
				importedGlobals.push(node);
			}
		}
	});

	return importedGlobals;
};

const getCountImportedFunc = ast => {
	let count = 0;

	t.traverse(ast, {
		ModuleImport({ node }) {
			if (t.isFuncImportDescr(node.descr)) {
				count++;
			}
		}
	});

	return count;
};

const getNextTypeIndex = ast => {
	const typeSectionMetadata = t.getSectionMetadata(ast, "type");

	if (typeSectionMetadata === void 0) {
		return t.indexLiteral(0);
	}

	return t.indexLiteral(typeSectionMetadata.vectorOfSize.value);
};

const getNextFuncIndex = (ast, countImportedFunc) => {
	const funcSectionMetadata = t.getSectionMetadata(ast, "func");

	if (funcSectionMetadata === void 0) {
		return t.indexLiteral(0 + countImportedFunc);
	}

	const vectorOfSize = funcSectionMetadata.vectorOfSize.value;

	return t.indexLiteral(vectorOfSize + countImportedFunc);
};

const createDefaultInitForGlobal = globalType => {
	if (globalType.valtype[0] === "i") {
		return t.objectInstruction("const", globalType.valtype, [
			t.numberLiteralFromRaw(66)
		]);
	} else if (globalType.valtype[0] === "f") {
		return t.objectInstruction("const", globalType.valtype, [
			t.floatLiteral(66, false, false, "66")
		]);
	} else {
		throw new Error("unknown type: " + globalType.valtype);
	}
};

const rewriteImportedGlobals = state => bin => {
	const additionalInitCode = state.additionalInitCode;
	const newGlobals = [];

	bin = editWithAST(state.ast, bin, {
		ModuleImport(path) {
			if (t.isGlobalType(path.node.descr)) {
				const globalType = path.node.descr;

				globalType.mutability = "var";

				const init = [
					createDefaultInitForGlobal(globalType),
					t.instruction("end")
				];

				newGlobals.push(t.global(globalType, init));

				path.remove();
			}
		},

		Global(path) {
			const { node } = path;
			const [init] = node.init;

			if (init.id === "get_global") {
				node.globalType.mutability = "var";

				const initialGlobalidx = init.args[0];

				node.init = [
					createDefaultInitForGlobal(node.globalType),
					t.instruction("end")
				];

				additionalInitCode.push(
					t.instruction("get_local", [initialGlobalidx]),
					t.instruction("set_global", [t.indexLiteral(newGlobals.length)])
				);
			}

			newGlobals.push(node);

			path.remove();
		}
	});

	return addWithAST(state.ast, bin, newGlobals);
};

const rewriteExportNames = ({ ast, module, externalExports }) => bin => {
	return editWithAST(ast, bin, {
		ModuleExport(path) {
			const isExternal = externalExports.has(path.node.name);
			if (isExternal) {
				path.remove();
				return;
			}
			const usedName = module.isUsed(path.node.name);
			if (!usedName) {
				path.remove();
				return;
			}
			path.node.name = usedName;
		}
	});
};

const rewriteImports = ({ ast, usedDependencyMap }) => bin => {
	return editWithAST(ast, bin, {
		ModuleImport(path) {
			const result = usedDependencyMap.get(
				path.node.module + ":" + path.node.name
			);

			if (result !== void 0) {
				path.node.module = result.module;
				path.node.name = result.name;
			}
		}
	});
};

const addInitFunction = ({
	ast,
	initFuncId,
	startAtFuncOffset,
	importedGlobals,
	additionalInitCode,
	nextFuncIndex,
	nextTypeIndex
}) => bin => {
	const funcParams = importedGlobals.map(importedGlobal => {
		const id = t.identifier(`${importedGlobal.module}.${importedGlobal.name}`);

		return t.funcParam(importedGlobal.descr.valtype, id);
	});

	const funcBody = importedGlobals.reduce((acc, importedGlobal, index) => {
		const args = [t.indexLiteral(index)];
		const body = [
			t.instruction("get_local", args),
			t.instruction("set_global", args)
		];

		return [...acc, ...body];
	}, []);

	if (typeof startAtFuncOffset == "number") {
		funcBody.push(t.callInstruction(t.numberLiteralFromRaw(startAtFuncOffset)));
	}

	for (const instr of additionalInitCode) {
		funcBody.push(instr);
	}

	funcBody.push(t.instruction("end"));

	const funcResults = [];

	const funcSignature = t.signature(funcParams, funcResults);
	const func = t.func(initFuncId, funcSignature, funcBody);

	const functype = t.typeInstruction(void 0, funcSignature);

	const funcindex = t.indexInFuncSection(nextTypeIndex);

	const moduleExport = t.moduleExport(
		initFuncId.value,
		t.moduleExportDescr("Func", nextFuncIndex)
	);

	return addWithAST(ast, bin, [func, moduleExport, funcindex, functype]);
};

const getUsedDependencyMap = (module, mangle) => {
	const map = new Map();
	for (const usedDep of WebAssemblyUtils.getUsedDependencies(module, mangle)) {
		const dep = usedDep.dependency;
		const request = dep.request;
		const exportName = dep.name;
		map.set(request + ":" + exportName, usedDep);
	}
	return map;
};

class WebAssemblyGenerator extends Generator {
	constructor(options) {
		super();
		this.options = options;
	}

	generate(module, dependencyTemplates, runtimeTemplate, type) {
		let bin = module.originalSource().source();

		const initFuncId = t.identifier(
			Array.isArray(module.usedExports)
				? Template.numberToIdentifer(module.usedExports.length)
				: "__webpack_init__"
		);

		const ast = decode(bin, {
			ignoreDataSection: true,
			ignoreCodeSection: true,
			ignoreCustomNameSection: true
		});

		const moduleContext = moduleContextFromModuleAST(ast.body[0]);

		const importedGlobals = getImportedGlobals(ast);
		const countImportedFunc = getCountImportedFunc(ast);
		const startAtFuncOffset = moduleContext.getStart();
		const nextFuncIndex = getNextFuncIndex(ast, countImportedFunc);
		const nextTypeIndex = getNextTypeIndex(ast);

		const usedDependencyMap = getUsedDependencyMap(
			module,
			this.options.mangleImports
		);
		const externalExports = new Set(
			module.dependencies
				.filter(d => d instanceof WebAssemblyExportImportedDependency)
				.map(d => {
					const wasmDep = (d);
					return wasmDep.exportName;
				})
		);

		const additionalInitCode = [];

		const transform = compose(
			rewriteExportNames({
				ast,
				module,
				externalExports
			}),

			removeStartFunc({ ast }),

			rewriteImportedGlobals({ ast, additionalInitCode }),

			rewriteImports({
				ast,
				usedDependencyMap
			}),

			addInitFunction({
				ast,
				initFuncId,
				importedGlobals,
				additionalInitCode,
				startAtFuncOffset,
				nextFuncIndex,
				nextTypeIndex
			})
		);

		const newBin = transform(bin);

		return new RawSource(newBin);
	}
}

module.exports = WebAssemblyGenerator;

},
// 213
function(module) {

module.exports = require("../vendor/wasm-edit");

},
// 214
function(module, exports, __webpack_require__) {

const Generator = __webpack_require__(58);
const Template = __webpack_require__(2);
const { RawSource } = __webpack_require__(0);
const WebAssemblyImportDependency = __webpack_require__(37);
const WebAssemblyExportImportedDependency = __webpack_require__(36);

class WebAssemblyJavascriptGenerator extends Generator {
	generate(module, dependencyTemplates, runtimeTemplate, type) {
		const initIdentifer = Array.isArray(module.usedExports)
			? Template.numberToIdentifer(module.usedExports.length)
			: "__webpack_init__";

		let needExportsCopy = false;
		const importedModules = new Map();
		const initParams = [];
		let index = 0;
		for (const dep of module.dependencies) {
			const depAsAny = (dep);
			if (dep.module) {
				let importData = importedModules.get(dep.module);
				if (importData === void 0) {
					importedModules.set(
						dep.module,
						(importData = {
							importVar: `m${index}`,
							index,
							request:
								"userRequest" in depAsAny ? depAsAny.userRequest : void 0,
							names: new Set(),
							reexports: []
						})
					);
					index++;
				}
				if (dep instanceof WebAssemblyImportDependency) {
					importData.names.add(dep.name);
					if (dep.description.type === "GlobalType") {
						const exportName = dep.name;
						const usedName = dep.module && dep.module.isUsed(exportName);

						if (dep.module) {
							if (usedName) {
								initParams.push(
									runtimeTemplate.exportFromImport({
										module: dep.module,
										request: dep.request,
										importVar: importData.importVar,
										originModule: module,
										exportName: dep.name,
										asiSafe: true,
										isCall: false,
										callContext: null
									})
								);
							}
						}
					}
				}
				if (dep instanceof WebAssemblyExportImportedDependency) {
					importData.names.add(dep.name);
					const usedName = module.isUsed(dep.exportName);
					if (usedName) {
						const exportProp = `${module.exportsArgument}[${JSON.stringify(
							usedName
						)}]`;
						const defineStatement = Template.asString([
							`${exportProp} = ${runtimeTemplate.exportFromImport({
								module: dep.module,
								request: dep.request,
								importVar: importData.importVar,
								originModule: module,
								exportName: dep.name,
								asiSafe: true,
								isCall: false,
								callContext: null
							})};`,
							`if(WebAssembly.Global) ${exportProp} = new WebAssembly.Global({ value: ${JSON.stringify(
									dep.valueType
								)} }, ${exportProp});`
						]);
						importData.reexports.push(defineStatement);
						needExportsCopy = true;
					}
				}
			}
		}
		const importsCode = Template.asString(
			Array.from(
				importedModules,
				([module, { importVar, request, reexports }]) => {
					const importStatement = runtimeTemplate.importStatement({
						module,
						request,
						importVar,
						originModule: module
					});
					return importStatement + reexports.join("\n");
				}
			)
		);

		const source = new RawSource(
			[
				'"use strict";',
				"// Instantiate WebAssembly module",
				"var wasmExports = __webpack_require__.w[module.i];",

				!Array.isArray(module.usedExports)
					? `__webpack_require__.r(${module.exportsArgument});`
					: "",

				"// export exports from WebAssembly module",
				Array.isArray(module.usedExports) && !needExportsCopy
					? module.moduleArgument + ".exports = wasmExports;"
					: `for(var name in wasmExports) if(name != ${JSON.stringify(initIdentifer)}) ${module.exportsArgument}[name] = wasmExports[name];`,
				"// exec imports from WebAssembly module (for esm order)",
				importsCode,
				"",
				"// exec wasm module",
				`wasmExports[${JSON.stringify(initIdentifer)}](${initParams.join(
					", "
				)})`
			].join("\n")
		);
		return source;
	}
}

module.exports = WebAssemblyJavascriptGenerator;

},
// 215
function(module, exports, __webpack_require__) {

const FunctionModuleTemplatePlugin = __webpack_require__(216);

class FunctionModulePlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap("FunctionModulePlugin", compilation => {
			new FunctionModuleTemplatePlugin().apply(
				compilation.moduleTemplates.javascript
			);
		});
	}
}

module.exports = FunctionModulePlugin;

},
// 216
function(module, exports, __webpack_require__) {

const { ConcatSource } = __webpack_require__(0);
const Template = __webpack_require__(2);

class FunctionModuleTemplatePlugin {
	apply(moduleTemplate) {
		moduleTemplate.hooks.render.tap(
			"FunctionModuleTemplatePlugin",
			(moduleSource, module) => {
				const source = new ConcatSource();
				const args = [module.moduleArgument];
				if (module.type && module.type.startsWith("javascript")) {
					if (!module.external) {
						args.push(module.exportsArgument);
						if (module.hasDependencies(d => d.requireWebpackRequire !== false))
							args.push("__webpack_require__");
					}
				} else if (!module.type || !module.type.startsWith("json"))
					args.push(module.exportsArgument, "__webpack_require__");

				source.add("/***/ (function(" + args.join(", ") + ") {\n\n");
				if (module.buildInfo.strict) source.add('"use strict";\n');
				source.add(moduleSource);
				source.add("\n\n/***/ })");
				return source;
			}
		);

		moduleTemplate.hooks.package.tap(
			"FunctionModuleTemplatePlugin",
			(moduleSource, module) => {
				if (moduleTemplate.runtimeTemplate.outputOptions.pathinfo) {
					const source = new ConcatSource();
					const req = module.readableIdentifier(
						moduleTemplate.runtimeTemplate.requestShortener
					);
					const reqStr = req.replace(/\*\//g, "*_/");
					const reqStrStar = "*".repeat(reqStr.length);
					source.add("/*!****" + reqStrStar + "****!*\\\n");
					source.add("  !*** " + reqStr + " ***!\n");
					source.add("  \\****" + reqStrStar + "****/\n");
					if (
						Array.isArray(module.buildMeta.providedExports) &&
						module.buildMeta.providedExports.length === 0
					) {
						source.add(Template.toComment("no exports provided") + "\n");
					} else if (Array.isArray(module.buildMeta.providedExports)) {
						source.add(
							Template.toComment(
								"exports provided: " +
									module.buildMeta.providedExports.join(", ")
							) + "\n"
						);
					} else if (module.buildMeta.providedExports) {
						source.add(Template.toComment("no static exports found") + "\n");
					}
					if (
						Array.isArray(module.usedExports) &&
						module.usedExports.length === 0
					) {
						source.add(Template.toComment("no exports used") + "\n");
					} else if (Array.isArray(module.usedExports)) {
						source.add(
							Template.toComment(
								"exports used: " + module.usedExports.join(", ")
							) + "\n"
						);
					} else if (module.usedExports) {
						source.add(Template.toComment("all exports used") + "\n");
					}
					if (module.optimizationBailout) {
						for (const text of module.optimizationBailout) {
							let code;
							if (typeof text == "function") {
								code = text(moduleTemplate.runtimeTemplate.requestShortener);
							} else {
								code = text;
							}
							source.add(Template.toComment(`${code}`) + "\n");
						}
					}
					source.add(moduleSource);
					return source;
				}
				return moduleSource;
			}
		);

		moduleTemplate.hooks.hash.tap("FunctionModuleTemplatePlugin", hash => {
			hash.update("FunctionModuleTemplatePlugin");
			hash.update("2");
		});
	}
}
module.exports = FunctionModuleTemplatePlugin;

},
// 217
function(module, exports, __webpack_require__) {

const { RawSource } = __webpack_require__(0);
const ModuleFilenameHelpers = __webpack_require__(18);

const cache = new WeakMap();

class EvalDevToolModuleTemplatePlugin {
	constructor(options) {
		this.sourceUrlComment = options.sourceUrlComment || "\n//# sourceURL=[url]";
		this.moduleFilenameTemplate =
			options.moduleFilenameTemplate ||
			"webpack://[namespace]/[resourcePath]?[loaders]";
		this.namespace = options.namespace || "";
	}

	apply(moduleTemplate) {
		moduleTemplate.hooks.module.tap(
			"EvalDevToolModuleTemplatePlugin",
			(source, module) => {
				const cacheEntry = cache.get(source);
				if (cacheEntry !== void 0) return cacheEntry;
				const content = source.source();
				const str = ModuleFilenameHelpers.createFilename(
					module,
					{
						moduleFilenameTemplate: this.moduleFilenameTemplate,
						namespace: this.namespace
					},
					moduleTemplate.runtimeTemplate.requestShortener
				);
				const footer =
					"\n" +
					this.sourceUrlComment.replace(
						/\[url\]/g,
						encodeURI(str)
							.replace(/%2F/g, "/")
							.replace(/%20/g, "_")
							.replace(/%5E/g, "^")
							.replace(/%5C/g, "\\")
							.replace(/^\//, "")
					);
				const result = new RawSource(
					`eval(${JSON.stringify(content + footer)});`
				);
				cache.set(source, result);
				return result;
			}
		);
		moduleTemplate.hooks.hash.tap("EvalDevToolModuleTemplatePlugin", hash => {
			hash.update("EvalDevToolModuleTemplatePlugin");
			hash.update("2");
		});
	}
}

module.exports = EvalDevToolModuleTemplatePlugin;

},
// 218
function(module) {

module.exports = JSON.parse(
	'{"definitions":{"rule":{"oneOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string","minLength":1}]},"rules":{"oneOf":[{"type":"array","items":{"description":"A rule condition","anyOf":[{"$ref":"#/definitions/rule"}]}},{"$ref":"#/definitions/rule"}]}},"title":"SourceMapDevToolPluginOptions","type":"object","additionalProperties":false,"properties":{"append":{"description":"Appends the given value to the original asset. Usually the #sourceMappingURL comment. [url] is replaced with a URL to the source map file. false disables the appending","oneOf":[{"description":"Append no SourceMap comment to the bundle, but still generate SourceMaps","enum":[false,null]},{"type":"string","minLength":1}]},"columns":{"description":"Indicates whether column mappings should be used (defaults to true)","type":"boolean"},"exclude":{"description":"Exclude modules that match the given value from source map generation","anyOf":[{"$ref":"#/definitions/rules"}]},"fallbackModuleFilenameTemplate":{"description":"Generator string or function to create identifiers of modules for the \'sources\' array in the SourceMap used only if \'moduleFilenameTemplate\' would result in a conflict","oneOf":[{"description":"Custom function generating the identifer","instanceof":"Function","tsType":"Function"},{"type":"string","minLength":1}]},"fileContext":{"description":"Path prefix to which the [file] placeholder is relative to","type":"string"},"filename":{"description":"Defines the output filename of the SourceMap (will be inlined if no value is provided)","oneOf":[{"description":"Disable separate SourceMap file and inline SourceMap as DataUrl","enum":[false,null]},{"type":"string","absolutePath":false,"minLength":1}]},"include":{"description":"Include source maps for module paths that match the given value","anyOf":[{"$ref":"#/definitions/rules"}]},"lineToLine":{"description":"(deprecated) try to map original files line to line to generated files","anyOf":[{"type":"boolean"},{"description":"Simplify and speed up source mapping by using line to line source mappings for matched modules","type":"object","additionalProperties":false,"properties":{"exclude":{"description":"Exclude modules that match the given value from source map generation","anyOf":[{"$ref":"#/definitions/rules"}]},"include":{"description":"Include source maps for module paths that match the given value","anyOf":[{"$ref":"#/definitions/rules"}]},"test":{"description":"Include source maps for modules based on their extension (defaults to .js and .css)","anyOf":[{"$ref":"#/definitions/rules"}]}}}]},"module":{"description":"Indicates whether SourceMaps from loaders should be used (defaults to true)","type":"boolean"},"moduleFilenameTemplate":{"description":"Generator string or function to create identifiers of modules for the \'sources\' array in the SourceMap","oneOf":[{"description":"Custom function generating the identifer","instanceof":"Function","tsType":"Function"},{"type":"string","minLength":1}]},"namespace":{"description":"Namespace prefix to allow multiple webpack roots in the devtools","type":"string"},"noSources":{"description":"Omit the \'sourceContents\' array from the SourceMap","type":"boolean"},"publicPath":{"description":"Provide a custom public path for the SourceMapping comment","type":"string"},"sourceRoot":{"description":"Provide a custom value for the \'sourceRoot\' property in the SourceMap","type":"string"},"test":{"description":"Include source maps for modules based on their extension (defaults to .js and .css)","anyOf":[{"$ref":"#/definitions/rules"}]}}}'
);

},
// 219
function(module, exports, __webpack_require__) {

const { RawSource } = __webpack_require__(0);
const ModuleFilenameHelpers = __webpack_require__(18);
const { absolutify } = __webpack_require__(13);

const cache = new WeakMap();

class EvalSourceMapDevToolModuleTemplatePlugin {
	constructor(compilation, options) {
		this.compilation = compilation;
		this.sourceMapComment =
			options.append || "//# sourceURL=[module]\n//# sourceMappingURL=[url]";
		this.moduleFilenameTemplate =
			options.moduleFilenameTemplate ||
			"webpack://[namespace]/[resource-path]?[hash]";
		this.namespace = options.namespace || "";
		this.options = options;
	}

	apply(moduleTemplate) {
		const self = this;
		const options = this.options;
		const matchModule = ModuleFilenameHelpers.matchObject.bind(
			ModuleFilenameHelpers,
			options
		);
		moduleTemplate.hooks.module.tap(
			"EvalSourceMapDevToolModuleTemplatePlugin",
			(source, module) => {
				const cachedSource = cache.get(source);
				if (cachedSource !== void 0) {
					return cachedSource;
				}

				if (!matchModule(module.resource)) {
					return source;
				}

				let sourceMap;
				let content;
				if (source.sourceAndMap) {
					const sourceAndMap = source.sourceAndMap(options);
					sourceMap = sourceAndMap.map;
					content = sourceAndMap.source;
				} else {
					sourceMap = source.map(options);
					content = source.source();
				}
				if (!sourceMap) {
					return source;
				}

				sourceMap = Object.keys(sourceMap).reduce((obj, key) => {
					obj[key] = sourceMap[key];
					return obj;
				}, {});
				const context = this.compilation.compiler.options.context;
				const modules = sourceMap.sources.map(source => {
					if (source.startsWith("webpack://")) {
						source = absolutify(context, source.slice(10));
					}
					const module = self.compilation.findModule(source);
					return module || source;
				});
				let moduleFilenames = modules.map(module => {
					return ModuleFilenameHelpers.createFilename(
						module,
						{
							moduleFilenameTemplate: self.moduleFilenameTemplate,
							namespace: self.namespace
						},
						moduleTemplate.runtimeTemplate.requestShortener
					);
				});
				moduleFilenames = ModuleFilenameHelpers.replaceDuplicates(
					moduleFilenames,
					(filename, i, n) => {
						for (let j = 0; j < n; j++) filename += "*";
						return filename;
					}
				);
				sourceMap.sources = moduleFilenames;
				sourceMap.sourceRoot = options.sourceRoot || "";
				sourceMap.file = `${module.id}.js`;

				const footer =
					self.sourceMapComment.replace(
						/\[url\]/g,
						`data:application/json;charset=utf-8;base64,${Buffer.from(
							JSON.stringify(sourceMap),
							"utf8"
						).toString("base64")}`
					) + `\n//# sourceURL=webpack-internal:///${module.id}\n`;

				const evalSource = new RawSource(
					`eval(${JSON.stringify(content + footer)});`
				);

				cache.set(source, evalSource);

				return evalSource;
			}
		);
		moduleTemplate.hooks.hash.tap(
			"EvalSourceMapDevToolModuleTemplatePlugin",
			hash => {
				hash.update("eval-source-map");
				hash.update("2");
			}
		);
	}
}
module.exports = EvalSourceMapDevToolModuleTemplatePlugin;

},
// 220
function(module, exports, __webpack_require__) {

const SingleEntryPlugin = __webpack_require__(61);
const MultiEntryPlugin = __webpack_require__(93);
const DynamicEntryPlugin = __webpack_require__(222);

const itemToPlugin = (context, item, name) => {
	if (Array.isArray(item)) {
		return new MultiEntryPlugin(context, item, name);
	}
	return new SingleEntryPlugin(context, item, name);
};

module.exports = class {
	apply(compiler) {
		compiler.hooks.entryOption.tap("EntryOptionPlugin", (context, entry) => {
			if (typeof entry == "string" || Array.isArray(entry)) {
				itemToPlugin(context, entry, "main").apply(compiler);
			} else if (typeof entry == "object") {
				for (const name of Object.keys(entry)) {
					itemToPlugin(context, entry[name], name).apply(compiler);
				}
			} else if (typeof entry == "function") {
				new DynamicEntryPlugin(context, entry).apply(compiler);
			}
			return true;
		});
	}
};

},
// 221
function(module, exports, __webpack_require__) {

const Module = __webpack_require__(16);
const Template = __webpack_require__(2);
const { RawSource } = __webpack_require__(0);

class MultiModule extends Module {
	constructor(context, dependencies, name) {
		super("javascript/dynamic", context);

		this.dependencies = dependencies;
		this.name = name;
		this._identifier = `multi ${this.dependencies
			.map(d => d.request)
			.join(" ")}`;
	}

	identifier() {
		return this._identifier;
	}

	readableIdentifier(requestShortener) {
		return `multi ${this.dependencies
			.map(d => requestShortener.shorten(d.request))
			.join(" ")}`;
	}

	build(options, compilation, resolver, fs, callback) {
		this.built = true;
		this.buildMeta = {};
		this.buildInfo = {};
		return callback();
	}

	needRebuild() {
		return false;
	}

	size() {
		return 16 + this.dependencies.length * 12;
	}

	updateHash(hash) {
		hash.update("multi module");
		hash.update(this.name || "");
		super.updateHash(hash);
	}

	source(dependencyTemplates, runtimeTemplate) {
		const str = [];
		let idx = 0;
		for (const dep of this.dependencies) {
			if (dep.module) {
				if (idx === this.dependencies.length - 1) {
					str.push("module.exports = ");
				}
				str.push("__webpack_require__(");
				if (runtimeTemplate.outputOptions.pathinfo) {
					str.push(Template.toComment(dep.request));
				}
				str.push(`${JSON.stringify(dep.module.id)}`);
				str.push(")");
			} else {
				const content = __webpack_require__(38).module(
					dep.request
				);
				str.push(content);
			}
			str.push(";\n");
			idx++;
		}
		return new RawSource(str.join(""));
	}
}

module.exports = MultiModule;

},
// 222
function(module, exports, __webpack_require__) {

const MultiEntryDependency = __webpack_require__(94);
const SingleEntryDependency = __webpack_require__(25);
const MultiModuleFactory = __webpack_require__(95);
const MultiEntryPlugin = __webpack_require__(93);
const SingleEntryPlugin = __webpack_require__(61);

class DynamicEntryPlugin {
	constructor(context, entry) {
		this.context = context;
		this.entry = entry;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap(
			"DynamicEntryPlugin",
			(compilation, { normalModuleFactory }) => {
				const multiModuleFactory = new MultiModuleFactory();

				compilation.dependencyFactories.set(
					MultiEntryDependency,
					multiModuleFactory
				);
				compilation.dependencyFactories.set(
					SingleEntryDependency,
					normalModuleFactory
				);
			}
		);

		compiler.hooks.make.tapAsync(
			"DynamicEntryPlugin",
			(compilation, callback) => {
				const addEntry = (entry, name) => {
					const dep = DynamicEntryPlugin.createDependency(entry, name);
					return new Promise((resolve, reject) => {
						compilation.addEntry(this.context, dep, name, err => {
							if (err) return reject(err);
							resolve();
						});
					});
				};

				Promise.resolve(this.entry()).then(entry => {
					if (typeof entry == "string" || Array.isArray(entry)) {
						addEntry(entry, "main").then(() => callback(), callback);
					} else if (typeof entry == "object") {
						Promise.all(
							Object.keys(entry).map(name => {
								return addEntry(entry[name], name);
							})
						).then(() => callback(), callback);
					}
				});
			}
		);
	}
}

module.exports = DynamicEntryPlugin;
DynamicEntryPlugin.createDependency = (entry, name) => {
	if (Array.isArray(entry)) {
		return MultiEntryPlugin.createDependency(entry, name);
	} else {
		return SingleEntryPlugin.createDependency(entry, name);
	}
};

},
// 223
function(module, exports, __webpack_require__) {

const identifierUtils = __webpack_require__(13);

class RecordIdsPlugin {
	constructor(options) {
		this.options = options || {};
	}

	apply(compiler) {
		const portableIds = this.options.portableIds;
		compiler.hooks.compilation.tap("RecordIdsPlugin", compilation => {
			compilation.hooks.recordModules.tap(
				"RecordIdsPlugin",
				(modules, records) => {
					if (!records.modules) records.modules = {};
					if (!records.modules.byIdentifier) records.modules.byIdentifier = {};
					if (!records.modules.usedIds) records.modules.usedIds = {};
					for (const module of modules) {
						if (typeof module.id != "number") continue;
						const identifier = portableIds
							? identifierUtils.makePathsRelative(
									compiler.context,
									module.identifier(),
									compilation.cache
								)
							: module.identifier();
						records.modules.byIdentifier[identifier] = module.id;
						records.modules.usedIds[module.id] = module.id;
					}
				}
			);
			compilation.hooks.reviveModules.tap(
				"RecordIdsPlugin",
				(modules, records) => {
					if (!records.modules) return;
					if (records.modules.byIdentifier) {
						const usedIds = new Set();
						for (const module of modules) {
							if (module.id !== null) continue;
							const identifier = portableIds
								? identifierUtils.makePathsRelative(
										compiler.context,
										module.identifier(),
										compilation.cache
									)
								: module.identifier();
							const id = records.modules.byIdentifier[identifier];
							if (id === void 0) continue;
							if (usedIds.has(id)) continue;
							usedIds.add(id);
							module.id = id;
						}
					}
					if (Array.isArray(records.modules.usedIds)) {
						compilation.usedModuleIds = new Set(records.modules.usedIds);
					}
				}
			);

			const getModuleIdentifier = module => {
				if (portableIds) {
					return identifierUtils.makePathsRelative(
						compiler.context,
						module.identifier(),
						compilation.cache
					);
				}
				return module.identifier();
			};

			const getChunkSources = chunk => {
				const sources = [];
				for (const chunkGroup of chunk.groupsIterable) {
					const index = chunkGroup.chunks.indexOf(chunk);
					if (chunkGroup.name) {
						sources.push(`${index} ${chunkGroup.name}`);
					} else {
						for (const origin of chunkGroup.origins) {
							if (origin.module) {
								if (origin.request) {
									sources.push(
										`${index} ${getModuleIdentifier(origin.module)} ${
											origin.request
										}`
									);
								} else if (typeof origin.loc == "string") {
									sources.push(
										`${index} ${getModuleIdentifier(origin.module)} ${
											origin.loc
										}`
									);
								} else if (
									origin.loc &&
									typeof origin.loc == "object" &&
									origin.loc.start
								) {
									sources.push(
										`${index} ${getModuleIdentifier(
											origin.module
										)} ${JSON.stringify(origin.loc.start)}`
									);
								}
							}
						}
					}
				}
				return sources;
			};

			compilation.hooks.recordChunks.tap(
				"RecordIdsPlugin",
				(chunks, records) => {
					if (!records.chunks) records.chunks = {};
					if (!records.chunks.byName) records.chunks.byName = {};
					if (!records.chunks.bySource) records.chunks.bySource = {};
					const usedIds = new Set();
					for (const chunk of chunks) {
						if (typeof chunk.id != "number") continue;
						const name = chunk.name;
						if (name) records.chunks.byName[name] = chunk.id;
						const sources = getChunkSources(chunk);
						for (const source of sources) {
							records.chunks.bySource[source] = chunk.id;
						}
						usedIds.add(chunk.id);
					}
					records.chunks.usedIds = Array.from(usedIds).sort();
				}
			);
			compilation.hooks.reviveChunks.tap(
				"RecordIdsPlugin",
				(chunks, records) => {
					if (!records.chunks) return;
					const usedIds = new Set();
					if (records.chunks.byName) {
						for (const chunk of chunks) {
							if (chunk.id !== null) continue;
							if (!chunk.name) continue;
							const id = records.chunks.byName[chunk.name];
							if (id === void 0) continue;
							if (usedIds.has(id)) continue;
							usedIds.add(id);
							chunk.id = id;
						}
					}
					if (records.chunks.bySource) {
						for (const chunk of chunks) {
							const sources = getChunkSources(chunk);
							for (const source of sources) {
								const id = records.chunks.bySource[source];
								if (id === void 0) continue;
								if (usedIds.has(id)) continue;
								usedIds.add(id);
								chunk.id = id;
								break;
							}
						}
					}
					if (Array.isArray(records.chunks.usedIds)) {
						compilation.usedChunkIds = new Set(records.chunks.usedIds);
					}
				}
			);
		});
	}
}
module.exports = RecordIdsPlugin;

},
// 224
function(module, exports, __webpack_require__) {

const ConstDependency = __webpack_require__(5);
const ParserHelpers = __webpack_require__(9);

const NullFactory = __webpack_require__(10);

const REPLACEMENTS = {
	__webpack_require__: "__webpack_require__",
	__webpack_public_path__: "__webpack_require__.p",
	__webpack_modules__: "__webpack_require__.m",
	__webpack_chunk_load__: "__webpack_require__.e",
	__non_webpack_require__: "require",
	__webpack_nonce__: "__webpack_require__.nc",
	"require.onError": "__webpack_require__.oe"
};
const NO_WEBPACK_REQUIRE = {
	__non_webpack_require__: true
};
const REPLACEMENT_TYPES = {
	__webpack_public_path__: "string",
	__webpack_require__: "function",
	__webpack_modules__: "object",
	__webpack_chunk_load__: "function",
	__webpack_nonce__: "string"
};

class APIPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"APIPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(ConstDependency, new NullFactory());
				compilation.dependencyTemplates.set(
					ConstDependency,
					new ConstDependency.Template()
				);

				const handler = parser => {
					Object.keys(REPLACEMENTS).forEach(key => {
						parser.hooks.expression
							.for(key)
							.tap(
								"APIPlugin",
								NO_WEBPACK_REQUIRE[key]
									? ParserHelpers.toConstantDependency(
											parser,
											REPLACEMENTS[key]
										)
									: ParserHelpers.toConstantDependencyWithWebpackRequire(
											parser,
											REPLACEMENTS[key]
										)
							);
						const type = REPLACEMENT_TYPES[key];
						if (type) {
							parser.hooks.evaluateTypeof
								.for(key)
								.tap("APIPlugin", ParserHelpers.evaluateToString(type));
						}
					});
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("APIPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("APIPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/esm")
					.tap("APIPlugin", handler);
			}
		);
	}
}

module.exports = APIPlugin;

},
// 225
function(module, exports, __webpack_require__) {

const ConstDependency = __webpack_require__(5);
const NullFactory = __webpack_require__(10);
const ParserHelpers = __webpack_require__(9);

const getQuery = request => {
	const i = request.indexOf("?");
	return i !== -1 ? request.substr(i) : "";
};

const collectDeclaration = (declarations, pattern) => {
	const stack = [pattern];
	while (stack.length > 0) {
		const node = stack.pop();
		switch (node.type) {
			case "Identifier":
				declarations.add(node.name);
				break;
			case "ArrayPattern":
				for (const element of node.elements) {
					if (element) {
						stack.push(element);
					}
				}
				break;
			case "AssignmentPattern":
				stack.push(node.left);
				break;
			case "ObjectPattern":
				for (const property of node.properties) {
					stack.push(property.value);
				}
				break;
			case "RestElement":
				stack.push(node.argument);
				break;
		}
	}
};

const getHoistedDeclarations = (branch, includeFunctionDeclarations) => {
	const declarations = new Set();
	const stack = [branch];
	while (stack.length > 0) {
		const node = stack.pop();
		if (!node) continue;
		switch (node.type) {
			case "BlockStatement":
				for (const stmt of node.body) {
					stack.push(stmt);
				}
				break;
			case "IfStatement":
				stack.push(node.consequent);
				stack.push(node.alternate);
				break;
			case "ForStatement":
				stack.push(node.init);
				stack.push(node.body);
				break;
			case "ForInStatement":
			case "ForOfStatement":
				stack.push(node.left);
				stack.push(node.body);
				break;
			case "DoWhileStatement":
			case "WhileStatement":
			case "LabeledStatement":
				stack.push(node.body);
				break;
			case "SwitchStatement":
				for (const cs of node.cases) {
					for (const consequent of cs.consequent) {
						stack.push(consequent);
					}
				}
				break;
			case "TryStatement":
				stack.push(node.block);
				if (node.handler) {
					stack.push(node.handler.body);
				}
				stack.push(node.finalizer);
				break;
			case "FunctionDeclaration":
				if (includeFunctionDeclarations) {
					collectDeclaration(declarations, node.id);
				}
				break;
			case "VariableDeclaration":
				if (node.kind === "var") {
					for (const decl of node.declarations) {
						collectDeclaration(declarations, decl.id);
					}
				}
				break;
		}
	}
	return Array.from(declarations);
};

class ConstPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"ConstPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(ConstDependency, new NullFactory());
				compilation.dependencyTemplates.set(
					ConstDependency,
					new ConstDependency.Template()
				);

				const handler = parser => {
					parser.hooks.statementIf.tap("ConstPlugin", statement => {
						if (parser.scope.isAsmJs) return;
						const param = parser.evaluateExpression(statement.test);
						const bool = param.asBool();
						if (typeof bool == "boolean") {
							if (statement.test.type !== "Literal") {
								const dep = new ConstDependency(`${bool}`, param.range);
								dep.loc = statement.loc;
								parser.state.current.addDependency(dep);
							}
							const branchToRemove = bool
								? statement.alternate
								: statement.consequent;
							if (branchToRemove) {
								let declarations;
								if (parser.scope.isStrict) {
									declarations = getHoistedDeclarations(branchToRemove, false);
								} else {
									declarations = getHoistedDeclarations(branchToRemove, true);
								}
								let replacement;
								if (declarations.length > 0) {
									replacement = `{ var ${declarations.join(", ")}; }`;
								} else {
									replacement = "{}";
								}
								const dep = new ConstDependency(
									replacement,
									branchToRemove.range
								);
								dep.loc = branchToRemove.loc;
								parser.state.current.addDependency(dep);
							}
							return bool;
						}
					});
					parser.hooks.expressionConditionalOperator.tap(
						"ConstPlugin",
						expression => {
							if (parser.scope.isAsmJs) return;
							const param = parser.evaluateExpression(expression.test);
							const bool = param.asBool();
							if (typeof bool == "boolean") {
								if (expression.test.type !== "Literal") {
									const dep = new ConstDependency(` ${bool}`, param.range);
									dep.loc = expression.loc;
									parser.state.current.addDependency(dep);
								}
								const branchToRemove = bool
									? expression.alternate
									: expression.consequent;
								const dep = new ConstDependency(
									"undefined",
									branchToRemove.range
								);
								dep.loc = branchToRemove.loc;
								parser.state.current.addDependency(dep);
								return bool;
							}
						}
					);
					parser.hooks.expressionLogicalOperator.tap(
						"ConstPlugin",
						expression => {
							if (parser.scope.isAsmJs) return;
							if (
								expression.operator === "&&" ||
								expression.operator === "||"
							) {
								const param = parser.evaluateExpression(expression.left);
								const bool = param.asBool();
								if (typeof bool == "boolean") {
									const keepRight =
										(expression.operator === "&&" && bool) ||
										(expression.operator === "||" && !bool);

									if (param.isBoolean() || keepRight) {
										const dep = new ConstDependency(` ${bool}`, param.range);
										dep.loc = expression.loc;
										parser.state.current.addDependency(dep);
									} else {
										parser.walkExpression(expression.left);
									}
									if (!keepRight) {
										const dep = new ConstDependency(
											"false",
											expression.right.range
										);
										dep.loc = expression.loc;
										parser.state.current.addDependency(dep);
									}
									return keepRight;
								}
							}
						}
					);
					parser.hooks.evaluateIdentifier
						.for("__resourceQuery")
						.tap("ConstPlugin", expr => {
							if (parser.scope.isAsmJs) return;
							if (!parser.state.module) return;
							return ParserHelpers.evaluateToString(
								getQuery(parser.state.module.resource)
							)(expr);
						});
					parser.hooks.expression
						.for("__resourceQuery")
						.tap("ConstPlugin", () => {
							if (parser.scope.isAsmJs) return;
							if (!parser.state.module) return;
							parser.state.current.addVariable(
								"__resourceQuery",
								JSON.stringify(getQuery(parser.state.module.resource))
							);
							return true;
						});
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("ConstPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("ConstPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/esm")
					.tap("ConstPlugin", handler);
			}
		);
	}
}

module.exports = ConstPlugin;

},
// 226
function(module, exports, __webpack_require__) {

const path = __webpack_require__(3);
const ParserHelpers = __webpack_require__(9);

class CommonJsStuffPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"CommonJsStuffPlugin",
			(compilation, { normalModuleFactory }) => {
				const handler = (parser, parserOptions) => {
					parser.hooks.expression
						.for("require.main.require")
						.tap(
							"CommonJsStuffPlugin",
							ParserHelpers.expressionIsUnsupported(
								parser,
								"require.main.require is not supported by webpack."
							)
						);
					parser.hooks.expression
						.for("module.parent.require")
						.tap(
							"CommonJsStuffPlugin",
							ParserHelpers.expressionIsUnsupported(
								parser,
								"module.parent.require is not supported by webpack."
							)
						);
					parser.hooks.expression
						.for("require.main")
						.tap(
							"CommonJsStuffPlugin",
							ParserHelpers.toConstantDependencyWithWebpackRequire(
								parser,
								"__webpack_require__.c[__webpack_require__.s]"
							)
						);
					parser.hooks.expression
						.for("module.loaded")
						.tap("CommonJsStuffPlugin", expr => {
							parser.state.module.buildMeta.moduleConcatenationBailout =
								"module.loaded";
							return ParserHelpers.toConstantDependency(
								parser,
								"module.l"
							)(expr);
						});
					parser.hooks.expression
						.for("module.id")
						.tap("CommonJsStuffPlugin", expr => {
							parser.state.module.buildMeta.moduleConcatenationBailout =
								"module.id";
							return ParserHelpers.toConstantDependency(
								parser,
								"module.i"
							)(expr);
						});
					parser.hooks.expression
						.for("module.exports")
						.tap("CommonJsStuffPlugin", () => {
							const module = parser.state.module;
							const isHarmony =
								module.buildMeta && module.buildMeta.exportsType;
							if (!isHarmony) return true;
						});
					parser.hooks.evaluateIdentifier
						.for("module.hot")
						.tap(
							"CommonJsStuffPlugin",
							ParserHelpers.evaluateToIdentifier("module.hot", false)
						);
					parser.hooks.expression
						.for("module")
						.tap("CommonJsStuffPlugin", () => {
							const module = parser.state.module;
							const isHarmony =
								module.buildMeta && module.buildMeta.exportsType;
							let moduleJsPath = path.join(
								__dirname,
								"..",
								"buildin",
								isHarmony ? "harmony-module.js" : "module.js"
							);
							if (module.context) {
								moduleJsPath = path.relative(
									parser.state.module.context,
									moduleJsPath
								);
								if (!/^[A-Z]:/i.test(moduleJsPath)) {
									moduleJsPath = `./${moduleJsPath.replace(/\\/g, "/")}`;
								}
							}
							return ParserHelpers.addParsedVariableToModule(
								parser,
								"module",
								`require(${JSON.stringify(moduleJsPath)})(module)`
							);
						});
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("CommonJsStuffPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("CommonJsStuffPlugin", handler);
			}
		);
	}
}
module.exports = CommonJsStuffPlugin;

},
// 227
function(module, exports, __webpack_require__) {

const ConstDependency = __webpack_require__(5);

const NullFactory = __webpack_require__(10);

class CompatibilityPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"CompatibilityPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(ConstDependency, new NullFactory());
				compilation.dependencyTemplates.set(
					ConstDependency,
					new ConstDependency.Template()
				);

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("CompatibilityPlugin", (parser, parserOptions) => {
						if (
							parserOptions.browserify !== void 0 &&
							!parserOptions.browserify
						)
							return;

						parser.hooks.call
							.for("require")
							.tap("CompatibilityPlugin", expr => {
								if (expr.arguments.length !== 2) return;
								const second = parser.evaluateExpression(expr.arguments[1]);
								if (!second.isBoolean()) return;
								if (second.asBool() !== true) return;
								const dep = new ConstDependency("require", expr.callee.range);
								dep.loc = expr.loc;
								if (parser.state.current.dependencies.length > 1) {
									const last =
										parser.state.current.dependencies[
											parser.state.current.dependencies.length - 1
										];
									if (
										last.critical &&
										last.options &&
										last.options.request === "." &&
										last.userRequest === "." &&
										last.options.recursive
									)
										parser.state.current.dependencies.pop();
								}
								parser.state.current.addDependency(dep);
								return true;
							});
					});
			}
		);
	}
}
module.exports = CompatibilityPlugin;

},
// 228
function(module, exports, __webpack_require__) {

const REGEXP_HASH = /\[hash(?::(\d+))?\]/gi,
	REGEXP_CHUNKHASH = /\[chunkhash(?::(\d+))?\]/gi,
	REGEXP_MODULEHASH = /\[modulehash(?::(\d+))?\]/gi,
	REGEXP_CONTENTHASH = /\[contenthash(?::(\d+))?\]/gi,
	REGEXP_NAME = /\[name\]/gi,
	REGEXP_ID = /\[id\]/gi,
	REGEXP_MODULEID = /\[moduleid\]/gi,
	REGEXP_FILE = /\[file\]/gi,
	REGEXP_QUERY = /\[query\]/gi,
	REGEXP_FILEBASE = /\[filebase\]/gi,
	REGEXP_URL = /\[url\]/gi;

const REGEXP_HASH_FOR_TEST = new RegExp(REGEXP_HASH.source, "i"),
	REGEXP_CHUNKHASH_FOR_TEST = new RegExp(REGEXP_CHUNKHASH.source, "i"),
	REGEXP_CONTENTHASH_FOR_TEST = new RegExp(REGEXP_CONTENTHASH.source, "i"),
	REGEXP_NAME_FOR_TEST = new RegExp(REGEXP_NAME.source, "i");

const withHashLength = (replacer, handlerFn, assetInfo) => {
	const fn = (match, hashLength, ...args) => {
		if (assetInfo) assetInfo.immutable = true;
		const length = hashLength && parseInt(hashLength, 10);
		if (length && handlerFn) {
			return handlerFn(length);
		}
		const hash = replacer(match, hashLength, ...args);
		return length ? hash.slice(0, length) : hash;
	};
	return fn;
};

const getReplacer = (value, allowEmpty) => {
	const fn = (match, ...args) => {
		const input = args[args.length - 1];
		if (value === null || value === void 0) {
			if (!allowEmpty) {
				throw new Error(
					`Path variable ${match} not implemented in this context: ${input}`
				);
			}
			return "";
		} else {
			return `${escapePathVariables(value)}`;
		}
	};
	return fn;
};

const escapePathVariables = value => {
	return typeof value == "string"
		? value.replace(/\[(\\*[\w:]+\\*)\]/gi, "[\\$1\\]")
		: value;
};

const replacePathVariables = (path, data, assetInfo) => {
	const chunk = data.chunk;
	const chunkId = chunk && chunk.id;
	const chunkName = chunk && (chunk.name || chunk.id);
	const chunkHash = chunk && (chunk.renderedHash || chunk.hash);
	const chunkHashWithLength = chunk && chunk.hashWithLength;
	const contentHashType = data.contentHashType;
	const contentHash =
		(chunk && chunk.contentHash && chunk.contentHash[contentHashType]) ||
		data.contentHash;
	const contentHashWithLength =
		(chunk &&
			chunk.contentHashWithLength &&
			chunk.contentHashWithLength[contentHashType]) ||
		data.contentHashWithLength;
	const module = data.module;
	const moduleId = module && module.id;
	const moduleHash = module && (module.renderedHash || module.hash);
	const moduleHashWithLength = module && module.hashWithLength;

	if (typeof path == "function") {
		path = path(data);
	}

	if (
		data.noChunkHash &&
		(REGEXP_CHUNKHASH_FOR_TEST.test(path) ||
			REGEXP_CONTENTHASH_FOR_TEST.test(path))
	) {
		throw new Error(
			`Cannot use [chunkhash] or [contenthash] for chunk in '${path}' (use [hash] instead)`
		);
	}

	return (
		path
			.replace(
				REGEXP_HASH,
				withHashLength(getReplacer(data.hash), data.hashWithLength, assetInfo)
			)
			.replace(
				REGEXP_CHUNKHASH,
				withHashLength(getReplacer(chunkHash), chunkHashWithLength, assetInfo)
			)
			.replace(
				REGEXP_CONTENTHASH,
				withHashLength(
					getReplacer(contentHash),
					contentHashWithLength,
					assetInfo
				)
			)
			.replace(
				REGEXP_MODULEHASH,
				withHashLength(getReplacer(moduleHash), moduleHashWithLength, assetInfo)
			)
			.replace(REGEXP_ID, getReplacer(chunkId))
			.replace(REGEXP_MODULEID, getReplacer(moduleId))
			.replace(REGEXP_NAME, getReplacer(chunkName))
			.replace(REGEXP_FILE, getReplacer(data.filename))
			.replace(REGEXP_FILEBASE, getReplacer(data.basename))
			.replace(REGEXP_QUERY, getReplacer(data.query, true))
			.replace(REGEXP_URL, getReplacer(data.url))
			.replace(/\[\\(\\*[\w:]+\\*)\\\]/gi, "[$1]")
	);
};

class TemplatedPathPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap("TemplatedPathPlugin", compilation => {
			const mainTemplate = compilation.mainTemplate;

			mainTemplate.hooks.assetPath.tap(
				"TemplatedPathPlugin",
				replacePathVariables
			);

			mainTemplate.hooks.globalHash.tap(
				"TemplatedPathPlugin",
				(chunk, paths) => {
					const outputOptions = mainTemplate.outputOptions;
					const publicPath = outputOptions.publicPath || "";
					const filename = outputOptions.filename || "";
					const chunkFilename =
						outputOptions.chunkFilename || outputOptions.filename;
					if (
						REGEXP_HASH_FOR_TEST.test(publicPath) ||
						REGEXP_CHUNKHASH_FOR_TEST.test(publicPath) ||
						REGEXP_CONTENTHASH_FOR_TEST.test(publicPath) ||
						REGEXP_NAME_FOR_TEST.test(publicPath)
					)
						return true;
					if (REGEXP_HASH_FOR_TEST.test(filename)) return true;
					if (REGEXP_HASH_FOR_TEST.test(chunkFilename)) return true;
					if (REGEXP_HASH_FOR_TEST.test(paths.join("|"))) return true;
				}
			);

			mainTemplate.hooks.hashForChunk.tap(
				"TemplatedPathPlugin",
				(hash, chunk) => {
					const outputOptions = mainTemplate.outputOptions;
					const chunkFilename =
						outputOptions.chunkFilename || outputOptions.filename;
					if (REGEXP_CHUNKHASH_FOR_TEST.test(chunkFilename)) {
						hash.update(JSON.stringify(chunk.getChunkMaps(true).hash));
					}
					if (REGEXP_CONTENTHASH_FOR_TEST.test(chunkFilename)) {
						hash.update(
							JSON.stringify(
								chunk.getChunkMaps(true).contentHash.javascript || {}
							)
						);
					}
					if (REGEXP_NAME_FOR_TEST.test(chunkFilename)) {
						hash.update(JSON.stringify(chunk.getChunkMaps(true).name));
					}
				}
			);
		});
	}
}

module.exports = TemplatedPathPlugin;

},
// 229
function(module, exports, __webpack_require__) {

const CaseSensitiveModulesWarning = __webpack_require__(230);

class WarnCaseSensitiveModulesPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"WarnCaseSensitiveModulesPlugin",
			compilation => {
				compilation.hooks.seal.tap("WarnCaseSensitiveModulesPlugin", () => {
					const moduleWithoutCase = new Map();
					for (const module of compilation.modules) {
						const identifier = module.identifier().toLowerCase();
						const array = moduleWithoutCase.get(identifier);
						if (array) {
							array.push(module);
						} else {
							moduleWithoutCase.set(identifier, [module]);
						}
					}
					for (const pair of moduleWithoutCase) {
						const array = pair[1];
						if (array.length > 1) {
							compilation.warnings.push(new CaseSensitiveModulesWarning(array));
						}
					}
				});
			}
		);
	}
}

module.exports = WarnCaseSensitiveModulesPlugin;

},
// 230
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);

const sortModules = modules => {
	return modules.slice().sort((a, b) => {
		const aIdent = a.identifier();
		const bIdent = b.identifier();
		if (aIdent < bIdent) return -1;
		if (aIdent > bIdent) return 1;
		return 0;
	});
};

const createModulesListMessage = modules => {
	return modules
		.map(m => {
			let message = `* ${m.identifier()}`;
			const validReasons = m.reasons.filter(reason => reason.module);

			if (validReasons.length > 0) {
				message += `\n    Used by ${validReasons.length} module(s), i. e.`;
				message += `\n    ${validReasons[0].module.identifier()}`;
			}
			return message;
		})
		.join("\n");
};

class CaseSensitiveModulesWarning extends WebpackError {
	constructor(modules) {
		const sortedModules = sortModules(modules);
		const modulesList = createModulesListMessage(sortedModules);
		super(`There are multiple modules with names that only differ in casing.
This can lead to unexpected behavior when compiling on a filesystem with other case-semantic.
Use equal casing. Compare these module identifiers:
${modulesList}`);

		this.name = "CaseSensitiveModulesWarning";
		this.origin = this.module = sortedModules[0];

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = CaseSensitiveModulesWarning;

},
// 231
function(module, exports, __webpack_require__) {

const ConstDependency = __webpack_require__(5);

class UseStrictPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"UseStrictPlugin",
			(compilation, { normalModuleFactory }) => {
				const handler = parser => {
					parser.hooks.program.tap("UseStrictPlugin", ast => {
						const firstNode = ast.body[0];
						if (
							firstNode &&
							firstNode.type === "ExpressionStatement" &&
							firstNode.expression.type === "Literal" &&
							firstNode.expression.value === "use strict"
						) {
							const dep = new ConstDependency("", firstNode.range);
							dep.loc = firstNode.loc;
							parser.state.current.addDependency(dep);
							parser.state.module.buildInfo.strict = true;
						}
					});
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("UseStrictPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("UseStrictPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/esm")
					.tap("UseStrictPlugin", handler);
			}
		);
	}
}

module.exports = UseStrictPlugin;

},
// 232
function(module, exports, __webpack_require__) {

const LoaderDependency = __webpack_require__(233);
const NormalModule = __webpack_require__(54);

class LoaderPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"LoaderPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					LoaderDependency,
					normalModuleFactory
				);
			}
		);

		compiler.hooks.compilation.tap("LoaderPlugin", compilation => {
			compilation.hooks.normalModuleLoader.tap(
				"LoaderPlugin",
				(loaderContext, module) => {
					loaderContext.loadModule = (request, callback) => {
						const dep = new LoaderDependency(request);
						dep.loc = {
							name: request
						};
						const factory = compilation.dependencyFactories.get(
							dep.constructor
						);
						if (factory === void 0) {
							return callback(
								new Error(
									`No module factory available for dependency type: ${dep.constructor.name}`
								)
							);
						}
						compilation.semaphore.release();
						compilation.addModuleDependencies(
							module,
							[
								{
									factory,
									dependencies: [dep]
								}
							],
							true,
							"lm",
							true,
							err => {
								compilation.semaphore.acquire(() => {
									if (err) {
										return callback(err);
									}
									if (!dep.module) {
										return callback(new Error("Cannot load the module"));
									}
									if (dep.module instanceof NormalModule && dep.module.error) {
										return callback(dep.module.error);
									}
									if (!dep.module._source) {
										throw new Error(
											"The module created for a LoaderDependency must have a property _source"
										);
									}
									let source, map;
									const moduleSource = dep.module._source;
									if (moduleSource.sourceAndMap) {
										const sourceAndMap = moduleSource.sourceAndMap();
										map = sourceAndMap.map;
										source = sourceAndMap.source;
									} else {
										map = moduleSource.map();
										source = moduleSource.source();
									}
									if (dep.module.buildInfo.fileDependencies) {
										for (const d of dep.module.buildInfo.fileDependencies) {
											loaderContext.addDependency(d);
										}
									}
									if (dep.module.buildInfo.contextDependencies) {
										for (const d of dep.module.buildInfo.contextDependencies) {
											loaderContext.addContextDependency(d);
										}
									}
									return callback(null, source, map, dep.module);
								});
							}
						);
					};
				}
			);
		});
	}
}
module.exports = LoaderPlugin;

},
// 233
function(module, exports, __webpack_require__) {

const ModuleDependency = __webpack_require__(4);

class LoaderDependency extends ModuleDependency {
	constructor(request) {
		super(request);
	}

	get type() {
		return "loader";
	}
}

module.exports = LoaderDependency;

},
// 234
function(module, exports, __webpack_require__) {

const ConstDependency = __webpack_require__(5);
const CommonJsRequireDependency = __webpack_require__(96);
const CommonJsRequireContextDependency = __webpack_require__(97);
const RequireResolveDependency = __webpack_require__(98);
const RequireResolveContextDependency = __webpack_require__(99);
const RequireResolveHeaderDependency = __webpack_require__(100);
const RequireHeaderDependency = __webpack_require__(101);

const NullFactory = __webpack_require__(10);

const RequireResolveDependencyParserPlugin = __webpack_require__(237);
const CommonJsRequireDependencyParserPlugin = __webpack_require__(238);

const ParserHelpers = __webpack_require__(9);

class CommonJsPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		compiler.hooks.compilation.tap(
			"CommonJsPlugin",
			(compilation, { contextModuleFactory, normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					CommonJsRequireDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					CommonJsRequireDependency,
					new CommonJsRequireDependency.Template()
				);

				compilation.dependencyFactories.set(
					CommonJsRequireContextDependency,
					contextModuleFactory
				);
				compilation.dependencyTemplates.set(
					CommonJsRequireContextDependency,
					new CommonJsRequireContextDependency.Template()
				);

				compilation.dependencyFactories.set(
					RequireResolveDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					RequireResolveDependency,
					new RequireResolveDependency.Template()
				);

				compilation.dependencyFactories.set(
					RequireResolveContextDependency,
					contextModuleFactory
				);
				compilation.dependencyTemplates.set(
					RequireResolveContextDependency,
					new RequireResolveContextDependency.Template()
				);

				compilation.dependencyFactories.set(
					RequireResolveHeaderDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					RequireResolveHeaderDependency,
					new RequireResolveHeaderDependency.Template()
				);

				compilation.dependencyFactories.set(
					RequireHeaderDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					RequireHeaderDependency,
					new RequireHeaderDependency.Template()
				);

				const handler = (parser, parserOptions) => {
					if (parserOptions.commonjs !== void 0 && !parserOptions.commonjs)
						return;

					const requireExpressions = [
						"require",
						"require.resolve",
						"require.resolveWeak"
					];
					for (let expression of requireExpressions) {
						parser.hooks.typeof
							.for(expression)
							.tap(
								"CommonJsPlugin",
								ParserHelpers.toConstantDependency(
									parser,
									JSON.stringify("function")
								)
							);
						parser.hooks.evaluateTypeof
							.for(expression)
							.tap(
								"CommonJsPlugin",
								ParserHelpers.evaluateToString("function")
							);
						parser.hooks.evaluateIdentifier
							.for(expression)
							.tap(
								"CommonJsPlugin",
								ParserHelpers.evaluateToIdentifier(expression, true)
							);
					}

					parser.hooks.evaluateTypeof
						.for("module")
						.tap("CommonJsPlugin", ParserHelpers.evaluateToString("object"));
					parser.hooks.assign.for("require").tap("CommonJsPlugin", expr => {
						const dep = new ConstDependency("var require;", 0);
						dep.loc = expr.loc;
						parser.state.current.addDependency(dep);
						parser.scope.definitions.add("require");
						return true;
					});
					parser.hooks.canRename
						.for("require")
						.tap("CommonJsPlugin", () => true);
					parser.hooks.rename.for("require").tap("CommonJsPlugin", expr => {
						const dep = new ConstDependency("var require;", 0);
						dep.loc = expr.loc;
						parser.state.current.addDependency(dep);
						return false;
					});
					parser.hooks.typeof.for("module").tap("CommonJsPlugin", () => true);
					parser.hooks.evaluateTypeof
						.for("exports")
						.tap("CommonJsPlugin", ParserHelpers.evaluateToString("object"));

					new CommonJsRequireDependencyParserPlugin(options).apply(parser);
					new RequireResolveDependencyParserPlugin(options).apply(parser);
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("CommonJsPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("CommonJsPlugin", handler);
			}
		);
	}
}
module.exports = CommonJsPlugin;

},
// 235
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);

class CriticalDependencyWarning extends WebpackError {
	constructor(message) {
		super();

		this.name = "CriticalDependencyWarning";
		this.message = "Critical dependency: " + message;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = CriticalDependencyWarning;

},
// 236
function(module, exports, __webpack_require__) {

class ContextDependencyTemplateAsId {
	apply(dep, source, runtime) {
		const moduleExports = runtime.moduleExports({
			module: dep.module,
			request: dep.request
		});

		if (dep.module) {
			if (dep.valueRange) {
				if (Array.isArray(dep.replaces)) {
					for (let i = 0; i < dep.replaces.length; i++) {
						const rep = dep.replaces[i];
						source.replace(rep.range[0], rep.range[1] - 1, rep.value);
					}
				}
				source.replace(dep.valueRange[1], dep.range[1] - 1, ")");
				source.replace(
					dep.range[0],
					dep.valueRange[0] - 1,
					`${moduleExports}.resolve(${
						typeof dep.prepend == "string" ? JSON.stringify(dep.prepend) : ""
					}`
				);
			} else {
				source.replace(
					dep.range[0],
					dep.range[1] - 1,
					`${moduleExports}.resolve`
				);
			}
		} else {
			source.replace(dep.range[0], dep.range[1] - 1, moduleExports);
		}
	}
}
module.exports = ContextDependencyTemplateAsId;

},
// 237
function(module, exports, __webpack_require__) {

const RequireResolveDependency = __webpack_require__(98);
const RequireResolveContextDependency = __webpack_require__(99);
const RequireResolveHeaderDependency = __webpack_require__(100);
const ContextDependencyHelpers = __webpack_require__(27);

class RequireResolveDependencyParserPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(parser) {
		const options = this.options;

		const process = (expr, weak) => {
			if (expr.arguments.length !== 1) return;
			const param = parser.evaluateExpression(expr.arguments[0]);
			if (param.isConditional()) {
				for (const option of param.options) {
					const result = processItem(expr, option, weak);
					if (result === void 0) {
						processContext(expr, option, weak);
					}
				}
				const dep = new RequireResolveHeaderDependency(expr.callee.range);
				dep.loc = expr.loc;
				parser.state.current.addDependency(dep);
				return true;
			} else {
				const result = processItem(expr, param, weak);
				if (result === void 0) {
					processContext(expr, param, weak);
				}
				const dep = new RequireResolveHeaderDependency(expr.callee.range);
				dep.loc = expr.loc;
				parser.state.current.addDependency(dep);
				return true;
			}
		};
		const processItem = (expr, param, weak) => {
			if (param.isString()) {
				const dep = new RequireResolveDependency(param.string, param.range);
				dep.loc = expr.loc;
				dep.optional = !!parser.scope.inTry;
				dep.weak = weak;
				parser.state.current.addDependency(dep);
				return true;
			}
		};
		const processContext = (expr, param, weak) => {
			const dep = ContextDependencyHelpers.create(
				RequireResolveContextDependency,
				param.range,
				param,
				expr,
				options,
				{
					mode: weak ? "weak" : "sync"
				},
				parser
			);
			if (!dep) return;
			dep.loc = expr.loc;
			dep.optional = !!parser.scope.inTry;
			parser.state.current.addDependency(dep);
			return true;
		};

		parser.hooks.call
			.for("require.resolve")
			.tap("RequireResolveDependencyParserPlugin", expr => {
				return process(expr, false);
			});
		parser.hooks.call
			.for("require.resolveWeak")
			.tap("RequireResolveDependencyParserPlugin", expr => {
				return process(expr, true);
			});
	}
}
module.exports = RequireResolveDependencyParserPlugin;

},
// 238
function(module, exports, __webpack_require__) {

const CommonJsRequireDependency = __webpack_require__(96);
const CommonJsRequireContextDependency = __webpack_require__(97);
const RequireHeaderDependency = __webpack_require__(101);
const LocalModuleDependency = __webpack_require__(40);
const ContextDependencyHelpers = __webpack_require__(27);
const LocalModulesHelpers = __webpack_require__(64);
const ParserHelpers = __webpack_require__(9);

class CommonJsRequireDependencyParserPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(parser) {
		const options = this.options;

		const processItem = (expr, param) => {
			if (param.isString()) {
				const dep = new CommonJsRequireDependency(param.string, param.range);
				dep.loc = expr.loc;
				dep.optional = !!parser.scope.inTry;
				parser.state.current.addDependency(dep);
				return true;
			}
		};
		const processContext = (expr, param) => {
			const dep = ContextDependencyHelpers.create(
				CommonJsRequireContextDependency,
				expr.range,
				param,
				expr,
				options,
				{},
				parser
			);
			if (!dep) return;
			dep.loc = expr.loc;
			dep.optional = !!parser.scope.inTry;
			parser.state.current.addDependency(dep);
			return true;
		};

		parser.hooks.expression
			.for("require.cache")
			.tap(
				"CommonJsRequireDependencyParserPlugin",
				ParserHelpers.toConstantDependencyWithWebpackRequire(
					parser,
					"__webpack_require__.c"
				)
			);
		parser.hooks.expression
			.for("require")
			.tap("CommonJsRequireDependencyParserPlugin", expr => {
				const dep = new CommonJsRequireContextDependency(
					{
						request: options.unknownContextRequest,
						recursive: options.unknownContextRecursive,
						regExp: options.unknownContextRegExp,
						mode: "sync"
					},
					expr.range
				);
				dep.critical =
					options.unknownContextCritical &&
					"require function is used in a way in which dependencies cannot be statically extracted";
				dep.loc = expr.loc;
				dep.optional = !!parser.scope.inTry;
				parser.state.current.addDependency(dep);
				return true;
			});

		const createHandler = callNew => expr => {
			if (expr.arguments.length !== 1) return;
			let localModule;
			const param = parser.evaluateExpression(expr.arguments[0]);
			if (param.isConditional()) {
				let isExpression = false;
				const prevLength = parser.state.current.dependencies.length;
				const dep = new RequireHeaderDependency(expr.callee.range);
				dep.loc = expr.loc;
				parser.state.current.addDependency(dep);
				for (const p of param.options) {
					const result = processItem(expr, p);
					if (result === void 0) {
						isExpression = true;
					}
				}
				if (isExpression) {
					parser.state.current.dependencies.length = prevLength;
				} else {
					return true;
				}
			}
			if (
				param.isString() &&
				(localModule = LocalModulesHelpers.getLocalModule(
					parser.state,
					param.string
				))
			) {
				const dep = new LocalModuleDependency(localModule, expr.range, callNew);
				dep.loc = expr.loc;
				parser.state.current.addDependency(dep);
				return true;
			} else {
				const result = processItem(expr, param);
				if (result === void 0) {
					processContext(expr, param);
				} else {
					const dep = new RequireHeaderDependency(expr.callee.range);
					dep.loc = expr.loc;
					parser.state.current.addDependency(dep);
				}
				return true;
			}
		};
		parser.hooks.call
			.for("require")
			.tap("CommonJsRequireDependencyParserPlugin", createHandler(false));
		parser.hooks.new
			.for("require")
			.tap("CommonJsRequireDependencyParserPlugin", createHandler(true));
		parser.hooks.call
			.for("module.require")
			.tap("CommonJsRequireDependencyParserPlugin", createHandler(false));
		parser.hooks.new
			.for("module.require")
			.tap("CommonJsRequireDependencyParserPlugin", createHandler(true));
	}
}
module.exports = CommonJsRequireDependencyParserPlugin;

},
// 239
function(module, exports, __webpack_require__) {

class LocalModule {
	constructor(module, name, idx) {
		this.module = module;
		this.name = name;
		this.idx = idx;
		this.used = false;
	}

	flagUsed() {
		this.used = true;
	}

	variableName() {
		return "__WEBPACK_LOCAL_MODULE_" + this.idx + "__";
	}
}
module.exports = LocalModule;

},
// 240
function(module, exports, __webpack_require__) {

const HarmonyCompatibilityDependency = __webpack_require__(41);
const HarmonyInitDependency = __webpack_require__(102);
const HarmonyImportSpecifierDependency = __webpack_require__(42);
const HarmonyImportSideEffectDependency = __webpack_require__(28);
const HarmonyExportHeaderDependency = __webpack_require__(104);
const HarmonyExportExpressionDependency = __webpack_require__(65);
const HarmonyExportSpecifierDependency = __webpack_require__(66);
const HarmonyExportImportedSpecifierDependency = __webpack_require__(43);
const HarmonyAcceptDependency = __webpack_require__(105);
const HarmonyAcceptImportDependency = __webpack_require__(106);

const NullFactory = __webpack_require__(10);

const HarmonyDetectionParserPlugin = __webpack_require__(241);
const HarmonyImportDependencyParserPlugin = __webpack_require__(242);
const HarmonyExportDependencyParserPlugin = __webpack_require__(243);
const HarmonyTopLevelThisParserPlugin = __webpack_require__(244);

class HarmonyModulesPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap(
			"HarmonyModulesPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					HarmonyCompatibilityDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					HarmonyCompatibilityDependency,
					new HarmonyCompatibilityDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyInitDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					HarmonyInitDependency,
					new HarmonyInitDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyImportSideEffectDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					HarmonyImportSideEffectDependency,
					new HarmonyImportSideEffectDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyImportSpecifierDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					HarmonyImportSpecifierDependency,
					new HarmonyImportSpecifierDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyExportHeaderDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					HarmonyExportHeaderDependency,
					new HarmonyExportHeaderDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyExportExpressionDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					HarmonyExportExpressionDependency,
					new HarmonyExportExpressionDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyExportSpecifierDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					HarmonyExportSpecifierDependency,
					new HarmonyExportSpecifierDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyExportImportedSpecifierDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					HarmonyExportImportedSpecifierDependency,
					new HarmonyExportImportedSpecifierDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyAcceptDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					HarmonyAcceptDependency,
					new HarmonyAcceptDependency.Template()
				);

				compilation.dependencyFactories.set(
					HarmonyAcceptImportDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					HarmonyAcceptImportDependency,
					new HarmonyAcceptImportDependency.Template()
				);

				const handler = (parser, parserOptions) => {
					if (parserOptions.harmony !== void 0 && !parserOptions.harmony)
						return;

					new HarmonyDetectionParserPlugin().apply(parser);
					new HarmonyImportDependencyParserPlugin(this.options).apply(parser);
					new HarmonyExportDependencyParserPlugin(this.options).apply(parser);
					new HarmonyTopLevelThisParserPlugin().apply(parser);
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("HarmonyModulesPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/esm")
					.tap("HarmonyModulesPlugin", handler);
			}
		);
	}
}
module.exports = HarmonyModulesPlugin;

},
// 241
function(module, exports, __webpack_require__) {

const HarmonyCompatibilityDependency = __webpack_require__(41);
const HarmonyInitDependency = __webpack_require__(102);

module.exports = class {
	apply(parser) {
		parser.hooks.program.tap("HarmonyDetectionParserPlugin", ast => {
			const isStrictHarmony = parser.state.module.type === "javascript/esm";
			const isHarmony =
				isStrictHarmony ||
				ast.body.some(
					statement =>
						statement.type === "ImportDeclaration" ||
						statement.type === "ExportDefaultDeclaration" ||
						statement.type === "ExportNamedDeclaration" ||
						statement.type === "ExportAllDeclaration"
				);
			if (isHarmony) {
				const module = parser.state.module;
				const compatDep = new HarmonyCompatibilityDependency(module);
				compatDep.loc = {
					start: {
						line: -1,
						column: 0
					},
					end: {
						line: -1,
						column: 0
					},
					index: -3
				};
				module.addDependency(compatDep);
				const initDep = new HarmonyInitDependency(module);
				initDep.loc = {
					start: {
						line: -1,
						column: 0
					},
					end: {
						line: -1,
						column: 0
					},
					index: -2
				};
				module.addDependency(initDep);
				parser.state.harmonyParserScope = parser.state.harmonyParserScope || {};
				parser.scope.isStrict = true;
				module.buildMeta.exportsType = "namespace";
				module.buildInfo.strict = true;
				module.buildInfo.exportsArgument = "__webpack_exports__";
				if (isStrictHarmony) {
					module.buildMeta.strictHarmonyModule = true;
					module.buildInfo.moduleArgument = "__webpack_module__";
				}
			}
		});

		const skipInHarmony = () => {
			const module = parser.state.module;
			if (module && module.buildMeta && module.buildMeta.exportsType) {
				return true;
			}
		};

		const nullInHarmony = () => {
			const module = parser.state.module;
			if (module && module.buildMeta && module.buildMeta.exportsType) {
				return null;
			}
		};

		const nonHarmonyIdentifiers = ["define", "exports"];
		for (const identifer of nonHarmonyIdentifiers) {
			parser.hooks.evaluateTypeof
				.for(identifer)
				.tap("HarmonyDetectionParserPlugin", nullInHarmony);
			parser.hooks.typeof
				.for(identifer)
				.tap("HarmonyDetectionParserPlugin", skipInHarmony);
			parser.hooks.evaluate
				.for(identifer)
				.tap("HarmonyDetectionParserPlugin", nullInHarmony);
			parser.hooks.expression
				.for(identifer)
				.tap("HarmonyDetectionParserPlugin", skipInHarmony);
			parser.hooks.call
				.for(identifer)
				.tap("HarmonyDetectionParserPlugin", skipInHarmony);
		}
	}
};

},
// 242
function(module, exports, __webpack_require__) {

const { SyncBailHook } = __webpack_require__(6);
const HarmonyImportSideEffectDependency = __webpack_require__(28);
const HarmonyImportSpecifierDependency = __webpack_require__(42);
const HarmonyAcceptImportDependency = __webpack_require__(106);
const HarmonyAcceptDependency = __webpack_require__(105);
const ConstDependency = __webpack_require__(5);

module.exports = class {
	constructor(moduleOptions) {
		this.strictExportPresence = moduleOptions.strictExportPresence;
		this.strictThisContextOnImports = moduleOptions.strictThisContextOnImports;
	}

	apply(parser) {
		parser.hooks.import.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source) => {
				parser.state.lastHarmonyImportOrder =
					(parser.state.lastHarmonyImportOrder || 0) + 1;
				const clearDep = new ConstDependency("", statement.range);
				clearDep.loc = statement.loc;
				parser.state.module.addDependency(clearDep);
				const sideEffectDep = new HarmonyImportSideEffectDependency(
					source,
					parser.state.module,
					parser.state.lastHarmonyImportOrder,
					parser.state.harmonyParserScope
				);
				sideEffectDep.loc = statement.loc;
				parser.state.module.addDependency(sideEffectDep);
				return true;
			}
		);
		parser.hooks.importSpecifier.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source, id, name) => {
				parser.scope.definitions.delete(name);
				parser.scope.renames.set(name, "imported var");
				if (!parser.state.harmonySpecifier) {
					parser.state.harmonySpecifier = new Map();
				}
				parser.state.harmonySpecifier.set(name, {
					source,
					id,
					sourceOrder: parser.state.lastHarmonyImportOrder
				});
				return true;
			}
		);
		parser.hooks.expression
			.for("imported var")
			.tap("HarmonyImportDependencyParserPlugin", expr => {
				const name = expr.name;
				const settings = parser.state.harmonySpecifier.get(name);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					parser.state.module,
					settings.sourceOrder,
					parser.state.harmonyParserScope,
					settings.id,
					name,
					expr.range,
					this.strictExportPresence
				);
				dep.shorthand = parser.scope.inShorthand;
				dep.directImport = true;
				dep.loc = expr.loc;
				parser.state.module.addDependency(dep);
				return true;
			});
		parser.hooks.expressionAnyMember
			.for("imported var")
			.tap("HarmonyImportDependencyParserPlugin", expr => {
				const name = expr.object.name;
				const settings = parser.state.harmonySpecifier.get(name);
				if (settings.id !== null) return false;
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					parser.state.module,
					settings.sourceOrder,
					parser.state.harmonyParserScope,
					expr.property.name || expr.property.value,
					name,
					expr.range,
					this.strictExportPresence
				);
				dep.shorthand = parser.scope.inShorthand;
				dep.directImport = false;
				dep.loc = expr.loc;
				parser.state.module.addDependency(dep);
				return true;
			});
		if (this.strictThisContextOnImports) {
			parser.hooks.callAnyMember
				.for("imported var")
				.tap("HarmonyImportDependencyParserPlugin", expr => {
					if (expr.callee.type !== "MemberExpression") return;
					if (expr.callee.object.type !== "Identifier") return;
					const name = expr.callee.object.name;
					const settings = parser.state.harmonySpecifier.get(name);
					if (settings.id !== null) return false;
					const dep = new HarmonyImportSpecifierDependency(
						settings.source,
						parser.state.module,
						settings.sourceOrder,
						parser.state.harmonyParserScope,
						expr.callee.property.name || expr.callee.property.value,
						name,
						expr.callee.range,
						this.strictExportPresence
					);
					dep.shorthand = parser.scope.inShorthand;
					dep.directImport = false;
					dep.namespaceObjectAsContext = true;
					dep.loc = expr.callee.loc;
					parser.state.module.addDependency(dep);
					if (expr.arguments) parser.walkExpressions(expr.arguments);
					return true;
				});
		}
		parser.hooks.call
			.for("imported var")
			.tap("HarmonyImportDependencyParserPlugin", expr => {
				const args = expr.arguments;
				const fullExpr = expr;
				expr = expr.callee;
				if (expr.type !== "Identifier") return;
				const name = expr.name;
				const settings = parser.state.harmonySpecifier.get(name);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					parser.state.module,
					settings.sourceOrder,
					parser.state.harmonyParserScope,
					settings.id,
					name,
					expr.range,
					this.strictExportPresence
				);
				dep.directImport = true;
				dep.callArgs = args;
				dep.call = fullExpr;
				dep.loc = expr.loc;
				parser.state.module.addDependency(dep);
				if (args) parser.walkExpressions(args);
				return true;
			});
		if (!parser.hooks.hotAcceptCallback) {
			parser.hooks.hotAcceptCallback = new SyncBailHook([
				"expression",
				"requests"
			]);
		}
		if (!parser.hooks.hotAcceptWithoutCallback) {
			parser.hooks.hotAcceptWithoutCallback = new SyncBailHook([
				"expression",
				"requests"
			]);
		}
		parser.hooks.hotAcceptCallback.tap(
			"HarmonyImportDependencyParserPlugin",
			(expr, requests) => {
				const harmonyParserScope = parser.state.harmonyParserScope;
				if (!harmonyParserScope) {
					return;
				}
				const dependencies = requests.map(request => {
					const dep = new HarmonyAcceptImportDependency(
						request,
						parser.state.module,
						harmonyParserScope
					);
					dep.loc = expr.loc;
					parser.state.module.addDependency(dep);
					return dep;
				});
				if (dependencies.length > 0) {
					const dep = new HarmonyAcceptDependency(
						expr.range,
						dependencies,
						true
					);
					dep.loc = expr.loc;
					parser.state.module.addDependency(dep);
				}
			}
		);
		parser.hooks.hotAcceptWithoutCallback.tap(
			"HarmonyImportDependencyParserPlugin",
			(expr, requests) => {
				const dependencies = requests.map(request => {
					const dep = new HarmonyAcceptImportDependency(
						request,
						parser.state.module,
						parser.state.harmonyParserScope
					);
					dep.loc = expr.loc;
					parser.state.module.addDependency(dep);
					return dep;
				});
				if (dependencies.length > 0) {
					const dep = new HarmonyAcceptDependency(
						expr.range,
						dependencies,
						false
					);
					dep.loc = expr.loc;
					parser.state.module.addDependency(dep);
				}
			}
		);
	}
};

},
// 243
function(module, exports, __webpack_require__) {

const HarmonyExportExpressionDependency = __webpack_require__(65);
const HarmonyImportSideEffectDependency = __webpack_require__(28);
const HarmonyExportHeaderDependency = __webpack_require__(104);
const HarmonyExportSpecifierDependency = __webpack_require__(66);
const HarmonyExportImportedSpecifierDependency = __webpack_require__(43);
const ConstDependency = __webpack_require__(5);

module.exports = class {
	constructor(moduleOptions) {
		this.strictExportPresence = moduleOptions.strictExportPresence;
	}

	apply(parser) {
		parser.hooks.export.tap(
			"HarmonyExportDependencyParserPlugin",
			statement => {
				const dep = new HarmonyExportHeaderDependency(
					statement.declaration && statement.declaration.range,
					statement.range
				);
				dep.loc = Object.create(statement.loc);
				dep.loc.index = -1;
				parser.state.current.addDependency(dep);
				return true;
			}
		);
		parser.hooks.exportImport.tap(
			"HarmonyExportDependencyParserPlugin",
			(statement, source) => {
				parser.state.lastHarmonyImportOrder =
					(parser.state.lastHarmonyImportOrder || 0) + 1;
				const clearDep = new ConstDependency("", statement.range);
				clearDep.loc = Object.create(statement.loc);
				clearDep.loc.index = -1;
				parser.state.current.addDependency(clearDep);
				const sideEffectDep = new HarmonyImportSideEffectDependency(
					source,
					parser.state.module,
					parser.state.lastHarmonyImportOrder,
					parser.state.harmonyParserScope
				);
				sideEffectDep.loc = Object.create(statement.loc);
				sideEffectDep.loc.index = -1;
				parser.state.current.addDependency(sideEffectDep);
				return true;
			}
		);
		parser.hooks.exportExpression.tap(
			"HarmonyExportDependencyParserPlugin",
			(statement, expr) => {
				const comments = parser.getComments([
					statement.range[0],
					expr.range[0]
				]);
				const dep = new HarmonyExportExpressionDependency(
					parser.state.module,
					expr.range,
					statement.range,
					comments
						.map(c => {
							switch (c.type) {
								case "Block":
									return `/*${c.value}*/`;
								case "Line":
									return `//${c.value}\n`;
							}
							return "";
						})
						.join("")
				);
				dep.loc = Object.create(statement.loc);
				dep.loc.index = -1;
				parser.state.current.addDependency(dep);
				return true;
			}
		);
		parser.hooks.exportDeclaration.tap(
			"HarmonyExportDependencyParserPlugin",
			statement => {}
		);
		parser.hooks.exportSpecifier.tap(
			"HarmonyExportDependencyParserPlugin",
			(statement, id, name, idx) => {
				const rename = parser.scope.renames.get(id);
				let dep;
				const harmonyNamedExports = (parser.state.harmonyNamedExports =
					parser.state.harmonyNamedExports || new Set());
				harmonyNamedExports.add(name);
				if (rename === "imported var") {
					const settings = parser.state.harmonySpecifier.get(id);
					dep = new HarmonyExportImportedSpecifierDependency(
						settings.source,
						parser.state.module,
						settings.sourceOrder,
						parser.state.harmonyParserScope,
						settings.id,
						name,
						harmonyNamedExports,
						null,
						this.strictExportPresence
					);
				} else {
					dep = new HarmonyExportSpecifierDependency(
						parser.state.module,
						id,
						name
					);
				}
				dep.loc = Object.create(statement.loc);
				dep.loc.index = idx;
				parser.state.current.addDependency(dep);
				return true;
			}
		);
		parser.hooks.exportImportSpecifier.tap(
			"HarmonyExportDependencyParserPlugin",
			(statement, source, id, name, idx) => {
				const harmonyNamedExports = (parser.state.harmonyNamedExports =
					parser.state.harmonyNamedExports || new Set());
				let harmonyStarExports = null;
				if (name) {
					harmonyNamedExports.add(name);
				} else {
					harmonyStarExports = parser.state.harmonyStarExports =
						parser.state.harmonyStarExports || [];
				}
				const dep = new HarmonyExportImportedSpecifierDependency(
					source,
					parser.state.module,
					parser.state.lastHarmonyImportOrder,
					parser.state.harmonyParserScope,
					id,
					name,
					harmonyNamedExports,
					harmonyStarExports && harmonyStarExports.slice(),
					this.strictExportPresence
				);
				if (harmonyStarExports) {
					harmonyStarExports.push(dep);
				}
				dep.loc = Object.create(statement.loc);
				dep.loc.index = idx;
				parser.state.current.addDependency(dep);
				return true;
			}
		);
	}
};

},
// 244
function(module, exports, __webpack_require__) {

const ConstDependency = __webpack_require__(5);

class HarmonyTopLevelThisParserPlugin {
	apply(parser) {
		parser.hooks.expression
			.for("this")
			.tap("HarmonyTopLevelThisParserPlugin", node => {
				if (!parser.scope.topLevelScope) return;
				const module = parser.state.module;
				const isHarmony = !!(module.buildMeta && module.buildMeta.exportsType);
				if (isHarmony) {
					const dep = new ConstDependency("undefined", node.range, false);
					dep.loc = node.loc;
					parser.state.current.addDependency(dep);
				}
			});
	}
}

module.exports = HarmonyTopLevelThisParserPlugin;

},
// 245
function(module, exports, __webpack_require__) {

const ParserHelpers = __webpack_require__(9);
const WebpackError = __webpack_require__(1);

class SystemPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap(
			"SystemPlugin",
			(compilation, { normalModuleFactory }) => {
				const handler = (parser, parserOptions) => {
					if (parserOptions.system !== void 0 && !parserOptions.system)
						return;

					const shouldWarn = parserOptions.system === void 0;

					const setNotSupported = name => {
						parser.hooks.evaluateTypeof
							.for(name)
							.tap("SystemPlugin", ParserHelpers.evaluateToString("undefined"));
						parser.hooks.expression
							.for(name)
							.tap(
								"SystemPlugin",
								ParserHelpers.expressionIsUnsupported(
									parser,
									name + " is not supported by webpack."
								)
							);
					};

					parser.hooks.typeof
						.for("System.import")
						.tap(
							"SystemPlugin",
							ParserHelpers.toConstantDependency(
								parser,
								JSON.stringify("function")
							)
						);
					parser.hooks.evaluateTypeof
						.for("System.import")
						.tap("SystemPlugin", ParserHelpers.evaluateToString("function"));
					parser.hooks.typeof
						.for("System")
						.tap(
							"SystemPlugin",
							ParserHelpers.toConstantDependency(
								parser,
								JSON.stringify("object")
							)
						);
					parser.hooks.evaluateTypeof
						.for("System")
						.tap("SystemPlugin", ParserHelpers.evaluateToString("object"));

					setNotSupported("System.set");
					setNotSupported("System.get");
					setNotSupported("System.register");

					parser.hooks.expression.for("System").tap("SystemPlugin", () => {
						const systemPolyfillRequire = ParserHelpers.requireFileAsExpression(
							parser.state.module.context,
							require.resolve("../buildin/system")
						);
						return ParserHelpers.addParsedVariableToModule(
							parser,
							"System",
							systemPolyfillRequire
						);
					});

					parser.hooks.call.for("System.import").tap("SystemPlugin", expr => {
						if (shouldWarn) {
							parser.state.module.warnings.push(
								new SystemImportDeprecationWarning(
									parser.state.module,
									expr.loc
								)
							);
						}

						return parser.hooks.importCall.call(expr);
					});
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("SystemPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("SystemPlugin", handler);
			}
		);
	}
}

class SystemImportDeprecationWarning extends WebpackError {
	constructor(module, loc) {
		super(
			"System.import() is deprecated and will be removed soon. Use import() instead.\nFor more info visit https://webpack.js.org/guides/code-splitting/"
		);

		this.name = "SystemImportDeprecationWarning";

		this.module = module;
		this.loc = loc;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = SystemPlugin;

},
// 246
function(module, exports, __webpack_require__) {

const ImportDependency = __webpack_require__(107);
const ImportEagerDependency = __webpack_require__(108);
const ImportWeakDependency = __webpack_require__(109);
const ImportContextDependency = __webpack_require__(110);
const ImportParserPlugin = __webpack_require__(247);

class ImportPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		compiler.hooks.compilation.tap(
			"ImportPlugin",
			(compilation, { contextModuleFactory, normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					ImportDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					ImportDependency,
					new ImportDependency.Template()
				);

				compilation.dependencyFactories.set(
					ImportEagerDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					ImportEagerDependency,
					new ImportEagerDependency.Template()
				);

				compilation.dependencyFactories.set(
					ImportWeakDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					ImportWeakDependency,
					new ImportWeakDependency.Template()
				);

				compilation.dependencyFactories.set(
					ImportContextDependency,
					contextModuleFactory
				);
				compilation.dependencyTemplates.set(
					ImportContextDependency,
					new ImportContextDependency.Template()
				);

				const handler = (parser, parserOptions) => {
					if (parserOptions.import !== void 0 && !parserOptions.import)
						return;

					new ImportParserPlugin(options).apply(parser);
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("ImportPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("ImportPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/esm")
					.tap("ImportPlugin", handler);
			}
		);
	}
}
module.exports = ImportPlugin;

},
// 247
function(module, exports, __webpack_require__) {

const ImportContextDependency = __webpack_require__(110);
const ImportWeakDependency = __webpack_require__(109);
const ImportDependenciesBlock = __webpack_require__(248);
const ImportEagerDependency = __webpack_require__(108);
const ContextDependencyHelpers = __webpack_require__(27);
const UnsupportedFeatureWarning = __webpack_require__(62);
const CommentCompilationWarning = __webpack_require__(249);

class ImportParserPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(parser) {
		parser.hooks.importCall.tap("ImportParserPlugin", expr => {
			if (expr.arguments.length !== 1) {
				throw new Error(
					"Incorrect number of arguments provided to 'import(module: string) -> Promise'."
				);
			}

			const param = parser.evaluateExpression(expr.arguments[0]);

			let chunkName = null;
			let mode = "lazy";
			let include = null;
			let exclude = null;
			const groupOptions = {};

			const {
				options: importOptions,
				errors: commentErrors
			} = parser.parseCommentOptions(expr.range);

			if (commentErrors) {
				for (const e of commentErrors) {
					const { comment } = e;
					parser.state.module.warnings.push(
						new CommentCompilationWarning(
							`Compilation error while processing magic comment(-s): /*${comment.value}*/: ${e.message}`,
							parser.state.module,
							comment.loc
						)
					);
				}
			}

			if (importOptions) {
				if (importOptions.webpackIgnore !== void 0) {
					if (typeof importOptions.webpackIgnore != "boolean") {
						parser.state.module.warnings.push(
							new UnsupportedFeatureWarning(
								parser.state.module,
								`\`webpackIgnore\` expected a boolean, but received: ${importOptions.webpackIgnore}.`,
								expr.loc
							)
						);
					} else {
						if (importOptions.webpackIgnore) {
							return false;
						}
					}
				}
				if (importOptions.webpackChunkName !== void 0) {
					if (typeof importOptions.webpackChunkName != "string") {
						parser.state.module.warnings.push(
							new UnsupportedFeatureWarning(
								parser.state.module,
								`\`webpackChunkName\` expected a string, but received: ${importOptions.webpackChunkName}.`,
								expr.loc
							)
						);
					} else {
						chunkName = importOptions.webpackChunkName;
					}
				}
				if (importOptions.webpackMode !== void 0) {
					if (typeof importOptions.webpackMode != "string") {
						parser.state.module.warnings.push(
							new UnsupportedFeatureWarning(
								parser.state.module,
								`\`webpackMode\` expected a string, but received: ${importOptions.webpackMode}.`,
								expr.loc
							)
						);
					} else {
						mode = importOptions.webpackMode;
					}
				}
				if (importOptions.webpackPrefetch !== void 0) {
					if (importOptions.webpackPrefetch === true) {
						groupOptions.prefetchOrder = 0;
					} else if (typeof importOptions.webpackPrefetch == "number") {
						groupOptions.prefetchOrder = importOptions.webpackPrefetch;
					} else {
						parser.state.module.warnings.push(
							new UnsupportedFeatureWarning(
								parser.state.module,
								`\`webpackPrefetch\` expected true or a number, but received: ${importOptions.webpackPrefetch}.`,
								expr.loc
							)
						);
					}
				}
				if (importOptions.webpackPreload !== void 0) {
					if (importOptions.webpackPreload === true) {
						groupOptions.preloadOrder = 0;
					} else if (typeof importOptions.webpackPreload == "number") {
						groupOptions.preloadOrder = importOptions.webpackPreload;
					} else {
						parser.state.module.warnings.push(
							new UnsupportedFeatureWarning(
								parser.state.module,
								`\`webpackPreload\` expected true or a number, but received: ${importOptions.webpackPreload}.`,
								expr.loc
							)
						);
					}
				}
				if (importOptions.webpackInclude !== void 0) {
					if (
						!importOptions.webpackInclude ||
						importOptions.webpackInclude.constructor.name !== "RegExp"
					) {
						parser.state.module.warnings.push(
							new UnsupportedFeatureWarning(
								parser.state.module,
								`\`webpackInclude\` expected a regular expression, but received: ${importOptions.webpackInclude}.`,
								expr.loc
							)
						);
					} else {
						include = new RegExp(importOptions.webpackInclude);
					}
				}
				if (importOptions.webpackExclude !== void 0) {
					if (
						!importOptions.webpackExclude ||
						importOptions.webpackExclude.constructor.name !== "RegExp"
					) {
						parser.state.module.warnings.push(
							new UnsupportedFeatureWarning(
								parser.state.module,
								`\`webpackExclude\` expected a regular expression, but received: ${importOptions.webpackExclude}.`,
								expr.loc
							)
						);
					} else {
						exclude = new RegExp(importOptions.webpackExclude);
					}
				}
			}

			if (param.isString()) {
				if (mode !== "lazy" && mode !== "eager" && mode !== "weak") {
					parser.state.module.warnings.push(
						new UnsupportedFeatureWarning(
							parser.state.module,
							`\`webpackMode\` expected 'lazy', 'eager' or 'weak', but received: ${mode}.`,
							expr.loc
						)
					);
				}

				if (mode === "eager") {
					const dep = new ImportEagerDependency(
						param.string,
						parser.state.module,
						expr.range
					);
					parser.state.current.addDependency(dep);
				} else if (mode === "weak") {
					const dep = new ImportWeakDependency(
						param.string,
						parser.state.module,
						expr.range
					);
					parser.state.current.addDependency(dep);
				} else {
					const depBlock = new ImportDependenciesBlock(
						param.string,
						expr.range,
						Object.assign(groupOptions, {
							name: chunkName
						}),
						parser.state.module,
						expr.loc,
						parser.state.module
					);
					parser.state.current.addBlock(depBlock);
				}
				return true;
			} else {
				if (
					mode !== "lazy" &&
					mode !== "lazy-once" &&
					mode !== "eager" &&
					mode !== "weak"
				) {
					parser.state.module.warnings.push(
						new UnsupportedFeatureWarning(
							parser.state.module,
							`\`webpackMode\` expected 'lazy', 'lazy-once', 'eager' or 'weak', but received: ${mode}.`,
							expr.loc
						)
					);
					mode = "lazy";
				}

				if (mode === "weak") {
					mode = "async-weak";
				}
				const dep = ContextDependencyHelpers.create(
					ImportContextDependency,
					expr.range,
					param,
					expr,
					this.options,
					{
						chunkName,
						groupOptions,
						include,
						exclude,
						mode,
						namespaceObject: parser.state.module.buildMeta.strictHarmonyModule
							? "strict"
							: true
					},
					parser
				);
				if (!dep) return;
				dep.loc = expr.loc;
				dep.optional = !!parser.scope.inTry;
				parser.state.current.addDependency(dep);
				return true;
			}
		});
	}
}

module.exports = ImportParserPlugin;

},
// 248
function(module, exports, __webpack_require__) {

const AsyncDependenciesBlock = __webpack_require__(35);
const ImportDependency = __webpack_require__(107);

module.exports = class extends AsyncDependenciesBlock {
	constructor(request, range, groupOptions, module, loc, originModule) {
		super(groupOptions, module, loc, request);
		this.range = range;
		const dep = new ImportDependency(request, originModule, this);
		dep.loc = loc;
		this.addDependency(dep);
	}
};

},
// 249
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);

class CommentCompilationWarning extends WebpackError {
	constructor(message, module, loc) {
		super(message);

		this.name = "CommentCompilationWarning";

		this.module = module;
		this.loc = loc;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = CommentCompilationWarning;

},
// 250
function(module, exports, __webpack_require__) {

const RequireContextDependency = __webpack_require__(111);
const ContextElementDependency = __webpack_require__(56);

const RequireContextDependencyParserPlugin = __webpack_require__(251);

class RequireContextPlugin {
	constructor(modulesDirectories, extensions, mainFiles) {
		if (!Array.isArray(modulesDirectories)) {
			throw new Error("modulesDirectories must be an array");
		}
		if (!Array.isArray(extensions)) {
			throw new Error("extensions must be an array");
		}
		this.modulesDirectories = modulesDirectories;
		this.extensions = extensions;
		this.mainFiles = mainFiles;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap(
			"RequireContextPlugin",
			(compilation, { contextModuleFactory, normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					RequireContextDependency,
					contextModuleFactory
				);
				compilation.dependencyTemplates.set(
					RequireContextDependency,
					new RequireContextDependency.Template()
				);

				compilation.dependencyFactories.set(
					ContextElementDependency,
					normalModuleFactory
				);

				const handler = (parser, parserOptions) => {
					if (
						parserOptions.requireContext !== void 0 &&
						!parserOptions.requireContext
					)
						return;

					new RequireContextDependencyParserPlugin().apply(parser);
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("RequireContextPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("RequireContextPlugin", handler);

				contextModuleFactory.hooks.alternatives.tap(
					"RequireContextPlugin",
					items => {
						if (items.length === 0) return items;
						return items
							.map(obj => {
								return this.extensions
									.filter(ext => {
										const l = obj.request.length;
										return (
											l > ext.length &&
											obj.request.substr(l - ext.length, l) === ext
										);
									})
									.map(ext => {
										const l = obj.request.length;
										return {
											context: obj.context,
											request: obj.request.substr(0, l - ext.length)
										};
									})
									.concat(obj);
							})
							.reduce((a, b) => a.concat(b), []);
					}
				);

				contextModuleFactory.hooks.alternatives.tap(
					"RequireContextPlugin",
					items => {
						if (items.length === 0) return items;
						return items
							.map(obj => {
								return this.mainFiles
									.filter(mainFile => {
										const l = obj.request.length;
										return (
											l > mainFile.length + 1 &&
											obj.request.substr(l - mainFile.length - 1, l) ===
												"/" + mainFile
										);
									})
									.map(mainFile => {
										const l = obj.request.length;
										return [
											{
												context: obj.context,
												request: obj.request.substr(0, l - mainFile.length)
											},
											{
												context: obj.context,
												request: obj.request.substr(0, l - mainFile.length - 1)
											}
										];
									})
									.reduce((a, b) => a.concat(b), [])
									.concat(obj);
							})
							.reduce((a, b) => a.concat(b), []);
					}
				);

				contextModuleFactory.hooks.alternatives.tap(
					"RequireContextPlugin",
					items => {
						if (items.length === 0) return items;
						return items.map(obj => {
							for (let i = 0; i < this.modulesDirectories.length; i++) {
								const dir = this.modulesDirectories[i];
								const idx = obj.request.indexOf("./" + dir + "/");
								if (idx === 0) {
									obj.request = obj.request.slice(dir.length + 3);
									break;
								}
							}
							return obj;
						});
					}
				);
			}
		);
	}
}
module.exports = RequireContextPlugin;

},
// 251
function(module, exports, __webpack_require__) {

const RequireContextDependency = __webpack_require__(111);

module.exports = class {
	apply(parser) {
		parser.hooks.call
			.for("require.context")
			.tap("RequireContextDependencyParserPlugin", expr => {
				let regExp = /^\.\/.*$/;
				let recursive = true;
				let mode = "sync";
				switch (expr.arguments.length) {
					case 4: {
						const modeExpr = parser.evaluateExpression(expr.arguments[3]);
						if (!modeExpr.isString()) return;
						mode = modeExpr.string;
					}
					case 3: {
						const regExpExpr = parser.evaluateExpression(expr.arguments[2]);
						if (!regExpExpr.isRegExp()) return;
						regExp = regExpExpr.regExp;
					}
					case 2: {
						const recursiveExpr = parser.evaluateExpression(expr.arguments[1]);
						if (!recursiveExpr.isBoolean()) return;
						recursive = recursiveExpr.bool;
					}
					case 1: {
						const requestExpr = parser.evaluateExpression(expr.arguments[0]);
						if (!requestExpr.isString()) return;
						const dep = new RequireContextDependency(
							{
								request: requestExpr.string,
								recursive,
								regExp,
								mode
							},
							expr.range
						);
						dep.loc = expr.loc;
						dep.optional = parser.scope.inTry;
						parser.state.current.addDependency(dep);
						return true;
					}
				}
			});
	}
};

},
// 252
function(module, exports, __webpack_require__) {

const RequireEnsureItemDependency = __webpack_require__(113);
const RequireEnsureDependency = __webpack_require__(114);

const NullFactory = __webpack_require__(10);

const RequireEnsureDependenciesBlockParserPlugin = __webpack_require__(253);

const ParserHelpers = __webpack_require__(9);

class RequireEnsurePlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"RequireEnsurePlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					RequireEnsureItemDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					RequireEnsureItemDependency,
					new RequireEnsureItemDependency.Template()
				);

				compilation.dependencyFactories.set(
					RequireEnsureDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					RequireEnsureDependency,
					new RequireEnsureDependency.Template()
				);

				const handler = (parser, parserOptions) => {
					if (
						parserOptions.requireEnsure !== void 0 &&
						!parserOptions.requireEnsure
					)
						return;

					new RequireEnsureDependenciesBlockParserPlugin().apply(parser);
					parser.hooks.evaluateTypeof
						.for("require.ensure")
						.tap(
							"RequireEnsurePlugin",
							ParserHelpers.evaluateToString("function")
						);
					parser.hooks.typeof
						.for("require.ensure")
						.tap(
							"RequireEnsurePlugin",
							ParserHelpers.toConstantDependency(
								parser,
								JSON.stringify("function")
							)
						);
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("RequireEnsurePlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("RequireEnsurePlugin", handler);
			}
		);
	}
}
module.exports = RequireEnsurePlugin;

},
// 253
function(module, exports, __webpack_require__) {

const RequireEnsureDependenciesBlock = __webpack_require__(254);
const RequireEnsureItemDependency = __webpack_require__(113);
const getFunctionExpression = __webpack_require__(115);

module.exports = class {
	apply(parser) {
		parser.hooks.call
			.for("require.ensure")
			.tap("RequireEnsureDependenciesBlockParserPlugin", expr => {
				let chunkName = null;
				let chunkNameRange = null;
				let errorExpressionArg = null;
				let errorExpression = null;
				switch (expr.arguments.length) {
					case 4: {
						const chunkNameExpr = parser.evaluateExpression(expr.arguments[3]);
						if (!chunkNameExpr.isString()) return;
						chunkNameRange = chunkNameExpr.range;
						chunkName = chunkNameExpr.string;
					}
					case 3: {
						errorExpressionArg = expr.arguments[2];
						errorExpression = getFunctionExpression(errorExpressionArg);

						if (!errorExpression && !chunkName) {
							const chunkNameExpr = parser.evaluateExpression(
								expr.arguments[2]
							);
							if (!chunkNameExpr.isString()) return;
							chunkNameRange = chunkNameExpr.range;
							chunkName = chunkNameExpr.string;
						}
					}
					case 2: {
						const dependenciesExpr = parser.evaluateExpression(
							expr.arguments[0]
						);
						const dependenciesItems = dependenciesExpr.isArray()
							? dependenciesExpr.items
							: [dependenciesExpr];
						const successExpressionArg = expr.arguments[1];
						const successExpression = getFunctionExpression(
							successExpressionArg
						);

						if (successExpression) {
							parser.walkExpressions(successExpression.expressions);
						}
						if (errorExpression) {
							parser.walkExpressions(errorExpression.expressions);
						}

						const dep = new RequireEnsureDependenciesBlock(
							expr,
							successExpression ? successExpression.fn : successExpressionArg,
							errorExpression ? errorExpression.fn : errorExpressionArg,
							chunkName,
							chunkNameRange,
							parser.state.module,
							expr.loc
						);
						const old = parser.state.current;
						parser.state.current = dep;
						try {
							let failed = false;
							parser.inScope([], () => {
								for (const ee of dependenciesItems) {
									if (ee.isString()) {
										const edep = new RequireEnsureItemDependency(ee.string);
										edep.loc = dep.loc;
										dep.addDependency(edep);
									} else {
										failed = true;
									}
								}
							});
							if (failed) {
								return;
							}
							if (successExpression) {
								if (successExpression.fn.body.type === "BlockStatement") {
									parser.walkStatement(successExpression.fn.body);
								} else {
									parser.walkExpression(successExpression.fn.body);
								}
							}
							old.addBlock(dep);
						} finally {
							parser.state.current = old;
						}
						if (!successExpression) {
							parser.walkExpression(successExpressionArg);
						}
						if (errorExpression) {
							if (errorExpression.fn.body.type === "BlockStatement") {
								parser.walkStatement(errorExpression.fn.body);
							} else {
								parser.walkExpression(errorExpression.fn.body);
							}
						} else if (errorExpressionArg) {
							parser.walkExpression(errorExpressionArg);
						}
						return true;
					}
				}
			});
	}
};

},
// 254
function(module, exports, __webpack_require__) {

const AsyncDependenciesBlock = __webpack_require__(35);
const RequireEnsureDependency = __webpack_require__(114);

module.exports = class extends AsyncDependenciesBlock {
	constructor(
		expr,
		successExpression,
		errorExpression,
		chunkName,
		chunkNameRange,
		module,
		loc
	) {
		super(chunkName, module, loc, null);
		this.expr = expr;
		const successBodyRange =
			successExpression &&
			successExpression.body &&
			successExpression.body.range;
		if (successBodyRange) {
			this.range = [successBodyRange[0] + 1, successBodyRange[1] - 1];
		}
		this.chunkNameRange = chunkNameRange;
		const dep = new RequireEnsureDependency(this);
		dep.loc = loc;
		this.addDependency(dep);
	}
};

},
// 255
function(module, exports, __webpack_require__) {

const RequireIncludeDependency = __webpack_require__(116);
const RequireIncludeDependencyParserPlugin = __webpack_require__(256);

const ParserHelpers = __webpack_require__(9);

class RequireIncludePlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"RequireIncludePlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					RequireIncludeDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					RequireIncludeDependency,
					new RequireIncludeDependency.Template()
				);

				const handler = (parser, parserOptions) => {
					if (
						parserOptions.requireInclude !== void 0 &&
						!parserOptions.requireInclude
					)
						return;

					new RequireIncludeDependencyParserPlugin().apply(parser);
					parser.hooks.evaluateTypeof
						.for("require.include")
						.tap(
							"RequireIncludePlugin",
							ParserHelpers.evaluateToString("function")
						);
					parser.hooks.typeof
						.for("require.include")
						.tap(
							"RequireIncludePlugin",
							ParserHelpers.toConstantDependency(
								parser,
								JSON.stringify("function")
							)
						);
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("RequireIncludePlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("RequireIncludePlugin", handler);
			}
		);
	}
}
module.exports = RequireIncludePlugin;

},
// 256
function(module, exports, __webpack_require__) {

const RequireIncludeDependency = __webpack_require__(116);

module.exports = class {
	apply(parser) {
		parser.hooks.call
			.for("require.include")
			.tap("RequireIncludeDependencyParserPlugin", expr => {
				if (expr.arguments.length !== 1) return;
				const param = parser.evaluateExpression(expr.arguments[0]);
				if (!param.isString()) return;
				const dep = new RequireIncludeDependency(param.string, expr.range);
				dep.loc = expr.loc;
				parser.state.current.addDependency(dep);
				return true;
			});
	}
};

},
// 257
function(module, exports, __webpack_require__) {

const { SyncWaterfallHook } = __webpack_require__(6);
const Template = __webpack_require__(2);

class JsonpMainTemplatePlugin {
	apply(mainTemplate) {
		const needChunkOnDemandLoadingCode = chunk => {
			for (const chunkGroup of chunk.groupsIterable) {
				if (chunkGroup.getNumberOfChildren() > 0) return true;
			}
			return false;
		};
		const needChunkLoadingCode = chunk => {
			for (const chunkGroup of chunk.groupsIterable) {
				if (chunkGroup.chunks.length > 1) return true;
				if (chunkGroup.getNumberOfChildren() > 0) return true;
			}
			return false;
		};
		const needEntryDeferringCode = chunk => {
			for (const chunkGroup of chunk.groupsIterable) {
				if (chunkGroup.chunks.length > 1) return true;
			}
			return false;
		};
		const needPrefetchingCode = chunk => {
			const allPrefetchChunks = chunk.getChildIdsByOrdersMap(true).prefetch;
			return allPrefetchChunks && Object.keys(allPrefetchChunks).length;
		};

		["jsonpScript", "linkPreload", "linkPrefetch"].forEach(hook => {
			if (!mainTemplate.hooks[hook]) {
				mainTemplate.hooks[hook] = new SyncWaterfallHook([
					"source",
					"chunk",
					"hash"
				]);
			}
		});

		const getScriptSrcPath = (hash, chunk, chunkIdExpression) => {
			const chunkFilename = mainTemplate.outputOptions.chunkFilename;
			const chunkMaps = chunk.getChunkMaps();
			return mainTemplate.getAssetPath(JSON.stringify(chunkFilename), {
				hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
				hashWithLength: length =>
					`" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`,
				chunk: {
					id: `" + ${chunkIdExpression} + "`,
					hash: `" + ${JSON.stringify(
						chunkMaps.hash
					)}[${chunkIdExpression}] + "`,
					hashWithLength(length) {
						const shortChunkHashMap = Object.create(null);
						for (const chunkId of Object.keys(chunkMaps.hash)) {
							if (typeof chunkMaps.hash[chunkId] == "string") {
								shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substr(
									0,
									length
								);
							}
						}
						return `" + ${JSON.stringify(
							shortChunkHashMap
						)}[${chunkIdExpression}] + "`;
					},
					name: `" + (${JSON.stringify(
						chunkMaps.name
					)}[${chunkIdExpression}]||${chunkIdExpression}) + "`,
					contentHash: {
						javascript: `" + ${JSON.stringify(
							chunkMaps.contentHash.javascript
						)}[${chunkIdExpression}] + "`
					},
					contentHashWithLength: {
						javascript: length => {
							const shortContentHashMap = {};
							const contentHash = chunkMaps.contentHash.javascript;
							for (const chunkId of Object.keys(contentHash)) {
								if (typeof contentHash[chunkId] == "string") {
									shortContentHashMap[chunkId] = contentHash[chunkId].substr(
										0,
										length
									);
								}
							}
							return `" + ${JSON.stringify(
								shortContentHashMap
							)}[${chunkIdExpression}] + "`;
						}
					}
				},
				contentHashType: "javascript"
			});
		};
		mainTemplate.hooks.localVars.tap(
			"JsonpMainTemplatePlugin",
			(source, chunk, hash) => {
				const extraCode = [];
				if (needChunkLoadingCode(chunk)) {
					extraCode.push(
						"",
						"// object to store loaded and loading chunks",
						"// undefined = chunk not loaded, null = chunk preloaded/prefetched",
						"// Promise = chunk loading, 0 = chunk loaded",
						"var installedChunks = {",
						Template.indent(
							chunk.ids.map(id => `${JSON.stringify(id)}: 0`).join(",\n")
						),
						"};",
						"",
						needEntryDeferringCode(chunk)
							? needPrefetchingCode(chunk)
								? "var deferredModules = [], deferredPrefetch = [];"
								: "var deferredModules = [];"
							: ""
					);
				}
				if (needChunkOnDemandLoadingCode(chunk)) {
					extraCode.push(
						"",
						"// script path function",
						"function jsonpScriptSrc(chunkId) {",
						Template.indent([
							`return ${mainTemplate.requireFn}.p + ${getScriptSrcPath(
								hash,
								chunk,
								"chunkId"
							)}`
						]),
						"}"
					);
				}
				if (extraCode.length === 0) return source;
				return Template.asString([source, ...extraCode]);
			}
		);

		mainTemplate.hooks.jsonpScript.tap(
			"JsonpMainTemplatePlugin",
			(_, chunk, hash) => {
				const crossOriginLoading =
					mainTemplate.outputOptions.crossOriginLoading;
				const chunkLoadTimeout = mainTemplate.outputOptions.chunkLoadTimeout;
				const jsonpScriptType = mainTemplate.outputOptions.jsonpScriptType;

				return Template.asString([
					"var script = document.createElement('script');",
					"var onScriptComplete;",
					jsonpScriptType
						? `script.type = ${JSON.stringify(jsonpScriptType)};`
						: "",
					"script.charset = 'utf-8';",
					`script.timeout = ${chunkLoadTimeout / 1000};`,
					`if (${mainTemplate.requireFn}.nc) {`,
					Template.indent(
						`script.setAttribute("nonce", ${mainTemplate.requireFn}.nc);`
					),
					"}",
					"script.src = jsonpScriptSrc(chunkId);",
					crossOriginLoading
						? Template.asString([
								"if (script.src.indexOf(window.location.origin + '/') !== 0) {",
								Template.indent(
									`script.crossOrigin = ${JSON.stringify(crossOriginLoading)};`
								),
								"}"
							])
						: "",
					"// create error before stack unwound to get useful stacktrace later",
					"var error = new Error();",
					"onScriptComplete = function (event) {",
					Template.indent([
						"// avoid mem leaks in IE.",
						"script.onerror = script.onload = null;",
						"clearTimeout(timeout);",
						"var chunk = installedChunks[chunkId];",
						"if(chunk !== 0) {",
						Template.indent([
							"if(chunk) {",
							Template.indent([
								"var errorType = event && (event.type === 'load' ? 'missing' : event.type);",
								"var realSrc = event && event.target && event.target.src;",
								"error.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';",
								"error.name = 'ChunkLoadError';",
								"error.type = errorType;",
								"error.request = realSrc;",
								"chunk[1](error);"
							]),
							"}",
							"installedChunks[chunkId] = undefined;"
						]),
						"}"
					]),
					"};",
					"var timeout = setTimeout(function(){",
					Template.indent([
						"onScriptComplete({ type: 'timeout', target: script });"
					]),
					`}, ${chunkLoadTimeout});`,
					"script.onerror = script.onload = onScriptComplete;"
				]);
			}
		);
		mainTemplate.hooks.linkPreload.tap(
			"JsonpMainTemplatePlugin",
			(_, chunk, hash) => {
				const crossOriginLoading =
					mainTemplate.outputOptions.crossOriginLoading;
				const jsonpScriptType = mainTemplate.outputOptions.jsonpScriptType;

				return Template.asString([
					"var link = document.createElement('link');",
					jsonpScriptType
						? `link.type = ${JSON.stringify(jsonpScriptType)};`
						: "",
					"link.charset = 'utf-8';",
					`if (${mainTemplate.requireFn}.nc) {`,
					Template.indent(
						`link.setAttribute("nonce", ${mainTemplate.requireFn}.nc);`
					),
					"}",
					'link.rel = "preload";',
					'link.as = "script";',
					"link.href = jsonpScriptSrc(chunkId);",
					crossOriginLoading
						? Template.asString([
								"if (link.href.indexOf(window.location.origin + '/') !== 0) {",
								Template.indent(
									`link.crossOrigin = ${JSON.stringify(crossOriginLoading)};`
								),
								"}"
							])
						: ""
				]);
			}
		);
		mainTemplate.hooks.linkPrefetch.tap(
			"JsonpMainTemplatePlugin",
			(_, chunk, hash) => {
				const crossOriginLoading =
					mainTemplate.outputOptions.crossOriginLoading;

				return Template.asString([
					"var link = document.createElement('link');",
					crossOriginLoading
						? `link.crossOrigin = ${JSON.stringify(crossOriginLoading)};`
						: "",
					`if (${mainTemplate.requireFn}.nc) {`,
					Template.indent(
						`link.setAttribute("nonce", ${mainTemplate.requireFn}.nc);`
					),
					"}",
					'link.rel = "prefetch";',
					'link.as = "script";',
					"link.href = jsonpScriptSrc(chunkId);"
				]);
			}
		);
		mainTemplate.hooks.requireEnsure.tap(
			"JsonpMainTemplatePlugin load",
			(source, chunk, hash) => {
				return Template.asString([
					source,
					"",
					"// JSONP chunk loading for javascript",
					"",
					"var installedChunkData = installedChunks[chunkId];",
					'if(installedChunkData !== 0) { // 0 means "already installed".',
					Template.indent([
						"",
						'// a Promise means "currently loading".',
						"if(installedChunkData) {",
						Template.indent(["promises.push(installedChunkData[2]);"]),
						"} else {",
						Template.indent([
							"// setup Promise in chunk cache",
							"var promise = new Promise(function(resolve, reject) {",
							Template.indent([
								"installedChunkData = installedChunks[chunkId] = [resolve, reject];"
							]),
							"});",
							"promises.push(installedChunkData[2] = promise);",
							"",
							"// start chunk loading",
							mainTemplate.hooks.jsonpScript.call("", chunk, hash),
							"document.head.appendChild(script);"
						]),
						"}"
					]),
					"}"
				]);
			}
		);
		mainTemplate.hooks.requireEnsure.tap(
			{
				name: "JsonpMainTemplatePlugin preload",
				stage: 10
			},
			(source, chunk, hash) => {
				const chunkMap = chunk.getChildIdsByOrdersMap().preload;
				if (!chunkMap || Object.keys(chunkMap).length === 0) return source;
				return Template.asString([
					source,
					"",
					"// chunk preloadng for javascript",
					"",
					`var chunkPreloadMap = ${JSON.stringify(chunkMap, null, "\t")};`,
					"",
					"var chunkPreloadData = chunkPreloadMap[chunkId];",
					"if(chunkPreloadData) {",
					Template.indent([
						"chunkPreloadData.forEach(function(chunkId) {",
						Template.indent([
							"if(installedChunks[chunkId] === undefined) {",
							Template.indent([
								"installedChunks[chunkId] = null;",
								mainTemplate.hooks.linkPreload.call("", chunk, hash),
								"document.head.appendChild(link);"
							]),
							"}"
						]),
						"});"
					]),
					"}"
				]);
			}
		);
		mainTemplate.hooks.requireExtensions.tap(
			"JsonpMainTemplatePlugin",
			(source, chunk) => {
				if (!needChunkOnDemandLoadingCode(chunk)) return source;

				return Template.asString([
					source,
					"",
					"// on error function for async loading",
					`${mainTemplate.requireFn}.oe = function(err) { console.error(err); throw err; };`
				]);
			}
		);
		mainTemplate.hooks.bootstrap.tap(
			"JsonpMainTemplatePlugin",
			(source, chunk, hash) => {
				if (needChunkLoadingCode(chunk)) {
					const withDefer = needEntryDeferringCode(chunk);
					const withPrefetch = needPrefetchingCode(chunk);
					return Template.asString([
						source,
						"",
						"// install a JSONP callback for chunk loading",
						"function webpackJsonpCallback(data) {",
						Template.indent([
							"var chunkIds = data[0];",
							"var moreModules = data[1];",
							withDefer ? "var executeModules = data[2];" : "",
							withPrefetch ? "var prefetchChunks = data[3] || [];" : "",
							'// add "moreModules" to the modules object,',
							'// then flag all "chunkIds" as loaded and fire callback',
							"var moduleId, chunkId, i = 0, resolves = [];",
							"for(;i < chunkIds.length; i++) {",
							Template.indent([
								"chunkId = chunkIds[i];",
								"if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {",
								Template.indent("resolves.push(installedChunks[chunkId][0]);"),
								"}",
								"installedChunks[chunkId] = 0;"
							]),
							"}",
							"for(moduleId in moreModules) {",
							Template.indent([
								"if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {",
								Template.indent(
									mainTemplate.renderAddModule(
										hash,
										chunk,
										"moduleId",
										"moreModules[moduleId]"
									)
								),
								"}"
							]),
							"}",
							"if(parentJsonpFunction) parentJsonpFunction(data);",
							withPrefetch
								? withDefer
									? "deferredPrefetch.push.apply(deferredPrefetch, prefetchChunks);"
									: Template.asString([
											"// chunk prefetching for javascript",
											"prefetchChunks.forEach(function(chunkId) {",
											Template.indent([
												"if(installedChunks[chunkId] === undefined) {",
												Template.indent([
													"installedChunks[chunkId] = null;",
													mainTemplate.hooks.linkPrefetch.call("", chunk, hash),
													"document.head.appendChild(link);"
												]),
												"}"
											]),
											"});"
										])
								: "",
							"while(resolves.length) {",
							Template.indent("resolves.shift()();"),
							"}",
							withDefer
								? Template.asString([
										"",
										"// add entry modules from loaded chunk to deferred list",
										"deferredModules.push.apply(deferredModules, executeModules || []);",
										"",
										"// run deferred modules when all chunks ready",
										"return checkDeferredModules();"
									])
								: ""
						]),
						"};",
						withDefer
							? Template.asString([
									"function checkDeferredModules() {",
									Template.indent([
										"var result;",
										"for(var i = 0; i < deferredModules.length; i++) {",
										Template.indent([
											"var deferredModule = deferredModules[i];",
											"var fulfilled = true;",
											"for(var j = 1; j < deferredModule.length; j++) {",
											Template.indent([
												"var depId = deferredModule[j];",
												"if(installedChunks[depId] !== 0) fulfilled = false;"
											]),
											"}",
											"if(fulfilled) {",
											Template.indent([
												"deferredModules.splice(i--, 1);",
												"result = " +
													mainTemplate.requireFn +
													"(" +
													mainTemplate.requireFn +
													".s = deferredModule[0]);"
											]),
											"}"
										]),
										"}",
										withPrefetch
											? Template.asString([
													"if(deferredModules.length === 0) {",
													Template.indent([
														"// chunk prefetching for javascript",
														"deferredPrefetch.forEach(function(chunkId) {",
														Template.indent([
															"if(installedChunks[chunkId] === undefined) {",
															Template.indent([
																"installedChunks[chunkId] = null;",
																mainTemplate.hooks.linkPrefetch.call(
																	"",
																	chunk,
																	hash
																),
																"document.head.appendChild(link);"
															]),
															"}"
														]),
														"});",
														"deferredPrefetch.length = 0;"
													]),
													"}"
												])
											: "",
										"return result;"
									]),
									"}"
								])
							: ""
					]);
				}
				return source;
			}
		);
		mainTemplate.hooks.beforeStartup.tap(
			"JsonpMainTemplatePlugin",
			(source, chunk, hash) => {
				if (needChunkLoadingCode(chunk)) {
					var jsonpFunction = mainTemplate.outputOptions.jsonpFunction;
					var globalObject = mainTemplate.outputOptions.globalObject;
					return Template.asString([
						`var jsonpArray = ${globalObject}[${JSON.stringify(
							jsonpFunction
						)}] = ${globalObject}[${JSON.stringify(jsonpFunction)}] || [];`,
						"var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);",
						"jsonpArray.push = webpackJsonpCallback;",
						"jsonpArray = jsonpArray.slice();",
						"for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);",
						"var parentJsonpFunction = oldJsonpFunction;",
						"",
						source
					]);
				}
				return source;
			}
		);
		mainTemplate.hooks.afterStartup.tap(
			"JsonpMainTemplatePlugin",
			(source, chunk, hash) => {
				const prefetchChunks = chunk.getChildIdsByOrders().prefetch;
				if (
					needChunkLoadingCode(chunk) &&
					prefetchChunks &&
					prefetchChunks.length
				) {
					return Template.asString([
						source,
						`webpackJsonpCallback([[], {}, 0, ${JSON.stringify(
							prefetchChunks
						)}]);`
					]);
				}
				return source;
			}
		);
		mainTemplate.hooks.startup.tap(
			"JsonpMainTemplatePlugin",
			(source, chunk, hash) => {
				if (needEntryDeferringCode(chunk)) {
					if (chunk.hasEntryModule()) {
						const entries = [chunk.entryModule].filter(Boolean).map(m =>
							[m.id].concat(
								Array.from(chunk.groupsIterable)[0]
									.chunks.filter(c => c !== chunk)
									.map(c => c.id)
							)
						);
						return Template.asString([
							"// add entry module to deferred list",
							`deferredModules.push(${entries
								.map(e => JSON.stringify(e))
								.join(", ")});`,
							"// run deferred modules when ready",
							"return checkDeferredModules();"
						]);
					} else {
						return Template.asString([
							"// run deferred modules from other chunks",
							"checkDeferredModules();"
						]);
					}
				}
				return source;
			}
		);
		mainTemplate.hooks.hotBootstrap.tap(
			"JsonpMainTemplatePlugin",
			(source, chunk, hash) => {
				const globalObject = mainTemplate.outputOptions.globalObject;
				const hotUpdateChunkFilename =
					mainTemplate.outputOptions.hotUpdateChunkFilename;
				const hotUpdateMainFilename =
					mainTemplate.outputOptions.hotUpdateMainFilename;
				const crossOriginLoading =
					mainTemplate.outputOptions.crossOriginLoading;
				const hotUpdateFunction = mainTemplate.outputOptions.hotUpdateFunction;
				const currentHotUpdateChunkFilename = mainTemplate.getAssetPath(
					JSON.stringify(hotUpdateChunkFilename),
					{
						hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
						hashWithLength: length =>
							`" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`,
						chunk: {
							id: '" + chunkId + "'
						}
					}
				);
				const currentHotUpdateMainFilename = mainTemplate.getAssetPath(
					JSON.stringify(hotUpdateMainFilename),
					{
						hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
						hashWithLength: length =>
							`" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`
					}
				);
				const runtimeSource = Template.getFunctionContent(
					__webpack_require__(258)
				)
					.replace(/\/\/\$semicolon/g, ";")
					.replace(/\$require\$/g, mainTemplate.requireFn)
					.replace(
						/\$crossOriginLoading\$/g,
						crossOriginLoading ? JSON.stringify(crossOriginLoading) : "null"
					)
					.replace(/\$hotMainFilename\$/g, currentHotUpdateMainFilename)
					.replace(/\$hotChunkFilename\$/g, currentHotUpdateChunkFilename)
					.replace(/\$hash\$/g, JSON.stringify(hash));
				return `${source}
function hotDisposeChunk(chunkId) {
	delete installedChunks[chunkId];
}
var parentHotUpdateCallback = ${globalObject}[${JSON.stringify(
					hotUpdateFunction
				)}];
${globalObject}[${JSON.stringify(hotUpdateFunction)}] = ${runtimeSource}`;
			}
		);
		mainTemplate.hooks.hash.tap("JsonpMainTemplatePlugin", hash => {
			hash.update("jsonp");
			hash.update("6");
		});
	}
}
module.exports = JsonpMainTemplatePlugin;

},
// 258
function(module, exports) {

var hotAddUpdateChunk = void 0;
var parentHotUpdateCallback = void 0;
var $require$ = void 0;
var $hotMainFilename$ = void 0;
var $hotChunkFilename$ = void 0;
var $crossOriginLoading$ = void 0;

module.exports = function() {
	function webpackHotUpdateCallback(chunkId, moreModules) {
		hotAddUpdateChunk(chunkId, moreModules);
		if (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
	}

	function hotDownloadUpdateChunk(chunkId) {
		var script = document.createElement("script");
		script.charset = "utf-8";
		script.src = $require$.p + $hotChunkFilename$;
		if ($crossOriginLoading$) script.crossOrigin = $crossOriginLoading$;
		document.head.appendChild(script);
	}

	function hotDownloadManifest(requestTimeout) {
		requestTimeout = requestTimeout || 10000;
		return new Promise(function(resolve, reject) {
			if (typeof XMLHttpRequest == "undefined")
				return reject(new Error("No browser support"));

			try {
				var request = new XMLHttpRequest();
				var requestPath = $require$.p + $hotMainFilename$;
				request.open("GET", requestPath, true);
				request.timeout = requestTimeout;
				request.send(null);
			} catch (err) {
				return reject(err);
			}
			request.onreadystatechange = function() {
				if (request.readyState !== 4) return;
				if (request.status === 0) {
					reject(
						new Error("Manifest request to " + requestPath + " timed out.")
					);
				} else if (request.status === 404) {
					resolve();
				} else if (request.status !== 200 && request.status !== 304) {
					reject(new Error("Manifest request to " + requestPath + " failed."));
				} else {
					try {
						var update = JSON.parse(request.responseText);
					} catch (e) {
						reject(e);
						return;
					}
					resolve(update);
				}
			};
		});
	}
};

},
// 259
function(module, exports, __webpack_require__) {

const { ConcatSource } = __webpack_require__(0);

const getEntryInfo = chunk => {
	return [chunk.entryModule].filter(Boolean).map(m =>
		[m.id].concat(
			Array.from(chunk.groupsIterable)[0]
				.chunks.filter(c => c !== chunk)
				.map(c => c.id)
		)
	);
};

class JsonpChunkTemplatePlugin {
	apply(chunkTemplate) {
		chunkTemplate.hooks.render.tap(
			"JsonpChunkTemplatePlugin",
			(modules, chunk) => {
				const jsonpFunction = chunkTemplate.outputOptions.jsonpFunction;
				const globalObject = chunkTemplate.outputOptions.globalObject;
				const source = new ConcatSource();
				const prefetchChunks = chunk.getChildIdsByOrders().prefetch;
				source.add(
					`(${globalObject}[${JSON.stringify(
						jsonpFunction
					)}] = ${globalObject}[${JSON.stringify(
						jsonpFunction
					)}] || []).push([${JSON.stringify(chunk.ids)},`
				);
				source.add(modules);
				const entries = getEntryInfo(chunk);
				if (entries.length > 0) {
					source.add(`,${JSON.stringify(entries)}`);
				} else if (prefetchChunks && prefetchChunks.length) {
					source.add(`,0`);
				}

				if (prefetchChunks && prefetchChunks.length) {
					source.add(`,${JSON.stringify(prefetchChunks)}`);
				}
				source.add("])");
				return source;
			}
		);
		chunkTemplate.hooks.hash.tap("JsonpChunkTemplatePlugin", hash => {
			hash.update("JsonpChunkTemplatePlugin");
			hash.update("4");
			hash.update(`${chunkTemplate.outputOptions.jsonpFunction}`);
			hash.update(`${chunkTemplate.outputOptions.globalObject}`);
		});
		chunkTemplate.hooks.hashForChunk.tap(
			"JsonpChunkTemplatePlugin",
			(hash, chunk) => {
				hash.update(JSON.stringify(getEntryInfo(chunk)));
				hash.update(JSON.stringify(chunk.getChildIdsByOrders().prefetch) || "");
			}
		);
	}
}
module.exports = JsonpChunkTemplatePlugin;

},
// 260
function(module, exports, __webpack_require__) {

const { ConcatSource } = __webpack_require__(0);

class JsonpHotUpdateChunkTemplatePlugin {
	apply(hotUpdateChunkTemplate) {
		hotUpdateChunkTemplate.hooks.render.tap(
			"JsonpHotUpdateChunkTemplatePlugin",
			(modulesSource, modules, removedModules, hash, id) => {
				const source = new ConcatSource();
				source.add(
					`${
						hotUpdateChunkTemplate.outputOptions.hotUpdateFunction
					}(${JSON.stringify(id)},`
				);
				source.add(modulesSource);
				source.add(")");
				return source;
			}
		);
		hotUpdateChunkTemplate.hooks.hash.tap(
			"JsonpHotUpdateChunkTemplatePlugin",
			hash => {
				hash.update("JsonpHotUpdateChunkTemplatePlugin");
				hash.update("3");
				hash.update(
					`${hotUpdateChunkTemplate.outputOptions.hotUpdateFunction}`
				);
				hash.update(`${hotUpdateChunkTemplate.outputOptions.library}`);
			}
		);
	}
}

module.exports = JsonpHotUpdateChunkTemplatePlugin;

},
// 261
function(module, exports) {

exports.assert = require.resolve('../web_modules/assert');
exports.buffer = require.resolve('../web_modules/buffer');
exports.child_process = null;
exports.cluster = null;
exports.console = require.resolve('../web_modules/console-browserify');
exports.constants = require.resolve('../web_modules/constants-browserify');
exports.crypto = require.resolve('../web_modules/crypto-browserify');
exports.dgram = null;
exports.dns = null;
exports.domain = require.resolve('../web_modules/domain-browser');
exports.events = require.resolve('../web_modules/events');
exports.fs = null;
exports.http = require.resolve('../web_modules/stream-http');
exports.https = require.resolve('../web_modules/https-browserify');
exports.module = null;
exports.net = null;
exports.os = require.resolve('../web_modules/os-browserify');
exports.path = require.resolve('../web_modules/path-browserify');
exports.punycode = require.resolve('../web_modules/punycode');
exports.process = require.resolve('../web_modules/process');
exports.querystring = require.resolve('../web_modules/querystring-es3');
exports.readline = null;
exports.repl = null;
exports.stream = require.resolve('../web_modules/stream-browserify');
exports._stream_duplex = require.resolve('../web_modules/readable-stream/duplex');
exports._stream_passthrough = require.resolve('../web_modules/readable-stream/passthrough');
exports._stream_readable = require.resolve('../web_modules/readable-stream/readable');
exports._stream_transform = require.resolve('../web_modules/readable-stream/transform');
exports._stream_writable = require.resolve('../web_modules/readable-stream/writable');
exports.string_decoder = require.resolve('../web_modules/string_decoder');
exports.sys = require.resolve('../web_modules/util');
exports.timers = require.resolve('../web_modules/timers-browserify');
exports.tls = null;
exports.tty = require.resolve('../web_modules/tty-browserify');
exports.url = require.resolve('../web_modules/url');
exports.util = require.resolve('../web_modules/util');
exports.vm = require.resolve('../web_modules/vm-browserify');
exports.zlib = require.resolve('../web_modules/browserify-zlib');

},
// 262
function(module, exports, __webpack_require__) {

const Template = __webpack_require__(2);

class WebWorkerMainTemplatePlugin {
	apply(mainTemplate) {
		const needChunkOnDemandLoadingCode = chunk => {
			for (const chunkGroup of chunk.groupsIterable) {
				if (chunkGroup.getNumberOfChildren() > 0) return true;
			}
			return false;
		};
		mainTemplate.hooks.localVars.tap(
			"WebWorkerMainTemplatePlugin",
			(source, chunk) => {
				if (needChunkOnDemandLoadingCode(chunk)) {
					return Template.asString([
						source,
						"",
						"// object to store loaded chunks",
						'// "1" means "already loaded"',
						"var installedChunks = {",
						Template.indent(
							chunk.ids.map(id => `${JSON.stringify(id)}: 1`).join(",\n")
						),
						"};"
					]);
				}
				return source;
			}
		);
		mainTemplate.hooks.requireEnsure.tap(
			"WebWorkerMainTemplatePlugin",
			(_, chunk, hash) => {
				const chunkFilename = mainTemplate.outputOptions.chunkFilename;
				const chunkMaps = chunk.getChunkMaps();
				return Template.asString([
					"promises.push(Promise.resolve().then(function() {",
					Template.indent([
						'// "1" is the signal for "already loaded"',
						"if(!installedChunks[chunkId]) {",
						Template.indent([
							"importScripts(__webpack_require__.p + " +
								mainTemplate.getAssetPath(JSON.stringify(chunkFilename), {
									hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
									hashWithLength: length =>
										`" + ${mainTemplate.renderCurrentHashCode(
											hash,
											length
										)} + "`,
									chunk: {
										id: '" + chunkId + "',
										hash: `" + ${JSON.stringify(chunkMaps.hash)}[chunkId] + "`,
										hashWithLength(length) {
											const shortChunkHashMap = Object.create(null);
											for (const chunkId of Object.keys(chunkMaps.hash)) {
												if (typeof chunkMaps.hash[chunkId] == "string") {
													shortChunkHashMap[chunkId] = chunkMaps.hash[
														chunkId
													].substr(0, length);
												}
											}
											return `" + ${JSON.stringify(
												shortChunkHashMap
											)}[chunkId] + "`;
										},
										contentHash: {
											javascript: `" + ${JSON.stringify(
												chunkMaps.contentHash.javascript
											)}[chunkId] + "`
										},
										contentHashWithLength: {
											javascript: length => {
												const shortContentHashMap = {};
												const contentHash = chunkMaps.contentHash.javascript;
												for (const chunkId of Object.keys(contentHash)) {
													if (typeof contentHash[chunkId] == "string") {
														shortContentHashMap[chunkId] = contentHash[
															chunkId
														].substr(0, length);
													}
												}
												return `" + ${JSON.stringify(
													shortContentHashMap
												)}[chunkId] + "`;
											}
										},
										name: `" + (${JSON.stringify(
											chunkMaps.name
										)}[chunkId]||chunkId) + "`
									},
									contentHashType: "javascript"
								}) +
								");"
						]),
						"}"
					]),
					"}));"
				]);
			}
		);
		mainTemplate.hooks.bootstrap.tap(
			"WebWorkerMainTemplatePlugin",
			(source, chunk, hash) => {
				if (needChunkOnDemandLoadingCode(chunk)) {
					const chunkCallbackName =
						mainTemplate.outputOptions.chunkCallbackName;
					const globalObject = mainTemplate.outputOptions.globalObject;
					return Template.asString([
						source,
						`${globalObject}[${JSON.stringify(
							chunkCallbackName
						)}] = function webpackChunkCallback(chunkIds, moreModules) {`,
						Template.indent([
							"for(var moduleId in moreModules) {",
							Template.indent(
								mainTemplate.renderAddModule(
									hash,
									chunk,
									"moduleId",
									"moreModules[moduleId]"
								)
							),
							"}",
							"while(chunkIds.length)",
							Template.indent("installedChunks[chunkIds.pop()] = 1;")
						]),
						"};"
					]);
				}
				return source;
			}
		);
		mainTemplate.hooks.hotBootstrap.tap(
			"WebWorkerMainTemplatePlugin",
			(source, chunk, hash) => {
				const hotUpdateChunkFilename =
					mainTemplate.outputOptions.hotUpdateChunkFilename;
				const hotUpdateMainFilename =
					mainTemplate.outputOptions.hotUpdateMainFilename;
				const hotUpdateFunction = mainTemplate.outputOptions.hotUpdateFunction;
				const globalObject = mainTemplate.outputOptions.globalObject;
				const currentHotUpdateChunkFilename = mainTemplate.getAssetPath(
					JSON.stringify(hotUpdateChunkFilename),
					{
						hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
						hashWithLength: length =>
							`" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`,
						chunk: {
							id: '" + chunkId + "'
						}
					}
				);
				const currentHotUpdateMainFilename = mainTemplate.getAssetPath(
					JSON.stringify(hotUpdateMainFilename),
					{
						hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
						hashWithLength: length =>
							`" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`
					}
				);

				return (
					source +
					`\nvar parentHotUpdateCallback = ${globalObject}[${JSON.stringify(
						hotUpdateFunction
					)}];\n${globalObject}[${JSON.stringify(hotUpdateFunction)}] = ` +
					Template.getFunctionContent(
						__webpack_require__(263)
					)
						.replace(/\/\/\$semicolon/g, ";")
						.replace(/\$require\$/g, mainTemplate.requireFn)
						.replace(/\$hotMainFilename\$/g, currentHotUpdateMainFilename)
						.replace(/\$hotChunkFilename\$/g, currentHotUpdateChunkFilename)
						.replace(/\$hash\$/g, JSON.stringify(hash))
				);
			}
		);
		mainTemplate.hooks.hash.tap("WebWorkerMainTemplatePlugin", hash => {
			hash.update("webworker");
			hash.update("4");
		});
	}
}
module.exports = WebWorkerMainTemplatePlugin;

},
// 263
function(module, exports) {

var hotAddUpdateChunk = void 0;
var parentHotUpdateCallback = void 0;
var $require$ = void 0;
var $hotChunkFilename$ = void 0;
var $hotMainFilename$ = void 0;
var installedChunks = void 0;
var importScripts = void 0;

module.exports = function() {
	function webpackHotUpdateCallback(chunkId, moreModules) {
		hotAddUpdateChunk(chunkId, moreModules);
		if (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
	}

	function hotDownloadUpdateChunk(chunkId) {
		importScripts($require$.p + $hotChunkFilename$);
	}

	function hotDownloadManifest(requestTimeout) {
		requestTimeout = requestTimeout || 10000;
		return new Promise(function(resolve, reject) {
			if (typeof XMLHttpRequest == "undefined")
				return reject(new Error("No browser support"));

			try {
				var request = new XMLHttpRequest();
				var requestPath = $require$.p + $hotMainFilename$;
				request.open("GET", requestPath, true);
				request.timeout = requestTimeout;
				request.send(null);
			} catch (err) {
				return reject(err);
			}
			request.onreadystatechange = function() {
				if (request.readyState !== 4) return;
				if (request.status === 0) {
					reject(
						new Error("Manifest request to " + requestPath + " timed out.")
					);
				} else if (request.status === 404) {
					resolve();
				} else if (request.status !== 200 && request.status !== 304) {
					reject(new Error("Manifest request to " + requestPath + " failed."));
				} else {
					try {
						var update = JSON.parse(request.responseText);
					} catch (e) {
						reject(e);
						return;
					}
					resolve(update);
				}
			};
		});
	}

	function hotDisposeChunk(chunkId) {
		delete installedChunks[chunkId];
	}
};

},
// 264
function(module, exports, __webpack_require__) {

const { ConcatSource } = __webpack_require__(0);

class WebWorkerChunkTemplatePlugin {
	apply(chunkTemplate) {
		chunkTemplate.hooks.render.tap(
			"WebWorkerChunkTemplatePlugin",
			(modules, chunk) => {
				const chunkCallbackName = chunkTemplate.outputOptions.chunkCallbackName;
				const globalObject = chunkTemplate.outputOptions.globalObject;
				const source = new ConcatSource();
				source.add(
					`${globalObject}[${JSON.stringify(
						chunkCallbackName
					)}](${JSON.stringify(chunk.ids)},`
				);
				source.add(modules);
				source.add(")");
				return source;
			}
		);
		chunkTemplate.hooks.hash.tap("WebWorkerChunkTemplatePlugin", hash => {
			hash.update("webworker");
			hash.update("3");
			hash.update(`${chunkTemplate.outputOptions.chunkCallbackName}`);
			hash.update(`${chunkTemplate.outputOptions.globalObject}`);
		});
	}
}
module.exports = WebWorkerChunkTemplatePlugin;

},
// 265
function(module, exports, __webpack_require__) {

const { ConcatSource } = __webpack_require__(0);

class WebWorkerHotUpdateChunkTemplatePlugin {
	apply(hotUpdateChunkTemplate) {
		hotUpdateChunkTemplate.hooks.render.tap(
			"WebWorkerHotUpdateChunkTemplatePlugin",
			(modulesSource, modules, removedModules, hash, id) => {
				const hotUpdateFunction =
					hotUpdateChunkTemplate.outputOptions.hotUpdateFunction;
				const globalObject = hotUpdateChunkTemplate.outputOptions.globalObject;
				const source = new ConcatSource();
				source.add(
					`${globalObject}[${JSON.stringify(
						hotUpdateFunction
					)}](${JSON.stringify(id)},`
				);
				source.add(modulesSource);
				source.add(")");
				return source;
			}
		);
		hotUpdateChunkTemplate.hooks.hash.tap(
			"WebWorkerHotUpdateChunkTemplatePlugin",
			hash => {
				hash.update("WebWorkerHotUpdateChunkTemplatePlugin");
				hash.update("3");
				hash.update(
					hotUpdateChunkTemplate.outputOptions.hotUpdateFunction + ""
				);
				hash.update(hotUpdateChunkTemplate.outputOptions.globalObject + "");
			}
		);
	}
}
module.exports = WebWorkerHotUpdateChunkTemplatePlugin;

},
// 266
function(module, exports, __webpack_require__) {

const Template = __webpack_require__(2);

module.exports = class {
	constructor(asyncChunkLoading) {
		this.asyncChunkLoading = asyncChunkLoading;
	}

	apply(mainTemplate) {
		const needChunkOnDemandLoadingCode = chunk => {
			for (const chunkGroup of chunk.groupsIterable) {
				if (chunkGroup.getNumberOfChildren() > 0) return true;
			}
			return false;
		};
		const asyncChunkLoading = this.asyncChunkLoading;
		mainTemplate.hooks.localVars.tap(
			"NodeMainTemplatePlugin",
			(source, chunk) => {
				if (needChunkOnDemandLoadingCode(chunk)) {
					return Template.asString([
						source,
						"",
						"// object to store loaded chunks",
						'// "0" means "already loaded"',
						"var installedChunks = {",
						Template.indent(
							chunk.ids.map(id => `${JSON.stringify(id)}: 0`).join(",\n")
						),
						"};"
					]);
				}
				return source;
			}
		);
		mainTemplate.hooks.requireExtensions.tap(
			"NodeMainTemplatePlugin",
			(source, chunk) => {
				if (needChunkOnDemandLoadingCode(chunk)) {
					return Template.asString([
						source,
						"",
						"// uncaught error handler for webpack runtime",
						`${mainTemplate.requireFn}.oe = function(err) {`,
						Template.indent([
							"process.nextTick(function() {",
							Template.indent(
								"throw err; // catch this error by using import().catch()"
							),
							"});"
						]),
						"};"
					]);
				}
				return source;
			}
		);
		mainTemplate.hooks.requireEnsure.tap(
			"NodeMainTemplatePlugin",
			(source, chunk, hash) => {
				const chunkFilename = mainTemplate.outputOptions.chunkFilename;
				const chunkMaps = chunk.getChunkMaps();
				const insertMoreModules = [
					"var moreModules = chunk.modules, chunkIds = chunk.ids;",
					"for(var moduleId in moreModules) {",
					Template.indent(
						mainTemplate.renderAddModule(
							hash,
							chunk,
							"moduleId",
							"moreModules[moduleId]"
						)
					),
					"}"
				];
				if (asyncChunkLoading) {
					return Template.asString([
						source,
						"",
						"// ReadFile + VM.run chunk loading for javascript",
						"",
						"var installedChunkData = installedChunks[chunkId];",
						'if(installedChunkData !== 0) { // 0 means "already installed".',
						Template.indent([
							'// array of [resolve, reject, promise] means "currently loading"',
							"if(installedChunkData) {",
							Template.indent(["promises.push(installedChunkData[2]);"]),
							"} else {",
							Template.indent([
								"// load the chunk and return promise to it",
								"var promise = new Promise(function(resolve, reject) {",
								Template.indent([
									"installedChunkData = installedChunks[chunkId] = [resolve, reject];",
									"var filename = require('path').join(__dirname, " +
										mainTemplate.getAssetPath(
											JSON.stringify(`/${chunkFilename}`),
											{
												hash: `" + ${mainTemplate.renderCurrentHashCode(
													hash
												)} + "`,
												hashWithLength: length =>
													`" + ${mainTemplate.renderCurrentHashCode(
														hash,
														length
													)} + "`,
												chunk: {
													id: '" + chunkId + "',
													hash: `" + ${JSON.stringify(
														chunkMaps.hash
													)}[chunkId] + "`,
													hashWithLength: length => {
														const shortChunkHashMap = {};
														for (const chunkId of Object.keys(chunkMaps.hash)) {
															if (typeof chunkMaps.hash[chunkId] == "string") {
																shortChunkHashMap[chunkId] = chunkMaps.hash[
																	chunkId
																].substr(0, length);
															}
														}
														return `" + ${JSON.stringify(
															shortChunkHashMap
														)}[chunkId] + "`;
													},
													contentHash: {
														javascript: `" + ${JSON.stringify(
															chunkMaps.contentHash.javascript
														)}[chunkId] + "`
													},
													contentHashWithLength: {
														javascript: length => {
															const shortContentHashMap = {};
															const contentHash =
																chunkMaps.contentHash.javascript;
															for (const chunkId of Object.keys(contentHash)) {
																if (typeof contentHash[chunkId] == "string") {
																	shortContentHashMap[chunkId] = contentHash[
																		chunkId
																	].substr(0, length);
																}
															}
															return `" + ${JSON.stringify(
																shortContentHashMap
															)}[chunkId] + "`;
														}
													},
													name: `" + (${JSON.stringify(
														chunkMaps.name
													)}[chunkId]||chunkId) + "`
												},
												contentHashType: "javascript"
											}
										) +
										");",
									"require('fs').readFile(filename, 'utf-8',  function(err, content) {",
									Template.indent(
										[
											"if(err) return reject(err);",
											"var chunk = {};",
											"require('vm').runInThisContext('(function(exports, require, __dirname, __filename) {' + content + '\\n})', filename)(chunk, require, require('path').dirname(filename), filename);"
										]
											.concat(insertMoreModules)
											.concat([
												"var callbacks = [];",
												"for(var i = 0; i < chunkIds.length; i++) {",
												Template.indent([
													"if(installedChunks[chunkIds[i]])",
													Template.indent([
														"callbacks = callbacks.concat(installedChunks[chunkIds[i]][0]);"
													]),
													"installedChunks[chunkIds[i]] = 0;"
												]),
												"}",
												"for(i = 0; i < callbacks.length; i++)",
												Template.indent("callbacks[i]();")
											])
									),
									"});"
								]),
								"});",
								"promises.push(installedChunkData[2] = promise);"
							]),
							"}"
						]),
						"}"
					]);
				} else {
					const request = mainTemplate.getAssetPath(
						JSON.stringify(`./${chunkFilename}`),
						{
							hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
							hashWithLength: length =>
								`" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`,
							chunk: {
								id: '" + chunkId + "',
								hash: `" + ${JSON.stringify(chunkMaps.hash)}[chunkId] + "`,
								hashWithLength: length => {
									const shortChunkHashMap = {};
									for (const chunkId of Object.keys(chunkMaps.hash)) {
										if (typeof chunkMaps.hash[chunkId] == "string") {
											shortChunkHashMap[chunkId] = chunkMaps.hash[
												chunkId
											].substr(0, length);
										}
									}
									return `" + ${JSON.stringify(
										shortChunkHashMap
									)}[chunkId] + "`;
								},
								contentHash: {
									javascript: `" + ${JSON.stringify(
										chunkMaps.contentHash.javascript
									)}[chunkId] + "`
								},
								contentHashWithLength: {
									javascript: length => {
										const shortContentHashMap = {};
										const contentHash = chunkMaps.contentHash.javascript;
										for (const chunkId of Object.keys(contentHash)) {
											if (typeof contentHash[chunkId] == "string") {
												shortContentHashMap[chunkId] = contentHash[
													chunkId
												].substr(0, length);
											}
										}
										return `" + ${JSON.stringify(
											shortContentHashMap
										)}[chunkId] + "`;
									}
								},
								name: `" + (${JSON.stringify(
									chunkMaps.name
								)}[chunkId]||chunkId) + "`
							},
							contentHashType: "javascript"
						}
					);
					return Template.asString([
						source,
						"",
						"// require() chunk loading for javascript",
						"",
						'// "0" is the signal for "already loaded"',
						"if(installedChunks[chunkId] !== 0) {",
						Template.indent(
							[`var chunk = require(${request});`]
								.concat(insertMoreModules)
								.concat([
									"for(var i = 0; i < chunkIds.length; i++)",
									Template.indent("installedChunks[chunkIds[i]] = 0;")
								])
						),
						"}"
					]);
				}
			}
		);
		mainTemplate.hooks.hotBootstrap.tap(
			"NodeMainTemplatePlugin",
			(source, chunk, hash) => {
				const hotUpdateChunkFilename =
					mainTemplate.outputOptions.hotUpdateChunkFilename;
				const hotUpdateMainFilename =
					mainTemplate.outputOptions.hotUpdateMainFilename;
				const chunkMaps = chunk.getChunkMaps();
				const currentHotUpdateChunkFilename = mainTemplate.getAssetPath(
					JSON.stringify(hotUpdateChunkFilename),
					{
						hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
						hashWithLength: length =>
							`" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`,
						chunk: {
							id: '" + chunkId + "',
							hash: `" + ${JSON.stringify(chunkMaps.hash)}[chunkId] + "`,
							hashWithLength: length => {
								const shortChunkHashMap = {};
								for (const chunkId of Object.keys(chunkMaps.hash)) {
									if (typeof chunkMaps.hash[chunkId] == "string") {
										shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substr(
											0,
											length
										);
									}
								}
								return `" + ${JSON.stringify(shortChunkHashMap)}[chunkId] + "`;
							},
							name: `" + (${JSON.stringify(
								chunkMaps.name
							)}[chunkId]||chunkId) + "`
						}
					}
				);
				const currentHotUpdateMainFilename = mainTemplate.getAssetPath(
					JSON.stringify(hotUpdateMainFilename),
					{
						hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
						hashWithLength: length =>
							`" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`
					}
				);
				return Template.getFunctionContent(
					asyncChunkLoading
						? __webpack_require__(267)
						: __webpack_require__(268)
				)
					.replace(/\$require\$/g, mainTemplate.requireFn)
					.replace(/\$hotMainFilename\$/g, currentHotUpdateMainFilename)
					.replace(/\$hotChunkFilename\$/g, currentHotUpdateChunkFilename);
			}
		);
		mainTemplate.hooks.hash.tap("NodeMainTemplatePlugin", hash => {
			hash.update("node");
			hash.update("4");
		});
	}
};

},
// 267
function(module) {

var $hotChunkFilename$ = void 0,
	$require$ = void 0,
	hotAddUpdateChunk = void 0,
	$hotMainFilename$ = void 0,
	installedChunks = void 0;

module.exports = function() {
	function hotDownloadUpdateChunk(chunkId) {
		var filename = require("path").join(__dirname, $hotChunkFilename$);
		require("fs").readFile(filename, "utf-8", function(err, content) {
			if (err) {
				if ($require$.onError) return $require$.oe(err);
				throw err;
			}
			var chunk = {};
			require("vm").runInThisContext(
				"(function(exports) {" + content + "\n})",
				{ filename: filename }
			)(chunk);
			hotAddUpdateChunk(chunk.id, chunk.modules);
		});
	}

	function hotDownloadManifest() {
		var filename = require("path").join(__dirname, $hotMainFilename$);
		return new Promise(function(resolve, reject) {
			require("fs").readFile(filename, "utf-8", function(err, content) {
				if (err) return resolve();
				try {
					var update = JSON.parse(content);
				} catch (e) {
					return reject(e);
				}
				resolve(update);
			});
		});
	}

	function hotDisposeChunk(chunkId) {
		delete installedChunks[chunkId];
	}
};

},
// 268
function(module) {

var $hotChunkFilename$ = void 0,
	hotAddUpdateChunk = void 0,
	installedChunks = void 0,
	$hotMainFilename$ = void 0;

module.exports = function() {
	function hotDownloadUpdateChunk(chunkId) {
		var chunk = require("./" + $hotChunkFilename$);
		hotAddUpdateChunk(chunk.id, chunk.modules);
	}

	function hotDownloadManifest() {
		try {
			var update = require("./" + $hotMainFilename$);
		} catch (_) {
			return Promise.resolve();
		}
		return Promise.resolve(update);
	}

	function hotDisposeChunk(chunkId) {
		delete installedChunks[chunkId];
	}
};

},
// 269
function(module, exports, __webpack_require__) {

const { ConcatSource } = __webpack_require__(0);

class NodeChunkTemplatePlugin {
	apply(chunkTemplate) {
		chunkTemplate.hooks.render.tap(
			"NodeChunkTemplatePlugin",
			(modules, chunk) => {
				const source = new ConcatSource();
				source.add(
					`exports.ids = ${JSON.stringify(chunk.ids)};\nexports.modules = `
				);
				source.add(modules);
				source.add(";");
				return source;
			}
		);
		chunkTemplate.hooks.hash.tap("NodeChunkTemplatePlugin", hash => {
			hash.update("node");
			hash.update("3");
		});
	}
}

module.exports = NodeChunkTemplatePlugin;

},
// 270
function(module, exports, __webpack_require__) {

const { ConcatSource } = __webpack_require__(0);

class NodeHotUpdateChunkTemplatePlugin {
	apply(hotUpdateChunkTemplate) {
		hotUpdateChunkTemplate.hooks.render.tap(
			"NodeHotUpdateChunkTemplatePlugin",
			(modulesSource, modules, removedModules, hash, id) => {
				const source = new ConcatSource();
				source.add(
					"exports.id = " + JSON.stringify(id) + ";\nexports.modules = "
				);
				source.add(modulesSource);
				source.add(";");
				return source;
			}
		);
		hotUpdateChunkTemplate.hooks.hash.tap(
			"NodeHotUpdateChunkTemplatePlugin",
			hash => {
				hash.update("NodeHotUpdateChunkTemplatePlugin");
				hash.update("3");
				hash.update(
					hotUpdateChunkTemplate.outputOptions.hotUpdateFunction + ""
				);
				hash.update(hotUpdateChunkTemplate.outputOptions.library + "");
			}
		);
	}
}
module.exports = NodeHotUpdateChunkTemplatePlugin;

},
// 271
function(module, exports, __webpack_require__) {

const { OriginalSource, RawSource } = __webpack_require__(0);
const Module = __webpack_require__(16);
const WebpackMissingModule = __webpack_require__(38);
const Template = __webpack_require__(2);

class ExternalModule extends Module {
	constructor(request, type, userRequest) {
		super("javascript/dynamic", null);

		this.request = request;
		this.externalType = type;
		this.userRequest = userRequest;
		this.external = true;
	}

	libIdent() {
		return this.userRequest;
	}

	chunkCondition(chunk) {
		return chunk.hasEntryModule();
	}

	identifier() {
		return "external " + JSON.stringify(this.request);
	}

	readableIdentifier() {
		return "external " + JSON.stringify(this.request);
	}

	needRebuild() {
		return false;
	}

	build(options, compilation, resolver, fs, callback) {
		this.built = true;
		this.buildMeta = {};
		this.buildInfo = {};
		callback();
	}

	getSourceForGlobalVariableExternal(variableName, type) {
		if (!Array.isArray(variableName)) {
			variableName = [variableName];
		}

		const objectLookup = variableName
			.map(r => `[${JSON.stringify(r)}]`)
			.join("");
		return `(function() { module.exports = ${type}${objectLookup}; }());`;
	}

	getSourceForCommonJsExternal(moduleAndSpecifiers) {
		if (!Array.isArray(moduleAndSpecifiers)) {
			return `module.exports = require(${JSON.stringify(
				moduleAndSpecifiers
			)});`;
		}

		const moduleName = moduleAndSpecifiers[0];
		const objectLookup = moduleAndSpecifiers
			.slice(1)
			.map(r => `[${JSON.stringify(r)}]`)
			.join("");
		return `module.exports = require(${JSON.stringify(
			moduleName
		)})${objectLookup};`;
	}

	checkExternalVariable(variableToCheck, request) {
		return `if(typeof ${variableToCheck} === 'undefined') {${WebpackMissingModule.moduleCode(
			request
		)}}\n`;
	}

	getSourceForAmdOrUmdExternal(id, optional, request) {
		const externalVariable = `__WEBPACK_EXTERNAL_MODULE_${Template.toIdentifier(
			`${id}`
		)}__`;
		const missingModuleError = optional
			? this.checkExternalVariable(externalVariable, request)
			: "";
		return `${missingModuleError}module.exports = ${externalVariable};`;
	}

	getSourceForDefaultCase(optional, request) {
		if (!Array.isArray(request)) {
			request = [request];
		}

		const variableName = request[0];
		const missingModuleError = optional
			? this.checkExternalVariable(variableName, request.join("."))
			: "";
		const objectLookup = request
			.slice(1)
			.map(r => `[${JSON.stringify(r)}]`)
			.join("");
		return `${missingModuleError}module.exports = ${variableName}${objectLookup};`;
	}

	getSourceString(runtime) {
		const request =
			typeof this.request == "object" && !Array.isArray(this.request)
				? this.request[this.externalType]
				: this.request;
		switch (this.externalType) {
			case "this":
			case "window":
			case "self":
				return this.getSourceForGlobalVariableExternal(
					request,
					this.externalType
				);
			case "global":
				return this.getSourceForGlobalVariableExternal(
					request,
					runtime.outputOptions.globalObject
				);
			case "commonjs":
			case "commonjs2":
				return this.getSourceForCommonJsExternal(request);
			case "amd":
			case "amd-require":
			case "umd":
			case "umd2":
			case "system":
				return this.getSourceForAmdOrUmdExternal(
					this.id,
					this.optional,
					request
				);
			default:
				return this.getSourceForDefaultCase(this.optional, request);
		}
	}

	getSource(sourceString) {
		if (this.useSourceMap) {
			return new OriginalSource(sourceString, this.identifier());
		}

		return new RawSource(sourceString);
	}

	source(dependencyTemplates, runtime) {
		return this.getSource(this.getSourceString(runtime));
	}

	size() {
		return 42;
	}

	updateHash(hash) {
		hash.update(this.externalType);
		hash.update(JSON.stringify(this.request));
		hash.update(JSON.stringify(Boolean(this.optional)));
		super.updateHash(hash);
	}
}

module.exports = ExternalModule;

},
// 272
function(module, exports, __webpack_require__) {

const { ConcatSource } = __webpack_require__(0);

const accessorToObjectAccess = accessor => {
	return accessor.map(a => `[${JSON.stringify(a)}]`).join("");
};

class ExportPropertyMainTemplatePlugin {
	constructor(property) {
		this.property = property;
	}

	apply(compilation) {
		const { mainTemplate, chunkTemplate } = compilation;

		const onRenderWithEntry = (source, chunk, hash) => {
			const postfix = `${accessorToObjectAccess([].concat(this.property))}`;
			return new ConcatSource(source, postfix);
		};

		for (const template of [mainTemplate, chunkTemplate]) {
			template.hooks.renderWithEntry.tap(
				"ExportPropertyMainTemplatePlugin",
				onRenderWithEntry
			);
		}

		mainTemplate.hooks.hash.tap("ExportPropertyMainTemplatePlugin", hash => {
			hash.update("export property");
			hash.update(`${this.property}`);
		});
	}
}

module.exports = ExportPropertyMainTemplatePlugin;

},
// 273
function(module, exports, __webpack_require__) {

const { ConcatSource } = __webpack_require__(0);
const Template = __webpack_require__(2);

class AmdMainTemplatePlugin {
	constructor(options) {
		if (!options || typeof options == "string") {
			this.name = options;
			this.requireAsWrapper = false;
		} else {
			this.name = options.name;
			this.requireAsWrapper = options.requireAsWrapper;
		}
	}

	apply(compilation) {
		const { mainTemplate, chunkTemplate } = compilation;

		const onRenderWithEntry = (source, chunk, hash) => {
			const externals = chunk.getModules().filter(m => m.external);
			const externalsDepsArray = JSON.stringify(
				externals.map(m =>
					typeof m.request == "object" ? m.request.amd : m.request
				)
			);
			const externalsArguments = externals
				.map(
					m => `__WEBPACK_EXTERNAL_MODULE_${Template.toIdentifier(`${m.id}`)}__`
				)
				.join(", ");

			if (this.requireAsWrapper) {
				return new ConcatSource(
					`require(${externalsDepsArray}, function(${externalsArguments}) { return `,
					source,
					"});"
				);
			} else if (this.name) {
				const name = mainTemplate.getAssetPath(this.name, {
					hash,
					chunk
				});

				return new ConcatSource(
					`define(${JSON.stringify(
						name
					)}, ${externalsDepsArray}, function(${externalsArguments}) { return `,
					source,
					"});"
				);
			} else if (externalsArguments) {
				return new ConcatSource(
					`define(${externalsDepsArray}, function(${externalsArguments}) { return `,
					source,
					"});"
				);
			} else {
				return new ConcatSource("define(function() { return ", source, "});");
			}
		};

		for (const template of [mainTemplate, chunkTemplate]) {
			template.hooks.renderWithEntry.tap(
				"AmdMainTemplatePlugin",
				onRenderWithEntry
			);
		}

		mainTemplate.hooks.globalHashPaths.tap("AmdMainTemplatePlugin", paths => {
			if (this.name) {
				paths.push(this.name);
			}
			return paths;
		});

		mainTemplate.hooks.hash.tap("AmdMainTemplatePlugin", hash => {
			hash.update("exports amd");
			if (this.name) {
				hash.update(this.name);
			}
		});
	}
}

module.exports = AmdMainTemplatePlugin;

},
// 274
function(module, exports, __webpack_require__) {

const { ConcatSource } = __webpack_require__(0);

class JsonpExportMainTemplatePlugin {
	constructor(name) {
		this.name = name;
	}

	apply(compilation) {
		const { mainTemplate, chunkTemplate } = compilation;

		const onRenderWithEntry = (source, chunk, hash) => {
			const name = mainTemplate.getAssetPath(this.name || "", {
				hash,
				chunk
			});
			return new ConcatSource(`${name}(`, source, ");");
		};

		for (const template of [mainTemplate, chunkTemplate]) {
			template.hooks.renderWithEntry.tap(
				"JsonpExportMainTemplatePlugin",
				onRenderWithEntry
			);
		}

		mainTemplate.hooks.globalHashPaths.tap(
			"JsonpExportMainTemplatePlugin",
			paths => {
				if (this.name) paths.push(this.name);
				return paths;
			}
		);

		mainTemplate.hooks.hash.tap("JsonpExportMainTemplatePlugin", hash => {
			hash.update("jsonp export");
			hash.update(`${this.name}`);
		});
	}
}

module.exports = JsonpExportMainTemplatePlugin;

},
// 275
function(module, exports, __webpack_require__) {

const { ConcatSource } = __webpack_require__(0);
const Template = __webpack_require__(2);

class SystemMainTemplatePlugin {
	constructor(options) {
		this.name = options.name;
	}

	apply(compilation) {
		const { mainTemplate, chunkTemplate } = compilation;

		const onRenderWithEntry = (source, chunk, hash) => {
			const externals = chunk.getModules().filter(m => m.external);

			const name = this.name
				? `${JSON.stringify(
						mainTemplate.getAssetPath(this.name, { hash, chunk })
					)}, `
				: "";

			const systemDependencies = JSON.stringify(
				externals.map(m =>
					typeof m.request == "object" ? m.request.amd : m.request
				)
			);

			const dynamicExport = "__WEBPACK_DYNAMIC_EXPORT__";

			const externalWebpackNames = externals.map(
				m => `__WEBPACK_EXTERNAL_MODULE_${Template.toIdentifier(`${m.id}`)}__`
			);

			const externalVarDeclarations =
				externalWebpackNames.length > 0
					? `var ${externalWebpackNames.join(", ")};`
					: "";

			const setters =
				externalWebpackNames.length === 0
					? ""
					: Template.asString([
							"setters: [",
							Template.indent(
								externalWebpackNames
									.map(external =>
										Template.asString([
											"function(module) {",
											Template.indent(`${external} = module;`),
											"}"
										])
									)
									.join(",\n")
							),
							"],"
						]);

			return new ConcatSource(
				Template.asString([
					`System.register(${name}${systemDependencies}, function(${dynamicExport}) {`,
					Template.indent([
						externalVarDeclarations,
						"return {",
						Template.indent([
							setters,
							"execute: function() {",
							Template.indent(`${dynamicExport}(`)
						])
					])
				]) + "\n",
				source,
				"\n" +
					Template.asString([
						Template.indent([
							Template.indent([Template.indent([");"]), "}"]),
							"};"
						]),
						"})"
					])
			);
		};

		for (const template of [mainTemplate, chunkTemplate]) {
			template.hooks.renderWithEntry.tap(
				"SystemMainTemplatePlugin",
				onRenderWithEntry
			);
		}

		mainTemplate.hooks.globalHashPaths.tap(
			"SystemMainTemplatePlugin",
			paths => {
				if (this.name) {
					paths.push(this.name);
				}
				return paths;
			}
		);

		mainTemplate.hooks.hash.tap("SystemMainTemplatePlugin", hash => {
			hash.update("exports system");
			if (this.name) {
				hash.update(this.name);
			}
		});
	}
}

module.exports = SystemMainTemplatePlugin;

},
// 276
function(module, exports, __webpack_require__) {

const path = __webpack_require__(3);
const AMDRequireDependency = __webpack_require__(125);
const AMDRequireItemDependency = __webpack_require__(67);
const AMDRequireArrayDependency = __webpack_require__(68);
const AMDRequireContextDependency = __webpack_require__(69);
const AMDDefineDependency = __webpack_require__(126);
const UnsupportedDependency = __webpack_require__(127);
const LocalModuleDependency = __webpack_require__(40);

const NullFactory = __webpack_require__(10);

const AMDRequireDependenciesBlockParserPlugin = __webpack_require__(277);
const AMDDefineDependencyParserPlugin = __webpack_require__(279);

const AliasPlugin = __webpack_require__(24).AliasPlugin;

const ParserHelpers = __webpack_require__(9);

class AMDPlugin {
	constructor(options, amdOptions) {
		this.amdOptions = amdOptions;
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		const amdOptions = this.amdOptions;
		compiler.hooks.compilation.tap(
			"AMDPlugin",
			(compilation, { contextModuleFactory, normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					AMDRequireDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					AMDRequireDependency,
					new AMDRequireDependency.Template()
				);

				compilation.dependencyFactories.set(
					AMDRequireItemDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					AMDRequireItemDependency,
					new AMDRequireItemDependency.Template()
				);

				compilation.dependencyFactories.set(
					AMDRequireArrayDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					AMDRequireArrayDependency,
					new AMDRequireArrayDependency.Template()
				);

				compilation.dependencyFactories.set(
					AMDRequireContextDependency,
					contextModuleFactory
				);
				compilation.dependencyTemplates.set(
					AMDRequireContextDependency,
					new AMDRequireContextDependency.Template()
				);

				compilation.dependencyFactories.set(
					AMDDefineDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					AMDDefineDependency,
					new AMDDefineDependency.Template()
				);

				compilation.dependencyFactories.set(
					UnsupportedDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					UnsupportedDependency,
					new UnsupportedDependency.Template()
				);

				compilation.dependencyFactories.set(
					LocalModuleDependency,
					new NullFactory()
				);
				compilation.dependencyTemplates.set(
					LocalModuleDependency,
					new LocalModuleDependency.Template()
				);

				const handler = (parser, parserOptions) => {
					if (parserOptions.amd !== void 0 && !parserOptions.amd) return;

					const setExpressionToModule = (outerExpr, module) => {
						parser.hooks.expression.for(outerExpr).tap("AMDPlugin", expr => {
							const dep = new AMDRequireItemDependency(module, expr.range);
							dep.userRequest = outerExpr;
							dep.loc = expr.loc;
							parser.state.current.addDependency(dep);
							return true;
						});
					};

					new AMDRequireDependenciesBlockParserPlugin(options).apply(parser);
					new AMDDefineDependencyParserPlugin(options).apply(parser);

					setExpressionToModule("require.amd", "!!webpack amd options");
					setExpressionToModule("define.amd", "!!webpack amd options");
					setExpressionToModule("define", "!!webpack amd define");

					parser.hooks.expression
						.for("__webpack_amd_options__")
						.tap("AMDPlugin", () =>
							parser.state.current.addVariable(
								"__webpack_amd_options__",
								JSON.stringify(amdOptions)
							)
						);
					parser.hooks.evaluateTypeof
						.for("define.amd")
						.tap(
							"AMDPlugin",
							ParserHelpers.evaluateToString(typeof amdOptions)
						);
					parser.hooks.evaluateTypeof
						.for("require.amd")
						.tap(
							"AMDPlugin",
							ParserHelpers.evaluateToString(typeof amdOptions)
						);
					parser.hooks.evaluateIdentifier
						.for("define.amd")
						.tap(
							"AMDPlugin",
							ParserHelpers.evaluateToIdentifier("define.amd", true)
						);
					parser.hooks.evaluateIdentifier
						.for("require.amd")
						.tap(
							"AMDPlugin",
							ParserHelpers.evaluateToIdentifier("require.amd", true)
						);
					parser.hooks.typeof
						.for("define")
						.tap(
							"AMDPlugin",
							ParserHelpers.toConstantDependency(
								parser,
								JSON.stringify("function")
							)
						);
					parser.hooks.evaluateTypeof
						.for("define")
						.tap("AMDPlugin", ParserHelpers.evaluateToString("function"));
					parser.hooks.canRename
						.for("define")
						.tap("AMDPlugin", ParserHelpers.approve);
					parser.hooks.rename.for("define").tap("AMDPlugin", expr => {
						const dep = new AMDRequireItemDependency(
							"!!webpack amd define",
							expr.range
						);
						dep.userRequest = "define";
						dep.loc = expr.loc;
						parser.state.current.addDependency(dep);
						return false;
					});
					parser.hooks.typeof
						.for("require")
						.tap(
							"AMDPlugin",
							ParserHelpers.toConstantDependency(
								parser,
								JSON.stringify("function")
							)
						);
					parser.hooks.evaluateTypeof
						.for("require")
						.tap("AMDPlugin", ParserHelpers.evaluateToString("function"));
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("AMDPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("AMDPlugin", handler);
			}
		);
		compiler.hooks.afterResolvers.tap("AMDPlugin", () => {
			compiler.resolverFactory.hooks.resolver
				.for("normal")
				.tap("AMDPlugin", resolver => {
					new AliasPlugin(
						"described-resolve",
						{
							name: "amdefine",
							alias: path.join(
								__dirname,
								"..",
								"buildin",
								"amd-define.js"
							)
						},
						"resolve"
					).apply(resolver);
					new AliasPlugin(
						"described-resolve",
						{
							name: "webpack amd options",
							alias: path.join(
								__dirname,
								"..",
								"buildin",
								"amd-options.js"
							)
						},
						"resolve"
					).apply(resolver);
					new AliasPlugin(
						"described-resolve",
						{
							name: "webpack amd define",
							alias: path.join(
								__dirname,
								"..",
								"buildin",
								"amd-define.js"
							)
						},
						"resolve"
					).apply(resolver);
				});
		});
	}
}
module.exports = AMDPlugin;

},
// 277
function(module, exports, __webpack_require__) {

const AMDRequireItemDependency = __webpack_require__(67);
const AMDRequireArrayDependency = __webpack_require__(68);
const AMDRequireContextDependency = __webpack_require__(69);
const AMDRequireDependenciesBlock = __webpack_require__(278);
const UnsupportedDependency = __webpack_require__(127);
const LocalModuleDependency = __webpack_require__(40);
const ContextDependencyHelpers = __webpack_require__(27);
const LocalModulesHelpers = __webpack_require__(64);
const ConstDependency = __webpack_require__(5);
const getFunctionExpression = __webpack_require__(115);
const UnsupportedFeatureWarning = __webpack_require__(62);

class AMDRequireDependenciesBlockParserPlugin {
	constructor(options) {
		this.options = options;
	}

	processFunctionArgument(parser, expression) {
		let bindThis = true;
		const fnData = getFunctionExpression(expression);
		if (fnData) {
			parser.inScope(
				fnData.fn.params.filter(i => {
					return !["require", "module", "exports"].includes(i.name);
				}),
				() => {
					if (fnData.fn.body.type === "BlockStatement") {
						parser.walkStatement(fnData.fn.body);
					} else {
						parser.walkExpression(fnData.fn.body);
					}
				}
			);
			parser.walkExpressions(fnData.expressions);
			if (fnData.needThis === false) {
				bindThis = false;
			}
		} else {
			parser.walkExpression(expression);
		}
		return bindThis;
	}

	apply(parser) {
		parser.hooks.call
			.for("require")
			.tap(
				"AMDRequireDependenciesBlockParserPlugin",
				this.processCallRequire.bind(this, parser)
			);
	}

	processArray(parser, expr, param) {
		if (param.isArray()) {
			for (const p of param.items) {
				const result = this.processItem(parser, expr, p);
				if (result === void 0) {
					this.processContext(parser, expr, p);
				}
			}
			return true;
		} else if (param.isConstArray()) {
			const deps = [];
			for (const request of param.array) {
				let dep, localModule;
				if (request === "require") {
					dep = "__webpack_require__";
				} else if (["exports", "module"].includes(request)) {
					dep = request;
				} else if (
					(localModule = LocalModulesHelpers.getLocalModule(
						parser.state,
						request
					))
				) {
					dep = new LocalModuleDependency(localModule, void 0, false);
					dep.loc = expr.loc;
					parser.state.current.addDependency(dep);
				} else {
					dep = this.newRequireItemDependency(request);
					dep.loc = expr.loc;
					dep.optional = !!parser.scope.inTry;
					parser.state.current.addDependency(dep);
				}
				deps.push(dep);
			}
			const dep = this.newRequireArrayDependency(deps, param.range);
			dep.loc = expr.loc;
			dep.optional = !!parser.scope.inTry;
			parser.state.current.addDependency(dep);
			return true;
		}
	}
	processItem(parser, expr, param) {
		if (param.isConditional()) {
			for (const p of param.options) {
				const result = this.processItem(parser, expr, p);
				if (result === void 0) {
					this.processContext(parser, expr, p);
				}
			}
			return true;
		} else if (param.isString()) {
			let dep, localModule;
			if (param.string === "require") {
				dep = new ConstDependency("__webpack_require__", param.string);
			} else if (param.string === "module") {
				dep = new ConstDependency(
					parser.state.module.buildInfo.moduleArgument,
					param.range
				);
			} else if (param.string === "exports") {
				dep = new ConstDependency(
					parser.state.module.buildInfo.exportsArgument,
					param.range
				);
			} else if (
				(localModule = LocalModulesHelpers.getLocalModule(
					parser.state,
					param.string
				))
			) {
				dep = new LocalModuleDependency(localModule, param.range, false);
			} else {
				dep = this.newRequireItemDependency(param.string, param.range);
			}
			dep.loc = expr.loc;
			dep.optional = !!parser.scope.inTry;
			parser.state.current.addDependency(dep);
			return true;
		}
	}
	processContext(parser, expr, param) {
		const dep = ContextDependencyHelpers.create(
			AMDRequireContextDependency,
			param.range,
			param,
			expr,
			this.options,
			{},
			parser
		);
		if (!dep) return;
		dep.loc = expr.loc;
		dep.optional = !!parser.scope.inTry;
		parser.state.current.addDependency(dep);
		return true;
	}

	processArrayForRequestString(param) {
		if (param.isArray()) {
			const result = param.items.map(item =>
				this.processItemForRequestString(item)
			);
			if (result.every(Boolean)) return result.join(" ");
		} else if (param.isConstArray()) {
			return param.array.join(" ");
		}
	}

	processItemForRequestString(param) {
		if (param.isConditional()) {
			const result = param.options.map(item =>
				this.processItemForRequestString(item)
			);
			if (result.every(Boolean)) return result.join("|");
		} else if (param.isString()) {
			return param.string;
		}
	}

	processCallRequire(parser, expr) {
		let param;
		let dep;
		let result;

		const old = parser.state.current;

		if (expr.arguments.length >= 1) {
			param = parser.evaluateExpression(expr.arguments[0]);
			dep = this.newRequireDependenciesBlock(
				expr,
				param.range,
				expr.arguments.length > 1 ? expr.arguments[1].range : null,
				expr.arguments.length > 2 ? expr.arguments[2].range : null,
				parser.state.module,
				expr.loc,
				this.processArrayForRequestString(param)
			);
			parser.state.current = dep;
		}

		if (expr.arguments.length === 1) {
			parser.inScope([], () => {
				result = this.processArray(parser, expr, param);
			});
			parser.state.current = old;
			if (!result) return;
			parser.state.current.addBlock(dep);
			return true;
		}

		if (expr.arguments.length === 2 || expr.arguments.length === 3) {
			try {
				parser.inScope([], () => {
					result = this.processArray(parser, expr, param);
				});
				if (!result) {
					dep = new UnsupportedDependency("unsupported", expr.range);
					old.addDependency(dep);
					if (parser.state.module) {
						parser.state.module.errors.push(
							new UnsupportedFeatureWarning(
								parser.state.module,
								"Cannot statically analyse 'require(…, …)' in line " +
									expr.loc.start.line,
								expr.loc
							)
						);
					}
					dep = null;
					return true;
				}
				dep.functionBindThis = this.processFunctionArgument(
					parser,
					expr.arguments[1]
				);
				if (expr.arguments.length === 3) {
					dep.errorCallbackBindThis = this.processFunctionArgument(
						parser,
						expr.arguments[2]
					);
				}
			} finally {
				parser.state.current = old;
				if (dep) parser.state.current.addBlock(dep);
			}
			return true;
		}
	}

	newRequireDependenciesBlock(
		expr,
		arrayRange,
		functionRange,
		errorCallbackRange,
		module,
		loc,
		request
	) {
		return new AMDRequireDependenciesBlock(
			expr,
			arrayRange,
			functionRange,
			errorCallbackRange,
			module,
			loc,
			request
		);
	}
	newRequireItemDependency(request, range) {
		return new AMDRequireItemDependency(request, range);
	}
	newRequireArrayDependency(depsArray, range) {
		return new AMDRequireArrayDependency(depsArray, range);
	}
}
module.exports = AMDRequireDependenciesBlockParserPlugin;

},
// 278
function(module, exports, __webpack_require__) {

const AsyncDependenciesBlock = __webpack_require__(35);
const AMDRequireDependency = __webpack_require__(125);

module.exports = class extends AsyncDependenciesBlock {
	constructor(
		expr,
		arrayRange,
		functionRange,
		errorCallbackRange,
		module,
		loc,
		request
	) {
		super(null, module, loc, request);
		this.expr = expr;
		this.outerRange = expr.range;
		this.arrayRange = arrayRange;
		this.functionBindThis = false;
		this.functionRange = functionRange;
		this.errorCallbackBindThis = false;
		this.errorCallbackRange = errorCallbackRange;
		this.bindThis = true;
		if (arrayRange && functionRange && errorCallbackRange) {
			this.range = [arrayRange[0], errorCallbackRange[1]];
		} else if (arrayRange && functionRange) {
			this.range = [arrayRange[0], functionRange[1]];
		} else if (arrayRange) {
			this.range = arrayRange;
		} else if (functionRange) {
			this.range = functionRange;
		} else {
			this.range = expr.range;
		}
		const dep = this.newRequireDependency();
		dep.loc = loc;
		this.addDependency(dep);
	}

	newRequireDependency() {
		return new AMDRequireDependency(this);
	}
};

},
// 279
function(module, exports, __webpack_require__) {

const AMDRequireItemDependency = __webpack_require__(67);
const AMDRequireContextDependency = __webpack_require__(69);
const ConstDependency = __webpack_require__(5);
const AMDDefineDependency = __webpack_require__(126);
const AMDRequireArrayDependency = __webpack_require__(68);
const LocalModuleDependency = __webpack_require__(40);
const ContextDependencyHelpers = __webpack_require__(27);
const LocalModulesHelpers = __webpack_require__(64);

const isBoundFunctionExpression = expr => {
	if (expr.type !== "CallExpression") return false;
	if (expr.callee.type !== "MemberExpression") return false;
	if (expr.callee.computed) return false;
	if (expr.callee.object.type !== "FunctionExpression") return false;
	if (expr.callee.property.type !== "Identifier") return false;
	if (expr.callee.property.name !== "bind") return false;
	return true;
};

const isUnboundFunctionExpression = expr => {
	if (expr.type === "FunctionExpression") return true;
	if (expr.type === "ArrowFunctionExpression") return true;
	return false;
};

const isCallable = expr => {
	if (isUnboundFunctionExpression(expr)) return true;
	if (isBoundFunctionExpression(expr)) return true;
	return false;
};

class AMDDefineDependencyParserPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(parser) {
		parser.hooks.call
			.for("define")
			.tap(
				"AMDDefineDependencyParserPlugin",
				this.processCallDefine.bind(this, parser)
			);
	}

	processArray(parser, expr, param, identifiers, namedModule) {
		if (param.isArray()) {
			param.items.forEach((param, idx) => {
				if (
					param.isString() &&
					["require", "module", "exports"].includes(param.string)
				)
					identifiers[idx] = param.string;
				const result = this.processItem(parser, expr, param, namedModule);
				if (result === void 0) {
					this.processContext(parser, expr, param);
				}
			});
			return true;
		} else if (param.isConstArray()) {
			const deps = [];
			param.array.forEach((request, idx) => {
				let dep;
				let localModule;
				if (request === "require") {
					identifiers[idx] = request;
					dep = "__webpack_require__";
				} else if (["exports", "module"].includes(request)) {
					identifiers[idx] = request;
					dep = request;
				} else if (
					(localModule = LocalModulesHelpers.getLocalModule(
						parser.state,
						request
					))
				) {
					dep = new LocalModuleDependency(localModule, void 0, false);
					dep.loc = expr.loc;
					parser.state.current.addDependency(dep);
				} else {
					dep = this.newRequireItemDependency(request);
					dep.loc = expr.loc;
					dep.optional = !!parser.scope.inTry;
					parser.state.current.addDependency(dep);
				}
				deps.push(dep);
			});
			const dep = this.newRequireArrayDependency(deps, param.range);
			dep.loc = expr.loc;
			dep.optional = !!parser.scope.inTry;
			parser.state.current.addDependency(dep);
			return true;
		}
	}
	processItem(parser, expr, param, namedModule) {
		if (param.isConditional()) {
			param.options.forEach(param => {
				const result = this.processItem(parser, expr, param);
				if (result === void 0) {
					this.processContext(parser, expr, param);
				}
			});
			return true;
		} else if (param.isString()) {
			let dep, localModule;
			if (param.string === "require") {
				dep = new ConstDependency("__webpack_require__", param.range);
			} else if (["require", "exports", "module"].includes(param.string)) {
				dep = new ConstDependency(param.string, param.range);
			} else if (
				(localModule = LocalModulesHelpers.getLocalModule(
					parser.state,
					param.string,
					namedModule
				))
			) {
				dep = new LocalModuleDependency(localModule, param.range, false);
			} else {
				dep = this.newRequireItemDependency(param.string, param.range);
			}
			dep.loc = expr.loc;
			dep.optional = !!parser.scope.inTry;
			parser.state.current.addDependency(dep);
			return true;
		}
	}
	processContext(parser, expr, param) {
		const dep = ContextDependencyHelpers.create(
			AMDRequireContextDependency,
			param.range,
			param,
			expr,
			this.options,
			{},
			parser
		);
		if (!dep) return;
		dep.loc = expr.loc;
		dep.optional = !!parser.scope.inTry;
		parser.state.current.addDependency(dep);
		return true;
	}

	processCallDefine(parser, expr) {
		let array, fn, obj, namedModule;
		switch (expr.arguments.length) {
			case 1:
				if (isCallable(expr.arguments[0])) {
					fn = expr.arguments[0];
				} else if (expr.arguments[0].type === "ObjectExpression") {
					obj = expr.arguments[0];
				} else {
					obj = fn = expr.arguments[0];
				}
				break;
			case 2:
				if (expr.arguments[0].type === "Literal") {
					namedModule = expr.arguments[0].value;
					if (isCallable(expr.arguments[1])) {
						fn = expr.arguments[1];
					} else if (expr.arguments[1].type === "ObjectExpression") {
						obj = expr.arguments[1];
					} else {
						obj = fn = expr.arguments[1];
					}
				} else {
					array = expr.arguments[0];
					if (isCallable(expr.arguments[1])) {
						fn = expr.arguments[1];
					} else if (expr.arguments[1].type === "ObjectExpression") {
						obj = expr.arguments[1];
					} else {
						obj = fn = expr.arguments[1];
					}
				}
				break;
			case 3:
				namedModule = expr.arguments[0].value;
				array = expr.arguments[1];
				if (isCallable(expr.arguments[2])) {
					fn = expr.arguments[2];
				} else if (expr.arguments[2].type === "ObjectExpression") {
					obj = expr.arguments[2];
				} else {
					obj = fn = expr.arguments[2];
				}
				break;
			default:
				return;
		}
		let fnParams = null;
		let fnParamsOffset = 0;
		if (fn) {
			if (isUnboundFunctionExpression(fn)) {
				fnParams = fn.params;
			} else if (isBoundFunctionExpression(fn)) {
				fnParams = fn.callee.object.params;
				fnParamsOffset = fn.arguments.length - 1;
				if (fnParamsOffset < 0) {
					fnParamsOffset = 0;
				}
			}
		}
		let fnRenames = parser.scope.renames.createChild();
		if (array) {
			const identifiers = {};
			const param = parser.evaluateExpression(array);
			const result = this.processArray(
				parser,
				expr,
				param,
				identifiers,
				namedModule
			);
			if (!result) return;
			if (fnParams) {
				fnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => {
					if (identifiers[idx]) {
						fnRenames.set(param.name, identifiers[idx]);
						return false;
					}
					return true;
				});
			}
		} else {
			const identifiers = ["require", "exports", "module"];
			if (fnParams) {
				fnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => {
					if (identifiers[idx]) {
						fnRenames.set(param.name, identifiers[idx]);
						return false;
					}
					return true;
				});
			}
		}
		let inTry;
		if (fn && isUnboundFunctionExpression(fn)) {
			inTry = parser.scope.inTry;
			parser.inScope(fnParams, () => {
				parser.scope.renames = fnRenames;
				parser.scope.inTry = inTry;
				if (fn.body.type === "BlockStatement") {
					parser.walkStatement(fn.body);
				} else {
					parser.walkExpression(fn.body);
				}
			});
		} else if (fn && isBoundFunctionExpression(fn)) {
			inTry = parser.scope.inTry;
			parser.inScope(
				fn.callee.object.params.filter(
					i => !["require", "module", "exports"].includes(i.name)
				),
				() => {
					parser.scope.renames = fnRenames;
					parser.scope.inTry = inTry;
					if (fn.callee.object.body.type === "BlockStatement") {
						parser.walkStatement(fn.callee.object.body);
					} else {
						parser.walkExpression(fn.callee.object.body);
					}
				}
			);
			if (fn.arguments) {
				parser.walkExpressions(fn.arguments);
			}
		} else if (fn || obj) {
			parser.walkExpression(fn || obj);
		}

		const dep = this.newDefineDependency(
			expr.range,
			array ? array.range : null,
			fn ? fn.range : null,
			obj ? obj.range : null,
			namedModule ? namedModule : null
		);
		dep.loc = expr.loc;
		if (namedModule) {
			dep.localModule = LocalModulesHelpers.addLocalModule(
				parser.state,
				namedModule
			);
		}
		parser.state.current.addDependency(dep);
		return true;
	}

	newDefineDependency(
		range,
		arrayRange,
		functionRange,
		objectRange,
		namedModule
	) {
		return new AMDDefineDependency(
			range,
			arrayRange,
			functionRange,
			objectRange,
			namedModule
		);
	}
	newRequireArrayDependency(depsArray, range) {
		return new AMDRequireArrayDependency(depsArray, range);
	}
	newRequireItemDependency(request, range) {
		return new AMDRequireItemDependency(request, range);
	}
}
module.exports = AMDDefineDependencyParserPlugin;

},
// 280
function(module, exports, __webpack_require__) {

const ParserHelpers = __webpack_require__(9);
const ConstDependency = __webpack_require__(5);
const NullFactory = __webpack_require__(10);

module.exports = class {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"RequireJsStuffPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(ConstDependency, new NullFactory());
				compilation.dependencyTemplates.set(
					ConstDependency,
					new ConstDependency.Template()
				);
				const handler = (parser, parserOptions) => {
					if (parserOptions.requireJs !== void 0 && !parserOptions.requireJs)
						return;

					parser.hooks.call
						.for("require.config")
						.tap(
							"RequireJsStuffPlugin",
							ParserHelpers.toConstantDependency(parser, "undefined")
						);
					parser.hooks.call
						.for("requirejs.config")
						.tap(
							"RequireJsStuffPlugin",
							ParserHelpers.toConstantDependency(parser, "undefined")
						);

					parser.hooks.expression
						.for("require.version")
						.tap(
							"RequireJsStuffPlugin",
							ParserHelpers.toConstantDependency(
								parser,
								JSON.stringify("0.0.0")
							)
						);
					parser.hooks.expression
						.for("requirejs.onError")
						.tap(
							"RequireJsStuffPlugin",
							ParserHelpers.toConstantDependencyWithWebpackRequire(
								parser,
								"__webpack_require__.oe"
							)
						);
				};
				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("RequireJsStuffPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("RequireJsStuffPlugin", handler);
			}
		);
	}
};

},
// 281
function(module, exports, __webpack_require__) {

const path = __webpack_require__(3);
const ParserHelpers = __webpack_require__(9);
const ConstDependency = __webpack_require__(5);

const NullFactory = __webpack_require__(10);

class NodeStuffPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		compiler.hooks.compilation.tap(
			"NodeStuffPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(ConstDependency, new NullFactory());
				compilation.dependencyTemplates.set(
					ConstDependency,
					new ConstDependency.Template()
				);

				const handler = (parser, parserOptions) => {
					if (parserOptions.node === false) return;

					let localOptions = options;
					if (parserOptions.node) {
						localOptions = Object.assign({}, localOptions, parserOptions.node);
					}

					const setConstant = (expressionName, value) => {
						parser.hooks.expression
							.for(expressionName)
							.tap("NodeStuffPlugin", () => {
								parser.state.current.addVariable(
									expressionName,
									JSON.stringify(value)
								);
								return true;
							});
					};

					const setModuleConstant = (expressionName, fn) => {
						parser.hooks.expression
							.for(expressionName)
							.tap("NodeStuffPlugin", () => {
								parser.state.current.addVariable(
									expressionName,
									JSON.stringify(fn(parser.state.module))
								);
								return true;
							});
					};
					const context = compiler.context;
					if (localOptions.__filename) {
						if (localOptions.__filename === "mock") {
							setConstant("__filename", "/index.js");
						} else {
							setModuleConstant("__filename", module =>
								path.relative(context, module.resource)
							);
						}
						parser.hooks.evaluateIdentifier
							.for("__filename")
							.tap("NodeStuffPlugin", expr => {
								if (!parser.state.module) return;
								const resource = parser.state.module.resource;
								const i = resource.indexOf("?");
								return ParserHelpers.evaluateToString(
									i < 0 ? resource : resource.substr(0, i)
								)(expr);
							});
					}
					if (localOptions.__dirname) {
						if (localOptions.__dirname === "mock") {
							setConstant("__dirname", "/");
						} else {
							setModuleConstant("__dirname", module =>
								path.relative(context, module.context)
							);
						}
						parser.hooks.evaluateIdentifier
							.for("__dirname")
							.tap("NodeStuffPlugin", expr => {
								if (!parser.state.module) return;
								return ParserHelpers.evaluateToString(
									parser.state.module.context
								)(expr);
							});
					}
					parser.hooks.expression
						.for("require.extensions")
						.tap(
							"NodeStuffPlugin",
							ParserHelpers.expressionIsUnsupported(
								parser,
								"require.extensions is not supported by webpack. Use a loader instead."
							)
						);
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("NodeStuffPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("NodeStuffPlugin", handler);
			}
		);
	}
}
module.exports = NodeStuffPlugin;

},
// 282
function(module, exports, __webpack_require__) {

const NoModeWarning = __webpack_require__(283);

class WarnNoModeSetPlugin {
	apply(compiler) {
		compiler.hooks.thisCompilation.tap("WarnNoModeSetPlugin", compilation => {
			compilation.warnings.push(new NoModeWarning());
		});
	}
}

module.exports = WarnNoModeSetPlugin;

},
// 283
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);

module.exports = class extends WebpackError {
	constructor(modules) {
		super();

		this.name = "NoModeWarning";
		this.message =
			"configuration\nThe 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.\nYou can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/";

		Error.captureStackTrace(this, this.constructor);
	}
};

},
// 284
function(module, exports, __webpack_require__) {

const GraphHelpers = __webpack_require__(22);

class EnsureChunkConditionsPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"EnsureChunkConditionsPlugin",
			compilation => {
				const handler = chunks => {
					let changed = false;
					for (const module of compilation.modules) {
						if (!module.chunkCondition) continue;
						const sourceChunks = new Set();
						const chunkGroups = new Set();
						for (const chunk of module.chunksIterable) {
							if (!module.chunkCondition(chunk)) {
								sourceChunks.add(chunk);
								for (const group of chunk.groupsIterable) {
									chunkGroups.add(group);
								}
							}
						}
						if (sourceChunks.size === 0) continue;
						const targetChunks = new Set();
						chunkGroupLoop: for (const chunkGroup of chunkGroups) {
							for (const chunk of chunkGroup.chunks) {
								if (module.chunkCondition(chunk)) {
									targetChunks.add(chunk);
									continue chunkGroupLoop;
								}
							}
							if (chunkGroup.isInitial()) {
								throw new Error(
									"Cannot fullfil chunk condition of " + module.identifier()
								);
							}
							for (const group of chunkGroup.parentsIterable) {
								chunkGroups.add(group);
							}
						}
						for (const sourceChunk of sourceChunks) {
							GraphHelpers.disconnectChunkAndModule(sourceChunk, module);
						}
						for (const targetChunk of targetChunks) {
							GraphHelpers.connectChunkAndModule(targetChunk, module);
						}
					}
					if (changed) return true;
				};
				compilation.hooks.optimizeChunksBasic.tap(
					"EnsureChunkConditionsPlugin",
					handler
				);
				compilation.hooks.optimizeExtractedChunksBasic.tap(
					"EnsureChunkConditionsPlugin",
					handler
				);
			}
		);
	}
}
module.exports = EnsureChunkConditionsPlugin;

},
// 285
function(module, exports, __webpack_require__) {

const Queue = __webpack_require__(128);
const { intersect } = __webpack_require__(30);

const getParentChunksWithModule = (currentChunk, module) => {
	const chunks = [];
	const stack = new Set(currentChunk.parentsIterable);

	for (const chunk of stack) {
		if (chunk.containsModule(module)) {
			chunks.push(chunk);
		} else {
			for (const parent of chunk.parentsIterable) {
				stack.add(parent);
			}
		}
	}

	return chunks;
};

class RemoveParentModulesPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap("RemoveParentModulesPlugin", compilation => {
			const handler = (chunks, chunkGroups) => {
				const queue = new Queue();
				const availableModulesMap = new WeakMap();

				for (const chunkGroup of compilation.entrypoints.values()) {
					availableModulesMap.set(chunkGroup, new Set());
					for (const child of chunkGroup.childrenIterable) {
						queue.enqueue(child);
					}
				}

				while (queue.length > 0) {
					const chunkGroup = queue.dequeue();
					let availableModules = availableModulesMap.get(chunkGroup);
					let changed = false;
					for (const parent of chunkGroup.parentsIterable) {
						const availableModulesInParent = availableModulesMap.get(parent);
						if (availableModulesInParent !== void 0) {
							if (availableModules === void 0) {
								availableModules = new Set(availableModulesInParent);
								for (const chunk of parent.chunks) {
									for (const m of chunk.modulesIterable) {
										availableModules.add(m);
									}
								}
								availableModulesMap.set(chunkGroup, availableModules);
								changed = true;
							} else {
								for (const m of availableModules) {
									if (
										!parent.containsModule(m) &&
										!availableModulesInParent.has(m)
									) {
										availableModules.delete(m);
										changed = true;
									}
								}
							}
						}
					}
					if (changed) {
						for (const child of chunkGroup.childrenIterable) {
							queue.enqueue(child);
						}
					}
				}

				for (const chunk of chunks) {
					const availableModulesSets = Array.from(
						chunk.groupsIterable,
						chunkGroup => availableModulesMap.get(chunkGroup)
					);
					if (availableModulesSets.some(s => s === void 0)) continue;
					const availableModules =
						availableModulesSets.length === 1
							? availableModulesSets[0]
							: intersect(availableModulesSets);
					const numberOfModules = chunk.getNumberOfModules();
					const toRemove = new Set();
					if (numberOfModules < availableModules.size) {
						for (const m of chunk.modulesIterable) {
							if (availableModules.has(m)) {
								toRemove.add(m);
							}
						}
					} else {
						for (const m of availableModules) {
							if (chunk.containsModule(m)) {
								toRemove.add(m);
							}
						}
					}
					for (const module of toRemove) {
						module.rewriteChunkInReasons(
							chunk,
							getParentChunksWithModule(chunk, module)
						);
						chunk.removeModule(module);
					}
				}
			};
			compilation.hooks.optimizeChunksBasic.tap(
				"RemoveParentModulesPlugin",
				handler
			);
			compilation.hooks.optimizeExtractedChunksBasic.tap(
				"RemoveParentModulesPlugin",
				handler
			);
		});
	}
}
module.exports = RemoveParentModulesPlugin;

},
// 286
function(module, exports, __webpack_require__) {

class RemoveEmptyChunksPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap("RemoveEmptyChunksPlugin", compilation => {
			const handler = chunks => {
				for (let i = chunks.length - 1; i >= 0; i--) {
					const chunk = chunks[i];
					if (
						chunk.isEmpty() &&
						!chunk.hasRuntime() &&
						!chunk.hasEntryModule()
					) {
						chunk.remove("empty");
						chunks.splice(i, 1);
					}
				}
			};
			compilation.hooks.optimizeChunksBasic.tap(
				"RemoveEmptyChunksPlugin",
				handler
			);
			compilation.hooks.optimizeChunksAdvanced.tap(
				"RemoveEmptyChunksPlugin",
				handler
			);
			compilation.hooks.optimizeExtractedChunksBasic.tap(
				"RemoveEmptyChunksPlugin",
				handler
			);
			compilation.hooks.optimizeExtractedChunksAdvanced.tap(
				"RemoveEmptyChunksPlugin",
				handler
			);
		});
	}
}
module.exports = RemoveEmptyChunksPlugin;

},
// 287
function(module, exports, __webpack_require__) {

class MergeDuplicateChunksPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"MergeDuplicateChunksPlugin",
			compilation => {
				compilation.hooks.optimizeChunksBasic.tap(
					"MergeDuplicateChunksPlugin",
					chunks => {
						const notDuplicates = new Set();

						for (const chunk of chunks) {
							let possibleDuplicates;
							for (const module of chunk.modulesIterable) {
								if (possibleDuplicates === void 0) {
									for (const dup of module.chunksIterable) {
										if (
											dup !== chunk &&
											chunk.getNumberOfModules() === dup.getNumberOfModules() &&
											!notDuplicates.has(dup)
										) {
											if (possibleDuplicates === void 0) {
												possibleDuplicates = new Set();
											}
											possibleDuplicates.add(dup);
										}
									}
									if (possibleDuplicates === void 0) break;
								} else {
									for (const dup of possibleDuplicates) {
										if (!dup.containsModule(module)) {
											possibleDuplicates.delete(dup);
										}
									}
									if (possibleDuplicates.size === 0) break;
								}
							}

							if (
								possibleDuplicates !== void 0 &&
								possibleDuplicates.size > 0
							) {
								for (const otherChunk of possibleDuplicates) {
									if (otherChunk.hasRuntime() !== chunk.hasRuntime()) continue;
									if (chunk.integrate(otherChunk, "duplicate")) {
										chunks.splice(chunks.indexOf(otherChunk), 1);
									}
								}
							}

							notDuplicates.add(chunk);
						}
					}
				);
			}
		);
	}
}
module.exports = MergeDuplicateChunksPlugin;

},
// 288
function(module, exports, __webpack_require__) {

class FlagIncludedChunksPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap("FlagIncludedChunksPlugin", compilation => {
			compilation.hooks.optimizeChunkIds.tap(
				"FlagIncludedChunksPlugin",
				chunks => {
					const moduleBits = new WeakMap();
					const modulesCount = compilation.modules.length;

					const modulo = 1 / Math.pow(1 / modulesCount, 1 / 31);
					const modulos = Array.from(
						{ length: 31 },
						(x, i) => Math.pow(modulo, i) | 0
					);

					let i = 0;
					for (const module of compilation.modules) {
						let bit = 30;
						while (i % modulos[bit] !== 0) {
							bit--;
						}
						moduleBits.set(module, 1 << bit);
						i++;
					}

					const chunkModulesHash = new WeakMap();
					for (const chunk of chunks) {
						let hash = 0;
						for (const module of chunk.modulesIterable) {
							hash |= moduleBits.get(module);
						}
						chunkModulesHash.set(chunk, hash);
					}

					for (const chunkA of chunks) {
						const chunkAHash = chunkModulesHash.get(chunkA);
						const chunkAModulesCount = chunkA.getNumberOfModules();
						if (chunkAModulesCount === 0) continue;
						let bestModule = void 0;
						for (const module of chunkA.modulesIterable) {
							if (
								bestModule === void 0 ||
								bestModule.getNumberOfChunks() > module.getNumberOfChunks()
							)
								bestModule = module;
						}
						loopB: for (const chunkB of bestModule.chunksIterable) {
							if (chunkA === chunkB) continue;

							const chunkBModulesCount = chunkB.getNumberOfModules();

							if (chunkBModulesCount === 0) continue;

							if (chunkAModulesCount > chunkBModulesCount) continue;

							const chunkBHash = chunkModulesHash.get(chunkB);
							if ((chunkBHash & chunkAHash) !== chunkAHash) continue;

							for (const m of chunkA.modulesIterable) {
								if (!chunkB.containsModule(m)) continue loopB;
							}
							chunkB.ids.push(chunkA.id);
						}
					}
				}
			);
		});
	}
}
module.exports = FlagIncludedChunksPlugin;

},
// 289
function(module) {

module.exports = require("../vendor/micromatch");

},
// 290
function(module, exports, __webpack_require__) {

const Queue = __webpack_require__(128);

const addToSet = (a, b) => {
	for (const item of b) {
		a.add(item);
	}
};

class FlagDependencyExportsPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"FlagDependencyExportsPlugin",
			compilation => {
				compilation.hooks.finishModules.tap(
					"FlagDependencyExportsPlugin",
					modules => {
						const dependencies = new Map();

						const queue = new Queue();

						let module;
						let moduleWithExports;
						let moduleProvidedExports;
						let providedExportsAreTemporary;

						const processDependenciesBlock = depBlock => {
							for (const dep of depBlock.dependencies) {
								if (processDependency(dep)) return true;
							}
							for (const variable of depBlock.variables) {
								for (const dep of variable.dependencies) {
									if (processDependency(dep)) return true;
								}
							}
							for (const block of depBlock.blocks) {
								if (processDependenciesBlock(block)) return true;
							}
							return false;
						};

						const processDependency = dep => {
							const exportDesc = dep.getExports && dep.getExports();
							if (!exportDesc) return;
							moduleWithExports = true;
							const exports = exportDesc.exports;
							if (module.buildMeta.providedExports === true) {
								return true;
							}
							if (exports === true) {
								module.buildMeta.providedExports = true;
								return true;
							}
							if (Array.isArray(exports)) {
								addToSet(moduleProvidedExports, exports);
							}
							const exportDeps = exportDesc.dependencies;
							if (exportDeps) {
								providedExportsAreTemporary = true;
								for (const exportDependency of exportDeps) {
									const set = dependencies.get(exportDependency);
									if (set === void 0) {
										dependencies.set(exportDependency, new Set([module]));
									} else {
										set.add(module);
									}
								}
							}
							return false;
						};

						const notifyDependencies = () => {
							const deps = dependencies.get(module);
							if (deps !== void 0) {
								for (const dep of deps) {
									queue.enqueue(dep);
								}
							}
						};

						const notifyDependenciesIfDifferent = (set, array) => {
							const deps = dependencies.get(module);
							if (deps !== void 0) {
								if (set.size === array.length) {
									let i = 0;
									let different = false;
									for (const item of set) {
										if (item !== array[i++]) {
											different = true;
											break;
										}
									}
									if (!different) return;
								}
								for (const dep of deps) {
									queue.enqueue(dep);
								}
							}
						};

						for (const module of modules) {
							if (module.buildInfo.temporaryProvidedExports) {
								module.buildMeta.providedExports = null;
								queue.enqueue(module);
							} else if (!module.buildMeta.providedExports) {
								queue.enqueue(module);
							}
						}

						while (queue.length > 0) {
							module = queue.dequeue();

							if (module.buildMeta.providedExports !== true) {
								moduleWithExports =
									module.buildMeta && module.buildMeta.exportsType;
								moduleProvidedExports = new Set();
								providedExportsAreTemporary = false;
								processDependenciesBlock(module);
								module.buildInfo.temporaryProvidedExports = providedExportsAreTemporary;
								if (!moduleWithExports) {
									notifyDependencies();
									module.buildMeta.providedExports = true;
								} else if (module.buildMeta.providedExports === true) {
									notifyDependencies();
								} else if (!module.buildMeta.providedExports) {
									notifyDependencies();
									module.buildMeta.providedExports = Array.from(
										moduleProvidedExports
									);
								} else {
									notifyDependenciesIfDifferent(
										moduleProvidedExports,
										module.buildMeta.providedExports
									);
									module.buildMeta.providedExports = Array.from(
										moduleProvidedExports
									);
								}
							}
						}
					}
				);
				const providedExportsCache = new WeakMap();
				compilation.hooks.rebuildModule.tap(
					"FlagDependencyExportsPlugin",
					module => {
						providedExportsCache.set(module, module.buildMeta.providedExports);
					}
				);
				compilation.hooks.finishRebuildingModule.tap(
					"FlagDependencyExportsPlugin",
					module => {
						module.buildMeta.providedExports = providedExportsCache.get(module);
					}
				);
			}
		);
	}
}

module.exports = FlagDependencyExportsPlugin;

},
// 291
function(module, exports, __webpack_require__) {

const addToSet = (a, b) => {
	for (const item of b) {
		if (!a.includes(item)) a.push(item);
	}
	return a;
};

const isSubset = (biggerSet, subset) => {
	if (biggerSet === true) return true;
	if (subset === true) return false;
	return subset.every(item => biggerSet.indexOf(item) >= 0);
};

class FlagDependencyUsagePlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap("FlagDependencyUsagePlugin", compilation => {
			compilation.hooks.optimizeDependencies.tap(
				"FlagDependencyUsagePlugin",
				modules => {
					const processModule = (module, usedExports) => {
						module.used = true;
						if (module.usedExports === true) return;
						if (usedExports === true) {
							module.usedExports = true;
						} else if (Array.isArray(usedExports)) {
							const old = module.usedExports ? module.usedExports.length : -1;
							module.usedExports = addToSet(
								module.usedExports || [],
								usedExports
							);
							if (module.usedExports.length === old) {
								return;
							}
						} else if (Array.isArray(module.usedExports)) {
							return;
						} else {
							module.usedExports = false;
						}

						if (module.factoryMeta.sideEffectFree) {
							if (module.usedExports === false) return;
							if (
								Array.isArray(module.usedExports) &&
								module.usedExports.length === 0
							)
								return;
						}

						queue.push([module, module, module.usedExports]);
					};

					const processDependenciesBlock = (module, depBlock, usedExports) => {
						for (const dep of depBlock.dependencies) {
							processDependency(module, dep);
						}
						for (const variable of depBlock.variables) {
							for (const dep of variable.dependencies) {
								processDependency(module, dep);
							}
						}
						for (const block of depBlock.blocks) {
							queue.push([module, block, usedExports]);
						}
					};

					const processDependency = (module, dep) => {
						const reference = compilation.getDependencyReference(module, dep);
						if (!reference) return;
						const referenceModule = reference.module;
						const importedNames = reference.importedNames;
						const oldUsed = referenceModule.used;
						const oldUsedExports = referenceModule.usedExports;
						if (
							!oldUsed ||
							(importedNames &&
								(!oldUsedExports || !isSubset(oldUsedExports, importedNames)))
						) {
							processModule(referenceModule, importedNames);
						}
					};

					for (const module of modules) {
						if (!module.used) module.used = false;
					}

					const queue = [];
					for (const preparedEntrypoint of compilation._preparedEntrypoints) {
						if (preparedEntrypoint.module) {
							processModule(preparedEntrypoint.module, true);
						}
					}

					while (queue.length) {
						const queueItem = queue.pop();
						processDependenciesBlock(queueItem[0], queueItem[1], queueItem[2]);
					}
				}
			);
		});
	}
}
module.exports = FlagDependencyUsagePlugin;

},
// 292
function(module, exports, __webpack_require__) {

const Module = __webpack_require__(16);
const Template = __webpack_require__(2);
const Parser = __webpack_require__(83);
const eslintScope = __webpack_require__(293);
const { ConcatSource, ReplaceSource } = __webpack_require__(0);
const DependencyReference = __webpack_require__(14);
const HarmonyImportDependency = __webpack_require__(19);
const HarmonyImportSideEffectDependency = __webpack_require__(28);
const HarmonyImportSpecifierDependency = __webpack_require__(42);
const HarmonyExportSpecifierDependency = __webpack_require__(66);
const HarmonyExportExpressionDependency = __webpack_require__(65);
const HarmonyExportImportedSpecifierDependency = __webpack_require__(43);
const HarmonyCompatibilityDependency = __webpack_require__(41);
const createHash = __webpack_require__(15);

const joinIterableWithComma = iterable => {
	let str = "";
	let first = true;
	for (const item of iterable) {
		if (first) {
			first = false;
		} else {
			str += ", ";
		}
		str += item;
	}
	return str;
};

const ensureNsObjSource = (
	info,
	moduleToInfoMap,
	requestShortener,
	strictHarmonyModule
) => {
	if (!info.hasNamespaceObject) {
		info.hasNamespaceObject = true;
		const name = info.exportMap.get(true);
		const nsObj = [`var ${name} = {};`, `__webpack_require__.r(${name});`];
		for (const exportName of info.module.buildMeta.providedExports) {
			const finalName = getFinalName(
				info,
				exportName,
				moduleToInfoMap,
				requestShortener,
				false,
				strictHarmonyModule
			);
			nsObj.push(
				`__webpack_require__.d(${name}, ${JSON.stringify(
					exportName
				)}, function() { return ${finalName}; });`
			);
		}
		info.namespaceObjectSource = nsObj.join("\n") + "\n";
	}
};

const getExternalImport = (
	importedModule,
	info,
	exportName,
	asCall,
	strictHarmonyModule
) => {
	const used = importedModule.isUsed(exportName);
	if (!used) return "/* unused reexport */undefined";
	const comment =
		used !== exportName ? ` ${Template.toNormalComment(exportName)}` : "";
	switch (importedModule.buildMeta.exportsType) {
		case "named":
			if (exportName === "default") {
				return info.name;
			} else if (exportName === true) {
				info.interopNamespaceObjectUsed = true;
				return info.interopNamespaceObjectName;
			} else {
				break;
			}
		case "namespace":
			if (exportName === true) {
				return info.name;
			} else {
				break;
			}
		default:
			if (strictHarmonyModule) {
				if (exportName === "default") {
					return info.name;
				} else if (exportName === true) {
					info.interopNamespaceObjectUsed = true;
					return info.interopNamespaceObjectName;
				} else {
					return "/* non-default import from non-esm module */undefined";
				}
			} else {
				if (exportName === "default") {
					info.interopDefaultAccessUsed = true;
					return asCall
						? `${info.interopDefaultAccessName}()`
						: `${info.interopDefaultAccessName}.a`;
				} else if (exportName === true) {
					return info.name;
				} else {
					break;
				}
			}
	}
	const reference = `${info.name}[${JSON.stringify(used)}${comment}]`;
	if (asCall) return `Object(${reference})`;
	return reference;
};

const getFinalName = (
	info,
	exportName,
	moduleToInfoMap,
	requestShortener,
	asCall,
	strictHarmonyModule,
	alreadyVisited = new Set()
) => {
	switch (info.type) {
		case "concatenated":
			const directExport = info.exportMap.get(exportName);
			if (directExport) {
				if (exportName === true) {
					ensureNsObjSource(
						info,
						moduleToInfoMap,
						requestShortener,
						strictHarmonyModule
					);
				} else if (!info.module.isUsed(exportName)) {
					return "/* unused export */ undefined";
				}
				if (info.globalExports.has(directExport)) {
					return directExport;
				}
				const name = info.internalNames.get(directExport);
				if (!name) {
					throw new Error(
						`The export "${directExport}" in "${info.module.readableIdentifier(
							requestShortener
						)}" has no internal name`
					);
				}
				return name;
			}
			const reexport = info.reexportMap.get(exportName);
			if (reexport) {
				if (alreadyVisited.has(reexport)) {
					throw new Error(
						`Circular reexports ${Array.from(
							alreadyVisited,
							e =>
								`"${e.module.readableIdentifier(requestShortener)}".${
									e.exportName
								}`
						).join(
							" --> "
						)} -(circular)-> "${reexport.module.readableIdentifier(
							requestShortener
						)}".${reexport.exportName}`
					);
				}
				alreadyVisited.add(reexport);
				const refInfo = moduleToInfoMap.get(reexport.module);
				if (refInfo) {
					return getFinalName(
						refInfo,
						reexport.exportName,
						moduleToInfoMap,
						requestShortener,
						asCall,
						strictHarmonyModule,
						alreadyVisited
					);
				}
			}
			const problem =
				`Cannot get final name for export "${exportName}" in "${info.module.readableIdentifier(
					requestShortener
				)}" (known exports: ${Array.from(info.exportMap.keys())
					.filter(name => name !== true)
					.join(" ")}, known reexports: ${Array.from(info.reexportMap.keys()).join(" ")})`;
			return `${Template.toNormalComment(problem)} undefined`;

		case "external":
			return getExternalImport(
				info.module,
				info,
				exportName,
				asCall,
				strictHarmonyModule
			);
	}
};

const addScopeSymbols1 = (s, nameSet, scopeSet) => {
	let scope = s;
	while (scope) {
		if (scopeSet.has(scope)) break;
		scopeSet.add(scope);
		for (const variable of scope.variables) {
			nameSet.add(variable.name);
		}
		scope = scope.upper;
	}
};

const addScopeSymbols2 = (s, nameSet, scopeSet1, scopeSet2) => {
	let scope = s;
	while (scope) {
		if (scopeSet1.has(scope)) break;
		if (scopeSet2.has(scope)) break;
		scopeSet1.add(scope);
		for (const variable of scope.variables) {
			nameSet.add(variable.name);
		}
		scope = scope.upper;
	}
};

const getAllReferences = variable => {
	let set = variable.references;
	const identifiers = new Set(variable.identifiers);
	for (const scope of variable.scope.childScopes) {
		for (const innerVar of scope.variables) {
			if (innerVar.identifiers.some(id => identifiers.has(id))) {
				set = set.concat(innerVar.references);
				break;
			}
		}
	}
	return set;
};

const getPathInAst = (ast, node) => {
	if (ast === node) {
		return [];
	}

	const nr = node.range;

	const enterNode = n => {
		if (!n) return void 0;
		const r = n.range;
		if (r) {
			if (r[0] <= nr[0] && r[1] >= nr[1]) {
				const path = getPathInAst(n, node);
				if (path) {
					path.push(n);
					return path;
				}
			}
		}
		return void 0;
	};

	var i;
	if (Array.isArray(ast)) {
		for (i = 0; i < ast.length; i++) {
			const enterResult = enterNode(ast[i]);
			if (enterResult !== void 0) return enterResult;
		}
	} else if (ast && typeof ast == "object") {
		const keys = Object.keys(ast);
		for (i = 0; i < keys.length; i++) {
			const value = ast[keys[i]];
			if (Array.isArray(value)) {
				const pathResult = getPathInAst(value, node);
				if (pathResult !== void 0) return pathResult;
			} else if (value && typeof value == "object") {
				const enterResult = enterNode(value);
				if (enterResult !== void 0) return enterResult;
			}
		}
	}
};

const getHarmonyExportImportedSpecifierDependencyExports = dep => {
	const importModule = dep._module;
	if (!importModule) return [];
	if (dep._id) {
		return [
			{
				name: dep.name,
				id: dep._id,
				module: importModule
			}
		];
	}
	if (dep.name) {
		return [
			{
				name: dep.name,
				id: true,
				module: importModule
			}
		];
	}
	return importModule.buildMeta.providedExports
		.filter(exp => exp !== "default" && !dep.activeExports.has(exp))
		.map(exp => {
			return {
				name: exp,
				id: exp,
				module: importModule
			};
		});
};

class ConcatenatedModule extends Module {
	constructor(rootModule, modules, concatenationList) {
		super("javascript/esm", null);
		super.setChunks(rootModule._chunks);

		this.rootModule = rootModule;
		this.factoryMeta = rootModule.factoryMeta;

		this.index = rootModule.index;
		this.index2 = rootModule.index2;
		this.depth = rootModule.depth;

		this.used = rootModule.used;
		this.usedExports = rootModule.usedExports;

		this.buildInfo = {
			strict: true,
			cacheable: modules.every(m => m.buildInfo.cacheable),
			moduleArgument: rootModule.buildInfo.moduleArgument,
			exportsArgument: rootModule.buildInfo.exportsArgument,
			fileDependencies: new Set(),
			contextDependencies: new Set(),
			assets: void 0
		};
		this.built = modules.some(m => m.built);
		this.buildMeta = rootModule.buildMeta;

		this._numberOfConcatenatedModules = modules.length;

		const modulesSet = new Set(modules);
		this.reasons = rootModule.reasons.filter(
			reason =>
				!(reason.dependency instanceof HarmonyImportDependency) ||
				!modulesSet.has(reason.module)
		);

		this.dependencies = [];
		this.blocks = [];

		this.warnings = [];
		this.errors = [];
		this._orderedConcatenationList =
			concatenationList ||
			ConcatenatedModule.createConcatenationList(rootModule, modulesSet, null);
		for (const info of this._orderedConcatenationList) {
			if (info.type === "concatenated") {
				const m = info.module;

				for (const d of m.dependencies.filter(
					dep =>
						!(dep instanceof HarmonyImportDependency) ||
						!modulesSet.has(dep._module)
				)) {
					this.dependencies.push(d);
				}
				for (const d of m.blocks) {
					this.blocks.push(d);
				}
				if (m.buildInfo.fileDependencies) {
					for (const file of m.buildInfo.fileDependencies) {
						this.buildInfo.fileDependencies.add(file);
					}
				}
				if (m.buildInfo.contextDependencies) {
					for (const context of m.buildInfo.contextDependencies) {
						this.buildInfo.contextDependencies.add(context);
					}
				}
				for (const warning of m.warnings) {
					this.warnings.push(warning);
				}
				for (const error of m.errors) {
					this.errors.push(error);
				}

				if (m.buildInfo.assets) {
					if (this.buildInfo.assets === void 0) {
						this.buildInfo.assets = Object.create(null);
					}
					Object.assign(this.buildInfo.assets, m.buildInfo.assets);
				}
				if (m.buildInfo.assetsInfo) {
					if (this.buildInfo.assetsInfo === void 0) {
						this.buildInfo.assetsInfo = new Map();
					}
					for (const [key, value] of m.buildInfo.assetsInfo) {
						this.buildInfo.assetsInfo.set(key, value);
					}
				}
			}
		}
		this._identifier = this._createIdentifier();
	}

	get modules() {
		return this._orderedConcatenationList
			.filter(info => info.type === "concatenated")
			.map(info => info.module);
	}

	identifier() {
		return this._identifier;
	}

	readableIdentifier(requestShortener) {
		return (
			this.rootModule.readableIdentifier(requestShortener) +
			` + ${this._numberOfConcatenatedModules - 1} modules`
		);
	}

	libIdent(options) {
		return this.rootModule.libIdent(options);
	}

	nameForCondition() {
		return this.rootModule.nameForCondition();
	}

	build(options, compilation, resolver, fs, callback) {
		throw new Error("Cannot build this module. It should be already built.");
	}

	size() {
		return this._orderedConcatenationList.reduce((sum, info) => {
			switch (info.type) {
				case "concatenated":
					return sum + info.module.size();
				case "external":
					return sum + 5;
			}
			return sum;
		}, 0);
	}

	static createConcatenationList(rootModule, modulesSet, compilation) {
		const list = [];
		const set = new Set();

		const getConcatenatedImports = module => {
			const map = new WeakMap();
			const references = module.dependencies
				.filter(dep => dep instanceof HarmonyImportDependency)
				.map(dep => {
					const ref = compilation.getDependencyReference(module, dep);
					if (ref) map.set(ref, dep);
					return ref;
				})
				.filter(ref => ref);
			DependencyReference.sort(references);
			return references.map(ref => {
				const dep = map.get(ref);
				return () => compilation.getDependencyReference(module, dep).module;
			});
		};

		const enterModule = getModule => {
			const module = getModule();
			if (!module) return;
			if (set.has(module)) return;
			set.add(module);
			if (modulesSet.has(module)) {
				const imports = getConcatenatedImports(module);
				imports.forEach(enterModule);
				list.push({
					type: "concatenated",
					module
				});
			} else {
				list.push({
					type: "external",
					get module() {
						return getModule();
					}
				});
			}
		};

		enterModule(() => rootModule);

		return list;
	}

	_createIdentifier() {
		let orderedConcatenationListIdentifiers = "";
		for (let i = 0; i < this._orderedConcatenationList.length; i++) {
			if (this._orderedConcatenationList[i].type === "concatenated") {
				orderedConcatenationListIdentifiers += this._orderedConcatenationList[
					i
				].module.identifier();
				orderedConcatenationListIdentifiers += " ";
			}
		}
		const hash = createHash("md4");
		hash.update(orderedConcatenationListIdentifiers);
		return this.rootModule.identifier() + " " + hash.digest("hex");
	}

	source(dependencyTemplates, runtimeTemplate) {
		const requestShortener = runtimeTemplate.requestShortener;
		const modulesWithInfo = this._orderedConcatenationList.map((info, idx) => {
			switch (info.type) {
				case "concatenated": {
					const exportMap = new Map();
					const reexportMap = new Map();
					for (const dep of info.module.dependencies) {
						if (dep instanceof HarmonyExportSpecifierDependency) {
							if (!exportMap.has(dep.name)) {
								exportMap.set(dep.name, dep.id);
							}
						} else if (dep instanceof HarmonyExportExpressionDependency) {
							if (!exportMap.has("default")) {
								exportMap.set("default", "__WEBPACK_MODULE_DEFAULT_EXPORT__");
							}
						} else if (
							dep instanceof HarmonyExportImportedSpecifierDependency
						) {
							const exportName = dep.name;
							const importName = dep._id;
							const importedModule = dep._module;
							if (exportName && importName) {
								if (!reexportMap.has(exportName)) {
									reexportMap.set(exportName, {
										module: importedModule,
										exportName: importName,
										dependency: dep
									});
								}
							} else if (exportName) {
								if (!reexportMap.has(exportName)) {
									reexportMap.set(exportName, {
										module: importedModule,
										exportName: true,
										dependency: dep
									});
								}
							} else if (importedModule) {
								for (const name of importedModule.buildMeta.providedExports) {
									if (dep.activeExports.has(name) || name === "default") {
										continue;
									}
									if (!reexportMap.has(name)) {
										reexportMap.set(name, {
											module: importedModule,
											exportName: name,
											dependency: dep
										});
									}
								}
							}
						}
					}
					return {
						type: "concatenated",
						module: info.module,
						index: idx,
						ast: void 0,
						internalSource: void 0,
						source: void 0,
						globalScope: void 0,
						moduleScope: void 0,
						internalNames: new Map(),
						globalExports: new Set(),
						exportMap: exportMap,
						reexportMap: reexportMap,
						hasNamespaceObject: false,
						namespaceObjectSource: null
					};
				}
				case "external":
					return {
						type: "external",
						module: info.module,
						index: idx,
						name: void 0,
						interopNamespaceObjectUsed: false,
						interopNamespaceObjectName: void 0,
						interopDefaultAccessUsed: false,
						interopDefaultAccessName: void 0
					};
				default:
					throw new Error(`Unsupported concatenation entry type ${info.type}`);
			}
		});

		const moduleToInfoMap = new Map();
		for (const m of modulesWithInfo) {
			moduleToInfoMap.set(m.module, m);
		}

		const innerDependencyTemplates = new Map(dependencyTemplates);

		innerDependencyTemplates.set(
			HarmonyImportSpecifierDependency,
			new HarmonyImportSpecifierDependencyConcatenatedTemplate(
				dependencyTemplates.get(HarmonyImportSpecifierDependency),
				moduleToInfoMap
			)
		);
		innerDependencyTemplates.set(
			HarmonyImportSideEffectDependency,
			new HarmonyImportSideEffectDependencyConcatenatedTemplate(
				dependencyTemplates.get(HarmonyImportSideEffectDependency),
				moduleToInfoMap
			)
		);
		innerDependencyTemplates.set(
			HarmonyExportSpecifierDependency,
			new NullTemplate()
		);
		innerDependencyTemplates.set(
			HarmonyExportExpressionDependency,
			new HarmonyExportExpressionDependencyConcatenatedTemplate(
				dependencyTemplates.get(HarmonyExportExpressionDependency),
				this.rootModule
			)
		);
		innerDependencyTemplates.set(
			HarmonyExportImportedSpecifierDependency,
			new NullTemplate()
		);
		innerDependencyTemplates.set(
			HarmonyCompatibilityDependency,
			new NullTemplate()
		);

		innerDependencyTemplates.set(
			"hash",
			innerDependencyTemplates.get("hash") + this.identifier()
		);

		for (const info of modulesWithInfo) {
			if (info.type === "concatenated") {
				const m = info.module;
				const source = m.source(innerDependencyTemplates, runtimeTemplate);
				const code = source.source();
				let ast;
				try {
					ast = Parser.parse(code, {
						sourceType: "module"
					});
				} catch (err) {
					if (
						err.loc &&
						typeof err.loc == "object" &&
						typeof err.loc.line == "number"
					) {
						const lineNumber = err.loc.line;
						const lines = code.split("\n");
						err.message +=
							"\n| " +
							lines
								.slice(Math.max(0, lineNumber - 3), lineNumber + 2)
								.join("\n| ");
					}
					throw err;
				}
				const scopeManager = eslintScope.analyze(ast, {
					ecmaVersion: 6,
					sourceType: "module",
					optimistic: true,
					ignoreEval: true,
					impliedStrict: true
				});
				const globalScope = scopeManager.acquire(ast);
				const moduleScope = globalScope.childScopes[0];
				const resultSource = new ReplaceSource(source);
				info.ast = ast;
				info.internalSource = source;
				info.source = resultSource;
				info.globalScope = globalScope;
				info.moduleScope = moduleScope;
			}
		}

		const allUsedNames = new Set([
			"__WEBPACK_MODULE_DEFAULT_EXPORT__",

			"abstract",
			"arguments",
			"async",
			"await",
			"boolean",
			"break",
			"byte",
			"case",
			"catch",
			"char",
			"class",
			"const",
			"continue",
			"debugger",
			"default",
			"delete",
			"do",
			"double",
			"else",
			"enum",
			"eval",
			"export",
			"extends",
			"false",
			"final",
			"finally",
			"float",
			"for",
			"function",
			"goto",
			"if",
			"implements",
			"import",
			"in",
			"instanceof",
			"int",
			"interface",
			"let",
			"long",
			"native",
			"new",
			"null",
			"package",
			"private",
			"protected",
			"public",
			"return",
			"short",
			"static",
			"super",
			"switch",
			"synchronized",
			"this",
			"throw",
			"throws",
			"transient",
			"true",
			"try",
			"typeof",
			"var",
			"void",
			"volatile",
			"while",
			"with",
			"yield",

			"module",
			"__dirname",
			"__filename",
			"exports",

			"Array",
			"Date",
			"eval",
			"function",
			"hasOwnProperty",
			"Infinity",
			"isFinite",
			"isNaN",
			"isPrototypeOf",
			"length",
			"Math",
			"NaN",
			"name",
			"Number",
			"Object",
			"prototype",
			"String",
			"toString",
			"undefined",
			"valueOf",

			"alert",
			"all",
			"anchor",
			"anchors",
			"area",
			"assign",
			"blur",
			"button",
			"checkbox",
			"clearInterval",
			"clearTimeout",
			"clientInformation",
			"close",
			"closed",
			"confirm",
			"constructor",
			"crypto",
			"decodeURI",
			"decodeURIComponent",
			"defaultStatus",
			"document",
			"element",
			"elements",
			"embed",
			"embeds",
			"encodeURI",
			"encodeURIComponent",
			"escape",
			"event",
			"fileUpload",
			"focus",
			"form",
			"forms",
			"frame",
			"innerHeight",
			"innerWidth",
			"layer",
			"layers",
			"link",
			"location",
			"mimeTypes",
			"navigate",
			"navigator",
			"frames",
			"frameRate",
			"hidden",
			"history",
			"image",
			"images",
			"offscreenBuffering",
			"open",
			"opener",
			"option",
			"outerHeight",
			"outerWidth",
			"packages",
			"pageXOffset",
			"pageYOffset",
			"parent",
			"parseFloat",
			"parseInt",
			"password",
			"pkcs11",
			"plugin",
			"prompt",
			"propertyIsEnum",
			"radio",
			"reset",
			"screenX",
			"screenY",
			"scroll",
			"secure",
			"select",
			"self",
			"setInterval",
			"setTimeout",
			"status",
			"submit",
			"taint",
			"text",
			"textarea",
			"top",
			"unescape",
			"untaint",
			"window",

			"onblur",
			"onclick",
			"onerror",
			"onfocus",
			"onkeydown",
			"onkeypress",
			"onkeyup",
			"onmouseover",
			"onload",
			"onmouseup",
			"onmousedown",
			"onsubmit"
		]);

		const alreadyCheckedScopes = new Set();

		for (const info of modulesWithInfo) {
			const superClassExpressions = [];

			if (info.moduleScope) {
				alreadyCheckedScopes.add(info.moduleScope);

				for (const childScope of info.moduleScope.childScopes) {
					if (childScope.type !== "class") continue;
					if (!childScope.block.superClass) continue;
					superClassExpressions.push({
						range: childScope.block.superClass.range,
						variables: childScope.variables
					});
				}
			}

			if (info.globalScope) {
				for (const reference of info.globalScope.through) {
					const name = reference.identifier.name;
					if (
						/^__WEBPACK_MODULE_REFERENCE__\d+_([\da-f]+|ns)(_call)?(_strict)?__$/.test(
							name
						)
					) {
						for (const expr of superClassExpressions) {
							if (
								expr.range[0] <= reference.identifier.range[0] &&
								expr.range[1] >= reference.identifier.range[1]
							) {
								for (const variable of expr.variables) {
									allUsedNames.add(variable.name);
								}
							}
						}
						addScopeSymbols1(
							reference.from,
							allUsedNames,
							alreadyCheckedScopes
						);
					} else {
						allUsedNames.add(name);
					}
				}
			}

			if (info.type === "concatenated") {
				const variables = new Set();
				for (const variable of info.moduleScope.variables) {
					variables.add(variable.name);
				}
				for (const [, variable] of info.exportMap) {
					if (!variables.has(variable)) {
						info.globalExports.add(variable);
					}
				}
			}
		}

		for (const info of modulesWithInfo) {
			switch (info.type) {
				case "concatenated": {
					const namespaceObjectName = this.findNewName(
						"namespaceObject",
						allUsedNames,
						null,
						info.module.readableIdentifier(requestShortener)
					);
					allUsedNames.add(namespaceObjectName);
					info.internalNames.set(namespaceObjectName, namespaceObjectName);
					info.exportMap.set(true, namespaceObjectName);
					for (const variable of info.moduleScope.variables) {
						const name = variable.name;
						if (allUsedNames.has(name)) {
							const references = getAllReferences(variable);
							const symbolsInReferences = new Set();
							const alreadyCheckedInnerScopes = new Set();
							for (const ref of references) {
								addScopeSymbols2(
									ref.from,
									symbolsInReferences,
									alreadyCheckedInnerScopes,
									alreadyCheckedScopes
								);
							}
							const newName = this.findNewName(
								name,
								allUsedNames,
								symbolsInReferences,
								info.module.readableIdentifier(requestShortener)
							);
							allUsedNames.add(newName);
							info.internalNames.set(name, newName);
							const source = info.source;
							const allIdentifiers = new Set(
								references.map(r => r.identifier).concat(variable.identifiers)
							);
							for (const identifier of allIdentifiers) {
								const r = identifier.range;
								const path = getPathInAst(info.ast, identifier);
								if (
									path &&
									path.length > 1 &&
									path[1].type === "Property" &&
									path[1].shorthand
								) {
									source.insert(r[1], `: ${newName}`);
								} else {
									source.replace(r[0], r[1] - 1, newName);
								}
							}
						} else {
							allUsedNames.add(name);
							info.internalNames.set(name, name);
						}
					}
					break;
				}
				case "external": {
					const externalName = this.findNewName(
						"",
						allUsedNames,
						null,
						info.module.readableIdentifier(requestShortener)
					);
					allUsedNames.add(externalName);
					info.name = externalName;
					if (
						info.module.buildMeta.exportsType === "named" ||
						!info.module.buildMeta.exportsType
					) {
						const externalNameInterop = this.findNewName(
							"namespaceObject",
							allUsedNames,
							null,
							info.module.readableIdentifier(requestShortener)
						);
						allUsedNames.add(externalNameInterop);
						info.interopNamespaceObjectName = externalNameInterop;
					}
					if (!info.module.buildMeta.exportsType) {
						const externalNameInterop = this.findNewName(
							"default",
							allUsedNames,
							null,
							info.module.readableIdentifier(requestShortener)
						);
						allUsedNames.add(externalNameInterop);
						info.interopDefaultAccessName = externalNameInterop;
					}
					break;
				}
			}
		}

		for (const info of modulesWithInfo) {
			if (info.type === "concatenated") {
				for (const reference of info.globalScope.through) {
					const name = reference.identifier.name;
					const match = /^__WEBPACK_MODULE_REFERENCE__(\d+)_([\da-f]+|ns)(_call)?(_strict)?__$/.exec(
						name
					);
					if (match) {
						const referencedModule = modulesWithInfo[+match[1]];
						let exportName;
						if (match[2] === "ns") {
							exportName = true;
						} else {
							const exportData = match[2];
							exportName = Buffer.from(exportData, "hex").toString("utf-8");
						}
						const asCall = !!match[3];
						const strictHarmonyModule = !!match[4];
						const finalName = getFinalName(
							referencedModule,
							exportName,
							moduleToInfoMap,
							requestShortener,
							asCall,
							strictHarmonyModule
						);
						const r = reference.identifier.range;
						const source = info.source;
						source.replace(r[0], r[1] - 1, finalName);
					}
				}
			}
		}

		const exportsMap = new Map();

		const unusedExports = new Set();

		for (const dep of this.rootModule.dependencies) {
			if (dep instanceof HarmonyExportSpecifierDependency) {
				const used = this.rootModule.isUsed(dep.name);
				if (used) {
					const info = moduleToInfoMap.get(this.rootModule);
					if (!exportsMap.has(used)) {
						exportsMap.set(
							used,
							() => `/* binding */ ${info.internalNames.get(dep.id)}`
						);
					}
				} else {
					unusedExports.add(dep.name || "namespace");
				}
			} else if (dep instanceof HarmonyExportImportedSpecifierDependency) {
				const exportDefs = getHarmonyExportImportedSpecifierDependencyExports(
					dep
				);
				for (const def of exportDefs) {
					const info = moduleToInfoMap.get(def.module);
					const used = dep.originModule.isUsed(def.name);
					if (used) {
						if (!exportsMap.has(used)) {
							exportsMap.set(used, requestShortener => {
								const finalName = getFinalName(
									info,
									def.id,
									moduleToInfoMap,
									requestShortener,
									false,
									this.rootModule.buildMeta.strictHarmonyModule
								);
								return `/* reexport */ ${finalName}`;
							});
						}
					} else {
						unusedExports.add(def.name);
					}
				}
			}
		}

		const result = new ConcatSource();

		const usedExports = this.rootModule.usedExports;
		if (usedExports === true || usedExports === null) {
			result.add(`// ESM COMPAT FLAG\n`);
			result.add(
				runtimeTemplate.defineEsModuleFlagStatement({
					exportsArgument: this.exportsArgument
				})
			);
		}

		if (exportsMap.size > 0) {
			result.add(`\n// EXPORTS\n`);
			for (const [key, value] of exportsMap) {
				result.add(
					`__webpack_require__.d(${this.exportsArgument}, ${JSON.stringify(
						key
					)}, function() { return ${value(requestShortener)}; });\n`
				);
			}
		}

		if (unusedExports.size > 0) {
			result.add(
				`\n// UNUSED EXPORTS: ${joinIterableWithComma(unusedExports)}\n`
			);
		}

		for (const info of modulesWithInfo) {
			if (info.namespaceObjectSource) {
				result.add(
					`\n// NAMESPACE OBJECT: ${info.module.readableIdentifier(
						requestShortener
					)}\n`
				);
				result.add(info.namespaceObjectSource);
			}
		}

		for (const info of modulesWithInfo) {
			switch (info.type) {
				case "concatenated":
					result.add(
						`\n// CONCATENATED MODULE: ${info.module.readableIdentifier(
							requestShortener
						)}\n`
					);
					result.add(info.source);
					break;
				case "external":
					result.add(
						`\n// EXTERNAL MODULE: ${info.module.readableIdentifier(
							requestShortener
						)}\n`
					);
					result.add(
						`var ${info.name} = __webpack_require__(${JSON.stringify(
							info.module.id
						)});\n`
					);
					if (info.interopNamespaceObjectUsed) {
						if (info.module.buildMeta.exportsType === "named") {
							result.add(
								`var ${info.interopNamespaceObjectName} = /*#__PURE__*/__webpack_require__.t(${info.name}, 2);\n`
							);
						} else if (!info.module.buildMeta.exportsType) {
							result.add(
								`var ${info.interopNamespaceObjectName} = /*#__PURE__*/__webpack_require__.t(${info.name});\n`
							);
						}
					}
					if (info.interopDefaultAccessUsed) {
						result.add(
							`var ${info.interopDefaultAccessName} = /*#__PURE__*/__webpack_require__.n(${info.name});\n`
						);
					}
					break;
				default:
					throw new Error(`Unsupported concatenation entry type ${info.type}`);
			}
		}

		return result;
	}

	findNewName(oldName, usedNamed1, usedNamed2, extraInfo) {
		let name = oldName;

		if (name === "__WEBPACK_MODULE_DEFAULT_EXPORT__") name = "";

		extraInfo = extraInfo.replace(
			/\.+\/|(\/index)?\.([a-zA-Z0-9]{1,4})($|\s|\?)|\s*\+\s*\d+\s*modules/g,
			""
		);

		const splittedInfo = extraInfo.split("/");
		while (splittedInfo.length) {
			name = splittedInfo.pop() + (name ? "_" + name : "");
			const nameIdent = Template.toIdentifier(name);
			if (
				!usedNamed1.has(nameIdent) &&
				(!usedNamed2 || !usedNamed2.has(nameIdent))
			)
				return nameIdent;
		}

		let i = 0;
		let nameWithNumber = Template.toIdentifier(`${name}_${i}`);
		while (
			usedNamed1.has(nameWithNumber) ||
			(usedNamed2 && usedNamed2.has(nameWithNumber))
		) {
			i++;
			nameWithNumber = Template.toIdentifier(`${name}_${i}`);
		}
		return nameWithNumber;
	}

	updateHash(hash) {
		for (const info of this._orderedConcatenationList) {
			switch (info.type) {
				case "concatenated":
					info.module.updateHash(hash);
					break;
				case "external":
					hash.update(`${info.module.id}`);
					break;
			}
		}
		super.updateHash(hash);
	}
}

class HarmonyImportSpecifierDependencyConcatenatedTemplate {
	constructor(originalTemplate, modulesMap) {
		this.originalTemplate = originalTemplate;
		this.modulesMap = modulesMap;
	}

	getHarmonyInitOrder(dep) {
		const module = dep._module;
		const info = this.modulesMap.get(module);
		if (!info) {
			return this.originalTemplate.getHarmonyInitOrder(dep);
		}
		return NaN;
	}

	harmonyInit(dep, source, runtimeTemplate, dependencyTemplates) {
		const module = dep._module;
		const info = this.modulesMap.get(module);
		if (!info) {
			this.originalTemplate.harmonyInit(
				dep,
				source,
				runtimeTemplate,
				dependencyTemplates
			);
			return;
		}
	}

	apply(dep, source, runtime, dependencyTemplates) {
		const module = dep._module;
		const info = this.modulesMap.get(module);
		if (!info) {
			this.originalTemplate.apply(dep, source, runtime, dependencyTemplates);
			return;
		}
		let content;
		const callFlag = dep.call ? "_call" : "";
		const strictFlag = dep.originModule.buildMeta.strictHarmonyModule
			? "_strict"
			: "";
		if (dep._id === null) {
			content = `__WEBPACK_MODULE_REFERENCE__${info.index}_ns${strictFlag}__`;
		} else if (dep.namespaceObjectAsContext) {
			content = `__WEBPACK_MODULE_REFERENCE__${
				info.index
			}_ns${strictFlag}__[${JSON.stringify(dep._id)}]`;
		} else {
			const exportData = Buffer.from(dep._id, "utf-8").toString("hex");
			content = `__WEBPACK_MODULE_REFERENCE__${info.index}_${exportData}${callFlag}${strictFlag}__`;
		}
		if (dep.shorthand) {
			content = dep.name + ": " + content;
		}
		source.replace(dep.range[0], dep.range[1] - 1, content);
	}
}

class HarmonyImportSideEffectDependencyConcatenatedTemplate {
	constructor(originalTemplate, modulesMap) {
		this.originalTemplate = originalTemplate;
		this.modulesMap = modulesMap;
	}

	getHarmonyInitOrder(dep) {
		const module = dep._module;
		const info = this.modulesMap.get(module);
		if (!info) {
			return this.originalTemplate.getHarmonyInitOrder(dep);
		}
		return NaN;
	}

	harmonyInit(dep, source, runtime, dependencyTemplates) {
		const module = dep._module;
		const info = this.modulesMap.get(module);
		if (!info) {
			this.originalTemplate.harmonyInit(
				dep,
				source,
				runtime,
				dependencyTemplates
			);
			return;
		}
	}

	apply(dep, source, runtime, dependencyTemplates) {
		const module = dep._module;
		const info = this.modulesMap.get(module);
		if (!info) {
			this.originalTemplate.apply(dep, source, runtime, dependencyTemplates);
			return;
		}
	}
}

class HarmonyExportExpressionDependencyConcatenatedTemplate {
	constructor(originalTemplate, rootModule) {
		this.originalTemplate = originalTemplate;
		this.rootModule = rootModule;
	}

	apply(dep, source, runtime, dependencyTemplates) {
		let content =
			"/* harmony default export */ var __WEBPACK_MODULE_DEFAULT_EXPORT__ = ";
		if (dep.originModule === this.rootModule) {
			const used = dep.originModule.isUsed("default");
			const exportsName = dep.originModule.exportsArgument;
			if (used) content += `${exportsName}[${JSON.stringify(used)}] = `;
		}

		if (dep.range) {
			source.replace(
				dep.rangeStatement[0],
				dep.range[0] - 1,
				content + "(" + dep.prefix
			);
			source.replace(dep.range[1], dep.rangeStatement[1] - 1, ");");
			return;
		}

		source.replace(
			dep.rangeStatement[0],
			dep.rangeStatement[1] - 1,
			content + dep.prefix
		);
	}
}

class NullTemplate {
	apply() {}
}

module.exports = ConcatenatedModule;

},
// 293
function(module, exports, __webpack_require__) {

const assert = __webpack_require__(48),

	ScopeManager = __webpack_require__(294),
	Referencer = __webpack_require__(296),
	Reference = __webpack_require__(70),
	Variable = __webpack_require__(50),
	Scope = __webpack_require__(133).Scope,
	version = __webpack_require__(299).version;

function defaultOptions() {
	return {
		optimistic: false,
		directive: false,
		nodejsScope: false,
		impliedStrict: false,
		sourceType: "script",
		ecmaVersion: 5,
		childVisitorKeys: null,
		fallback: "iteration"
	};
}

function updateDeeply(target, override) {
	function isHashObject(value) {
		return typeof value == "object" && value instanceof Object &&
			!(value instanceof Array || value instanceof RegExp);
	}

	for (const key in override)
		if (override.hasOwnProperty(key)) {
			const val = override[key];

			isHashObject(val)
				? isHashObject(target[key])
					? updateDeeply(target[key], val)
					: (target[key] = updateDeeply({}, val))
				: (target[key] = val);
		}

	return target;
}

function analyze(tree, providedOptions) {
	const options = updateDeeply(defaultOptions(), providedOptions),
		scopeManager = new ScopeManager(options);

	new Referencer(options, scopeManager).visit(tree);

	assert(scopeManager.__currentScope === null, "currentScope should be null.");

	return scopeManager;
}

module.exports = { version, Reference, Variable, Scope, ScopeManager, analyze };

},
// 294
function(module, exports, __webpack_require__) {

const Scope = __webpack_require__(133),
	assert = __webpack_require__(48),

	GlobalScope = Scope.GlobalScope,
	CatchScope = Scope.CatchScope,
	WithScope = Scope.WithScope,
	ModuleScope = Scope.ModuleScope,
	ClassScope = Scope.ClassScope,
	SwitchScope = Scope.SwitchScope,
	FunctionScope = Scope.FunctionScope,
	ForScope = Scope.ForScope,
	FunctionExpressionNameScope = Scope.FunctionExpressionNameScope,
	BlockScope = Scope.BlockScope;

class ScopeManager {
	constructor(options) {
		this.scopes = [];
		this.globalScope = null;
		this.__nodeToScope = new WeakMap();
		this.__currentScope = null;
		this.__options = options;
		this.__declaredVariables = new WeakMap();
	}

	__useDirective() {
		return this.__options.directive;
	}

	__isOptimistic() {
		return this.__options.optimistic;
	}

	__ignoreEval() {
		return this.__options.ignoreEval;
	}

	__isNodejsScope() {
		return this.__options.nodejsScope;
	}

	isModule() {
		return this.__options.sourceType === "module";
	}

	isImpliedStrict() {
		return this.__options.impliedStrict;
	}

	isStrictModeSupported() {
		return this.__options.ecmaVersion >= 5;
	}

	__get(node) {
		return this.__nodeToScope.get(node);
	}

	getDeclaredVariables(node) {
		return this.__declaredVariables.get(node) || [];
	}

	acquire(node, inner) {
		function predicate(testScope) {
			return testScope.type !== "function" || !testScope.functionExpressionScope;
		}

		const scopes = this.__get(node);

		if (!scopes || scopes.length === 0) return null;

		if (scopes.length === 1) return scopes[0];

		if (inner)
			for (let i = scopes.length - 1; i >= 0; --i) {
				const scope = scopes[i];

				if (predicate(scope)) return scope;
			}
		else
			for (let i = 0, iz = scopes.length; i < iz; ++i) {
				const scope = scopes[i];

				if (predicate(scope)) return scope;
			}

		return null;
	}

	acquireAll(node) {
		return this.__get(node);
	}

	release(node, inner) {
		const scopes = this.__get(node);

		if (scopes && scopes.length) {
			const scope = scopes[0].upper;

			return scope ? this.acquire(scope.block, inner) : null;
		}
		return null;
	}

	attach() {}

	detach() {}

	__nestScope(scope) {
		if (scope instanceof GlobalScope) {
			assert(this.__currentScope === null);
			this.globalScope = scope;
		}
		this.__currentScope = scope;
		return scope;
	}

	__nestGlobalScope(node) {
		return this.__nestScope(new GlobalScope(this, node));
	}

	__nestBlockScope(node) {
		return this.__nestScope(new BlockScope(this, this.__currentScope, node));
	}

	__nestFunctionScope(node, isMethodDefinition) {
		return this.__nestScope(new FunctionScope(this, this.__currentScope, node, isMethodDefinition));
	}

	__nestForScope(node) {
		return this.__nestScope(new ForScope(this, this.__currentScope, node));
	}

	__nestCatchScope(node) {
		return this.__nestScope(new CatchScope(this, this.__currentScope, node));
	}

	__nestWithScope(node) {
		return this.__nestScope(new WithScope(this, this.__currentScope, node));
	}

	__nestClassScope(node) {
		return this.__nestScope(new ClassScope(this, this.__currentScope, node));
	}

	__nestSwitchScope(node) {
		return this.__nestScope(new SwitchScope(this, this.__currentScope, node));
	}

	__nestModuleScope(node) {
		return this.__nestScope(new ModuleScope(this, this.__currentScope, node));
	}

	__nestFunctionExpressionNameScope(node) {
		return this.__nestScope(new FunctionExpressionNameScope(this, this.__currentScope, node));
	}

	__isES6() {
		return this.__options.ecmaVersion >= 6;
	}
}

module.exports = ScopeManager;

},
// 295
function(module) {

module.exports = {
	name: "estraverse",
	description: "ECMAScript JS AST traversal functions",
	version: "4.3.0"
};

},
// 296
function(module, exports, __webpack_require__) {

const Syntax = __webpack_require__(49).Syntax,
	esrecurse = __webpack_require__(135),
	Reference = __webpack_require__(70),
	Variable = __webpack_require__(50),
	PatternVisitor = __webpack_require__(298),
	definition = __webpack_require__(134),
	assert = __webpack_require__(48),

	ParameterDefinition = definition.ParameterDefinition,
	Definition = definition.Definition;

function traverseIdentifierInPattern(options, rootPattern, referencer, callback) {
	const visitor = new PatternVisitor(options, rootPattern, callback);

	visitor.visit(rootPattern);

	referencer === null || referencer === void 0 ||
		visitor.rightHandNodes.forEach(referencer.visit, referencer);
}

class Importer extends esrecurse.Visitor {
	constructor(declaration, referencer) {
		super(null, referencer.options);
		this.declaration = declaration;
		this.referencer = referencer;
	}

	visitImport(id, specifier) {
		this.referencer.visitPattern(id, pattern => {
			this.referencer.currentScope().__define(
				pattern,
				new Definition(Variable.ImportBinding, pattern, specifier, this.declaration, null, null)
			);
		});
	}

	ImportNamespaceSpecifier(node) {
		const local = node.local || node.id;

		local && this.visitImport(local, node);
	}

	ImportDefaultSpecifier(node) {
		const local = node.local || node.id;

		this.visitImport(local, node);
	}

	ImportSpecifier(node) {
		const local = node.local || node.id;

		node.name ? this.visitImport(node.name, node) : this.visitImport(local, node);
	}
}

class Referencer extends esrecurse.Visitor {
	constructor(options, scopeManager) {
		super(null, options);
		this.options = options;
		this.scopeManager = scopeManager;
		this.parent = null;
		this.isInnerMethodDefinition = false;
	}

	currentScope() {
		return this.scopeManager.__currentScope;
	}

	close(node) {
		while (this.currentScope() && node === this.currentScope().block)
			this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);
	}

	pushInnerMethodDefinition(isInnerMethodDefinition) {
		const previous = this.isInnerMethodDefinition;

		this.isInnerMethodDefinition = isInnerMethodDefinition;
		return previous;
	}

	popInnerMethodDefinition(isInnerMethodDefinition) {
		this.isInnerMethodDefinition = isInnerMethodDefinition;
	}

	referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {
		const scope = this.currentScope();

		assignments.forEach(assignment => {
			scope.__referencing(
				pattern,
				Reference.WRITE,
				assignment.right,
				maybeImplicitGlobal,
				pattern !== assignment.left,
				init
			);
		});
	}

	visitPattern(node, options, callback) {
		if (typeof options == "function") {
			callback = options;
			options = { processRightHandNodes: false };
		}
		traverseIdentifierInPattern(
			this.options,
			node,
			options.processRightHandNodes ? this : null,
			callback
		);
	}

	visitFunction(node) {
		let i, iz;

		node.type !== Syntax.FunctionDeclaration ||
			this.currentScope().__define(
				node.id,
				new Definition(Variable.FunctionName, node.id, node, null, null, null)
			);

		node.type === Syntax.FunctionExpression && node.id &&
			this.scopeManager.__nestFunctionExpressionNameScope(node);

		this.scopeManager.__nestFunctionScope(node, this.isInnerMethodDefinition);

		const that = this;

		function visitPatternCallback(pattern, info) {
			that.currentScope().__define(pattern, new ParameterDefinition(pattern, node, i, info.rest));

			that.referencingDefaultValue(pattern, info.assignments, null, true);
		}

		for (i = 0, iz = node.params.length; i < iz; ++i)
			this.visitPattern(node.params[i], { processRightHandNodes: true }, visitPatternCallback);

		node.rest &&
			this.visitPattern({ type: "RestElement", argument: node.rest }, pattern => {
				this.currentScope().__define(
					pattern,
					new ParameterDefinition(pattern, node, node.params.length, true)
				);
			});

		if (node.body)
			node.body.type === Syntax.BlockStatement
				? this.visitChildren(node.body)
				: this.visit(node.body);

		this.close(node);
	}

	visitClass(node) {
		node.type !== Syntax.ClassDeclaration ||
			this.currentScope().__define(
				node.id,
				new Definition(Variable.ClassName, node.id, node, null, null, null)
			);

		this.visit(node.superClass);

		this.scopeManager.__nestClassScope(node);

		node.id &&
			this.currentScope().__define(node.id, new Definition(Variable.ClassName, node.id, node));

		this.visit(node.body);

		this.close(node);
	}

	visitProperty(node) {
		let previous;

		node.computed && this.visit(node.key);

		const isMethodDefinition = node.type === Syntax.MethodDefinition;

		if (isMethodDefinition) previous = this.pushInnerMethodDefinition(true);

		this.visit(node.value);
		isMethodDefinition && this.popInnerMethodDefinition(previous);
	}

	visitForIn(node) {
		node.left.type !== Syntax.VariableDeclaration || node.left.kind === "var" ||
			this.scopeManager.__nestForScope(node);

		if (node.left.type === Syntax.VariableDeclaration) {
			this.visit(node.left);
			this.visitPattern(node.left.declarations[0].id, pattern => {
				this.currentScope().__referencing(pattern, Reference.WRITE, node.right, null, true, true);
			});
		} else
			this.visitPattern(node.left, { processRightHandNodes: true }, (pattern, info) => {
				let maybeImplicitGlobal = this.currentScope().isStrict ? null : { pattern, node };

				this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
				this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, true, false);
			});

		this.visit(node.right);
		this.visit(node.body);

		this.close(node);
	}

	visitVariableDeclaration(variableTargetScope, type, node, index) {
		const decl = node.declarations[index],
			init = decl.init;

		this.visitPattern(decl.id, { processRightHandNodes: true }, (pattern, info) => {
			variableTargetScope.__define(
				pattern,
				new Definition(type, pattern, decl, node, index, node.kind)
			);

			this.referencingDefaultValue(pattern, info.assignments, null, true);
			init &&
				this.currentScope().__referencing(pattern, Reference.WRITE, init, null, !info.topLevel, true);
		});
	}

	AssignmentExpression(node) {
		if (PatternVisitor.isPattern(node.left))
			if (node.operator === "=")
				this.visitPattern(node.left, { processRightHandNodes: true }, (pattern, info) => {
					let maybeImplicitGlobal = this.currentScope().isStrict ? null : { pattern, node };

					this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
					this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, !info.topLevel, false);
				});
			else this.currentScope().__referencing(node.left, Reference.RW, node.right);
		else this.visit(node.left);

		this.visit(node.right);
	}

	CatchClause(node) {
		this.scopeManager.__nestCatchScope(node);

		this.visitPattern(node.param, { processRightHandNodes: true }, (pattern, info) => {
			this.currentScope().__define(
				pattern,
				new Definition(Variable.CatchClause, node.param, node, null, null, null)
			);
			this.referencingDefaultValue(pattern, info.assignments, null, true);
		});
		this.visit(node.body);

		this.close(node);
	}

	Program(node) {
		this.scopeManager.__nestGlobalScope(node);

		if (this.scopeManager.__isNodejsScope()) {
			this.currentScope().isStrict = false;
			this.scopeManager.__nestFunctionScope(node, false);
		}

		this.scopeManager.__isES6() && this.scopeManager.isModule() &&
			this.scopeManager.__nestModuleScope(node);

		if (this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict())
			this.currentScope().isStrict = true;

		this.visitChildren(node);
		this.close(node);
	}

	Identifier(node) {
		this.currentScope().__referencing(node);
	}

	UpdateExpression(node) {
		PatternVisitor.isPattern(node.argument)
			? this.currentScope().__referencing(node.argument, Reference.RW, null)
			: this.visitChildren(node);
	}

	MemberExpression(node) {
		this.visit(node.object);
		node.computed && this.visit(node.property);
	}

	Property(node) {
		this.visitProperty(node);
	}

	MethodDefinition(node) {
		this.visitProperty(node);
	}

	BreakStatement() {}

	ContinueStatement() {}

	LabeledStatement(node) {
		this.visit(node.body);
	}

	ForStatement(node) {
		node.init && node.init.type === Syntax.VariableDeclaration && node.init.kind !== "var" &&
			this.scopeManager.__nestForScope(node);

		this.visitChildren(node);

		this.close(node);
	}

	ClassExpression(node) {
		this.visitClass(node);
	}

	ClassDeclaration(node) {
		this.visitClass(node);
	}

	CallExpression(node) {
		this.scopeManager.__ignoreEval() || node.callee.type !== Syntax.Identifier || node.callee.name !== "eval" ||
			this.currentScope().variableScope.__detectEval();

		this.visitChildren(node);
	}

	BlockStatement(node) {
		this.scopeManager.__isES6() && this.scopeManager.__nestBlockScope(node);

		this.visitChildren(node);

		this.close(node);
	}

	ThisExpression() {
		this.currentScope().variableScope.__detectThis();
	}

	WithStatement(node) {
		this.visit(node.object);

		this.scopeManager.__nestWithScope(node);

		this.visit(node.body);

		this.close(node);
	}

	VariableDeclaration(node) {
		const variableTargetScope = node.kind === "var" ? this.currentScope().variableScope : this.currentScope();

		for (let i = 0, iz = node.declarations.length; i < iz; ++i) {
			const decl = node.declarations[i];

			this.visitVariableDeclaration(variableTargetScope, Variable.Variable, node, i);
			decl.init && this.visit(decl.init);
		}
	}

	SwitchStatement(node) {
		this.visit(node.discriminant);

		this.scopeManager.__isES6() && this.scopeManager.__nestSwitchScope(node);

		for (let i = 0, iz = node.cases.length; i < iz; ++i) this.visit(node.cases[i]);

		this.close(node);
	}

	FunctionDeclaration(node) {
		this.visitFunction(node);
	}

	FunctionExpression(node) {
		this.visitFunction(node);
	}

	ForOfStatement(node) {
		this.visitForIn(node);
	}

	ForInStatement(node) {
		this.visitForIn(node);
	}

	ArrowFunctionExpression(node) {
		this.visitFunction(node);
	}

	ImportDeclaration(node) {
		assert(
			this.scopeManager.__isES6() && this.scopeManager.isModule(),
			"ImportDeclaration should appear when the mode is ES6 and in the module context."
		);

		new Importer(node, this).visit(node);
	}

	visitExportDeclaration(node) {
		node.source || (node.declaration ? this.visit(node.declaration) : this.visitChildren(node));
	}

	ExportDeclaration(node) {
		this.visitExportDeclaration(node);
	}

	ExportNamedDeclaration(node) {
		this.visitExportDeclaration(node);
	}

	ExportSpecifier(node) {
		const local = node.id || node.local;

		this.visit(local);
	}

	MetaProperty() {}
}

module.exports = Referencer;

},
// 297
function(module) {

module.exports = {
	name: "esrecurse",
	description: "ECMAScript AST recursive visitor",
	version: "4.2.1"
};

},
// 298
function(module, exports, __webpack_require__) {

const Syntax = __webpack_require__(49).Syntax,
	esrecurse = __webpack_require__(135);

function getLast(xs) {
	return xs[xs.length - 1] || null;
}

class PatternVisitor extends esrecurse.Visitor {
	static isPattern(node) {
		const nodeType = node.type;

		return (
			nodeType === Syntax.Identifier ||
			nodeType === Syntax.ObjectPattern ||
			nodeType === Syntax.ArrayPattern ||
			nodeType === Syntax.SpreadElement ||
			nodeType === Syntax.RestElement ||
			nodeType === Syntax.AssignmentPattern
		);
	}

	constructor(options, rootPattern, callback) {
		super(null, options);
		this.rootPattern = rootPattern;
		this.callback = callback;
		this.assignments = [];
		this.rightHandNodes = [];
		this.restElements = [];
	}

	Identifier(pattern) {
		const lastRestElement = getLast(this.restElements);

		this.callback(pattern, {
			topLevel: pattern === this.rootPattern,
			rest: lastRestElement !== null && lastRestElement !== void 0 && lastRestElement.argument === pattern,
			assignments: this.assignments
		});
	}

	Property(property) {
		property.computed && this.rightHandNodes.push(property.key);

		this.visit(property.value);
	}

	ArrayPattern(pattern) {
		for (let i = 0, iz = pattern.elements.length; i < iz; ++i) {
			const element = pattern.elements[i];

			this.visit(element);
		}
	}

	AssignmentPattern(pattern) {
		this.assignments.push(pattern);
		this.visit(pattern.left);
		this.rightHandNodes.push(pattern.right);
		this.assignments.pop();
	}

	RestElement(pattern) {
		this.restElements.push(pattern);
		this.visit(pattern.argument);
		this.restElements.pop();
	}

	MemberExpression(node) {
		node.computed && this.rightHandNodes.push(node.property);

		this.rightHandNodes.push(node.object);
	}

	SpreadElement(node) {
		this.visit(node.argument);
	}

	ArrayExpression(node) {
		node.elements.forEach(this.visit, this);
	}

	AssignmentExpression(node) {
		this.assignments.push(node);
		this.visit(node.left);
		this.rightHandNodes.push(node.right);
		this.assignments.pop();
	}

	CallExpression(node) {
		node.arguments.forEach(a => {
			this.rightHandNodes.push(a);
		});
		this.visit(node.callee);
	}
}

module.exports = PatternVisitor;

},
// 299
function(module) {

module.exports = {
	name: "eslint-scope",
	description: "ECMAScript scope analyzer for ESLint",
	version: "4.0.3"
};

},
// 300
function(module, exports, __webpack_require__) {

const similarity = (a, b) => {
	const l = Math.min(a.length, b.length);
	let dist = 0;
	for (let i = 0; i < l; i++) {
		const ca = a.charCodeAt(i);
		const cb = b.charCodeAt(i);
		dist += Math.max(0, 10 - Math.abs(ca - cb));
	}
	return dist;
};

const getName = (a, b) => {
	const l = Math.min(a.length, b.length);
	let r = "";
	for (let i = 0; i < l; i++) {
		const ca = a.charAt(i);
		const cb = b.charAt(i);
		r += ca;
		if (ca === cb) {
			continue;
		}
		return r;
	}
	return a;
};

class Node {
	constructor(item, key, size) {
		this.item = item;
		this.key = key;
		this.size = size;
	}
}

class Group {
	constructor(nodes, similarities) {
		this.nodes = nodes;
		this.similarities = similarities;
		this.size = nodes.reduce((size, node) => size + node.size, 0);
		this.key = void 0;
	}
}

module.exports = ({ maxSize, minSize, items, getSize, getKey }) => {
	const result = [];

	const nodes = Array.from(
		items,
		item => new Node(item, getKey(item), getSize(item))
	);

	const initialNodes = [];

	nodes.sort((a, b) => {
		if (a.key < b.key) return -1;
		if (a.key > b.key) return 1;
		return 0;
	});

	for (const node of nodes) {
		if (node.size >= maxSize) {
			result.push(new Group([node], []));
		} else {
			initialNodes.push(node);
		}
	}

	if (initialNodes.length > 0) {
		const similarities = [];
		for (let i = 1; i < initialNodes.length; i++) {
			const a = initialNodes[i - 1];
			const b = initialNodes[i];
			similarities.push(similarity(a.key, b.key));
		}

		const initialGroup = new Group(initialNodes, similarities);

		if (initialGroup.size < minSize) {
			if (result.length > 0) {
				const smallestGroup = result.reduce((min, group) =>
					min.size > group.size ? group : min
				);
				for (const node of initialGroup.nodes) smallestGroup.nodes.push(node);
				smallestGroup.nodes.sort((a, b) => {
					if (a.key < b.key) return -1;
					if (a.key > b.key) return 1;
					return 0;
				});
			} else {
				result.push(initialGroup);
			}
		} else {
			const queue = [initialGroup];

			while (queue.length) {
				const group = queue.pop();
				if (group.size < maxSize) {
					result.push(group);
					continue;
				}

				let left = 0;
				let leftSize = 0;
				while (leftSize <= minSize) {
					leftSize += group.nodes[left].size;
					left++;
				}
				let right = group.nodes.length - 1;
				let rightSize = 0;
				while (rightSize <= minSize) {
					rightSize += group.nodes[right].size;
					right--;
				}

				if (left - 1 > right) {
					result.push(group);
					continue;
				}
				if (left <= right) {
					let best = left - 1;
					let bestSimilarity = group.similarities[best];
					for (let i = left; i <= right; i++) {
						const similarity = group.similarities[i];
						if (similarity < bestSimilarity) {
							best = i;
							bestSimilarity = similarity;
						}
					}
					left = best + 1;
					right = best;
				}

				const rightNodes = [group.nodes[right + 1]];
				const rightSimilaries = [];
				for (let i = right + 2; i < group.nodes.length; i++) {
					rightSimilaries.push(group.similarities[i - 1]);
					rightNodes.push(group.nodes[i]);
				}
				queue.push(new Group(rightNodes, rightSimilaries));

				const leftNodes = [group.nodes[0]];
				const leftSimilaries = [];
				for (let i = 1; i < left; i++) {
					leftSimilaries.push(group.similarities[i - 1]);
					leftNodes.push(group.nodes[i]);
				}
				queue.push(new Group(leftNodes, leftSimilaries));
			}
		}
	}

	result.sort((a, b) => {
		if (a.nodes[0].key < b.nodes[0].key) return -1;
		if (a.nodes[0].key > b.nodes[0].key) return 1;
		return 0;
	});

	for (let i = 0; i < result.length; i++) {
		const group = result[i];
		const first = group.nodes[0];
		const last = group.nodes[group.nodes.length - 1];
		let name = getName(first.key, last.key);
		group.key = name;
	}

	return result.map(group => {
		return {
			key: group.key,
			items: group.nodes.map(node => node.item),
			size: group.size
		};
	});
};

},
// 301
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1),
	SizeFormatHelpers = __webpack_require__(31);

class MinMaxSizeWarning extends WebpackError {
	constructor(keys, minSize, maxSize) {
		let keysMessage = "Fallback cache group";
		if (keys)
			keysMessage =
				keys.length > 1
					? "Cache groups " + keys.sort().join(", ")
					: "Cache group " + keys[0];

		super(
			`SplitChunksPlugin\n${keysMessage}\nConfigured minSize (${SizeFormatHelpers.formatSize(minSize)}) is bigger than maxSize (${SizeFormatHelpers.formatSize(maxSize)}).\nThis seem to be a invalid optimiziation.splitChunks configuration.`
		);
	}
}

module.exports = MinMaxSizeWarning;

},
// 302
function(module, exports, __webpack_require__) {

const UnsupportedWebAssemblyFeatureError = __webpack_require__(85);

class WasmFinalizeExportsPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap("WasmFinalizeExportsPlugin", compilation => {
			compilation.hooks.finishModules.tap(
				"WasmFinalizeExportsPlugin",
				modules => {
					for (const module of modules) {
						if (module.type.startsWith("webassembly") === true) {
							const jsIncompatibleExports =
								module.buildMeta.jsIncompatibleExports;

							if (jsIncompatibleExports === void 0) {
								continue;
							}

							for (const reason of module.reasons) {
								if (reason.module.type.startsWith("webassembly") === false) {
									const ref = compilation.getDependencyReference(
										reason.module,
										reason.dependency
									);

									if (!ref) continue;

									const importedNames = ref.importedNames;

									if (Array.isArray(importedNames)) {
										importedNames.forEach(name => {
											if (
												Object.prototype.hasOwnProperty.call(
													jsIncompatibleExports,
													name
												)
											) {
												const error = new UnsupportedWebAssemblyFeatureError(
													`Export "${name}" with ${jsIncompatibleExports[name]} can only be used for direct wasm to wasm dependencies`
												);
												error.module = module;
												error.origin = reason.module;
												error.originLoc = reason.dependency.loc;
												error.dependencies = [reason.dependency];
												compilation.errors.push(error);
											}
										});
									}
								}
							}
						}
					}
				}
			);
		});
	}
}

module.exports = WasmFinalizeExportsPlugin;

},
// 303
function(module) {

module.exports = JSON.parse(
	'{"title":"HashedModuleIdsPluginOptions","type":"object","additionalProperties":false,"properties":{"context":{"description":"The context directory for creating names.","type":"string","absolutePath":true},"hashDigest":{"description":"The encoding to use when generating the hash, defaults to \'base64\'. All encodings from Node.JS\' hash.digest are supported.","enum":["hex","latin1","base64"]},"hashDigestLength":{"description":"The prefix length of the hash digest to use, defaults to 4.","type":"number","minimum":1},"hashFunction":{"description":"The hashing algorithm to use, defaults to \'md5\'. All functions from Node.JS\' crypto.createHash are supported.","type":"string","minLength":1}}}'
);

},
// 304
function(module) {

module.exports = JSON.parse(
	'{"title":"OccurrenceOrderModuleIdsPluginOptions","type":"object","additionalProperties":false,"properties":{"prioritiseInitial":{"description":"Prioritise initial size over total size","type":"boolean"}}}'
);

},
// 305
function(module, exports, __webpack_require__) {

class NaturalChunkOrderPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap("NaturalChunkOrderPlugin", compilation => {
			compilation.hooks.optimizeChunkOrder.tap(
				"NaturalChunkOrderPlugin",
				chunks => {
					chunks.sort((chunkA, chunkB) => {
						const a = chunkA.modulesIterable[Symbol.iterator]();
						const b = chunkB.modulesIterable[Symbol.iterator]();
						while (true) {
							const aItem = a.next();
							const bItem = b.next();
							if (aItem.done && bItem.done) return 0;
							if (aItem.done) return -1;
							if (bItem.done) return 1;
							const aModuleId = aItem.value.id;
							const bModuleId = bItem.value.id;
							if (aModuleId < bModuleId) return -1;
							if (aModuleId > bModuleId) return 1;
						}
					});
				}
			);
		});
	}
}

module.exports = NaturalChunkOrderPlugin;

},
// 306
function(module) {

module.exports = JSON.parse(
	'{"title":"OccurrenceOrderChunkIdsPluginOptions","type":"object","additionalProperties":false,"properties":{"prioritiseInitial":{"description":"Prioritise initial size over total size","type":"boolean"}}}'
);

},
// 307
function(module, exports, __webpack_require__) {

const EntrypointsOverSizeLimitWarning = __webpack_require__(308);
const AssetsOverSizeLimitWarning = __webpack_require__(309);
const NoAsyncChunksWarning = __webpack_require__(310);

module.exports = class {
	constructor(options) {
		this.hints = options.hints;
		this.maxAssetSize = options.maxAssetSize;
		this.maxEntrypointSize = options.maxEntrypointSize;
		this.assetFilter = options.assetFilter;
	}

	apply(compiler) {
		const entrypointSizeLimit = this.maxEntrypointSize;
		const assetSizeLimit = this.maxAssetSize;
		const hints = this.hints;
		const assetFilter =
			this.assetFilter || ((name, source, info) => !info.development);

		compiler.hooks.afterEmit.tap("SizeLimitsPlugin", compilation => {
			const warnings = [];

			const getEntrypointSize = entrypoint =>
				entrypoint.getFiles().reduce((currentSize, file) => {
					const asset = compilation.getAsset(file);
					if (
						asset &&
						assetFilter(asset.name, asset.source, asset.info) &&
						asset.source
					) {
						return currentSize + (asset.info.size || asset.source.size());
					}

					return currentSize;
				}, 0);

			const assetsOverSizeLimit = [];
			for (const { name, source, info } of compilation.getAssets()) {
				if (!assetFilter(name, source, info) || !source) {
					continue;
				}

				const size = info.size || source.size();
				if (size > assetSizeLimit) {
					assetsOverSizeLimit.push({
						name,
						size
					});
					(source).isOverSizeLimit = true;
				}
			}

			const fileFilter = name => {
				const asset = compilation.getAsset(name);
				return asset && assetFilter(asset.name, asset.source, asset.info);
			};

			const entrypointsOverLimit = [];
			for (const [name, entry] of compilation.entrypoints) {
				const size = getEntrypointSize(entry);

				if (size > entrypointSizeLimit) {
					entrypointsOverLimit.push({
						name: name,
						size: size,
						files: entry.getFiles().filter(fileFilter)
					});
					(entry).isOverSizeLimit = true;
				}
			}

			if (hints) {
				if (assetsOverSizeLimit.length > 0) {
					warnings.push(
						new AssetsOverSizeLimitWarning(assetsOverSizeLimit, assetSizeLimit)
					);
				}
				if (entrypointsOverLimit.length > 0) {
					warnings.push(
						new EntrypointsOverSizeLimitWarning(
							entrypointsOverLimit,
							entrypointSizeLimit
						)
					);
				}

				if (warnings.length > 0) {
					const hasAsyncChunks =
						compilation.chunks.filter(chunk => !chunk.canBeInitial()).length >
						0;

					if (!hasAsyncChunks) {
						warnings.push(new NoAsyncChunksWarning());
					}

					if (hints === "error") {
						compilation.errors.push(...warnings);
					} else {
						compilation.warnings.push(...warnings);
					}
				}
			}
		});
	}
};

},
// 308
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);
const SizeFormatHelpers = __webpack_require__(31);

module.exports = class extends WebpackError {
	constructor(entrypoints, entrypointLimit) {
		const entrypointList = entrypoints
			.map(
				entrypoint =>
					`\n  ${entrypoint.name} (${SizeFormatHelpers.formatSize(
						entrypoint.size
					)})\n${entrypoint.files.map(asset => `      ${asset}`).join("\n")}`
			)
			.join("");
		super(`entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (${SizeFormatHelpers.formatSize(
			entrypointLimit
		)}). This can impact web performance.
Entrypoints:${entrypointList}\n`);

		this.name = "EntrypointsOverSizeLimitWarning";
		this.entrypoints = entrypoints;

		Error.captureStackTrace(this, this.constructor);
	}
};

},
// 309
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);
const SizeFormatHelpers = __webpack_require__(31);

module.exports = class extends WebpackError {
	constructor(assetsOverSizeLimit, assetLimit) {
		const assetLists = assetsOverSizeLimit
			.map(
				asset =>
					`\n  ${asset.name} (${SizeFormatHelpers.formatSize(asset.size)})`
			)
			.join("");

		super(`asset size limit: The following asset(s) exceed the recommended size limit (${SizeFormatHelpers.formatSize(
			assetLimit
		)}).
This can impact web performance.
Assets: ${assetLists}`);

		this.name = "AssetsOverSizeLimitWarning";
		this.assets = assetsOverSizeLimit;

		Error.captureStackTrace(this, this.constructor);
	}
};

},
// 310
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);

module.exports = class extends WebpackError {
	constructor() {
		super(
			"webpack performance recommendations: \nYou can limit the size of your bundles by using import() or require.ensure to lazy load some parts of your application.\nFor more info visit https://webpack.js.org/guides/code-splitting/"
		);

		this.name = "NoAsyncChunksWarning";

		Error.captureStackTrace(this, this.constructor);
	}
};

},
// 311
function(module, exports, __webpack_require__) {

const path = __webpack_require__(3);

const OptionsDefaulter = __webpack_require__(312);
const Template = __webpack_require__(2);

const isProductionLikeMode = options => {
	return options.mode === "production" || !options.mode;
};

const isWebLikeTarget = options => {
	return options.target === "web" || options.target === "webworker";
};

const getDevtoolNamespace = library => {
	if (Array.isArray(library)) {
		return library.join(".");
	} else if (typeof library == "object") {
		return getDevtoolNamespace(library.root);
	}
	return library || "";
};

class WebpackOptionsDefaulter extends OptionsDefaulter {
	constructor() {
		super();

		this.set("entry", "./src");

		this.set("devtool", "make", options =>
			options.mode === "development" ? "eval" : false
		);
		this.set("cache", "make", options => options.mode === "development");

		this.set("context", process.cwd());
		this.set("target", "web");

		this.set("module", "call", value => Object.assign({}, value));
		this.set("module.unknownContextRequest", ".");
		this.set("module.unknownContextRegExp", false);
		this.set("module.unknownContextRecursive", true);
		this.set("module.unknownContextCritical", true);
		this.set("module.exprContextRequest", ".");
		this.set("module.exprContextRegExp", false);
		this.set("module.exprContextRecursive", true);
		this.set("module.exprContextCritical", true);
		this.set("module.wrappedContextRegExp", /.*/);
		this.set("module.wrappedContextRecursive", true);
		this.set("module.wrappedContextCritical", false);
		this.set("module.strictExportPresence", false);
		this.set("module.strictThisContextOnImports", false);
		this.set("module.unsafeCache", "make", options => !!options.cache);
		this.set("module.rules", []);
		this.set("module.defaultRules", "make", options => [
			{
				type: "javascript/auto",
				resolve: {}
			},
			{
				test: /\.mjs$/i,
				type: "javascript/esm",
				resolve: {
					mainFields:
						options.target === "web" ||
						options.target === "webworker" ||
						options.target === "electron-renderer"
							? ["browser", "main"]
							: ["main"]
				}
			},
			{
				test: /\.json$/i,
				type: "json"
			},
			{
				test: /\.wasm$/i,
				type: "webassembly/experimental"
			}
		]);

		this.set("output", "call", (value, options) => {
			if (typeof value == "string") {
				return {
					filename: value
				};
			} else if (typeof value != "object") {
				return {};
			} else {
				return Object.assign({}, value);
			}
		});

		this.set("output.filename", "[name].js");
		this.set("output.chunkFilename", "make", options => {
			const filename = options.output.filename;
			if (typeof filename != "function") {
				const hasName = filename.includes("[name]");
				const hasId = filename.includes("[id]");
				const hasChunkHash = filename.includes("[chunkhash]");
				if (hasChunkHash || hasName || hasId) return filename;
				return filename.replace(/(^|\/)([^/]*(?:\?|$))/, "$1[id].$2");
			}
			return "[id].js";
		});
		this.set("output.webassemblyModuleFilename", "[modulehash].module.wasm");
		this.set("output.library", "");
		this.set("output.hotUpdateFunction", "make", options => {
			return Template.toIdentifier(
				"webpackHotUpdate" + Template.toIdentifier(options.output.library)
			);
		});
		this.set("output.jsonpFunction", "make", options => {
			return Template.toIdentifier(
				"webpackJsonp" + Template.toIdentifier(options.output.library)
			);
		});
		this.set("output.chunkCallbackName", "make", options => {
			return Template.toIdentifier(
				"webpackChunk" + Template.toIdentifier(options.output.library)
			);
		});
		this.set("output.globalObject", "make", options => {
			switch (options.target) {
				case "web":
				case "electron-renderer":
				case "node-webkit":
					return "window";
				case "webworker":
					return "self";
				case "node":
				case "async-node":
				case "electron-main":
					return "global";
				default:
					return "self";
			}
		});
		this.set("output.devtoolNamespace", "make", options => {
			return getDevtoolNamespace(options.output.library);
		});
		this.set("output.libraryTarget", "var");
		this.set("output.path", path.join(process.cwd(), "dist"));
		this.set(
			"output.pathinfo",
			"make",
			options => options.mode === "development"
		);
		this.set("output.sourceMapFilename", "[file].map[query]");
		this.set("output.hotUpdateChunkFilename", "[id].[hash].hot-update.js");
		this.set("output.hotUpdateMainFilename", "[hash].hot-update.json");
		this.set("output.crossOriginLoading", false);
		this.set("output.jsonpScriptType", false);
		this.set("output.chunkLoadTimeout", 120000);
		this.set("output.hashFunction", "md4");
		this.set("output.hashDigest", "hex");
		this.set("output.hashDigestLength", 20);
		this.set("output.devtoolLineToLine", false);
		this.set("output.strictModuleExceptionHandling", false);

		this.set("node", "call", value => {
			if (typeof value == "boolean") {
				return value;
			} else {
				return Object.assign({}, value);
			}
		});
		this.set("node.console", false);
		this.set("node.process", true);
		this.set("node.global", true);
		this.set("node.Buffer", true);
		this.set("node.setImmediate", true);
		this.set("node.__filename", "mock");
		this.set("node.__dirname", "mock");

		this.set("performance", "call", (value, options) => {
			if (value === false) return false;
			if (
				value === void 0 &&
				(!isProductionLikeMode(options) || !isWebLikeTarget(options))
			)
				return false;
			return Object.assign({}, value);
		});
		this.set("performance.maxAssetSize", 250000);
		this.set("performance.maxEntrypointSize", 250000);
		this.set("performance.hints", "make", options =>
			isProductionLikeMode(options) ? "warning" : false
		);

		this.set("optimization", "call", value => Object.assign({}, value));
		this.set(
			"optimization.removeAvailableModules",
			"make",
			options => options.mode !== "development"
		);
		this.set("optimization.removeEmptyChunks", true);
		this.set("optimization.mergeDuplicateChunks", true);
		this.set("optimization.flagIncludedChunks", "make", options =>
			isProductionLikeMode(options)
		);
		this.set("optimization.occurrenceOrder", "make", options =>
			isProductionLikeMode(options)
		);
		this.set("optimization.sideEffects", "make", options =>
			isProductionLikeMode(options)
		);
		this.set("optimization.providedExports", true);
		this.set("optimization.usedExports", "make", options =>
			isProductionLikeMode(options)
		);
		this.set("optimization.concatenateModules", "make", options =>
			isProductionLikeMode(options)
		);
		this.set("optimization.splitChunks", {});
		this.set("optimization.splitChunks.hidePathInfo", "make", options => {
			return isProductionLikeMode(options);
		});
		this.set("optimization.splitChunks.chunks", "async");
		this.set("optimization.splitChunks.minSize", "make", options => {
			return isProductionLikeMode(options) ? 30000 : 10000;
		});
		this.set("optimization.splitChunks.minChunks", 1);
		this.set("optimization.splitChunks.maxAsyncRequests", "make", options => {
			return isProductionLikeMode(options) ? 5 : Infinity;
		});
		this.set("optimization.splitChunks.automaticNameDelimiter", "~");
		this.set("optimization.splitChunks.automaticNameMaxLength", 109);
		this.set("optimization.splitChunks.maxInitialRequests", "make", options => {
			return isProductionLikeMode(options) ? 3 : Infinity;
		});
		this.set("optimization.splitChunks.name", true);
		this.set("optimization.splitChunks.cacheGroups", {});
		this.set("optimization.splitChunks.cacheGroups.default", {
			automaticNamePrefix: "",
			reuseExistingChunk: true,
			minChunks: 2,
			priority: -20
		});
		this.set("optimization.splitChunks.cacheGroups.vendors", {
			automaticNamePrefix: "vendors",
			test: /[\\/]node_modules[\\/]/,
			priority: -10
		});
		this.set("optimization.runtimeChunk", "call", value => {
			if (value === "single") {
				return {
					name: "runtime"
				};
			}
			if (value === true || value === "multiple") {
				return {
					name: entrypoint => `runtime~${entrypoint.name}`
				};
			}
			return value;
		});
		this.set("optimization.noEmitOnErrors", "make", options =>
			isProductionLikeMode(options)
		);
		this.set("optimization.checkWasmTypes", "make", options =>
			isProductionLikeMode(options)
		);
		this.set("optimization.mangleWasmImports", false);
		this.set(
			"optimization.namedModules",
			"make",
			options => options.mode === "development"
		);
		this.set("optimization.hashedModuleIds", false);
		this.set(
			"optimization.namedChunks",
			"make",
			options => options.mode === "development"
		);
		this.set(
			"optimization.portableRecords",
			"make",
			options =>
				!!(
					options.recordsInputPath ||
					options.recordsOutputPath ||
					options.recordsPath
				)
		);
		this.set("optimization.minimize", "make", options =>
			isProductionLikeMode(options)
		);
		this.set("optimization.minimizer", "make", options => [
			{
				apply: compiler => {
					const TerserPlugin = __webpack_require__(145);
					const SourceMapDevToolPlugin = __webpack_require__(60);
					new TerserPlugin({
						cache: true,
						parallel: true,
						sourceMap:
							(options.devtool && /source-?map/.test(options.devtool)) ||
							(options.plugins &&
								options.plugins.some(p => p instanceof SourceMapDevToolPlugin))
					}).apply(compiler);
				}
			}
		]);
		this.set("optimization.nodeEnv", "make", options => {
			return options.mode || "production";
		});

		this.set("resolve", "call", value => Object.assign({}, value));
		this.set("resolve.unsafeCache", true);
		this.set("resolve.modules", ["node_modules"]);
		this.set("resolve.extensions", [".wasm", ".mjs", ".js", ".json"]);
		this.set("resolve.mainFiles", ["index"]);
		this.set("resolve.aliasFields", "make", options => {
			if (
				options.target === "web" ||
				options.target === "webworker" ||
				options.target === "electron-renderer"
			) {
				return ["browser"];
			} else {
				return [];
			}
		});
		this.set("resolve.mainFields", "make", options => {
			if (
				options.target === "web" ||
				options.target === "webworker" ||
				options.target === "electron-renderer"
			) {
				return ["browser", "module", "main"];
			} else {
				return ["module", "main"];
			}
		});
		this.set("resolve.cacheWithContext", "make", options => {
			return (
				Array.isArray(options.resolve.plugins) &&
				options.resolve.plugins.length > 0
			);
		});
		this.set(
			"resolve.preferAbsolute",
			"make",
			options => !options.resolve.roots || options.resolve.roots.length === 0
		);
		this.set(
			"resolve.ignoreRootsErrors",
			"make",
			options => !options.resolve.roots || options.resolve.roots.length === 0
		);
		this.set("resolve.roots", "make", options => [options.context]);

		this.set("resolveLoader", "call", value => Object.assign({}, value));
		this.set("resolveLoader.unsafeCache", true);
		this.set("resolveLoader.mainFields", ["loader", "main"]);
		this.set("resolveLoader.extensions", [".js", ".json"]);
		this.set("resolveLoader.mainFiles", ["index"]);
		this.set("resolveLoader.cacheWithContext", "make", options => {
			return (
				Array.isArray(options.resolveLoader.plugins) &&
				options.resolveLoader.plugins.length > 0
			);
		});

		this.set("infrastructureLogging", "call", value =>
			Object.assign({}, value)
		);
		this.set("infrastructureLogging.level", "info");
		this.set("infrastructureLogging.debug", false);
	}
}

module.exports = WebpackOptionsDefaulter;

},
// 312
function(module) {

const getProperty = (obj, path) => {
	let name = path.split(".");
	for (let i = 0; i < name.length - 1; i++)
		if (typeof (obj = obj[name[i]]) != "object" || !obj || Array.isArray(obj)) return;

	return obj[name.pop()];
};

const setProperty = (obj, path, value) => {
	let name = path.split(".");
	for (let i = 0; i < name.length - 1; i++) {
		if (typeof obj[name[i]] != "object" && obj[name[i]] !== void 0) return;
		if (Array.isArray(obj[name[i]])) return;
		obj[name[i]] || (obj[name[i]] = {});
		obj = obj[name[i]];
	}
	obj[name.pop()] = value;
};

class OptionsDefaulter {
	constructor() {
		this.defaults = {};
		this.config = {};
	}

	process(options) {
		options = Object.assign({}, options);
		for (let name in this.defaults)
			switch (this.config[name]) {
				case void 0:
					getProperty(options, name) !== void 0 ||
						setProperty(options, name, this.defaults[name]);

					break;
				case "call":
					setProperty(
						options,
						name,
						this.defaults[name].call(this, getProperty(options, name), options)
					);
					break;
				case "make":
					getProperty(options, name) !== void 0 ||
						setProperty(options, name, this.defaults[name].call(this, options));

					break;
				case "append":
					let oldValue = getProperty(options, name);
					Array.isArray(oldValue) || (oldValue = []);

					oldValue.push(...this.defaults[name]);
					setProperty(options, name, oldValue);
					break;

				default:
					throw new Error(
						"OptionsDefaulter cannot process " + this.config[name]
					);
			}

		return options;
	}

	set(name, config, def) {
		if (def !== void 0) {
			this.defaults[name] = def;
			this.config[name] = config;
		} else {
			this.defaults[name] = config;
			delete this.config[name];
		}
	}
}

module.exports = OptionsDefaulter;

},
// 313
function(module, exports, __webpack_require__) {

const Ajv = __webpack_require__(314);
const ajv = new Ajv({
	errorDataPath: "configuration",
	allErrors: true,
	verbose: true
});
__webpack_require__(315)(ajv, ["instanceof"]);
__webpack_require__(316)(ajv);

const validateSchema = (schema, options) => {
	if (Array.isArray(options)) {
		const errors = options.map(options => validateObject(schema, options));
		errors.forEach((list, idx) => {
			const applyPrefix = err => {
				err.dataPath = `[${idx}]${err.dataPath}`;
				if (err.children) {
					err.children.forEach(applyPrefix);
				}
			};
			list.forEach(applyPrefix);
		});
		return errors.reduce((arr, items) => {
			return arr.concat(items);
		}, []);
	} else {
		return validateObject(schema, options);
	}
};

const validateObject = (schema, options) => {
	const validate = ajv.compile(schema);
	const valid = validate(options);
	return valid ? [] : filterErrors(validate.errors);
};

const filterErrors = errors => {
	let newErrors = [];
	for (const err of errors) {
		const dataPath = err.dataPath;
		let children = [];
		newErrors = newErrors.filter(oldError => {
			if (oldError.dataPath.includes(dataPath)) {
				if (oldError.children) {
					children = children.concat(oldError.children.slice(0));
				}
				oldError.children = void 0;
				children.push(oldError);
				return false;
			}
			return true;
		});
		if (children.length) {
			err.children = children;
		}
		newErrors.push(err);
	}

	return newErrors;
};

module.exports = validateSchema;

},
// 314
function(module) {

module.exports = require("../vendor/ajv");

},
// 315
function(module) {

module.exports = require("../vendor/ajv-keywords");

},
// 316
function(module, exports, __webpack_require__) {

const errorMessage = (schema, data, message) => ({
	keyword: "absolutePath",
	params: { absolutePath: data },
	message: message,
	parentSchema: schema
});

const getErrorFor = (shouldBeAbsolute, data, schema) => {
	const message = shouldBeAbsolute
		? `The provided value ${JSON.stringify(data)} is not an absolute path!`
		: `A relative path is expected. However, the provided value ${JSON.stringify(
				data
			)} is an absolute path!`;

	return errorMessage(schema, data, message);
};

module.exports = ajv =>
	ajv.addKeyword("absolutePath", {
		errors: true,
		type: "string",
		compile(expected, schema) {
			function callback(data) {
				let passes = true;
				const isExclamationMarkPresent = data.includes("!");

				if (isExclamationMarkPresent) {
					callback.errors = [
						errorMessage(
							schema,
							data,
							`The provided value ${JSON.stringify(
								data
							)} contains exclamation mark (!) which is not allowed because it's reserved for loader syntax.`
						)
					];
					passes = false;
				}
				const isCorrectAbsolutePath =
					expected === /^(?:[A-Za-z]:\\|\\\\|\/)/.test(data);
				if (!isCorrectAbsolutePath) {
					callback.errors = [getErrorFor(expected, data, schema)];
					passes = false;
				}

				return passes;
			}
			callback.errors = [];

			return callback;
		}
	});

},
// 317
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);
const webpackOptionsSchema = __webpack_require__(146);

const getSchemaPart = (path, parents, additionalPath) => {
	parents = parents || 0;
	path = path.split("/");
	path = path.slice(0, path.length - parents);
	if (additionalPath) {
		additionalPath = additionalPath.split("/");
		path = path.concat(additionalPath);
	}
	let schemaPart = webpackOptionsSchema;
	for (let i = 1; i < path.length; i++) {
		const inner = schemaPart[path[i]];
		if (inner) schemaPart = inner;
	}
	return schemaPart;
};

const getSchemaPartText = (schemaPart, additionalPath) => {
	if (additionalPath) {
		for (let i = 0; i < additionalPath.length; i++) {
			const inner = schemaPart[additionalPath[i]];
			if (inner) schemaPart = inner;
		}
	}
	while (schemaPart.$ref) {
		schemaPart = getSchemaPart(schemaPart.$ref);
	}
	let schemaText = WebpackOptionsValidationError.formatSchema(schemaPart);
	if (schemaPart.description) {
		schemaText += `\n-> ${schemaPart.description}`;
	}
	return schemaText;
};

const getSchemaPartDescription = schemaPart => {
	while (schemaPart.$ref) {
		schemaPart = getSchemaPart(schemaPart.$ref);
	}
	if (schemaPart.description) {
		return `\n-> ${schemaPart.description}`;
	}
	return "";
};

const SPECIFICITY = {
	type: 1,
	oneOf: 1,
	anyOf: 1,
	allOf: 1,
	additionalProperties: 2,
	enum: 1,
	instanceof: 1,
	required: 2,
	minimum: 2,
	uniqueItems: 2,
	minLength: 2,
	minItems: 2,
	minProperties: 2,
	absolutePath: 2
};

const filterMax = (array, fn) => {
	const max = array.reduce((max, item) => Math.max(max, fn(item)), 0);
	return array.filter(item => fn(item) === max);
};

const filterChildren = children => {
	children = filterMax(children, err =>
		err.dataPath ? err.dataPath.length : 0
	);
	children = filterMax(children, err => SPECIFICITY[err.keyword] || 2);
	return children;
};

const indent = (str, prefix, firstLine) => {
	if (firstLine) {
		return prefix + str.replace(/\n(?!$)/g, "\n" + prefix);
	} else {
		return str.replace(/\n(?!$)/g, `\n${prefix}`);
	}
};

class WebpackOptionsValidationError extends WebpackError {
	constructor(validationErrors) {
		super(
			"Invalid configuration object. Webpack has been initialised using a configuration object that does not match the API schema.\n" +
				validationErrors
					.map(
						err =>
							" - " +
							indent(
								WebpackOptionsValidationError.formatValidationError(err),
								"   ",
								false
							)
					)
					.join("\n")
		);

		this.name = "WebpackOptionsValidationError";
		this.validationErrors = validationErrors;

		Error.captureStackTrace(this, this.constructor);
	}

	static formatSchema(schema, prevSchemas) {
		prevSchemas = prevSchemas || [];

		const formatInnerSchema = (innerSchema, addSelf) => {
			if (!addSelf) {
				return WebpackOptionsValidationError.formatSchema(
					innerSchema,
					prevSchemas
				);
			}
			if (prevSchemas.includes(innerSchema)) {
				return "(recursive)";
			}
			return WebpackOptionsValidationError.formatSchema(
				innerSchema,
				prevSchemas.concat(schema)
			);
		};

		if (schema.type === "string") {
			if (schema.minLength === 1) {
				return "non-empty string";
			}
			if (schema.minLength > 1) {
				return `string (min length ${schema.minLength})`;
			}
			return "string";
		}
		if (schema.type === "boolean") {
			return "boolean";
		}
		if (schema.type === "number") {
			return "number";
		}
		if (schema.type === "object") {
			if (schema.properties) {
				const required = schema.required || [];
				return `object { ${Object.keys(schema.properties)
					.map(property => {
						if (!required.includes(property)) return property + "?";
						return property;
					})
					.concat(schema.additionalProperties ? ["…"] : [])
					.join(", ")} }`;
			}
			if (schema.additionalProperties) {
				return `object { <key>: ${formatInnerSchema(
					schema.additionalProperties
				)} }`;
			}
			return "object";
		}
		if (schema.type === "array") {
			return `[${formatInnerSchema(schema.items)}]`;
		}

		switch (schema.instanceof) {
			case "Function":
				return "function";
			case "RegExp":
				return "RegExp";
		}

		if (schema.enum) {
			return schema.enum.map(item => JSON.stringify(item)).join(" | ");
		}

		if (schema.$ref) {
			return formatInnerSchema(getSchemaPart(schema.$ref), true);
		}
		if (schema.allOf) {
			return schema.allOf.map(formatInnerSchema).join(" & ");
		}
		if (schema.oneOf) {
			return schema.oneOf.map(formatInnerSchema).join(" | ");
		}
		if (schema.anyOf) {
			return schema.anyOf.map(formatInnerSchema).join(" | ");
		}
		return JSON.stringify(schema, null, 2);
	}

	static formatValidationError(err) {
		const dataPath = `configuration${err.dataPath}`;
		if (err.keyword === "additionalProperties") {
			const baseMessage = `${dataPath} has an unknown property '${
				err.params.additionalProperty
			}'. These properties are valid:\n${getSchemaPartText(err.parentSchema)}`;
			if (!err.dataPath) {
				switch (err.params.additionalProperty) {
					case "debug":
						return (
							`${baseMessage}\nThe 'debug' property was removed in webpack 2.0.0.\nLoaders should be updated to allow passing this option via loader options in module.rules.\nUntil loaders are updated one can use the LoaderOptionsPlugin to switch loaders into debug mode:\nplugins: [\n  new webpack.LoaderOptionsPlugin({\n    debug: true\n  })\n]`
						);
				}
				return (
					`${baseMessage}\nFor typos: please correct them.\nFor loader options: webpack >= v2.0.0 no longer allows custom properties in configuration.\n  Loaders should be updated to allow passing options via loader options in module.rules.\n  Until loaders are updated one can use the LoaderOptionsPlugin to pass these options to the loader:\n  plugins: [\n    new webpack.LoaderOptionsPlugin({\n      // test: /\\.xxx$/, // may apply this only for some modules\n      options: {\n        ${err.params.additionalProperty}: …\n      }\n    })\n  ]`
				);
			}
			return baseMessage;
		} else if (err.keyword === "oneOf" || err.keyword === "anyOf") {
			if (err.children && err.children.length > 0) {
				if (err.schema.length === 1) {
					const lastChild = err.children[err.children.length - 1];
					const remainingChildren = err.children.slice(
						0,
						err.children.length - 1
					);
					return WebpackOptionsValidationError.formatValidationError(
						Object.assign({}, lastChild, {
							children: remainingChildren,
							parentSchema: Object.assign(
								{},
								err.parentSchema,
								lastChild.parentSchema
							)
						})
					);
				}
				const children = filterChildren(err.children);
				if (children.length === 1)
					return WebpackOptionsValidationError.formatValidationError(
						children[0]
					);

				return (
					`${dataPath} should be one of these:\n${getSchemaPartText(
						err.parentSchema
					)}\nDetails:\n${children.map(
						err =>
							" * " +
							indent(
								WebpackOptionsValidationError.formatValidationError(err),
								"   ",
								false
							)
					)
					.join("\n")}`
				);
			}
			return `${dataPath} should be one of these:\n${getSchemaPartText(
				err.parentSchema
			)}`;
		} else if (err.keyword === "enum") {
			if (
				err.parentSchema &&
				err.parentSchema.enum &&
				err.parentSchema.enum.length === 1
			) {
				return `${dataPath} should be ${getSchemaPartText(err.parentSchema)}`;
			}
			return `${dataPath} should be one of these:\n${getSchemaPartText(
				err.parentSchema
			)}`;
		} else if (err.keyword === "allOf") {
			return `${dataPath} should be:\n${getSchemaPartText(err.parentSchema)}`;
		} else if (err.keyword === "type") {
			switch (err.params.type) {
				case "object":
					return `${dataPath} should be an object.${getSchemaPartDescription(
						err.parentSchema
					)}`;
				case "string":
					return `${dataPath} should be a string.${getSchemaPartDescription(
						err.parentSchema
					)}`;
				case "boolean":
					return `${dataPath} should be a boolean.${getSchemaPartDescription(
						err.parentSchema
					)}`;
				case "number":
					return `${dataPath} should be a number.${getSchemaPartDescription(
						err.parentSchema
					)}`;
				case "array":
					return `${dataPath} should be an array:\n${getSchemaPartText(
						err.parentSchema
					)}`;
			}
			return `${dataPath} should be ${err.params.type}:\n${getSchemaPartText(
				err.parentSchema
			)}`;
		} else if (err.keyword === "instanceof") {
			return `${dataPath} should be an instance of ${getSchemaPartText(
				err.parentSchema
			)}`;
		} else if (err.keyword === "required") {
			const missingProperty = err.params.missingProperty.replace(/^\./, "");
			return `${dataPath} misses the property '${missingProperty}'.\n${getSchemaPartText(
				err.parentSchema,
				["properties", missingProperty]
			)}`;
		} else if (err.keyword === "minimum") {
			return `${dataPath} ${err.message}.${getSchemaPartDescription(
				err.parentSchema
			)}`;
		} else if (err.keyword === "uniqueItems") {
			return `${dataPath} should not contain the item '${
				err.data[err.params.i]
			}' twice.${getSchemaPartDescription(err.parentSchema)}`;
		} else if (
			err.keyword === "minLength" ||
			err.keyword === "minItems" ||
			err.keyword === "minProperties"
		) {
			if (err.params.limit === 1) {
				switch (err.keyword) {
					case "minLength":
						return `${dataPath} should be an non-empty string.${getSchemaPartDescription(
							err.parentSchema
						)}`;
					case "minItems":
						return `${dataPath} should be an non-empty array.${getSchemaPartDescription(
							err.parentSchema
						)}`;
					case "minProperties":
						return `${dataPath} should be an non-empty object.${getSchemaPartDescription(
							err.parentSchema
						)}`;
				}
				return `${dataPath} should be not empty.${getSchemaPartDescription(
					err.parentSchema
				)}`;
			} else {
				return `${dataPath} ${err.message}${getSchemaPartDescription(
					err.parentSchema
				)}`;
			}
		} else if (err.keyword === "not") {
			return `${dataPath} should not be ${getSchemaPartText(
				err.schema
			)}\n${getSchemaPartText(err.parentSchema)}`;
		} else if (err.keyword === "absolutePath") {
			const baseMessage = `${dataPath}: ${
				err.message
			}${getSchemaPartDescription(err.parentSchema)}`;
			if (dataPath === "configuration.output.filename")
				return (
					baseMessage + "\nPlease use output.path to specify absolute path and output.filename for the file name."
				);

			return baseMessage;
		} else {
			return `${dataPath} ${err.message} (${JSON.stringify(
				err,
				null,
				2
			)}).\n${getSchemaPartText(err.parentSchema)}`;
		}
	}
}

module.exports = WebpackOptionsValidationError;

},
// 318
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);

module.exports = class extends WebpackError {
	constructor(message) {
		super(message);

		Error.captureStackTrace(this, this.constructor);
	}
};

},
// 319
function(module, exports, __webpack_require__) {

const asyncLib = __webpack_require__(12);
const PrefetchDependency = __webpack_require__(147);
const NormalModule = __webpack_require__(54);

class AutomaticPrefetchPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"AutomaticPrefetchPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					PrefetchDependency,
					normalModuleFactory
				);
			}
		);
		let lastModules = null;
		compiler.hooks.afterCompile.tap("AutomaticPrefetchPlugin", compilation => {
			lastModules = compilation.modules
				.filter(m => m instanceof NormalModule)
				.map((m) => ({
					context: m.context,
					request: m.request
				}));
		});
		compiler.hooks.make.tapAsync(
			"AutomaticPrefetchPlugin",
			(compilation, callback) => {
				if (!lastModules) return callback();
				asyncLib.forEach(
					lastModules,
					(m, callback) => {
						compilation.prefetch(
							m.context || compiler.context,
							new PrefetchDependency(m.request),
							callback
						);
					},
					callback
				);
			}
		);
	}
}
module.exports = AutomaticPrefetchPlugin;

},
// 320
function(module, exports, __webpack_require__) {

const { ConcatSource } = __webpack_require__(0);
const ModuleFilenameHelpers = __webpack_require__(18);
const Template = __webpack_require__(2);

const validateOptions = __webpack_require__(8);
const schema = __webpack_require__(321);

const wrapComment = str => {
	if (!str.includes("\n")) {
		return Template.toComment(str);
	}
	return `/*!\n * ${str
		.replace(/\*\//g, "* /")
		.split("\n")
		.join("\n * ")}\n */`;
};

class BannerPlugin {
	constructor(options) {
		if (arguments.length > 1) {
			throw new Error(
				"BannerPlugin only takes one argument (pass an options object)"
			);
		}

		validateOptions(schema, options, "Banner Plugin");

		if (typeof options == "string" || typeof options == "function") {
			options = {
				banner: options
			};
		}

		this.options = options;

		const bannerOption = options.banner;
		if (typeof bannerOption == "function") {
			const getBanner = bannerOption;
			this.banner = this.options.raw
				? getBanner
				: data => wrapComment(getBanner(data));
		} else {
			const banner = this.options.raw
				? bannerOption
				: wrapComment(bannerOption);
			this.banner = () => banner;
		}
	}

	apply(compiler) {
		const options = this.options;
		const banner = this.banner;
		const matchObject = ModuleFilenameHelpers.matchObject.bind(
			void 0,
			options
		);

		compiler.hooks.compilation.tap("BannerPlugin", compilation => {
			compilation.hooks.optimizeChunkAssets.tap("BannerPlugin", chunks => {
				for (const chunk of chunks) {
					if (options.entryOnly && !chunk.canBeInitial()) {
						continue;
					}

					for (const file of chunk.files) {
						if (!matchObject(file)) {
							continue;
						}

						let query = "";
						let filename = file;
						const hash = compilation.hash;
						const querySplit = filename.indexOf("?");

						if (querySplit >= 0) {
							query = filename.substr(querySplit);
							filename = filename.substr(0, querySplit);
						}

						const lastSlashIndex = filename.lastIndexOf("/");

						const basename =
							lastSlashIndex === -1
								? filename
								: filename.substr(lastSlashIndex + 1);

						const data = {
							hash,
							chunk,
							filename,
							basename,
							query
						};

						const comment = compilation.getPath(banner(data), data);

						compilation.updateAsset(
							file,
							old => new ConcatSource(comment, "\n", old)
						);
					}
				}
			});
		});
	}
}

module.exports = BannerPlugin;

},
// 321
function(module) {

module.exports = JSON.parse(
	'{"definitions":{"BannerFunction":{"description":"The banner as function, it will be wrapped in a comment","instanceof":"Function","tsType":"(data: { hash: string, chunk: import(\'../../lib/Chunk\'), filename: string, basename: string, query: string}) => string"},"Rule":{"oneOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string","minLength":1}]},"Rules":{"oneOf":[{"type":"array","items":{"description":"A rule condition","anyOf":[{"$ref":"#/definitions/Rule"}]}},{"$ref":"#/definitions/Rule"}]}},"title":"BannerPluginArgument","oneOf":[{"title":"BannerPluginOptions","type":"object","additionalProperties":false,"properties":{"banner":{"description":"Specifies the banner","anyOf":[{"$ref":"#/definitions/BannerFunction"},{"type":"string"}]},"entryOnly":{"description":"If true, the banner will only be added to the entry chunks","type":"boolean"},"exclude":{"description":"Exclude all modules matching any of these conditions","anyOf":[{"$ref":"#/definitions/Rules"}]},"include":{"description":"Include all modules matching any of these conditions","anyOf":[{"$ref":"#/definitions/Rules"}]},"raw":{"description":"If true, banner will not be wrapped in a comment","type":"boolean"},"test":{"description":"Include all modules that pass test assertion","anyOf":[{"$ref":"#/definitions/Rules"}]}},"required":["banner"]},{"$ref":"#/definitions/BannerFunction"},{"description":"The banner as string, it will be wrapped in a comment","type":"string","minLength":1}]}'
);

},
// 322
function(module, exports, __webpack_require__) {

class ContextExclusionPlugin {
	constructor(negativeMatcher) {
		this.negativeMatcher = negativeMatcher;
	}

	apply(compiler) {
		compiler.hooks.contextModuleFactory.tap("ContextExclusionPlugin", cmf => {
			cmf.hooks.contextModuleFiles.tap("ContextExclusionPlugin", files => {
				return files.filter(filePath => !this.negativeMatcher.test(filePath));
			});
		});
	}
}

module.exports = ContextExclusionPlugin;

},
// 323
function(module, exports, __webpack_require__) {

const path = __webpack_require__(3);
const ContextElementDependency = __webpack_require__(56);

class ContextReplacementPlugin {
	constructor(
		resourceRegExp,
		newContentResource,
		newContentRecursive,
		newContentRegExp
	) {
		this.resourceRegExp = resourceRegExp;

		if (typeof newContentResource == "function") {
			this.newContentCallback = newContentResource;
		} else if (
			typeof newContentResource == "string" &&
			typeof newContentRecursive == "object"
		) {
			this.newContentResource = newContentResource;
			this.newContentCreateContextMap = (fs, callback) => {
				callback(null, newContentRecursive);
			};
		} else if (
			typeof newContentResource == "string" &&
			typeof newContentRecursive == "function"
		) {
			this.newContentResource = newContentResource;
			this.newContentCreateContextMap = newContentRecursive;
		} else {
			if (typeof newContentResource != "string") {
				newContentRegExp = newContentRecursive;
				newContentRecursive = newContentResource;
				newContentResource = void 0;
			}
			if (typeof newContentRecursive != "boolean") {
				newContentRegExp = newContentRecursive;
				newContentRecursive = void 0;
			}
			this.newContentResource = newContentResource;
			this.newContentRecursive = newContentRecursive;
			this.newContentRegExp = newContentRegExp;
		}
	}

	apply(compiler) {
		const resourceRegExp = this.resourceRegExp;
		const newContentCallback = this.newContentCallback;
		const newContentResource = this.newContentResource;
		const newContentRecursive = this.newContentRecursive;
		const newContentRegExp = this.newContentRegExp;
		const newContentCreateContextMap = this.newContentCreateContextMap;

		compiler.hooks.contextModuleFactory.tap("ContextReplacementPlugin", cmf => {
			cmf.hooks.beforeResolve.tap("ContextReplacementPlugin", result => {
				if (!result) return;
				if (resourceRegExp.test(result.request)) {
					if (newContentResource !== void 0) {
						result.request = newContentResource;
					}
					if (newContentRecursive !== void 0) {
						result.recursive = newContentRecursive;
					}
					if (newContentRegExp !== void 0) {
						result.regExp = newContentRegExp;
					}
					if (typeof newContentCallback == "function") {
						newContentCallback(result);
					} else {
						for (const d of result.dependencies) {
							if (d.critical) d.critical = false;
						}
					}
				}
				return result;
			});
			cmf.hooks.afterResolve.tap("ContextReplacementPlugin", result => {
				if (!result) return;
				if (resourceRegExp.test(result.resource)) {
					if (newContentResource !== void 0) {
						result.resource = path.resolve(result.resource, newContentResource);
					}
					if (newContentRecursive !== void 0) {
						result.recursive = newContentRecursive;
					}
					if (newContentRegExp !== void 0) {
						result.regExp = newContentRegExp;
					}
					if (typeof newContentCreateContextMap == "function") {
						result.resolveDependencies = createResolveDependenciesFromContextMap(
							newContentCreateContextMap
						);
					}
					if (typeof newContentCallback == "function") {
						const origResource = result.resource;
						newContentCallback(result);
						if (result.resource !== origResource) {
							result.resource = path.resolve(origResource, result.resource);
						}
					} else {
						for (const d of result.dependencies) {
							if (d.critical) d.critical = false;
						}
					}
				}
				return result;
			});
		});
	}
}

const createResolveDependenciesFromContextMap = createContextMap => {
	const resolveDependenciesFromContextMap = (fs, options, callback) => {
		createContextMap(fs, (err, map) => {
			if (err) return callback(err);
			const dependencies = Object.keys(map).map(key => {
				return new ContextElementDependency(
					map[key] + options.resourceQuery,
					key
				);
			});
			callback(null, dependencies);
		});
	};
	return resolveDependenciesFromContextMap;
};

module.exports = ContextReplacementPlugin;

},
// 324
function(module, exports, __webpack_require__) {

const DllEntryPlugin = __webpack_require__(325);
const FlagAllModulesAsUsedPlugin = __webpack_require__(329);
const LibManifestPlugin = __webpack_require__(330);

const validateOptions = __webpack_require__(8);
const schema = __webpack_require__(331);

class DllPlugin {
	constructor(options) {
		validateOptions(schema, options, "Dll Plugin");
		this.options = options;
	}

	apply(compiler) {
		compiler.hooks.entryOption.tap("DllPlugin", (context, entry) => {
			const itemToPlugin = (item, name) => {
				if (Array.isArray(item)) {
					return new DllEntryPlugin(context, item, name);
				}
				throw new Error("DllPlugin: supply an Array as entry");
			};
			if (typeof entry == "object" && !Array.isArray(entry)) {
				Object.keys(entry).forEach(name => {
					itemToPlugin(entry[name], name).apply(compiler);
				});
			} else {
				itemToPlugin(entry, "main").apply(compiler);
			}
			return true;
		});
		new LibManifestPlugin(this.options).apply(compiler);
		if (!this.options.entryOnly) {
			new FlagAllModulesAsUsedPlugin("DllPlugin").apply(compiler);
		}
	}
}

module.exports = DllPlugin;

},
// 325
function(module, exports, __webpack_require__) {

const DllEntryDependency = __webpack_require__(326);
const SingleEntryDependency = __webpack_require__(25);
const DllModuleFactory = __webpack_require__(327);

class DllEntryPlugin {
	constructor(context, entries, name) {
		this.context = context;
		this.entries = entries;
		this.name = name;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap(
			"DllEntryPlugin",
			(compilation, { normalModuleFactory }) => {
				const dllModuleFactory = new DllModuleFactory();
				compilation.dependencyFactories.set(
					DllEntryDependency,
					dllModuleFactory
				);
				compilation.dependencyFactories.set(
					SingleEntryDependency,
					normalModuleFactory
				);
			}
		);
		compiler.hooks.make.tapAsync("DllEntryPlugin", (compilation, callback) => {
			compilation.addEntry(
				this.context,
				new DllEntryDependency(
					this.entries.map((e, idx) => {
						const dep = new SingleEntryDependency(e);
						dep.loc = {
							name: this.name,
							index: idx
						};
						return dep;
					}),
					this.name
				),
				this.name,
				callback
			);
		});
	}
}

module.exports = DllEntryPlugin;

},
// 326
function(module, exports, __webpack_require__) {

const Dependency = __webpack_require__(17);

class DllEntryDependency extends Dependency {
	constructor(dependencies, name) {
		super();
		this.dependencies = dependencies;
		this.name = name;
	}

	get type() {
		return "dll entry";
	}
}

module.exports = DllEntryDependency;

},
// 327
function(module, exports, __webpack_require__) {

const { Tapable } = __webpack_require__(6);
const DllModule = __webpack_require__(328);

class DllModuleFactory extends Tapable {
	constructor() {
		super();
		this.hooks = {};
	}
	create(data, callback) {
		const dependency = data.dependencies[0];
		callback(
			null,
			new DllModule(
				data.context,
				dependency.dependencies,
				dependency.name,
				dependency.type
			)
		);
	}
}

module.exports = DllModuleFactory;

},
// 328
function(module, exports, __webpack_require__) {

const { RawSource } = __webpack_require__(0);
const Module = __webpack_require__(16);

class DllModule extends Module {
	constructor(context, dependencies, name, type) {
		super("javascript/dynamic", context);

		this.dependencies = dependencies;
		this.name = name;
		this.type = type;
	}

	identifier() {
		return `dll ${this.name}`;
	}

	readableIdentifier() {
		return `dll ${this.name}`;
	}

	build(options, compilation, resolver, fs, callback) {
		this.built = true;
		this.buildMeta = {};
		this.buildInfo = {};
		return callback();
	}

	source() {
		return new RawSource("module.exports = __webpack_require__;");
	}

	needRebuild() {
		return false;
	}

	size() {
		return 12;
	}

	updateHash(hash) {
		hash.update("dll module");
		hash.update(this.name || "");
		super.updateHash(hash);
	}
}

module.exports = DllModule;

},
// 329
function(module, exports, __webpack_require__) {

class FlagAllModulesAsUsedPlugin {
	constructor(explanation) {
		this.explanation = explanation;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap(
			"FlagAllModulesAsUsedPlugin",
			compilation => {
				compilation.hooks.optimizeDependencies.tap(
					"FlagAllModulesAsUsedPlugin",
					modules => {
						for (const module of modules) {
							module.used = true;
							module.usedExports = true;
							module.addReason(null, null, this.explanation);
						}
					}
				);
			}
		);
	}
}

module.exports = FlagAllModulesAsUsedPlugin;

},
// 330
function(module, exports, __webpack_require__) {

const path = __webpack_require__(3);
const asyncLib = __webpack_require__(12);
const SingleEntryDependency = __webpack_require__(25);

class LibManifestPlugin {
	constructor(options) {
		this.options = options;
	}

	apply(compiler) {
		compiler.hooks.emit.tapAsync(
			"LibManifestPlugin",
			(compilation, callback) => {
				asyncLib.forEach(
					compilation.chunks,
					(chunk, callback) => {
						if (!chunk.isOnlyInitial()) {
							callback();
							return;
						}
						const targetPath = compilation.getPath(this.options.path, {
							hash: compilation.hash,
							chunk
						});
						const name =
							this.options.name &&
							compilation.getPath(this.options.name, {
								hash: compilation.hash,
								chunk
							});
						const manifest = {
							name,
							type: this.options.type,
							content: Array.from(chunk.modulesIterable, module => {
								if (
									this.options.entryOnly &&
									!module.reasons.some(
										r => r.dependency instanceof SingleEntryDependency
									)
								) {
									return;
								}
								if (module.libIdent) {
									const ident = module.libIdent({
										context: this.options.context || compiler.options.context
									});
									if (ident) {
										return {
											ident,
											data: {
												id: module.id,
												buildMeta: module.buildMeta
											}
										};
									}
								}
							})
								.filter(Boolean)
								.reduce((obj, item) => {
									obj[item.ident] = item.data;
									return obj;
								}, Object.create(null))
						};
						const manifestContent = this.options.format
							? JSON.stringify(manifest, null, 2)
							: JSON.stringify(manifest);
						const content = Buffer.from(manifestContent, "utf8");
						compiler.outputFileSystem.mkdirp(path.dirname(targetPath), err => {
							if (err) return callback(err);
							compiler.outputFileSystem.writeFile(
								targetPath,
								content,
								callback
							);
						});
					},
					callback
				);
			}
		);
	}
}
module.exports = LibManifestPlugin;

},
// 331
function(module) {

module.exports = JSON.parse(
	'{"title":"DllPluginOptions","type":"object","additionalProperties":false,"properties":{"context":{"description":"Context of requests in the manifest file (defaults to the webpack context)","type":"string","minLength":1},"entryOnly":{"description":"If true, only entry points will be exposed","type":"boolean"},"format":{"description":"If true, manifest json file (output) will be formatted","type":"boolean"},"name":{"description":"Name of the exposed dll function (external name, use value of \'output.library\')","type":"string","minLength":1},"path":{"description":"Absolute path to the manifest json file (output)","type":"string","minLength":1},"type":{"description":"Type of the dll bundle (external type, use value of \'output.libraryTarget\')","type":"string","minLength":1}},"required":["path"]}'
);

},
// 332
function(module, exports, __webpack_require__) {

const parseJson = __webpack_require__(51);
const DelegatedSourceDependency = __webpack_require__(148);
const DelegatedModuleFactoryPlugin = __webpack_require__(333);
const ExternalModuleFactoryPlugin = __webpack_require__(121);
const DelegatedExportsDependency = __webpack_require__(149);
const NullFactory = __webpack_require__(10);
const makePathsRelative = __webpack_require__(13).makePathsRelative;
const WebpackError = __webpack_require__(1);

const validateOptions = __webpack_require__(8);
const schema = __webpack_require__(335);

class DllReferencePlugin {
	constructor(options) {
		validateOptions(schema, options, "Dll Reference Plugin");
		this.options = options;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap(
			"DllReferencePlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					DelegatedSourceDependency,
					normalModuleFactory
				);
				compilation.dependencyFactories.set(
					DelegatedExportsDependency,
					new NullFactory()
				);
			}
		);

		compiler.hooks.beforeCompile.tapAsync(
			"DllReferencePlugin",
			(params, callback) => {
				if ("manifest" in this.options) {
					const manifest = this.options.manifest;
					if (typeof manifest == "string") {
						params.compilationDependencies.add(manifest);
						compiler.inputFileSystem.readFile(manifest, (err, result) => {
							if (err) return callback(err);
							try {
								params["dll reference " + manifest] = parseJson(
									result.toString("utf-8")
								);
							} catch (e) {
								const manifestPath = makePathsRelative(
									compiler.options.context,
									manifest
								);
								params[
									"dll reference parse error " + manifest
								] = new DllManifestError(manifestPath, e.message);
							}
							return callback();
						});
						return;
					}
				}
				return callback();
			}
		);

		compiler.hooks.compile.tap("DllReferencePlugin", params => {
			let name = this.options.name;
			let sourceType = this.options.sourceType;
			let content =
				"content" in this.options ? this.options.content : void 0;
			if ("manifest" in this.options) {
				let manifestParameter = this.options.manifest;
				let manifest;
				if (typeof manifestParameter == "string") {
					if (params["dll reference parse error " + manifestParameter]) {
						return;
					}
					manifest =
						(params[
							"dll reference " + manifestParameter
						]);
				} else {
					manifest = manifestParameter;
				}
				if (manifest) {
					if (!name) name = manifest.name;
					if (!sourceType) sourceType = manifest.type;
					if (!content) content = manifest.content;
				}
			}
			const externals = {};
			const source = "dll-reference " + name;
			externals[source] = name;
			const normalModuleFactory = params.normalModuleFactory;
			new ExternalModuleFactoryPlugin(sourceType || "var", externals).apply(
				normalModuleFactory
			);
			new DelegatedModuleFactoryPlugin({
				source: source,
				type: this.options.type,
				scope: this.options.scope,
				context: this.options.context || compiler.options.context,
				content,
				extensions: this.options.extensions
			}).apply(normalModuleFactory);
		});

		compiler.hooks.compilation.tap(
			"DllReferencePlugin",
			(compilation, params) => {
				if ("manifest" in this.options) {
					let manifest = this.options.manifest;
					if (typeof manifest == "string") {
						let e = params["dll reference parse error " + manifest];
						if (e) {
							compilation.errors.push(e);
						}
					}
				}
			}
		);
	}
}

class DllManifestError extends WebpackError {
	constructor(filename, message) {
		super();

		this.name = "DllManifestError";
		this.message = `Dll manifest ${filename}\n${message}`;

		Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = DllReferencePlugin;

},
// 333
function(module, exports, __webpack_require__) {

const DelegatedModule = __webpack_require__(334);

class DelegatedModuleFactoryPlugin {
	constructor(options) {
		this.options = options;
		options.type = options.type || "require";
		options.extensions = options.extensions || [
			"",
			".wasm",
			".mjs",
			".js",
			".json"
		];
	}

	apply(normalModuleFactory) {
		const scope = this.options.scope;
		if (scope) {
			normalModuleFactory.hooks.factory.tap(
				"DelegatedModuleFactoryPlugin",
				factory => (data, callback) => {
					const dependency = data.dependencies[0];
					const request = dependency.request;
					if (request && request.indexOf(scope + "/") === 0) {
						const innerRequest = "." + request.substr(scope.length);
						let resolved;
						if (innerRequest in this.options.content) {
							resolved = this.options.content[innerRequest];
							return callback(
								null,
								new DelegatedModule(
									this.options.source,
									resolved,
									this.options.type,
									innerRequest,
									request
								)
							);
						}
						for (let i = 0; i < this.options.extensions.length; i++) {
							const extension = this.options.extensions[i];
							const requestPlusExt = innerRequest + extension;
							if (requestPlusExt in this.options.content) {
								resolved = this.options.content[requestPlusExt];
								return callback(
									null,
									new DelegatedModule(
										this.options.source,
										resolved,
										this.options.type,
										requestPlusExt,
										request + extension
									)
								);
							}
						}
					}
					return factory(data, callback);
				}
			);
		} else {
			normalModuleFactory.hooks.module.tap(
				"DelegatedModuleFactoryPlugin",
				module => {
					if (module.libIdent) {
						const request = module.libIdent(this.options);
						if (request && request in this.options.content) {
							const resolved = this.options.content[request];
							return new DelegatedModule(
								this.options.source,
								resolved,
								this.options.type,
								request,
								module
							);
						}
					}
					return module;
				}
			);
		}
	}
}
module.exports = DelegatedModuleFactoryPlugin;

},
// 334
function(module, exports, __webpack_require__) {

const { OriginalSource, RawSource } = __webpack_require__(0);

const Module = __webpack_require__(16);
const WebpackMissingModule = __webpack_require__(38);
const DelegatedSourceDependency = __webpack_require__(148);
const DelegatedExportsDependency = __webpack_require__(149);

class DelegatedModule extends Module {
	constructor(sourceRequest, data, type, userRequest, originalRequest) {
		super("javascript/dynamic", null);

		this.sourceRequest = sourceRequest;
		this.request = data.id;
		this.type = type;
		this.userRequest = userRequest;
		this.originalRequest = originalRequest;
		this.delegateData = data;

		this.delegatedSourceDependency = void 0;
	}

	libIdent(options) {
		return typeof this.originalRequest == "string"
			? this.originalRequest
			: this.originalRequest.libIdent(options);
	}

	identifier() {
		return `delegated ${JSON.stringify(this.request)} from ${
			this.sourceRequest
		}`;
	}

	readableIdentifier() {
		return `delegated ${this.userRequest} from ${this.sourceRequest}`;
	}

	needRebuild() {
		return false;
	}

	build(options, compilation, resolver, fs, callback) {
		this.built = true;
		this.buildMeta = Object.assign({}, this.delegateData.buildMeta);
		this.buildInfo = {};
		this.delegatedSourceDependency = new DelegatedSourceDependency(
			this.sourceRequest
		);
		this.addDependency(this.delegatedSourceDependency);
		this.addDependency(
			new DelegatedExportsDependency(this, this.delegateData.exports || true)
		);
		callback();
	}

	source(depTemplates, runtime) {
		const dep = (this.dependencies[0]);
		const sourceModule = dep.module;
		let str;

		if (!sourceModule) {
			str = WebpackMissingModule.moduleCode(this.sourceRequest);
		} else {
			str = `module.exports = (${runtime.moduleExports({
				module: sourceModule,
				request: dep.request
			})})`;

			switch (this.type) {
				case "require":
					str += `(${JSON.stringify(this.request)})`;
					break;
				case "object":
					str += `[${JSON.stringify(this.request)}]`;
					break;
			}

			str += ";";
		}

		if (this.useSourceMap) {
			return new OriginalSource(str, this.identifier());
		} else {
			return new RawSource(str);
		}
	}

	size() {
		return 42;
	}

	updateHash(hash) {
		hash.update(this.type);
		hash.update(JSON.stringify(this.request));
		super.updateHash(hash);
	}
}

module.exports = DelegatedModule;

},
// 335
function(module) {

module.exports = JSON.parse(
	'{"definitions":{"DllReferencePluginOptionsContent":{"description":"The mappings from request to module info","type":"object","additionalProperties":{"description":"Module info","type":"object","additionalProperties":false,"properties":{"buildMeta":{"description":"Meta information about the module","type":"object"},"exports":{"description":"Information about the provided exports of the module","anyOf":[{"description":"Exports unknown/dynamic","enum":[true]},{"description":"List of provided exports of the module","type":"array","items":{"description":"Name of the export","type":"string","minLength":1}}]},"id":{"description":"Module ID","anyOf":[{"type":"number"},{"type":"string","minLength":1}]}},"required":["id"]},"minProperties":1},"DllReferencePluginOptionsManifest":{"description":"An object containing content, name and type","type":"object","additionalProperties":false,"properties":{"content":{"description":"The mappings from request to module info","anyOf":[{"$ref":"#/definitions/DllReferencePluginOptionsContent"}]},"name":{"description":"The name where the dll is exposed (external name)","type":"string","minLength":1},"type":{"description":"The type how the dll is exposed (external type)","anyOf":[{"$ref":"#/definitions/DllReferencePluginOptionsSourceType"}]}},"required":["content"]},"DllReferencePluginOptionsSourceType":{"description":"The type how the dll is exposed (external type)","enum":["var","assign","this","window","global","commonjs","commonjs2","commonjs-module","amd","amd-require","umd","umd2","jsonp"]}},"title":"DllReferencePluginOptions","anyOf":[{"type":"object","additionalProperties":false,"properties":{"context":{"description":"(absolute path) context of requests in the manifest (or content property)","type":"string","absolutePath":true},"extensions":{"description":"Extensions used to resolve modules in the dll bundle (only used when using \'scope\')","type":"array","items":{"description":"An extension","type":"string"}},"manifest":{"description":"An object containing content and name or a string to the absolute path of the JSON manifest to be loaded upon compilation","oneOf":[{"$ref":"#/definitions/DllReferencePluginOptionsManifest"},{"type":"string","absolutePath":true}]},"name":{"description":"The name where the dll is exposed (external name, defaults to manifest.name)","type":"string","minLength":1},"scope":{"description":"Prefix which is used for accessing the content of the dll","type":"string","minLength":1},"sourceType":{"description":"How the dll is exposed (libraryTarget, defaults to manifest.type)","anyOf":[{"$ref":"#/definitions/DllReferencePluginOptionsSourceType"}]},"type":{"description":"The way how the export of the dll bundle is used","enum":["require","object"]}},"required":["manifest"]},{"type":"object","additionalProperties":false,"properties":{"content":{"description":"The mappings from request to module info","anyOf":[{"$ref":"#/definitions/DllReferencePluginOptionsContent"}]},"context":{"description":"(absolute path) context of requests in the manifest (or content property)","type":"string","absolutePath":true},"extensions":{"description":"Extensions used to resolve modules in the dll bundle (only used when using \'scope\')","type":"array","items":{"description":"An extension","type":"string"}},"name":{"description":"The name where the dll is exposed (external name)","type":"string","minLength":1},"scope":{"description":"Prefix which is used for accessing the content of the dll","type":"string","minLength":1},"sourceType":{"description":"How the dll is exposed (libraryTarget)","anyOf":[{"$ref":"#/definitions/DllReferencePluginOptionsSourceType"}]},"type":{"description":"The way how the export of the dll bundle is used","enum":["require","object"]}},"required":["content","name"]}]}'
);

},
// 336
function(module, exports, __webpack_require__) {

const WebpackError = __webpack_require__(1);
const DefinePlugin = __webpack_require__(71);

const needsEnvVarFix =
	["8", "9"].indexOf(process.versions.node.split(".")[0]) >= 0 &&
	process.platform === "win32";

class EnvironmentPlugin {
	constructor(...keys) {
		if (keys.length === 1 && Array.isArray(keys[0])) {
			this.keys = keys[0];
			this.defaultValues = {};
		} else if (keys.length === 1 && keys[0] && typeof keys[0] == "object") {
			this.keys = Object.keys(keys[0]);
			this.defaultValues = keys[0];
		} else {
			this.keys = keys;
			this.defaultValues = {};
		}
	}

	apply(compiler) {
		const definitions = this.keys.reduce((defs, key) => {
			if (needsEnvVarFix) __webpack_require__(337).cpus();

			const value =
				process.env[key] !== void 0
					? process.env[key]
					: this.defaultValues[key];

			if (value === void 0) {
				compiler.hooks.thisCompilation.tap("EnvironmentPlugin", compilation => {
					const error = new WebpackError(
						`EnvironmentPlugin - ${key} environment variable is undefined.\n\nYou can pass an object with default values to suppress this warning.\nSee https://webpack.js.org/plugins/environment-plugin for example.`
					);

					error.name = "EnvVariableNotDefinedError";
					compilation.warnings.push(error);
				});
			}

			defs[`process.env.${key}`] =
				value === void 0 ? "undefined" : JSON.stringify(value);

			return defs;
		}, {});

		new DefinePlugin(definitions).apply(compiler);
	}
}

module.exports = EnvironmentPlugin;

},
// 337
function(module) {

module.exports = require("os");

},
// 338
function(module, exports, __webpack_require__) {

const Template = __webpack_require__(2);
const ConstDependency = __webpack_require__(5);
const ParserHelpers = __webpack_require__(9);
const NullFactory = __webpack_require__(10);

const REPLACEMENTS = {
	__webpack_hash__: "__webpack_require__.h",
	__webpack_chunkname__: "__webpack_require__.cn"
};
const REPLACEMENT_TYPES = {
	__webpack_hash__: "string",
	__webpack_chunkname__: "string"
};

class ExtendedAPIPlugin {
	apply(compiler) {
		compiler.hooks.compilation.tap(
			"ExtendedAPIPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(ConstDependency, new NullFactory());
				compilation.dependencyTemplates.set(
					ConstDependency,
					new ConstDependency.Template()
				);

				const mainTemplate = compilation.mainTemplate;
				mainTemplate.hooks.requireExtensions.tap(
					"ExtendedAPIPlugin",
					(source, chunk, hash) => {
						const buf = [source];
						buf.push("");
						buf.push("// __webpack_hash__");
						buf.push(`${mainTemplate.requireFn}.h = ${JSON.stringify(hash)};`);
						buf.push("");
						buf.push("// __webpack_chunkname__");
						buf.push(
							`${mainTemplate.requireFn}.cn = ${JSON.stringify(chunk.name)};`
						);
						return Template.asString(buf);
					}
				);
				mainTemplate.hooks.globalHash.tap("ExtendedAPIPlugin", () => true);

				const handler = (parser, parserOptions) => {
					Object.keys(REPLACEMENTS).forEach(key => {
						parser.hooks.expression
							.for(key)
							.tap(
								"ExtendedAPIPlugin",
								ParserHelpers.toConstantDependencyWithWebpackRequire(
									parser,
									REPLACEMENTS[key]
								)
							);
						parser.hooks.evaluateTypeof
							.for(key)
							.tap(
								"ExtendedAPIPlugin",
								ParserHelpers.evaluateToString(REPLACEMENT_TYPES[key])
							);
					});
				};

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("ExtendedAPIPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("ExtendedAPIPlugin", handler);
				normalModuleFactory.hooks.parser
					.for("javascript/esm")
					.tap("ExtendedAPIPlugin", handler);
			}
		);
	}
}

module.exports = ExtendedAPIPlugin;

},
// 339
function(module, exports, __webpack_require__) {

const { SyncBailHook } = __webpack_require__(6);
const { RawSource } = __webpack_require__(0);
const Template = __webpack_require__(2);
const ModuleHotAcceptDependency = __webpack_require__(131);
const ModuleHotDeclineDependency = __webpack_require__(132);
const ConstDependency = __webpack_require__(5);
const NullFactory = __webpack_require__(10);
const ParserHelpers = __webpack_require__(9);

module.exports = class {
	constructor(options) {
		this.options = options || {};
		this.multiStep = this.options.multiStep;
		this.fullBuildTimeout = this.options.fullBuildTimeout || 200;
		this.requestTimeout = this.options.requestTimeout || 10000;
	}

	apply(compiler) {
		const multiStep = this.multiStep;
		const fullBuildTimeout = this.fullBuildTimeout;
		const requestTimeout = this.requestTimeout;
		const hotUpdateChunkFilename =
			compiler.options.output.hotUpdateChunkFilename;
		const hotUpdateMainFilename = compiler.options.output.hotUpdateMainFilename;
		compiler.hooks.additionalPass.tapAsync(
			"HotModuleReplacementPlugin",
			callback => {
				if (multiStep) return setTimeout(callback, fullBuildTimeout);
				return callback();
			}
		);

		const addParserPlugins = (parser, parserOptions) => {
			parser.hooks.expression
				.for("__webpack_hash__")
				.tap(
					"HotModuleReplacementPlugin",
					ParserHelpers.toConstantDependencyWithWebpackRequire(
						parser,
						"__webpack_require__.h()"
					)
				);
			parser.hooks.evaluateTypeof
				.for("__webpack_hash__")
				.tap(
					"HotModuleReplacementPlugin",
					ParserHelpers.evaluateToString("string")
				);
			parser.hooks.evaluateIdentifier.for("module.hot").tap(
				{
					name: "HotModuleReplacementPlugin",
					before: "NodeStuffPlugin"
				},
				expr => {
					return ParserHelpers.evaluateToIdentifier(
						"module.hot",
						!!parser.state.compilation.hotUpdateChunkTemplate
					)(expr);
				}
			);
			if (!parser.hooks.hotAcceptCallback) {
				parser.hooks.hotAcceptCallback = new SyncBailHook([
					"expression",
					"requests"
				]);
			}
			if (!parser.hooks.hotAcceptWithoutCallback) {
				parser.hooks.hotAcceptWithoutCallback = new SyncBailHook([
					"expression",
					"requests"
				]);
			}
			parser.hooks.call
				.for("module.hot.accept")
				.tap("HotModuleReplacementPlugin", expr => {
					if (!parser.state.compilation.hotUpdateChunkTemplate) {
						return false;
					}
					if (expr.arguments.length >= 1) {
						const arg = parser.evaluateExpression(expr.arguments[0]);
						let params = [];
						let requests = [];
						if (arg.isString()) {
							params = [arg];
						} else if (arg.isArray()) {
							params = arg.items.filter(param => param.isString());
						}
						if (params.length > 0) {
							params.forEach((param, idx) => {
								const request = param.string;
								const dep = new ModuleHotAcceptDependency(request, param.range);
								dep.optional = true;
								dep.loc = Object.create(expr.loc);
								dep.loc.index = idx;
								parser.state.module.addDependency(dep);
								requests.push(request);
							});
							if (expr.arguments.length > 1) {
								parser.hooks.hotAcceptCallback.call(
									expr.arguments[1],
									requests
								);
								parser.walkExpression(expr.arguments[1]);
								return true;
							} else {
								parser.hooks.hotAcceptWithoutCallback.call(expr, requests);
								return true;
							}
						}
					}
				});
			parser.hooks.call
				.for("module.hot.decline")
				.tap("HotModuleReplacementPlugin", expr => {
					if (!parser.state.compilation.hotUpdateChunkTemplate) {
						return false;
					}
					if (expr.arguments.length === 1) {
						const arg = parser.evaluateExpression(expr.arguments[0]);
						let params = [];
						if (arg.isString()) {
							params = [arg];
						} else if (arg.isArray()) {
							params = arg.items.filter(param => param.isString());
						}
						params.forEach((param, idx) => {
							const dep = new ModuleHotDeclineDependency(
								param.string,
								param.range
							);
							dep.optional = true;
							dep.loc = Object.create(expr.loc);
							dep.loc.index = idx;
							parser.state.module.addDependency(dep);
						});
					}
				});
			parser.hooks.expression
				.for("module.hot")
				.tap("HotModuleReplacementPlugin", ParserHelpers.skipTraversal);
		};

		compiler.hooks.compilation.tap(
			"HotModuleReplacementPlugin",
			(compilation, { normalModuleFactory }) => {
				if (compilation.compiler !== compiler) return;

				const hotUpdateChunkTemplate = compilation.hotUpdateChunkTemplate;
				if (!hotUpdateChunkTemplate) return;

				compilation.dependencyFactories.set(ConstDependency, new NullFactory());
				compilation.dependencyTemplates.set(
					ConstDependency,
					new ConstDependency.Template()
				);

				compilation.dependencyFactories.set(
					ModuleHotAcceptDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					ModuleHotAcceptDependency,
					new ModuleHotAcceptDependency.Template()
				);

				compilation.dependencyFactories.set(
					ModuleHotDeclineDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					ModuleHotDeclineDependency,
					new ModuleHotDeclineDependency.Template()
				);

				compilation.hooks.record.tap(
					"HotModuleReplacementPlugin",
					(compilation, records) => {
						if (records.hash === compilation.hash) return;
						records.hash = compilation.hash;
						records.moduleHashs = {};
						for (const module of compilation.modules) {
							const identifier = module.identifier();
							records.moduleHashs[identifier] = module.hash;
						}
						records.chunkHashs = {};
						for (const chunk of compilation.chunks) {
							records.chunkHashs[chunk.id] = chunk.hash;
						}
						records.chunkModuleIds = {};
						for (const chunk of compilation.chunks) {
							records.chunkModuleIds[chunk.id] = Array.from(
								chunk.modulesIterable,
								m => m.id
							);
						}
					}
				);
				let initialPass = false;
				let recompilation = false;
				compilation.hooks.afterHash.tap("HotModuleReplacementPlugin", () => {
					let records = compilation.records;
					if (!records) {
						initialPass = true;
						return;
					}
					if (!records.hash) initialPass = true;
					const preHash = records.preHash || "x";
					const prepreHash = records.prepreHash || "x";
					if (preHash === compilation.hash) {
						recompilation = true;
						compilation.modifyHash(prepreHash);
						return;
					}
					records.prepreHash = records.hash || "x";
					records.preHash = compilation.hash;
					compilation.modifyHash(records.prepreHash);
				});
				compilation.hooks.shouldGenerateChunkAssets.tap(
					"HotModuleReplacementPlugin",
					() => {
						if (multiStep && !recompilation && !initialPass) return false;
					}
				);
				compilation.hooks.needAdditionalPass.tap(
					"HotModuleReplacementPlugin",
					() => {
						if (multiStep && !recompilation && !initialPass) return true;
					}
				);
				compilation.hooks.additionalChunkAssets.tap(
					"HotModuleReplacementPlugin",
					() => {
						const records = compilation.records;
						if (records.hash === compilation.hash) return;
						if (
							!records.moduleHashs ||
							!records.chunkHashs ||
							!records.chunkModuleIds
						)
							return;
						for (const module of compilation.modules) {
							const identifier = module.identifier();
							let hash = module.hash;
							module.hotUpdate = records.moduleHashs[identifier] !== hash;
						}
						const hotUpdateMainContent = {
							h: compilation.hash,
							c: {}
						};
						for (const key of Object.keys(records.chunkHashs)) {
							const chunkId = isNaN(+key) ? key : +key;
							const currentChunk = compilation.chunks.find(
								chunk => `${chunk.id}` === key
							);
							if (currentChunk) {
								const newModules = currentChunk
									.getModules()
									.filter(module => module.hotUpdate);
								const allModules = new Set();
								for (const module of currentChunk.modulesIterable) {
									allModules.add(module.id);
								}
								const removedModules = records.chunkModuleIds[chunkId].filter(
									id => !allModules.has(id)
								);
								if (newModules.length > 0 || removedModules.length > 0) {
									const source = hotUpdateChunkTemplate.render(
										chunkId,
										newModules,
										removedModules,
										compilation.hash,
										compilation.moduleTemplates.javascript,
										compilation.dependencyTemplates
									);
									const {
										path: filename,
										info: assetInfo
									} = compilation.getPathWithInfo(hotUpdateChunkFilename, {
										hash: records.hash,
										chunk: currentChunk
									});
									compilation.additionalChunkAssets.push(filename);
									compilation.emitAsset(
										filename,
										source,
										Object.assign({ hotModuleReplacement: true }, assetInfo)
									);
									hotUpdateMainContent.c[chunkId] = true;
									currentChunk.files.push(filename);
									compilation.hooks.chunkAsset.call(currentChunk, filename);
								}
							} else {
								hotUpdateMainContent.c[chunkId] = false;
							}
						}
						const source = new RawSource(JSON.stringify(hotUpdateMainContent));
						const {
							path: filename,
							info: assetInfo
						} = compilation.getPathWithInfo(hotUpdateMainFilename, {
							hash: records.hash
						});
						compilation.emitAsset(
							filename,
							source,
							Object.assign({ hotModuleReplacement: true }, assetInfo)
						);
					}
				);

				const mainTemplate = compilation.mainTemplate;

				mainTemplate.hooks.hash.tap("HotModuleReplacementPlugin", hash => {
					hash.update("HotMainTemplateDecorator");
				});

				mainTemplate.hooks.moduleRequire.tap(
					"HotModuleReplacementPlugin",
					(_, chunk, hash, varModuleId) => {
						return `hotCreateRequire(${varModuleId})`;
					}
				);

				mainTemplate.hooks.requireExtensions.tap(
					"HotModuleReplacementPlugin",
					source => {
						const buf = [source];
						buf.push("");
						buf.push("// __webpack_hash__");
						buf.push(
							mainTemplate.requireFn +
								".h = function() { return hotCurrentHash; };"
						);
						return Template.asString(buf);
					}
				);

				const needChunkLoadingCode = chunk => {
					for (const chunkGroup of chunk.groupsIterable) {
						if (chunkGroup.chunks.length > 1) return true;
						if (chunkGroup.getNumberOfChildren() > 0) return true;
					}
					return false;
				};

				mainTemplate.hooks.bootstrap.tap(
					"HotModuleReplacementPlugin",
					(source, chunk, hash) => {
						source = mainTemplate.hooks.hotBootstrap.call(source, chunk, hash);
						return Template.asString([
							source,
							"",
							hotInitCode
								.replace(/\$require\$/g, mainTemplate.requireFn)
								.replace(/\$hash\$/g, JSON.stringify(hash))
								.replace(/\$requestTimeout\$/g, requestTimeout)
								.replace(
									/\/\*foreachInstalledChunks\*\//g,
									needChunkLoadingCode(chunk)
										? "for(var chunkId in installedChunks)"
										: `var chunkId = ${JSON.stringify(chunk.id)};`
								)
						]);
					}
				);

				mainTemplate.hooks.globalHash.tap(
					"HotModuleReplacementPlugin",
					() => true
				);

				mainTemplate.hooks.currentHash.tap(
					"HotModuleReplacementPlugin",
					(_, length) => {
						if (isFinite(length)) {
							return `hotCurrentHash.substr(0, ${length})`;
						} else {
							return "hotCurrentHash";
						}
					}
				);

				mainTemplate.hooks.moduleObj.tap(
					"HotModuleReplacementPlugin",
					(source, chunk, hash, varModuleId) => {
						return Template.asString([
							`${source},`,
							`hot: hotCreateModule(${varModuleId}),`,
							"parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),",
							"children: []"
						]);
					}
				);

				normalModuleFactory.hooks.parser
					.for("javascript/auto")
					.tap("HotModuleReplacementPlugin", addParserPlugins);
				normalModuleFactory.hooks.parser
					.for("javascript/dynamic")
					.tap("HotModuleReplacementPlugin", addParserPlugins);

				compilation.hooks.normalModuleLoader.tap(
					"HotModuleReplacementPlugin",
					context => {
						context.hot = true;
					}
				);
			}
		);
	}
};

const hotInitCode = Template.getFunctionContent(
	__webpack_require__(340)
);

},
// 340
function(module) {

var $hash$ = void 0,
	$requestTimeout$ = void 0,
	installedModules = void 0,
	$require$ = void 0,
	hotDownloadManifest = void 0,
	hotDownloadUpdateChunk = void 0,
	hotDisposeChunk = void 0,
	modules = void 0,
	chunkId = void 0;

module.exports = function() {
	var hotApplyOnUpdate = true,
		hotCurrentHash = $hash$,
		hotRequestTimeout = $requestTimeout$,
		hotCurrentModuleData = {},
		hotCurrentChildModule,
		hotCurrentParents = [],
		hotCurrentParentsTemp = [];

	function hotCreateRequire(moduleId) {
		var me = installedModules[moduleId];
		if (!me) return $require$;
		var fn = function(request) {
			if (me.hot.active) {
				if (installedModules[request])
					installedModules[request].parents.indexOf(moduleId) > -1 ||
						installedModules[request].parents.push(moduleId);
				else {
					hotCurrentParents = [moduleId];
					hotCurrentChildModule = request;
				}
				me.children.indexOf(request) > -1 || me.children.push(request);
			} else {
				console.warn(
					"[HMR] unexpected require(" + request + ") from disposed module " + moduleId
				);
				hotCurrentParents = [];
			}
			return $require$(request);
		};
		var ObjectFactory = function(name) {
			return {
				configurable: true,
				enumerable: true,
				get: function() {
					return $require$[name];
				},
				set: function(value) {
					$require$[name] = value;
				}
			};
		};
		for (var name in $require$) {
			if (
				Object.prototype.hasOwnProperty.call($require$, name) &&
				name !== "e" &&
				name !== "t"
			) {
				Object.defineProperty(fn, name, ObjectFactory(name));
			}
		}
		fn.e = function(chunkId) {
			if (hotStatus === "ready") hotSetStatus("prepare");
			hotChunksLoading++;
			return $require$.e(chunkId).then(finishChunkLoading, function(err) {
				finishChunkLoading();
				throw err;
			});

			function finishChunkLoading() {
				hotChunksLoading--;
				if (hotStatus === "prepare") {
					if (!hotWaitingFilesMap[chunkId]) {
						hotEnsureUpdateChunk(chunkId);
					}
					if (hotChunksLoading === 0 && hotWaitingFiles === 0) {
						hotUpdateDownloaded();
					}
				}
			}
		};
		fn.t = function(value, mode) {
			if (mode & 1) value = fn(value);
			return $require$.t(value, mode & ~1);
		};
		return fn;
	}

	function hotCreateModule(moduleId) {
		var hot = {
			_acceptedDependencies: {},
			_declinedDependencies: {},
			_selfAccepted: false,
			_selfDeclined: false,
			_selfInvalidated: false,
			_disposeHandlers: [],
			_main: hotCurrentChildModule !== moduleId,

			active: true,
			accept: function(dep, callback) {
				if (dep === void 0) hot._selfAccepted = true;
				else if (typeof dep == "function") hot._selfAccepted = dep;
				else if (typeof dep == "object")
					for (var i = 0; i < dep.length; i++)
						hot._acceptedDependencies[dep[i]] = callback || function() {};
				else hot._acceptedDependencies[dep] = callback || function() {};
			},
			decline: function(dep) {
				if (dep === void 0) hot._selfDeclined = true;
				else if (typeof dep == "object")
					for (var i = 0; i < dep.length; i++)
						hot._declinedDependencies[dep[i]] = true;
				else hot._declinedDependencies[dep] = true;
			},
			dispose: function(callback) {
				hot._disposeHandlers.push(callback);
			},
			addDisposeHandler: function(callback) {
				hot._disposeHandlers.push(callback);
			},
			removeDisposeHandler: function(callback) {
				var idx = hot._disposeHandlers.indexOf(callback);
				if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
			},
			invalidate: function() {
				this._selfInvalidated = true;
				switch (hotStatus) {
					case "idle":
						hotUpdate = {};
						hotUpdate[moduleId] = modules[moduleId];
						hotSetStatus("ready");
						break;
					case "ready":
						hotApplyInvalidatedModule(moduleId);
						break;
					case "prepare":
					case "check":
					case "dispose":
					case "apply":
						(hotQueuedInvalidatedModules =
							hotQueuedInvalidatedModules || []).push(moduleId);
						break;
					default:
						break;
				}
			},

			check: hotCheck,
			apply: hotApply,
			status: function(l) {
				if (!l) return hotStatus;
				hotStatusHandlers.push(l);
			},
			addStatusHandler: function(l) {
				hotStatusHandlers.push(l);
			},
			removeStatusHandler: function(l) {
				var idx = hotStatusHandlers.indexOf(l);
				if (idx >= 0) hotStatusHandlers.splice(idx, 1);
			},

			data: hotCurrentModuleData[moduleId]
		};
		hotCurrentChildModule = void 0;
		return hot;
	}

	var hotStatusHandlers = [];
	var hotStatus = "idle";

	function hotSetStatus(newStatus) {
		hotStatus = newStatus;
		for (var i = 0; i < hotStatusHandlers.length; i++)
			hotStatusHandlers[i].call(null, newStatus);
	}

	var hotWaitingFiles = 0;
	var hotChunksLoading = 0;
	var hotWaitingFilesMap = {};
	var hotRequestedFilesMap = {};
	var hotAvailableFilesMap = {};
	var hotDeferred;

	var hotUpdate, hotUpdateNewHash, hotQueuedInvalidatedModules;

	function toModuleId(id) {
		var isNumber = +id + "" === id;
		return isNumber ? +id : id;
	}

	function hotCheck(apply) {
		if (hotStatus !== "idle") {
			throw new Error("check() is only allowed in idle status");
		}
		hotApplyOnUpdate = apply;
		hotSetStatus("check");
		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
			if (!update) {
				hotSetStatus(hotApplyInvalidatedModules() ? "ready" : "idle");
				return null;
			}
			hotRequestedFilesMap = {};
			hotWaitingFilesMap = {};
			hotAvailableFilesMap = update.c;
			hotUpdateNewHash = update.h;

			hotSetStatus("prepare");
			var promise = new Promise(function(resolve, reject) {
				hotDeferred = {
					resolve: resolve,
					reject: reject
				};
			});
			hotUpdate = {};
			{
				hotEnsureUpdateChunk(chunkId);
			}
			if (
				hotStatus === "prepare" &&
				hotChunksLoading === 0 &&
				hotWaitingFiles === 0
			) {
				hotUpdateDownloaded();
			}
			return promise;
		});
	}

	function hotAddUpdateChunk(chunkId, moreModules) {
		if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
			return;
		hotRequestedFilesMap[chunkId] = false;
		for (var moduleId in moreModules) {
			if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
				hotUpdate[moduleId] = moreModules[moduleId];
			}
		}
		if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
			hotUpdateDownloaded();
		}
	}

	function hotEnsureUpdateChunk(chunkId) {
		if (!hotAvailableFilesMap[chunkId]) {
			hotWaitingFilesMap[chunkId] = true;
		} else {
			hotRequestedFilesMap[chunkId] = true;
			hotWaitingFiles++;
			hotDownloadUpdateChunk(chunkId);
		}
	}

	function hotUpdateDownloaded() {
		hotSetStatus("ready");
		var deferred = hotDeferred;
		hotDeferred = null;
		if (!deferred) return;
		if (hotApplyOnUpdate) {
			Promise.resolve()
				.then(function() {
					return hotApply(hotApplyOnUpdate);
				})
				.then(
					function(result) {
						deferred.resolve(result);
					},
					function(err) {
						deferred.reject(err);
					}
				);
		} else {
			var outdatedModules = [];
			for (var id in hotUpdate) {
				if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
					outdatedModules.push(toModuleId(id));
				}
			}
			deferred.resolve(outdatedModules);
		}
	}

	function hotApply(options) {
		if (hotStatus !== "ready")
			throw new Error("apply() is only allowed in ready status");
		options = options || {};
		return hotApplyInternal(options);
	}

	function hotApplyInternal(options) {
		hotApplyInvalidatedModules();

		var cb;
		var i;
		var j;
		var module;
		var moduleId;

		function getAffectedStuff(updateModuleId) {
			var outdatedModules = [updateModuleId];
			var outdatedDependencies = {};

			var queue = outdatedModules.map(function(id) {
				return {
					chain: [id],
					id: id
				};
			});
			while (queue.length > 0) {
				var queueItem = queue.pop();
				var moduleId = queueItem.id;
				var chain = queueItem.chain;
				module = installedModules[moduleId];
				if (
					!module ||
					(module.hot._selfAccepted && !module.hot._selfInvalidated)
				)
					continue;
				if (module.hot._selfDeclined) {
					return {
						type: "self-declined",
						chain: chain,
						moduleId: moduleId
					};
				}
				if (module.hot._main) {
					return {
						type: "unaccepted",
						chain: chain,
						moduleId: moduleId
					};
				}
				for (var i = 0; i < module.parents.length; i++) {
					var parentId = module.parents[i];
					var parent = installedModules[parentId];
					if (!parent) continue;
					if (parent.hot._declinedDependencies[moduleId]) {
						return {
							type: "declined",
							chain: chain.concat([parentId]),
							moduleId: moduleId,
							parentId: parentId
						};
					}
					if (outdatedModules.indexOf(parentId) > -1) continue;
					if (parent.hot._acceptedDependencies[moduleId]) {
						if (!outdatedDependencies[parentId])
							outdatedDependencies[parentId] = [];
						addAllToSet(outdatedDependencies[parentId], [moduleId]);
						continue;
					}
					delete outdatedDependencies[parentId];
					outdatedModules.push(parentId);
					queue.push({
						chain: chain.concat([parentId]),
						id: parentId
					});
				}
			}

			return {
				type: "accepted",
				moduleId: updateModuleId,
				outdatedModules: outdatedModules,
				outdatedDependencies: outdatedDependencies
			};
		}

		function addAllToSet(a, b) {
			for (var i = 0; i < b.length; i++) {
				var item = b[i];
				a.indexOf(item) > -1 || a.push(item);
			}
		}

		var outdatedDependencies = {},
			outdatedModules = [],
			appliedUpdate = {};

		var warnUnexpectedRequire = function() {
			console.warn(
				"[HMR] unexpected require(" + result.moduleId + ") to disposed module"
			);
		};

		for (var id in hotUpdate) {
			if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
				moduleId = toModuleId(id);
				var result;
				if (hotUpdate[id]) {
					result = getAffectedStuff(moduleId);
				} else {
					result = {
						type: "disposed",
						moduleId: id
					};
				}
				var abortError = false;
				var doApply = false;
				var doDispose = false;
				var chainInfo = "";
				if (result.chain) {
					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
				}
				switch (result.type) {
					case "self-declined":
						if (options.onDeclined) options.onDeclined(result);
						if (!options.ignoreDeclined)
							abortError = new Error(
								"Aborted because of self decline: " +
									result.moduleId +
									chainInfo
							);
						break;
					case "declined":
						if (options.onDeclined) options.onDeclined(result);
						if (!options.ignoreDeclined)
							abortError = new Error(
								"Aborted because of declined dependency: " +
									result.moduleId +
									" in " +
									result.parentId +
									chainInfo
							);
						break;
					case "unaccepted":
						if (options.onUnaccepted) options.onUnaccepted(result);
						if (!options.ignoreUnaccepted)
							abortError = new Error(
								"Aborted because " + moduleId + " is not accepted" + chainInfo
							);
						break;
					case "accepted":
						if (options.onAccepted) options.onAccepted(result);
						doApply = true;
						break;
					case "disposed":
						if (options.onDisposed) options.onDisposed(result);
						doDispose = true;
						break;
					default:
						throw new Error("Unexception type " + result.type);
				}
				if (abortError) {
					hotSetStatus("abort");
					return Promise.reject(abortError);
				}
				if (doApply) {
					appliedUpdate[moduleId] = hotUpdate[moduleId];
					addAllToSet(outdatedModules, result.outdatedModules);
					for (moduleId in result.outdatedDependencies) {
						if (
							Object.prototype.hasOwnProperty.call(
								result.outdatedDependencies,
								moduleId
							)
						) {
							if (!outdatedDependencies[moduleId])
								outdatedDependencies[moduleId] = [];
							addAllToSet(
								outdatedDependencies[moduleId],
								result.outdatedDependencies[moduleId]
							);
						}
					}
				}
				if (doDispose) {
					addAllToSet(outdatedModules, [result.moduleId]);
					appliedUpdate[moduleId] = warnUnexpectedRequire;
				}
			}
		}

		var outdatedSelfAcceptedModules = [];
		for (i = 0; i < outdatedModules.length; i++) {
			moduleId = outdatedModules[i];
			if (
				installedModules[moduleId] &&
				installedModules[moduleId].hot._selfAccepted &&
				appliedUpdate[moduleId] !== warnUnexpectedRequire &&
				!installedModules[moduleId].hot._selfInvalidated
			) {
				outdatedSelfAcceptedModules.push({
					module: moduleId,
					parents: installedModules[moduleId].parents.slice(),
					errorHandler: installedModules[moduleId].hot._selfAccepted
				});
			}
		}

		hotSetStatus("dispose");
		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
			if (hotAvailableFilesMap[chunkId] === false) {
				hotDisposeChunk(chunkId);
			}
		});

		var idx,
			queue = outdatedModules.slice();
		while (queue.length > 0) {
			moduleId = queue.pop();
			module = installedModules[moduleId];
			if (!module) continue;

			var data = {};

			var disposeHandlers = module.hot._disposeHandlers;
			for (j = 0; j < disposeHandlers.length; j++) {
				cb = disposeHandlers[j];
				cb(data);
			}
			hotCurrentModuleData[moduleId] = data;

			module.hot.active = false;

			delete installedModules[moduleId];

			delete outdatedDependencies[moduleId];

			for (j = 0; j < module.children.length; j++) {
				var child = installedModules[module.children[j]];
				if (!child) continue;
				idx = child.parents.indexOf(moduleId);
				if (idx >= 0) {
					child.parents.splice(idx, 1);
				}
			}
		}

		var dependency, moduleOutdatedDependencies;
		for (moduleId in outdatedDependencies)
			if (Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
				module = installedModules[moduleId];
				if (module) {
					moduleOutdatedDependencies = outdatedDependencies[moduleId];// TODO
					for (j = 0; j < moduleOutdatedDependencies.length; j++) {
						dependency = moduleOutdatedDependencies[j];
						idx = module.children.indexOf(dependency);
						idx < 0 || module.children.splice(idx, 1);
					}
				}
			}

		hotSetStatus("apply");

		if (hotUpdateNewHash !== void 0) {
			hotCurrentHash = hotUpdateNewHash;
			hotUpdateNewHash = void 0;
		}
		hotUpdate = void 0;

		for (moduleId in appliedUpdate)
			if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId))
				modules[moduleId] = appliedUpdate[moduleId];

		var error = null;
		for (moduleId in outdatedDependencies)
			if (Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
				module = installedModules[moduleId];
				if (!module) continue;

				moduleOutdatedDependencies = outdatedDependencies[moduleId];
				var callbacks = [];
				for (i = 0; i < moduleOutdatedDependencies.length; i++) {
					dependency = moduleOutdatedDependencies[i];
					cb = module.hot._acceptedDependencies[dependency];
					if (cb) {
						if (callbacks.indexOf(cb) > -1) continue;
						callbacks.push(cb);
					}
				}
				for (i = 0; i < callbacks.length; i++) {
					cb = callbacks[i];
					try {
						cb(moduleOutdatedDependencies);
					} catch (err) {
						options.onErrored &&
							options.onErrored({
								type: "accept-errored",
								moduleId: moduleId,
								dependencyId: moduleOutdatedDependencies[i],
								error: err
							});

						options.ignoreErrored || error || (error = err);
					}
				}
			}

		for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
			var item = outdatedSelfAcceptedModules[i];
			moduleId = item.module;
			hotCurrentParents = item.parents;
			hotCurrentChildModule = moduleId;
			try {
				$require$(moduleId);
			} catch (err) {
				if (typeof item.errorHandler == "function")
					try {
						item.errorHandler(err);
					} catch (err2) {
						options.onErrored &&
							options.onErrored({
								type: "self-accept-error-handler-errored",
								moduleId: moduleId,
								error: err2,
								originalError: err
							});

						options.ignoreErrored || error || (error = err2);

						error || (error = err);
					}
				else {
					options.onErrored &&
						options.onErrored({ type: "self-accept-errored", moduleId: moduleId, error: err });

					options.ignoreErrored || error || (error = err);
				}
			}
		}

		if (error) {
			hotSetStatus("fail");
			return Promise.reject(error);
		}

		if (hotQueuedInvalidatedModules)
			return hotApplyInternal(options).then(function(list) {
				outdatedModules.forEach(function(moduleId) {
					list.indexOf(moduleId) < 0 && list.push(moduleId);
				});
				return list;
			});

		hotSetStatus("idle");
		return new Promise(function(resolve) {
			resolve(outdatedModules);
		});
	}

	function hotApplyInvalidatedModules() {
		if (hotQueuedInvalidatedModules) {
			hotUpdate || (hotUpdate = {});
			hotQueuedInvalidatedModules.forEach(hotApplyInvalidatedModule);
			hotQueuedInvalidatedModules = void 0;
			return true;
		}
	}

	function hotApplyInvalidatedModule(moduleId) {
		Object.prototype.hasOwnProperty.call(hotUpdate, moduleId) ||
			(hotUpdate[moduleId] = modules[moduleId]);
	}
};

},
// 341
function(module, exports, __webpack_require__) {

const validateOptions = __webpack_require__(8),
	schema = __webpack_require__(342);

class IgnorePlugin {
	constructor(options) {
		if (arguments.length > 1 || options instanceof RegExp)
			options = { resourceRegExp: arguments[0], contextRegExp: arguments[1] };

		validateOptions(schema, options, "IgnorePlugin");
		this.options = options;

		this.checkIgnore = this.checkIgnore.bind(this);
	}

	checkIgnore(result) {
		if (!result) return result;

		if (
			"checkResource" in this.options &&
			this.options.checkResource &&
			this.options.checkResource(result.request, result.context)
		) {
			if (!("checkContext" in this.options && this.options.checkContext)) return null;

			if (this.options.checkContext(result.context)) return null;
		}

		if (
			"resourceRegExp" in this.options &&
			this.options.resourceRegExp &&
			this.options.resourceRegExp.test(result.request)
		) {
			if (!("contextRegExp" in this.options && this.options.contextRegExp)) return null;

			if (this.options.contextRegExp.test(result.context)) return null;
		}

		return result;
	}

	apply(compiler) {
		compiler.hooks.normalModuleFactory.tap("IgnorePlugin", nmf => {
			nmf.hooks.beforeResolve.tap("IgnorePlugin", this.checkIgnore);
		});
		compiler.hooks.contextModuleFactory.tap("IgnorePlugin", cmf => {
			cmf.hooks.beforeResolve.tap("IgnorePlugin", this.checkIgnore);
		});
	}
}

module.exports = IgnorePlugin;

},
// 342
function(module) {

module.exports = JSON.parse(
	'{"title":"IgnorePluginOptions","oneOf":[{"type":"object","additionalProperties":false,"properties":{"contextRegExp":{"description":"A RegExp to test the context (directory) against","instanceof":"RegExp","tsType":"RegExp"},"resourceRegExp":{"description":"A RegExp to test the request against","instanceof":"RegExp","tsType":"RegExp"}}},{"type":"object","additionalProperties":false,"properties":{"checkContext":{"description":"A filter function for context","instanceof":"Function","tsType":"((context: string) => boolean)"},"checkResource":{"description":"A filter function for resource and context","instanceof":"Function","tsType":"((resource: string, context: string) => boolean)"}}}]}'
);

},
// 343
function(module, exports, __webpack_require__) {

const ModuleFilenameHelpers = __webpack_require__(18),

	validateOptions = __webpack_require__(8),
	schema = __webpack_require__(344);

class LoaderOptionsPlugin {
	constructor(options) {
		validateOptions(schema, options || {}, "Loader Options Plugin");

		if (typeof options != "object") options = {};
		options.test || (options.test = { test: () => true });

		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		compiler.hooks.compilation.tap("LoaderOptionsPlugin", compilation => {
			compilation.hooks.normalModuleLoader.tap(
				"LoaderOptionsPlugin",
				(context, module) => {
					const resource = module.resource;
					if (!resource) return;
					const i = resource.indexOf("?");
					if (
						ModuleFilenameHelpers.matchObject(
							options,
							i < 0 ? resource : resource.substr(0, i)
						)
					)
						for (const key of Object.keys(options))
							if (key !== "include" && key !== "exclude" && key !== "test")
								context[key] = options[key];
				}
			);
		});
	}
}

module.exports = LoaderOptionsPlugin;

},
// 344
function(module) {

module.exports = JSON.parse(
	'{"title":"LoaderOptionsPluginOptions","type":"object","additionalProperties":true,"properties":{"debug":{"description":"Whether loaders should be in debug mode or not. debug will be removed as of webpack 3","type":"boolean"},"minimize":{"description":"Where loaders can be switched to minimize mode","type":"boolean"},"options":{"description":"A configuration object that can be used to configure older loaders","type":"object","additionalProperties":true,"properties":{"context":{"description":"The context that can be used to configure older loaders","type":"string","absolutePath":true}}}}}'
);

},
// 345
function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(346);

},
// 346
function(module, exports, __webpack_require__) {

const normalize = __webpack_require__(150),
	join = __webpack_require__(347),
	MemoryFileSystemError = __webpack_require__(348),
	errors = __webpack_require__(349),
	stream = __webpack_require__(352),

	ReadableStream = stream.Readable,
	WritableStream = stream.Writable;

function isDir(item) {
	return typeof item == "object" && item[""] === true;
}

function isFile(item) {
	return typeof item == "object" && !item[""];
}

function pathToArray(path) {
	path = normalize(path);
	if (/^\//.test(path)) path = path.replace(/\/+/g, "/").substr(1).split("/");
	else {
		if (!/^[A-Za-z]:/.test(path))
			throw new MemoryFileSystemError(errors.code.EINVAL, path);

		path = path.replace(/[\\\/]+/g, "\\").split(/[\\\/]/);
		path[0] = path[0].toUpperCase();
	}
	path[path.length - 1] || path.pop();
	return path;
}

function trueFn() { return true; }
function falseFn() { return false; }

class MemoryFileSystem {
	constructor(data) {
		this.data = data || {};
		this.join = join;
		this.pathToArray = pathToArray;
		this.normalize = normalize;
	}

	meta(_path) {
		const path = pathToArray(_path);
		let current = this.data,
			i = 0;
		for (; i < path.length - 1; i++) {
			if (!isDir(current[path[i]])) return;
			current = current[path[i]];
		}
		return current[path[i]];
	}

	existsSync(_path) {
		return !!this.meta(_path);
	}

	statSync(_path) {
		let current = this.meta(_path);
		if (_path === "/" || isDir(current))
			return {
				isFile: falseFn,
				isDirectory: trueFn,
				isBlockDevice: falseFn,
				isCharacterDevice: falseFn,
				isSymbolicLink: falseFn,
				isFIFO: falseFn,
				isSocket: falseFn
			};
		if (isFile(current))
			return {
				isFile: trueFn,
				isDirectory: falseFn,
				isBlockDevice: falseFn,
				isCharacterDevice: falseFn,
				isSymbolicLink: falseFn,
				isFIFO: falseFn,
				isSocket: falseFn
			};

		throw new MemoryFileSystemError(errors.code.ENOENT, _path, "stat");
	}

	readFileSync(_path, optionsOrEncoding) {
		const path = pathToArray(_path);
		let current = this.data,
			i = 0
		for (; i < path.length - 1; i++) {
			if (!isDir(current[path[i]]))
				throw new MemoryFileSystemError(errors.code.ENOENT, _path, "readFile");
			current = current[path[i]];
		}
		if (!isFile(current[path[i]]))
			throw isDir(current[path[i]])
				? new MemoryFileSystemError(errors.code.EISDIR, _path, "readFile")
				: new MemoryFileSystemError(errors.code.ENOENT, _path, "readFile");

		current = current[path[i]];
		const encoding = typeof optionsOrEncoding == "object" ? optionsOrEncoding.encoding : optionsOrEncoding;
		return encoding ? current.toString(encoding) : current;
	}

	readdirSync(_path) {
		if (_path === "/") return Object.keys(this.data).filter(Boolean);
		const path = pathToArray(_path);
		let current = this.data,
			i = 0;
		for (; i < path.length - 1; i++) {
			if (!isDir(current[path[i]]))
				throw new MemoryFileSystemError(errors.code.ENOENT, _path, "readdir");
			current = current[path[i]];
		}
		if (!isDir(current[path[i]]))
			throw isFile(current[path[i]])
				? new MemoryFileSystemError(errors.code.ENOTDIR, _path, "readdir")
				: new MemoryFileSystemError(errors.code.ENOENT, _path, "readdir");

		return Object.keys(current[path[i]]).filter(Boolean);
	}

	mkdirpSync(_path) {
		const path = pathToArray(_path);
		if (path.length === 0) return;
		for (let current = this.data, i = 0; i < path.length; i++) {
			if (isFile(current[path[i]]))
				throw new MemoryFileSystemError(errors.code.ENOTDIR, _path, "mkdirp");
			isDir(current[path[i]]) || (current[path[i]] = { "": true });
			current = current[path[i]];
		}
	}

	mkdirSync(_path) {
		const path = pathToArray(_path);
		if (path.length === 0) return;
		let current = this.data,
			i = 0;
		for (; i < path.length - 1; i++) {
			if (!isDir(current[path[i]]))
				throw new MemoryFileSystemError(errors.code.ENOENT, _path, "mkdir");
			current = current[path[i]];
		}
		if (isDir(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.EEXIST, _path, "mkdir");
		if (isFile(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOTDIR, _path, "mkdir");
		current[path[i]] = { "": true };
	}

	_remove(_path, name, testFn) {
		const path = pathToArray(_path),
			operation = name === "File" ? "unlink" : "rmdir";
		if (path.length === 0)
			throw new MemoryFileSystemError(errors.code.EPERM, _path, operation);

		let current = this.data,
			i = 0;
		for (; i < path.length - 1; i++) {
			if (!isDir(current[path[i]]))
				throw new MemoryFileSystemError(errors.code.ENOENT, _path, operation);
			current = current[path[i]];
		}
		if (!testFn(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.ENOENT, _path, operation);
		delete current[path[i]];
	}

	rmdirSync(_path) {
		return this._remove(_path, "Directory", isDir);
	}

	unlinkSync(_path) {
		return this._remove(_path, "File", isFile);
	}

	readlinkSync(_path) {
		throw new MemoryFileSystemError(errors.code.ENOSYS, _path, "readlink");
	}

	writeFileSync(_path, content, optionsOrEncoding) {
		if (!content && !optionsOrEncoding) throw new Error("No content");
		const path = pathToArray(_path);
		if (path.length === 0)
			throw new MemoryFileSystemError(errors.code.EISDIR, _path, "writeFile");

		let current = this.data,
			i = 0
		for (; i < path.length - 1; i++) {
			if (!isDir(current[path[i]]))
				throw new MemoryFileSystemError(errors.code.ENOENT, _path, "writeFile");
			current = current[path[i]];
		}
		if (isDir(current[path[i]]))
			throw new MemoryFileSystemError(errors.code.EISDIR, _path, "writeFile");
		const encoding = typeof optionsOrEncoding == "object" ? optionsOrEncoding.encoding : optionsOrEncoding;
		current[path[i]] = optionsOrEncoding || typeof content == "string"
			? new Buffer(content, encoding)
			: content;
	}

	createReadStream(path, options) {
		let data,
			stream = new ReadableStream(),
			done = false;
		try {
			data = this.readFileSync(path);
		} catch (e) {
			stream._read = function() {
				if (done) return;

				done = true;
				this.emit('error', e);
				this.push(null);
			};
			return stream;
		}
		options = options || {};
		options.start = options.start || 0;
		options.end = options.end || data.length;
		stream._read = function() {
			if (done) return;

			done = true;
			this.push(data.slice(options.start, options.end));
			this.push(null);
		};
		return stream;
	}

	createWriteStream(path) {
		let stream = new WritableStream();
		try {
			this.writeFileSync(path, new Buffer(0));
		} catch (e) {
			stream.once('prefinish', function() {
				stream.emit('error', e);
			});
			return stream;
		}
		let bl = [], len = 0;
		stream._write = (chunk, encoding, callback) => {
			bl.push(chunk);
			len += chunk.length;
			this.writeFile(path, Buffer.concat(bl, len), callback);
		};
		return stream;
	}

	exists(path, callback) {
		return callback(this.existsSync(path));
	}

	writeFile(path, content, encoding, callback) {
		if (!callback) {
			callback = encoding;
			encoding = void 0;
		}
		try {
			this.writeFileSync(path, content, encoding);
		} catch (e) {
			return callback(e);
		}
		return callback();
	}
}

["stat", "readdir", "mkdirp", "rmdir", "unlink", "readlink"].forEach(function(fn) {
	MemoryFileSystem.prototype[fn] = function(path, callback) {
		let result;
		try {
			result = this[fn + "Sync"](path);
		} catch (e) {
			setImmediate(function() {
				callback(e);
			});

			return;
		}
		setImmediate(function() {
			callback(null, result);
		});
	};
});

["mkdir", "readFile"].forEach(function(fn) {
	MemoryFileSystem.prototype[fn] = function(path, optArg, callback) {
		if (!callback) {
			callback = optArg;
			optArg = void 0;
		}
		let result;
		try {
			result = this[fn + "Sync"](path, optArg);
		} catch (e) {
			setImmediate(function() {
				callback(e);
			});

			return;
		}
		setImmediate(function() {
			callback(null, result);
		});
	};
});

module.exports = MemoryFileSystem;

},
// 347
function(module, exports, __webpack_require__) {

const normalize = __webpack_require__(150),

	absoluteWinRegExp = /^[A-Z]:([\\\/]|$)/i,
	absoluteNixRegExp = /^\//i;

module.exports = function(path, request) {
	return !request ? normalize(path)
		: absoluteWinRegExp.test(request) ? normalize(request.replace(/\//g, "\\"))
		: absoluteNixRegExp.test(request) ? normalize(request)
		: path == "/" ? normalize(path + request)
		: absoluteWinRegExp.test(path)
		? normalize(path.replace(/\//g, "\\") + "\\" + request.replace(/\//g, "\\"))
		: normalize(path + "/" + request);
};

},
// 348
function(module) {

class MemoryFileSystemError extends Error {
	constructor(err, path, operation) {
		super(err, path);

		this.name = this.constructor.name;
		var message = [err.code + ":", err.description + ","];
		operation && message.push(operation);

		message.push(`'${path}'`);
		this.message = message.join(' ');

		this.code = err.code;
		this.errno = err.errno;
		this.path = path;
		this.operation = operation;

		Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
	}
}

module.exports = MemoryFileSystemError;

},
// 349
function(module, exports, __webpack_require__) {

var all = (module.exports.all = [
	{ errno: -2, code: 'ENOENT', description: 'no such file or directory' },
	{ errno: -1, code: 'UNKNOWN', description: 'unknown error' },
	{ errno: 0, code: 'OK', description: 'success' },
	{ errno: 1, code: 'EOF', description: 'end of file' },
	{ errno: 2, code: 'EADDRINFO', description: 'getaddrinfo error' },
	{ errno: 3, code: 'EACCES', description: 'permission denied' },
	{ errno: 4, code: 'EAGAIN', description: 'resource temporarily unavailable' },
	{ errno: 5, code: 'EADDRINUSE', description: 'address already in use' },
	{ errno: 6, code: 'EADDRNOTAVAIL', description: 'address not available' },
	{ errno: 7, code: 'EAFNOSUPPORT', description: 'address family not supported' },
	{ errno: 8, code: 'EALREADY', description: 'connection already in progress' },
	{ errno: 9, code: 'EBADF', description: 'bad file descriptor' },
	{ errno: 10, code: 'EBUSY', description: 'resource busy or locked' },
	{ errno: 11, code: 'ECONNABORTED', description: 'software caused connection abort' },
	{ errno: 12, code: 'ECONNREFUSED', description: 'connection refused' },
	{ errno: 13, code: 'ECONNRESET', description: 'connection reset by peer' },
	{ errno: 14, code: 'EDESTADDRREQ', description: 'destination address required' },
	{ errno: 15, code: 'EFAULT', description: 'bad address in system call argument' },
	{ errno: 16, code: 'EHOSTUNREACH', description: 'host is unreachable' },
	{ errno: 17, code: 'EINTR', description: 'interrupted system call' },
	{ errno: 18, code: 'EINVAL', description: 'invalid argument' },
	{ errno: 19, code: 'EISCONN', description: 'socket is already connected' },
	{ errno: 20, code: 'EMFILE', description: 'too many open files' },
	{ errno: 21, code: 'EMSGSIZE', description: 'message too long' },
	{ errno: 22, code: 'ENETDOWN', description: 'network is down' },
	{ errno: 23, code: 'ENETUNREACH', description: 'network is unreachable' },
	{ errno: 24, code: 'ENFILE', description: 'file table overflow' },
	{ errno: 25, code: 'ENOBUFS', description: 'no buffer space available' },
	{ errno: 26, code: 'ENOMEM', description: 'not enough memory' },
	{ errno: 27, code: 'ENOTDIR', description: 'not a directory' },
	{ errno: 28, code: 'EISDIR', description: 'illegal operation on a directory' },
	{ errno: 29, code: 'ENONET', description: 'machine is not on the network' },
	{ errno: 31, code: 'ENOTCONN', description: 'socket is not connected' },
	{ errno: 32, code: 'ENOTSOCK', description: 'socket operation on non-socket' },
	{ errno: 33, code: 'ENOTSUP', description: 'operation not supported on socket' },
	{ errno: 34, code: 'ENOENT', description: 'no such file or directory' },
	{ errno: 35, code: 'ENOSYS', description: 'function not implemented' },
	{ errno: 36, code: 'EPIPE', description: 'broken pipe' },
	{ errno: 37, code: 'EPROTO', description: 'protocol error' },
	{ errno: 38, code: 'EPROTONOSUPPORT', description: 'protocol not supported' },
	{ errno: 39, code: 'EPROTOTYPE', description: 'protocol wrong type for socket' },
	{ errno: 40, code: 'ETIMEDOUT', description: 'connection timed out' },
	{ errno: 41, code: 'ECHARSET', description: 'invalid Unicode character' },
	{ errno: 42, code: 'EAIFAMNOSUPPORT', description: 'address family for hostname not supported' },
	{ errno: 44, code: 'EAISERVICE', description: 'servname not supported for ai_socktype' },
	{ errno: 45, code: 'EAISOCKTYPE', description: 'ai_socktype not supported' },
	{ errno: 46, code: 'ESHUTDOWN', description: 'cannot send after transport endpoint shutdown' },
	{ errno: 47, code: 'EEXIST', description: 'file already exists' },
	{ errno: 48, code: 'ESRCH', description: 'no such process' },
	{ errno: 49, code: 'ENAMETOOLONG', description: 'name too long' },
	{ errno: 50, code: 'EPERM', description: 'operation not permitted' },
	{ errno: 51, code: 'ELOOP', description: 'too many symbolic links encountered' },
	{ errno: 52, code: 'EXDEV', description: 'cross-device link not permitted' },
	{ errno: 53, code: 'ENOTEMPTY', description: 'directory not empty' },
	{ errno: 54, code: 'ENOSPC', description: 'no space left on device' },
	{ errno: 55, code: 'EIO', description: 'i/o error' },
	{ errno: 56, code: 'EROFS', description: 'read-only file system' },
	{ errno: 57, code: 'ENODEV', description: 'no such device' },
	{ errno: 58, code: 'ESPIPE', description: 'invalid seek' },
	{ errno: 59, code: 'ECANCELED', description: 'operation canceled' }
])

module.exports.errno = {}
module.exports.code = {}

all.forEach(function(error) {
	module.exports.errno[error.errno] = error
	module.exports.code[error.code] = error
})

module.exports.custom = __webpack_require__(350)(module.exports)
module.exports.create = module.exports.custom.createError

},
// 350
function(module, exports, __webpack_require__) {

var prr = __webpack_require__(351)

function init(type, message, cause) {
	if (!!message && typeof message != 'string')
		message = message.message || message.name

	prr(this, {
		type: type,
		name: type,
		cause: typeof message != 'string' ? message : cause,
		message: message
	}, 'ewr')
}

function CustomError(message, cause) {
	Error.call(this)
	Error.captureStackTrace && Error.captureStackTrace(this, this.constructor)
	init.call(this, 'CustomError', message, cause)
}

CustomError.prototype = new Error()

function createError(errno, type, proto) {
	var err = function(message, cause) {
		init.call(this, type, message, cause)
		if (type == 'FilesystemError') {
			this.code = this.cause.code
			this.path = this.cause.path
			this.errno = this.cause.errno
			this.message =
				(errno.errno[this.cause.errno]
					? errno.errno[this.cause.errno].description
					: this.cause.message) +
				(this.cause.path ? ' [' + this.cause.path + ']' : '')
		}
		Error.call(this)
		Error.captureStackTrace && Error.captureStackTrace(this, err)
	}
	err.prototype = !!proto ? new proto() : new CustomError()
	return err
}

module.exports = function(errno) {
	var ce = function(type, proto) {
		return createError(errno, type, proto)
	}
	return { CustomError: CustomError, FilesystemError: ce('FilesystemError'), createError: ce }
}

},
// 351
function(module) {

var setProperty = typeof Object.defineProperty == 'function'
	? function(obj, key, options) {
			Object.defineProperty(obj, key, options)
			return obj
		}
	: function(obj, key, options) {
			obj[key] = options.value
			return obj
		}

var makeOptions = function(value, options) {
	var oo = typeof options == 'object',
		os = !oo && typeof options == 'string',
		op = function(p) {
			return oo ? !!options[p] : !!os && options.indexOf(p[0]) > -1
		}

	return {
		enumerable: op('enumerable'),
		configurable: op('configurable'),
		writable: op('writable'),
		value: value
	}
}

var prr = function(obj, key, value, options) {
	options = makeOptions(value, options)

	if (typeof key == 'object') {
		for (var k in key)
			if (Object.prototype.hasOwnProperty.call(key, k)) {
				options.value = key[k]
				setProperty(obj, k, options)
			}

		return obj
	}

	return setProperty(obj, key, options)
}

module.exports = prr

},
// 352
function(module) {

module.exports = require("../vendor/readable-stream");

},
// 353
function(module, exports, __webpack_require__) {

const path = __webpack_require__(3);

class NormalModuleReplacementPlugin {
	constructor(resourceRegExp, newResource) {
		this.resourceRegExp = resourceRegExp;
		this.newResource = newResource;
	}

	apply(compiler) {
		const resourceRegExp = this.resourceRegExp,
			newResource = this.newResource;
		compiler.hooks.normalModuleFactory.tap("NormalModuleReplacementPlugin", nmf => {
			nmf.hooks.beforeResolve.tap("NormalModuleReplacementPlugin", result => {
				if (!result) return;
				if (resourceRegExp.test(result.request))
					typeof newResource == "function"
						? newResource(result)
						: (result.request = newResource);

				return result;
			});
			nmf.hooks.afterResolve.tap("NormalModuleReplacementPlugin", result => {
				if (!result) return;
				if (resourceRegExp.test(result.resource))
					typeof newResource == "function"
						? newResource(result)
						: (result.resource = path.resolve(path.dirname(result.resource), newResource));

				return result;
			});
		});
	}
}

module.exports = NormalModuleReplacementPlugin;

},
// 354
function(module, exports, __webpack_require__) {

const PrefetchDependency = __webpack_require__(147);

class PrefetchPlugin {
	constructor(context, request) {
		if (request) {
			this.context = context;
			this.request = request;
		} else this.request = context;
	}

	apply(compiler) {
		compiler.hooks.compilation.tap(
			"PrefetchPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					PrefetchDependency,
					normalModuleFactory
				);
			}
		);
		compiler.hooks.make.tapAsync("PrefetchPlugin", (compilation, callback) => {
			compilation.prefetch(
				this.context || compiler.context,
				new PrefetchDependency(this.request),
				callback
			);
		});
	}
}
module.exports = PrefetchPlugin;

},
// 355
function(module, exports, __webpack_require__) {

const validateOptions = __webpack_require__(8),
	schema = __webpack_require__(356);

const createDefaultHandler = (profile, logger) => {
	let lastState, lastStateTime;

	return (percentage, msg, ...args) => {
		logger.status(Math.floor(percentage * 100) + "%", msg, ...args);
		if (profile) {
			let state = msg;
			state = state.replace(/^\d+\/\d+\s+/, "");
			if (percentage === 0) {
				lastState = null;
				lastStateTime = Date.now();
			} else if (state !== lastState || percentage === 1) {
				const now = Date.now();
				if (lastState) {
					const diff = now - lastStateTime,
						stateMsg = `${diff}ms ${lastState}`;
					diff > 1000
						? logger.warn(stateMsg)
						: diff > 10
						? logger.info(stateMsg)
						: diff > 0
						? logger.log(stateMsg)
						: logger.debug(stateMsg);
				}
				lastState = state;
				lastStateTime = now;
			}
		}
		percentage !== 1 || logger.status();
	};
};

class ProgressPlugin {
	constructor(options) {
		if (typeof options == "function") options = { handler: options };

		options = options || {};
		validateOptions(schema, options, "Progress Plugin");
		options = Object.assign({}, ProgressPlugin.defaultOptions, options);

		this.profile = options.profile;
		this.handler = options.handler;
		this.modulesCount = options.modulesCount;
		this.showEntries = options.entries;
		this.showModules = options.modules;
		this.showActiveModules = options.activeModules;
	}

	apply(compiler) {
		const { modulesCount } = this,
			handler =
				this.handler ||
				createDefaultHandler(this.profile, compiler.getInfrastructureLogger("webpack.Progress")),
			showEntries = this.showEntries,
			showModules = this.showModules,
			showActiveModules = this.showActiveModules;
		if (compiler.compilers) {
			const states = new Array(compiler.compilers.length);
			compiler.compilers.forEach((compiler, idx) => {
				new ProgressPlugin((p, msg, ...args) => {
					states[idx] = [p, msg, ...args];
					handler(
						states
							.map(state => (state && state[0]) || 0)
							.reduce((a, b) => a + b) / states.length,
						`[${idx}] ${msg}`,
						...args
					);
				}).apply(compiler);
			});
		} else {
			let lastModulesCount = 0,
				lastEntriesCount = 0,
				moduleCount = modulesCount,
				entriesCount = 1,
				doneModules = 0,
				doneEntries = 0;
			const activeModules = new Set();
			let lastActiveModule = "";

			const update = () => {
				const percentByModules = doneModules / Math.max(lastModulesCount, moduleCount),
					percentByEntries = doneEntries / Math.max(lastEntriesCount, entriesCount),

					items = [0.1 + Math.max(percentByModules, percentByEntries) * 0.6, "building"];
				showEntries && items.push(`${doneEntries}/${entriesCount} entries`);

				showModules && items.push(`${doneModules}/${moduleCount} modules`);

				if (showActiveModules) {
					items.push(activeModules.size + " active");
					items.push(lastActiveModule);
				}
				handler(...items);
			};

			const moduleAdd = module => {
				moduleCount++;
				if (showActiveModules) {
					const ident = module.identifier();
					if (ident) {
						activeModules.add(ident);
						lastActiveModule = ident;
					}
				}
				update();
			};

			const entryAdd = (entry, name) => {
				entriesCount++;
				update();
			};

			const moduleDone = module => {
				doneModules++;
				if (showActiveModules) {
					const ident = module.identifier();
					if (ident) {
						activeModules.delete(ident);
						if (lastActiveModule === ident) {
							lastActiveModule = "";
							for (const m of activeModules) lastActiveModule = m;
						}
					}
				}
				update();
			};

			const entryDone = (entry, name) => {
				doneEntries++;
				update();
			};

			compiler.hooks.compilation.tap("ProgressPlugin", compilation => {
				if (compilation.compiler.isChild()) return;
				lastModulesCount = moduleCount;
				lastEntriesCount = entriesCount;
				moduleCount = entriesCount = 0;
				doneModules = doneEntries = 0;
				handler(0, "compiling");

				compilation.hooks.buildModule.tap("ProgressPlugin", moduleAdd);
				compilation.hooks.failedModule.tap("ProgressPlugin", moduleDone);
				compilation.hooks.succeedModule.tap("ProgressPlugin", moduleDone);

				compilation.hooks.addEntry.tap("ProgressPlugin", entryAdd);
				compilation.hooks.failedEntry.tap("ProgressPlugin", entryDone);
				compilation.hooks.succeedEntry.tap("ProgressPlugin", entryDone);

				const hooks = {
					finishModules: "finish module graph",
					seal: "sealing",
					beforeChunks: "chunk graph",
					afterChunks: "after chunk graph",
					optimizeDependenciesBasic: "basic dependencies optimization",
					optimizeDependencies: "dependencies optimization",
					optimizeDependenciesAdvanced: "advanced dependencies optimization",
					afterOptimizeDependencies: "after dependencies optimization",
					optimize: "optimizing",
					optimizeModulesBasic: "basic module optimization",
					optimizeModules: "module optimization",
					optimizeModulesAdvanced: "advanced module optimization",
					afterOptimizeModules: "after module optimization",
					optimizeChunksBasic: "basic chunk optimization",
					optimizeChunks: "chunk optimization",
					optimizeChunksAdvanced: "advanced chunk optimization",
					afterOptimizeChunks: "after chunk optimization",
					optimizeTree: "module and chunk tree optimization",
					afterOptimizeTree: "after module and chunk tree optimization",
					optimizeChunkModulesBasic: "basic chunk modules optimization",
					optimizeChunkModules: "chunk modules optimization",
					optimizeChunkModulesAdvanced: "advanced chunk modules optimization",
					afterOptimizeChunkModules: "after chunk modules optimization",
					reviveModules: "module reviving",
					optimizeModuleOrder: "module order optimization",
					advancedOptimizeModuleOrder: "advanced module order optimization",
					beforeModuleIds: "before module ids",
					moduleIds: "module ids",
					optimizeModuleIds: "module id optimization",
					afterOptimizeModuleIds: "module id optimization",
					reviveChunks: "chunk reviving",
					optimizeChunkOrder: "chunk order optimization",
					beforeChunkIds: "before chunk ids",
					optimizeChunkIds: "chunk id optimization",
					afterOptimizeChunkIds: "after chunk id optimization",
					recordModules: "record modules",
					recordChunks: "record chunks",
					beforeHash: "hashing",
					afterHash: "after hashing",
					recordHash: "record hash",
					beforeModuleAssets: "module assets processing",
					beforeChunkAssets: "chunk assets processing",
					additionalChunkAssets: "additional chunk assets processing",
					record: "recording",
					additionalAssets: "additional asset processing",
					optimizeChunkAssets: "chunk asset optimization",
					afterOptimizeChunkAssets: "after chunk asset optimization",
					optimizeAssets: "asset optimization",
					afterOptimizeAssets: "after asset optimization",
					afterSeal: "after seal"
				};
				const numberOfHooks = Object.keys(hooks).length;
				Object.keys(hooks).forEach((name, idx) => {
					const title = hooks[name],
						percentage = (idx / numberOfHooks) * 0.25 + 0.7;
					compilation.hooks[name].intercept({
						name: "ProgressPlugin",
						context: true,
						call: () => {
							handler(percentage, title);
						},
						tap: (context, tap) => {
							if (context)
								context.reportProgress = (p, ...args) => {
									handler(percentage, title, tap.name, ...args);
								};

							handler(percentage, title, tap.name);
						}
					});
				});
			});
			compiler.hooks.emit.intercept({
				name: "ProgressPlugin",
				context: true,
				call: () => {
					handler(0.95, "emitting");
				},
				tap: (context, tap) => {
					if (context)
						context.reportProgress = (p, ...args) => {
							handler(0.95, "emitting", tap.name, ...args);
						};

					handler(0.95, "emitting", tap.name);
				}
			});
			compiler.hooks.afterEmit.intercept({
				name: "ProgressPlugin",
				context: true,
				call: () => {
					handler(0.98, "after emitting");
				},
				tap: (context, tap) => {
					if (context)
						context.reportProgress = (p, ...args) => {
							handler(0.98, "after emitting", tap.name, ...args);
						};

					handler(0.98, "after emitting", tap.name);
				}
			});
			compiler.hooks.done.tap("ProgressPlugin", () => {
				handler(1, "");
			});
		}
	}
}

ProgressPlugin.defaultOptions = {
	profile: false,
	modulesCount: 500,
	modules: true,
	activeModules: true,
	entries: false
};

module.exports = ProgressPlugin;

},
// 356
function(module) {

module.exports = JSON.parse(
	'{"definitions":{"HandlerFunction":{"description":"Function that executes for every progress step","instanceof":"Function","tsType":"((percentage: number, msg: string, ...args: string[]) => void)"},"ProgressPluginOptions":{"type":"object","additionalProperties":false,"properties":{"activeModules":{"description":"Show active modules count and one active module in progress message","type":"boolean"},"entries":{"description":"Show entries count in progress message","type":"boolean"},"handler":{"description":"Function that executes for every progress step","anyOf":[{"$ref":"#/definitions/HandlerFunction"}]},"modules":{"description":"Show modules count in progress message","type":"boolean"},"modulesCount":{"description":"Minimum modules count to start with. Only for mode=modules. Default: 500","type":"number"},"profile":{"description":"Collect profile data for progress steps. Default: false","enum":[true,false,null]}}}},"title":"ProgressPluginArgument","oneOf":[{"$ref":"#/definitions/ProgressPluginOptions"},{"$ref":"#/definitions/HandlerFunction"}]}'
);

},
// 357
function(module, exports, __webpack_require__) {

const ParserHelpers = __webpack_require__(9),
	ConstDependency = __webpack_require__(5),

	NullFactory = __webpack_require__(10);

class ProvidePlugin {
	constructor(definitions) {
		this.definitions = definitions;
	}

	apply(compiler) {
		const definitions = this.definitions;
		compiler.hooks.compilation.tap("ProvidePlugin", (compilation, { normalModuleFactory }) => {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(
				ConstDependency,
				new ConstDependency.Template()
			);
			const handler = (parser, parserOptions) => {
				Object.keys(definitions).forEach(name => {
					var request = [].concat(definitions[name]),
						splittedName = name.split(".");
					if (splittedName.length > 0)
						splittedName.slice(1).forEach((_, i) => {
							const name = splittedName.slice(0, i + 1).join(".");
							parser.hooks.canRename
								.for(name)
								.tap("ProvidePlugin", ParserHelpers.approve);
						});

					parser.hooks.expression.for(name).tap("ProvidePlugin", expr => {
						let nameIdentifier = name;
						const scopedName = name.includes(".");
						let expression = `require(${JSON.stringify(request[0])})`;
						if (scopedName)
							nameIdentifier = "__webpack_provided_" + name.replace(/\./g, "_dot_");

						if (request.length > 1)
							expression += request
								.slice(1)
								.map(r => `[${JSON.stringify(r)}]`)
								.join("");

						if (
							!ParserHelpers.addParsedVariableToModule(
								parser,
								nameIdentifier,
								expression
							)
						)
							return false;

						scopedName &&
							ParserHelpers.toConstantDependency(parser, nameIdentifier)(expr);

						return true;
					});
				});
			};
			normalModuleFactory.hooks.parser
				.for("javascript/auto")
				.tap("ProvidePlugin", handler);
			normalModuleFactory.hooks.parser
				.for("javascript/dynamic")
				.tap("ProvidePlugin", handler);
		});
	}
}
module.exports = ProvidePlugin;

},
// 358
function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });

var _ConstDependency2 = __webpack_require__(5),
	_NullFactory2 = __webpack_require__(10),

	_MissingLocalizationError2 = __webpack_require__(359).default,
	_MakeLocalizeFunction2 = __webpack_require__(360).default;

class I18nPlugin {
	constructor(localization, options, failOnMissing) {
		if (typeof options == 'string') options = { functionName: options };

		if (failOnMissing !== void 0) options.failOnMissing = failOnMissing;

		this.options = options || {};
		this.localization = localization
			? typeof localization == 'function'
				? localization
				: _MakeLocalizeFunction2(localization, !!this.options.nested)
			: null;
		this.functionName = this.options.functionName || '__';
		this.failOnMissing = !!this.options.failOnMissing;
		this.hideMessage = this.options.hideMessage || false;
	}

	apply(compiler) {
		var localization = this.localization,
			failOnMissing = this.failOnMissing,
			hideMessage = this.hideMessage,

			name = this.functionName;

		compiler.plugin('compilation', function(compilation, params) {
			compilation.dependencyFactories.set(_ConstDependency2, new _NullFactory2());
			compilation.dependencyTemplates.set(_ConstDependency2, new _ConstDependency2.Template());
		});

		compiler.plugin('compilation', function(compilation, data) {
			data.normalModuleFactory.plugin('parser', function(parser, options) {
				parser.plugin("call " + name, function(expr) {
					var param = void 0,
						defaultValue = void 0;
					switch (expr.arguments.length) {
						case 2:
							param = this.evaluateExpression(expr.arguments[1]);
							if (!param.isString()) return;
							param = param.string;
							defaultValue = this.evaluateExpression(expr.arguments[0]);
							if (!defaultValue.isString()) return;
							defaultValue = defaultValue.string;
							break;
						case 1:
							param = this.evaluateExpression(expr.arguments[0]);
							if (!param.isString()) return;
							defaultValue = param = param.string;
							break;
						default:
							return;
					}
					var result = localization ? localization(param) : defaultValue;

					if (result === void 0) {
						var error = this.state.module[__dirname];
						if (error) error.requests.includes(param) || error.add(param, defaultValue);
						else {
							error = new _MissingLocalizationError2(this.state.module, param, defaultValue);
							this.state.module[__dirname] = error;

							failOnMissing
								? this.state.module.errors.push(error)
								: hideMessage || this.state.module.warnings.push(error);
						}

						result = defaultValue;
					}

					var dep = new _ConstDependency2(JSON.stringify(result), expr.range);
					dep.loc = expr.loc;
					this.state.current.addDependency(dep);
					return true;
				});
			});
		});
	}
}

(exports = module.exports = I18nPlugin).default = I18nPlugin;

},
// 359
function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });

class MissingLocalizationError extends Error {
	constructor(module, name, value) {
		super();

		Error.captureStackTrace(this, MissingLocalizationError);
		this.name = 'MissingLocalizationError';
		this.requests = [{ name, value }];
		this.module = module;
		Object.setPrototypeOf(this, MissingLocalizationError.prototype);
		this._buildMessage();
	}

	_buildMessage() {
		this.message = this.requests.map(function(request) {
			return request.name === request.value
				? "Missing localization: " + request.name
				: `Missing localization: (${request.name}) ${request.value}`;
		}).join('\n');
	}

	add(name, value) {
		for (var i = 0; i < this.requests.length; i++)
			if (this.requests[i].name === name) return;

		this.requests.push({ name, value });
		this._buildMessage();
	}
}

exports.default = MissingLocalizationError;

},
// 360
function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
function makeLocalizeFunction(localization, nested) {
	return function(key) {
		return nested ? byString(localization, key) : localization[key];
	};
}

function byString(object, string) {
	var keysArray = string.replace(/^\./, '').split('.');
	for (var i = 0, length = keysArray.length; i < length; ++i) {
		var key = keysArray[i];

		if (!(key in object)) return;

		object = object[key];
	}

	return object;
}

exports.default = makeLocalizeFunction;

},
// 361
function(module) {

module.exports = require("./copy-plugin");

},
// 362
function(module, exports, __webpack_require__) {

const { ReplaceSource } = __webpack_require__(0),
	validateOptions = __webpack_require__(8);

const schema = {
	type: 'array',
	minItems: 1,
	items: {
		type: 'object',
		additionalProperties: false,
		properties: {
			search: { anyOf: [{ type: 'string', minLength: 1 }, { instanceof: 'RegExp' }] },
			replace: { anyOf: [{ type: 'string' }, { instanceof: 'Function' }] },
			test: { instanceof: 'RegExp' }
		},
		required: ['search', 'replace']
	}
};

const searchReplacements = (str, patterns) => {
	const indices = [];

	patterns.forEach(({ search, replace }) => {
		if (typeof search == 'string') {
			const i = str.indexOf(search);
			if (i >= 0) indices.push({ start: i, end: i + search.length - 1, replace });
		} else {
			const re = new RegExp(search.source, search.flags);

			str.replace(search, (m, ...args) => {
				if (typeof args.pop() === 'object') args.pop();
				const k = args.pop();

				indices.push({ start: k, end: k + m.length - 1, replace: m.replace(re, replace) });
				return '';
			});
		}
	});

	return indices;
};

class ReplaceCodePlugin {
	constructor(options) {
		this.options = Array.isArray(options) ? options : [options];

		validateOptions(schema, this.options, 'ReplaceCode Plugin');
	}

	apply(compiler) {
		const options = this.options;

		compiler.hooks.compilation.tap('ReplaceCodePlugin', (compilation) => {
			compilation.hooks.optimizeChunkAssets.tap('ReplaceCodePlugin', (chunks) => {
				for (const chunk of chunks)
					for (const file of chunk.files) {
						const filtered = options.filter(({ test }) => !test || test.test(file));
						if (!filtered.length) continue;

						const patterns = filtered.map(({ search, replace }) => ({ search, replace }));

						compilation.updateAsset(file, (old) => {
							const indices = searchReplacements(old.source(), patterns),

								source = new ReplaceSource(old);
							indices.forEach(({ start, end, replace }) => source.replace(start, end, replace));

							return source;
						});
					}
			});
		});
	}
}

module.exports = ReplaceCodePlugin;

},
// 363
function(module, exports, __webpack_require__) {

const validateOptions = __webpack_require__(8),
	schema = __webpack_require__(364);

class IgnoringWatchFileSystem {
	constructor(wfs, paths) {
		this.wfs = wfs;
		this.paths = paths;
	}

	watch(files, dirs, missing, startTime, options, callback, callbackUndelayed) {
		const ignored = path =>
			this.paths.some(p =>
				p instanceof RegExp ? p.test(path) : path.indexOf(p) === 0
			);

		const notIgnored = path => !ignored(path),

			ignoredFiles = files.filter(ignored),
			ignoredDirs = dirs.filter(ignored);

		const watcher = this.wfs.watch(
			files.filter(notIgnored),
			dirs.filter(notIgnored),
			missing,
			startTime,
			options,
			(
				err,
				filesModified,
				dirsModified,
				missingModified,
				fileTimestamps,
				dirTimestamps,
				removedFiles
			) => {
				if (err) return callback(err);
				for (const path of ignoredFiles) fileTimestamps.set(path, 1);

				for (const path of ignoredDirs) dirTimestamps.set(path, 1);

				callback(
					err,
					filesModified,
					dirsModified,
					missingModified,
					fileTimestamps,
					dirTimestamps,
					removedFiles
				);
			},
			callbackUndelayed
		);

		return {
			close: () => watcher.close(),
			pause: () => watcher.pause(),
			getContextTimestamps: () => {
				const dirTimestamps = watcher.getContextTimestamps();
				for (const path of ignoredDirs) dirTimestamps.set(path, 1);

				return dirTimestamps;
			},
			getFileTimestamps: () => {
				const fileTimestamps = watcher.getFileTimestamps();
				for (const path of ignoredFiles) fileTimestamps.set(path, 1);

				return fileTimestamps;
			}
		};
	}
}

class WatchIgnorePlugin {
	constructor(paths) {
		validateOptions(schema, paths, "Watch Ignore Plugin");
		this.paths = paths;
	}

	apply(compiler) {
		compiler.hooks.afterEnvironment.tap("WatchIgnorePlugin", () => {
			compiler.watchFileSystem = new IgnoringWatchFileSystem(
				compiler.watchFileSystem,
				this.paths
			);
		});
	}
}

module.exports = WatchIgnorePlugin;

},
// 364
function(module) {

module.exports = JSON.parse(
	'{"title":"WatchIgnorePluginOptions","description":"A list of RegExps or absolute paths to directories or files that should be ignored","type":"array","items":{"description":"RegExp or absolute path to directories or files that should be ignored","oneOf":[{"type":"string"},{"instanceof":"RegExp","tsType":"RegExp"}]},"minItems":1}'
);

},
// 365
function(module) {

class AggressiveMergingPlugin {
	constructor(options) {
		if (
			(options !== void 0 && typeof options != "object") ||
			Array.isArray(options)
		)
			throw new Error(
				"Argument should be an options object. To use defaults, pass in nothing.\nFor more info on options, see https://webpack.js.org/plugins/"
			);

		this.options = options || {};
	}

	apply(compiler) {
		const options = this.options,
			minSizeReduce = options.minSizeReduce || 1.5;

		compiler.hooks.thisCompilation.tap("AggressiveMergingPlugin", compilation => {
			compilation.hooks.optimizeChunksAdvanced.tap("AggressiveMergingPlugin", chunks => {
				let combinations = [];
				chunks.forEach((a, idx) => {
					if (!a.canBeInitial())
						for (let i = 0; i < idx; i++) {
							const b = chunks[i];
							b.canBeInitial() || combinations.push({ a, b, improvement: void 0 });
						}
				});

				for (const pair of combinations) {
					const a = pair.b.size({ chunkOverhead: 0 }),
						b = pair.a.size({ chunkOverhead: 0 }),
						ab = pair.b.integratedSize(pair.a, { chunkOverhead: 0 });
					let newSize;
					if (ab === false) {
						pair.improvement = false;
						return;
					}
					newSize = ab;

					pair.improvement = (a + b) / newSize;
				}
				combinations = combinations.filter(pair => pair.improvement !== false);
				combinations.sort((a, b) => b.improvement - a.improvement);

				const pair = combinations[0];

				if (pair && pair.improvement >= minSizeReduce &&
						pair.b.integrate(pair.a, "aggressive-merge")) {
					chunks.splice(chunks.indexOf(pair.a), 1);
					return true;
				}
			});
		});
	}
}

module.exports = AggressiveMergingPlugin;

},
// 366
function(module, exports, __webpack_require__) {

const identifierUtils = __webpack_require__(13),
	{ intersect } = __webpack_require__(30),
	validateOptions = __webpack_require__(8),
	schema = __webpack_require__(367);

const moveModuleBetween = (oldChunk, newChunk) =>
	module => {
		oldChunk.moveModule(module, newChunk);
	};

const isNotAEntryModule = entryModule => module => entryModule !== module;

class AggressiveSplittingPlugin {
	constructor(options) {
		options || (options = {});

		validateOptions(schema, options, "Aggressive Splitting Plugin");

		this.options = options;
		if (typeof this.options.minSize != "number") this.options.minSize = 30720;

		if (typeof this.options.maxSize != "number") this.options.maxSize = 51200;

		if (typeof this.options.chunkOverhead != "number") this.options.chunkOverhead = 0;

		if (typeof this.options.entryChunkMultiplicator != "number")
			this.options.entryChunkMultiplicator = 1;
	}
	apply(compiler) {
		compiler.hooks.thisCompilation.tap("AggressiveSplittingPlugin", compilation => {
			let newSplits,
				fromAggressiveSplittingSet,
				chunkSplitDataMap,
				needAdditionalSeal = false;
			compilation.hooks.optimize.tap("AggressiveSplittingPlugin", () => {
				newSplits = [];
				fromAggressiveSplittingSet = new Set();
				chunkSplitDataMap = new Map();
			});
			compilation.hooks.optimizeChunksAdvanced.tap("AggressiveSplittingPlugin", chunks => {
				const nameToModuleMap = new Map(),
					moduleToNameMap = new Map();
				for (const m of compilation.modules) {
					const name = identifierUtils.makePathsRelative(
						compiler.context,
						m.identifier(),
						compilation.cache
					);
					nameToModuleMap.set(name, m);
					moduleToNameMap.set(m, name);
				}

				const usedIds = new Set();
				for (const chunk of chunks) usedIds.add(chunk.id);

				const recordedSplits =
						(compilation.records && compilation.records.aggressiveSplits) || [],
					usedSplits = newSplits ? recordedSplits.concat(newSplits) : recordedSplits,

					minSize = this.options.minSize,
					maxSize = this.options.maxSize;

				const applySplit = splitData => {
					if (splitData.id !== void 0 && usedIds.has(splitData.id)) return false;

					const selectedModules = splitData.modules.map(name =>
						nameToModuleMap.get(name)
					);

					if (!selectedModules.every(Boolean)) return false;

					const size = selectedModules.reduce((sum, m) => sum + m.size(), 0);
					if (size !== splitData.size) return false;

					const selectedChunks = intersect(
						selectedModules.map(m => new Set(m.chunksIterable))
					);

					if (selectedChunks.size === 0) return false;

					if (
						selectedChunks.size === 1 &&
						Array.from(selectedChunks)[0].getNumberOfModules() === selectedModules.length
					) {
						const chunk = Array.from(selectedChunks)[0];
						if (fromAggressiveSplittingSet.has(chunk)) return false;
						fromAggressiveSplittingSet.add(chunk);
						chunkSplitDataMap.set(chunk, splitData);
						return true;
					}

					const newChunk = compilation.addChunk();
					newChunk.chunkReason = "aggressive splitted";
					for (const chunk of selectedChunks) {
						selectedModules.forEach(moveModuleBetween(chunk, newChunk));
						chunk.split(newChunk);
						chunk.name = null;
					}
					fromAggressiveSplittingSet.add(newChunk);
					chunkSplitDataMap.set(newChunk, splitData);

					if (splitData.id !== null && splitData.id !== void 0)
						newChunk.id = splitData.id;

					return true;
				};

				let changed = false;
				for (let j = 0; j < usedSplits.length; j++)
					if (applySplit(usedSplits[j])) changed = true;

				const sortedChunks = chunks.slice().sort((a, b) => {
					const diff1 = b.modulesSize() - a.modulesSize();
					if (diff1) return diff1;
					const diff2 = a.getNumberOfModules() - b.getNumberOfModules();
					if (diff2) return diff2;
					const modulesA = Array.from(a.modulesIterable),
						modulesB = Array.from(b.modulesIterable);
					modulesA.sort();
					modulesB.sort();
					const aI = modulesA[Symbol.iterator](),
						bI = modulesB[Symbol.iterator]();
					while (1) {
						const aItem = aI.next(),
							bItem = bI.next();
						if (aItem.done) return 0;
						const aModuleIdentifier = aItem.value.identifier(),
							bModuleIdentifier = bItem.value.identifier();
						if (aModuleIdentifier > bModuleIdentifier) return -1;
						if (aModuleIdentifier < bModuleIdentifier) return 1;
					}
				});
				for (const chunk of sortedChunks) {
					if (fromAggressiveSplittingSet.has(chunk)) continue;
					const size = chunk.modulesSize();
					if (!(size > maxSize && chunk.getNumberOfModules() > 1)) continue;

					const modules = chunk
						.getModules()
						.filter(isNotAEntryModule(chunk.entryModule))
						.sort((a, b) =>
							(a = a.identifier()) > (b = b.identifier()) ? 1 : a < b ? -1 : 0
						);
					const selectedModules = [];
					let selectedModulesSize = 0;
					for (let k = 0; k < modules.length; k++) {
						const module = modules[k],
							newSize = selectedModulesSize + module.size();
						if (newSize > maxSize && selectedModulesSize >= minSize) break;

						selectedModulesSize = newSize;
						selectedModules.push(module);
					}
					if (selectedModules.length === 0) continue;
					const splitData = {
						modules: selectedModules.map(m => moduleToNameMap.get(m)).sort(),
						size: selectedModulesSize
					};

					if (applySplit(splitData)) {
						newSplits = (newSplits || []).concat(splitData);
						changed = true;
					}
				}
				if (changed) return true;
			});
			compilation.hooks.recordHash.tap("AggressiveSplittingPlugin", records => {
				const allSplits = new Set(),
					invalidSplits = new Set();

				for (const chunk of compilation.chunks) {
					const splitData = chunkSplitDataMap.get(chunk);
					splitData !== void 0 && splitData.hash && chunk.hash !== splitData.hash &&
						invalidSplits.add(splitData);
				}

				if (invalidSplits.size > 0) {
					records.aggressiveSplits = records.aggressiveSplits.filter(
						splitData => !invalidSplits.has(splitData)
					);
					needAdditionalSeal = true;
				} else {
					for (const chunk of compilation.chunks) {
						const splitData = chunkSplitDataMap.get(chunk);
						if (splitData !== void 0) {
							splitData.hash = chunk.hash;
							splitData.id = chunk.id;
							allSplits.add(splitData);
							chunk.recorded = true;
						}
					}

					const recordedSplits =
						compilation.records && compilation.records.aggressiveSplits;
					if (recordedSplits)
						for (const splitData of recordedSplits)
							invalidSplits.has(splitData) || allSplits.add(splitData);

					records.aggressiveSplits = Array.from(allSplits);

					needAdditionalSeal = false;
				}
			});
			compilation.hooks.needAdditionalSeal.tap("AggressiveSplittingPlugin", () => {
				if (needAdditionalSeal) {
					needAdditionalSeal = false;
					return true;
				}
			});
		});
	}
}
module.exports = AggressiveSplittingPlugin;

},
// 367
function(module) {

module.exports = JSON.parse(
	'{"title":"AggressiveSplittingPluginOptions","type":"object","additionalProperties":false,"properties":{"chunkOverhead":{"description":"Default: 0","type":"number"},"entryChunkMultiplicator":{"description":"Default: 1","type":"number"},"maxSize":{"description":"Byte, maxsize of per file. Default: 51200","type":"number"},"minSize":{"description":"Byte, split point. Default: 30720","type":"number"}}}'
);

},
// 368
function(module) {

const sortByIndex = (a, b) => a.index - b.index,

	sortByIndex2 = (a, b) => a.index2 - b.index2;

class ChunkModuleIdRangePlugin {
	constructor(options) {
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		compiler.hooks.compilation.tap("ChunkModuleIdRangePlugin", compilation => {
			compilation.hooks.moduleIds.tap("ChunkModuleIdRangePlugin", modules => {
				const chunk = compilation.chunks.find(chunk => chunk.name === options.name);
				if (!chunk)
					throw new Error(
						`ChunkModuleIdRangePlugin: Chunk with name '${options.name}"' was not found`
					);

				let chunkModules;
				if (options.order) {
					chunkModules = Array.from(chunk.modulesIterable);
					switch (options.order) {
						case "index":
							chunkModules.sort(sortByIndex);
							break;
						case "index2":
							chunkModules.sort(sortByIndex2);
							break;
						default:
							throw new Error("ChunkModuleIdRangePlugin: unexpected value of order");
					}
				} else chunkModules = modules.filter(m => m.chunksIterable.has(chunk));

				let currentId = options.start || 0;
				for (let i = 0; i < chunkModules.length; i++) {
					const m = chunkModules[i];
					if (m.id === null) m.id = currentId++;

					if (options.end && currentId > options.end) break;
				}
			});
		});
	}
}
module.exports = ChunkModuleIdRangePlugin;

},
// 369
function(module, exports, __webpack_require__) {

const validateOptions = __webpack_require__(8),
	schema = __webpack_require__(370),
	LazyBucketSortedSet = __webpack_require__(371);

const addToSetMap = (map, key, value) => {
	const set = map.get(key);
	set === void 0 ? map.set(key, new Set([value])) : set.add(value);
};

class LimitChunkCountPlugin {
	constructor(options) {
		options || (options = {});

		validateOptions(schema, options, "Limit Chunk Count Plugin");
		this.options = options;
	}

	apply(compiler) {
		const options = this.options;
		compiler.hooks.compilation.tap("LimitChunkCountPlugin", compilation => {
			compilation.hooks.optimizeChunksAdvanced.tap("LimitChunkCountPlugin", chunks => {
				const maxChunks = options.maxChunks;
				if (!maxChunks || maxChunks < 1 || chunks.length <= maxChunks) return;

				let remainingChunksToMerge = chunks.length - maxChunks;

				const orderedChunks = chunks.slice().sort((a, b) => a.compareTo(b));

				const combinations = new LazyBucketSortedSet(
					c => c.sizeDiff,
					(a, b) => b - a,
					c => c.integratedSize,
					(a, b) => a - b,
					c => c.bIdx - c.aIdx,
					(a, b) => a - b,
					(a, b) => a.bIdx - b.bIdx
				);

				const combinationsByChunk = new Map();

				orderedChunks.forEach((b, bIdx) => {
					for (let aIdx = 0; aIdx < bIdx; aIdx++) {
						const a = orderedChunks[aIdx],
							integratedSize = a.integratedSize(b, options);

						if (integratedSize === false) continue;

						const aSize = a.size(options),
							bSize = b.size(options);
						const c = {
							deleted: false,
							sizeDiff: aSize + bSize - integratedSize,
							integratedSize,
							a,
							b,
							aIdx,
							bIdx,
							aSize,
							bSize
						};
						combinations.add(c);
						addToSetMap(combinationsByChunk, a, c);
						addToSetMap(combinationsByChunk, b, c);
					}
					return combinations;
				});

				const modifiedChunks = new Set();

				let changed = false;
				loop: while (1) {
					const combination = combinations.popFirst();
					if (combination === void 0) break;

					combination.deleted = true;
					const { a, b, integratedSize } = combination;

					if (modifiedChunks.size > 0) {
						const queue = new Set(a.groupsIterable);
						for (const group of b.groupsIterable) queue.add(group);

						for (const group of queue) {
							for (const mChunk of modifiedChunks)
								if (mChunk !== a && mChunk !== b && mChunk.isInGroup(group)) {
									remainingChunksToMerge--;
									if (remainingChunksToMerge <= 0) break loop;
									modifiedChunks.add(a);
									modifiedChunks.add(b);
									continue loop;
								}

							for (const parent of group.parentsIterable) queue.add(parent);
						}
					}

					if (a.integrate(b, "limit")) {
						chunks.splice(chunks.indexOf(b), 1);

						modifiedChunks.add(a);

						changed = true;
						remainingChunksToMerge--;
						if (remainingChunksToMerge <= 0) break;

						for (const combination of combinationsByChunk.get(b))
							if (!combination.deleted) {
								combination.deleted = true;
								combinations.delete(combination);
							}

						for (const combination of combinationsByChunk.get(a)) {
							if (combination.deleted) continue;
							if (combination.a === a) {
								const newIntegratedSize = a.integratedSize(combination.b, options);
								if (newIntegratedSize === false) {
									combination.deleted = true;
									combinations.delete(combination);
									continue;
								}
								const finishUpdate = combinations.startUpdate(combination);
								combination.integratedSize = newIntegratedSize;
								combination.aSize = integratedSize;
								combination.sizeDiff =
									combination.bSize + integratedSize - newIntegratedSize;
								finishUpdate();
							} else if (combination.b === a) {
								const newIntegratedSize = combination.a.integratedSize(a, options);
								if (newIntegratedSize === false) {
									combination.deleted = true;
									combinations.delete(combination);
									continue;
								}
								const finishUpdate = combinations.startUpdate(combination);
								combination.integratedSize = newIntegratedSize;
								combination.bSize = integratedSize;
								combination.sizeDiff =
									integratedSize + combination.aSize - newIntegratedSize;
								finishUpdate();
							}
						}
					}
				}
				if (changed) return true;
			});
		});
	}
}
module.exports = LimitChunkCountPlugin;

},
// 370
function(module) {

module.exports = JSON.parse(
	'{"title":"LimitChunkCountPluginOptions","type":"object","additionalProperties":false,"properties":{"maxChunks":{"description":"Limit the maximum number of chunks using a value greater greater than or equal to 1","type":"number","minimum":1},"minChunkSize":{"description":"Set a minimum chunk size","type":"number"}}}'
);

},
// 371
function(module, exports, __webpack_require__) {

const SortableSet = __webpack_require__(20);

class LazyBucketSortedSet {
	constructor(getKey, comparator, ...args) {
		this._getKey = getKey;
		this._innerArgs = args;
		this._leaf = args.length <= 1;
		this._keys = new SortableSet(void 0, comparator);
		this._map = new Map();
		this._unsortedItems = new Set();
		this.size = 0;
	}

	add(item) {
		this.size++;
		this._unsortedItems.add(item);
	}

	_addInternal(key, item) {
		let entry = this._map.get(key);
		if (entry === void 0) {
			entry = this._leaf
				? new SortableSet(void 0, this._innerArgs[0])
				: new (LazyBucketSortedSet)(...this._innerArgs);
			this._keys.add(key);
			this._map.set(key, entry);
		}
		entry.add(item);
	}

	delete(item) {
		this.size--;
		if (this._unsortedItems.has(item)) {
			this._unsortedItems.delete(item);
			return;
		}
		const key = this._getKey(item),
			entry = this._map.get(key);
		entry.delete(item);
		entry.size !== 0 || this._deleteKey(key);
	}

	_deleteKey(key) {
		this._keys.delete(key);
		this._map.delete(key);
	}

	popFirst() {
		if (this.size === 0) return void 0;
		this.size--;
		if (this._unsortedItems.size > 0) {
			for (const item of this._unsortedItems) {
				const key = this._getKey(item);
				this._addInternal(key, item);
			}
			this._unsortedItems.clear();
		}
		this._keys.sort();
		const key = this._keys.values().next().value,
			entry = this._map.get(key);
		if (this._leaf) {
			const leafEntry = entry;
			leafEntry.sort();
			const item = leafEntry.values().next().value;
			leafEntry.delete(item);
			leafEntry.size !== 0 || this._deleteKey(key);

			return item;
		}
		const nodeEntry = entry,
			item = nodeEntry.popFirst();
		nodeEntry.size !== 0 || this._deleteKey(key);

		return item;
	}

	startUpdate(item) {
		if (this._unsortedItems.has(item))
			return remove => {
				if (remove) {
					this._unsortedItems.delete(item);
					this.size--;
				}
			};

		const key = this._getKey(item);
		if (this._leaf) {
			const oldEntry = this._map.get(key);
			return remove => {
				if (remove) {
					this.size--;
					oldEntry.delete(item);
					oldEntry.size !== 0 || this._deleteKey(key);

					return;
				}
				const newKey = this._getKey(item);
				if (key === newKey) oldEntry.add(item);
				else {
					oldEntry.delete(item);
					oldEntry.size !== 0 || this._deleteKey(key);

					this._addInternal(newKey, item);
				}
			};
		}

		const oldEntry = (this._map.get( key )),
			finishUpdate = oldEntry.startUpdate(item);
		return remove => {
			if (remove) {
				this.size--;
				finishUpdate(true);
				oldEntry.size !== 0 || this._deleteKey(key);

				return;
			}
			const newKey = this._getKey(item);
			if (key === newKey) finishUpdate();
			else {
				finishUpdate(true);
				oldEntry.size !== 0 || this._deleteKey(key);

				this._addInternal(newKey, item);
			}
		};
	}

	_appendIterators(iterators) {
		this._unsortedItems.size > 0 && iterators.push(this._unsortedItems[Symbol.iterator]());
		for (const key of this._keys) {
			const entry = this._map.get(key);
			if (this._leaf) {
				const iterator = entry[Symbol.iterator]();
				iterators.push(iterator);
			} else entry._appendIterators(iterators);
		}
	}

	[Symbol.iterator]() {
		const iterators = [];
		this._appendIterators(iterators);
		iterators.reverse();
		let currentIterator = iterators.pop();
		return {
			next: () => {
				const res = currentIterator.next();
				if (res.done) {
					if (iterators.length === 0) return res;
					currentIterator = iterators.pop();
					return currentIterator.next();
				}
				return res;
			}
		};
	}
}

module.exports = LazyBucketSortedSet;

},
// 372
function(module, exports, __webpack_require__) {

const validateOptions = __webpack_require__(8),
	schema = __webpack_require__(373);

class MinChunkSizePlugin {
	constructor(options) {
		validateOptions(schema, options, "Min Chunk Size Plugin");
		this.options = options;
	}

	apply(compiler) {
		const options = this.options,
			minChunkSize = options.minChunkSize;
		compiler.hooks.compilation.tap("MinChunkSizePlugin", compilation => {
			compilation.hooks.optimizeChunksAdvanced.tap("MinChunkSizePlugin", chunks => {
				const equalOptions = { chunkOverhead: 1, entryChunkMultiplicator: 1 };

				const sortedSizeFilteredExtendedPairCombinations = chunks
					.reduce((combinations, a, idx) => {
						for (let i = 0; i < idx; i++) {
							const b = chunks[i];
							combinations.push([b, a]);
						}
						return combinations;
					}, [])
					.filter(pair => {
						const p0SmallerThanMinChunkSize = pair[0].size(equalOptions) < minChunkSize,
							p1SmallerThanMinChunkSize = pair[1].size(equalOptions) < minChunkSize;
						return p0SmallerThanMinChunkSize || p1SmallerThanMinChunkSize;
					})
					.map(pair => {
						const a = pair[0].size(options),
							b = pair[1].size(options),
							ab = pair[0].integratedSize(pair[1], options);
						return [a + b - ab, ab, pair[0], pair[1]];
					})
					.filter(pair => pair[1] !== false)
					.sort((a, b) => {
						const diff = b[0] - a[0];
						return diff !== 0 ? diff : a[1] - b[1];
					});

				if (sortedSizeFilteredExtendedPairCombinations.length === 0) return;

				const pair = sortedSizeFilteredExtendedPairCombinations[0];

				pair[2].integrate(pair[3], "min-size");
				chunks.splice(chunks.indexOf(pair[3]), 1);
				return true;
			});
		});
	}
}
module.exports = MinChunkSizePlugin;

},
// 373
function(module) {

module.exports = JSON.parse(
	'{"title":"MinChunkSizePluginOptions","type":"object","additionalProperties":false,"properties":{"minChunkSize":{"description":"Minimum number of characters","type":"number"}},"required":["minChunkSize"]}'
);

},
// 374
function(module) {

class OccurrenceOrderPlugin {
	constructor(preferEntry) {
		if (preferEntry !== void 0 && typeof preferEntry != "boolean")
			throw new Error(
				"Argument should be a boolean.\nFor more info on this plugin, see https://webpack.js.org/plugins/"
			);

		this.preferEntry = preferEntry;
	}
	apply(compiler) {
		const preferEntry = this.preferEntry;
		compiler.hooks.compilation.tap("OccurrenceOrderPlugin", compilation => {
			compilation.hooks.optimizeModuleOrder.tap("OccurrenceOrderPlugin", modules => {
				const occursInInitialChunksMap = new Map(),
					occursInAllChunksMap = new Map(),

					initialChunkChunkMap = new Map(),
					entryCountMap = new Map();
				for (const m of modules) {
					let initial = 0,
						entry = 0;
					for (const c of m.chunksIterable) {
						c.canBeInitial() && initial++;
						c.entryModule !== m || entry++;
					}
					initialChunkChunkMap.set(m, initial);
					entryCountMap.set(m, entry);
				}

				const countOccursInEntry =
					(sum, r) => (r.module ? sum + initialChunkChunkMap.get(r.module) : sum);
				const countOccurs = (sum, r) => {
					if (!r.module) return sum;

					let factor = 1;
					if (typeof r.dependency.getNumberOfIdOccurrences == "function")
						factor = r.dependency.getNumberOfIdOccurrences();

					return factor === 0 ? sum : sum + factor * r.module.getNumberOfChunks();
				};

				if (preferEntry)
					for (const m of modules) {
						const result =
							m.reasons.reduce(countOccursInEntry, 0) +
							initialChunkChunkMap.get(m) +
							entryCountMap.get(m);
						occursInInitialChunksMap.set(m, result);
					}

				const originalOrder = new Map();
				let i = 0;
				for (const m of modules) {
					const result =
						m.reasons.reduce(countOccurs, 0) +
						m.getNumberOfChunks() +
						entryCountMap.get(m);
					occursInAllChunksMap.set(m, result);
					originalOrder.set(m, i++);
				}

				modules.sort((a, b) => {
					if (preferEntry) {
						const aEntryOccurs = occursInInitialChunksMap.get(a),
							bEntryOccurs = occursInInitialChunksMap.get(b);
						if (aEntryOccurs > bEntryOccurs) return -1;
						if (aEntryOccurs < bEntryOccurs) return 1;
					}
					const aOccurs = occursInAllChunksMap.get(a),
						bOccurs = occursInAllChunksMap.get(b);
					return aOccurs > bOccurs ? -1
						: aOccurs < bOccurs ? 1
						: originalOrder.get(a) - originalOrder.get(b);
				});
			});
			compilation.hooks.optimizeChunkOrder.tap("OccurrenceOrderPlugin", chunks => {
				const occursInInitialChunksMap = new Map(),
					originalOrder = new Map();

				let i = 0;
				for (const c of chunks) {
					let occurs = 0;
					for (const chunkGroup of c.groupsIterable)
						for (const parent of chunkGroup.parentsIterable) parent.isInitial() && occurs++;

					occursInInitialChunksMap.set(c, occurs);
					originalOrder.set(c, i++);
				}

				chunks.sort((a, b) => {
					const aEntryOccurs = occursInInitialChunksMap.get(a),
						bEntryOccurs = occursInInitialChunksMap.get(b);
					if (aEntryOccurs > bEntryOccurs) return -1;
					if (aEntryOccurs < bEntryOccurs) return 1;
					const aOccurs = a.getNumberOfGroups(),
						bOccurs = b.getNumberOfGroups();
					return aOccurs > bOccurs ? -1
						: aOccurs < bOccurs ? 1
						: originalOrder.get(a) - originalOrder.get(b);
				});
			});
		});
	}
}

module.exports = OccurrenceOrderPlugin;

},
// 375
function(module, exports, __webpack_require__) {

const fs = __webpack_require__(34),
	path = __webpack_require__(3),
	mkdirp = __webpack_require__(82),
	{ Tracer } = __webpack_require__(376),
	validateOptions = __webpack_require__(8),
	schema = __webpack_require__(378);

let inspector = void 0;

try {
	inspector = __webpack_require__(379);
} catch (_e) {
	console.log("Unable to CPU profile in < node 8.0");
}

class Profiler {
	constructor(inspector) {
		this.session = void 0;
		this.inspector = inspector;
	}

	hasSession() {
		return this.session !== void 0;
	}

	startProfiling() {
		if (this.inspector === void 0) return Promise.resolve();

		try {
			this.session = new inspector.Session();
			this.session.connect();
		} catch (_) {
			this.session = void 0;
			return Promise.resolve();
		}

		return Promise.all([
			this.sendCommand("Profiler.setSamplingInterval", { interval: 100 }),
			this.sendCommand("Profiler.enable"),
			this.sendCommand("Profiler.start")
		]);
	}

	sendCommand(method, params) {
		return this.hasSession()
			? new Promise((res, rej) =>
					this.session.post(method, params, (err, params) => {
						err !== null ? rej(err) : res(params);
					})
				)
			: Promise.resolve();
	}

	destroy() {
		this.hasSession() && this.session.disconnect();

		return Promise.resolve();
	}

	stopProfiling() {
		return this.sendCommand("Profiler.stop");
	}
}

const createTrace = outputPath => {
	const trace = new Tracer({ noStream: true }),
		profiler = new Profiler(inspector);
	if (/\/|\\/.test(outputPath)) {
		const dirPath = path.dirname(outputPath);
		mkdirp.sync(dirPath);
	}
	const fsStream = fs.createWriteStream(outputPath);

	let counter = 0;

	trace.pipe(fsStream);
	trace.instantEvent({
		name: "TracingStartedInPage",
		id: ++counter,
		cat: ["disabled-by-default-devtools.timeline"],
		args: {
			data: {
				sessionId: "-1",
				page: "0xfff",
				frames: [{ frame: "0xfff", url: "webpack", name: "" }]
			}
		}
	});

	trace.instantEvent({
		name: "TracingStartedInBrowser",
		id: ++counter,
		cat: ["disabled-by-default-devtools.timeline"],
		args: { data: { sessionId: "-1" } }
	});

	return {
		trace,
		counter,
		profiler,
		end: callback => {
			fsStream.on("finish", () => {
				callback();
			});
			trace.push(null);
		}
	};
};

const pluginName = "ProfilingPlugin";

class ProfilingPlugin {
	constructor(opts) {
		validateOptions(schema, opts || {}, "Profiling plugin");
		opts = opts || {};
		this.outputPath = opts.outputPath || "events.json";
	}

	apply(compiler) {
		const tracer = createTrace(this.outputPath);
		tracer.profiler.startProfiling();

		Object.keys(compiler.hooks).forEach(hookName => {
			compiler.hooks[hookName].intercept(
				makeInterceptorFor("Compiler", tracer)(hookName)
			);
		});

		Object.keys(compiler.resolverFactory.hooks).forEach(hookName => {
			compiler.resolverFactory.hooks[hookName].intercept(
				makeInterceptorFor("Resolver", tracer)(hookName)
			);
		});

		compiler.hooks.compilation.tap(
			pluginName,
			(compilation, { normalModuleFactory, contextModuleFactory }) => {
				interceptAllHooksFor(compilation, tracer, "Compilation");
				interceptAllHooksFor(
					normalModuleFactory,
					tracer,
					"Normal Module Factory"
				);
				interceptAllHooksFor(
					contextModuleFactory,
					tracer,
					"Context Module Factory"
				);
				interceptAllParserHooks(normalModuleFactory, tracer);
				interceptTemplateInstancesFrom(compilation, tracer);
			}
		);

		compiler.hooks.done.tapAsync({ name: pluginName, stage: Infinity }, (stats, callback) => {
			tracer.profiler.stopProfiling().then(parsedResults => {
				if (parsedResults === void 0) {
					tracer.profiler.destroy();
					tracer.trace.flush();
					tracer.end(callback);
					return;
				}

				const cpuStartTime = parsedResults.profile.startTime,
					cpuEndTime = parsedResults.profile.endTime;

				tracer.trace.completeEvent({
					name: "TaskQueueManager::ProcessTaskFromWorkQueue",
					id: ++tracer.counter,
					cat: ["toplevel"],
					ts: cpuStartTime,
					args: { src_file: "../../ipc/ipc_moji_bootstrap.cc", src_func: "Accept" }
				});

				tracer.trace.completeEvent({
					name: "EvaluateScript",
					id: ++tracer.counter,
					cat: ["devtools.timeline"],
					ts: cpuStartTime,
					dur: cpuEndTime - cpuStartTime,
					args: { data: { url: "webpack", lineNumber: 1, columnNumber: 1, frame: "0xFFF" } }
				});

				tracer.trace.instantEvent({
					name: "CpuProfile",
					id: ++tracer.counter,
					cat: ["disabled-by-default-devtools.timeline"],
					ts: cpuEndTime,
					args: { data: { cpuProfile: parsedResults.profile } }
				});

				tracer.profiler.destroy();
				tracer.trace.flush();
				tracer.end(callback);
			});
		});
	}
}

const interceptTemplateInstancesFrom = (compilation, tracer) => {
	const { mainTemplate, chunkTemplate, hotUpdateChunkTemplate, moduleTemplates } = compilation,

		{ javascript, webassembly } = moduleTemplates;

	[
		{ instance: mainTemplate, name: "MainTemplate" },
		{ instance: chunkTemplate, name: "ChunkTemplate" },
		{ instance: hotUpdateChunkTemplate, name: "HotUpdateChunkTemplate" },
		{ instance: javascript, name: "JavaScriptModuleTemplate" },
		{ instance: webassembly, name: "WebAssemblyModuleTemplate" }
	].forEach(templateObject => {
		Object.keys(templateObject.instance.hooks).forEach(hookName => {
			templateObject.instance.hooks[hookName].intercept(
				makeInterceptorFor(templateObject.name, tracer)(hookName)
			);
		});
	});
};

const interceptAllHooksFor = (instance, tracer, logLabel) => {
	Reflect.has(instance, "hooks") &&
		Object.keys(instance.hooks).forEach(hookName => {
			instance.hooks[hookName].intercept(
				makeInterceptorFor(logLabel, tracer)(hookName)
			);
		});
};

const interceptAllParserHooks = (moduleFactory, tracer) => {
	[
		"javascript/auto",
		"javascript/dynamic",
		"javascript/esm",
		"json",
		"webassembly/experimental"
	].forEach(moduleType => {
		moduleFactory.hooks.parser
			.for(moduleType)
			.tap("ProfilingPlugin", (parser, parserOpts) => {
				interceptAllHooksFor(parser, tracer, "Parser");
			});
	});
};

const makeInterceptorFor = (instance, tracer) => hookName => ({
	register: ({ name, type, context, fn }) =>
		({ name, type, context, fn: makeNewProfiledTapFn(hookName, tracer, { name, type, fn }) })
});

const makeNewProfiledTapFn = (hookName, tracer, { name, type, fn }) => {
	const defaultCategory = ["blink.user_timing"];

	switch (type) {
		case "promise":
			return (...args) => {
				const id = ++tracer.counter;
				tracer.trace.begin({ name, id, cat: defaultCategory });
				const promise = (fn(...args));
				return promise.then(r => {
					tracer.trace.end({ name, id, cat: defaultCategory });
					return r;
				});
			};
		case "async":
			return (...args) => {
				const id = ++tracer.counter;
				tracer.trace.begin({ name, id, cat: defaultCategory });
				const callback = args.pop();
				fn(...args, (...r) => {
					tracer.trace.end({ name, id, cat: defaultCategory });
					callback(...r);
				});
			};
		case "sync":
			return (...args) => {
				const id = ++tracer.counter;
				if (name === pluginName) return fn(...args);

				tracer.trace.begin({ name, id, cat: defaultCategory });
				let r;
				try {
					r = fn(...args);
				} catch (error) {
					tracer.trace.end({ name, id, cat: defaultCategory });
					throw error;
				}
				tracer.trace.end({ name, id, cat: defaultCategory });
				return r;
			};
		default:
			break;
	}
};

module.exports = ProfilingPlugin;
module.exports.Profiler = Profiler;

},
// 376
function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
exports.Tracer = void 0;
const stream_1 = __webpack_require__(377);
function evCommon() {
	var hrtime = process.hrtime();
	return {
		ts: hrtime[0] * 1000000 + Math.round(hrtime[1] / 1000),
		pid: process.pid,
		tid: process.pid
	};
}
class Tracer extends stream_1.Readable {
	constructor(opts = {}) {
		super();
		this.noStream = false;
		this.events = [];
		if (typeof opts != "object")
			throw new Error("Invalid options passed (must be an object)");

		if (opts.parent != null && typeof opts.parent != "object")
			throw new Error("Invalid option (parent) passed (must be an object)");

		if (opts.fields != null && typeof opts.fields != "object")
			throw new Error("Invalid option (fields) passed (must be an object)");

		if (opts.objectMode != null && opts.objectMode !== true && opts.objectMode !== false)
			throw new Error("Invalid option (objectsMode) passed (must be a boolean)");

		this.noStream = opts.noStream || false;
		this.parent = opts.parent;
		this.fields = this.parent ? Object.assign({}, opts.parent && opts.parent.fields) : {};

		opts.fields && Object.assign(this.fields, opts.fields);

		if (!this.fields.cat) this.fields.cat = "default";
		else if (Array.isArray(this.fields.cat)) this.fields.cat = this.fields.cat.join(",");

		this.fields.args || (this.fields.args = {});

		if (this.parent) this._push = this.parent._push.bind(this.parent);
		else {
			this._objectMode = Boolean(opts.objectMode);
			var streamOpts = { objectMode: this._objectMode };
			if (this._objectMode) this._push = this.push;
			else {
				this._push = this._pushString;
				streamOpts.encoding = "utf8";
			}
			stream_1.Readable.call(this, streamOpts);
		}
	}
	flush() {
		if (this.noStream === true) {
			for (const evt of this.events) this._push(evt);

			this._flush();
		}
	}
	_read(_) {}
	_pushString(ev) {
		var separator = "";
		if (this.firstPush) separator = ",\n";
		else {
			this.push("[");
			this.firstPush = true;
		}

		this.push(separator + JSON.stringify(ev), "utf8");
	}
	_flush() {
		this._objectMode || this.push("]");
	}
	child(fields) {
		return new Tracer({ parent: this, fields: fields });
	}
	begin(fields) {
		return this.mkEventFunc("b")(fields);
	}
	end(fields) {
		return this.mkEventFunc("e")(fields);
	}
	completeEvent(fields) {
		return this.mkEventFunc("X")(fields);
	}
	instantEvent(fields) {
		return this.mkEventFunc("I")(fields);
	}
	mkEventFunc(ph) {
		return (fields) => {
			var ev = evCommon();
			ev.ph = ph;
			if (fields)
				if (typeof fields == "string") ev.name = fields;
				else
					for (const k of Object.keys(fields))
						if (k === "cat") ev.cat = fields.cat.join(",");
						else ev[k] = fields[k];

			this.noStream ? this.events.push(ev) : this._push(ev);
		};
	}
}
exports.Tracer = Tracer;

},
// 377
function(module) {

module.exports = require("stream");

},
// 378
function(module) {

module.exports = JSON.parse(
	'{"title":"ProfilingPluginOptions","type":"object","additionalProperties":false,"properties":{"outputPath":{"description":"Path to the output file e.g. `profiling/events.json`. Defaults to `events.json`.","type":"string","absolutePath":false,"minLength":4}}}'
);

},
// 379
function(module) {

module.exports = require("inspector");

}
]);
