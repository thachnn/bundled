"use strict";

var traverse = require('./traverse'),
  t$5 = require('./types'),
  template$1 = require('./template'),
  assert = require('assert'),
  vendors = require('./vendors.js'),
  generate = require('./generator'),
  path = require('path'),
  fs = require('fs'),
  url = require('url'),
  module$1 = require('module'),
  parser$1 = require('./parser'),
  common = require('./common.js'),
  process$1 = require('process'),
  v8 = require('v8'),
  util = require('util');

var _babel = Object.freeze({
  __proto__: null,
  get DEFAULT_EXTENSIONS() { return DEFAULT_EXTENSIONS; },
  get File() { return File; },
  get buildExternalHelpers() { return babelBuildExternalHelpers; },
  get createConfigItem() { return createConfigItem; },
  get createConfigItemAsync() { return createConfigItemAsync; },
  get createConfigItemSync() { return createConfigItemSync; },
  get getEnv() { return getEnv; },
  get loadOptions() { return loadOptions; },
  get loadOptionsAsync() { return loadOptionsAsync; },
  get loadOptionsSync() { return loadOptionsSync; },
  get loadPartialConfig() { return loadPartialConfig; },
  get loadPartialConfigAsync() { return loadPartialConfigAsync; },
  get loadPartialConfigSync() { return loadPartialConfigSync; },
  get parse() { return parse; },
  get parseAsync() { return parseAsync; },
  get parseSync() { return parseSync; },
  get resolvePlugin() { return resolvePlugin; },
  get resolvePreset() { return resolvePreset; },
  get template() { return template$1.default; },
  get tokTypes() { return parser$1.tokTypes; },
  get transform() { return transform$2; },
  get transformAsync() { return transformAsync$1; },
  get transformFile() { return transformFile$1; },
  get transformFileAsync() { return transformFileAsync$1; },
  get transformFileSync() { return transformFileSync; },
  get transformFromAst() { return transformFromAst$1; },
  get transformFromAstAsync() { return transformFromAstAsync$1; },
  get transformFromAstSync() { return transformFromAstSync; },
  get transformSync() { return transformSync; },
  get traverse() { return traverse.default; },
  get types() { return t$5; },
  get version() { return version$1; }
});

function helper$3(minVersion, source) {
  return Object.freeze({
    minVersion,
    ast: () => template$1.program.ast(source, { preserveComments: true })
  });
}
var generated = Object.freeze({
  AsyncGenerator: helper$3("7.0.0-beta.0",
    'import OverloadYield from"OverloadYield";export default function AsyncGenerator(e){var r,t;function resume(r,t){try{var n=e[r](t),o=n.value,u=o instanceof OverloadYield;Promise.resolve(u?o.v:o).then((function(t){if(u){var i="return"===r?"return":"next";if(!o.k||t.done)return resume(i,t);t=e[i](t).value}settle(n.done?"return":"normal",t)}),(function(e){resume("throw",e)}))}catch(e){settle("throw",e)}}function settle(e,n){switch(e){case"return":r.resolve({value:n,done:!0});break;case"throw":r.reject(n);break;default:r.resolve({value:n,done:!1})}(r=r.next)?resume(r.key,r.arg):t=null}this._invoke=function(e,n){return new Promise((function(o,u){var i={key:e,arg:n,resolve:o,reject:u,next:null};t?t=t.next=i:(r=t=i,resume(e,n))}))},"function"!=typeof e.return&&(this.return=void 0)}AsyncGenerator.prototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){return this},AsyncGenerator.prototype.next=function(e){return this._invoke("next",e)},AsyncGenerator.prototype.throw=function(e){return this._invoke("throw",e)},AsyncGenerator.prototype.return=function(e){return this._invoke("return",e)};'
  ),
  OverloadYield: helper$3("7.18.14", "export default function _OverloadYield(t,e){this.v=t,this.k=e}"),
  applyDecs: helper$3("7.17.8",
    'function old_createMetadataMethodsForProperty(e,t,a,r){return{getMetadata:function(o){old_assertNotFinished(r,"getMetadata"),old_assertMetadataKey(o);var i=e[o];if(void 0!==i)if(1===t){var n=i.public;if(void 0!==n)return n[a]}else if(2===t){var l=i.private;if(void 0!==l)return l.get(a)}else if(Object.hasOwnProperty.call(i,"constructor"))return i.constructor},setMetadata:function(o,i){old_assertNotFinished(r,"setMetadata"),old_assertMetadataKey(o);var n=e[o];if(void 0===n&&(n=e[o]={}),1===t){var l=n.public;void 0===l&&(l=n.public={}),l[a]=i}else if(2===t){var s=n.priv;void 0===s&&(s=n.private=new Map),s.set(a,i)}else n.constructor=i}}}function old_convertMetadataMapToFinal(e,t){var a=e[Symbol.metadata||Symbol.for("Symbol.metadata")],r=Object.getOwnPropertySymbols(t);if(0!==r.length){for(var o=0;o<r.length;o++){var i=r[o],n=t[i],l=a?a[i]:null,s=n.public,c=l?l.public:null;s&&c&&Object.setPrototypeOf(s,c);var d=n.private;if(d){var u=Array.from(d.values()),f=l?l.private:null;f&&(u=u.concat(f)),n.private=u}l&&Object.setPrototypeOf(n,l)}a&&Object.setPrototypeOf(t,a),e[Symbol.metadata||Symbol.for("Symbol.metadata")]=t}}function old_createAddInitializerMethod(e,t){return function(a){old_assertNotFinished(t,"addInitializer"),old_assertCallable(a,"An initializer"),e.push(a)}}function old_memberDec(e,t,a,r,o,i,n,l,s){var c;switch(i){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var d,u,f={kind:c,name:l?"#"+t:t,isStatic:n,isPrivate:l},p={v:!1};if(0!==i&&(f.addInitializer=old_createAddInitializerMethod(o,p)),l){d=2,u=Symbol(t);var v={};0===i?(v.get=a.get,v.set=a.set):2===i?v.get=function(){return a.value}:(1!==i&&3!==i||(v.get=function(){return a.get.call(this)}),1!==i&&4!==i||(v.set=function(e){a.set.call(this,e)})),f.access=v}else d=1,u=t;try{return e(s,Object.assign(f,old_createMetadataMethodsForProperty(r,d,u,p)))}finally{p.v=!0}}function old_assertNotFinished(e,t){if(e.v)throw new Error("attempted to call "+t+" after decoration was finished")}function old_assertMetadataKey(e){if("symbol"!=typeof e)throw new TypeError("Metadata keys must be symbols, received: "+e)}function old_assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function old_assertValidReturnValue(e,t){var a=typeof t;if(1===e){if("object"!==a||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&old_assertCallable(t.get,"accessor.get"),void 0!==t.set&&old_assertCallable(t.set,"accessor.set"),void 0!==t.init&&old_assertCallable(t.init,"accessor.init"),void 0!==t.initializer&&old_assertCallable(t.initializer,"accessor.initializer")}else if("function"!==a){var r;throw r=0===e?"field":10===e?"class":"method",new TypeError(r+" decorators must return a function or void 0")}}function old_getInit(e){var t;return null==(t=e.init)&&(t=e.initializer)&&"undefined"!=typeof console&&console.warn(".initializer has been renamed to .init as of March 2022"),t}function old_applyMemberDec(e,t,a,r,o,i,n,l,s){var c,d,u,f,p,v,h=a[0];if(n?c=0===o||1===o?{get:a[3],set:a[4]}:3===o?{get:a[3]}:4===o?{set:a[3]}:{value:a[3]}:0!==o&&(c=Object.getOwnPropertyDescriptor(t,r)),1===o?u={get:c.get,set:c.set}:2===o?u=c.value:3===o?u=c.get:4===o&&(u=c.set),"function"==typeof h)void 0!==(f=old_memberDec(h,r,c,l,s,o,i,n,u))&&(old_assertValidReturnValue(o,f),0===o?d=f:1===o?(d=old_getInit(f),p=f.get||u.get,v=f.set||u.set,u={get:p,set:v}):u=f);else for(var y=h.length-1;y>=0;y--){var b;if(void 0!==(f=old_memberDec(h[y],r,c,l,s,o,i,n,u)))old_assertValidReturnValue(o,f),0===o?b=f:1===o?(b=old_getInit(f),p=f.get||u.get,v=f.set||u.set,u={get:p,set:v}):u=f,void 0!==b&&(void 0===d?d=b:"function"==typeof d?d=[d,b]:d.push(b))}if(0===o||1===o){if(void 0===d)d=function(e,t){return t};else if("function"!=typeof d){var g=d;d=function(e,t){for(var a=t,r=0;r<g.length;r++)a=g[r].call(e,a);return a}}else{var m=d;d=function(e,t){return m.call(e,t)}}e.push(d)}0!==o&&(1===o?(c.get=u.get,c.set=u.set):2===o?c.value=u:3===o?c.get=u:4===o&&(c.set=u),n?1===o?(e.push((function(e,t){return u.get.call(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===o?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.defineProperty(t,r,c))}function old_applyMemberDecs(e,t,a,r,o){for(var i,n,l=new Map,s=new Map,c=0;c<o.length;c++){var d=o[c];if(Array.isArray(d)){var u,f,p,v=d[1],h=d[2],y=d.length>3,b=v>=5;if(b?(u=t,f=r,0!==(v-=5)&&(p=n=n||[])):(u=t.prototype,f=a,0!==v&&(p=i=i||[])),0!==v&&!y){var g=b?s:l,m=g.get(h)||0;if(!0===m||3===m&&4!==v||4===m&&3!==v)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);!m&&v>2?g.set(h,v):g.set(h,!0)}old_applyMemberDec(e,u,d,h,v,b,y,f,p)}}old_pushInitializers(e,i),old_pushInitializers(e,n)}function old_pushInitializers(e,t){t&&e.push((function(e){for(var a=0;a<t.length;a++)t[a].call(e);return e}))}function old_applyClassDecs(e,t,a,r){if(r.length>0){for(var o=[],i=t,n=t.name,l=r.length-1;l>=0;l--){var s={v:!1};try{var c=Object.assign({kind:"class",name:n,addInitializer:old_createAddInitializerMethod(o,s)},old_createMetadataMethodsForProperty(a,0,n,s)),d=r[l](i,c)}finally{s.v=!0}void 0!==d&&(old_assertValidReturnValue(10,d),i=d)}e.push(i,(function(){for(var e=0;e<o.length;e++)o[e].call(i)}))}}export default function applyDecs(e,t,a){var r=[],o={},i={};return old_applyMemberDecs(r,e,i,o,t),old_convertMetadataMapToFinal(e.prototype,i),old_applyClassDecs(r,e,o,a),old_convertMetadataMapToFinal(e,o),r}'
  ),
  applyDecs2203: helper$3("7.19.0",
    'function applyDecs2203Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw new Error("attempted to call "+t+" after decoration was finished")}(t,"addInitializer"),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,a,n,i,s,o){var c;switch(n){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==n&&(f.addInitializer=createAddInitializerMethod(a,p)),0===n?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===n?l=function(){return r.value}:(1!==n&&3!==n||(l=function(){return r.get.call(this)}),1!==n&&4!==n||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r){var a;throw a=0===e?"field":10===e?"class":"method",new TypeError(a+" decorators must return a function or void 0")}}function applyMemberDec(e,t,r,a,n,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===n||1===n?{get:r[3],set:r[4]}:3===n?{get:r[3]}:4===n?{set:r[3]}:{value:r[3]}:0!==n&&(c=Object.getOwnPropertyDescriptor(t,a)),1===n?u={get:c.get,set:c.set}:2===n?u=c.value:3===n?u=c.get:4===n&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?l=f:1===n?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;if(void 0!==(f=memberDec(h[v],a,c,o,n,i,s,u)))assertValidReturnValue(n,f),0===n?g=f:1===n?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==g&&(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g))}if(0===n||1===n){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var y=l;l=function(e,t){for(var r=t,a=0;a<y.length;a++)r=y[a].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.push(l)}0!==n&&(1===n?(c.get=u.get,c.set=u.set):2===n?c.value=u:3===n?c.get=u:4===n&&(c.set=u),s?1===n?(e.push((function(e,t){return u.get.call(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===n?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.defineProperty(t,a,c))}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){var a=[];return function(e,t,r){for(var a,n,i=new Map,s=new Map,o=0;o<r.length;o++){var c=r[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=t,0!=(f-=5)&&(u=n=n||[])):(l=t.prototype,0!==f&&(u=a=a||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(e,l,c,p,f,h,d,u)}}pushInitializers(e,a),pushInitializers(e,n)}(a,e,t),function(e,t,r){if(r.length>0){for(var a=[],n=t,i=t.name,s=r.length-1;s>=0;s--){var o={v:!1};try{var c=r[s](n,{kind:"class",name:i,addInitializer:createAddInitializerMethod(a,o)})}finally{o.v=!0}void 0!==c&&(assertValidReturnValue(10,c),n=c)}e.push(n,(function(){for(var e=0;e<a.length;e++)a[e].call(n)}))}}(a,e,r),a}}var applyDecs2203Impl;export default function applyDecs2203(e,t,r){return(applyDecs2203Impl=applyDecs2203Impl||applyDecs2203Factory())(e,t,r)}'
  ),
  applyDecs2203R: helper$3("7.20.0",
    'function applyDecs2203RFactory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw new Error("attempted to call "+t+" after decoration was finished")}(t,"addInitializer"),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,n,a,i,s,o){var c;switch(a){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==a&&(f.addInitializer=createAddInitializerMethod(n,p)),0===a?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===a?l=function(){return r.value}:(1!==a&&3!==a||(l=function(){return r.get.call(this)}),1!==a&&4!==a||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r){var n;throw n=0===e?"field":10===e?"class":"method",new TypeError(n+" decorators must return a function or void 0")}}function applyMemberDec(e,t,r,n,a,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===a||1===a?{get:r[3],set:r[4]}:3===a?{get:r[3]}:4===a?{set:r[3]}:{value:r[3]}:0!==a&&(c=Object.getOwnPropertyDescriptor(t,n)),1===a?u={get:c.get,set:c.set}:2===a?u=c.value:3===a?u=c.get:4===a&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,n,c,o,a,i,s,u))&&(assertValidReturnValue(a,f),0===a?l=f:1===a?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;if(void 0!==(f=memberDec(h[v],n,c,o,a,i,s,u)))assertValidReturnValue(a,f),0===a?g=f:1===a?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==g&&(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var y=l;l=function(e,t){for(var r=t,n=0;n<y.length;n++)r=y[n].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.push(l)}0!==a&&(1===a?(c.get=u.get,c.set=u.set):2===a?c.value=u:3===a?c.get=u:4===a&&(c.set=u),s?1===a?(e.push((function(e,t){return u.get.call(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===a?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.defineProperty(t,n,c))}function applyMemberDecs(e,t){for(var r,n,a=[],i=new Map,s=new Map,o=0;o<t.length;o++){var c=t[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=e,0!==(f-=5)&&(u=n=n||[])):(l=e.prototype,0!==f&&(u=r=r||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(a,l,c,p,f,h,d,u)}}return pushInitializers(a,r),pushInitializers(a,n),a}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){return{e:applyMemberDecs(e,t),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}finally{s.v=!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}export default function applyDecs2203R(e,t,r){return(applyDecs2203R=applyDecs2203RFactory())(e,t,r)}'
  ),
  applyDecs2301: helper$3("7.21.0",
    'import checkInRHS from"checkInRHS";function applyDecs2301Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw new Error("attempted to call "+t+" after decoration was finished")}(t,"addInitializer"),assertCallable(r,"An initializer"),e.push(r)}}function assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,r,n,a,i,s,o,c){var u;switch(a){case 1:u="accessor";break;case 2:u="method";break;case 3:u="getter";break;case 4:u="setter";break;default:u="field"}var l,f,p={kind:u,name:s?"#"+t:t,static:i,private:s},d={v:!1};if(0!==a&&(p.addInitializer=createAddInitializerMethod(n,d)),s||0!==a&&2!==a)if(2===a)l=function(e){return assertInstanceIfPrivate(c,e),r.value};else{var h=0===a||1===a;(h||3===a)&&(l=s?function(e){return assertInstanceIfPrivate(c,e),r.get.call(e)}:function(e){return r.get.call(e)}),(h||4===a)&&(f=s?function(e,t){assertInstanceIfPrivate(c,e),r.set.call(e,t)}:function(e,t){r.set.call(e,t)})}else l=function(e){return e[t]},0===a&&(f=function(e,r){e[t]=r});var v=s?c.bind():function(e){return t in e};p.access=l&&f?{get:l,set:f,has:v}:l?{get:l,has:v}:{set:f,has:v};try{return e(o,p)}finally{d.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r){var n;throw n=0===e?"field":10===e?"class":"method",new TypeError(n+" decorators must return a function or void 0")}}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c){var u,l,f,p,d,h,v,g=r[0];if(s?u=0===a||1===a?{get:(p=r[3],function(){return p(this)}),set:curryThis2(r[4])}:3===a?{get:r[3]}:4===a?{set:r[3]}:{value:r[3]}:0!==a&&(u=Object.getOwnPropertyDescriptor(t,n)),1===a?f={get:u.get,set:u.set}:2===a?f=u.value:3===a?f=u.get:4===a&&(f=u.set),"function"==typeof g)void 0!==(d=memberDec(g,n,u,o,a,i,s,f,c))&&(assertValidReturnValue(a,d),0===a?l=d:1===a?(l=d.init,h=d.get||f.get,v=d.set||f.set,f={get:h,set:v}):f=d);else for(var y=g.length-1;y>=0;y--){var m;if(void 0!==(d=memberDec(g[y],n,u,o,a,i,s,f,c)))assertValidReturnValue(a,d),0===a?m=d:1===a?(m=d.init,h=d.get||f.get,v=d.set||f.set,f={get:h,set:v}):f=d,void 0!==m&&(void 0===l?l=m:"function"==typeof l?l=[l,m]:l.push(m))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var b=l;l=function(e,t){for(var r=t,n=0;n<b.length;n++)r=b[n].call(e,r);return r}}else{var I=l;l=function(e,t){return I.call(e,t)}}e.push(l)}0!==a&&(1===a?(u.get=f.get,u.set=f.set):2===a?u.value=f:3===a?u.get=f:4===a&&(u.set=f),s?1===a?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===a?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,n,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,u=0;u<t.length;u++){var l=t[u];if(Array.isArray(l)){var f,p,d=l[1],h=l[2],v=l.length>3,g=d>=5,y=r;if(g?(f=e,0!==(d-=5)&&(p=a=a||[]),v&&!i&&(i=function(t){return checkInRHS(t)===e}),y=i):(f=e.prototype,0!==d&&(p=n=n||[])),0!==d&&!v){var m=g?c:o,b=m.get(h)||0;if(!0===b||3===b&&4!==d||4===b&&3!==d)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);!b&&d>2?m.set(h,d):m.set(h,!0)}applyMemberDec(s,f,l,h,d,g,v,p,y)}}return pushInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r,n){return{e:applyMemberDecs(e,t,n),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}finally{s.v=!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}export default function applyDecs2301(e,t,r,n){return(applyDecs2301=applyDecs2301Factory())(e,t,r,n)}'
  ),
  applyDecs2305: helper$3("7.21.0",
    'import checkInRHS from"checkInRHS";function createAddInitializerMethod(e,t){return function(r){assertNotFinished(t,"addInitializer"),assertCallable(r,"An initializer"),e.push(r)}}function assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,r,n,a,i,s,o,c,l){var u;switch(i){case 1:u="accessor";break;case 2:u="method";break;case 3:u="getter";break;case 4:u="setter";break;default:u="field"}var f,d,p={kind:u,name:o?"#"+r:r,static:s,private:o},h={v:!1};if(0!==i&&(p.addInitializer=createAddInitializerMethod(a,h)),o||0!==i&&2!==i)if(2===i)f=function(e){return assertInstanceIfPrivate(l,e),n.value};else{var v=0===i||1===i;(v||3===i)&&(f=o?function(e){return assertInstanceIfPrivate(l,e),n.get.call(e)}:function(e){return n.get.call(e)}),(v||4===i)&&(d=o?function(e,t){assertInstanceIfPrivate(l,e),n.set.call(e,t)}:function(e,t){n.set.call(e,t)})}else f=function(e){return e[r]},0===i&&(d=function(e,t){e[r]=t});var y=o?l.bind():function(e){return r in e};p.access=f&&d?{get:f,set:d,has:y}:f?{get:f,has:y}:{set:d,has:y};try{return e.call(t,c,p)}finally{h.v=!0}}function assertNotFinished(e,t){if(e.v)throw new Error("attempted to call "+t+" after decoration was finished")}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r){var n;throw n=0===e?"field":5===e?"class":"method",new TypeError(n+" decorators must return a function or void 0")}}function curryThis1(e){return function(){return e(this)}}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c,l){var u,f,d,p,h,v,y=r[0];n||Array.isArray(y)||(y=[y]),o?u=0===i||1===i?{get:curryThis1(r[3]),set:curryThis2(r[4])}:3===i?{get:r[3]}:4===i?{set:r[3]}:{value:r[3]}:0!==i&&(u=Object.getOwnPropertyDescriptor(t,a)),1===i?d={get:u.get,set:u.set}:2===i?d=u.value:3===i?d=u.get:4===i&&(d=u.set);for(var g=n?2:1,m=y.length-1;m>=0;m-=g){var b;if(void 0!==(p=memberDec(y[m],n?y[m-1]:void 0,a,u,c,i,s,o,d,l)))assertValidReturnValue(i,p),0===i?b=p:1===i?(b=p.init,h=p.get||d.get,v=p.set||d.set,d={get:h,set:v}):d=p,void 0!==b&&(void 0===f?f=b:"function"==typeof f?f=[f,b]:f.push(b))}if(0===i||1===i){if(void 0===f)f=function(e,t){return t};else if("function"!=typeof f){var I=f;f=function(e,t){for(var r=t,n=I.length-1;n>=0;n--)r=I[n].call(e,r);return r}}else{var w=f;f=function(e,t){return w.call(e,t)}}e.push(f)}0!==i&&(1===i?(u.get=d.get,u.set=d.set):2===i?u.value=d:3===i?u.get=d:4===i&&(u.set=d),o?1===i?(e.push((function(e,t){return d.get.call(e,t)})),e.push((function(e,t){return d.set.call(e,t)}))):2===i?e.push(d):e.push((function(e,t){return d.call(e,t)})):Object.defineProperty(t,a,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,l=0;l<t.length;l++){var u=t[l];if(Array.isArray(u)){var f,d,p=u[1],h=u[2],v=u.length>3,y=16&p,g=!!(8&p),m=r;if(p&=7,g?(f=e,0!==p&&(d=a=a||[]),v&&!i&&(i=function(t){return checkInRHS(t)===e}),m=i):(f=e.prototype,0!==p&&(d=n=n||[])),0!==p&&!v){var b=g?c:o,I=b.get(h)||0;if(!0===I||3===I&&4!==p||4===I&&3!==p)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);b.set(h,!(!I&&p>2)||p)}applyMemberDec(s,f,u,y,h,p,g,v,d,m)}}return pushInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}function applyClassDecs(e,t,r){if(t.length){for(var n=[],a=e,i=e.name,s=r?2:1,o=t.length-1;o>=0;o-=s){var c={v:!1};try{var l=t[o].call(r?t[o-1]:void 0,a,{kind:"class",name:i,addInitializer:createAddInitializerMethod(n,c)})}finally{c.v=!0}void 0!==l&&(assertValidReturnValue(5,l),a=l)}return[a,function(){for(var e=0;e<n.length;e++)n[e].call(a)}]}}export default function applyDecs2305(e,t,r,n,a){return{e:applyMemberDecs(e,t,a),get c(){return applyClassDecs(e,r,n)}}}'
  ),
  asyncGeneratorDelegate: helper$3("7.0.0-beta.0",
    'import OverloadYield from"OverloadYield";export default function _asyncGeneratorDelegate(t){var e={},n=!1;function pump(e,r){return n=!0,r=new Promise((function(n){n(t[e](r))})),{done:!1,value:new OverloadYield(r,1)}}return e["undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=function(){return this},e.next=function(t){return n?(n=!1,t):pump("next",t)},"function"==typeof t.throw&&(e.throw=function(t){if(n)throw n=!1,t;return pump("throw",t)}),"function"==typeof t.return&&(e.return=function(t){return n?(n=!1,t):pump("return",t)}),e}'
  ),
  asyncIterator: helper$3("7.15.9",
    'export default function _asyncIterator(r){var n,t,o,e=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIterator,o=Symbol.iterator);e--;){if(t&&null!=(n=r[t]))return n.call(r);if(o&&null!=(n=r[o]))return new AsyncFromSyncIterator(n.call(r));t="@@asyncIterator",o="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(r){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var n=r.done;return Promise.resolve(r.value).then((function(r){return{value:r,done:n}}))}return AsyncFromSyncIterator=function(r){this.s=r,this.n=r.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(r){var n=this.s.return;return void 0===n?Promise.resolve({value:r,done:!0}):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))},throw:function(r){var n=this.s.return;return void 0===n?Promise.reject(r):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))}},new AsyncFromSyncIterator(r)}'
  ),
  awaitAsyncGenerator: helper$3("7.0.0-beta.0",
    'import OverloadYield from"OverloadYield";export default function _awaitAsyncGenerator(e){return new OverloadYield(e,0)}'
  ),
  checkInRHS: helper$3("7.20.5",
    'export default function _checkInRHS(e){if(Object(e)!==e)throw TypeError("right-hand side of \'in\' should be an object, got "+(null!==e?typeof e:"null"));return e}'
  ),
  defineAccessor: helper$3("7.20.7",
    "export default function _defineAccessor(e,r,n,t){var c={configurable:!0,enumerable:!0};return c[e]=t,Object.defineProperty(r,n,c)}"
  ),
  dispose: helper$3("7.22.0",
    'function dispose_SuppressedError(r,e){return"undefined"!=typeof SuppressedError?dispose_SuppressedError=SuppressedError:(dispose_SuppressedError=function(r,e){this.suppressed=r,this.error=e,this.stack=(new Error).stack},dispose_SuppressedError.prototype=Object.create(Error.prototype,{constructor:{value:dispose_SuppressedError,writable:!0,configurable:!0}})),new dispose_SuppressedError(r,e)}export default function _dispose(r,e,s){function next(){for(;r.length>0;)try{var o=r.pop(),p=o.d.call(o.v);if(o.a)return Promise.resolve(p).then(next,err)}catch(r){return err(r)}if(s)throw e}function err(r){return e=s?new dispose_SuppressedError(r,e):r,s=!0,next()}return next()}'
  ),
  iterableToArrayLimit: helper$3("7.0.0-beta.0",
    'export default function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u))return}finally{if(o)throw n}}return a}}'
  ),
  iterableToArrayLimitLoose: helper$3("7.0.0-beta.0",
    'export default function _iterableToArrayLimitLoose(e,r){var t=e&&("undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"]);if(null!=t){var o,l=[];for(t=t.call(e);e.length<r&&!(o=t.next()).done;)l.push(o.value);return l}}'
  ),
  jsx: helper$3("7.0.0-beta.0",
    'var REACT_ELEMENT_TYPE;export default function _createRawReactElement(e,r,E,l){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var o=e&&e.defaultProps,n=arguments.length-3;if(r||0===n||(r={children:void 0}),1===n)r.children=l;else if(n>1){for(var t=new Array(n),f=0;f<n;f++)t[f]=arguments[f+3];r.children=t}if(r&&o)for(var i in o)void 0===r[i]&&(r[i]=o[i]);else r||(r=o||{});return{$$typeof:REACT_ELEMENT_TYPE,type:e,key:void 0===E?null:""+E,ref:null,props:r,_owner:null}}'
  ),
  objectSpread2: helper$3("7.5.0",
    'import defineProperty from"defineProperty";function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,o)}return t}export default function _objectSpread2(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach((function(r){defineProperty(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}'
  ),
  regeneratorRuntime: helper$3("7.18.0",
    'export default function _regeneratorRuntime(){"use strict";\n/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */_regeneratorRuntime=function(){return e};var t,e={},r=Object.prototype,n=r.hasOwnProperty,o=Object.defineProperty||function(t,e,r){t[e]=r.value},i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function define(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{define({},"")}catch(t){define=function(t,e,r){return t[e]=r}}function wrap(t,e,r,n){var i=e&&e.prototype instanceof Generator?e:Generator,a=Object.create(i.prototype),c=new Context(n||[]);return o(a,"_invoke",{value:makeInvokeMethod(t,r,c)}),a}function tryCatch(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}e.wrap=wrap;var h="suspendedStart",l="suspendedYield",f="executing",s="completed",y={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var p={};define(p,a,(function(){return this}));var d=Object.getPrototypeOf,v=d&&d(d(values([])));v&&v!==r&&n.call(v,a)&&(p=v);var g=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(p);function defineIteratorMethods(t){["next","throw","return"].forEach((function(e){define(t,e,(function(t){return this._invoke(e,t)}))}))}function AsyncIterator(t,e){function invoke(r,o,i,a){var c=tryCatch(t[r],t,o);if("throw"!==c.type){var u=c.arg,h=u.value;return h&&"object"==typeof h&&n.call(h,"__await")?e.resolve(h.__await).then((function(t){invoke("next",t,i,a)}),(function(t){invoke("throw",t,i,a)})):e.resolve(h).then((function(t){u.value=t,i(u)}),(function(t){return invoke("throw",t,i,a)}))}a(c.arg)}var r;o(this,"_invoke",{value:function(t,n){function callInvokeWithMethodAndArg(){return new e((function(e,r){invoke(t,n,e,r)}))}return r=r?r.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}})}function makeInvokeMethod(e,r,n){var o=h;return function(i,a){if(o===f)throw new Error("Generator is already running");if(o===s){if("throw"===i)throw a;return{value:t,done:!0}}for(n.method=i,n.arg=a;;){var c=n.delegate;if(c){var u=maybeInvokeDelegate(c,n);if(u){if(u===y)continue;return u}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(o===h)throw o=s,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);o=f;var p=tryCatch(e,r,n);if("normal"===p.type){if(o=n.done?s:l,p.arg===y)continue;return{value:p.arg,done:n.done}}"throw"===p.type&&(o=s,n.method="throw",n.arg=p.arg)}}}function maybeInvokeDelegate(e,r){var n=r.method,o=e.iterator[n];if(o===t)return r.delegate=null,"throw"===n&&e.iterator.return&&(r.method="return",r.arg=t,maybeInvokeDelegate(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a \'"+n+"\' method")),y;var i=tryCatch(o,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,y;var a=i.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,y):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function pushTryEntry(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function resetTryEntry(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function Context(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(pushTryEntry,this),this.reset(!0)}function values(e){if(e||""===e){var r=e[a];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var o=-1,i=function next(){for(;++o<e.length;)if(n.call(e,o))return next.value=e[o],next.done=!1,next;return next.value=t,next.done=!0,next};return i.next=i}}throw new TypeError(typeof e+" is not iterable")}return GeneratorFunction.prototype=GeneratorFunctionPrototype,o(g,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),o(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,u,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===GeneratorFunction||"GeneratorFunction"===(e.displayName||e.name))},e.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,define(t,u,"GeneratorFunction")),t.prototype=Object.create(g),t},e.awrap=function(t){return{__await:t}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,c,(function(){return this})),e.AsyncIterator=AsyncIterator,e.async=function(t,r,n,o,i){void 0===i&&(i=Promise);var a=new AsyncIterator(wrap(t,r,n,o),i);return e.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},defineIteratorMethods(g),define(g,u,"Generator"),define(g,a,(function(){return this})),define(g,"toString",(function(){return"[object Generator]"})),e.keys=function(t){var e=Object(t),r=[];for(var n in e)r.push(n);return r.reverse(),function next(){for(;r.length;){var t=r.pop();if(t in e)return next.value=t,next.done=!1,next}return next.done=!0,next}},e.values=values,Context.prototype={constructor:Context,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(resetTryEntry),!e)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function handle(n,o){return a.type="throw",a.arg=e,r.next=n,o&&(r.method="next",r.arg=t),!!o}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],a=i.completion;if("root"===i.tryLoc)return handle("end");if(i.tryLoc<=this.prev){var c=n.call(i,"catchLoc"),u=n.call(i,"finallyLoc");if(c&&u){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0);if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}else if(c){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0)}else{if(!u)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;resetTryEntry(r)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:values(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),y}},e}'
  ),
  typeof: helper$3("7.0.0-beta.0",
    'export default function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},_typeof(o)}'
  ),
  using: helper$3("7.22.0",
    'export default function _using(o,e,n){if(null==e)return e;if("object"!=typeof e)throw new TypeError("using declarations can only be used with objects, null, or undefined.");if(n)var r=e[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==r&&(r=e[Symbol.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof r)throw new TypeError("Property [Symbol.dispose] is not a function.");return o.push({v:e,d:r,a:n}),e}'
  ),
  wrapRegExp: helper$3("7.19.0",
    'import setPrototypeOf from"setPrototypeOf";import inherits from"inherits";export default function _wrapRegExp(){_wrapRegExp=function(e,r){return new BabelRegExp(e,void 0,r)};var e=RegExp.prototype,r=new WeakMap;function BabelRegExp(e,t,p){var o=new RegExp(e,t);return r.set(o,p||r.get(e)),setPrototypeOf(o,BabelRegExp.prototype)}function buildGroups(e,t){var p=r.get(t);return Object.keys(p).reduce((function(r,t){var o=p[t];if("number"==typeof o)r[t]=e[o];else{for(var i=0;void 0===e[o[i]]&&i+1<o.length;)i++;r[t]=e[o[i]]}return r}),Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(r){var t=e.exec.call(this,r);if(t){t.groups=buildGroups(t,this);var p=t.indices;p&&(p.groups=buildGroups(p,this))}return t},BabelRegExp.prototype[Symbol.replace]=function(t,p){if("string"==typeof p){var o=r.get(this);return e[Symbol.replace].call(this,t,p.replace(/\\$<([^>]+)>/g,(function(e,r){var t=o[r];return"$"+(Array.isArray(t)?t.join("$"):t)})))}if("function"==typeof p){var i=this;return e[Symbol.replace].call(this,t,(function(){var e=arguments;return"object"!=typeof e[e.length-1]&&(e=[].slice.call(e)).push(buildGroups(e,i)),p.apply(this,e)}))}return e[Symbol.replace].call(this,t,p)},_wrapRegExp.apply(this,arguments)}'
  )
});

const helpers$1 = Object.assign({ __proto__: null }, generated),
  helper$2 = minVersion => tpl => ({ minVersion, ast: () => template$1.program.ast(tpl) });

helpers$1.AwaitValue = helper$2("7.0.0-beta.0")`
  export default function _AwaitValue(value) {
    this.wrapped = value;
  }
`;

helpers$1.wrapAsyncGenerator = helper$2("7.0.0-beta.0")`
  import AsyncGenerator from "AsyncGenerator";

  export default function _wrapAsyncGenerator(fn) {
    return function () {
      return new AsyncGenerator(fn.apply(this, arguments));
    };
  }
`;
helpers$1.asyncToGenerator = helper$2("7.0.0-beta.0")`
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg),
        value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    info.done ? resolve(value) : Promise.resolve(value).then(_next, _throw);
  }

  export default function _asyncToGenerator(fn) {
    return function () {
      var self = this, args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(void 0);
      });
    };
  }
`;
helpers$1.classCallCheck = helper$2("7.0.0-beta.0")`
  export default function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
  }
`;
helpers$1.createClass = helper$2("7.0.0-beta.0")`
  import toPropertyKey from "toPropertyKey";
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
    }
  }

  export default function _createClass(Constructor, protoProps, staticProps) {
    protoProps && _defineProperties(Constructor.prototype, protoProps);
    staticProps && _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
`;
helpers$1.defineEnumerableProperties = helper$2("7.0.0-beta.0")`
  export default function _defineEnumerableProperties(obj, descs) {
    for (var key in descs) {
      (desc = descs[key]).configurable = desc.enumerable = true;
      if ("value" in desc) desc.writable = true;
      Object.defineProperty(obj, key, desc);
    }

    if (Object.getOwnPropertySymbols)
      for (var objectSymbols = Object.getOwnPropertySymbols(descs), i = 0; i < objectSymbols.length; i++) {
        var sym = objectSymbols[i],
          desc = descs[sym];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, sym, desc);
      }

    return obj;
  }
`;
helpers$1.defaults = helper$2("7.0.0-beta.0")`
  export default function _defaults(obj, defaults) {
    for (var keys = Object.getOwnPropertyNames(defaults), i = 0; i < keys.length; i++) {
      var key = keys[i],
        value = Object.getOwnPropertyDescriptor(defaults, key);
      value && value.configurable && obj[key] === void 0 && Object.defineProperty(obj, key, value);
    }
    return obj;
  }
`;
helpers$1.defineProperty = helper$2("7.0.0-beta.0")`
  import toPropertyKey from "toPropertyKey";
  export default function _defineProperty(obj, key, value) {
    (key = toPropertyKey(key)) in obj
      ? Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true })
      : (obj[key] = value);

    return obj;
  }
`;
helpers$1.extends = helper$2("7.0.0-beta.0")`
  export default function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
      }
      return target;
    };

    return _extends.apply(this, arguments);
  }
`;

helpers$1.objectSpread = helper$2("7.0.0-beta.0")`
  import defineProperty from "defineProperty";

  export default function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? Object(arguments[i]) : {},
        ownKeys = Object.keys(source);
      typeof Object.getOwnPropertySymbols != 'function' ||
        ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));

      ownKeys.forEach(function(key) {
        defineProperty(target, key, source[key]);
      });
    }
    return target;
  }
`;

helpers$1.inherits = helper$2("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inherits(subClass, superClass) {
    if (typeof superClass != "function" && superClass !== null)
      throw new TypeError("Super expression must either be null or a function");

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: { value: subClass, writable: true, configurable: true }
    });
    Object.defineProperty(subClass, "prototype", { writable: false });
    superClass && setPrototypeOf(subClass, superClass);
  }
`;
helpers$1.inheritsLoose = helper$2("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    setPrototypeOf(subClass, superClass);
  }
`;
helpers$1.getPrototypeOf = helper$2("7.0.0-beta.0")`
  export default function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }
`;
helpers$1.setPrototypeOf = helper$2("7.0.0-beta.0")`
  export default function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
`;
helpers$1.isNativeReflectConstruct = helper$2("7.9.0")`
  export default function _isNativeReflectConstruct() {
    if (typeof Reflect == "undefined" || !Reflect.construct || Reflect.construct.sham) return false;

    if (typeof Proxy == "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
      return true;
    } catch (_e) {
      return false;
    }
  }
`;
helpers$1.construct = helper$2("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";
  import isNativeReflectConstruct from "isNativeReflectConstruct";

  export default function _construct(Parent, args, Class) {
    _construct = isNativeReflectConstruct() ? Reflect.construct.bind() : function (Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a),
        instance = new Constructor();
      Class && setPrototypeOf(instance, Class.prototype);
      return instance;
    };

    return _construct.apply(null, arguments);
  }
`;
helpers$1.isNativeFunction = helper$2("7.0.0-beta.0")`
  export default function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") > -1;
  }
`;
helpers$1.wrapNativeSuper = helper$2("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";
  import setPrototypeOf from "setPrototypeOf";
  import isNativeFunction from "isNativeFunction";
  import construct from "construct";

  export default function _wrapNativeSuper(Class) {
    var _cache = typeof Map == "function" ? new Map() : void 0;

    _wrapNativeSuper = function (Class) {
      if (Class === null || !isNativeFunction(Class)) return Class;
      if (typeof Class != "function") throw new TypeError("Super expression must either be null or a function");

      if (_cache !== void 0) {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return construct(Class, arguments, getPrototypeOf(this).constructor);
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true }
      });

      return setPrototypeOf(Wrapper, Class);
    }

    return _wrapNativeSuper(Class)
  }
`;
helpers$1.instanceof = helper$2("7.0.0-beta.0")`
  export default function _instanceof(left, right) {
    return right != null && typeof Symbol != "undefined" && right[Symbol.hasInstance]
      ? !!right[Symbol.hasInstance](left)
      : left instanceof right;
  }
`;
helpers$1.interopRequireDefault = helper$2("7.0.0-beta.0")`
  export default function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
`;
helpers$1.interopRequireWildcard = helper$2("7.14.0")`
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap != "function") return null;

    var cacheBabelInterop = new WeakMap(),
      cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function (nodeInterop) {
      return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }

  export default function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) return obj;

    if (obj === null || (typeof obj != "object" && typeof obj != "function")) return { default: obj };

    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) return cache.get(obj);

    var newObj = {},
      hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj)
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : (newObj[key] = obj[key]);
      }

    newObj.default = obj;
    cache && cache.set(obj, newObj);

    return newObj;
  }
`;
helpers$1.newArrowCheck = helper$2("7.0.0-beta.0")`
  export default function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) throw new TypeError("Cannot instantiate an arrow function");
  }
`;
helpers$1.objectDestructuringEmpty = helper$2("7.0.0-beta.0")`
  export default function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure " + obj);
  }
`;
helpers$1.objectWithoutPropertiesLoose = helper$2("7.0.0-beta.0")`
  export default function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};

    var target = {};

    for (var key, sourceKeys = Object.keys(source), i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) < 0) target[key] = source[key];
    }

    return target;
  }
`;
helpers$1.objectWithoutProperties = helper$2("7.0.0-beta.0")`
  import objectWithoutPropertiesLoose from "objectWithoutPropertiesLoose";

  export default function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = objectWithoutPropertiesLoose(source, excluded);

    if (Object.getOwnPropertySymbols)
      for (var key, sourceSymbolKeys = Object.getOwnPropertySymbols(source), i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) < 0 && Object.prototype.propertyIsEnumerable.call(source, key))
          target[key] = source[key];
      }

    return target;
  }
`;
helpers$1.assertThisInitialized = helper$2("7.0.0-beta.0")`
  export default function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");

    return self;
  }
`;
helpers$1.possibleConstructorReturn = helper$2("7.0.0-beta.0")`
  import assertThisInitialized from "assertThisInitialized";

  export default function _possibleConstructorReturn(self, call) {
    if (call && (typeof call == "object" || typeof call == "function")) return call;

    if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");

    return assertThisInitialized(self);
  }
`;
helpers$1.createSuper = helper$2("7.9.0")`
  import getPrototypeOf from "getPrototypeOf";
  import isNativeReflectConstruct from "isNativeReflectConstruct";
  import possibleConstructorReturn from "possibleConstructorReturn";

  export default function _createSuper(Derived) {
    var hasNativeReflectConstruct = isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else result = Super.apply(this, arguments);

      return possibleConstructorReturn(this, result);
    }
  }
 `;
helpers$1.superPropBase = helper$2("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";

  export default function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property) && (object = getPrototypeOf(object)) !== null);

    return object;
  }
`;
helpers$1.get = helper$2("7.0.0-beta.0")`
  import superPropBase from "superPropBase";

  export default function _get() {
    _get = typeof Reflect != "undefined" && Reflect.get ? Reflect.get.bind() : function (target, property, receiver) {
      var base = superPropBase(target, property);

      if (!base) return;

      var desc = Object.getOwnPropertyDescriptor(base, property);
      return desc.get ? desc.get.call(arguments.length < 3 ? target : receiver) : desc.value;
    };

    return _get.apply(this, arguments);
  }
`;
helpers$1.set = helper$2("7.0.0-beta.0")`
  import superPropBase from "superPropBase";
  import defineProperty from "defineProperty";

  function set(target, property, value, receiver) {
    set = typeof Reflect != "undefined" && Reflect.set ? Reflect.set : function (target, property, value, receiver) {
      var desc,
        base = superPropBase(target, property);

      if (base) {
        if ((desc = Object.getOwnPropertyDescriptor(base, property)).set) {
          desc.set.call(receiver, value);
          return true;
        }
        if (!desc.writable) return false;
      }

      if ((desc = Object.getOwnPropertyDescriptor(receiver, property))) {
        if (!desc.writable) return false;

        desc.value = value;
        Object.defineProperty(receiver, property, desc);
      } else defineProperty(receiver, property, value);

      return true;
    };

    return set(target, property, value, receiver);
  }

  export default function _set(target, property, value, receiver, isStrict) {
    if (!set(target, property, value, receiver || target) && isStrict) throw new TypeError('failed to set property');

    return value;
  }
`;
helpers$1.taggedTemplateLiteral = helper$2("7.0.0-beta.0")`
  export default function _taggedTemplateLiteral(strings, raw) {
    raw || (raw = strings.slice(0));
    return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
  }
`;
helpers$1.taggedTemplateLiteralLoose = helper$2("7.0.0-beta.0")`
  export default function _taggedTemplateLiteralLoose(strings, raw) {
    raw || (raw = strings.slice(0));
    strings.raw = raw;
    return strings;
  }
`;
helpers$1.readOnlyError = helper$2("7.0.0-beta.0")`
  export default function _readOnlyError(name) {
    throw new TypeError('"' + name + '" is read-only');
  }
`;
helpers$1.writeOnlyError = helper$2("7.12.13")`
  export default function _writeOnlyError(name) {
    throw new TypeError('"' + name + '" is write-only');
  }
`;
helpers$1.classNameTDZError = helper$2("7.0.0-beta.0")`
  export default function _classNameTDZError(name) {
    throw new ReferenceError('Class "' + name + '" cannot be referenced in computed property keys.');
  }
`;
helpers$1.temporalUndefined = helper$2("7.0.0-beta.0")`
  export default function _temporalUndefined() {}
`;
helpers$1.tdz = helper$2("7.5.5")`
  export default function _tdzError(name) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  }
`;
helpers$1.temporalRef = helper$2("7.0.0-beta.0")`
  import undef from "temporalUndefined";
  import err from "tdz";

  export default function _temporalRef(val, name) {
    return val === undef ? err(name) : val;
  }
`;
helpers$1.slicedToArray = helper$2("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimit from "iterableToArrayLimit";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArray(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimit(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`;
helpers$1.slicedToArrayLoose = helper$2("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimitLoose from "iterableToArrayLimitLoose";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArrayLoose(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimitLoose(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`;
helpers$1.toArray = helper$2("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _toArray(arr) {
    return (
      arrayWithHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableRest()
    );
  }
`;
helpers$1.toConsumableArray = helper$2("7.0.0-beta.0")`
  import arrayWithoutHoles from "arrayWithoutHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableSpread from "nonIterableSpread";

  export default function _toConsumableArray(arr) {
    return (
      arrayWithoutHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableSpread()
    );
  }
`;
helpers$1.arrayWithoutHoles = helper$2("7.0.0-beta.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
  }
`;
helpers$1.arrayWithHoles = helper$2("7.0.0-beta.0")`
  export default function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
`;
helpers$1.maybeArrayLike = helper$2("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _maybeArrayLike(next, arr, i) {
    if (arr && !Array.isArray(arr) && typeof arr.length == "number") {
      var len = arr.length;
      return arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);
    }
    return next(arr, i);
  }
`;
helpers$1.iterableToArray = helper$2("7.0.0-beta.0")`
  export default function _iterableToArray(iter) {
    if ((typeof Symbol != "undefined" && iter[Symbol.iterator] != null) || iter["@@iterator"] != null)
      return Array.from(iter);
  }
`;
helpers$1.unsupportedIterableToArray = helper$2("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o == "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
  }
`;
helpers$1.arrayLikeToArray = helper$2("7.9.0")`
  export default function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
`;
helpers$1.nonIterableSpread = helper$2("7.0.0-beta.0")`
  export default function _nonIterableSpread() {
    throw new TypeError(
      "Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`;
helpers$1.nonIterableRest = helper$2("7.0.0-beta.0")`
  export default function _nonIterableRest() {
    throw new TypeError(
      "Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`;
helpers$1.createForOfIteratorHelper = helper$2("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  // s: start (create the iterator)
  // n: next
  // e: error (called whenever something throws)
  // f: finish (always called at the end)

  export default function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = (typeof Symbol != "undefined" && o[Symbol.iterator]) || o["@@iterator"];

    if (!it) {
      // Fallback for engines without symbol support
      if (
        Array.isArray(o) ||
        (it = unsupportedIterableToArray(o)) ||
        (allowArrayLike && o && typeof o.length == "number")
      ) {
        if (it) o = it;
        var i = 0,
          F = function() {};
        return {
          s: F,
          n: function() {
            return i >= o.length ? { done: true } : { done: false, value: o[i++] };
          },
          e: function(e) { throw e; },
          f: F,
        };
      }

      throw new TypeError(
        "Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
      );
    }

    var err, normalCompletion = true, didErr = false;

    return {
      s: function() {
        it = it.call(o);
      },
      n: function() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function(e) {
        didErr = true;
        err = e;
      },
      f: function() {
        try {
          normalCompletion || it.return == null || it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }
`;
helpers$1.createForOfIteratorHelperLoose = helper$2("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = (typeof Symbol != "undefined" && o[Symbol.iterator]) || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);

    // Fallback for engines without symbol support
    if (
      Array.isArray(o) ||
      (it = unsupportedIterableToArray(o)) ||
      (allowArrayLike && o && typeof o.length == "number")
    ) {
      if (it) o = it;
      var i = 0;
      return function() {
        return i >= o.length ? { done: true } : { done: false, value: o[i++] };
      }
    }

    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`;
helpers$1.skipFirstGeneratorNext = helper$2("7.0.0-beta.0")`
  export default function _skipFirstGeneratorNext(fn) {
    return function () {
      var it = fn.apply(this, arguments);
      it.next();
      return it;
    }
  }
`;
helpers$1.toPrimitive = helper$2("7.1.5")`
  export default function _toPrimitive(
    input,
    hint /*: "default" | "string" | "number" | void */
  ) {
    if (typeof input != "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res != "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
`;
helpers$1.toPropertyKey = helper$2("7.1.5")`
  import toPrimitive from "toPrimitive";

  export default function _toPropertyKey(arg) {
    var key = toPrimitive(arg, "string");
    return typeof key == "symbol" ? key : String(key);
  }
`;
helpers$1.initializerWarningHelper = helper$2("7.0.0-beta.0")`
  export default function _initializerWarningHelper(descriptor, context) {
    throw new Error(
      'Decorating class property failed. Please ensure that transform-class-properties is enabled and runs after the decorators transform.'
    );
  }
`;
helpers$1.initializerDefineProperty = helper$2("7.0.0-beta.0")`
  export default function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;

    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }
`;
helpers$1.applyDecoratedDescriptor = helper$2("7.0.0-beta.0")`
  export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function(key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) desc.writable = true;

    desc = decorators.slice().reverse().reduce(function(desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = void 0;
    }

    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }

    return desc;
  }
`;
helpers$1.classPrivateFieldLooseKey = helper$2("7.0.0-beta.0")`
  var id = 0;
  export default function _classPrivateFieldKey(name) {
    return "__private_" + id++ + "_" + name;
  }
`;
helpers$1.classPrivateFieldLooseBase = helper$2("7.0.0-beta.0")`
  export default function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey))
      throw new TypeError("attempted to use private field on non-instance");

    return receiver;
  }
`;
helpers$1.classPrivateFieldGet = helper$2("7.0.0-beta.0")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`;
helpers$1.classPrivateFieldSet = helper$2("7.0.0-beta.0")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`;
helpers$1.classPrivateFieldDestructureSet = helper$2("7.4.4")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`;
helpers$1.classExtractFieldDescriptor = helper$2("7.13.10")`
  export default function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) throw new TypeError("attempted to " + action + " private field on non-instance");

    return privateMap.get(receiver);
  }
`;
helpers$1.classStaticPrivateFieldSpecGet = helper$2("7.0.2")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`;
helpers$1.classStaticPrivateFieldSpecSet = helper$2("7.0.2")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`;
helpers$1.classStaticPrivateMethodGet = helper$2("7.3.2")`
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    return method;
  }
`;
helpers$1.classStaticPrivateMethodSet = helper$2("7.3.2")`
  export default function _classStaticPrivateMethodSet() {
    throw new TypeError("attempted to set read only static private field");
  }
`;
helpers$1.classApplyDescriptorGet = helper$2("7.13.10")`
  export default function _classApplyDescriptorGet(receiver, descriptor) {
    return descriptor.get ? descriptor.get.call(receiver) : descriptor.value;
  }
`;
helpers$1.classApplyDescriptorSet = helper$2("7.13.10")`
  export default function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) descriptor.set.call(receiver, value);
    else {
      if (!descriptor.writable) throw new TypeError("attempted to set read only private field");

      descriptor.value = value;
    }
  }
`;
helpers$1.classApplyDescriptorDestructureSet = helper$2("7.13.10")`
  export default function _classApplyDescriptorDestructureSet(receiver, descriptor) {
    if (descriptor.set) {
      "__destrObj" in descriptor ||
        (descriptor.__destrObj = {
          set value(v) {
            descriptor.set.call(receiver, v);
          }
        });

      return descriptor.__destrObj;
    }

    if (!descriptor.writable) throw new TypeError("attempted to set read only private field");

    return descriptor;
  }
`;
helpers$1.classStaticPrivateFieldDestructureSet = helper$2("7.13.10")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`;
helpers$1.classCheckPrivateStaticAccess = helper$2("7.13.10")`
  export default function _classCheckPrivateStaticAccess(receiver, classConstructor) {
    if (receiver !== classConstructor) throw new TypeError("Private static access of wrong provenance");
  }
`;
helpers$1.classCheckPrivateStaticFieldDescriptor = helper$2("7.13.10")`
  export default function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {
    if (descriptor === void 0)
      throw new TypeError("attempted to " + action + " private static field before its declaration");
  }
`;
helpers$1.decorate = helper$2("7.1.5")`
  import toArray from "toArray";
  import toPropertyKey from "toPropertyKey";

  export default function _decorate(
    decorators /*: ClassDecorator[] */,
    factory /*: ClassFactory */,
    superClass /*: ?Class<*> */,
    mixins /*: ?Array<Function> */
  ) /*: Class<*> */ {
    var api = _getDecoratorsApi();
    if (mixins) for (var i = 0; i < mixins.length; i++) api = mixins[i](api);

    var r = factory(function (O) {
      api.initializeInstanceElements(O, decorated.elements);
    }, superClass);
    var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators);

    api.initializeClassElements(r.F, decorated.elements);

    return api.runClassFinishers(r.F, decorated.finishers);
  }

  function _getDecoratorsApi() {
    _getDecoratorsApi = function() {
      return api;
    };

    var api = {
      elementsDefinitionOrder: [["method"], ["field"]],

      initializeInstanceElements: function(O, elements) {
        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element) {
            element.kind !== kind || element.placement !== "own" || this.defineClassElement(O, element);
          }, this);
        }, this);
      },

      initializeClassElements: function(F /*: Class<C> */, elements) {
        var proto = F.prototype;

        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element) {
            var placement = element.placement;
            if (element.kind === kind && (placement === "static" || placement === "prototype")) {
              var receiver = placement === "static" ? F : proto;
              this.defineClassElement(receiver, element);
            }
          }, this);
        }, this);
      },

      defineClassElement: function(receiver /*: C | Class<C> */, element) {
        var descriptor = element.descriptor;
        if (element.kind === "field") {
          var initializer = element.initializer;
          descriptor = {
            enumerable: descriptor.enumerable,
            writable: descriptor.writable,
            configurable: descriptor.configurable,
            value: initializer === void 0 ? void 0 : initializer.call(receiver)
          };
        }
        Object.defineProperty(receiver, element.key, descriptor);
      },

      decorateClass: function(elements, decorators) /*: ElementsFinishers */ {
        var newElements = [],
          finishers /*: ClassFinisher[] */ = [],
          placements = { static: [], prototype: [], own: [] };

        elements.forEach(function(element) {
          this.addElementPlacement(element, placements);
        }, this);

        elements.forEach(function(element) {
          if (!_hasDecorators(element)) return newElements.push(element);

          var elementFinishersExtras = this.decorateElement(element, placements);
          newElements.push(elementFinishersExtras.element);
          newElements.push.apply(newElements, elementFinishersExtras.extras);
          finishers.push.apply(finishers, elementFinishersExtras.finishers);
        }, this);

        if (!decorators) return { elements: newElements, finishers: finishers };

        var result = this.decorateConstructor(newElements, decorators);
        finishers.push.apply(finishers, result.finishers);
        result.finishers = finishers;

        return result;
      },

      addElementPlacement: function(element, placements, silent /*: boolean */) {
        var keys = placements[element.placement];
        if (!silent && keys.indexOf(element.key) > -1)
          throw new TypeError("Duplicated element (" + element.key + ")");

        keys.push(element.key);
      },

      decorateElement: function(element, placements) /*: ElementFinishersExtras */ {
        var extras /*: ElementDescriptor[] */ = [],
          finishers = [];

        for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) {
          var keys = placements[element.placement];
          keys.splice(keys.indexOf(element.key), 1);

          var elementObject = this.fromElementDescriptor(element),
            elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject);

          element = elementFinisherExtras.element;
          this.addElementPlacement(element, placements);

          elementFinisherExtras.finisher && finishers.push(elementFinisherExtras.finisher);

          var newExtras = elementFinisherExtras.extras;
          if (newExtras) {
            for (var j = 0; j < newExtras.length; j++) this.addElementPlacement(newExtras[j], placements);

            extras.push.apply(extras, newExtras);
          }
        }

        return { element: element, finishers: finishers, extras: extras };
      },

      decorateConstructor: function(elements, decorators) /*: ElementsFinishers */ {
        var finishers = [];

        for (var i = decorators.length - 1; i >= 0; i--) {
          var obj = this.fromClassDescriptor(elements),
            elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj);

          elementsAndFinisher.finisher === void 0 || finishers.push(elementsAndFinisher.finisher);

          if (elementsAndFinisher.elements !== void 0) {
            elements = elementsAndFinisher.elements;

            for (var j = 0; j < elements.length - 1; j++)
              for (var k = j + 1; k < elements.length; k++)
                if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement)
                  throw new TypeError("Duplicated element (" + elements[j].key + ")");
          }
        }

        return { elements: elements, finishers: finishers };
      },

      fromElementDescriptor: function(element) /*: ElementObject */ {
        var obj = {
          kind: element.kind,
          key: element.key,
          placement: element.placement,
          descriptor: element.descriptor
        };

        Object.defineProperty(obj, Symbol.toStringTag, { value: "Descriptor", configurable: true });

        if (element.kind === "field") obj.initializer = element.initializer;

        return obj;
      },

      toElementDescriptors: function(elementObjects) {
        if (elementObjects !== void 0)
          return toArray(elementObjects).map(function(elementObject) {
            var element = this.toElementDescriptor(elementObject);
            this.disallowProperty(elementObject, "finisher", "An element descriptor");
            this.disallowProperty(elementObject, "extras", "An element descriptor");
            return element;
          }, this);
      },

      toElementDescriptor: function(elementObject) {
        var kind = String(elementObject.kind);
        if (kind !== "method" && kind !== "field")
          throw new TypeError(
            'An element descriptor\\'s .kind property must be either "method" or "field", but a decorator created an element descriptor with .kind "' +
              kind + '"'
          );

        var key = toPropertyKey(elementObject.key),

          placement = String(elementObject.placement);
        if (placement !== "static" && placement !== "prototype" && placement !== "own")
          throw new TypeError(
            'An element descriptor\\'s .placement property must be one of "static", "prototype" or "own", but a decorator created an element descriptor with .placement "' +
              placement + '"'
          );

        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;

        this.disallowProperty(elementObject, "elements", "An element descriptor");

        var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) };

        if (kind !== "field") this.disallowProperty(elementObject, "initializer", "A method descriptor");
        else {
          this.disallowProperty(descriptor, "get", "The property descriptor of a field descriptor");
          this.disallowProperty(descriptor, "set", "The property descriptor of a field descriptor");
          this.disallowProperty(descriptor, "value", "The property descriptor of a field descriptor");

          element.initializer = elementObject.initializer;
        }

        return element;
      },

      toElementFinisherExtras: function(elementObject) {
        return {
          element: this.toElementDescriptor(elementObject),
          finisher: _optionalCallableProperty(elementObject, "finisher"),
          extras: this.toElementDescriptors(elementObject.extras)
        };
      },

      fromClassDescriptor: function(elements) /*: ClassObject */ {
        var obj = { kind: "class", elements: elements.map(this.fromElementDescriptor, this) };

        Object.defineProperty(obj, Symbol.toStringTag, { value: "Descriptor", configurable: true });

        return obj;
      },

      toClassDescriptor: function(obj /*: ClassObject */) /*: ElementsFinisher */ {
        var kind = String(obj.kind);
        if (kind !== "class")
          throw new TypeError(
            'A class descriptor\\'s .kind property must be "class", but a decorator created a class descriptor with .kind "' +
              kind + '"'
          );

        this.disallowProperty(obj, "key", "A class descriptor");
        this.disallowProperty(obj, "placement", "A class descriptor");
        this.disallowProperty(obj, "descriptor", "A class descriptor");
        this.disallowProperty(obj, "initializer", "A class descriptor");
        this.disallowProperty(obj, "extras", "A class descriptor");

        var finisher = _optionalCallableProperty(obj, "finisher");

        return { elements: this.toElementDescriptors(obj.elements), finisher: finisher };
      },

      runClassFinishers: function(constructor /*: Class<*> */, finishers) /*: Class<*> */ {
        for (var i = 0; i < finishers.length; i++) {
          var newConstructor = (0, finishers[i])(constructor);
          if (newConstructor !== void 0) {
            if (typeof newConstructor != "function") throw new TypeError("Finishers must return a constructor.");

            constructor = newConstructor;
          }
        }
        return constructor;
      },

      disallowProperty: function(obj, name, objectType) {
        if (obj[name] !== void 0) throw new TypeError(objectType + " can't have a ." + name + " property.");
      }
    };

    return api;
  }

  function _createElementDescriptor(def /*: ElementDefinition */) {
    var descriptor,
      key = toPropertyKey(def.key);

    def.kind === "method"
      ? (descriptor = { value: def.value, writable: true, configurable: true, enumerable: false })
      : def.kind === "get"
      ? (descriptor = { get: def.value, configurable: true, enumerable: false })
      : def.kind === "set"
      ? (descriptor = { set: def.value, configurable: true, enumerable: false })
      : def.kind !== "field" || (descriptor = { configurable: true, writable: true, enumerable: true });

    var element = {
      kind: def.kind === "field" ? "field" : "method",
      key: key,
      placement: def.static ? "static" : def.kind === "field" ? "own" : "prototype",
      descriptor: descriptor
    };
    if (def.decorators) element.decorators = def.decorators;
    if (def.kind === "field") element.initializer = def.value;

    return element;
  }

  function _coalesceGetterSetter(element, other) {
    element.descriptor.get !== void 0
      ? (other.descriptor.get = element.descriptor.get)
      : (other.descriptor.set = element.descriptor.set);
  }

  function _coalesceClassElements(elements) /*: ElementDescriptor[] */ {
    var newElements = [];

    var isSameElement = function(other) {
      return other.kind === "method" && other.key === element.key && other.placement === element.placement;
    };

    for (var i = 0; i < elements.length; i++) {
      var other,
        element = elements[i];

      if (element.kind === "method" && (other = newElements.find(isSameElement)))
        if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) {
          if (_hasDecorators(element) || _hasDecorators(other))
            throw new ReferenceError("Duplicated methods (" + element.key + ") can't be decorated.");

          other.descriptor = element.descriptor;
        } else {
          if (_hasDecorators(element)) {
            if (_hasDecorators(other))
              throw new ReferenceError(
                "Decorators can't be placed on different accessors with for the same property (" + element.key + ")."
              );

            other.decorators = element.decorators;
          }
          _coalesceGetterSetter(element, other);
        }
      else newElements.push(element);
    }

    return newElements;
  }

  function _hasDecorators(element) {
    return element.decorators && element.decorators.length;
  }

  function _isDataDescriptor(desc) {
    return desc !== void 0 && !(desc.value === void 0 && desc.writable === void 0);
  }

  function _optionalCallableProperty(obj, name) /*: ?Function */ {
    var value = obj[name];
    if (value !== void 0 && typeof value != "function")
      throw new TypeError("Expected '" + name + "' to be a function");

    return value;
  }

`;
helpers$1.classPrivateMethodGet = helper$2("7.1.6")`
  export default function _classPrivateMethodGet(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) throw new TypeError("attempted to get private field on non-instance");

    return fn;
  }
`;
helpers$1.checkPrivateRedeclaration = helper$2("7.14.1")`
  export default function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj))
      throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
`;
helpers$1.classPrivateFieldInitSpec = helper$2("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateFieldInitSpec(obj, privateMap, value) {
    checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
  }
`;
helpers$1.classPrivateMethodInitSpec = helper$2("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateMethodInitSpec(obj, privateSet) {
    checkPrivateRedeclaration(obj, privateSet);
    privateSet.add(obj);
  }
`;

helpers$1.classPrivateMethodSet = helper$2("7.1.6")`
  export default function _classPrivateMethodSet() {
    throw new TypeError("attempted to reassign private method");
  }
`;

helpers$1.identity = helper$2("7.17.0")`
  export default function _identity(x) {
    return x;
  }
`;

const {
  assignmentExpression: assignmentExpression$9,
  cloneNode: cloneNode$d,
  expressionStatement: expressionStatement$5,
  file: file$1,
  identifier: identifier$c
} = t$5;
function makePath(path) {
  const parts = [];
  for (; path.parentPath; path = path.parentPath) {
    parts.push(path.key);
    path.inList && parts.push(path.listKey);
  }
  return parts.reverse().join(".");
}
let FileClass = void 0;
function getHelperMetadata(file) {
  const globals = new Set(),
    localBindingNames = new Set(),
    dependencies = new Map();
  let exportName, exportPath;
  const exportBindingAssignments = [],
    importPaths = [],
    importBindingsReferences = [];
  const dependencyVisitor = {
    ImportDeclaration(child) {
      const name = child.node.source.value;
      if (!helpers$1[name]) throw child.buildCodeFrameError("Unknown helper " + name);

      if (child.get("specifiers").length !== 1 || !child.get("specifiers.0").isImportDefaultSpecifier())
        throw child.buildCodeFrameError("Helpers can only import a default value");

      const bindingIdentifier = child.node.specifiers[0].local;
      dependencies.set(bindingIdentifier, name);
      importPaths.push(makePath(child));
    },
    ExportDefaultDeclaration(child) {
      const decl = child.get("declaration");
      if (!decl.isFunctionDeclaration() || !decl.node.id)
        throw decl.buildCodeFrameError("Helpers can only export named function declarations");

      exportName = decl.node.id.name;
      exportPath = makePath(child);
    },
    ExportAllDeclaration(child) {
      throw child.buildCodeFrameError("Helpers can only export default");
    },
    ExportNamedDeclaration(child) {
      throw child.buildCodeFrameError("Helpers can only export default");
    },
    Statement(child) {
      child.isImportDeclaration() || child.isExportDeclaration() || child.skip();
    }
  };
  const referenceVisitor = {
    Program(path) {
      const bindings = path.scope.getAllBindings();
      Object.keys(bindings).forEach(name => {
        name === exportName || dependencies.has(bindings[name].identifier) || localBindingNames.add(name);
      });
    },
    ReferencedIdentifier(child) {
      const name = child.node.name,
        binding = child.scope.getBinding(name);
      binding
        ? dependencies.has(binding.identifier) && importBindingsReferences.push(makePath(child))
        : globals.add(name);
    },
    AssignmentExpression(child) {
      const left = child.get("left");
      if (!(exportName in left.getBindingIdentifiers())) return;
      if (!left.isIdentifier())
        throw left.buildCodeFrameError("Only simple assignments to exports are allowed in helpers");

      const binding = child.scope.getBinding(exportName);
      binding != null && binding.scope.path.isProgram() && exportBindingAssignments.push(makePath(child));
    }
  };
  traverse.default(file.ast, dependencyVisitor, file.scope);
  traverse.default(file.ast, referenceVisitor, file.scope);
  if (!exportPath) throw new Error("Helpers must have a default export.");
  exportBindingAssignments.reverse();
  return {
    globals: Array.from(globals),
    localBindingNames: Array.from(localBindingNames),
    dependencies,
    exportBindingAssignments,
    exportPath,
    exportName,
    importBindingsReferences,
    importPaths
  };
}
function permuteHelperAST(file, metadata, id, localBindings, getDependency) {
  if (localBindings && !id) throw new Error("Unexpected local bindings for module-based helpers.");

  if (!id) return;
  const {
    localBindingNames,
    dependencies,
    exportBindingAssignments,
    exportPath,
    exportName,
    importBindingsReferences,
    importPaths
  } = metadata;
  const dependenciesRefs = {};
  dependencies.forEach((name, id) => {
    dependenciesRefs[id.name] = (typeof getDependency == "function" && getDependency(name)) || id;
  });
  const toRename = {},
    bindings = new Set(localBindings || []);
  localBindingNames.forEach(name => {
    let newName = name;
    while (bindings.has(newName)) newName = "_" + newName;
    if (newName !== name) toRename[name] = newName;
  });
  if (id.type === "Identifier" && exportName !== id.name) toRename[exportName] = id.name;

  const { path } = file,
    exp = path.get(exportPath),
    imps = importPaths.map(p => path.get(p)),
    impsBindingRefs = importBindingsReferences.map(p => path.get(p)),
    decl = exp.get("declaration");
  if (id.type === "Identifier") exp.replaceWith(decl);
  else {
    if (id.type !== "MemberExpression") throw new Error("Unexpected helper format.");

    exportBindingAssignments.forEach(assignPath => {
      const assign = path.get(assignPath);
      assign.replaceWith(assignmentExpression$9("=", id, assign.node));
    });
    exp.replaceWith(decl);
    path.pushContainer("body", expressionStatement$5(assignmentExpression$9("=", id, identifier$c(exportName))));
  }

  Object.keys(toRename).forEach(name => {
    path.scope.rename(name, toRename[name]);
  });
  for (const path of imps) path.remove();
  for (const path of impsBindingRefs) {
    const node = cloneNode$d(dependenciesRefs[path.node.name]);
    path.replaceWith(node);
  }
}
const helperData = Object.create(null);
function loadHelper(name) {
  if (!helperData[name]) {
    const helper = helpers$1[name];
    if (!helper)
      throw Object.assign(new ReferenceError("Unknown helper " + name), { code: "BABEL_HELPER_UNKNOWN", helper: name });

    const fn = () => {
      if (!FileClass) {
        const fakeFile = { ast: file$1(helper.ast()), path: null };
        traverse.default(fakeFile.ast, { Program: path => (fakeFile.path = path).stop() });
        return fakeFile;
      }

      return new FileClass(
        { filename: "babel-helper://" + name },
        { ast: file$1(helper.ast()), code: "[internal Babel helper code]", inputMap: null }
      );
    };
    let metadata = null;
    helperData[name] = {
      minVersion: helper.minVersion,
      build(getDependency, id, localBindings) {
        const file = fn();
        metadata || (metadata = getHelperMetadata(file));
        permuteHelperAST(file, metadata, id, localBindings, getDependency);
        return { nodes: file.ast.program.body, globals: metadata.globals };
      },
      getDependencies() {
        metadata || (metadata = getHelperMetadata(fn()));
        return Array.from(metadata.dependencies.values());
      }
    };
  }
  return helperData[name];
}
function get$3(name, getDependency, id, localBindings) {
  return loadHelper(name).build(getDependency, id, localBindings);
}
function minVersion(name) {
  return loadHelper(name).minVersion;
}
function getDependencies(name) {
  return loadHelper(name).getDependencies();
}
function ensure(name, newFileClass) {
  FileClass || (FileClass = newFileClass);
  loadHelper(name);
}
const list = Object.keys(helpers$1).map(name => name.replace(/^_/, ""));

const {
  callExpression: callExpression$9,
  cloneNode: cloneNode$c,
  expressionStatement: expressionStatement$4,
  identifier: identifier$b,
  importDeclaration,
  importDefaultSpecifier,
  importNamespaceSpecifier,
  importSpecifier,
  memberExpression: memberExpression$9,
  stringLiteral: stringLiteral$5,
  variableDeclaration: variableDeclaration$5,
  variableDeclarator: variableDeclarator$5
} = t$5;
class ImportBuilder {
  constructor(importedSource, scope, hub) {
    this._statements = [];
    this._resultName = null;
    this._importedSource = void 0;
    this._scope = scope;
    this._hub = hub;
    this._importedSource = importedSource;
  }
  done() {
    return { statements: this._statements, resultName: this._resultName };
  }
  import() {
    this._statements.push(importDeclaration([], stringLiteral$5(this._importedSource)));
    return this;
  }
  require() {
    this._statements.push(
      expressionStatement$4(callExpression$9(identifier$b("require"), [stringLiteral$5(this._importedSource)]))
    );
    return this;
  }
  namespace(name = "namespace") {
    const local = this._scope.generateUidIdentifier(name),
      statement = this._statements[this._statements.length - 1];
    assert(statement.type === "ImportDeclaration");
    assert(statement.specifiers.length === 0);
    statement.specifiers = [importNamespaceSpecifier(local)];
    this._resultName = cloneNode$c(local);
    return this;
  }
  default(name) {
    const id = this._scope.generateUidIdentifier(name),
      statement = this._statements[this._statements.length - 1];
    assert(statement.type === "ImportDeclaration");
    assert(statement.specifiers.length === 0);
    statement.specifiers = [importDefaultSpecifier(id)];
    this._resultName = cloneNode$c(id);
    return this;
  }
  named(name, importName) {
    if (importName === "default") return this.default(name);
    const id = this._scope.generateUidIdentifier(name),
      statement = this._statements[this._statements.length - 1];
    assert(statement.type === "ImportDeclaration");
    assert(statement.specifiers.length === 0);
    statement.specifiers = [importSpecifier(id, identifier$b(importName))];
    this._resultName = cloneNode$c(id);
    return this;
  }
  var(name) {
    const id = this._scope.generateUidIdentifier(name);
    let statement = this._statements[this._statements.length - 1];
    if (statement.type !== "ExpressionStatement") {
      assert(this._resultName);
      statement = expressionStatement$4(this._resultName);
      this._statements.push(statement);
    }
    this._statements[this._statements.length - 1] = variableDeclaration$5("var", [
      variableDeclarator$5(id, statement.expression)
    ]);
    this._resultName = cloneNode$c(id);
    return this;
  }
  defaultInterop() {
    return this._interop(this._hub.addHelper("interopRequireDefault"));
  }
  wildcardInterop() {
    return this._interop(this._hub.addHelper("interopRequireWildcard"));
  }
  _interop(callee) {
    const statement = this._statements[this._statements.length - 1];
    if (statement.type === "ExpressionStatement")
      statement.expression = callExpression$9(callee, [statement.expression]);
    else if (statement.type === "VariableDeclaration") {
      assert(statement.declarations.length === 1);
      statement.declarations[0].init = callExpression$9(callee, [statement.declarations[0].init]);
    } else assert.fail("Unexpected type.");

    return this;
  }
  prop(name) {
    const statement = this._statements[this._statements.length - 1];
    if (statement.type === "ExpressionStatement")
      statement.expression = memberExpression$9(statement.expression, identifier$b(name));
    else if (statement.type === "VariableDeclaration") {
      assert(statement.declarations.length === 1);
      statement.declarations[0].init = memberExpression$9(statement.declarations[0].init, identifier$b(name));
    } else assert.fail("Unexpected type:" + statement.type);

    return this;
  }
  read(name) {
    this._resultName = memberExpression$9(this._resultName, identifier$b(name));
  }
}

function isModule(path) {
  return path.node.sourceType === "module";
}

const { numericLiteral: numericLiteral$4, sequenceExpression: sequenceExpression$5 } = t$5;
class ImportInjector {
  constructor(path, importedSource, opts) {
    this._defaultOpts = {
      importedSource: null,
      importedType: "commonjs",
      importedInterop: "babel",
      importingInterop: "babel",
      ensureLiveReference: false,
      ensureNoContext: false,
      importPosition: "before"
    };
    const programPath = path.find(p => p.isProgram());
    this._programPath = programPath;
    this._programScope = programPath.scope;
    this._hub = programPath.hub;
    this._defaultOpts = this._applyDefaults(importedSource, opts, true);
  }
  addDefault(importedSourceIn, opts) {
    return this.addNamed("default", importedSourceIn, opts);
  }
  addNamed(importName, importedSourceIn, opts) {
    assert(typeof importName == "string");
    return this._generateImport(this._applyDefaults(importedSourceIn, opts), importName);
  }
  addNamespace(importedSourceIn, opts) {
    return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);
  }
  addSideEffect(importedSourceIn, opts) {
    return this._generateImport(this._applyDefaults(importedSourceIn, opts), void 0);
  }
  _applyDefaults(importedSource, opts, isInit = false) {
    let newOpts;
    if (typeof importedSource == "string") newOpts = Object.assign({}, this._defaultOpts, { importedSource }, opts);
    else {
      assert(!opts, "Unexpected secondary arguments.");
      newOpts = Object.assign({}, this._defaultOpts, importedSource);
    }
    if (!isInit && opts) {
      if (opts.nameHint !== void 0) newOpts.nameHint = opts.nameHint;
      if (opts.blockHoist !== void 0) newOpts.blockHoist = opts.blockHoist;
    }
    return newOpts;
  }
  _generateImport(opts, importName) {
    const isDefault = importName === "default",
      isNamed = !!importName && !isDefault,
      isNamespace = importName === null;
    const {
      importedSource,
      importedType,
      importedInterop,
      importingInterop,
      ensureLiveReference,
      ensureNoContext,
      nameHint,
      importPosition,
      blockHoist
    } = opts;
    let name = nameHint || importName;
    const isMod = isModule(this._programPath),
      isModuleForNode = isMod && importingInterop === "node",
      isModuleForBabel = isMod && importingInterop === "babel";
    if (importPosition === "after" && !isMod)
      throw new Error('"importPosition": "after" is only supported in modules');

    const builder = new ImportBuilder(importedSource, this._programScope, this._hub);
    if (importedType === "es6") {
      if (!isModuleForNode && !isModuleForBabel) throw new Error("Cannot import an ES6 module from CommonJS");

      builder.import();
      isNamespace
        ? builder.namespace(nameHint || importedSource)
        : (isDefault || isNamed) && builder.named(name, importName);
    } else if (importedType !== "commonjs") throw new Error(`Unexpected interopType "${importedType}"`);
    else if (importedInterop === "babel")
      if (isModuleForNode) {
        name = name !== "default" ? name : importedSource;
        const es6Default = importedSource + "$es6Default";
        builder.import();
        isNamespace
          ? builder.default(es6Default).var(name || importedSource).wildcardInterop()
          : isDefault
          ? ensureLiveReference
            ? builder.default(es6Default).var(name || importedSource).defaultInterop().read("default")
            : builder.default(es6Default).var(name).defaultInterop().prop(importName)
          : isNamed && builder.default(es6Default).read(importName);
      } else if (isModuleForBabel) {
        builder.import();
        isNamespace
          ? builder.namespace(name || importedSource)
          : (isDefault || isNamed) && builder.named(name, importName);
      } else {
        builder.require();
        if (isNamespace) builder.var(name || importedSource).wildcardInterop();
        else if ((isDefault || isNamed) && ensureLiveReference)
          if (isDefault) {
            name = name !== "default" ? name : importedSource;
            builder.var(name).read(importName);
            builder.defaultInterop();
          } else builder.var(importedSource).read(importName);
        else isDefault
          ? builder.var(name).defaultInterop().prop(importName)
          : isNamed && builder.var(name).prop(importName);
      }
    else if (importedInterop === "compiled")
      if (isModuleForNode) {
        builder.import();
        isNamespace
          ? builder.default(name || importedSource)
          : (isDefault || isNamed) && builder.default(importedSource).read(name);
      } else if (isModuleForBabel) {
        builder.import();
        isNamespace
          ? builder.namespace(name || importedSource)
          : (isDefault || isNamed) && builder.named(name, importName);
      } else {
        builder.require();
        isNamespace
          ? builder.var(name || importedSource)
          : (isDefault || isNamed) &&
            (ensureLiveReference ? builder.var(importedSource).read(name) : builder.prop(importName).var(name));
      }
    else {
      if (importedInterop !== "uncompiled") throw new Error(`Unknown importedInterop "${importedInterop}".`);
      if (isDefault && ensureLiveReference) throw new Error("No live reference for commonjs default");

      if (isModuleForNode) {
        builder.import();
        isNamespace
          ? builder.default(name || importedSource)
          : isDefault
          ? builder.default(name)
          : isNamed && builder.default(importedSource).read(name);
      } else if (isModuleForBabel) {
        builder.import();
        isNamespace
          ? builder.default(name || importedSource)
          : isDefault
          ? builder.default(name)
          : isNamed && builder.named(name, importName);
      } else {
        builder.require();
        isNamespace
          ? builder.var(name || importedSource)
          : isDefault
          ? builder.var(name)
          : isNamed &&
            (ensureLiveReference ? builder.var(importedSource).read(name) : builder.var(name).prop(importName));
      }
    }

    const { statements, resultName } = builder.done();
    this._insertStatements(statements, importPosition, blockHoist);

    return (isDefault || isNamed) && ensureNoContext && resultName.type !== "Identifier"
      ? sequenceExpression$5([numericLiteral$4(0), resultName])
      : resultName;
  }
  _insertStatements(statements, importPosition = "before", blockHoist = 3) {
    const body = this._programPath.get("body");
    if (importPosition === "after") {
      for (let i = body.length - 1; i >= 0; i--)
        if (body[i].isImportDeclaration()) {
          body[i].insertAfter(statements);
          return;
        }
    } else {
      statements.forEach(node => {
        node._blockHoist = blockHoist;
      });
      const targetPath = body.find(p => {
        const val = p.node._blockHoist;
        return Number.isFinite(val) && val < 4;
      });
      if (targetPath) {
        targetPath.insertBefore(statements);
        return;
      }
    }
    this._programPath.unshiftContainer("body", statements);
  }
}

function addDefault(path, importedSource, opts) {
  return new ImportInjector(path).addDefault(importedSource, opts);
}
function addNamed(path, name, importedSource, opts) {
  return new ImportInjector(path).addNamed(name, importedSource, opts);
}
function addNamespace(path, importedSource, opts) {
  return new ImportInjector(path).addNamespace(importedSource, opts);
}

function requeueComputedKeyAndDecorators(path) {
  const { context, node } = path;
  node.computed && context.maybeQueue(path.get("key"));

  if (node.decorators) for (const decorator of path.get("decorators")) context.maybeQueue(decorator);
}
const visitor$5 = {
  FunctionParent(path) {
    if (path.isArrowFunctionExpression()) return;

    path.skip();
    path.isMethod() && requeueComputedKeyAndDecorators(path);
  },
  Property(path) {
    if (path.isObjectProperty()) return;

    path.skip();
    requeueComputedKeyAndDecorators(path);
  }
};

const { numericLiteral: numericLiteral$3, unaryExpression: unaryExpression$3 } = t$5;
const rewriteThisVisitor = traverse.visitors.merge([visitor$5, {
  ThisExpression(path) {
    path.replaceWith(unaryExpression$3("void", numericLiteral$3(0), true));
  }
}]);
function rewriteThis(programPath) {
  traverse.default(programPath.node, Object.assign({}, rewriteThisVisitor, { noScope: true }));
}

const {
  LOGICAL_OPERATORS: LOGICAL_OPERATORS$1,
  assignmentExpression: assignmentExpression$8,
  binaryExpression: binaryExpression$3,
  cloneNode: cloneNode$b,
  identifier: identifier$a,
  logicalExpression: logicalExpression$1,
  numericLiteral: numericLiteral$2,
  sequenceExpression: sequenceExpression$4,
  unaryExpression: unaryExpression$2
} = t$5;
const simpleAssignmentVisitor = {
  AssignmentExpression: {
    exit(path) {
      const { scope, seen, bindingNames } = this;
      if (path.node.operator === "=" || seen.has(path.node)) return;
      seen.add(path.node);
      const left = path.get("left");
      if (!left.isIdentifier()) return;
      const localName = left.node.name;
      if (!bindingNames.has(localName) || scope.getBinding(localName) !== path.scope.getBinding(localName)) return;

      const operator = path.node.operator.slice(0, -1);
      if (LOGICAL_OPERATORS$1.includes(operator))
        path.replaceWith(logicalExpression$1(
          operator, path.node.left, assignmentExpression$8("=", cloneNode$b(path.node.left), path.node.right)
        ));
      else {
        path.node.right = binaryExpression$3(operator, cloneNode$b(path.node.left), path.node.right);
        path.node.operator = "=";
      }
    }
  }
};

simpleAssignmentVisitor.UpdateExpression = {
  exit(path) {
    if (!this.includeUpdateExpression) return;
    const { scope, bindingNames } = this,
      arg = path.get("argument");
    if (!arg.isIdentifier()) return;
    const localName = arg.node.name;
    if (!bindingNames.has(localName) || scope.getBinding(localName) !== path.scope.getBinding(localName)) return;

    if (path.parentPath.isExpressionStatement() && !path.isCompletionRecord()) {
      const operator = path.node.operator == "++" ? "+=" : "-=";
      path.replaceWith(assignmentExpression$8(operator, arg.node, numericLiteral$2(1)));
    } else if (path.node.prefix)
      path.replaceWith(assignmentExpression$8(
        "=", identifier$a(localName),
        binaryExpression$3(path.node.operator[0], unaryExpression$2("+", arg.node), numericLiteral$2(1))
      ));
    else {
      const old = path.scope.generateUidIdentifierBasedOnNode(arg.node, "old"),
        varName = old.name;
      path.scope.push({ id: old });
      const binary = binaryExpression$3(path.node.operator[0], identifier$a(varName), numericLiteral$2(1));
      path.replaceWith(sequenceExpression$4([
        assignmentExpression$8("=", identifier$a(varName), unaryExpression$2("+", arg.node)),
        assignmentExpression$8("=", cloneNode$b(arg.node), binary),
        identifier$a(varName)
      ]));
    }
  }
};

function simplifyAccess(path, bindingNames) {
  var _arguments$;
  path.traverse(simpleAssignmentVisitor, {
    scope: path.scope,
    bindingNames,
    seen: new WeakSet(),
    includeUpdateExpression: (_arguments$ = arguments[2]) == null || _arguments$
  });
}

const {
  assignmentExpression: assignmentExpression$7,
  callExpression: callExpression$8,
  cloneNode: cloneNode$a,
  expressionStatement: expressionStatement$3,
  getOuterBindingIdentifiers,
  identifier: identifier$9,
  isMemberExpression: isMemberExpression$2,
  isVariableDeclaration,
  jsxIdentifier,
  jsxMemberExpression,
  memberExpression: memberExpression$8,
  numericLiteral: numericLiteral$1,
  sequenceExpression: sequenceExpression$3,
  stringLiteral: stringLiteral$4,
  variableDeclaration: variableDeclaration$4,
  variableDeclarator: variableDeclarator$4
} = t$5;
function isInType$1(path) {
  do {
    switch (path.parent.type) {
      case "TSTypeAnnotation":
      case "TSTypeAliasDeclaration":
      case "TSTypeReference":
      case "TypeAnnotation":
      case "TypeAlias":
        return true;
      case "ExportSpecifier":
        return path.parentPath.parent.exportKind === "type";
      default:
        if (path.parentPath.isStatement() || path.parentPath.isExpression()) return false;
    }
  } while ((path = path.parentPath));
}
function rewriteLiveReferences(programPath, metadata) {
  const imported = new Map(),
    exported = new Map();
  const requeueInParent = path => {
    programPath.requeue(path);
  };
  for (const [source, data] of metadata.source) {
    for (const [localName, importName] of data.imports) imported.set(localName, [source, importName, null]);

    for (const localName of data.importsNamespace) imported.set(localName, [source, null, localName]);
  }
  for (const [local, data] of metadata.local) {
    let exportMeta = exported.get(local);
    if (!exportMeta) {
      exportMeta = [];
      exported.set(local, exportMeta);
    }
    exportMeta.push(...data.names);
  }
  const rewriteBindingInitVisitorState = { metadata, requeueInParent, scope: programPath.scope, exported };
  programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);
  const bindingNames = new Set([...Array.from(imported.keys()), ...Array.from(exported.keys())]);

  simplifyAccess(programPath, bindingNames, false);

  const rewriteReferencesVisitorState = {
    seen: new WeakSet(),
    metadata,
    requeueInParent,
    scope: programPath.scope,
    imported,
    exported,
    buildImportReference: ([source, importName, localName], identNode) => {
      const meta = metadata.source.get(source);
      meta.referenced = true;
      if (localName) {
        if (meta.lazy) identNode = callExpression$8(identNode, []);

        return identNode;
      }
      let namespace = identifier$9(meta.name);
      if (meta.lazy) namespace = callExpression$8(namespace, []);
      if (importName === "default" && meta.interop === "node-default") return namespace;

      const computed = metadata.stringSpecifiers.has(importName);
      return memberExpression$8(namespace, computed ? stringLiteral$4(importName) : identifier$9(importName), computed);
    }
  };
  programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);
}
const rewriteBindingInitVisitor = {
  Scope(path) {
    path.skip();
  },
  ClassDeclaration(path) {
    const { requeueInParent, exported, metadata } = this,
      { id } = path.node;
    if (!id) throw new Error("Expected class to have a name");
    const localName = id.name,
      exportNames = exported.get(localName) || [];
    if (exportNames.length > 0) {
      const statement = expressionStatement$3(
        buildBindingExportAssignmentExpression(metadata, exportNames, identifier$9(localName), path.scope)
      );
      statement._blockHoist = path.node._blockHoist;
      requeueInParent(path.insertAfter(statement)[0]);
    }
  },
  VariableDeclaration(path) {
    const { requeueInParent, exported, metadata } = this;
    Object.keys(path.getOuterBindingIdentifiers()).forEach(localName => {
      const exportNames = exported.get(localName) || [];
      if (exportNames.length > 0) {
        const statement = expressionStatement$3(
          buildBindingExportAssignmentExpression(metadata, exportNames, identifier$9(localName), path.scope)
        );
        statement._blockHoist = path.node._blockHoist;
        requeueInParent(path.insertAfter(statement)[0]);
      }
    });
  }
};
const buildBindingExportAssignmentExpression = (metadata, exportNames, localExpr, scope) => {
  const exportsObjectName = metadata.exportName;
  for (let currentScope = scope; currentScope != null; currentScope = currentScope.parent)
    currentScope.hasOwnBinding(exportsObjectName) && currentScope.rename(exportsObjectName);

  return (exportNames || []).reduce((expr, exportName) => {
    const { stringSpecifiers } = metadata,
      computed = stringSpecifiers.has(exportName);
    return assignmentExpression$7("=", memberExpression$8(
      identifier$9(exportsObjectName),
      computed ? stringLiteral$4(exportName) : identifier$9(exportName),
      computed
    ), expr);
  }, localExpr);
};
const buildImportThrow = localName => template$1.expression.ast`
  (function() {
    throw new Error('"${localName}" is read-only.');
  })()
`;
const rewriteReferencesVisitor = {
  ReferencedIdentifier(path) {
    const { seen, buildImportReference, scope, imported, requeueInParent } = this;
    if (seen.has(path.node)) return;
    seen.add(path.node);
    const localName = path.node.name,
      importData = imported.get(localName);
    if (importData) {
      if (isInType$1(path))
        throw path.buildCodeFrameError(
          `Cannot transform the imported binding "${localName}" since it's also used in a type annotation. Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`
        );

      const localBinding = path.scope.getBinding(localName);
      if (scope.getBinding(localName) !== localBinding) return;
      const ref = buildImportReference(importData, path.node);
      ref.loc = path.node.loc;
      if (
        (path.parentPath.isCallExpression({ callee: path.node }) ||
          path.parentPath.isOptionalCallExpression({ callee: path.node }) ||
          path.parentPath.isTaggedTemplateExpression({ tag: path.node })) &&
        isMemberExpression$2(ref)
      )
        path.replaceWith(sequenceExpression$3([numericLiteral$1(0), ref]));
      else if (path.isJSXIdentifier() && isMemberExpression$2(ref)) {
        const { object, property } = ref;
        path.replaceWith(jsxMemberExpression(jsxIdentifier(object.name), jsxIdentifier(property.name)));
      } else path.replaceWith(ref);

      requeueInParent(path);
      path.skip();
    }
  },
  UpdateExpression(path) {
    const { scope, seen, imported, exported, requeueInParent, buildImportReference } = this;
    if (seen.has(path.node)) return;
    seen.add(path.node);
    const arg = path.get("argument");
    if (arg.isMemberExpression()) return;
    const update = path.node;
    if (arg.isIdentifier()) {
      const localName = arg.node.name;
      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) return;

      const exportedNames = exported.get(localName),
        importData = imported.get(localName);
      if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData)
        if (importData)
          path.replaceWith(assignmentExpression$7(
            update.operator[0] + "=", buildImportReference(importData, arg.node), buildImportThrow(localName)
          ));
        else if (update.prefix)
          path.replaceWith(
            buildBindingExportAssignmentExpression(this.metadata, exportedNames, cloneNode$a(update), path.scope)
          );
        else {
          const ref = scope.generateDeclaredUidIdentifier(localName);
          path.replaceWith(sequenceExpression$3([
            assignmentExpression$7("=", cloneNode$a(ref), cloneNode$a(update)),
            buildBindingExportAssignmentExpression(this.metadata, exportedNames, identifier$9(localName), path.scope),
            cloneNode$a(ref)
          ]));
        }
    }
    requeueInParent(path);
    path.skip();
  },
  AssignmentExpression: {
    exit(path) {
      const { scope, seen, imported, exported, requeueInParent, buildImportReference } = this;
      if (seen.has(path.node)) return;
      seen.add(path.node);
      const left = path.get("left");
      if (left.isMemberExpression()) return;
      if (left.isIdentifier()) {
        const localName = left.node.name;
        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) return;

        const exportedNames = exported.get(localName),
          importData = imported.get(localName);
        if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {
          assert(path.node.operator === "=", "Path was not simplified");
          const assignment = path.node;
          if (importData) {
            assignment.left = buildImportReference(importData, left.node);
            assignment.right = sequenceExpression$3([assignment.right, buildImportThrow(localName)]);
          }
          path.replaceWith(
            buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment, path.scope)
          );
          requeueInParent(path);
        }
      } else {
        const ids = left.getOuterBindingIdentifiers(),
          programScopeIds = Object.keys(ids).filter(
            localName => scope.getBinding(localName) === path.scope.getBinding(localName)
          ),
          id = programScopeIds.find(localName => imported.has(localName));
        if (id) path.node.right = sequenceExpression$3([path.node.right, buildImportThrow(id)]);

        const items = [];
        programScopeIds.forEach(localName => {
          const exportedNames = exported.get(localName) || [];
          exportedNames.length > 0 &&
            items.push(
              buildBindingExportAssignmentExpression(this.metadata, exportedNames, identifier$9(localName), path.scope)
            );
        });
        if (items.length > 0) {
          let node = sequenceExpression$3(items);
          if (path.parentPath.isExpressionStatement()) {
            node = expressionStatement$3(node);
            node._blockHoist = path.parentPath.node._blockHoist;
          }
          requeueInParent(path.insertAfter(node)[0]);
        }
      }
    }
  },
  "ForOfStatement|ForInStatement"(path) {
    const { scope, node } = path,
      { left } = node,
      { exported, imported, scope: programScope } = this;
    if (!isVariableDeclaration(left)) {
      let importConstViolationName,
        didTransformExport = false;
      const loopBodyScope = path.get("body").scope;
      for (const name of Object.keys(getOuterBindingIdentifiers(left)))
        if (programScope.getBinding(name) === scope.getBinding(name)) {
          if (exported.has(name)) {
            didTransformExport = true;
            loopBodyScope.hasOwnBinding(name) && loopBodyScope.rename(name);
          }
          if (imported.has(name) && !importConstViolationName) importConstViolationName = name;
        }

      if (!didTransformExport && !importConstViolationName) return;

      path.ensureBlock();
      const bodyPath = path.get("body"),
        newLoopId = scope.generateUidIdentifierBasedOnNode(left);
      path.get("left").replaceWith(variableDeclaration$4("let", [variableDeclarator$4(cloneNode$a(newLoopId))]));
      scope.registerDeclaration(path.get("left"));
      didTransformExport &&
        bodyPath.unshiftContainer("body", expressionStatement$3(assignmentExpression$7("=", left, newLoopId)));

      importConstViolationName &&
        bodyPath.unshiftContainer("body", expressionStatement$3(buildImportThrow(importConstViolationName)));
    }
  }
};

const {
  cloneNode: cloneNode$9,
  exportNamedDeclaration: exportNamedDeclaration$1,
  exportSpecifier: exportSpecifier$1,
  identifier: identifier$8,
  variableDeclaration: variableDeclaration$3,
  variableDeclarator: variableDeclarator$3
} = t$5;
function splitExportDeclaration(exportDeclaration) {
  if (!exportDeclaration.isExportDeclaration() || exportDeclaration.isExportAllDeclaration())
    throw new Error("Only default and named export declarations can be split.");

  if (exportDeclaration.isExportDefaultDeclaration()) {
    const declaration = exportDeclaration.get("declaration"),
      standaloneDeclaration = declaration.isFunctionDeclaration() || declaration.isClassDeclaration(),
      exportExpr = declaration.isFunctionExpression() || declaration.isClassExpression(),
      scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;
    let id = declaration.node.id,
      needBindingRegistration = false;
    if (!id) {
      needBindingRegistration = true;
      id = scope.generateUidIdentifier("default");
      if (standaloneDeclaration || exportExpr) declaration.node.id = cloneNode$9(id);
    } else if (exportExpr && scope.hasBinding(id.name)) {
      needBindingRegistration = true;
      id = scope.generateUidIdentifier(id.name);
    }
    const updatedDeclaration = standaloneDeclaration
      ? declaration.node
      : variableDeclaration$3("var", [variableDeclarator$3(cloneNode$9(id), declaration.node)]);
    const updatedExportDeclaration = exportNamedDeclaration$1(null, [
      exportSpecifier$1(cloneNode$9(id), identifier$8("default"))
    ]);
    exportDeclaration.insertAfter(updatedExportDeclaration);
    exportDeclaration.replaceWith(updatedDeclaration);
    needBindingRegistration && scope.registerDeclaration(exportDeclaration);

    return exportDeclaration;
  }
  if (exportDeclaration.get("specifiers").length > 0)
    throw new Error("It doesn't make sense to split exported specifiers.");

  const declaration = exportDeclaration.get("declaration"),
    bindingIdentifiers = declaration.getOuterBindingIdentifiers(),
    specifiers = Object.keys(bindingIdentifiers).map(name => exportSpecifier$1(identifier$8(name), identifier$8(name))),
    aliasDeclar = exportNamedDeclaration$1(null, specifiers);
  exportDeclaration.insertAfter(aliasDeclar);
  exportDeclaration.replaceWith(declaration.node);
  return exportDeclaration;
}

function hasExports(metadata) {
  return metadata.hasExports;
}
function isSideEffectImport(source) {
  return (
    source.imports.size === 0 && source.importsNamespace.size === 0 &&
    source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll
  );
}
function validateImportInteropOption(importInterop) {
  if (
    typeof importInterop != "function" &&
    importInterop !== "none" && importInterop !== "babel" && importInterop !== "node"
  )
    throw new Error(
      `.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${importInterop}).`
    );

  return importInterop;
}
function resolveImportInterop(importInterop, source, filename) {
  return typeof importInterop == "function"
    ? validateImportInteropOption(importInterop(source, filename))
    : importInterop;
}
function normalizeModuleAndLoadMetadata(
  programPath,
  exportName,
  { importInterop, initializeReexports = false, lazy = false, esNamespaceOnly = false, filename }
) {
  exportName || (exportName = programPath.scope.generateUidIdentifier("exports").name);

  const stringSpecifiers = new Set();
  nameAnonymousExports(programPath);
  const { local, sources, hasExports } = getModuleMetadata(programPath, { initializeReexports, lazy }, stringSpecifiers);
  removeImportExportDeclarations(programPath);
  for (const [source, metadata] of sources) {
    const { importsNamespace, imports } = metadata;
    if (importsNamespace.size > 0 && imports.size === 0) {
      const [nameOfnamespace] = importsNamespace;
      metadata.name = nameOfnamespace;
    }
    const resolvedInterop = resolveImportInterop(importInterop, source, filename);
    if (resolvedInterop === "none") metadata.interop = "none";
    else if (resolvedInterop === "node" && metadata.interop === "namespace") metadata.interop = "node-namespace";
    else if (resolvedInterop === "node" && metadata.interop === "default") metadata.interop = "node-default";
    else if (esNamespaceOnly && metadata.interop === "namespace") metadata.interop = "default";
  }
  return { exportName, exportNameListName: null, hasExports, local, source: sources, stringSpecifiers };
}
function getExportSpecifierName$1(path, stringSpecifiers) {
  if (path.isIdentifier()) return path.node.name;

  if (path.isStringLiteral()) {
    const stringValue = path.node.value;
    common.isIdentifierName(stringValue) || stringSpecifiers.add(stringValue);

    return stringValue;
  }
  throw new Error("Expected export specifier to be either Identifier or StringLiteral, got " + path.node.type);
}
function assertExportSpecifier(path) {
  if (path.isExportSpecifier()) return;

  throw path.isExportNamespaceSpecifier()
    ? path.buildCodeFrameError(
        "Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`."
      )
    : path.buildCodeFrameError("Unexpected export specifier type");
}
function getModuleMetadata(programPath, { lazy, initializeReexports }, stringSpecifiers) {
  const localData = getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers),
    sourceData = new Map();
  const getData = sourceNode => {
    const source = sourceNode.value;
    let data = sourceData.get(source);
    if (!data) {
      data = {
        name: programPath.scope.generateUidIdentifier(path.basename(source, path.extname(source))).name,
        interop: "none",
        loc: null,
        imports: new Map(),
        importsNamespace: new Set(),
        reexports: new Map(),
        reexportNamespace: new Set(),
        reexportAll: null,
        lazy: false,
        referenced: false
      };
      sourceData.set(source, data);
    }
    return data;
  };
  let hasExports = false;
  programPath.get("body").forEach(child => {
    if (child.isImportDeclaration()) {
      const data = getData(child.node.source);
      data.loc || (data.loc = child.node.loc);
      child.get("specifiers").forEach(spec => {
        if (spec.isImportDefaultSpecifier()) {
          const localName = spec.get("local").node.name;
          data.imports.set(localName, "default");
          const reexport = localData.get(localName);
          if (reexport) {
            localData.delete(localName);
            reexport.names.forEach(name => {
              data.reexports.set(name, "default");
            });
            data.referenced = true;
          }
        } else if (spec.isImportNamespaceSpecifier()) {
          const localName = spec.get("local").node.name;
          data.importsNamespace.add(localName);
          const reexport = localData.get(localName);
          if (reexport) {
            localData.delete(localName);
            reexport.names.forEach(name => {
              data.reexportNamespace.add(name);
            });
            data.referenced = true;
          }
        } else if (spec.isImportSpecifier()) {
          const importName = getExportSpecifierName$1(spec.get("imported"), stringSpecifiers),
            localName = spec.get("local").node.name;
          data.imports.set(localName, importName);
          const reexport = localData.get(localName);
          if (reexport) {
            localData.delete(localName);
            reexport.names.forEach(name => {
              data.reexports.set(name, importName);
            });
            data.referenced = true;
          }
        }
      });
    } else if (child.isExportAllDeclaration()) {
      hasExports = true;
      const data = getData(child.node.source);
      data.loc || (data.loc = child.node.loc);
      data.reexportAll = { loc: child.node.loc };
      data.referenced = true;
    } else if (child.isExportNamedDeclaration() && child.node.source) {
      hasExports = true;
      const data = getData(child.node.source);
      data.loc || (data.loc = child.node.loc);
      child.get("specifiers").forEach(spec => {
        assertExportSpecifier(spec);
        const importName = getExportSpecifierName$1(spec.get("local"), stringSpecifiers),
          exportName = getExportSpecifierName$1(spec.get("exported"), stringSpecifiers);
        data.reexports.set(exportName, importName);
        data.referenced = true;
        if (exportName === "__esModule")
          throw spec.get("exported").buildCodeFrameError('Illegal export "__esModule".');
      });
    } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) hasExports = true;
  });
  for (const metadata of sourceData.values()) {
    let needsDefault = false,
      needsNamed = false;
    if (metadata.importsNamespace.size > 0) {
      needsDefault = true;
      needsNamed = true;
    }
    if (metadata.reexportAll) needsNamed = true;

    for (const importName of metadata.imports.values())
      importName === "default" ? (needsDefault = true) : (needsNamed = true);

    for (const importName of metadata.reexports.values())
      importName === "default" ? (needsDefault = true) : (needsNamed = true);

    if (needsDefault && needsNamed) metadata.interop = "namespace";
    else if (needsDefault) metadata.interop = "default";
  }
  for (const [source, metadata] of sourceData)
    if (lazy !== false && !isSideEffectImport(metadata) && !metadata.reexportAll)
      if (lazy === true) metadata.lazy = !/\./.test(source);
      else if (Array.isArray(lazy)) metadata.lazy = lazy.indexOf(source) > -1;
      else if (typeof lazy == "function") metadata.lazy = lazy(source);
      else throw new Error(".lazy must be a boolean, string array, or function");

  return { hasExports, local: localData, sources: sourceData };
}
function getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers) {
  const bindingKindLookup = new Map();
  programPath.get("body").forEach(child => {
    let kind;
    if (child.isImportDeclaration()) kind = "import";
    else {
      if (child.isExportDefaultDeclaration()) child = child.get("declaration");

      if (child.isExportNamedDeclaration())
        if (child.node.declaration) child = child.get("declaration");
        else if (initializeReexports && child.node.source && child.get("source").isStringLiteral()) {
          child.get("specifiers").forEach(spec => {
            assertExportSpecifier(spec);
            bindingKindLookup.set(spec.get("local").node.name, "block");
          });
          return;
        }

      if (child.isFunctionDeclaration()) kind = "hoisted";
      else if (child.isClassDeclaration()) kind = "block";
      else if (child.isVariableDeclaration({ kind: "var" })) kind = "var";
      else if (child.isVariableDeclaration()) kind = "block";
      else return;
    }
    Object.keys(child.getOuterBindingIdentifiers()).forEach(name => {
      bindingKindLookup.set(name, kind);
    });
  });
  const localMetadata = new Map();
  const getLocalMetadata = idPath => {
    const localName = idPath.node.name;
    let metadata = localMetadata.get(localName);
    if (!metadata) {
      const kind = bindingKindLookup.get(localName);
      if (kind === void 0) throw idPath.buildCodeFrameError(`Exporting local "${localName}", which is not declared.`);

      metadata = { names: [], kind };
      localMetadata.set(localName, metadata);
    }
    return metadata;
  };
  programPath.get("body").forEach(child => {
    if (!child.isExportNamedDeclaration() || (!initializeReexports && child.node.source)) {
      if (child.isExportDefaultDeclaration()) {
        const declaration = child.get("declaration");
        if (!declaration.isFunctionDeclaration() && !declaration.isClassDeclaration())
          throw declaration.buildCodeFrameError("Unexpected default expression export.");

        getLocalMetadata(declaration.get("id")).names.push("default");
      }
    } else if (child.node.declaration) {
      const declaration = child.get("declaration"),
        ids = declaration.getOuterBindingIdentifierPaths();
      Object.keys(ids).forEach(name => {
        if (name === "__esModule") throw declaration.buildCodeFrameError('Illegal export "__esModule".');

        getLocalMetadata(ids[name]).names.push(name);
      });
    } else
      child.get("specifiers").forEach(spec => {
        const local = spec.get("local"),
          exported = spec.get("exported"),
          localMetadata = getLocalMetadata(local),
          exportName = getExportSpecifierName$1(exported, stringSpecifiers);
        if (exportName === "__esModule") throw exported.buildCodeFrameError('Illegal export "__esModule".');

        localMetadata.names.push(exportName);
      });
  });
  return localMetadata;
}
function nameAnonymousExports(programPath) {
  programPath.get("body").forEach(child => {
    child.isExportDefaultDeclaration() && splitExportDeclaration(child);
  });
}
function removeImportExportDeclarations(programPath) {
  programPath.get("body").forEach(child => {
    if (child.isImportDeclaration()) child.remove();
    else if (child.isExportNamedDeclaration())
      if (child.node.declaration) {
        child.node.declaration._blockHoist = child.node._blockHoist;
        child.replaceWith(child.node.declaration);
      } else child.remove();
    else if (child.isExportDefaultDeclaration()) {
      const declaration = child.get("declaration");
      if (!declaration.isFunctionDeclaration() && !declaration.isClassDeclaration())
        throw declaration.buildCodeFrameError("Unexpected default expression export.");

      declaration._blockHoist = child.node._blockHoist;
      child.replaceWith(declaration);
    } else child.isExportAllDeclaration() && child.remove();
  });
}

function buildDynamicImport(node, deferToThen, wrapWithPromise, builder) {
  const [specifier] = node.arguments;
  if (t$5.isStringLiteral(specifier) || (t$5.isTemplateLiteral(specifier) && specifier.quasis.length === 0))
    return deferToThen
      ? template$1.expression.ast`
        Promise.resolve().then(() => ${builder(specifier)})
      `
      : builder(specifier);

  const specifierToString = t$5.isTemplateLiteral(specifier)
    ? t$5.identifier("specifier")
    : t$5.templateLiteral(
        [t$5.templateElement({ raw: "" }), t$5.templateElement({ raw: "" })],
        [t$5.identifier("specifier")]
      );
  return deferToThen
    ? template$1.expression.ast`
      (specifier =>
        new Promise(r => r(${specifierToString})).then(s => ${builder(t$5.identifier("s"))})
      )(${specifier})
    `
    : wrapWithPromise
    ? template$1.expression.ast`
      (specifier => new Promise(r => r(${builder(specifierToString)})))(${specifier})
    `
    : template$1.expression.ast`
      (specifier => ${builder(specifierToString)})(${specifier})
    `;
}

{
  const originalGetModuleName = getModuleName;
  getModuleName = function (rootOpts, pluginOpts) {
    var _pluginOpts$moduleId, _pluginOpts$moduleIds, _pluginOpts$getModule, _pluginOpts$moduleRoo;
    return originalGetModuleName(rootOpts, {
      moduleId: (_pluginOpts$moduleId = pluginOpts.moduleId) != null ? _pluginOpts$moduleId : rootOpts.moduleId,
      moduleIds: (_pluginOpts$moduleIds = pluginOpts.moduleIds) != null ? _pluginOpts$moduleIds : rootOpts.moduleIds,
      getModuleId:
        (_pluginOpts$getModule = pluginOpts.getModuleId) != null ? _pluginOpts$getModule : rootOpts.getModuleId,
      moduleRoot: (_pluginOpts$moduleRoo = pluginOpts.moduleRoot) != null ? _pluginOpts$moduleRoo : rootOpts.moduleRoot
    });
  };
}
function getModuleName(rootOpts, pluginOpts) {
  const { filename, filenameRelative = filename, sourceRoot = pluginOpts.moduleRoot } = rootOpts,
    { moduleId, moduleIds = !!moduleId, getModuleId, moduleRoot = sourceRoot } = pluginOpts;
  if (!moduleIds) return null;
  if (moduleId != null && !getModuleId) return moduleId;

  let moduleName = moduleRoot != null ? moduleRoot + "/" : "";
  if (filenameRelative) {
    const sourceRootReplacer = sourceRoot != null ? new RegExp("^" + sourceRoot + "/?") : "";
    moduleName += filenameRelative.replace(sourceRootReplacer, "").replace(/\.(\w*?)$/, "");
  }
  moduleName = moduleName.replace(/\\/g, "/");
  return (getModuleId && getModuleId(moduleName)) || moduleName;
}

const {
  booleanLiteral: booleanLiteral$3,
  callExpression: callExpression$7,
  cloneNode: cloneNode$8,
  directive,
  directiveLiteral,
  expressionStatement: expressionStatement$2,
  identifier: identifier$7,
  isIdentifier: isIdentifier$7,
  memberExpression: memberExpression$7,
  stringLiteral: stringLiteral$3,
  valueToNode,
  variableDeclaration: variableDeclaration$2,
  variableDeclarator: variableDeclarator$2
} = t$5;
function rewriteModuleStatementsAndPrepareHeader(path, {
  exportName,
  strict,
  allowTopLevelThis,
  strictMode,
  noInterop,
  importInterop = noInterop ? "none" : "babel",
  lazy,
  esNamespaceOnly,
  filename,
  constantReexports = arguments[1].loose,
  enumerableModuleMeta = arguments[1].loose,
  noIncompleteNsImportDetection
}) {
  validateImportInteropOption(importInterop);
  assert(isModule(path), "Cannot process module statements in a script");
  path.node.sourceType = "script";
  const meta = normalizeModuleAndLoadMetadata(path, exportName, {
    importInterop,
    initializeReexports: constantReexports,
    lazy,
    esNamespaceOnly,
    filename
  });
  allowTopLevelThis || rewriteThis(path);

  rewriteLiveReferences(path, meta);
  strictMode === false ||
    path.node.directives.some(directive => directive.value.value === "use strict") ||
    path.unshiftContainer("directives", directive(directiveLiteral("use strict")));

  const headers = [];
  !hasExports(meta) || strict || headers.push(buildESModuleHeader(meta, enumerableModuleMeta));

  const nameList = buildExportNameListDeclaration(path, meta);
  if (nameList) {
    meta.exportNameListName = nameList.name;
    headers.push(nameList.statement);
  }
  headers.push(...buildExportInitializationStatements(path, meta, constantReexports, noIncompleteNsImportDetection));
  return { meta, headers };
}
function ensureStatementsHoisted(statements) {
  statements.forEach(header => {
    header._blockHoist = 3;
  });
}
function wrapInterop(programPath, expr, type) {
  if (type === "none") return null;

  if (type === "node-namespace")
    return callExpression$7(programPath.hub.addHelper("interopRequireWildcard"), [expr, booleanLiteral$3(true)]);
  if (type === "node-default") return null;

  let helper;
  if (type === "default") helper = "interopRequireDefault";
  else if (type === "namespace") helper = "interopRequireWildcard";
  else throw new Error("Unknown interop: " + type);

  return callExpression$7(programPath.hub.addHelper(helper), [expr]);
}
function buildNamespaceInitStatements(metadata, sourceMetadata, constantReexports = false) {
  const statements = [],
    srcNamespaceId = identifier$7(sourceMetadata.name);
  for (const localName of sourceMetadata.importsNamespace)
    localName === sourceMetadata.name ||
      statements.push(
        template$1.statement`var NAME = SOURCE;`({ NAME: localName, SOURCE: cloneNode$8(srcNamespaceId) })
      );

  const srcNamespace = sourceMetadata.lazy ? callExpression$7(srcNamespaceId, []) : srcNamespaceId;
  constantReexports && statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, true));

  for (const exportName of sourceMetadata.reexportNamespace)
    statements.push(
      (sourceMetadata.lazy
        ? template$1.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() { return NAMESPACE; }
            });
          `
        : template$1.statement`EXPORTS.NAME = NAMESPACE;`)({
        EXPORTS: metadata.exportName,
        NAME: exportName,
        NAMESPACE: cloneNode$8(srcNamespace)
      })
    );

  if (sourceMetadata.reexportAll) {
    const statement = buildNamespaceReexport(metadata, cloneNode$8(srcNamespace), constantReexports);
    statement.loc = sourceMetadata.reexportAll.loc;
    statements.push(statement);
  }
  return statements;
}
const ReexportTemplate = {
  constant: template$1.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`,
  constantComputed: template$1.statement`EXPORTS["EXPORT_NAME"] = NAMESPACE_IMPORT;`,
  spec: template$1.statement`
    Object.defineProperty(EXPORTS, "EXPORT_NAME", {
      enumerable: true,
      get: function() { return NAMESPACE_IMPORT; }
    });
    `
};
function buildReexportsFromMeta(meta, metadata, constantReexports) {
  const namespace = metadata.lazy ? callExpression$7(identifier$7(metadata.name), []) : identifier$7(metadata.name),
    { stringSpecifiers } = meta;
  return Array.from(metadata.reexports, ([exportName, importName]) => {
    let NAMESPACE_IMPORT = cloneNode$8(namespace);
    if (importName !== "default" || metadata.interop !== "node-default")
      NAMESPACE_IMPORT = stringSpecifiers.has(importName)
        ? memberExpression$7(NAMESPACE_IMPORT, stringLiteral$3(importName), true)
        : memberExpression$7(NAMESPACE_IMPORT, identifier$7(importName));

    const astNodes = { EXPORTS: meta.exportName, EXPORT_NAME: exportName, NAMESPACE_IMPORT };
    return constantReexports || isIdentifier$7(NAMESPACE_IMPORT)
      ? stringSpecifiers.has(exportName)
        ? ReexportTemplate.constantComputed(astNodes)
        : ReexportTemplate.constant(astNodes)
      : ReexportTemplate.spec(astNodes);
  });
}
function buildESModuleHeader(metadata, enumerableModuleMeta = false) {
  return (
    enumerableModuleMeta
      ? template$1.statement`
        EXPORTS.__esModule = true;
      `
      : template$1.statement`
        Object.defineProperty(EXPORTS, "__esModule", { value: true });
      `
  )({ EXPORTS: metadata.exportName });
}
function buildNamespaceReexport(metadata, namespace, constantReexports) {
  return (
    constantReexports
      ? template$1.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      `
      : template$1.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() { return NAMESPACE[key]; }
          });
        });
    `
  )({
    NAMESPACE: namespace,
    EXPORTS: metadata.exportName,
    VERIFY_NAME_LIST: metadata.exportNameListName
      ? template$1.default`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({ EXPORTS_LIST: metadata.exportNameListName })
      : null
  });
}
function buildExportNameListDeclaration(programPath, metadata) {
  const exportedVars = Object.create(null);
  for (const data of metadata.local.values()) for (const name of data.names) exportedVars[name] = true;

  let hasReexport = false;
  for (const data of metadata.source.values()) {
    for (const exportName of data.reexports.keys()) exportedVars[exportName] = true;

    for (const exportName of data.reexportNamespace) exportedVars[exportName] = true;

    hasReexport = hasReexport || !!data.reexportAll;
  }
  if (!hasReexport || Object.keys(exportedVars).length === 0) return null;
  const name = programPath.scope.generateUidIdentifier("exportNames");
  delete exportedVars.default;
  return {
    name: name.name,
    statement: variableDeclaration$2("var", [variableDeclarator$2(name, valueToNode(exportedVars))])
  };
}
function buildExportInitializationStatements(
  programPath,
  metadata,
  constantReexports = false,
  noIncompleteNsImportDetection = false
) {
  const initStatements = [];
  for (const [localName, data] of metadata.local)
    if (data.kind === "import");
    else if (data.kind === "hoisted")
      initStatements.push([data.names[0], buildInitStatement(metadata, data.names, identifier$7(localName))]);
    else if (!noIncompleteNsImportDetection)
      for (const exportName of data.names) initStatements.push([exportName, null]);

  for (const data of metadata.source.values()) {
    if (!constantReexports) {
      const reexportsStatements = buildReexportsFromMeta(metadata, data, false),
        reexports = [...data.reexports.keys()];
      for (let i = 0; i < reexportsStatements.length; i++)
        initStatements.push([reexports[i], reexportsStatements[i]]);
    }
    if (!noIncompleteNsImportDetection)
      for (const exportName of data.reexportNamespace) initStatements.push([exportName, null]);
  }
  initStatements.sort(([a], [b]) => (a < b ? -1 : b < a ? 1 : 0));
  const results = [];
  if (noIncompleteNsImportDetection) for (const [, initStatement] of initStatements) results.push(initStatement);
  else {
    const chunkSize = 100;
    for (let i = 0; i < initStatements.length; i += chunkSize) {
      let uninitializedExportNames = [];
      for (let j = 0; j < chunkSize && i + j < initStatements.length; j++) {
        const [exportName, initStatement] = initStatements[i + j];
        if (initStatement !== null) {
          if (uninitializedExportNames.length > 0) {
            results.push(
              buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode())
            );
            uninitializedExportNames = [];
          }
          results.push(initStatement);
        } else uninitializedExportNames.push(exportName);
      }
      uninitializedExportNames.length > 0 &&
        results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));
    }
  }
  return results;
}
const InitTemplate = {
  computed: template$1.expression`EXPORTS["NAME"] = VALUE`,
  default: template$1.expression`EXPORTS.NAME = VALUE`
};
function buildInitStatement(metadata, exportNames, initExpr) {
  const { stringSpecifiers, exportName: EXPORTS } = metadata;
  return expressionStatement$2(exportNames.reduce((acc, exportName) => {
    const params = { EXPORTS, NAME: exportName, VALUE: acc };
    return stringSpecifiers.has(exportName) ? InitTemplate.computed(params) : InitTemplate.default(params);
  }, initExpr));
}

const { cloneNode: cloneNode$7, interpreterDirective } = t$5;
const errorVisitor = {
  enter(path, state) {
    const loc = path.node.loc;
    if (loc) {
      state.loc = loc;
      path.stop();
    }
  }
};
class File {
  constructor(options, { code, ast, inputMap }) {
    this._map = new Map();
    this.opts = void 0;
    this.declarations = {};
    this.path = void 0;
    this.ast = void 0;
    this.scope = void 0;
    this.metadata = {};
    this.code = "";
    this.inputMap = void 0;
    this.hub = {
      file: this,
      getCode: () => this.code,
      getScope: () => this.scope,
      addHelper: this.addHelper.bind(this),
      buildError: this.buildCodeFrameError.bind(this)
    };
    this.opts = options;
    this.code = code;
    this.ast = ast;
    this.inputMap = inputMap;
    this.path = traverse.NodePath.get({
      hub: this.hub,
      parentPath: null,
      parent: this.ast,
      container: this.ast,
      key: "program"
    }).setContext();
    this.scope = this.path.scope;
  }
  get shebang() {
    const { interpreter } = this.path.node;
    return interpreter ? interpreter.value : "";
  }
  set shebang(value) {
    value
      ? this.path.get("interpreter").replaceWith(interpreterDirective(value))
      : this.path.get("interpreter").remove();
  }
  set(key, val) {
    if (key === "helpersNamespace")
      throw new Error(
        "Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to explore using 'helperGenerator' alongside 'file.availableHelper()'."
      );

    this._map.set(key, val);
  }
  get(key) {
    return this._map.get(key);
  }
  has(key) {
    return this._map.has(key);
  }
  getModuleName() {
    return getModuleName(this.opts, this.opts);
  }
  addImport() {
    throw new Error(
      "This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-module-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'."
    );
  }
  availableHelper(name, versionRange) {
    let minVersion$1;
    try {
      minVersion$1 = minVersion(name);
    } catch (err) {
      if (err.code !== "BABEL_HELPER_UNKNOWN") throw err;
      return false;
    }
    if (typeof versionRange != "string") return true;
    if (vendors.semver.valid(versionRange)) versionRange = "^" + versionRange;
    return (
      !vendors.semver.intersects("<" + minVersion$1, versionRange) &&
      !vendors.semver.intersects(">=8.0.0", versionRange)
    );
  }
  addHelper(name) {
    const declar = this.declarations[name];
    if (declar) return cloneNode$7(declar);
    const generator = this.get("helperGenerator");
    if (generator) {
      const res = generator(name);
      if (res) return res;
    }
    ensure(name, File);
    const uid = (this.declarations[name] = this.scope.generateUidIdentifier(name)),
      dependencies = {};
    for (const dep of getDependencies(name)) dependencies[dep] = this.addHelper(dep);

    const { nodes, globals } = get$3(name, dep => dependencies[dep], uid, Object.keys(this.scope.getAllBindings()));
    globals.forEach(name => {
      this.path.scope.hasBinding(name, true) && this.path.scope.rename(name);
    });
    nodes.forEach(node => {
      node._compact = true;
    });
    this.path.unshiftContainer("body", nodes);
    this.path.get("body").forEach(path => {
      nodes.indexOf(path.node) < 0 || !path.isVariableDeclaration() || this.scope.registerDeclaration(path);
    });
    return uid;
  }
  addTemplateObject() {
    throw new Error("This function has been moved into the template literal transform itself.");
  }
  buildCodeFrameError(node, msg, _Error = SyntaxError) {
    let loc = node && (node.loc || node._loc);
    if (!loc && node) {
      const state = { loc: null };
      traverse.default(node, errorVisitor, this.scope, state);
      loc = state.loc;
      let txt = "This is an error on an internal node. Probably an internal error.";
      if (loc) txt += " Location has been estimated.";
      msg += ` (${txt})`;
    }
    if (loc) {
      const { highlightCode = true } = this.opts;
      msg += "\n" + template$1.codeFrameColumns(this.code, {
        start: { line: loc.start.line, column: loc.start.column + 1 },
        end: loc.end && loc.start.line === loc.end.line ? { line: loc.end.line, column: loc.end.column + 1 } : void 0
      }, { highlightCode });
    }
    return new _Error(msg);
  }
}

const {
  arrayExpression,
  assignmentExpression: assignmentExpression$6,
  binaryExpression: binaryExpression$2,
  blockStatement: blockStatement$1,
  callExpression: callExpression$6,
  cloneNode: cloneNode$6,
  conditionalExpression: conditionalExpression$2,
  exportNamedDeclaration,
  exportSpecifier,
  expressionStatement: expressionStatement$1,
  functionExpression: functionExpression$1,
  identifier: identifier$6,
  memberExpression: memberExpression$6,
  objectExpression: objectExpression$1,
  program,
  stringLiteral: stringLiteral$2,
  unaryExpression: unaryExpression$1,
  variableDeclaration: variableDeclaration$1,
  variableDeclarator: variableDeclarator$1
} = t$5;
const buildUmdWrapper = replacements =>
  template$1.statement`
    (function (root, factory) {
      typeof exports == "object"
        ? factory(COMMON_ARGUMENTS)
        : typeof define == "function" && define.amd
        ? define(AMD_ARGUMENTS, factory)
        : factory(BROWSER_ARGUMENTS);
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(replacements);
function buildGlobal(allowlist) {
  const namespace = identifier$6("babelHelpers"),
    body = [],
    container = functionExpression$1(null, [identifier$6("global")], blockStatement$1(body));
  const tree = program([
    expressionStatement$1(callExpression$6(container, [
      conditionalExpression$2(
        binaryExpression$2("===", unaryExpression$1("typeof", identifier$6("global")), stringLiteral$2("undefined")),
        identifier$6("self"),
        identifier$6("global")
      )
    ]))
  ]);
  body.push(variableDeclaration$1("var", [
    variableDeclarator$1(
      namespace,
      assignmentExpression$6("=", memberExpression$6(identifier$6("global"), namespace), objectExpression$1([]))
    )
  ]));
  buildHelpers(body, namespace, allowlist);
  return tree;
}
function buildModule(allowlist) {
  const body = [],
    refs = buildHelpers(body, null, allowlist);
  body.unshift(
    exportNamedDeclaration(null,
      Object.keys(refs).map(name => exportSpecifier(cloneNode$6(refs[name]), identifier$6(name)))
    )
  );
  return program(body, [], "module");
}
function buildUmd(allowlist) {
  const namespace = identifier$6("babelHelpers"),
    body = [];
  body.push(variableDeclaration$1("var", [variableDeclarator$1(namespace, identifier$6("global"))]));
  buildHelpers(body, namespace, allowlist);
  return program([
    buildUmdWrapper({
      FACTORY_PARAMETERS: identifier$6("global"),
      BROWSER_ARGUMENTS: assignmentExpression$6(
        "=", memberExpression$6(identifier$6("root"), namespace), objectExpression$1([])
      ),
      COMMON_ARGUMENTS: identifier$6("exports"),
      AMD_ARGUMENTS: arrayExpression([stringLiteral$2("exports")]),
      FACTORY_BODY: body,
      UMD_ROOT: identifier$6("this")
    })
  ]);
}
function buildVar(allowlist) {
  const namespace = identifier$6("babelHelpers"),
    body = [];
  body.push(variableDeclaration$1("var", [variableDeclarator$1(namespace, objectExpression$1([]))]));
  const tree = program(body);
  buildHelpers(body, namespace, allowlist);
  body.push(expressionStatement$1(namespace));
  return tree;
}
function buildHelpers(body, namespace, allowlist) {
  const getHelperReference = name =>
      namespace ? memberExpression$6(namespace, identifier$6(name)) : identifier$6("_" + name),
    refs = {};
  list.forEach(function (name) {
    if (allowlist && allowlist.indexOf(name) < 0) return;
    const ref = (refs[name] = getHelperReference(name));
    ensure(name, File);
    const { nodes } = get$3(name, getHelperReference, ref);
    body.push(...nodes);
  });
  return refs;
}
function babelBuildExternalHelpers(allowlist, outputType = "global") {
  let tree;
  const build = { global: buildGlobal, module: buildModule, umd: buildUmd, var: buildVar }[outputType];
  if (!build) throw new Error("Unsupported output type " + outputType);

  tree = build(allowlist);
  return generate.default(tree).code;
}

const GENSYNC_START = Symbol.for("gensync:v1:start"),
  GENSYNC_SUSPEND = Symbol.for("gensync:v1:suspend"),
  GENSYNC_EXPECTED_START = "GENSYNC_EXPECTED_START",
  GENSYNC_EXPECTED_SUSPEND = "GENSYNC_EXPECTED_SUSPEND",
  GENSYNC_OPTIONS_ERROR = "GENSYNC_OPTIONS_ERROR",
  GENSYNC_RACE_NONEMPTY = "GENSYNC_RACE_NONEMPTY",
  GENSYNC_ERRBACK_NO_CALLBACK = "GENSYNC_ERRBACK_NO_CALLBACK";
var gensync = Object.assign(function (optsOrFn) {
  let genFn = optsOrFn;
  genFn = typeof optsOrFn != "function" ? newGenerator(optsOrFn) : wrapGenerator(optsOrFn);

  return Object.assign(genFn, makeFunctionAPI(genFn));
}, {
  all: buildOperation({
    name: "all",
    arity: 1,
    sync: function (args) {
      return Array.from(args[0]).map(item => evaluateSync(item));
    },
    async: function (args, resolve, reject) {
      const items = Array.from(args[0]);
      if (items.length === 0) {
        Promise.resolve().then(() => resolve([]));
        return;
      }
      let count = 0;
      const results = items.map(() => void 0);
      items.forEach((item, i) => {
        evaluateAsync(item, val => {
          results[i] = val;
          count += 1;
          count !== results.length || resolve(results);
        }, reject);
      });
    }
  }),
  race: buildOperation({
    name: "race",
    arity: 1,
    sync: function (args) {
      const items = Array.from(args[0]);
      if (items.length === 0) throw makeError("Must race at least 1 item", GENSYNC_RACE_NONEMPTY);

      return evaluateSync(items[0]);
    },
    async: function (args, resolve, reject) {
      const items = Array.from(args[0]);
      if (items.length === 0) throw makeError("Must race at least 1 item", GENSYNC_RACE_NONEMPTY);

      for (const item of items) evaluateAsync(item, resolve, reject);
    }
  })
});
function makeFunctionAPI(genFn) {
  return {
    sync: function (...args) {
      return evaluateSync(genFn.apply(this, args));
    },
    async: function (...args) {
      return new Promise((resolve, reject) => {
        evaluateAsync(genFn.apply(this, args), resolve, reject);
      });
    },
    errback: function (...args) {
      const cb = args.pop();
      if (typeof cb != "function")
        throw makeError("Asynchronous function called without callback", GENSYNC_ERRBACK_NO_CALLBACK);

      let gen;
      try {
        gen = genFn.apply(this, args);
      } catch (err) {
        cb(err);
        return;
      }
      evaluateAsync(gen, val => cb(void 0, val), err => cb(err));
    }
  };
}
function assertTypeof(type, name, value, allowUndefined) {
  if (typeof value === type || (allowUndefined && value === void 0)) return;

  let msg = allowUndefined
    ? `Expected opts.${name} to be either a ${type}, or undefined.`
    : `Expected opts.${name} to be a ${type}.`;

  throw makeError(msg, GENSYNC_OPTIONS_ERROR);
}
function makeError(msg, code) {
  return Object.assign(new Error(msg), { code });
}
function newGenerator({ name, arity, sync, async, errback }) {
  assertTypeof("string", "name", name, true);
  assertTypeof("number", "arity", arity, true);
  assertTypeof("function", "sync", sync);
  assertTypeof("function", "async", async, true);
  assertTypeof("function", "errback", errback, true);
  if (async && errback)
    throw makeError("Expected one of either opts.async or opts.errback, but got _both_.", GENSYNC_OPTIONS_ERROR);

  if (typeof name != "string") {
    let fnName;
    if (errback && errback.name && errback.name !== "errback") fnName = errback.name;

    if (async && async.name && async.name !== "async") fnName = async.name.replace(/Async$/, "");

    if (sync && sync.name && sync.name !== "sync") fnName = sync.name.replace(/Sync$/, "");

    if (typeof fnName == "string") name = fnName;
  }
  if (typeof arity != "number") arity = sync.length;

  return buildOperation({
    name,
    arity,
    sync: function (args) {
      return sync.apply(this, args);
    },
    async: function (args, resolve, reject) {
      async
        ? async.apply(this, args).then(resolve, reject)
        : errback
        ? errback.call(this, ...args, (err, value) => {
            err == null ? resolve(value) : reject(err);
          })
        : resolve(sync.apply(this, args));
    }
  });
}
function wrapGenerator(genFn) {
  return setFunctionMetadata(genFn.name, genFn.length, function (...args) {
    return genFn.apply(this, args);
  });
}
function buildOperation({ name, arity, sync, async }) {
  return setFunctionMetadata(name, arity, function* (...args) {
    const resume = yield GENSYNC_START;
    if (!resume) return sync.call(this, args);

    let result;
    try {
      async.call(this, args, value => {
        if (result) return;
        result = { value };
        resume();
      }, err => {
        if (result) return;
        result = { err };
        resume();
      });
    } catch (err) {
      result = { err };
      resume();
    }
    yield GENSYNC_SUSPEND;
    if (result.hasOwnProperty("err")) throw result.err;

    return result.value;
  });
}
function evaluateSync(gen) {
  let value;
  while (!({ value } = gen.next()).done) assertStart(value, gen);

  return value;
}
function evaluateAsync(gen, resolve, reject) {
  !(function step() {
    try {
      let value;
      while (!({ value } = gen.next()).done) {
        assertStart(value, gen);
        let sync = true,
          didSyncResume = false;
        const out = gen.next(() => {
          sync ? (didSyncResume = true) : step();
        });
        sync = false;
        assertSuspend(out, gen);
        if (!didSyncResume) return;
      }
      return resolve(value);
    } catch (err) {
      return reject(err);
    }
  })();
}
function assertStart(value, gen) {
  value === GENSYNC_START ||
    throwError(gen, makeError(
      `Got unexpected yielded value in gensync generator: ${JSON.stringify(
        value
      )}. Did you perhaps mean to use 'yield*' instead of 'yield'?`,
      GENSYNC_EXPECTED_START
    ));
}
function assertSuspend({ value, done }, gen) {
  if (!done && value === GENSYNC_SUSPEND) return;
  throwError(gen, makeError(
    done
      ? "Unexpected generator completion. If you get this, it is probably a gensync bug."
      : `Expected GENSYNC_SUSPEND, got ${JSON.stringify(value)}. If you get this, it is probably a gensync bug.`,
    GENSYNC_EXPECTED_SUSPEND
  ));
}
function throwError(gen, err) {
  gen.throw && gen.throw(err);
  throw err;
}
function setFunctionMetadata(name, arity, fn) {
  if (typeof name == "string") {
    const nameDesc = Object.getOwnPropertyDescriptor(fn, "name");
    (nameDesc && !nameDesc.configurable) ||
      Object.defineProperty(fn, "name", Object.assign(nameDesc || {}, { configurable: true, value: name }));
  }
  if (typeof arity == "number") {
    const lengthDesc = Object.getOwnPropertyDescriptor(fn, "length");
    (lengthDesc && !lengthDesc.configurable) ||
      Object.defineProperty(fn, "length", Object.assign(lengthDesc || {}, { configurable: true, value: arity }));
  }
  return fn;
}

const runGenerator = gensync(function* (item) {
  return yield* item;
});
const isAsync = gensync({
  sync: () => false,
  errback: cb => cb(null, true)
});
function maybeAsync(fn, message) {
  return gensync({
    sync(...args) {
      const result = fn.apply(this, args);
      if (isThenable$1(result)) throw new Error(message);
      return result;
    },
    async(...args) {
      return Promise.resolve(fn.apply(this, args));
    }
  });
}
const withKind = gensync({
  sync: cb => cb("sync"),
  async: cb => new Promise(resolve => resolve(cb("async")))
});
function forwardAsync(action, cb) {
  const g = gensync(action);
  return withKind(kind => {
    const adapted = g[kind];
    return cb(adapted);
  });
}
const onFirstPause = gensync({
  name: "onFirstPause",
  arity: 2,
  sync: function (item) {
    return runGenerator.sync(item);
  },
  errback: function (item, firstPause, cb) {
    let completed = false;
    runGenerator.errback(item, (err, value) => {
      completed = true;
      cb(err, value);
    });
    completed || firstPause();
  }
});
const waitFor = gensync({
  sync: x => x,
  async: x => Promise.resolve(x)
});
function isThenable$1(val) {
  return !(!val || (typeof val != "object" && typeof val != "function") || !val.then || typeof val.then != "function");
}

function mergeOptions(target, source) {
  for (const k of Object.keys(source))
    if ((k === "parserOpts" || k === "generatorOpts" || k === "assumptions") && source[k]) {
      const parserOpts = source[k];
      mergeDefaultFields(target[k] || (target[k] = {}), parserOpts);
    } else {
      const val = source[k];
      if (val !== void 0) target[k] = val;
    }
}
function mergeDefaultFields(target, source) {
  for (const k of Object.keys(source)) {
    const val = source[k];
    if (val !== void 0) target[k] = val;
  }
}
function isIterableIterator(value) {
  return !!value && typeof value.next == "function" && typeof value[Symbol.iterator] == "function";
}

const synchronize = gen => gensync(gen).sync;
function* genTrue() {
  return true;
}
function makeWeakCache(handler) {
  return makeCachedFunction(WeakMap, handler);
}
function makeWeakCacheSync(handler) {
  return synchronize(makeWeakCache(handler));
}
function makeStrongCache(handler) {
  return makeCachedFunction(Map, handler);
}
function makeStrongCacheSync(handler) {
  return synchronize(makeStrongCache(handler));
}
function makeCachedFunction(CallCache, handler) {
  const callCacheSync = new CallCache(),
    callCacheAsync = new CallCache(),
    futureCache = new CallCache();
  return function* (arg, data) {
    const asyncContext = yield* isAsync(),
      callCache = asyncContext ? callCacheAsync : callCacheSync,
      cached = yield* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data);
    if (cached.valid) return cached.value;
    const cache = new CacheConfigurator(data),
      handlerResult = handler(arg, cache);
    let finishLock, value;
    value = isIterableIterator(handlerResult)
      ? yield* onFirstPause(handlerResult, () => {
          finishLock = setupAsyncLocks(cache, futureCache, arg);
        })
      : handlerResult;

    updateFunctionCache(callCache, cache, arg, value);
    if (finishLock) {
      futureCache.delete(arg);
      finishLock.release(value);
    }
    return value;
  };
}
function* getCachedValue(cache, arg, data) {
  const cachedValue = cache.get(arg);
  if (cachedValue)
    for (const { value, valid } of cachedValue) if (yield* valid(data)) return { valid: true, value };

  return { valid: false, value: null };
}
function* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data) {
  const cached = yield* getCachedValue(callCache, arg, data);
  if (cached.valid) return cached;

  if (asyncContext) {
    const cached = yield* getCachedValue(futureCache, arg, data);
    if (cached.valid) return { valid: true, value: yield* waitFor(cached.value.promise) };
  }
  return { valid: false, value: null };
}
function setupAsyncLocks(config, futureCache, arg) {
  const finishLock = new Lock();
  updateFunctionCache(futureCache, config, arg, finishLock);
  return finishLock;
}
function updateFunctionCache(cache, config, arg, value) {
  config.configured() || config.forever();
  let cachedValue = cache.get(arg);
  config.deactivate();
  switch (config.mode()) {
    case "forever":
      cachedValue = [{ value, valid: genTrue }];
      cache.set(arg, cachedValue);
      break;
    case "invalidate":
      cachedValue = [{ value, valid: config.validator() }];
      cache.set(arg, cachedValue);
      break;
    case "valid":
      if (cachedValue) cachedValue.push({ value, valid: config.validator() });
      else {
        cachedValue = [{ value, valid: config.validator() }];
        cache.set(arg, cachedValue);
      }
  }
}
class CacheConfigurator {
  constructor(data) {
    this._active = true;
    this._never = false;
    this._forever = false;
    this._invalidate = false;
    this._configured = false;
    this._pairs = [];
    this._data = void 0;
    this._data = data;
  }
  simple() {
    return makeSimpleConfigurator(this);
  }
  mode() {
    return this._never ? "never" : this._forever ? "forever" : this._invalidate ? "invalidate" : "valid";
  }
  forever() {
    if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");

    if (this._never) throw new Error("Caching has already been configured with .never()");

    this._forever = true;
    this._configured = true;
  }
  never() {
    if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");

    if (this._forever) throw new Error("Caching has already been configured with .forever()");

    this._never = true;
    this._configured = true;
  }
  using(handler) {
    if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");

    if (this._never || this._forever)
      throw new Error("Caching has already been configured with .never or .forever()");

    this._configured = true;
    const key = handler(this._data);
    const fn = maybeAsync(handler,
      "You appear to be using an async cache handler, but Babel has been called synchronously"
    );
    if (isThenable$1(key))
      return key.then(key => {
        this._pairs.push([key, fn]);
        return key;
      });

    this._pairs.push([key, fn]);
    return key;
  }
  invalidate(handler) {
    this._invalidate = true;
    return this.using(handler);
  }
  validator() {
    const pairs = this._pairs;
    return function* (data) {
      for (const [key, fn] of pairs) if (key !== (yield* fn(data))) return false;

      return true;
    };
  }
  deactivate() {
    this._active = false;
  }
  configured() {
    return this._configured;
  }
}
function makeSimpleConfigurator(cache) {
  function cacheFn(val) {
    if (typeof val != "boolean") return cache.using(() => assertSimpleType(val()));

    val ? cache.forever() : cache.never();
  }
  cacheFn.forever = () => cache.forever();
  cacheFn.never = () => cache.never();
  cacheFn.using = cb => cache.using(() => assertSimpleType(cb()));
  cacheFn.invalidate = cb => cache.invalidate(() => assertSimpleType(cb()));
  return cacheFn;
}
function assertSimpleType(value) {
  if (isThenable$1(value))
    throw new Error(
      "You appear to be using an async cache handler, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously handle your caching logic."
    );

  if (value != null && typeof value != "string" && typeof value != "boolean" && typeof value != "number")
    throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");

  return value;
}
class Lock {
  constructor() {
    this.released = false;
    this.promise = void 0;
    this._resolve = void 0;
    this.promise = new Promise(resolve => {
      this._resolve = resolve;
    });
  }
  release(value) {
    this.released = true;
    this._resolve(value);
  }
}

const readFile = gensync({ sync: fs.readFileSync, errback: fs.readFile }),
  stat = gensync({ sync: fs.statSync, errback: fs.stat });

function makeStaticFileCache(fn) {
  return makeStrongCache(function* (filepath, cache) {
    return cache.invalidate(() => fileMtime(filepath)) === null
      ? null
      : fn(filepath, yield* readFile(filepath, "utf8"));
  });
}
function fileMtime(filepath) {
  if (!fs.existsSync(filepath)) return null;
  try {
    return +fs.statSync(filepath).mtime;
  } catch (e) {
    if (e.code !== "ENOENT" && e.code !== "ENOTDIR") throw e;
  }
  return null;
}

var _Object$getOwnPropert;
const ErrorToString = Function.call.bind(Error.prototype.toString);
const SUPPORTED =
  !!Error.captureStackTrace &&
  ((_Object$getOwnPropert = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit")) == null
    ? void 0 : _Object$getOwnPropert.writable) === true;
const START_HIDING = "startHiding - secret - don't use this - v1",
  STOP_HIDING = "stopHiding - secret - don't use this - v1",
  expectedErrors = new WeakSet(),
  virtualFrames = new WeakMap();
function CallSite(filename) {
  return Object.create({
    isNative: () => false,
    isConstructor: () => false,
    isToplevel: () => true,
    getFileName: () => filename,
    getLineNumber: () => void 0,
    getColumnNumber: () => void 0,
    getFunctionName: () => void 0,
    getMethodName: () => void 0,
    getTypeName: () => void 0,
    toString: () => filename
  });
}
function injectVirtualStackFrame(error, filename) {
  if (!SUPPORTED) return;
  let frames = virtualFrames.get(error);
  frames || virtualFrames.set(error, (frames = []));
  frames.push(CallSite(filename));
  return error;
}
function expectedError(error) {
  if (!SUPPORTED) return;
  expectedErrors.add(error);
  return error;
}
function beginHiddenCallStack(fn) {
  return !SUPPORTED ? fn : Object.defineProperty(
    function (...args) {
      setupPrepareStackTrace();
      return fn(...args);
    },
    "name", { value: STOP_HIDING }
  );
}
function endHiddenCallStack(fn) {
  return !SUPPORTED ? fn : Object.defineProperty(
    function (...args) {
      return fn(...args);
    },
    "name", { value: START_HIDING }
  );
}
function setupPrepareStackTrace() {
  setupPrepareStackTrace = () => {};
  const { prepareStackTrace = defaultPrepareStackTrace } = Error,
    MIN_STACK_TRACE_LIMIT = 50;
  Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, MIN_STACK_TRACE_LIMIT));
  Error.prepareStackTrace = function (err, trace) {
    let newTrace = [],
      status = expectedErrors.has(err) ? "hiding" : "unknown";
    for (let i = 0; i < trace.length; i++) {
      const name = trace[i].getFunctionName();
      if (name === START_HIDING) status = "hiding";
      else if (name === STOP_HIDING) {
        if (status === "hiding") {
          status = "showing";
          virtualFrames.has(err) && newTrace.unshift(...virtualFrames.get(err));
        } else if (status === "unknown") {
          newTrace = trace;
          break;
        }
      } else status === "hiding" || newTrace.push(trace[i]);
    }
    return prepareStackTrace(err, newTrace);
  };
}
function defaultPrepareStackTrace(err, trace) {
  return trace.length === 0 ? ErrorToString(err) : `${ErrorToString(err)}\n    at ${trace.join("\n    at ")}`;
}

class ConfigError extends Error {
  constructor(message, filename) {
    super(message);
    expectedError(this);
    filename && injectVirtualStackFrame(this, filename);
  }
}

const PACKAGE_FILENAME = "package.json";
const readConfigPackage = makeStaticFileCache((filepath, content) => {
  let options;
  try {
    options = JSON.parse(content);
  } catch (err) {
    throw new ConfigError("Error while parsing JSON - " + err.message, filepath);
  }
  if (!options) throw new Error(filepath + ": No config detected");
  if (typeof options != "object") throw new ConfigError("Config returned typeof " + typeof options, filepath);

  if (Array.isArray(options)) throw new ConfigError("Expected config object but found array", filepath);

  return { filepath, dirname: path.dirname(filepath), options };
});
function* findPackageData(filepath) {
  let pkg = null;
  const directories = [];
  let isPackage = true,
    dirname = path.dirname(filepath);
  while (!pkg && path.basename(dirname) !== "node_modules") {
    directories.push(dirname);
    pkg = yield* readConfigPackage(path.join(dirname, PACKAGE_FILENAME));
    const nextLoc = path.dirname(dirname);
    if (dirname === nextLoc) {
      isPackage = false;
      break;
    }
    dirname = nextLoc;
  }
  return { filepath, directories, pkg, isPackage };
}

function makeConfigAPI(cache) {
  const env = value => cache.using(data =>
    value === void 0
      ? data.envName
      : typeof value == "function"
      ? assertSimpleType(value(data.envName))
      : (Array.isArray(value) ? value : [value]).some(entry => {
          if (typeof entry != "string") throw new Error("Unexpected non-string value");

          return entry === data.envName;
        })
  );
  const caller = cb => cache.using(data => assertSimpleType(cb(data.caller)));
  return { version: version$1, cache: cache.simple(), env, async: () => false, caller, assertVersion };
}
function makePresetAPI(cache, externalDependencies) {
  const targets = () => JSON.parse(cache.using(data => JSON.stringify(data.targets))),
    addExternalDependency = ref => {
      externalDependencies.push(ref);
    };
  return Object.assign({}, makeConfigAPI(cache), { targets, addExternalDependency });
}
function makePluginAPI(cache, externalDependencies) {
  const assumption = name => cache.using(data => data.assumptions[name]);
  return Object.assign({}, makePresetAPI(cache, externalDependencies), { assumption });
}
function assertVersion(range) {
  if (typeof range == "number") {
    if (!Number.isInteger(range)) throw new Error("Expected string or integer value.");

    range = `^${range}.0.0-0`;
  }
  if (typeof range != "string") throw new Error("Expected string or integer value.");

  if (vendors.semver.satisfies(version$1, range)) return;
  const limit = Error.stackTraceLimit;
  if (typeof limit == "number" && limit < 25) Error.stackTraceLimit = 25;

  const err = new Error(
    `Requires Babel "${range}", but was loaded with "${version$1}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`
  );
  if (typeof limit == "number") Error.stackTraceLimit = limit;

  throw Object.assign(err, { code: "BABEL_VERSION_UNSUPPORTED", version: version$1, range });
}

function finalize(deepArr) {
  return Object.freeze(deepArr);
}
function flattenToSet(arr) {
  const result = new Set(),
    stack = [arr];
  while (stack.length > 0) for (const el of stack.pop()) Array.isArray(el) ? stack.push(el) : result.add(el);

  return result;
}

class Plugin {
  constructor(plugin, options, key, externalDependencies = finalize([])) {
    this.key = void 0;
    this.manipulateOptions = void 0;
    this.post = void 0;
    this.pre = void 0;
    this.visitor = void 0;
    this.parserOverride = void 0;
    this.generatorOverride = void 0;
    this.options = void 0;
    this.externalDependencies = void 0;
    this.key = plugin.name || key;
    this.manipulateOptions = plugin.manipulateOptions;
    this.post = plugin.post;
    this.pre = plugin.pre;
    this.visitor = plugin.visitor || {};
    this.parserOverride = plugin.parserOverride;
    this.generatorOverride = plugin.generatorOverride;
    this.options = options;
    this.externalDependencies = externalDependencies;
  }
}

function once(fn) {
  let result, resultP;
  return function* () {
    if (result) return result;
    if (!(yield* isAsync())) return (result = yield* fn());
    if (resultP) return yield* waitFor(resultP);
    let resolve, reject;
    resultP = new Promise((res, rej) => {
      resolve = res;
      reject = rej;
    });
    try {
      result = yield* fn();
      resultP = null;
      resolve(result);
      return result;
    } catch (error) {
      reject(error);
      throw error;
    }
  };
}

const { min } = Math;
function levenshtein(a, b) {
  let i,
    j,
    t = [],
    u = [];
  const m = a.length,
    n = b.length;
  if (!m) return n;
  if (!n) return m;

  for (j = 0; j <= n; j++) t[j] = j;

  for (i = 1; i <= m; i++) {
    for (u = [i], j = 1; j <= n; j++) u[j] = a[i - 1] === b[j - 1] ? t[j - 1] : min(t[j - 1], t[j], u[j - 1]) + 1;

    t = u;
  }
  return u[n];
}
function findSuggestion(str, arr) {
  const distances = arr.map(el => levenshtein(el, str));
  return arr[distances.indexOf(min(...distances))];
}

class OptionValidator {
  constructor(descriptor) {
    this.descriptor = descriptor;
  }
  validateTopLevelOptions(options, TopLevelOptionShape) {
    const validOptionNames = Object.keys(TopLevelOptionShape);
    for (const option of Object.keys(options))
      if (!validOptionNames.includes(option))
        throw new Error(
          this.formatMessage(`'${option}' is not a valid top-level option.
- Did you mean '${findSuggestion(option, validOptionNames)}'?`)
        );
  }
  validateBooleanOption(name, value, defaultValue) {
    if (value === void 0) return defaultValue;

    this.invariant(typeof value == "boolean", `'${name}' option must be a boolean.`);

    return value;
  }
  validateStringOption(name, value, defaultValue) {
    if (value === void 0) return defaultValue;

    this.invariant(typeof value == "string", `'${name}' option must be a string.`);

    return value;
  }
  invariant(condition, message) {
    if (!condition) throw new Error(this.formatMessage(message));
  }
  formatMessage(message) {
    return `${this.descriptor}: ${message}`;
  }
}

var require$$0$6 = {
  "es6.module": {
    chrome: "61",
    and_chr: "61",
    edge: "16",
    firefox: "60",
    and_ff: "60",
    node: "13.2.0",
    opera: "48",
    op_mob: "45",
    safari: "10.1",
    ios: "10.3",
    samsung: "8.2",
    android: "61",
    electron: "2.0",
    ios_saf: "10.3"
  }
};

var nativeModules = require$$0$6,

  yallist = Yallist$1;
Yallist$1.Node = Node;
Yallist$1.create = Yallist$1;
function Yallist$1(list) {
  var self = this;
  self instanceof Yallist$1 || (self = new Yallist$1());

  self.tail = null;
  self.head = null;
  self.length = 0;
  if (list && typeof list.forEach == 'function')
    list.forEach(function (item) {
      self.push(item);
    });
  else if (arguments.length > 0) for (var i = 0, l = arguments.length; i < l; i++) self.push(arguments[i]);

  return self;
}
Yallist$1.prototype.removeNode = function (node) {
  if (node.list !== this) throw new Error('removing node which does not belong to this list');

  var next = node.next,
    prev = node.prev;
  if (next) next.prev = prev;
  if (prev) prev.next = next;

  if (node === this.head) this.head = next;
  if (node === this.tail) this.tail = prev;

  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};
Yallist$1.prototype.unshiftNode = function (node) {
  if (node === this.head) return;

  node.list && node.list.removeNode(node);

  var head = this.head;
  node.list = this;
  node.next = head;
  if (head) head.prev = node;

  this.head = node;
  this.tail || (this.tail = node);

  this.length++;
};
Yallist$1.prototype.pushNode = function (node) {
  if (node === this.tail) return;

  node.list && node.list.removeNode(node);

  var tail = this.tail;
  node.list = this;
  node.prev = tail;
  if (tail) tail.next = node;

  this.tail = node;
  this.head || (this.head = node);

  this.length++;
};
Yallist$1.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) push(this, arguments[i]);

  return this.length;
};
Yallist$1.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) unshift(this, arguments[i]);

  return this.length;
};
Yallist$1.prototype.pop = function () {
  if (!this.tail) return void 0;

  var res = this.tail.value;
  this.tail = this.tail.prev;
  this.tail ? (this.tail.next = null) : (this.head = null);

  this.length--;
  return res;
};
Yallist$1.prototype.shift = function () {
  if (!this.head) return void 0;

  var res = this.head.value;
  this.head = this.head.next;
  this.head ? (this.head.prev = null) : (this.tail = null);

  this.length--;
  return res;
};
Yallist$1.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};
Yallist$1.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};
Yallist$1.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) walker = walker.next;

  if (i === n && walker !== null) return walker.value;
};
Yallist$1.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) walker = walker.prev;

  if (i === n && walker !== null) return walker.value;
};
Yallist$1.prototype.map = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.head; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }
  return res;
};
Yallist$1.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.tail; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }
  return res;
};
Yallist$1.prototype.reduce = function (fn, initial) {
  var acc,
    walker = this.head;
  if (arguments.length > 1) acc = initial;
  else {
    if (!this.head) throw new TypeError('Reduce of empty list with no initial value');

    walker = this.head.next;
    acc = this.head.value;
  }
  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }
  return acc;
};
Yallist$1.prototype.reduceReverse = function (fn, initial) {
  var acc,
    walker = this.tail;
  if (arguments.length > 1) acc = initial;
  else {
    if (!this.tail) throw new TypeError('Reduce of empty list with no initial value');

    walker = this.tail.prev;
    acc = this.tail.value;
  }
  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }
  return acc;
};
Yallist$1.prototype.toArray = function () {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }
  return arr;
};
Yallist$1.prototype.toArrayReverse = function () {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }
  return arr;
};
Yallist$1.prototype.slice = function (from, to) {
  if ((to = to || this.length) < 0) to += this.length;

  if ((from = from || 0) < 0) from += this.length;

  var ret = new Yallist$1();
  if (to < from || to < 0) return ret;

  if (from < 0) from = 0;
  if (to > this.length) to = this.length;

  for (var i = 0, walker = this.head; walker !== null && i < from; i++) walker = walker.next;

  for (; walker !== null && i < to; i++, walker = walker.next) ret.push(walker.value);

  return ret;
};
Yallist$1.prototype.sliceReverse = function (from, to) {
  if ((to = to || this.length) < 0) to += this.length;

  if ((from = from || 0) < 0) from += this.length;

  var ret = new Yallist$1();
  if (to < from || to < 0) return ret;

  if (from < 0) from = 0;
  if (to > this.length) to = this.length;

  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) walker = walker.prev;

  for (; walker !== null && i > from; i--, walker = walker.prev) ret.push(walker.value);

  return ret;
};
Yallist$1.prototype.splice = function (start, deleteCount) {
  if (start > this.length) start = this.length - 1;
  if (start < 0) start = this.length + start;

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) walker = walker.next;

  var ret = [];
  for (i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }
  if (walker === null) walker = this.tail;

  if (walker !== this.head && walker !== this.tail) walker = walker.prev;

  for (i = 2; i < arguments.length; i++) walker = insert$1(this, walker, arguments[i]);

  return ret;
};
Yallist$1.prototype.reverse = function () {
  var head = this.head,
    tail = this.tail;
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }
  this.head = tail;
  this.tail = head;
  return this;
};
function insert$1(self, node, value) {
  var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
  if (inserted.next === null) self.tail = inserted;

  if (inserted.prev === null) self.head = inserted;

  self.length++;
  return inserted;
}
function push(self, item) {
  self.tail = new Node(item, self.tail, null, self);
  self.head || (self.head = self.tail);

  self.length++;
}
function unshift(self, item) {
  self.head = new Node(item, null, self.head, self);
  self.tail || (self.tail = self.head);

  self.length++;
}
function Node(value, prev, next, list) {
  if (!(this instanceof Node)) return new Node(value, prev, next, list);

  this.list = list;
  this.value = value;
  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else this.prev = null;

  if (next) {
    next.prev = this;
    this.next = next;
  } else this.next = null;
}
try {
  Yallist$1.prototype[Symbol.iterator] = function* () {
    for (let walker = this.head; walker; walker = walker.next) yield walker.value;
  };
} catch (_er) {}

const Yallist = yallist,
  MAX = Symbol('max'),
  LENGTH = Symbol('length'),
  LENGTH_CALCULATOR = Symbol('lengthCalculator'),
  ALLOW_STALE = Symbol('allowStale'),
  MAX_AGE = Symbol('maxAge'),
  DISPOSE = Symbol('dispose'),
  NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet'),
  LRU_LIST = Symbol('lruList'),
  CACHE = Symbol('cache'),
  UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet'),
  naiveLength = () => 1;
class LRUCache {
  constructor(options) {
    if (typeof options == 'number') options = { max: options };
    options || (options = {});
    if (options.max && (typeof options.max != 'number' || options.max < 0))
      throw new TypeError('max must be a non-negative number');
    this[MAX] = options.max || Infinity;
    const lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc != 'function' ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge != 'number') throw new TypeError('maxAge must be a number');
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  }
  set max(mL) {
    if (typeof mL != 'number' || mL < 0) throw new TypeError('max must be a non-negative number');
    this[MAX] = mL || Infinity;
    trim(this);
  }
  get max() {
    return this[MAX];
  }
  set allowStale(allowStale) {
    this[ALLOW_STALE] = !!allowStale;
  }
  get allowStale() {
    return this[ALLOW_STALE];
  }
  set maxAge(mA) {
    if (typeof mA != 'number') throw new TypeError('maxAge must be a non-negative number');
    this[MAX_AGE] = mA;
    trim(this);
  }
  get maxAge() {
    return this[MAX_AGE];
  }
  set lengthCalculator(lC) {
    if (typeof lC != 'function') lC = naiveLength;
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC;
      this[LENGTH] = 0;
      this[LRU_LIST].forEach(hit => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
        this[LENGTH] += hit.length;
      });
    }
    trim(this);
  }
  get lengthCalculator() {
    return this[LENGTH_CALCULATOR];
  }
  get length() {
    return this[LENGTH];
  }
  get itemCount() {
    return this[LRU_LIST].length;
  }
  rforEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].tail; walker !== null; ) {
      const prev = walker.prev;
      forEachStep(this, fn, walker, thisp);
      walker = prev;
    }
  }
  forEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].head; walker !== null; ) {
      const next = walker.next;
      forEachStep(this, fn, walker, thisp);
      walker = next;
    }
  }
  keys() {
    return this[LRU_LIST].toArray().map(k => k.key);
  }
  values() {
    return this[LRU_LIST].toArray().map(k => k.value);
  }
  reset() {
    this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length &&
      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value));

    this[CACHE] = new Map();
    this[LRU_LIST] = new Yallist();
    this[LENGTH] = 0;
  }
  dump() {
    return this[LRU_LIST].map(
      hit => !isStale(this, hit) && { k: hit.key, v: hit.value, e: hit.now + (hit.maxAge || 0) }
    ).toArray().filter(h => h);
  }
  dumpLru() {
    return this[LRU_LIST];
  }
  set(key, value, maxAge) {
    if ((maxAge = maxAge || this[MAX_AGE]) && typeof maxAge != 'number')
      throw new TypeError('maxAge must be a number');
    const now = maxAge ? Date.now() : 0,
      len = this[LENGTH_CALCULATOR](value, key);
    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key));
        return false;
      }
      const item = this[CACHE].get(key).value;
      !this[DISPOSE] || this[NO_DISPOSE_ON_SET] || this[DISPOSE](key, item.value);

      item.now = now;
      item.maxAge = maxAge;
      item.value = value;
      this[LENGTH] += len - item.length;
      item.length = len;
      this.get(key);
      trim(this);
      return true;
    }
    const hit = new Entry$1(key, value, len, now, maxAge);
    if (hit.length > this[MAX]) {
      this[DISPOSE] && this[DISPOSE](key, value);
      return false;
    }
    this[LENGTH] += hit.length;
    this[LRU_LIST].unshift(hit);
    this[CACHE].set(key, this[LRU_LIST].head);
    trim(this);
    return true;
  }
  has(key) {
    if (!this[CACHE].has(key)) return false;
    const hit = this[CACHE].get(key).value;
    return !isStale(this, hit);
  }
  get(key) {
    return get$2(this, key, true);
  }
  peek(key) {
    return get$2(this, key, false);
  }
  pop() {
    const node = this[LRU_LIST].tail;
    if (!node) return null;
    del(this, node);
    return node.value;
  }
  del(key) {
    del(this, this[CACHE].get(key));
  }
  load(arr) {
    this.reset();
    const now = Date.now();
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l],
        expiresAt = hit.e || 0;
      if (expiresAt === 0) this.set(hit.k, hit.v);
      else {
        const maxAge = expiresAt - now;
        maxAge > 0 && this.set(hit.k, hit.v, maxAge);
      }
    }
  }
  prune() {
    this[CACHE].forEach((value, key) => get$2(this, key, false));
  }
}
const get$2 = (self, key, doUse) => {
  const node = self[CACHE].get(key);
  if (node) {
    const hit = node.value;
    if (isStale(self, hit)) {
      del(self, node);
      if (!self[ALLOW_STALE]) return void 0;
    } else if (doUse) {
      if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
      self[LRU_LIST].unshiftNode(node);
    }
    return hit.value;
  }
};
const isStale = (self, hit) => {
  if (!hit || (!hit.maxAge && !self[MAX_AGE])) return false;
  const diff = Date.now() - hit.now;
  return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
};
const trim = self => {
  if (self[LENGTH] > self[MAX])
    for (let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null; ) {
      const prev = walker.prev;
      del(self, walker);
      walker = prev;
    }
};
const del = (self, node) => {
  if (node) {
    const hit = node.value;
    self[DISPOSE] && self[DISPOSE](hit.key, hit.value);
    self[LENGTH] -= hit.length;
    self[CACHE].delete(hit.key);
    self[LRU_LIST].removeNode(node);
  }
};
let Entry$1 = class {
  constructor(key, value, length, now, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length;
    this.now = now;
    this.maxAge = maxAge || 0;
  }
};
const forEachStep = (self, fn, node, thisp) => {
  let hit = node.value;
  if (isStale(self, hit)) {
    del(self, node);
    self[ALLOW_STALE] || (hit = void 0);
  }
  hit && fn.call(thisp, hit.value, hit.key, self);
};
var lruCache = LRUCache;

const unreleasedLabels = { safari: "tp" };
const browserNameMap = {
  and_chr: "chrome",
  and_ff: "firefox",
  android: "android",
  chrome: "chrome",
  edge: "edge",
  firefox: "firefox",
  ie: "ie",
  ie_mob: "ie",
  ios_saf: "ios",
  node: "node",
  deno: "deno",
  op_mob: "opera_mobile",
  opera: "opera",
  safari: "safari",
  samsung: "samsung"
};

const versionRegExp = /^(\d+|\d+.\d+)$/,
  v$4 = new OptionValidator("@babel/helper-compilation-targets");
function semverMin(first, second) {
  return first && vendors.semver.lt(first, second) ? first : second;
}
function semverify(version) {
  if (typeof version == "string" && vendors.semver.valid(version)) return version;

  v$4.invariant(
    typeof version == "number" || (typeof version == "string" && versionRegExp.test(version)),
    `'${version}' is not a valid version`
  );
  version = version.toString();
  let pos = 0,
    num = 0;
  while ((pos = version.indexOf(".", pos + 1)) > 0) num++;

  return version + ".0".repeat(2 - num);
}
function isUnreleasedVersion(version, env) {
  const unreleasedLabel = unreleasedLabels[env];
  return !!unreleasedLabel && unreleasedLabel === version.toString().toLowerCase();
}
function getLowestUnreleased(a, b, env) {
  const unreleasedLabel = unreleasedLabels[env];
  return a === unreleasedLabel ? b : b === unreleasedLabel ? a : semverMin(a, b);
}
function getHighestUnreleased(a, b, env) {
  return getLowestUnreleased(a, b, env) === a ? b : a;
}
function getLowestImplementedVersion(plugin, environment) {
  const result = plugin[environment];
  return result || environment !== "android" ? result : plugin.chrome;
}

const TargetNames = {
  node: "node",
  deno: "deno",
  chrome: "chrome",
  opera: "opera",
  edge: "edge",
  firefox: "firefox",
  safari: "safari",
  ie: "ie",
  ios: "ios",
  android: "android",
  electron: "electron",
  samsung: "samsung",
  rhino: "rhino",
  opera_mobile: "opera_mobile"
};

function prettifyVersion(version) {
  if (typeof version != "string") return version;

  const { major, minor, patch } = vendors.semver.parse(version),
    parts = [major];
  if (minor || patch) parts.push(minor);

  patch && parts.push(patch);

  return parts.join(".");
}
function prettifyTargets(targets) {
  return Object.keys(targets).reduce((results, target) => {
    let value = targets[target];
    const unreleasedLabel = unreleasedLabels[target];
    if (typeof value == "string" && unreleasedLabel !== value) value = prettifyVersion(value);

    results[target] = value;
    return results;
  }, {});
}

function getInclusionReasons(item, targetVersions, list) {
  const minVersions = list[item] || {};
  return Object.keys(targetVersions).reduce((result, env) => {
    const minVersion = getLowestImplementedVersion(minVersions, env),
      targetVersion = targetVersions[env];
    if (minVersion) {
      const minIsUnreleased = isUnreleasedVersion(minVersion, env);
      isUnreleasedVersion(targetVersion, env) ||
        (!minIsUnreleased && !vendors.semver.lt(targetVersion.toString(), semverify(minVersion))) ||
        (result[env] = prettifyVersion(targetVersion));
    } else result[env] = prettifyVersion(targetVersion);

    return result;
  }, {});
}

var require$$0$5 = {
  "transform-unicode-sets-regex": {
    chrome: "112",
    opera: "98",
    edge: "112",
    firefox: "116",
    safari: "tp",
    node: "20",
    deno: "1.32",
    opera_mobile: "75",
    electron: "24.0"
  },
  "transform-class-static-block": {
    chrome: "94",
    opera: "80",
    edge: "94",
    firefox: "93",
    safari: "16.4",
    node: "16.11",
    deno: "1.14",
    ios: "16.4",
    samsung: "17",
    opera_mobile: "66",
    electron: "15.0"
  },
  "proposal-class-static-block": {
    chrome: "94",
    opera: "80",
    edge: "94",
    firefox: "93",
    safari: "16.4",
    node: "16.11",
    deno: "1.14",
    ios: "16.4",
    samsung: "17",
    opera_mobile: "66",
    electron: "15.0"
  },
  "transform-private-property-in-object": {
    chrome: "91",
    opera: "77",
    edge: "91",
    firefox: "90",
    safari: "15",
    node: "16.9",
    deno: "1.9",
    ios: "15",
    samsung: "16",
    opera_mobile: "64",
    electron: "13.0"
  },
  "proposal-private-property-in-object": {
    chrome: "91",
    opera: "77",
    edge: "91",
    firefox: "90",
    safari: "15",
    node: "16.9",
    deno: "1.9",
    ios: "15",
    samsung: "16",
    opera_mobile: "64",
    electron: "13.0"
  },
  "transform-class-properties": {
    chrome: "74",
    opera: "62",
    edge: "79",
    firefox: "90",
    safari: "14.1",
    node: "12",
    deno: "1",
    ios: "14.5",
    samsung: "11",
    opera_mobile: "53",
    electron: "6.0"
  },
  "proposal-class-properties": {
    chrome: "74",
    opera: "62",
    edge: "79",
    firefox: "90",
    safari: "14.1",
    node: "12",
    deno: "1",
    ios: "14.5",
    samsung: "11",
    opera_mobile: "53",
    electron: "6.0"
  },
  "transform-private-methods": {
    chrome: "84",
    opera: "70",
    edge: "84",
    firefox: "90",
    safari: "15",
    node: "14.6",
    deno: "1",
    ios: "15",
    samsung: "14",
    opera_mobile: "60",
    electron: "10.0"
  },
  "proposal-private-methods": {
    chrome: "84",
    opera: "70",
    edge: "84",
    firefox: "90",
    safari: "15",
    node: "14.6",
    deno: "1",
    ios: "15",
    samsung: "14",
    opera_mobile: "60",
    electron: "10.0"
  },
  "transform-numeric-separator": {
    chrome: "75",
    opera: "62",
    edge: "79",
    firefox: "70",
    safari: "13",
    node: "12.5",
    deno: "1",
    ios: "13",
    samsung: "11",
    rhino: "1.7.14",
    opera_mobile: "54",
    electron: "6.0"
  },
  "proposal-numeric-separator": {
    chrome: "75",
    opera: "62",
    edge: "79",
    firefox: "70",
    safari: "13",
    node: "12.5",
    deno: "1",
    ios: "13",
    samsung: "11",
    rhino: "1.7.14",
    opera_mobile: "54",
    electron: "6.0"
  },
  "transform-logical-assignment-operators": {
    chrome: "85",
    opera: "71",
    edge: "85",
    firefox: "79",
    safari: "14",
    node: "15",
    deno: "1.2",
    ios: "14",
    samsung: "14",
    opera_mobile: "60",
    electron: "10.0"
  },
  "proposal-logical-assignment-operators": {
    chrome: "85",
    opera: "71",
    edge: "85",
    firefox: "79",
    safari: "14",
    node: "15",
    deno: "1.2",
    ios: "14",
    samsung: "14",
    opera_mobile: "60",
    electron: "10.0"
  },
  "transform-nullish-coalescing-operator": {
    chrome: "80",
    opera: "67",
    edge: "80",
    firefox: "72",
    safari: "13.1",
    node: "14",
    deno: "1",
    ios: "13.4",
    samsung: "13",
    opera_mobile: "57",
    electron: "8.0"
  },
  "proposal-nullish-coalescing-operator": {
    chrome: "80",
    opera: "67",
    edge: "80",
    firefox: "72",
    safari: "13.1",
    node: "14",
    deno: "1",
    ios: "13.4",
    samsung: "13",
    opera_mobile: "57",
    electron: "8.0"
  },
  "transform-optional-chaining": {
    chrome: "91",
    opera: "77",
    edge: "91",
    firefox: "74",
    safari: "13.1",
    node: "16.9",
    deno: "1.9",
    ios: "13.4",
    samsung: "16",
    opera_mobile: "64",
    electron: "13.0"
  },
  "proposal-optional-chaining": {
    chrome: "91",
    opera: "77",
    edge: "91",
    firefox: "74",
    safari: "13.1",
    node: "16.9",
    deno: "1.9",
    ios: "13.4",
    samsung: "16",
    opera_mobile: "64",
    electron: "13.0"
  },
  "transform-json-strings": {
    chrome: "66",
    opera: "53",
    edge: "79",
    firefox: "62",
    safari: "12",
    node: "10",
    deno: "1",
    ios: "12",
    samsung: "9",
    rhino: "1.7.14",
    opera_mobile: "47",
    electron: "3.0"
  },
  "proposal-json-strings": {
    chrome: "66",
    opera: "53",
    edge: "79",
    firefox: "62",
    safari: "12",
    node: "10",
    deno: "1",
    ios: "12",
    samsung: "9",
    rhino: "1.7.14",
    opera_mobile: "47",
    electron: "3.0"
  },
  "transform-optional-catch-binding": {
    chrome: "66",
    opera: "53",
    edge: "79",
    firefox: "58",
    safari: "11.1",
    node: "10",
    deno: "1",
    ios: "11.3",
    samsung: "9",
    opera_mobile: "47",
    electron: "3.0"
  },
  "proposal-optional-catch-binding": {
    chrome: "66",
    opera: "53",
    edge: "79",
    firefox: "58",
    safari: "11.1",
    node: "10",
    deno: "1",
    ios: "11.3",
    samsung: "9",
    opera_mobile: "47",
    electron: "3.0"
  },
  "transform-parameters": {
    chrome: "49",
    opera: "36",
    edge: "18",
    firefox: "53",
    safari: "16.3",
    node: "6",
    deno: "1",
    ios: "16.3",
    samsung: "5",
    opera_mobile: "36",
    electron: "0.37"
  },
  "transform-async-generator-functions": {
    chrome: "63",
    opera: "50",
    edge: "79",
    firefox: "57",
    safari: "12",
    node: "10",
    deno: "1",
    ios: "12",
    samsung: "8",
    opera_mobile: "46",
    electron: "3.0"
  },
  "proposal-async-generator-functions": {
    chrome: "63",
    opera: "50",
    edge: "79",
    firefox: "57",
    safari: "12",
    node: "10",
    deno: "1",
    ios: "12",
    samsung: "8",
    opera_mobile: "46",
    electron: "3.0"
  },
  "transform-object-rest-spread": {
    chrome: "60",
    opera: "47",
    edge: "79",
    firefox: "55",
    safari: "11.1",
    node: "8.3",
    deno: "1",
    ios: "11.3",
    samsung: "8",
    opera_mobile: "44",
    electron: "2.0"
  },
  "proposal-object-rest-spread": {
    chrome: "60",
    opera: "47",
    edge: "79",
    firefox: "55",
    safari: "11.1",
    node: "8.3",
    deno: "1",
    ios: "11.3",
    samsung: "8",
    opera_mobile: "44",
    electron: "2.0"
  },
  "transform-dotall-regex": {
    chrome: "62",
    opera: "49",
    edge: "79",
    firefox: "78",
    safari: "11.1",
    node: "8.10",
    deno: "1",
    ios: "11.3",
    samsung: "8",
    opera_mobile: "46",
    electron: "3.0"
  },
  "transform-unicode-property-regex": {
    chrome: "64",
    opera: "51",
    edge: "79",
    firefox: "78",
    safari: "11.1",
    node: "10",
    deno: "1",
    ios: "11.3",
    samsung: "9",
    opera_mobile: "47",
    electron: "3.0"
  },
  "proposal-unicode-property-regex": {
    chrome: "64",
    opera: "51",
    edge: "79",
    firefox: "78",
    safari: "11.1",
    node: "10",
    deno: "1",
    ios: "11.3",
    samsung: "9",
    opera_mobile: "47",
    electron: "3.0"
  },
  "transform-named-capturing-groups-regex": {
    chrome: "64",
    opera: "51",
    edge: "79",
    firefox: "78",
    safari: "11.1",
    node: "10",
    deno: "1",
    ios: "11.3",
    samsung: "9",
    opera_mobile: "47",
    electron: "3.0"
  },
  "transform-async-to-generator": {
    chrome: "55",
    opera: "42",
    edge: "15",
    firefox: "52",
    safari: "11",
    node: "7.6",
    deno: "1",
    ios: "11",
    samsung: "6",
    opera_mobile: "42",
    electron: "1.6"
  },
  "transform-exponentiation-operator": {
    chrome: "52",
    opera: "39",
    edge: "14",
    firefox: "52",
    safari: "10.1",
    node: "7",
    deno: "1",
    ios: "10.3",
    samsung: "6",
    rhino: "1.7.14",
    opera_mobile: "41",
    electron: "1.3"
  },
  "transform-template-literals": {
    chrome: "41",
    opera: "28",
    edge: "13",
    firefox: "34",
    safari: "13",
    node: "4",
    deno: "1",
    ios: "13",
    samsung: "3.4",
    opera_mobile: "28",
    electron: "0.21"
  },
  "transform-literals": {
    chrome: "44",
    opera: "31",
    edge: "12",
    firefox: "53",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "4",
    opera_mobile: "32",
    electron: "0.30"
  },
  "transform-function-name": {
    chrome: "51",
    opera: "38",
    edge: "79",
    firefox: "53",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "transform-arrow-functions": {
    chrome: "47",
    opera: "34",
    edge: "13",
    firefox: "43",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    rhino: "1.7.13",
    opera_mobile: "34",
    electron: "0.36"
  },
  "transform-block-scoped-functions": {
    chrome: "41",
    opera: "28",
    edge: "12",
    firefox: "46",
    safari: "10",
    node: "4",
    deno: "1",
    ie: "11",
    ios: "10",
    samsung: "3.4",
    opera_mobile: "28",
    electron: "0.21"
  },
  "transform-classes": {
    chrome: "46",
    opera: "33",
    edge: "13",
    firefox: "45",
    safari: "10",
    node: "5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "33",
    electron: "0.36"
  },
  "transform-object-super": {
    chrome: "46",
    opera: "33",
    edge: "13",
    firefox: "45",
    safari: "10",
    node: "5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "33",
    electron: "0.36"
  },
  "transform-shorthand-properties": {
    chrome: "43",
    opera: "30",
    edge: "12",
    firefox: "33",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "4",
    rhino: "1.7.14",
    opera_mobile: "30",
    electron: "0.27"
  },
  "transform-duplicate-keys": {
    chrome: "42",
    opera: "29",
    edge: "12",
    firefox: "34",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "3.4",
    opera_mobile: "29",
    electron: "0.25"
  },
  "transform-computed-properties": {
    chrome: "44",
    opera: "31",
    edge: "12",
    firefox: "34",
    safari: "7.1",
    node: "4",
    deno: "1",
    ios: "8",
    samsung: "4",
    opera_mobile: "32",
    electron: "0.30"
  },
  "transform-for-of": {
    chrome: "51",
    opera: "38",
    edge: "15",
    firefox: "53",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "transform-sticky-regex": {
    chrome: "49",
    opera: "36",
    edge: "13",
    firefox: "3",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "36",
    electron: "0.37"
  },
  "transform-unicode-escapes": {
    chrome: "44",
    opera: "31",
    edge: "12",
    firefox: "53",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "4",
    opera_mobile: "32",
    electron: "0.30"
  },
  "transform-unicode-regex": {
    chrome: "50",
    opera: "37",
    edge: "13",
    firefox: "46",
    safari: "12",
    node: "6",
    deno: "1",
    ios: "12",
    samsung: "5",
    opera_mobile: "37",
    electron: "1.1"
  },
  "transform-spread": {
    chrome: "46",
    opera: "33",
    edge: "13",
    firefox: "45",
    safari: "10",
    node: "5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "33",
    electron: "0.36"
  },
  "transform-destructuring": {
    chrome: "51",
    opera: "38",
    edge: "15",
    firefox: "53",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "transform-block-scoping": {
    chrome: "50",
    opera: "37",
    edge: "14",
    firefox: "53",
    safari: "11",
    node: "6",
    deno: "1",
    ios: "11",
    samsung: "5",
    opera_mobile: "37",
    electron: "1.1"
  },
  "transform-typeof-symbol": {
    chrome: "38",
    opera: "25",
    edge: "12",
    firefox: "36",
    safari: "9",
    node: "0.12",
    deno: "1",
    ios: "9",
    samsung: "3",
    rhino: "1.7.13",
    opera_mobile: "25",
    electron: "0.20"
  },
  "transform-new-target": {
    chrome: "46",
    opera: "33",
    edge: "14",
    firefox: "41",
    safari: "10",
    node: "5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "33",
    electron: "0.36"
  },
  "transform-regenerator": {
    chrome: "50",
    opera: "37",
    edge: "13",
    firefox: "53",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "37",
    electron: "1.1"
  },
  "transform-member-expression-literals": {
    chrome: "7",
    opera: "12",
    edge: "12",
    firefox: "2",
    safari: "5.1",
    node: "0.4",
    deno: "1",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    opera_mobile: "12",
    electron: "0.20"
  },
  "transform-property-literals": {
    chrome: "7",
    opera: "12",
    edge: "12",
    firefox: "2",
    safari: "5.1",
    node: "0.4",
    deno: "1",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    opera_mobile: "12",
    electron: "0.20"
  },
  "transform-reserved-words": {
    chrome: "13",
    opera: "10.50",
    edge: "12",
    firefox: "2",
    safari: "3.1",
    node: "0.6",
    deno: "1",
    ie: "9",
    android: "4.4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    opera_mobile: "10.1",
    electron: "0.20"
  },
  "transform-export-namespace-from": {
    chrome: "72",
    deno: "1.0",
    edge: "79",
    firefox: "80",
    node: "13.2",
    opera: "60",
    opera_mobile: "51",
    safari: "14.1",
    ios: "14.5",
    samsung: "11.0",
    android: "72",
    electron: "5.0"
  },
  "proposal-export-namespace-from": {
    chrome: "72",
    deno: "1.0",
    edge: "79",
    firefox: "80",
    node: "13.2",
    opera: "60",
    opera_mobile: "51",
    safari: "14.1",
    ios: "14.5",
    samsung: "11.0",
    android: "72",
    electron: "5.0"
  }
};

var plugins$1 = require$$0$5;

function targetsSupported(target, support) {
  const targetEnvironments = Object.keys(target);
  if (targetEnvironments.length === 0) return false;

  return targetEnvironments.filter(environment => {
    const lowestImplementedVersion = getLowestImplementedVersion(support, environment);
    if (!lowestImplementedVersion) return true;

    const lowestTargetedVersion = target[environment];
    if (isUnreleasedVersion(lowestTargetedVersion, environment)) return false;

    if (isUnreleasedVersion(lowestImplementedVersion, environment)) return true;

    if (!vendors.semver.valid(lowestTargetedVersion.toString()))
      throw new Error(
        `Invalid version passed for target "${environment}": "${lowestTargetedVersion}". Versions must be in semver format (major.minor.patch)`
      );

    return vendors.semver.gt(semverify(lowestImplementedVersion), lowestTargetedVersion.toString());
  }).length === 0;
}
function isRequired(name, targets, { compatData = plugins$1, includes, excludes } = {}) {
  return !(
    (excludes != null && excludes.has(name)) ||
    ((includes == null || !includes.has(name)) && targetsSupported(targets, compatData[name]))
  );
}
function filterItems(list, includes, excludes, targets, defaultIncludes, defaultExcludes, pluginSyntaxMap) {
  const result = new Set(),
    options = { compatData: list, includes, excludes };
  for (const item in list)
    if (isRequired(item, targets, options)) result.add(item);
    else if (pluginSyntaxMap) {
      const shippedProposalsSyntax = pluginSyntaxMap.get(item);
      shippedProposalsSyntax && result.add(shippedProposalsSyntax);
    }

  defaultIncludes == null || defaultIncludes.forEach(item => !excludes.has(item) && result.add(item));
  defaultExcludes == null || defaultExcludes.forEach(item => !includes.has(item) && result.delete(item));
  return result;
}

const ESM_SUPPORT = nativeModules["es6.module"],
  v$3 = new OptionValidator("@babel/helper-compilation-targets");
function validateTargetNames(targets) {
  const validTargets = Object.keys(TargetNames);
  for (const target of Object.keys(targets))
    if (!(target in TargetNames))
      throw new Error(
        v$3.formatMessage(`'${target}' is not a valid target
- Did you mean '${findSuggestion(target, validTargets)}'?`)
      );

  return targets;
}
function isBrowsersQueryValid(browsers) {
  return typeof browsers == "string" || (Array.isArray(browsers) && browsers.every(b => typeof b == "string"));
}
function validateBrowsers(browsers) {
  v$3.invariant(browsers === void 0 || isBrowsersQueryValid(browsers),
    `'${String(browsers)}' is not a valid browserslist query`
  );
  return browsers;
}
function getLowestVersions(browsers) {
  return browsers.reduce((all, browser) => {
    const [browserName, browserVersion] = browser.split(" "),
      target = browserNameMap[browserName];
    if (!target) return all;

    try {
      const splitVersion = browserVersion.split("-")[0].toLowerCase(),
        isSplitUnreleased = isUnreleasedVersion(splitVersion, target);
      if (!all[target]) {
        all[target] = isSplitUnreleased ? splitVersion : semverify(splitVersion);
        return all;
      }
      const version = all[target],
        isUnreleased = isUnreleasedVersion(version, target);
      if (isUnreleased && isSplitUnreleased) all[target] = getLowestUnreleased(version, splitVersion, target);
      else if (isUnreleased) all[target] = semverify(splitVersion);
      else if (!isUnreleased && !isSplitUnreleased) {
        const parsedBrowserVersion = semverify(splitVersion);
        all[target] = semverMin(version, parsedBrowserVersion);
      }
    } catch (_) {}
    return all;
  }, {});
}
function outputDecimalWarning(decimalTargets) {
  if (!decimalTargets.length) return;

  console.warn("Warning, the following targets are using a decimal version:\n");
  decimalTargets.forEach(({ target, value }) => console.warn(`  ${target}: ${value}`));
  console.warn(
    "\nWe recommend using a string for minor/patch versions to avoid numbers like 6.10\n\
getting parsed as 6.1, which can lead to unexpected behavior.\n"
  );
}
function semverifyTarget(target, value) {
  try {
    return semverify(value);
  } catch (_error) {
    throw new Error(v$3.formatMessage(`'${value}' is not a valid value for 'targets.${target}'.`));
  }
}
function nodeTargetParser(value) {
  return ["node", value === true || value === "current" ? process.versions.node : semverifyTarget("node", value)];
}
function defaultTargetParser(target, value) {
  return [target, isUnreleasedVersion(value, target) ? value.toLowerCase() : semverifyTarget(target, value)];
}
function generateTargets(inputTargets) {
  const input = Object.assign({}, inputTargets);
  delete input.esmodules;
  delete input.browsers;
  return input;
}
function resolveTargets$1(queries, env) {
  return getLowestVersions(vendors.browserslist(queries, { mobileToDesktop: true, env }));
}
const targetsCache = new lruCache({ max: 64 });
function resolveTargetsCached(queries, env) {
  const cacheKey = typeof queries == "string" ? queries : queries.join() + env;
  let cached = targetsCache.get(cacheKey);
  if (!cached) {
    cached = resolveTargets$1(queries, env);
    targetsCache.set(cacheKey, cached);
  }
  return Object.assign({}, cached);
}
function getTargets$1(inputTargets = {}, options = {}) {
  var _browsers, _browsers2;
  let { browsers, esmodules } = inputTargets;
  const { configPath = "." } = options;
  validateBrowsers(browsers);
  let targets = validateTargetNames(generateTargets(inputTargets));
  const hasTargets = !!browsers || Object.keys(targets).length > 0,
    shouldSearchForConfig = !options.ignoreBrowserslistConfig && !hasTargets;
  if (!browsers && shouldSearchForConfig) {
    browsers = vendors.browserslist.loadConfig({
      config: options.configFile,
      path: configPath,
      env: options.browserslistEnv
    });
    if (browsers == null) browsers = [];
  }
  if (esmodules && (esmodules !== "intersect" || (_browsers = browsers) == null || !_browsers.length)) {
    browsers = Object.keys(ESM_SUPPORT).map(browser => `${browser} >= ${ESM_SUPPORT[browser]}`).join(", ");
    esmodules = false;
  }
  if ((_browsers2 = browsers) != null && _browsers2.length) {
    const queryBrowsers = resolveTargetsCached(browsers, options.browserslistEnv);
    if (esmodules === "intersect")
      for (const browser of Object.keys(queryBrowsers))
        if (browser !== "deno" && browser !== "ie") {
          const esmSupportVersion = ESM_SUPPORT[browser === "opera_mobile" ? "op_mob" : browser];
          if (esmSupportVersion) {
            const version = queryBrowsers[browser];
            queryBrowsers[browser] = getHighestUnreleased(version, semverify(esmSupportVersion), browser);
          } else delete queryBrowsers[browser];
        } else delete queryBrowsers[browser];

    targets = Object.assign(queryBrowsers, targets);
  }
  const result = {},
    decimalWarnings = [];
  for (const target of Object.keys(targets).sort()) {
    const value = targets[target];
    typeof value != "number" || value % 1 == 0 || decimalWarnings.push({ target, value });

    const [parsedTarget, parsedValue] =
      target === "node" ? nodeTargetParser(value) : defaultTargetParser(target, value);
    if (parsedValue) result[parsedTarget] = parsedValue;
  }
  outputDecimalWarning(decimalWarnings);
  return result;
}

function resolveBrowserslistConfigFile(browserslistConfigFile, configFileDir) {
  return path.resolve(configFileDir, browserslistConfigFile);
}
function resolveTargets(options, root) {
  const optTargets = options.targets;
  let targets;
  if (typeof optTargets == "string" || Array.isArray(optTargets)) targets = { browsers: optTargets };
  else if (optTargets)
    targets = "esmodules" in optTargets ? Object.assign({}, optTargets, { esmodules: "intersect" }) : optTargets;

  const { browserslistConfigFile } = options;
  let configFile,
    ignoreBrowserslistConfig = false;
  typeof browserslistConfigFile == "string"
    ? (configFile = browserslistConfigFile)
    : (ignoreBrowserslistConfig = browserslistConfigFile === false);

  return getTargets$1(targets, {
    ignoreBrowserslistConfig,
    configFile,
    configPath: root,
    browserslistEnv: options.browserslistEnv
  });
}

function isEqualDescriptor(a, b) {
  var _a$file, _b$file, _a$file2, _b$file2;
  return (
    a.name === b.name && a.value === b.value && a.options === b.options &&
    a.dirname === b.dirname && a.alias === b.alias && a.ownPass === b.ownPass &&
    ((_a$file = a.file) == null ? void 0 : _a$file.request) ===
      ((_b$file = b.file) == null ? void 0 : _b$file.request) &&
    ((_a$file2 = a.file) == null ? void 0 : _a$file2.resolved) ===
      ((_b$file2 = b.file) == null ? void 0 : _b$file2.resolved)
  );
}
function* handlerOf(value) {
  return value;
}
function optionsWithResolvedBrowserslistConfigFile(options, dirname) {
  if (typeof options.browserslistConfigFile == "string")
    options.browserslistConfigFile = resolveBrowserslistConfigFile(options.browserslistConfigFile, dirname);

  return options;
}
function createCachedDescriptors(dirname, options, alias) {
  const { plugins, presets, passPerPreset } = options;
  return {
    options: optionsWithResolvedBrowserslistConfigFile(options, dirname),
    plugins: plugins ? () => createCachedPluginDescriptors(plugins, dirname)(alias) : () => handlerOf([]),
    presets: presets
      ? () => createCachedPresetDescriptors(presets, dirname)(alias)(!!passPerPreset)
      : () => handlerOf([])
  };
}
function createUncachedDescriptors(dirname, options, alias) {
  return {
    options: optionsWithResolvedBrowserslistConfigFile(options, dirname),
    plugins: once(() => createPluginDescriptors(options.plugins || [], dirname, alias)),
    presets: once(() => createPresetDescriptors(options.presets || [], dirname, alias, !!options.passPerPreset))
  };
}
const PRESET_DESCRIPTOR_CACHE = new WeakMap();
const createCachedPresetDescriptors = makeWeakCacheSync((items, cache) => {
  const dirname = cache.using(dir => dir);
  return makeStrongCacheSync(alias => makeStrongCache(function* (passPerPreset) {
    return (yield* createPresetDescriptors(items, dirname, alias, passPerPreset)).map(desc =>
      loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc)
    );
  }));
});
const PLUGIN_DESCRIPTOR_CACHE = new WeakMap();
const createCachedPluginDescriptors = makeWeakCacheSync((items, cache) => {
  const dirname = cache.using(dir => dir);
  return makeStrongCache(function* (alias) {
    return (yield* createPluginDescriptors(items, dirname, alias)).map(desc =>
      loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc)
    );
  });
});
const DEFAULT_OPTIONS = {};
function loadCachedDescriptor(cache, desc) {
  const { value, options = DEFAULT_OPTIONS } = desc;
  if (options === false) return desc;
  let cacheByOptions = cache.get(value);
  if (!cacheByOptions) {
    cacheByOptions = new WeakMap();
    cache.set(value, cacheByOptions);
  }
  let possibilities = cacheByOptions.get(options);
  if (!possibilities) {
    possibilities = [];
    cacheByOptions.set(options, possibilities);
  }
  if (possibilities.indexOf(desc) < 0) {
    const matches = possibilities.filter(possibility => isEqualDescriptor(possibility, desc));
    if (matches.length > 0) return matches[0];

    possibilities.push(desc);
  }
  return desc;
}
function* createPresetDescriptors(items, dirname, alias, passPerPreset) {
  return yield* createDescriptors("preset", items, dirname, alias, passPerPreset);
}
function* createPluginDescriptors(items, dirname, alias) {
  return yield* createDescriptors("plugin", items, dirname, alias);
}
function* createDescriptors(type, items, dirname, alias, ownPass) {
  const descriptors = yield* gensync.all(items.map((item, index) =>
    createDescriptor(item, dirname, { type, alias: `${alias}$${index}`, ownPass: !!ownPass })
  ));
  assertNoDuplicates(descriptors);
  return descriptors;
}
function* createDescriptor(pair, dirname, { type, alias, ownPass }) {
  const desc = getItemDescriptor(pair);
  if (desc) return desc;

  let name,
    options,
    value = pair;
  if (Array.isArray(value)) value.length === 3 ? ([value, options, name] = value) : ([value, options] = value);

  let file = void 0,
    filepath = null;
  if (typeof value == "string") {
    if (typeof type != "string") throw new Error("To resolve a string-based item, the type of item must be given");

    const resolver = type === "plugin" ? loadPlugin : loadPreset,
      request = value;
    ({ filepath, value } = yield* resolver(value, dirname));
    file = { request, resolved: filepath };
  }
  if (!value) throw new Error("Unexpected falsy value: " + String(value));

  if (typeof value == "object" && value.__esModule) {
    if (!value.default) throw new Error("Must export a default export when using ES6 modules.");

    value = value.default;
  }
  if (typeof value != "object" && typeof value != "function")
    throw new Error(`Unsupported format: ${typeof value}. Expected an object or a function.`);

  if (filepath !== null && typeof value == "object" && value)
    throw new Error("Plugin/Preset files are not allowed to export objects, only functions. In " + filepath);

  return { name, alias: filepath || alias, value, options, dirname, ownPass, file };
}
function assertNoDuplicates(items) {
  const map = new Map();
  for (const item of items) {
    if (typeof item.value != "function") continue;
    let nameMap = map.get(item.value);
    if (!nameMap) {
      nameMap = new Set();
      map.set(item.value, nameMap);
    }
    if (nameMap.has(item.name)) {
      const conflicts = items.filter(i => i.value === item.value);
      throw new Error([
        "Duplicate plugin/preset detected.",
        "If you'd like to use two separate instances of a plugin,",
        "they need separate names, e.g.", "",
        "  plugins: [",
        "    ['some-plugin', {}],",
        "    ['some-plugin', {}, 'some unique name'],",
        "  ]", "",
        "Duplicates detected are:",
        "" + JSON.stringify(conflicts, null, 2)
      ].join("\n"));
    }
    nameMap.add(item.name);
  }
}

function createItemFromDescriptor(desc) {
  return new ConfigItem(desc);
}
function* createConfigItem$1(value, { dirname = ".", type } = {}) {
  return createItemFromDescriptor(
    yield* createDescriptor(value, path.resolve(dirname), { type, alias: "programmatic item" })
  );
}
const CONFIG_ITEM_BRAND = Symbol.for("@babel/core@7 - ConfigItem");
function getItemDescriptor(item) {
  return item != null && item[CONFIG_ITEM_BRAND] ? item._descriptor : void 0;
}
class ConfigItem {
  constructor(descriptor) {
    this._descriptor = void 0;
    this[CONFIG_ITEM_BRAND] = true;
    this.value = void 0;
    this.options = void 0;
    this.dirname = void 0;
    this.name = void 0;
    this.file = void 0;
    this._descriptor = descriptor;
    Object.defineProperty(this, "_descriptor", { enumerable: false });
    Object.defineProperty(this, CONFIG_ITEM_BRAND, { enumerable: false });
    this.value = this._descriptor.value;
    this.options = this._descriptor.options;
    this.dirname = this._descriptor.dirname;
    this.name = this._descriptor.name;
    this.file = this._descriptor.file
      ? { request: this._descriptor.file.request, resolved: this._descriptor.file.resolved }
      : void 0;
    Object.freeze(this);
  }
}
Object.freeze(ConfigItem.prototype);

var removed = {
  auxiliaryComment: { message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`" },
  blacklist: { message: "Put the specific transforms you want in the `plugins` option" },
  breakConfig: { message: "This is not a necessary option in Babel 6" },
  experimental: { message: "Put the specific transforms you want in the `plugins` option" },
  externalHelpers: {
    message: "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/"
  },
  extra: { message: "" },
  jsxPragma: {
    message:
      "use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/"
  },
  loose: {
    message: "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option."
  },
  metadataUsedHelpers: { message: "Not required anymore as this is enabled by default" },
  modules: {
    message:
      "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules"
  },
  nonStandard: {
    message:
      "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/"
  },
  optional: { message: "Put the specific transforms you want in the `plugins` option" },
  sourceMapName: {
    message:
      "The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves."
  },
  stage: { message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets" },
  whitelist: { message: "Put the specific transforms you want in the `plugins` option" },
  resolveModuleSource: { version: 6, message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options" },
  metadata: { version: 6, message: "Generated plugin metadata is always included in the output result" },
  sourceMapTarget: {
    version: 6,
    message:
      "The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves."
  }
};

function msg(loc) {
  switch (loc.type) {
    case "root":
      return "";
    case "env":
      return `${msg(loc.parent)}.env["${loc.name}"]`;
    case "overrides":
      return `${msg(loc.parent)}.overrides[${loc.index}]`;
    case "option":
      return `${msg(loc.parent)}.${loc.name}`;
    case "access":
      return `${msg(loc.parent)}[${JSON.stringify(loc.name)}]`;
    default:
      throw new Error("Assertion failure: Unknown type " + loc.type);
  }
}
function access(loc, name) {
  return { type: "access", name, parent: loc };
}
function assertRootMode(loc, value) {
  if (value !== void 0 && value !== "root" && value !== "upward" && value !== "upward-optional")
    throw new Error(msg(loc) + ' must be a "root", "upward", "upward-optional" or undefined');

  return value;
}
function assertSourceMaps(loc, value) {
  if (value !== void 0 && typeof value != "boolean" && value !== "inline" && value !== "both")
    throw new Error(msg(loc) + ' must be a boolean, "inline", "both", or undefined');

  return value;
}
function assertCompact(loc, value) {
  if (value !== void 0 && typeof value != "boolean" && value !== "auto")
    throw new Error(msg(loc) + ' must be a boolean, "auto", or undefined');

  return value;
}
function assertSourceType(loc, value) {
  if (value !== void 0 && value !== "module" && value !== "script" && value !== "unambiguous")
    throw new Error(msg(loc) + ' must be "module", "script", "unambiguous", or undefined');

  return value;
}
function assertCallerMetadata(loc, value) {
  const obj = assertObject(loc, value);
  if (obj) {
    if (typeof obj.name != "string") throw new Error(msg(loc) + ' set but does not contain "name" property string');

    for (const prop of Object.keys(obj)) {
      const propLoc = access(loc, prop),
        value = obj[prop];
      if (value != null && typeof value != "boolean" && typeof value != "string" && typeof value != "number")
        throw new Error(msg(propLoc) + " must be null, undefined, a boolean, a string, or a number.");
    }
  }
  return value;
}
function assertInputSourceMap(loc, value) {
  if (value !== void 0 && typeof value != "boolean" && (typeof value != "object" || !value))
    throw new Error(msg(loc) + " must be a boolean, object, or undefined");

  return value;
}
function assertString(loc, value) {
  if (value !== void 0 && typeof value != "string") throw new Error(msg(loc) + " must be a string, or undefined");

  return value;
}
function assertFunction(loc, value) {
  if (value !== void 0 && typeof value != "function") throw new Error(msg(loc) + " must be a function, or undefined");

  return value;
}
function assertBoolean(loc, value) {
  if (value !== void 0 && typeof value != "boolean") throw new Error(msg(loc) + " must be a boolean, or undefined");

  return value;
}
function assertObject(loc, value) {
  if (value !== void 0 && (typeof value != "object" || Array.isArray(value) || !value))
    throw new Error(msg(loc) + " must be an object, or undefined");

  return value;
}
function assertArray(loc, value) {
  if (value != null && !Array.isArray(value)) throw new Error(msg(loc) + " must be an array, or undefined");

  return value;
}
function assertIgnoreList(loc, value) {
  const arr = assertArray(loc, value);
  arr == null || arr.forEach((item, i) => assertIgnoreItem(access(loc, i), item));
  return arr;
}
function assertIgnoreItem(loc, value) {
  if (typeof value != "string" && typeof value != "function" && !(value instanceof RegExp))
    throw new Error(msg(loc) + " must be an array of string/Function/RegExp values, or undefined");

  return value;
}
function assertConfigApplicableTest(loc, value) {
  if (value === void 0) return value;

  if (Array.isArray(value))
    value.forEach((item, i) => {
      if (!checkValidTest(item)) throw new Error(msg(access(loc, i)) + " must be a string/Function/RegExp.");
    });
  else if (!checkValidTest(value))
    throw new Error(msg(loc) + " must be a string/Function/RegExp, or an array of those");

  return value;
}
function checkValidTest(value) {
  return typeof value == "string" || typeof value == "function" || value instanceof RegExp;
}
function assertConfigFileSearch(loc, value) {
  if (value !== void 0 && typeof value != "boolean" && typeof value != "string")
    throw new Error(msg(loc) + " must be a undefined, a boolean, a string, got " + JSON.stringify(value));

  return value;
}
function assertBabelrcSearch(loc, value) {
  if (value === void 0 || typeof value == "boolean") return value;

  if (Array.isArray(value))
    value.forEach((item, i) => {
      if (!checkValidTest(item)) throw new Error(msg(access(loc, i)) + " must be a string/Function/RegExp.");
    });
  else if (!checkValidTest(value))
    throw new Error(
      msg(loc) + " must be a undefined, a boolean, a string/Function/RegExp or an array of those, got " +
        JSON.stringify(value)
    );

  return value;
}
function assertPluginList(loc, value) {
  const arr = assertArray(loc, value);
  arr && arr.forEach((item, i) => assertPluginItem(access(loc, i), item));

  return arr;
}
function assertPluginItem(loc, value) {
  if (Array.isArray(value)) {
    if (value.length === 0) throw new Error(msg(loc) + " must include an object");

    if (value.length > 3) throw new Error(msg(loc) + " may only be a two-tuple or three-tuple");

    assertPluginTarget(access(loc, 0), value[0]);
    if (value.length > 1) {
      const opts = value[1];
      if (opts !== void 0 && opts !== false && (typeof opts != "object" || Array.isArray(opts) || opts === null))
        throw new Error(msg(access(loc, 1)) + " must be an object, false, or undefined");
    }
    if (value.length === 3) {
      const name = value[2];
      if (name !== void 0 && typeof name != "string")
        throw new Error(msg(access(loc, 2)) + " must be a string, or undefined");
    }
  } else assertPluginTarget(loc, value);

  return value;
}
function assertPluginTarget(loc, value) {
  if ((typeof value != "object" || !value) && typeof value != "string" && typeof value != "function")
    throw new Error(msg(loc) + " must be a string, object, function");

  return value;
}
function assertTargets(loc, value) {
  if (isBrowsersQueryValid(value)) return value;
  if (typeof value != "object" || !value || Array.isArray(value))
    throw new Error(msg(loc) + " must be a string, an array of strings or an object");

  const browsersLoc = access(loc, "browsers"),
    esmodulesLoc = access(loc, "esmodules");
  assertBrowsersList(browsersLoc, value.browsers);
  assertBoolean(esmodulesLoc, value.esmodules);
  for (const key of Object.keys(value)) {
    const val = value[key],
      subLoc = access(loc, key);
    if (key === "esmodules") assertBoolean(subLoc, val);
    else if (key === "browsers") assertBrowsersList(subLoc, val);
    else if (!Object.hasOwnProperty.call(TargetNames, key)) {
      const validTargets = Object.keys(TargetNames).join(", ");
      throw new Error(`${msg(subLoc)} is not a valid target. Supported targets are ${validTargets}`);
    } else assertBrowserVersion(subLoc, val);
  }
  return value;
}
function assertBrowsersList(loc, value) {
  if (value !== void 0 && !isBrowsersQueryValid(value))
    throw new Error(msg(loc) + " must be undefined, a string or an array of strings");
}
function assertBrowserVersion(loc, value) {
  if ((typeof value != "number" || Math.round(value) !== value) && typeof value != "string")
    throw new Error(msg(loc) + " must be a string or an integer number");
}
function assertAssumptions(loc, value) {
  if (value === void 0) return;
  if (typeof value != "object" || value === null) throw new Error(msg(loc) + " must be an object or undefined.");

  let root = loc;
  do {
    root = root.parent;
  } while (root.type !== "root");
  const inPreset = root.source === "preset";
  for (const name of Object.keys(value)) {
    const subLoc = access(loc, name);
    if (!assumptionsNames.has(name)) throw new Error(msg(subLoc) + " is not a supported assumption.");

    if (typeof value[name] != "boolean") throw new Error(msg(subLoc) + " must be a boolean.");

    if (inPreset && value[name] === false) throw new Error(msg(subLoc) + " cannot be set to 'false' inside presets.");
  }
  return value;
}

const ROOT_VALIDATORS = {
  cwd: assertString,
  root: assertString,
  rootMode: assertRootMode,
  configFile: assertConfigFileSearch,
  caller: assertCallerMetadata,
  filename: assertString,
  filenameRelative: assertString,
  code: assertBoolean,
  ast: assertBoolean,
  cloneInputAst: assertBoolean,
  envName: assertString
};
const BABELRC_VALIDATORS = {
  babelrc: assertBoolean,
  babelrcRoots: assertBabelrcSearch
};
const NONPRESET_VALIDATORS = {
  extends: assertString,
  ignore: assertIgnoreList,
  only: assertIgnoreList,
  targets: assertTargets,
  browserslistConfigFile: assertConfigFileSearch,
  browserslistEnv: assertString
};
const COMMON_VALIDATORS = {
  inputSourceMap: assertInputSourceMap,
  presets: assertPluginList,
  plugins: assertPluginList,
  passPerPreset: assertBoolean,
  assumptions: assertAssumptions,
  env: assertEnvSet,
  overrides: assertOverridesList,
  test: assertConfigApplicableTest,
  include: assertConfigApplicableTest,
  exclude: assertConfigApplicableTest,
  retainLines: assertBoolean,
  comments: assertBoolean,
  shouldPrintComment: assertFunction,
  compact: assertCompact,
  minified: assertBoolean,
  auxiliaryCommentBefore: assertString,
  auxiliaryCommentAfter: assertString,
  sourceType: assertSourceType,
  wrapPluginVisitorMethod: assertFunction,
  highlightCode: assertBoolean,
  sourceMaps: assertSourceMaps,
  sourceMap: assertSourceMaps,
  sourceFileName: assertString,
  sourceRoot: assertString,
  parserOpts: assertObject,
  generatorOpts: assertObject
};

Object.assign(COMMON_VALIDATORS, {
  getModuleId: assertFunction,
  moduleRoot: assertString,
  moduleIds: assertBoolean,
  moduleId: assertString
});

const knownAssumptions = [
  "arrayLikeIsIterable",
  "constantReexports",
  "constantSuper",
  "enumerableModuleMeta",
  "ignoreFunctionLength",
  "ignoreToPrimitiveHint",
  "iterableIsArray",
  "mutableTemplateObject",
  "noClassCalls",
  "noDocumentAll",
  "noIncompleteNsImportDetection",
  "noNewArrows",
  "objectRestNoSymbols",
  "privateFieldsAsSymbols",
  "privateFieldsAsProperties",
  "pureGetters",
  "setClassMethods",
  "setComputedProperties",
  "setPublicClassFields",
  "setSpreadProperties",
  "skipForOfIteratorClosing",
  "superIsCallableConstructor"
];
const assumptionsNames = new Set(knownAssumptions);
function getSource(loc) {
  return loc.type === "root" ? loc.source : getSource(loc.parent);
}
function validate(type, opts, filename) {
  try {
    return validateNested({ type: "root", source: type }, opts);
  } catch (error) {
    const configError = new ConfigError(error.message, filename);
    if (error.code) configError.code = error.code;
    throw configError;
  }
}
function validateNested(loc, opts) {
  const type = getSource(loc);
  assertNoDuplicateSourcemap(opts);
  Object.keys(opts).forEach(key => {
    const optLoc = { type: "option", name: key, parent: loc };
    if (type === "preset" && NONPRESET_VALIDATORS[key])
      throw new Error(msg(optLoc) + " is not allowed in preset options");

    if (type !== "arguments" && ROOT_VALIDATORS[key])
      throw new Error(msg(optLoc) + " is only allowed in root programmatic options");

    if (type !== "arguments" && type !== "configfile" && BABELRC_VALIDATORS[key]) {
      if (type === "babelrcfile" || type === "extendsfile")
        throw new Error(
          msg(optLoc) + ' is not allowed in .babelrc or "extends"ed files, only in root programmatic options, or babel.config.js/config file options'
        );

      throw new Error(
        msg(optLoc) + " is only allowed in root programmatic options, or babel.config.js/config file options"
      );
    }
    (
      COMMON_VALIDATORS[key] || NONPRESET_VALIDATORS[key] || BABELRC_VALIDATORS[key] || ROOT_VALIDATORS[key] ||
      throwUnknownError
    )(optLoc, opts[key]);
  });
  return opts;
}
function throwUnknownError(loc) {
  const key = loc.name;
  if (removed[key]) {
    const { message, version = 5 } = removed[key];
    throw new Error(`Using removed Babel ${version} option: ${msg(loc)} - ${message}`);
  }

  const unknownOptErr = new Error(
    `Unknown option: ${msg(loc)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`
  );
  unknownOptErr.code = "BABEL_UNKNOWN_OPTION";
  throw unknownOptErr;
}
function has$4(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function assertNoDuplicateSourcemap(opts) {
  if (has$4(opts, "sourceMap") && has$4(opts, "sourceMaps"))
    throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
}
function assertEnvSet(loc, value) {
  if (loc.parent.type === "env") throw new Error(msg(loc) + " is not allowed inside of another .env block");

  const parent = loc.parent,
    obj = assertObject(loc, value);
  if (obj)
    for (const envName of Object.keys(obj)) {
      const env = assertObject(access(loc, envName), obj[envName]);
      env && validateNested({ type: "env", name: envName, parent }, env);
    }

  return obj;
}
function assertOverridesList(loc, value) {
  if (loc.parent.type === "env") throw new Error(msg(loc) + " is not allowed inside an .env block");

  if (loc.parent.type === "overrides") throw new Error(msg(loc) + " is not allowed inside an .overrides block");

  const parent = loc.parent,
    arr = assertArray(loc, value);
  if (arr)
    for (const [index, item] of arr.entries()) {
      const objLoc = access(loc, index),
        env = assertObject(objLoc, item);
      if (!env) throw new Error(msg(objLoc) + " must be an object");
      validateNested({ type: "overrides", index, parent }, env);
    }

  return arr;
}
function checkNoUnwrappedItemOptionPairs(items, index, type, e) {
  if (index === 0) return;
  const lastItem = items[index - 1],
    thisItem = items[index];
  if (lastItem.file && lastItem.options === void 0 && typeof thisItem.value == "object")
    e.message += `\n- Maybe you meant to use\n"${type}s": [
  ["${lastItem.file.request}", ${JSON.stringify(thisItem.value, void 0, 2)}]\n]
To be a valid ${type}, its name and options should be wrapped in a pair of brackets`;
}

const sep = "\\" + path.sep,
  endSep = `(?:${sep}|$)`,
  substitution = `[^${sep}]+`,
  starPat = `(?:${substitution}${sep})`,
  starPatLast = `(?:${substitution}${endSep})`,
  starStarPat = starPat + "*?",
  starStarPatLast = `${starPat}*?${starPatLast}?`;
function escapeRegExp(string) {
  return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
}
function pathToPattern(pattern, dirname) {
  const parts = path.resolve(dirname, pattern).split(path.sep);
  return new RegExp(["^", ...parts.map((part, i) => {
    const last = i === parts.length - 1;
    return part === "**"
      ? (last ? starStarPatLast : starStarPat)
      : part === "*"
      ? (last ? starPatLast : starPat)
      : part.indexOf("*.") === 0
      ? substitution + escapeRegExp(part.slice(1)) + (last ? endSep : sep)
      : escapeRegExp(part) + (last ? endSep : sep);
  })].join(""));
}

const ChainFormatter = { Programmatic: 0, Config: 1 };
const Formatter = {
  title(type, callerName, filepath) {
    let title = "";
    if (type === ChainFormatter.Programmatic) {
      title = "programmatic options";
      if (callerName) title += " from " + callerName;
    } else title = "config " + filepath;

    return title;
  },
  loc(index, envName) {
    let loc = "";
    if (index != null) loc += `.overrides[${index}]`;

    if (envName != null) loc += `.env["${envName}"]`;

    return loc;
  },
  *optionsAndDescriptors(opt) {
    const content = Object.assign({}, opt.options);
    delete content.overrides;
    delete content.env;
    const pluginDescriptors = [...(yield* opt.plugins())];
    if (pluginDescriptors.length) content.plugins = pluginDescriptors.map(d => descriptorToConfig(d));

    const presetDescriptors = [...(yield* opt.presets())];
    if (presetDescriptors.length) content.presets = [...presetDescriptors].map(d => descriptorToConfig(d));

    return JSON.stringify(content, void 0, 2);
  }
};
function descriptorToConfig(d) {
  var _d$file;
  let name = (_d$file = d.file) == null ? void 0 : _d$file.request;
  if (name == null)
    if (typeof d.value == "object") name = d.value;
    else if (typeof d.value == "function") name = `[Function: ${d.value.toString().slice(0, 50)} ... ]`;

  if (name == null) name = "[Unknown]";

  return d.options === void 0 ? name : d.name == null ? [name, d.options] : [name, d.options, d.name];
}
class ConfigPrinter {
  constructor() {
    this._stack = [];
  }
  configure(enabled, type, { callerName, filepath }) {
    return !enabled ? () => {} : (content, index, envName) => {
      this._stack.push({ type, callerName, filepath, content, index, envName });
    };
  }
  static *format(config) {
    let title = Formatter.title(config.type, config.callerName, config.filepath);
    const loc = Formatter.loc(config.index, config.envName);
    if (loc) title += " " + loc;
    return `${title}\n${yield* Formatter.optionsAndDescriptors(config.content)}`;
  }
  *output() {
    return this._stack.length === 0
      ? ""
      : (yield* gensync.all(this._stack.map(s => ConfigPrinter.format(s)))).join("\n\n");
  }
}

const debug$4 = traverse.buildDebug("babel:config:config-chain");
function* buildPresetChain(arg, context) {
  const chain = yield* buildPresetChainWalker(arg, context);
  return !chain ? null : {
    plugins: dedupDescriptors(chain.plugins),
    presets: dedupDescriptors(chain.presets),
    options: chain.options.map(o => normalizeOptions$5(o)),
    files: new Set()
  };
}
const buildPresetChainWalker = makeChainWalker({
  root: preset => loadPresetDescriptors(preset),
  env: (preset, envName) => loadPresetEnvDescriptors(preset)(envName),
  overrides: (preset, index) => loadPresetOverridesDescriptors(preset)(index),
  overridesEnv: (preset, index, envName) => loadPresetOverridesEnvDescriptors(preset)(index)(envName),
  createLogger: () => () => {}
});
const loadPresetDescriptors = makeWeakCacheSync(preset =>
  buildRootDescriptors(preset, preset.alias, createUncachedDescriptors)
);
const loadPresetEnvDescriptors = makeWeakCacheSync(preset =>
  makeStrongCacheSync(envName => buildEnvDescriptors(preset, preset.alias, createUncachedDescriptors, envName))
);
const loadPresetOverridesDescriptors = makeWeakCacheSync(preset =>
  makeStrongCacheSync(index => buildOverrideDescriptors(preset, preset.alias, createUncachedDescriptors, index))
);
const loadPresetOverridesEnvDescriptors = makeWeakCacheSync(preset =>
  makeStrongCacheSync(index => makeStrongCacheSync(envName =>
    buildOverrideEnvDescriptors(preset, preset.alias, createUncachedDescriptors, index, envName)
  ))
);
function* buildRootChain(opts, context) {
  let configReport, babelRcReport;
  const programmaticLogger = new ConfigPrinter();
  const programmaticChain = yield* loadProgrammaticChain({
    options: opts,
    dirname: context.cwd
  }, context, void 0, programmaticLogger);
  if (!programmaticChain) return null;
  const programmaticReport = yield* programmaticLogger.output();
  let configFile;
  if (typeof opts.configFile == "string")
    configFile = yield* loadConfig(opts.configFile, context.cwd, context.envName, context.caller);
  else if (opts.configFile !== false)
    configFile = yield* findRootConfig(context.root, context.envName, context.caller);

  let { babelrc, babelrcRoots } = opts,
    babelrcRootsDirectory = context.cwd;
  const configFileChain = emptyChain(),
    configFileLogger = new ConfigPrinter();
  if (configFile) {
    const validatedFile = validateConfigFile(configFile),
      result = yield* loadFileChain(validatedFile, context, void 0, configFileLogger);
    if (!result) return null;
    configReport = yield* configFileLogger.output();
    if (babelrc === void 0) babelrc = validatedFile.options.babelrc;

    if (babelrcRoots === void 0) {
      babelrcRootsDirectory = validatedFile.dirname;
      babelrcRoots = validatedFile.options.babelrcRoots;
    }
    mergeChain(configFileChain, result);
  }
  let ignoreFile, babelrcFile,
    isIgnored = false;
  const fileChain = emptyChain();
  if ((babelrc === true || babelrc === void 0) && typeof context.filename == "string") {
    const pkgData = yield* findPackageData(context.filename);
    if (pkgData && babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory)) {
      ({ ignore: ignoreFile, config: babelrcFile } = yield* findRelativeConfig(pkgData, context.envName, context.caller));
      ignoreFile && fileChain.files.add(ignoreFile.filepath);

      if (ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname)) isIgnored = true;

      if (babelrcFile && !isIgnored) {
        const validatedFile = validateBabelrcFile(babelrcFile),
          babelrcLogger = new ConfigPrinter(),
          result = yield* loadFileChain(validatedFile, context, void 0, babelrcLogger);
        if (result) {
          babelRcReport = yield* babelrcLogger.output();
          mergeChain(fileChain, result);
        } else isIgnored = true;
      }
      babelrcFile && isIgnored && fileChain.files.add(babelrcFile.filepath);
    }
  }
  context.showConfig &&
    console.log(
      `Babel configs on "${context.filename}" (ascending priority):\n` +
        [configReport, babelRcReport, programmaticReport].filter(x => !!x).join("\n\n") +
        "\n-----End Babel configs-----"
    );

  const chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);
  return {
    plugins: isIgnored ? [] : dedupDescriptors(chain.plugins),
    presets: isIgnored ? [] : dedupDescriptors(chain.presets),
    options: isIgnored ? [] : chain.options.map(o => normalizeOptions$5(o)),
    fileHandling: isIgnored ? "ignored" : "transpile",
    ignore: ignoreFile || void 0,
    babelrc: babelrcFile || void 0,
    config: configFile || void 0,
    files: chain.files
  };
}
function babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory) {
  if (typeof babelrcRoots == "boolean") return babelrcRoots;
  const absoluteRoot = context.root;
  if (babelrcRoots === void 0) return pkgData.directories.indexOf(absoluteRoot) > -1;

  let babelrcPatterns = babelrcRoots;
  Array.isArray(babelrcPatterns) || (babelrcPatterns = [babelrcPatterns]);

  babelrcPatterns = babelrcPatterns.map(pat =>
    typeof pat == "string" ? path.resolve(babelrcRootsDirectory, pat) : pat
  );
  return babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot
    ? pkgData.directories.indexOf(absoluteRoot) > -1
    : babelrcPatterns.some(pat => {
        if (typeof pat == "string") pat = pathToPattern(pat, babelrcRootsDirectory);

        return pkgData.directories.some(directory => matchPattern(pat, babelrcRootsDirectory, directory, context));
      });
}
const validateConfigFile = makeWeakCacheSync(file => ({
  filepath: file.filepath,
  dirname: file.dirname,
  options: validate("configfile", file.options, file.filepath)
}));
const validateBabelrcFile = makeWeakCacheSync(file => ({
  filepath: file.filepath,
  dirname: file.dirname,
  options: validate("babelrcfile", file.options, file.filepath)
}));
const validateExtendFile = makeWeakCacheSync(file => ({
  filepath: file.filepath,
  dirname: file.dirname,
  options: validate("extendsfile", file.options, file.filepath)
}));
const loadProgrammaticChain = makeChainWalker({
  root: input => buildRootDescriptors(input, "base", createCachedDescriptors),
  env: (input, envName) => buildEnvDescriptors(input, "base", createCachedDescriptors, envName),
  overrides: (input, index) => buildOverrideDescriptors(input, "base", createCachedDescriptors, index),
  overridesEnv: (input, index, envName) =>
    buildOverrideEnvDescriptors(input, "base", createCachedDescriptors, index, envName),
  createLogger: (input, context, baseLogger) => buildProgrammaticLogger(input, context, baseLogger)
});
const loadFileChainWalker = makeChainWalker({
  root: file => loadFileDescriptors(file),
  env: (file, envName) => loadFileEnvDescriptors(file)(envName),
  overrides: (file, index) => loadFileOverridesDescriptors(file)(index),
  overridesEnv: (file, index, envName) => loadFileOverridesEnvDescriptors(file)(index)(envName),
  createLogger: (file, context, baseLogger) => buildFileLogger(file.filepath, context, baseLogger)
});
function* loadFileChain(input, context, files, baseLogger) {
  const chain = yield* loadFileChainWalker(input, context, files, baseLogger);
  chain == null || chain.files.add(input.filepath);
  return chain;
}
const loadFileDescriptors = makeWeakCacheSync(file =>
  buildRootDescriptors(file, file.filepath, createUncachedDescriptors)
);
const loadFileEnvDescriptors = makeWeakCacheSync(file =>
  makeStrongCacheSync(envName => buildEnvDescriptors(file, file.filepath, createUncachedDescriptors, envName))
);
const loadFileOverridesDescriptors = makeWeakCacheSync(file =>
  makeStrongCacheSync(index => buildOverrideDescriptors(file, file.filepath, createUncachedDescriptors, index))
);
const loadFileOverridesEnvDescriptors = makeWeakCacheSync(file =>
  makeStrongCacheSync(index => makeStrongCacheSync(envName =>
    buildOverrideEnvDescriptors(file, file.filepath, createUncachedDescriptors, index, envName)
  ))
);
function buildFileLogger(filepath, context, baseLogger) {
  return baseLogger ? baseLogger.configure(context.showConfig, ChainFormatter.Config, { filepath }) : () => {};
}
function buildRootDescriptors({ dirname, options }, alias, descriptors) {
  return descriptors(dirname, options, alias);
}
function buildProgrammaticLogger(_, context, baseLogger) {
  var _context$caller;
  return baseLogger
    ? baseLogger.configure(context.showConfig, ChainFormatter.Programmatic, {
        callerName: (_context$caller = context.caller) == null ? void 0 : _context$caller.name
      })
    : () => {};
}
function buildEnvDescriptors({ dirname, options }, alias, descriptors, envName) {
  var _options$env;
  const opts = (_options$env = options.env) == null ? void 0 : _options$env[envName];
  return opts ? descriptors(dirname, opts, `${alias}.env["${envName}"]`) : null;
}
function buildOverrideDescriptors({ dirname, options }, alias, descriptors, index) {
  var _options$overrides;
  const opts = (_options$overrides = options.overrides) == null ? void 0 : _options$overrides[index];
  if (!opts) throw new Error("Assertion failure - missing override");
  return descriptors(dirname, opts, `${alias}.overrides[${index}]`);
}
function buildOverrideEnvDescriptors({ dirname, options }, alias, descriptors, index, envName) {
  var _options$overrides2, _override$env;
  const override = (_options$overrides2 = options.overrides) == null ? void 0 : _options$overrides2[index];
  if (!override) throw new Error("Assertion failure - missing override");
  const opts = (_override$env = override.env) == null ? void 0 : _override$env[envName];
  return opts ? descriptors(dirname, opts, `${alias}.overrides[${index}].env["${envName}"]`) : null;
}
function makeChainWalker({ root, env, overrides, overridesEnv, createLogger }) {
  return function* (input, context, files = new Set(), baseLogger) {
    const { dirname } = input,
      flattenedConfigs = [],
      rootOpts = root(input);
    if (configIsApplicable(rootOpts, dirname, context, input.filepath)) {
      flattenedConfigs.push({ config: rootOpts, envName: void 0, index: void 0 });
      const envOpts = env(input, context.envName);
      envOpts && configIsApplicable(envOpts, dirname, context, input.filepath) &&
        flattenedConfigs.push({ config: envOpts, envName: context.envName, index: void 0 });

      (rootOpts.options.overrides || []).forEach((_, index) => {
        const overrideOps = overrides(input, index);
        if (configIsApplicable(overrideOps, dirname, context, input.filepath)) {
          flattenedConfigs.push({ config: overrideOps, index, envName: void 0 });
          const overrideEnvOpts = overridesEnv(input, index, context.envName);
          overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname, context, input.filepath) &&
            flattenedConfigs.push({ config: overrideEnvOpts, index, envName: context.envName });
        }
      });
    }
    if (flattenedConfigs.some(
      ({
        config: {
          options: { ignore, only }
        }
      }) => shouldIgnore(context, ignore, only, dirname)
    ))
      return null;

    const chain = emptyChain(),
      logger = createLogger(input, context, baseLogger);
    for (const { config, index, envName } of flattenedConfigs) {
      if (!(yield* mergeExtendsChain(chain, config.options, dirname, context, files, baseLogger))) return null;

      logger(config, index, envName);
      yield* mergeChainOpts(chain, config);
    }
    return chain;
  };
}
function* mergeExtendsChain(chain, opts, dirname, context, files, baseLogger) {
  if (opts.extends === void 0) return true;
  const file = yield* loadConfig(opts.extends, dirname, context.envName, context.caller);
  if (files.has(file))
    throw new Error(
      `Configuration cycle detected loading ${file.filepath}.\nFile already loaded following the config chain:\n` +
        Array.from(files, file => " - " + file.filepath).join("\n")
    );

  files.add(file);
  const fileChain = yield* loadFileChain(validateExtendFile(file), context, files, baseLogger);
  files.delete(file);
  if (!fileChain) return false;
  mergeChain(chain, fileChain);
  return true;
}
function mergeChain(target, source) {
  target.options.push(...source.options);
  target.plugins.push(...source.plugins);
  target.presets.push(...source.presets);
  for (const file of source.files) target.files.add(file);

  return target;
}
function* mergeChainOpts(target, { options, plugins, presets }) {
  target.options.push(options);
  target.plugins.push(...(yield* plugins()));
  target.presets.push(...(yield* presets()));
  return target;
}
function emptyChain() {
  return { options: [], presets: [], plugins: [], files: new Set() };
}
function normalizeOptions$5(opts) {
  const options = Object.assign({}, opts);
  delete options.extends;
  delete options.env;
  delete options.overrides;
  delete options.plugins;
  delete options.presets;
  delete options.passPerPreset;
  delete options.ignore;
  delete options.only;
  delete options.test;
  delete options.include;
  delete options.exclude;
  if (Object.prototype.hasOwnProperty.call(options, "sourceMap")) {
    options.sourceMaps = options.sourceMap;
    delete options.sourceMap;
  }
  return options;
}
function dedupDescriptors(items) {
  const map = new Map(),
    descriptors = [];
  for (const item of items)
    if (typeof item.value == "function") {
      const fnKey = item.value;
      let nameMap = map.get(fnKey);
      if (!nameMap) {
        nameMap = new Map();
        map.set(fnKey, nameMap);
      }
      let desc = nameMap.get(item.name);
      if (desc) desc.value = item;
      else {
        desc = { value: item };
        descriptors.push(desc);
        item.ownPass || nameMap.set(item.name, desc);
      }
    } else descriptors.push({ value: item });

  return descriptors.reduce((acc, desc) => {
    acc.push(desc.value);
    return acc;
  }, []);
}
function configIsApplicable({ options }, dirname, context, configName) {
  return (
    (options.test === void 0 || configFieldIsApplicable(context, options.test, dirname, configName)) &&
    (options.include === void 0 || configFieldIsApplicable(context, options.include, dirname, configName)) &&
    (options.exclude === void 0 || !configFieldIsApplicable(context, options.exclude, dirname, configName))
  );
}
function configFieldIsApplicable(context, test, dirname, configName) {
  return matchesPatterns(context, Array.isArray(test) ? test : [test], dirname, configName);
}
function ignoreListReplacer(_key, value) {
  return value instanceof RegExp ? String(value) : value;
}
function shouldIgnore(context, ignore, only, dirname) {
  if (ignore && matchesPatterns(context, ignore, dirname)) {
    var _context$filename;
    const message = `No config is applied to "${
      (_context$filename = context.filename) != null ? _context$filename : "(unknown)"
    }" because it matches one of \`ignore: ${JSON.stringify(ignore, ignoreListReplacer)}\` from "${dirname}"`;
    debug$4(message);
    context.showConfig && console.log(message);

    return true;
  }
  if (only && !matchesPatterns(context, only, dirname)) {
    var _context$filename2;
    const message = `No config is applied to "${
      (_context$filename2 = context.filename) != null ? _context$filename2 : "(unknown)"
    }" because it fails to match one of \`only: ${JSON.stringify(only, ignoreListReplacer)}\` from "${dirname}"`;
    debug$4(message);
    context.showConfig && console.log(message);

    return true;
  }
  return false;
}
function matchesPatterns(context, patterns, dirname, configName) {
  return patterns.some(pattern => matchPattern(pattern, dirname, context.filename, context, configName));
}
function matchPattern(pattern, dirname, pathToTest, context, configName) {
  if (typeof pattern == "function")
    return !!endHiddenCallStack(pattern)(pathToTest, { dirname, envName: context.envName, caller: context.caller });

  if (typeof pathToTest != "string")
    throw new ConfigError(
      "Configuration contains string/RegExp pattern, but no filename was passed to Babel", configName
    );

  if (typeof pattern == "string") pattern = pathToPattern(pattern, dirname);

  return pattern.test(pathToTest);
}

const VALIDATORS = {
  name: assertString,
  manipulateOptions: assertFunction,
  pre: assertFunction,
  post: assertFunction,
  inherits: assertFunction,
  visitor: assertVisitorMap,
  parserOverride: assertFunction,
  generatorOverride: assertFunction
};
function assertVisitorMap(loc, value) {
  const obj = assertObject(loc, value);
  if (obj) {
    Object.keys(obj).forEach(prop => {
      prop === "_exploded" || prop === "_verified" || assertVisitorHandler(prop, obj[prop]);
    });
    if (obj.enter || obj.exit)
      throw new Error(
        msg(loc) + ' cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.'
      );
  }
  return obj;
}
function assertVisitorHandler(key, value) {
  if (value && typeof value == "object")
    Object.keys(value).forEach(handler => {
      if (handler !== "enter" && handler !== "exit")
        throw new Error(`.visitor["${key}"] may only have .enter and/or .exit handlers.`);
    });
  else if (typeof value != "function") throw new Error(`.visitor["${key}"] must be a function`);
}
function validatePluginObject(obj) {
  const rootPath = { type: "root", source: "plugin" };
  Object.keys(obj).forEach(key => {
    const validator = VALIDATORS[key];
    if (!validator) {
      const invalidPluginPropertyError = new Error(`.${key} is not a valid Plugin property`);
      invalidPluginPropertyError.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY";
      throw invalidPluginPropertyError;
    }

    validator({ type: "option", name: key, parent: rootPath }, obj[key]);
  });
  return obj;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  return source == null ? {} : Object.keys(source).reduce(function (target, key) {
    if (excluded.indexOf(key) < 0) target[key] = source[key];
    return target;
  }, {});
}

function getEnv(defaultValue = "development") {
  return process.env.BABEL_ENV || "production"; // || defaultValue
}

function resolveRootMode(rootDir, rootMode) {
  switch (rootMode) {
    case "root":
      return rootDir;
    case "upward-optional": {
      const upwardRootDir = findConfigUpwards(rootDir);
      return upwardRootDir === null ? rootDir : upwardRootDir;
    }
    case "upward": {
      const upwardRootDir = findConfigUpwards(rootDir);
      if (upwardRootDir !== null) return upwardRootDir;
      throw Object.assign(
        new Error(
          `Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${rootDir}".
One of the following config files must be in the directory tree: "${ROOT_CONFIG_FILENAMES.join(", ")}".`
        ),
        { code: "BABEL_ROOT_NOT_FOUND", dirname: rootDir }
      );
    }
    default:
      throw new Error("Assertion failure - unknown rootMode value.");
  }
}
function* loadPrivatePartialConfig(inputOpts) {
  if (inputOpts != null && (typeof inputOpts != "object" || Array.isArray(inputOpts)))
    throw new Error("Babel options must be an object, null, or undefined");

  const args = inputOpts ? validate("arguments", inputOpts) : {},
    { envName = getEnv(), cwd = ".", root: rootDir = ".", rootMode = "root", caller, cloneInputAst = true } = args,
    absoluteCwd = path.resolve(cwd),
    absoluteRootDir = resolveRootMode(path.resolve(absoluteCwd, rootDir), rootMode),
    filename = typeof args.filename == "string" ? path.resolve(cwd, args.filename) : void 0;
  const context = {
    filename,
    cwd: absoluteCwd,
    root: absoluteRootDir,
    envName,
    caller,
    showConfig: (yield* resolveShowConfigPath(absoluteCwd)) === filename
  };
  const configChain = yield* buildRootChain(args, context);
  if (!configChain) return null;
  const merged = { assumptions: {} };
  configChain.options.forEach(opts => {
    mergeOptions(merged, opts);
  });
  const options = Object.assign({}, merged, {
    targets: resolveTargets(merged, absoluteRootDir),
    cloneInputAst,
    babelrc: false,
    configFile: false,
    browserslistConfigFile: false,
    passPerPreset: false,
    envName: context.envName,
    cwd: context.cwd,
    root: context.root,
    rootMode: "root",
    filename: typeof context.filename == "string" ? context.filename : void 0,
    plugins: configChain.plugins.map(descriptor => createItemFromDescriptor(descriptor)),
    presets: configChain.presets.map(descriptor => createItemFromDescriptor(descriptor))
  });
  return {
    options,
    context,
    fileHandling: configChain.fileHandling,
    ignore: configChain.ignore,
    babelrc: configChain.babelrc,
    config: configChain.config,
    files: configChain.files
  };
}
function* loadPartialConfig$1(opts) {
  let showIgnoredFiles = false;
  if (typeof opts == "object" && opts !== null && !Array.isArray(opts)) {
    var _opts = opts;
    ({ showIgnoredFiles } = _opts);
    opts = _objectWithoutPropertiesLoose(_opts, ["showIgnoredFiles"]);
  }
  const result = yield* loadPrivatePartialConfig(opts);
  if (!result) return null;
  const { options, babelrc, ignore, config, fileHandling, files } = result;
  if (fileHandling === "ignored" && !showIgnoredFiles) return null;

  (options.plugins || []).forEach(item => {
    if (item.value instanceof Plugin)
      throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()");
  });
  return new PartialConfig(
    options,
    babelrc ? babelrc.filepath : void 0,
    ignore ? ignore.filepath : void 0,
    config ? config.filepath : void 0,
    fileHandling,
    files
  );
}
class PartialConfig {
  constructor(options, babelrc, ignore, config, fileHandling, files) {
    this.options = void 0;
    this.babelrc = void 0;
    this.babelignore = void 0;
    this.config = void 0;
    this.fileHandling = void 0;
    this.files = void 0;
    this.options = options;
    this.babelignore = ignore;
    this.babelrc = babelrc;
    this.config = config;
    this.fileHandling = fileHandling;
    this.files = files;
    Object.freeze(this);
  }
  hasFilesystemConfig() {
    return this.babelrc !== void 0 || this.config !== void 0;
  }
}
Object.freeze(PartialConfig.prototype);

var loadConfig$1 = gensync(function* (inputOpts) {
  var _opts$assumptions;
  const result = yield* loadPrivatePartialConfig(inputOpts);
  if (!result) return null;

  const { options, context, fileHandling } = result;
  if (fileHandling === "ignored") return null;

  const optionDefaults = {},
    { plugins, presets } = options;
  if (!plugins || !presets) throw new Error("Assertion failure - plugins and presets exist");

  const presetContext = Object.assign({}, context, { targets: options.targets });
  const toDescriptor = item => {
    const desc = getItemDescriptor(item);
    if (!desc) throw new Error("Assertion failure - must be config item");

    return desc;
  };
  const presetsDescriptors = presets.map(toDescriptor),
    initialPluginsDescriptors = plugins.map(toDescriptor),
    pluginDescriptorsByPass = [[]],
    passes = [],
    externalDependencies = [];
  const ignored = yield* enhanceError(context, function* recursePresetDescriptors(rawPresets, pluginDescriptorsPass) {
    const presets = [];
    for (let i = 0; i < rawPresets.length; i++) {
      const descriptor = rawPresets[i];
      if (descriptor.options !== false) {
        try {
          var preset = yield* loadPresetDescriptor(descriptor, presetContext);
        } catch (e) {
          e.code !== "BABEL_UNKNOWN_OPTION" || checkNoUnwrappedItemOptionPairs(rawPresets, i, "preset", e);

          throw e;
        }
        externalDependencies.push(preset.externalDependencies);
        descriptor.ownPass
          ? presets.push({ preset: preset.chain, pass: [] })
          : presets.unshift({ preset: preset.chain, pass: pluginDescriptorsPass });
      }
    }
    if (presets.length > 0) {
      pluginDescriptorsByPass.splice(1, 0, ...presets.map(o => o.pass).filter(p => p !== pluginDescriptorsPass));
      for (const { preset, pass } of presets) {
        if (!preset) return true;
        pass.push(...preset.plugins);
        if (yield* recursePresetDescriptors(preset.presets, pass)) return true;
        preset.options.forEach(opts => {
          mergeOptions(optionDefaults, opts);
        });
      }
    }
  })(presetsDescriptors, pluginDescriptorsByPass[0]);
  if (ignored) return null;
  const opts = optionDefaults;
  mergeOptions(opts, options);
  const pluginContext = Object.assign({}, presetContext, {
    assumptions: (_opts$assumptions = opts.assumptions) != null ? _opts$assumptions : {}
  });
  yield* enhanceError(context, function* () {
    pluginDescriptorsByPass[0].unshift(...initialPluginsDescriptors);
    for (const descs of pluginDescriptorsByPass) {
      const pass = [];
      passes.push(pass);
      for (let i = 0; i < descs.length; i++) {
        const descriptor = descs[i];
        if (descriptor.options !== false) {
          try {
            var plugin = yield* loadPluginDescriptor(descriptor, pluginContext);
          } catch (e) {
            e.code !== "BABEL_UNKNOWN_PLUGIN_PROPERTY" || checkNoUnwrappedItemOptionPairs(descs, i, "plugin", e);

            throw e;
          }
          pass.push(plugin);
          externalDependencies.push(plugin.externalDependencies);
        }
      }
    }
  })();
  opts.plugins = passes[0];
  opts.presets = passes.slice(1).filter(plugins => plugins.length > 0).map(plugins => ({ plugins }));
  opts.passPerPreset = opts.presets.length > 0;
  return { options: opts, passes, externalDependencies: finalize(externalDependencies) };
});
function enhanceError(context, fn) {
  return function* (arg1, arg2) {
    try {
      return yield* fn(arg1, arg2);
    } catch (e) {
      if (!/^\[BABEL\]/.test(e.message)) {
        var _context$filename = context.filename;
        e.message = `[BABEL] ${_context$filename != null ? _context$filename : "unknown file"}: ${e.message}`;
      }
      throw e;
    }
  };
}
const makeDescriptorLoader = apiFactory => makeWeakCache(function* ({ value, options, dirname, alias }, cache) {
  if (options === false) throw new Error("Assertion failure");
  options = options || {};
  const externalDependencies = [];
  let item = value;
  if (typeof value == "function") {
    const factory = maybeAsync(value,
      "You appear to be using an async plugin/preset, but Babel has been called synchronously"
    );
    const api = Object.assign({}, _babel, apiFactory(cache, externalDependencies));
    try {
      item = yield* factory(api, options, dirname);
    } catch (e) {
      if (alias) e.message += ` (While processing: ${JSON.stringify(alias)})`;

      throw e;
    }
  }
  if (!item || typeof item != "object") throw new Error("Plugin/Preset did not return an object.");

  if (isThenable$1(item)) {
    yield* [];
    throw new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. \
If you're using a published plugin, you may need to upgrade your @babel/core version. \
As an alternative, you can prefix the promise with "await". (While processing: ${JSON.stringify(alias)})`);
  }
  if (externalDependencies.length > 0 && (!cache.configured() || cache.mode() === "forever")) {
    let error = `A plugin/preset has external untracked dependencies (${externalDependencies[0]}), but the cache `;
    cache.configured()
      ? (error += " has been configured to never be invalidated. ")
      : (error += "has not been configured to be invalidated when the external dependencies change. ");

    error += `Plugins/presets should configure their cache to be invalidated when the external dependencies change, \
for example using \`api.cache.invalidate(() => statSync(filepath).mtimeMs)\` or \`api.cache.never()\`
(While processing: ${JSON.stringify(alias)})`;
    throw new Error(error);
  }
  return { value: item, options, dirname, alias, externalDependencies: finalize(externalDependencies) };
});
const pluginDescriptorLoader = makeDescriptorLoader(makePluginAPI),
  presetDescriptorLoader = makeDescriptorLoader(makePresetAPI);
const instantiatePlugin = makeWeakCache(function* ({ value, options, dirname, alias, externalDependencies }, cache) {
  const pluginObj = validatePluginObject(value),
    plugin = Object.assign({}, pluginObj);
  if (plugin.visitor) plugin.visitor = traverse.default.explode(Object.assign({}, plugin.visitor));

  if (plugin.inherits) {
    const inheritsDescriptor = { name: void 0, alias: alias + "$inherits", value: plugin.inherits, options, dirname };
    const inherits = yield* forwardAsync(loadPluginDescriptor, run =>
      cache.invalidate(data => run(inheritsDescriptor, data))
    );
    plugin.pre = chain(inherits.pre, plugin.pre);
    plugin.post = chain(inherits.post, plugin.post);
    plugin.manipulateOptions = chain(inherits.manipulateOptions, plugin.manipulateOptions);
    plugin.visitor = traverse.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]);
    if (inherits.externalDependencies.length > 0)
      externalDependencies = externalDependencies.length === 0
        ? inherits.externalDependencies
        : finalize([externalDependencies, inherits.externalDependencies]);
  }
  return new Plugin(plugin, options, alias, externalDependencies);
});
function* loadPluginDescriptor(descriptor, context) {
  if (descriptor.value instanceof Plugin) {
    if (descriptor.options) throw new Error("Passed options to an existing Plugin instance will not work.");

    return descriptor.value;
  }
  return yield* instantiatePlugin(yield* pluginDescriptorLoader(descriptor, context), context);
}
const needsFilename = val => val && typeof val != "function";
const validateIfOptionNeedsFilename = (options, descriptor) => {
  if (needsFilename(options.test) || needsFilename(options.include) || needsFilename(options.exclude)) {
    const formattedPresetName = descriptor.name ? `"${descriptor.name}"` : "/* your preset */";
    throw new ConfigError([
      `Preset ${formattedPresetName} requires a filename to be set when babel is called directly,`,
      "```",
      `babel.transformSync(code, { filename: 'file.ts', presets: [${formattedPresetName}] });`,
      "```",
      "See https://babeljs.io/docs/en/options#filename for more information."
    ].join("\n"));
  }
};
const validatePreset = (preset, context, descriptor) => {
  if (!context.filename) {
    var _options$overrides;
    const { options } = preset;
    validateIfOptionNeedsFilename(options, descriptor);
    (_options$overrides = options.overrides) == null ||
      _options$overrides.forEach(overrideOptions => validateIfOptionNeedsFilename(overrideOptions, descriptor));
  }
};
const instantiatePreset = makeWeakCacheSync(({ value, dirname, alias, externalDependencies }) => ({
  options: validate("preset", value),
  alias,
  dirname,
  externalDependencies
}));
function* loadPresetDescriptor(descriptor, context) {
  const preset = instantiatePreset(yield* presetDescriptorLoader(descriptor, context));
  validatePreset(preset, context, descriptor);
  return { chain: yield* buildPresetChain(preset, context), externalDependencies: preset.externalDependencies };
}
function chain(a, b) {
  const fns = [a, b].filter(Boolean);
  return fns.length <= 1 ? fns[0] : function (...args) {
    for (const fn of fns) fn.apply(this, args);
  };
}

const loadPartialConfigRunner = gensync(loadPartialConfig$1);
function loadPartialConfigAsync(...args) {
  return beginHiddenCallStack(loadPartialConfigRunner.async)(...args);
}
function loadPartialConfigSync(...args) {
  return beginHiddenCallStack(loadPartialConfigRunner.sync)(...args);
}
function loadPartialConfig(opts, callback) {
  if (callback !== void 0) beginHiddenCallStack(loadPartialConfigRunner.errback)(opts, callback);
  else if (typeof opts == "function") beginHiddenCallStack(loadPartialConfigRunner.errback)(void 0, opts);
  else return loadPartialConfigSync(opts);
}
function* loadOptionsImpl(opts) {
  var _config$options;
  const config = yield* loadConfig$1(opts);
  return (_config$options = config == null ? void 0 : config.options) != null ? _config$options : null;
}
const loadOptionsRunner = gensync(loadOptionsImpl);
function loadOptionsAsync(...args) {
  return beginHiddenCallStack(loadOptionsRunner.async)(...args);
}
function loadOptionsSync(...args) {
  return beginHiddenCallStack(loadOptionsRunner.sync)(...args);
}
function loadOptions(opts, callback) {
  if (callback !== void 0) beginHiddenCallStack(loadOptionsRunner.errback)(opts, callback);
  else if (typeof opts == "function") beginHiddenCallStack(loadOptionsRunner.errback)(void 0, opts);
  else return loadOptionsSync(opts);
}
const createConfigItemRunner = gensync(createConfigItem$1);
function createConfigItemAsync(...args) {
  return beginHiddenCallStack(createConfigItemRunner.async)(...args);
}
function createConfigItemSync(...args) {
  return beginHiddenCallStack(createConfigItemRunner.sync)(...args);
}
function createConfigItem(target, options, callback) {
  if (callback !== void 0) beginHiddenCallStack(createConfigItemRunner.errback)(target, options, callback);
  else if (typeof options != "function") return createConfigItemSync(target, options);
  else beginHiddenCallStack(createConfigItemRunner.errback)(target, void 0, callback);
}

class PluginPass {
  constructor(file, key, options) {
    this._map = new Map();
    this.key = void 0;
    this.file = void 0;
    this.opts = void 0;
    this.cwd = void 0;
    this.filename = void 0;
    this.key = key;
    this.file = file;
    this.opts = options || {};
    this.cwd = file.opts.cwd;
    this.filename = file.opts.filename;
  }
  set(key, val) {
    this._map.set(key, val);
  }
  get(key) {
    return this._map.get(key);
  }
  availableHelper(name, versionRange) {
    return this.file.availableHelper(name, versionRange);
  }
  addHelper(name) {
    return this.file.addHelper(name);
  }
  buildCodeFrameError(node, msg, _Error) {
    return this.file.buildCodeFrameError(node, msg, _Error);
  }
}

PluginPass.prototype.getModuleName = function () {
  return this.file.getModuleName();
};
PluginPass.prototype.addImport = function () {
  this.file.addImport();
};

let LOADED_PLUGIN;
const blockHoistPlugin = {
  name: "internal.blockHoist",
  visitor: {
    Block: {
      exit({ node }) {
        const { body } = node;
        let max = Math.pow(2, 30) - 1,
          hasChange = false;
        for (let i = 0; i < body.length; i++) {
          const p = priority(body[i]);
          if (p > max) {
            hasChange = true;
            break;
          }
          max = p;
        }
        if (hasChange) node.body = stableSort(body.slice());
      }
    }
  }
};
function loadBlockHoistPlugin() {
  LOADED_PLUGIN ||
    (LOADED_PLUGIN = new Plugin(Object.assign({}, blockHoistPlugin, {
      visitor: traverse.default.explode(blockHoistPlugin.visitor)
    }), {}));

  return LOADED_PLUGIN;
}
function priority(bodyNode) {
  const priority = bodyNode == null ? void 0 : bodyNode._blockHoist;
  return priority == null ? 1 : priority === true ? 2 : priority;
}
function stableSort(body) {
  const buckets = Object.create(null);
  for (let i = 0; i < body.length; i++) {
    const n = body[i],
      p = priority(n);
    (buckets[p] || (buckets[p] = [])).push(n);
  }
  const keys = Object.keys(buckets).map(k => +k).sort((a, b) => b - a);
  let index = 0;
  for (const key of keys) {
    const bucket = buckets[key];
    for (const n of bucket) body[index++] = n;
  }
  return body;
}

function normalizeOptions$4(config) {
  const {
    filename,
    cwd,
    filenameRelative = typeof filename == "string" ? path.relative(cwd, filename) : "unknown",
    sourceType = "module",
    inputSourceMap,
    sourceMaps = !!inputSourceMap,
    sourceRoot = config.options.moduleRoot,
    sourceFileName = path.basename(filenameRelative),
    comments = true,
    compact = "auto"
  } = config.options;
  const opts = config.options;
  const options = Object.assign({}, opts, {
    parserOpts: Object.assign({
      sourceType: path.extname(filenameRelative) === ".mjs" ? "module" : sourceType,
      sourceFileName: filename,
      plugins: []
    }, opts.parserOpts),
    generatorOpts: Object.assign({
      filename,
      auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
      auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
      retainLines: opts.retainLines,
      comments,
      shouldPrintComment: opts.shouldPrintComment,
      compact,
      minified: opts.minified,
      sourceMaps,
      sourceRoot,
      sourceFileName
    }, opts.generatorOpts)
  });
  for (const plugins of config.passes)
    for (const plugin of plugins) plugin.manipulateOptions && plugin.manipulateOptions(options, options.parserOpts);

  return options;
}

const pluginNameMap = {
  asyncDoExpressions: {
    syntax: {
      name: "@babel/plugin-syntax-async-do-expressions",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions"
    }
  },
  decimal: {
    syntax: {
      name: "@babel/plugin-syntax-decimal",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal"
    }
  },
  decorators: {
    syntax: {
      name: "@babel/plugin-syntax-decorators",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators"
    },
    transform: {
      name: "@babel/plugin-proposal-decorators",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators"
    }
  },
  doExpressions: {
    syntax: {
      name: "@babel/plugin-syntax-do-expressions",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions"
    },
    transform: {
      name: "@babel/plugin-proposal-do-expressions",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions"
    }
  },
  exportDefaultFrom: {
    syntax: {
      name: "@babel/plugin-syntax-export-default-from",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from"
    },
    transform: {
      name: "@babel/plugin-proposal-export-default-from",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from"
    }
  },
  flow: {
    syntax: {
      name: "@babel/plugin-syntax-flow",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow"
    },
    transform: {
      name: "@babel/preset-flow",
      url: "https://github.com/babel/babel/tree/main/packages/babel-preset-flow"
    }
  },
  functionBind: {
    syntax: {
      name: "@babel/plugin-syntax-function-bind",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind"
    },
    transform: {
      name: "@babel/plugin-proposal-function-bind",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind"
    }
  },
  functionSent: {
    syntax: {
      name: "@babel/plugin-syntax-function-sent",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent"
    },
    transform: {
      name: "@babel/plugin-proposal-function-sent",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent"
    }
  },
  jsx: {
    syntax: {
      name: "@babel/plugin-syntax-jsx",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx"
    },
    transform: {
      name: "@babel/preset-react",
      url: "https://github.com/babel/babel/tree/main/packages/babel-preset-react"
    }
  },
  importAttributes: {
    syntax: {
      name: "@babel/plugin-syntax-import-attributes",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-attributes"
    }
  },
  pipelineOperator: {
    syntax: {
      name: "@babel/plugin-syntax-pipeline-operator",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator"
    },
    transform: {
      name: "@babel/plugin-proposal-pipeline-operator",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator"
    }
  },
  recordAndTuple: {
    syntax: {
      name: "@babel/plugin-syntax-record-and-tuple",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple"
    }
  },
  throwExpressions: {
    syntax: {
      name: "@babel/plugin-syntax-throw-expressions",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions"
    },
    transform: {
      name: "@babel/plugin-proposal-throw-expressions",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions"
    }
  },
  typescript: {
    syntax: {
      name: "@babel/plugin-syntax-typescript",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript"
    },
    transform: {
      name: "@babel/preset-typescript",
      url: "https://github.com/babel/babel/tree/main/packages/babel-preset-typescript"
    }
  }
};

Object.assign(pluginNameMap, {
  asyncGenerators: {
    syntax: {
      name: "@babel/plugin-syntax-async-generators",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators"
    },
    transform: {
      name: "@babel/plugin-transform-async-generator-functions",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-async-generator-functions"
    }
  },
  classProperties: {
    syntax: {
      name: "@babel/plugin-syntax-class-properties",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
    },
    transform: {
      name: "@babel/plugin-transform-class-properties",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
    }
  },
  classPrivateProperties: {
    syntax: {
      name: "@babel/plugin-syntax-class-properties",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
    },
    transform: {
      name: "@babel/plugin-transform-class-properties",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
    }
  },
  classPrivateMethods: {
    syntax: {
      name: "@babel/plugin-syntax-class-properties",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
    },
    transform: {
      name: "@babel/plugin-transform-private-methods",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-methods"
    }
  },
  classStaticBlock: {
    syntax: {
      name: "@babel/plugin-syntax-class-static-block",
      url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block"
    },
    transform: {
      name: "@babel/plugin-transform-class-static-block",
      url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-transform-class-static-block"
    }
  },
  dynamicImport: {
    syntax: {
      name: "@babel/plugin-syntax-dynamic-import",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import"
    }
  },
  exportNamespaceFrom: {
    syntax: {
      name: "@babel/plugin-syntax-export-namespace-from",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from"
    },
    transform: {
      name: "@babel/plugin-transform-export-namespace-from",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-export-namespace-from"
    }
  },
  importAssertions: {
    syntax: {
      name: "@babel/plugin-syntax-import-assertions",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions"
    }
  },
  importMeta: {
    syntax: {
      name: "@babel/plugin-syntax-import-meta",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta"
    }
  },
  logicalAssignment: {
    syntax: {
      name: "@babel/plugin-syntax-logical-assignment-operators",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators"
    },
    transform: {
      name: "@babel/plugin-transform-logical-assignment-operators",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-logical-assignment-operators"
    }
  },
  moduleStringNames: {
    syntax: {
      name: "@babel/plugin-syntax-module-string-names",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names"
    }
  },
  numericSeparator: {
    syntax: {
      name: "@babel/plugin-syntax-numeric-separator",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator"
    },
    transform: {
      name: "@babel/plugin-transform-numeric-separator",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-numeric-separator"
    }
  },
  nullishCoalescingOperator: {
    syntax: {
      name: "@babel/plugin-syntax-nullish-coalescing-operator",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator"
    },
    transform: {
      name: "@babel/plugin-transform-nullish-coalescing-operator",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator"
    }
  },
  objectRestSpread: {
    syntax: {
      name: "@babel/plugin-syntax-object-rest-spread",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread"
    },
    transform: {
      name: "@babel/plugin-transform-object-rest-spread",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-object-rest-spread"
    }
  },
  optionalCatchBinding: {
    syntax: {
      name: "@babel/plugin-syntax-optional-catch-binding",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding"
    },
    transform: {
      name: "@babel/plugin-transform-optional-catch-binding",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-catch-binding"
    }
  },
  optionalChaining: {
    syntax: {
      name: "@babel/plugin-syntax-optional-chaining",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining"
    },
    transform: {
      name: "@babel/plugin-transform-optional-chaining",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-chaining"
    }
  },
  privateIn: {
    syntax: {
      name: "@babel/plugin-syntax-private-property-in-object",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object"
    },
    transform: {
      name: "@babel/plugin-transform-private-property-in-object",
      url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-property-in-object"
    }
  },
  regexpUnicodeSets: {
    syntax: {
      name: "@babel/plugin-syntax-unicode-sets-regex",
      url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md"
    },
    transform: {
      name: "@babel/plugin-transform-unicode-sets-regex",
      url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md"
    }
  }
});

const getNameURLCombination = ({ name, url }) => `${name} (${url})`;
function generateMissingPluginMessage(missingPluginName, loc, codeFrame) {
  let helpMessage =
    `Support for the experimental syntax '${missingPluginName}' isn't currently enabled (${loc.line}:${
      loc.column + 1
    }):\n\n` + codeFrame;
  const pluginInfo = pluginNameMap[missingPluginName];
  if (pluginInfo) {
    const { syntax: syntaxPlugin, transform: transformPlugin } = pluginInfo;
    if (syntaxPlugin) {
      const syntaxPluginInfo = getNameURLCombination(syntaxPlugin);
      helpMessage += transformPlugin
        ? `\n\nAdd ${getNameURLCombination(transformPlugin)} to the '${
            transformPlugin.name.startsWith("@babel/plugin") ? "plugins" : "presets"
          }' section of your Babel config to enable transformation.
If you want to leave it as-is, add ${syntaxPluginInfo} to the 'plugins' section to enable parsing.`
        : `\n\nAdd ${syntaxPluginInfo} to the 'plugins' section of your Babel config to enable parsing.`;
    }
  }
  return helpMessage;
}

function* parser(pluginPasses, { parserOpts, highlightCode = true, filename = "unknown" }, code) {
  try {
    const results = [];
    for (const plugins of pluginPasses)
      for (const plugin of plugins) {
        const { parserOverride } = plugin;
        if (parserOverride) {
          const ast = parserOverride(code, parserOpts, parser$1.parse);
          ast === void 0 || results.push(ast);
        }
      }

    if (results.length === 0) return parser$1.parse(code, parserOpts);
    if (results.length === 1) {
      yield* [];
      if (typeof results[0].then == "function")
        throw new Error(
          "You appear to be using an async parser plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version."
        );

      return results[0];
    }
    throw new Error("More than one plugin attempted to override parsing.");
  } catch (err) {
    if (err.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED")
      err.message +=
        "\nConsider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.";

    const { loc, missingPlugin } = err;
    if (loc) {
      const codeFrame = template$1.codeFrameColumns(code, {
        start: { line: loc.line, column: loc.column + 1 }
      }, { highlightCode });
      err.message = missingPlugin
        ? filename + ": " + generateMissingPluginMessage(missingPlugin[0], loc, codeFrame)
        : `${filename}: ${err.message}\n\n` + codeFrame;

      err.code = "BABEL_PARSE_ERROR";
    }
    throw err;
  }
}

function deepClone(value, cache) {
  if (value === null) return value;

  if (cache.has(value)) return cache.get(value);
  let cloned;
  if (Array.isArray(value)) {
    cloned = new Array(value.length);
    cache.set(value, cloned);
    for (let i = 0; i < value.length; i++)
      cloned[i] = typeof value[i] != "object" ? value[i] : deepClone(value[i], cache);
  } else {
    cloned = {};
    cache.set(value, cloned);
    const keys = Object.keys(value);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      cloned[key] = typeof value[key] != "object" ? value[key] : deepClone(value[key], cache);
    }
  }
  return cloned;
}
function cloneDeep(value) {
  return typeof value != "object" ? value : deepClone(value, new Map());
}

const { file, traverseFast } = t$5,
  debug$3 = traverse.buildDebug("babel:transform:file"),
  INLINE_SOURCEMAP_REGEX =
    /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/,
  EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;
function* normalizeFile(pluginPasses, options, code, ast) {
  code = `${code || ""}`;
  if (ast) {
    if (ast.type === "Program") ast = file(ast, [], []);
    else if (ast.type !== "File") throw new Error("AST root must be a Program or File node");

    if (options.cloneInputAst) ast = cloneDeep(ast);
  } else ast = yield* parser(pluginPasses, options, code);

  let inputMap = null;
  if (options.inputSourceMap !== false) {
    if (typeof options.inputSourceMap == "object")
      inputMap = vendors.convertSourceMap.fromObject(options.inputSourceMap);

    if (!inputMap) {
      const lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);
      if (lastComment)
        try {
          inputMap = vendors.convertSourceMap.fromComment(lastComment);
        } catch (err) {
          debug$3("discarding unknown inline input sourcemap", err);
        }
    }
    if (!inputMap) {
      const lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);
      if (typeof options.filename == "string" && lastComment)
        try {
          const match = EXTERNAL_SOURCEMAP_REGEX.exec(lastComment),
            inputMapContent = fs.readFileSync(path.resolve(path.dirname(options.filename), match[1]), "utf8");
          inputMap = vendors.convertSourceMap.fromJSON(inputMapContent);
        } catch (err) {
          debug$3("discarding unknown file input sourcemap", err);
        }
      else lastComment && debug$3("discarding un-loadable file input sourcemap");
    }
  }
  return new File(options, { code, ast, inputMap });
}
function extractCommentsFromList(regex, comments, lastComment) {
  if (comments)
    comments = comments.filter(({ value }) => {
      if (regex.test(value)) {
        lastComment = value;
        return false;
      }
      return true;
    });

  return [comments, lastComment];
}
function extractComments(regex, ast) {
  let lastComment = null;
  traverseFast(ast, node => {
    [node.leadingComments, lastComment] = extractCommentsFromList(regex, node.leadingComments, lastComment);
    [node.innerComments, lastComment] = extractCommentsFromList(regex, node.innerComments, lastComment);
    [node.trailingComments, lastComment] = extractCommentsFromList(regex, node.trailingComments, lastComment);
  });
  return lastComment;
}

const comma = ','.charCodeAt(0),
  semicolon = ';'.charCodeAt(0),
  chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
  intToChar = new Uint8Array(64),
  charToInt = new Uint8Array(128);
for (let i = 0; i < chars.length; i++) {
  const c = chars.charCodeAt(i);
  intToChar[i] = c;
  charToInt[c] = i;
}
const td = typeof TextDecoder != 'undefined'
  ? new TextDecoder()
  : typeof Buffer != 'undefined'
  ? { decode: buf => Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength).toString() }
  : {
      decode(buf) {
        let out = '';
        for (let i = 0; i < buf.length; i++) out += String.fromCharCode(buf[i]);

        return out;
      }
    };
function decode(mappings) {
  const state = new Int32Array(5),
    decoded = [];
  let index = 0;
  do {
    const semi = indexOf(mappings, index),
      line = [];
    let sorted = true,
      lastCol = 0;
    state[0] = 0;
    for (let i = index; i < semi; i++) {
      let seg;
      i = decodeInteger(mappings, i, state, 0);
      const col = state[0];
      if (col < lastCol) sorted = false;
      lastCol = col;
      if (hasMoreVlq(mappings, i, semi)) {
        i = decodeInteger(mappings, i, state, 1);
        i = decodeInteger(mappings, i, state, 2);
        i = decodeInteger(mappings, i, state, 3);
        if (hasMoreVlq(mappings, i, semi)) {
          i = decodeInteger(mappings, i, state, 4);
          seg = [col, state[1], state[2], state[3], state[4]];
        } else seg = [col, state[1], state[2], state[3]];
      } else seg = [col];

      line.push(seg);
    }
    sorted || sort(line);
    decoded.push(line);
    index = semi + 1;
  } while (index <= mappings.length);
  return decoded;
}
function indexOf(mappings, index) {
  const idx = mappings.indexOf(';', index);
  return idx < 0 ? mappings.length : idx;
}
function decodeInteger(mappings, pos, state, j) {
  let value = 0,
    shift = 0,
    integer = 0;
  do {
    const c = mappings.charCodeAt(pos++);
    integer = charToInt[c];
    value |= (integer & 31) << shift;
    shift += 5;
  } while (integer & 32);
  const shouldNegate = value & 1;
  value >>>= 1;
  if (shouldNegate) value = -0x80000000 | -value;

  state[j] += value;
  return pos;
}
function hasMoreVlq(mappings, i, length) {
  return i < length && mappings.charCodeAt(i) !== comma;
}
function sort(line) {
  line.sort(sortComparator$1);
}
function sortComparator$1(a, b) {
  return a[0] - b[0];
}
function encode(decoded) {
  const state = new Int32Array(5),
    bufLength = 16384,
    subLength = bufLength - 36,
    buf = new Uint8Array(bufLength),
    sub = buf.subarray(0, subLength);
  let pos = 0,
    out = '';
  for (let i = 0; i < decoded.length; i++) {
    const line = decoded[i];
    if (i > 0) {
      if (pos === bufLength) {
        out += td.decode(buf);
        pos = 0;
      }
      buf[pos++] = semicolon;
    }
    if (line.length === 0) continue;
    state[0] = 0;
    for (let j = 0; j < line.length; j++) {
      const segment = line[j];
      if (pos > subLength) {
        out += td.decode(sub);
        buf.copyWithin(0, subLength, pos);
        pos -= subLength;
      }
      if (j > 0) buf[pos++] = comma;
      pos = encodeInteger(buf, pos, state, segment, 0);
      if (segment.length === 1) continue;
      pos = encodeInteger(buf, pos, state, segment, 1);
      pos = encodeInteger(buf, pos, state, segment, 2);
      pos = encodeInteger(buf, pos, state, segment, 3);
      if (segment.length !== 4) pos = encodeInteger(buf, pos, state, segment, 4);
    }
  }
  return out + td.decode(buf.subarray(0, pos));
}
function encodeInteger(buf, pos, state, segment, j) {
  const next = segment[j];
  let num = next - state[j];
  state[j] = next;
  num = num < 0 ? (-num << 1) | 1 : num << 1;
  do {
    let clamped = num & 0b011111;
    num >>>= 5;
    if (num > 0) clamped |= 0b100000;
    buf[pos++] = intToChar[clamped];
  } while (num > 0);
  return pos;
}

const schemeRegex = /^[\w+.-]+:\/\//,
  urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/,
  fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
var UrlType;
!(function (UrlType) {
  UrlType[(UrlType.Empty = 1)] = "Empty";
  UrlType[(UrlType.Hash = 2)] = "Hash";
  UrlType[(UrlType.Query = 3)] = "Query";
  UrlType[(UrlType.RelativePath = 4)] = "RelativePath";
  UrlType[(UrlType.AbsolutePath = 5)] = "AbsolutePath";
  UrlType[(UrlType.SchemeRelative = 6)] = "SchemeRelative";
  UrlType[(UrlType.Absolute = 7)] = "Absolute";
})(UrlType || (UrlType = {}));
function isAbsoluteUrl(input) {
  return schemeRegex.test(input);
}
function isSchemeRelativeUrl(input) {
  return input.startsWith('//');
}
function isAbsolutePath(input) {
  return input.startsWith('/');
}
function isFileUrl(input) {
  return input.startsWith('file:');
}
function isRelative(input) {
  return /^[.?#]/.test(input);
}
function parseAbsoluteUrl(input) {
  const match = urlRegex.exec(input);
  return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');
}
function parseFileUrl(input) {
  const match = fileRegex.exec(input),
    path = match[2];
  return makeUrl(
    'file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || ''
  );
}
function makeUrl(scheme, user, host, port, path, query, hash) {
  return { scheme, user, host, port, path, query, hash, type: UrlType.Absolute };
}
function parseUrl(input) {
  if (isSchemeRelativeUrl(input)) {
    const url = parseAbsoluteUrl('http:' + input);
    url.scheme = '';
    url.type = UrlType.SchemeRelative;
    return url;
  }
  if (isAbsolutePath(input)) {
    const url = parseAbsoluteUrl('http://foo.com' + input);
    url.scheme = '';
    url.host = '';
    url.type = UrlType.AbsolutePath;
    return url;
  }
  if (isFileUrl(input)) return parseFileUrl(input);
  if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);
  const url = parseAbsoluteUrl('http://foo.com/' + input);
  url.scheme = '';
  url.host = '';
  url.type = input
    ? (input.startsWith('?') ? UrlType.Query : input.startsWith('#') ? UrlType.Hash : UrlType.RelativePath)
    : UrlType.Empty;
  return url;
}
function stripPathFilename(path) {
  if (path.endsWith('/..')) return path;
  const index = path.lastIndexOf('/');
  return path.slice(0, index + 1);
}
function mergePaths(url, base) {
  normalizePath(base, base.type);
  url.path === '/' ? (url.path = base.path) : (url.path = stripPathFilename(base.path) + url.path);
}
function normalizePath(url, type) {
  const rel = type <= UrlType.RelativePath,
    pieces = url.path.split('/');
  let pointer = 1,
    positive = 0,
    addTrailingSlash = false;
  for (let i = 1; i < pieces.length; i++) {
    const piece = pieces[i];
    if (!piece) {
      addTrailingSlash = true;
      continue;
    }
    addTrailingSlash = false;
    if (piece === '.') continue;
    if (piece !== '..') {
      pieces[pointer++] = piece;
      positive++;
    } else if (positive) {
      addTrailingSlash = true;
      positive--;
      pointer--;
    } else if (rel) pieces[pointer++] = piece;
  }
  let path = '';
  for (let i = 1; i < pointer; i++) path += '/' + pieces[i];

  if (!path || (addTrailingSlash && !path.endsWith('/..'))) path += '/';

  url.path = path;
}
function resolve$3(input, base) {
  if (!input && !base) return '';
  const url = parseUrl(input);
  let inputType = url.type;
  if (base && inputType !== UrlType.Absolute) {
    const baseUrl = parseUrl(base),
      baseType = baseUrl.type;
    switch (inputType) {
      case UrlType.Empty:
        url.hash = baseUrl.hash;
      case UrlType.Hash:
        url.query = baseUrl.query;
      case UrlType.Query:
      case UrlType.RelativePath:
        mergePaths(url, baseUrl);
      case UrlType.AbsolutePath:
        url.user = baseUrl.user;
        url.host = baseUrl.host;
        url.port = baseUrl.port;
      case UrlType.SchemeRelative:
        url.scheme = baseUrl.scheme;
    }
    if (baseType > inputType) inputType = baseType;
  }
  normalizePath(url, inputType);
  const queryHash = url.query + url.hash;
  switch (inputType) {
    case UrlType.Hash:
    case UrlType.Query:
      return queryHash;
    case UrlType.RelativePath:
      const path = url.path.slice(1);
      return !path
        ? queryHash || '.'
        : isRelative(base || input) && !isRelative(path)
        ? './' + path + queryHash
        : path + queryHash;

    case UrlType.AbsolutePath:
      return url.path + queryHash;
    default:
      return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;
  }
}

function resolve$2(input, base) {
  if (base && !base.endsWith('/')) base += '/';
  return resolve$3(input, base);
}
function stripFilename(path) {
  if (!path) return '';
  const index = path.lastIndexOf('/');
  return path.slice(0, index + 1);
}
const COLUMN = 0;
function maybeSort(mappings, owned) {
  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
  if (unsortedIndex === mappings.length) return mappings;
  owned || (mappings = mappings.slice());
  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1))
    mappings[i] = sortSegments(mappings[i], owned);

  return mappings;
}
function nextUnsortedSegmentLine(mappings, start) {
  for (let i = start; i < mappings.length; i++) if (!isSorted(mappings[i])) return i;

  return mappings.length;
}
function isSorted(line) {
  for (let j = 1; j < line.length; j++) if (line[j][COLUMN] < line[j - 1][COLUMN]) return false;

  return true;
}
function sortSegments(line, owned) {
  owned || (line = line.slice());
  return line.sort(sortComparator);
}
function sortComparator(a, b) {
  return a[COLUMN] - b[COLUMN];
}
let found = false;
function binarySearch(haystack, needle, low, high) {
  while (low <= high) {
    const mid = low + ((high - low) >> 1),
      cmp = haystack[mid][COLUMN] - needle;
    if (cmp === 0) {
      found = true;
      return mid;
    }
    cmp < 0 ? (low = mid + 1) : (high = mid - 1);
  }
  found = false;
  return low - 1;
}
function upperBound(haystack, needle, index) {
  for (let i = index + 1; i < haystack.length && haystack[i][COLUMN] === needle; index = i++);

  return index;
}
function lowerBound(haystack, needle, index) {
  for (let i = index - 1; i >= 0 && haystack[i][COLUMN] === needle; index = i--);

  return index;
}
function memoizedState() {
  return { lastKey: -1, lastNeedle: -1, lastIndex: -1 };
}
function memoizedBinarySearch(haystack, needle, state, key) {
  const { lastKey, lastNeedle, lastIndex } = state;
  let low = 0,
    high = haystack.length - 1;
  if (key === lastKey) {
    if (needle === lastNeedle) {
      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
      return lastIndex;
    }
    needle >= lastNeedle ? (low = lastIndex === -1 ? 0 : lastIndex) : (high = lastIndex);
  }
  state.lastKey = key;
  state.lastNeedle = needle;
  return (state.lastIndex = binarySearch(haystack, needle, low, high));
}
const LEAST_UPPER_BOUND = -1,
  GREATEST_LOWER_BOUND = 1;
let decodedMappings, traceSegment;
class TraceMap {
  constructor(map, mapUrl) {
    const isString = typeof map == 'string';
    if (!isString && map._decodedMemo) return map;
    const parsed = isString ? JSON.parse(map) : map,
      { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
    this.version = version;
    this.file = file;
    this.names = names;
    this.sourceRoot = sourceRoot;
    this.sources = sources;
    this.sourcesContent = sourcesContent;
    const from = resolve$2(sourceRoot || '', stripFilename(mapUrl));
    this.resolvedSources = sources.map(s => resolve$2(s || '', from));
    const { mappings } = parsed;
    if (typeof mappings == 'string') {
      this._encoded = mappings;
      this._decoded = void 0;
    } else {
      this._encoded = void 0;
      this._decoded = maybeSort(mappings, isString);
    }
    this._decodedMemo = memoizedState();
    this._bySources = void 0;
    this._bySourceMemos = void 0;
  }
}
(() => {
  decodedMappings = map => map._decoded || (map._decoded = decode(map._encoded));
  traceSegment = (map, line, column) => {
    const decoded = decodedMappings(map);
    if (line >= decoded.length) return null;
    const segments = decoded[line],
      index = traceSegmentInternal(segments, map._decodedMemo, line, column, GREATEST_LOWER_BOUND);
    return index === -1 ? null : segments[index];
  };
})();
function traceSegmentInternal(segments, memo, line, column, bias) {
  let index = memoizedBinarySearch(segments, column, memo, line);
  found
    ? (index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index))
    : bias !== LEAST_UPPER_BOUND || index++;
  return index === -1 || index === segments.length ? -1 : index;
}

let get$1, put;
class SetArray {
  constructor() {
    this._indexes = { __proto__: null };
    this.array = [];
  }
}
(() => {
  get$1 = (strarr, key) => strarr._indexes[key];
  put = (strarr, key) => {
    const index = get$1(strarr, key);
    if (index !== void 0) return index;
    const { array, _indexes: indexes } = strarr;
    return (indexes[key] = array.push(key) - 1);
  };
})();

let addSegment, setSourceContent, decodedMap, encodedMap;
class GenMapping {
  constructor({ file, sourceRoot } = {}) {
    this._names = new SetArray();
    this._sources = new SetArray();
    this._sourcesContent = [];
    this._mappings = [];
    this.file = file;
    this.sourceRoot = sourceRoot;
  }
}
(() => {
  addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name) => {
    const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map,
      line = getLine(mappings, genLine);
    if (source == null) {
      const seg = [genColumn];
      return insert(line, getColumnIndex(line, genColumn, seg), seg);
    }
    const sourcesIndex = put(sources, source),
      seg = name
        ? [genColumn, sourcesIndex, sourceLine, sourceColumn, put(names, name)]
        : [genColumn, sourcesIndex, sourceLine, sourceColumn],
      index = getColumnIndex(line, genColumn, seg);
    if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = null;
    insert(line, index, seg);
  };
  setSourceContent = (map, source, content) => {
    const { _sources: sources, _sourcesContent: sourcesContent } = map;
    sourcesContent[put(sources, source)] = content;
  };
  decodedMap = map => {
    const {
      file,
      sourceRoot,
      _mappings: mappings,
      _sources: sources,
      _sourcesContent: sourcesContent,
      _names: names
    } = map;
    return {
      version: 3,
      file,
      names: names.array,
      sourceRoot: sourceRoot || void 0,
      sources: sources.array,
      sourcesContent,
      mappings
    };
  };
  encodedMap = map => {
    const decoded = decodedMap(map);
    return Object.assign(Object.assign({}, decoded), { mappings: encode(decoded.mappings) });
  };
})();
function getLine(mappings, index) {
  for (let i = mappings.length; i <= index; i++) mappings[i] = [];

  return mappings[index];
}
function getColumnIndex(line, column, seg) {
  let index = line.length;
  for (let i = index - 1; i >= 0; i--, index--) {
    const current = line[i],
      col = current[0];
    if (col > column) continue;
    if (col < column) break;
    const cmp = compare$2(current, seg);
    if (cmp === 0) return index;
    if (cmp < 0) break;
  }
  return index;
}
function compare$2(a, b) {
  let cmp = compareNum(a.length, b.length);
  if (cmp !== 0) return cmp;
  if (a.length === 1) return 0;
  cmp = compareNum(a[1], b[1]);
  if (cmp !== 0) return cmp;
  cmp = compareNum(a[2], b[2]);
  if (cmp !== 0) return cmp;
  cmp = compareNum(a[3], b[3]);
  return cmp !== 0 ? cmp : a.length === 4 ? 0 : compareNum(a[4], b[4]);
}
function compareNum(a, b) {
  return a - b;
}
function insert(array, index, value) {
  if (index === -1) return;
  for (let i = array.length; i > index; i--) array[i] = array[i - 1];

  array[index] = value;
}

const SOURCELESS_MAPPING = { source: null, column: null, line: null, name: null, content: null },
  EMPTY_SOURCES = [];
function Source(map, sources, source, content) {
  return { map, sources, source, content };
}
function MapSource(map, sources) {
  return Source(map, sources, '', null);
}
function OriginalSource(source, content) {
  return Source(null, EMPTY_SOURCES, source, content);
}
function traceMappings(tree) {
  const gen = new GenMapping({ file: tree.map.file }),
    { sources: rootSources, map } = tree,
    rootNames = map.names,
    rootMappings = decodedMappings(map);
  for (let i = 0; i < rootMappings.length; i++) {
    const segments = rootMappings[i];
    let lastSource = null,
      lastSourceLine = null,
      lastSourceColumn = null;
    for (let j = 0; j < segments.length; j++) {
      const segment = segments[j],
        genCol = segment[0];
      let traced = SOURCELESS_MAPPING;
      if (segment.length !== 1) {
        traced = originalPositionFor(
          rootSources[segment[1]], segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : ''
        );
        if (traced == null) continue;
      }
      const { column, line, name, content, source } = traced;
      if (line === lastSourceLine && column === lastSourceColumn && source === lastSource) continue;

      lastSourceLine = line;
      lastSourceColumn = column;
      lastSource = source;
      addSegment(gen, i, genCol, source, line, column, name);
      content == null || setSourceContent(gen, source, content);
    }
  }
  return gen;
}
function originalPositionFor(source, line, column, name) {
  if (!source.map) return { column, line, name, source: source.source, content: source.content };

  const segment = traceSegment(source.map, line, column);
  return segment == null ? null
    : segment.length === 1 ? SOURCELESS_MAPPING
    : originalPositionFor(
        source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name
      );
}
function asArray(value) {
  return Array.isArray(value) ? value : [value];
}
function buildSourceMapTree(input, loader) {
  const maps = asArray(input).map(m => new TraceMap(m, '')),
    map = maps.pop();
  for (let i = 0; i < maps.length; i++)
    if (maps[i].sources.length > 1)
      throw new Error(`Transformation map ${i} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);

  let tree = build$1(map, loader, '', 0);
  for (let i = maps.length - 1; i >= 0; i--) tree = MapSource(maps[i], [tree]);

  return tree;
}
function build$1(map, loader, importer, importerDepth) {
  const { resolvedSources, sourcesContent } = map,
    depth = importerDepth + 1;

  return MapSource(map, resolvedSources.map((sourceFile, i) => {
    const ctx = { importer, depth, source: sourceFile || '', content: void 0 },
      sourceMap = loader(ctx.source, ctx),
      { source, content } = ctx;
    return sourceMap
      ? build$1(new TraceMap(sourceMap, source), loader, source, depth)
      : OriginalSource(source, content !== void 0 ? content : sourcesContent ? sourcesContent[i] : null);
  }));
}
class SourceMap {
  constructor(map, options) {
    const out = options.decodedMappings ? decodedMap(map) : encodedMap(map);
    this.version = out.version;
    this.file = out.file;
    this.mappings = out.mappings;
    this.names = out.names;
    this.sourceRoot = out.sourceRoot;
    this.sources = out.sources;
    options.excludeContent || (this.sourcesContent = out.sourcesContent);
  }
  toString() {
    return JSON.stringify(this);
  }
}
function remapping(input, loader, options) {
  const opts = typeof options == 'object' ? options : { excludeContent: !!options, decodedMappings: false },
    tree = buildSourceMapTree(input, loader);
  return new SourceMap(traceMappings(tree), opts);
}

function mergeSourceMap(inputMap, map, sourceFileName) {
  const source = sourceFileName.replace(/\\/g, "/");
  let found = false;
  const result = remapping(rootless(map), (s, ctx) => {
    if (s === source && !found) {
      found = true;
      ctx.source = "";
      return rootless(inputMap);
    }
    return null;
  });
  if (typeof inputMap.sourceRoot == "string") result.sourceRoot = inputMap.sourceRoot;

  return Object.assign({}, result);
}
function rootless(map) {
  return Object.assign({}, map, { sourceRoot: null });
}

function generateCode(pluginPasses, file) {
  const { opts, ast, code, inputMap } = file,
    { generatorOpts } = opts;
  generatorOpts.inputSourceMap = inputMap == null ? void 0 : inputMap.toObject();
  const results = [];
  for (const plugins of pluginPasses)
    for (const plugin of plugins) {
      const { generatorOverride } = plugin;
      if (generatorOverride) {
        const result = generatorOverride(ast, generatorOpts, code, generate.default);
        result === void 0 || results.push(result);
      }
    }

  let result;
  if (results.length === 0) result = generate.default(ast, generatorOpts, code);
  else {
    if (results.length !== 1) throw new Error("More than one plugin attempted to override codegen.");

    result = results[0];
    if (typeof result.then == "function")
      throw new Error(
        "You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version."
      );
  }
  let { code: outputCode, decodedMap: outputMap = result.map } = result;
  if (result.__mergedMap) outputMap = Object.assign({}, result.map);
  else if (outputMap)
    outputMap = inputMap ? mergeSourceMap(inputMap.toObject(), outputMap, generatorOpts.sourceFileName) : result.map;

  (opts.sourceMaps !== "inline" && opts.sourceMaps !== "both") ||
    (outputCode += "\n" + vendors.convertSourceMap.fromObject(outputMap).toComment());

  if (opts.sourceMaps === "inline") outputMap = null;

  return { outputCode, outputMap };
}

function* run(config, code, ast) {
  const file = yield* normalizeFile(config.passes, normalizeOptions$4(config), code, ast),
    opts = file.opts;
  try {
    yield* transformFile$2(file, config.passes);
  } catch (e) {
    var _opts$filename;
    e.message = `${(_opts$filename = opts.filename) != null ? _opts$filename : "unknown file"}: ${e.message}`;
    e.code || (e.code = "BABEL_TRANSFORM_ERROR");

    throw e;
  }
  let outputCode, outputMap;
  try {
    if (opts.code !== false) ({ outputCode, outputMap } = generateCode(config.passes, file));
  } catch (e) {
    var _opts$filename2;
    e.message = `${(_opts$filename2 = opts.filename) != null ? _opts$filename2 : "unknown file"}: ${e.message}`;
    e.code || (e.code = "BABEL_GENERATE_ERROR");

    throw e;
  }
  return {
    metadata: file.metadata,
    options: opts,
    ast: opts.ast === true ? file.ast : null,
    code: outputCode === void 0 ? null : outputCode,
    map: outputMap === void 0 ? null : outputMap,
    sourceType: file.ast.program.sourceType,
    externalDependencies: flattenToSet(config.externalDependencies)
  };
}
function* transformFile$2(file, pluginPasses) {
  for (const pluginPairs of pluginPasses) {
    const passPairs = [],
      passes = [],
      visitors = [];
    for (const plugin of pluginPairs.concat([loadBlockHoistPlugin()])) {
      const pass = new PluginPass(file, plugin.key, plugin.options);
      passPairs.push([plugin, pass]);
      passes.push(pass);
      visitors.push(plugin.visitor);
    }
    for (const [plugin, pass] of passPairs) {
      const fn = plugin.pre;
      if (fn) {
        const result = fn.call(pass, file);
        yield* [];
        if (isThenable(result))
          throw new Error(
            "You appear to be using an plugin with an async .pre, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version."
          );
      }
    }
    const visitor = traverse.visitors.merge(visitors, passes, file.opts.wrapPluginVisitorMethod);

    traverse.default(file.ast, visitor, file.scope);

    for (const [plugin, pass] of passPairs) {
      const fn = plugin.post;
      if (fn) {
        const result = fn.call(pass, file);
        yield* [];
        if (isThenable(result))
          throw new Error(
            "You appear to be using an plugin with an async .post, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version."
          );
      }
    }
  }
}
function isThenable(val) {
  return !(!val || (typeof val != "object" && typeof val != "function") || !val.then || typeof val.then != "function");
}

const transformFileRunner = gensync(function* (filename, opts) {
  const options = Object.assign({}, opts, { filename }),
    config = yield* loadConfig$1(options);
  if (config === null) return null;
  const code = yield* readFile(filename, "utf8");
  return yield* run(config, code);
});
function transformFile$1(...args) {
  transformFileRunner.errback(...args);
}
function transformFileSync(...args) {
  return transformFileRunner.sync(...args);
}
function transformFileAsync$1(...args) {
  return transformFileRunner.async(...args);
}

var version$2 = "7.22.15";

function declare(x) {
  return x;
}

var removePlugin = function (plugins, name) {
  const indices = [];
  plugins.forEach((plugin, i) => {
    (Array.isArray(plugin) ? plugin[0] : plugin) !== name || indices.unshift(i);
  });
  for (const i of indices) plugins.splice(i, 1);
};

var syntaxTypescript = declare((api, opts) => {
  api.assertVersion(7);
  const { disallowAmbiguousJSXLike, dts } = opts;

  var { isTSX } = opts;

  return {
    name: "syntax-typescript",
    manipulateOptions(opts, parserOpts) {
      const { plugins } = parserOpts;
      removePlugin(plugins, "flow");
      removePlugin(plugins, "jsx");
      plugins.push("objectRestSpread", "classProperties");
      isTSX && plugins.push("jsx");

      parserOpts.plugins.push(["typescript", { disallowAmbiguousJSXLike, dts }]);
    }
  };
});

const {
  NOT_LOCAL_BINDING,
  cloneNode: cloneNode$5,
  identifier: identifier$5,
  isAssignmentExpression,
  isAssignmentPattern: isAssignmentPattern$3,
  isFunction,
  isIdentifier: isIdentifier$6,
  isLiteral: isLiteral$1,
  isNullLiteral,
  isObjectMethod,
  isObjectProperty: isObjectProperty$3,
  isRegExpLiteral,
  isRestElement: isRestElement$2,
  isTemplateLiteral,
  isVariableDeclarator,
  toBindingIdentifierName
} = t$5;
function getFunctionArity(node) {
  const count = node.params.findIndex(param => isAssignmentPattern$3(param) || isRestElement$2(param));
  return count < 0 ? node.params.length : count;
}
const buildPropertyMethodAssignmentWrapper = template$1.statement(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }

    return FUNCTION_ID;
  })(FUNCTION)
`);
const buildGeneratorPropertyMethodAssignmentWrapper = template$1.statement(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };

    return FUNCTION_ID;
  })(FUNCTION)
`);
const visitor$4 = {
  "ReferencedIdentifier|BindingIdentifier"(path, state) {
    if (path.node.name !== state.name || path.scope.getBindingIdentifier(state.name) !== state.outerDeclar) return;
    state.selfReference = true;
    path.stop();
  }
};
function getNameFromLiteralId(id) {
  return isNullLiteral(id)
    ? "null"
    : isRegExpLiteral(id)
    ? `_${id.pattern}_${id.flags}`
    : isTemplateLiteral(id)
    ? id.quasis.map(quasi => quasi.value.raw).join("")
    : id.value !== void 0
    ? id.value + ""
    : "";
}
function wrap(state, method, id, scope) {
  if (state.selfReference) {
    if (!scope.hasBinding(id.name) || scope.hasGlobal(id.name)) {
      if (!isFunction(method)) return;
      let build = buildPropertyMethodAssignmentWrapper;
      if (method.generator) build = buildGeneratorPropertyMethodAssignmentWrapper;

      const template = build({
        FUNCTION: method,
        FUNCTION_ID: id,
        FUNCTION_KEY: scope.generateUidIdentifier(id.name)
      }).expression;
      const params = template.callee.body.body[0].params;
      for (let i = 0, len = getFunctionArity(method); i < len; i++) params.push(scope.generateUidIdentifier("x"));

      return template;
    }
    scope.rename(id.name);
  }
  method.id = id;
  scope.getProgramParent().references[id.name] = true;
}
function visit(node, name, scope) {
  const state = { selfAssignment: false, selfReference: false, outerDeclar: scope.getBindingIdentifier(name), name },
    binding = scope.getOwnBinding(name);
  if (binding) {
    if (binding.kind === "param") state.selfReference = true;
  } else if (state.outerDeclar || scope.hasGlobal(name)) scope.traverse(node, visitor$4, state);

  return state;
}
function nameFunction({ node, parent, scope, id }, localBinding = false, supportUnicodeId = false) {
  if (node.id) return;
  if (
    (isObjectProperty$3(parent) || isObjectMethod(parent, { kind: "method" })) &&
    (!parent.computed || isLiteral$1(parent.key))
  )
    id = parent.key;
  else if (isVariableDeclarator(parent)) {
    id = parent.id;
    if (isIdentifier$6(id) && !localBinding) {
      const binding = scope.parent.getBinding(id.name);
      if (binding && binding.constant && scope.getBinding(id.name) === binding) {
        node.id = cloneNode$5(id);
        node.id[NOT_LOCAL_BINDING] = true;
        return;
      }
    }
  } else if (isAssignmentExpression(parent, { operator: "=" })) id = parent.left;
  else if (!id) return;

  let name;
  if (id && isLiteral$1(id)) name = getNameFromLiteralId(id);
  else if (id && isIdentifier$6(id)) name = id.name;

  if (name === void 0) return;
  if (!supportUnicodeId && isFunction(node) && /[\uD800-\uDFFF]/.test(name)) return;

  name = toBindingIdentifierName(name);
  const newId = identifier$5(name);
  newId[NOT_LOCAL_BINDING] = true;
  return wrap(visit(node, name, scope), node, newId, scope) || node;
}

function willPathCastToBoolean$1(path) {
  const maybeWrapped = path,
    { node, parentPath } = maybeWrapped;
  if (parentPath.isLogicalExpression()) {
    const { operator, right } = parentPath.node;
    if (operator === "&&" || operator === "||" || (operator === "??" && node === right))
      return willPathCastToBoolean$1(parentPath);
  }
  if (parentPath.isSequenceExpression()) {
    const { expressions } = parentPath.node;
    return expressions[expressions.length - 1] !== node || willPathCastToBoolean$1(parentPath);
  }
  return (
    parentPath.isConditional({ test: node }) ||
    parentPath.isUnaryExpression({ operator: "!" }) ||
    parentPath.isLoop({ test: node })
  );
}

const {
  LOGICAL_OPERATORS,
  arrowFunctionExpression,
  assignmentExpression: assignmentExpression$5,
  binaryExpression: binaryExpression$1,
  booleanLiteral: booleanLiteral$2,
  callExpression: callExpression$5,
  cloneNode: cloneNode$4,
  conditionalExpression: conditionalExpression$1,
  identifier: identifier$4,
  isMemberExpression: isMemberExpression$1,
  isOptionalCallExpression,
  isOptionalMemberExpression,
  isUpdateExpression,
  logicalExpression,
  memberExpression: memberExpression$5,
  nullLiteral: nullLiteral$1,
  optionalCallExpression: optionalCallExpression$1,
  optionalMemberExpression: optionalMemberExpression$1,
  sequenceExpression: sequenceExpression$2,
  updateExpression
} = t$5;
class AssignmentMemoiser {
  constructor() {
    this._map = void 0;
    this._map = new WeakMap();
  }
  has(key) {
    return this._map.has(key);
  }
  get(key) {
    if (!this.has(key)) return;
    const record = this._map.get(key),
      { value } = record;
    record.count--;
    return record.count === 0 ? assignmentExpression$5("=", value, key) : value;
  }
  set(key, value, count) {
    return this._map.set(key, { count, value });
  }
}
function toNonOptional(path, base) {
  const { node } = path;
  if (isOptionalMemberExpression(node)) return memberExpression$5(base, node.property, node.computed);

  if (path.isOptionalCallExpression()) {
    const callee = path.get("callee");
    if (path.node.optional && callee.isOptionalMemberExpression()) {
      const object = callee.node.object,
        context = path.scope.maybeGenerateMemoised(object);
      callee.get("object").replaceWith(assignmentExpression$5("=", context, object));
      return callExpression$5(memberExpression$5(base, identifier$4("call")), [context, ...path.node.arguments]);
    }
    return callExpression$5(base, path.node.arguments);
  }
  return path.node;
}
function isInDetachedTree(path) {
  while (path && !path.isProgram()) {
    const { parentPath, container, listKey } = path,
      parentNode = parentPath.node;
    if (listKey) {
      if (container !== parentNode[listKey]) return true;
    } else if (container !== parentNode) return true;

    path = parentPath;
  }
  return false;
}
const handle$1 = {
  memoise() {},
  handle(member, noDocumentAll) {
    const { node, parent, parentPath, scope } = member;
    if (member.isOptionalMemberExpression()) {
      if (isInDetachedTree(member)) return;
      const endPath = member.find(({ node, parent }) =>
        isOptionalMemberExpression(parent)
          ? parent.optional || parent.object !== node
          : !isOptionalCallExpression(parent) || (node !== member.node && parent.optional) || parent.callee !== node
      );
      if (scope.path.isPattern()) {
        endPath.replaceWith(callExpression$5(arrowFunctionExpression([], endPath.node), []));
        return;
      }
      const willEndPathCastToBoolean = willPathCastToBoolean$1(endPath),
        rootParentPath = endPath.parentPath;
      if (rootParentPath.isUpdateExpression({ argument: node }) || rootParentPath.isAssignmentExpression({ left: node }))
        throw member.buildCodeFrameError("can't handle assignment");

      const isDeleteOperation = rootParentPath.isUnaryExpression({ operator: "delete" });
      if (isDeleteOperation && endPath.isOptionalMemberExpression() && endPath.get("property").isPrivateName())
        throw member.buildCodeFrameError("can't delete a private class element");

      let startingOptional = member;
      for (;;)
        if (startingOptional.isOptionalMemberExpression()) {
          if (startingOptional.node.optional) break;
          startingOptional = startingOptional.get("object");
        } else if (startingOptional.isOptionalCallExpression()) {
          if (startingOptional.node.optional) break;
          startingOptional = startingOptional.get("callee");
        } else throw new Error("Internal error: unexpected " + startingOptional.node.type);

      const startingNode = startingOptional.isOptionalMemberExpression()
          ? startingOptional.node.object
          : startingOptional.node.callee,
        baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode),
        baseRef = baseNeedsMemoised != null ? baseNeedsMemoised : startingNode,
        parentIsOptionalCall = parentPath.isOptionalCallExpression({ callee: node }),
        isOptionalCall = parent => parentIsOptionalCall,
        parentIsCall = parentPath.isCallExpression({ callee: node });
      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));
      isOptionalCall()
        ? parent.optional
          ? parentPath.replaceWith(this.optionalCall(member, parent.arguments))
          : parentPath.replaceWith(this.call(member, parent.arguments))
        : parentIsCall
        ? member.replaceWith(this.boundGet(member))
        : this.delete && parentPath.isUnaryExpression({ operator: "delete" })
        ? parentPath.replaceWith(this.delete(member))
        : member.replaceWith(this.get(member));

      let context,
        regular = member.node;
      for (let current = member; current !== endPath; ) {
        const parentPath = current.parentPath;
        if (parentPath === endPath && isOptionalCall() && parent.optional) {
          regular = parentPath.node;
          break;
        }
        regular = toNonOptional(parentPath, regular);
        current = parentPath;
      }
      const endParentPath = endPath.parentPath;
      if (
        isMemberExpression$1(regular) &&
        endParentPath.isOptionalCallExpression({ callee: endPath.node, optional: true })
      ) {
        const { object } = regular;
        context = member.scope.maybeGenerateMemoised(object);
        if (context) regular.object = assignmentExpression$5("=", context, object);
      }
      let replacementPath = endPath;
      if (isDeleteOperation) {
        replacementPath = endParentPath;
        regular = endParentPath.node;
      }
      const baseMemoised = baseNeedsMemoised
        ? assignmentExpression$5("=", cloneNode$4(baseRef), cloneNode$4(startingNode))
        : cloneNode$4(baseRef);
      if (willEndPathCastToBoolean) {
        let nonNullishCheck = noDocumentAll
          ? binaryExpression$1("!=", baseMemoised, nullLiteral$1())
          : logicalExpression("&&",
              binaryExpression$1("!==", baseMemoised, nullLiteral$1()),
              binaryExpression$1("!==", cloneNode$4(baseRef), scope.buildUndefinedNode())
            );

        replacementPath.replaceWith(logicalExpression("&&", nonNullishCheck, regular));
      } else {
        let nullishCheck = noDocumentAll
          ? binaryExpression$1("==", baseMemoised, nullLiteral$1())
          : logicalExpression("||",
              binaryExpression$1("===", baseMemoised, nullLiteral$1()),
              binaryExpression$1("===", cloneNode$4(baseRef), scope.buildUndefinedNode())
            );

        replacementPath.replaceWith(conditionalExpression$1(
          nullishCheck, isDeleteOperation ? booleanLiteral$2(true) : scope.buildUndefinedNode(), regular
        ));
      }
      if (context) {
        const endParent = endParentPath.node;
        endParentPath.replaceWith(optionalCallExpression$1(
          optionalMemberExpression$1(endParent.callee, identifier$4("call"), false, true),
          [cloneNode$4(context), ...endParent.arguments], false
        ));
      }
      return;
    }
    if (isUpdateExpression(parent, { argument: node })) {
      if (this.simpleSet) {
        member.replaceWith(this.simpleSet(member));
        return;
      }
      const { operator, prefix } = parent;
      this.memoise(member, 2);
      const ref = scope.generateUidIdentifierBasedOnNode(node);
      scope.push({ id: ref });
      const seq = [assignmentExpression$5("=", cloneNode$4(ref), this.get(member))];
      if (prefix) {
        seq.push(updateExpression(operator, cloneNode$4(ref), prefix));
        const value = sequenceExpression$2(seq);
        parentPath.replaceWith(this.set(member, value));
        return;
      }
      //{
      const ref2 = scope.generateUidIdentifierBasedOnNode(node);
      scope.push({ id: ref2 });
      seq.push(
        assignmentExpression$5("=", cloneNode$4(ref2), updateExpression(operator, cloneNode$4(ref), prefix)),
        cloneNode$4(ref)
      );
      const value = sequenceExpression$2(seq);
      parentPath.replaceWith(sequenceExpression$2([this.set(member, value), cloneNode$4(ref2)]));
      return;
      //}
    }
    if (parentPath.isAssignmentExpression({ left: node })) {
      if (this.simpleSet) {
        member.replaceWith(this.simpleSet(member));
        return;
      }
      const { operator, right: value } = parentPath.node;
      if (operator === "=") parentPath.replaceWith(this.set(member, value));
      else {
        const operatorTrunc = operator.slice(0, -1);
        if (LOGICAL_OPERATORS.includes(operatorTrunc)) {
          this.memoise(member, 1);
          parentPath.replaceWith(logicalExpression(operatorTrunc, this.get(member), this.set(member, value)));
        } else {
          this.memoise(member, 2);
          parentPath.replaceWith(this.set(member, binaryExpression$1(operatorTrunc, this.get(member), value)));
        }
      }
    } else if (parentPath.isCallExpression({ callee: node }))
      parentPath.replaceWith(this.call(member, parentPath.node.arguments));
    else if (parentPath.isOptionalCallExpression({ callee: node })) {
      if (scope.path.isPattern()) {
        parentPath.replaceWith(callExpression$5(arrowFunctionExpression([], parentPath.node), []));
        return;
      }
      parentPath.replaceWith(this.optionalCall(member, parentPath.node.arguments));
    } else this.delete && parentPath.isUnaryExpression({ operator: "delete" })
      ? parentPath.replaceWith(this.delete(member))
      : parentPath.isForXStatement({ left: node }) ||
        (parentPath.isObjectProperty({ value: node }) && parentPath.parentPath.isObjectPattern()) ||
        (parentPath.isAssignmentPattern({ left: node }) &&
          parentPath.parentPath.isObjectProperty({ value: parent }) &&
          parentPath.parentPath.parentPath.isObjectPattern()) ||
        parentPath.isArrayPattern() ||
        (parentPath.isAssignmentPattern({ left: node }) && parentPath.parentPath.isArrayPattern()) ||
        parentPath.isRestElement()
      ? member.replaceWith(this.destructureSet(member))
      : parentPath.isTaggedTemplateExpression()
      ? member.replaceWith(this.boundGet(member))
      : member.replaceWith(this.get(member));
  }
};
function memberExpressionToFunctions(path, visitor, state) {
  path.traverse(visitor, Object.assign({}, handle$1, state, { memoiser: new AssignmentMemoiser() }));
}

const {
  callExpression: callExpression$4,
  identifier: identifier$3,
  isIdentifier: isIdentifier$5,
  isSpreadElement,
  memberExpression: memberExpression$4,
  optionalCallExpression,
  optionalMemberExpression
} = t$5;
function optimiseCallExpression(callee, thisNode, args, optional) {
  return args.length === 1 && isSpreadElement(args[0]) && isIdentifier$5(args[0].argument, { name: "arguments" })
    ? optional
      ? optionalCallExpression(
          optionalMemberExpression(callee, identifier$3("apply"), false, true),
          [thisNode, args[0].argument], false
        )
      : callExpression$4(memberExpression$4(callee, identifier$3("apply")), [thisNode, args[0].argument])
    : optional
    ? optionalCallExpression(
        optionalMemberExpression(callee, identifier$3("call"), false, true),
        [thisNode, ...args], false
      )
    : callExpression$4(memberExpression$4(callee, identifier$3("call")), [thisNode, ...args]);
}

const {
  assignmentExpression: assignmentExpression$4,
  booleanLiteral: booleanLiteral$1,
  callExpression: callExpression$3,
  cloneNode: cloneNode$3,
  identifier: identifier$2,
  memberExpression: memberExpression$3,
  sequenceExpression: sequenceExpression$1,
  stringLiteral: stringLiteral$1,
  thisExpression: thisExpression$1
} = t$5;
function getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {
  objectRef = cloneNode$3(objectRef);
  const targetRef = isStatic || isPrivateMethod ? objectRef : memberExpression$3(objectRef, identifier$2("prototype"));
  return callExpression$3(file.addHelper("getPrototypeOf"), [targetRef]);
}
const visitor$3 = traverse.visitors.merge([visitor$5, {
  Super(path, state) {
    const { node, parentPath } = path;
    parentPath.isMemberExpression({ object: node }) && state.handle(parentPath);
  }
}]);
const unshadowSuperBindingVisitor = traverse.visitors.merge([visitor$5, {
  Scopable(path, { refName }) {
    const binding = path.scope.getOwnBinding(refName);
    binding && binding.identifier.name === refName && path.scope.rename(refName);
  }
}]);
const specHandlers = {
  memoise(superMember, count) {
    const { scope, node } = superMember,
      { computed, property } = node;
    if (!computed) return;

    const memo = scope.maybeGenerateMemoised(property);
    memo && this.memoiser.set(property, memo, count);
  },
  prop(superMember) {
    const { computed, property } = superMember.node;

    return this.memoiser.has(property)
      ? cloneNode$3(this.memoiser.get(property))
      : computed
      ? cloneNode$3(property)
      : stringLiteral$1(property.name);
  },
  get(superMember) {
    return this._get(superMember, this._getThisRefs());
  },
  _get(superMember, thisRefs) {
    const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
    return callExpression$3(this.file.addHelper("get"), [
      thisRefs.memo ? sequenceExpression$1([thisRefs.memo, proto]) : proto,
      this.prop(superMember), thisRefs.this
    ]);
  },
  _getThisRefs() {
    if (!this.isDerivedConstructor) return { this: thisExpression$1() };

    const thisRef = this.scope.generateDeclaredUidIdentifier("thisSuper");
    return { memo: assignmentExpression$4("=", thisRef, thisExpression$1()), this: cloneNode$3(thisRef) };
  },
  set(superMember, value) {
    const thisRefs = this._getThisRefs(),
      proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
    return callExpression$3(this.file.addHelper("set"), [
      thisRefs.memo ? sequenceExpression$1([thisRefs.memo, proto]) : proto,
      this.prop(superMember), value, thisRefs.this,
      booleanLiteral$1(superMember.isInStrictMode())
    ]);
  },
  destructureSet(superMember) {
    throw superMember.buildCodeFrameError("Destructuring to a super field is not supported yet.");
  },
  call(superMember, args) {
    const thisRefs = this._getThisRefs();
    return optimiseCallExpression(this._get(superMember, thisRefs), cloneNode$3(thisRefs.this), args, false);
  },
  optionalCall(superMember, args) {
    const thisRefs = this._getThisRefs();
    return optimiseCallExpression(this._get(superMember, thisRefs), cloneNode$3(thisRefs.this), args, true);
  },
  delete(superMember) {
    return superMember.node.computed
      ? sequenceExpression$1([
          callExpression$3(this.file.addHelper("toPropertyKey"), [cloneNode$3(superMember.node.property)]),
          template$1.expression.ast`
          (function () { throw new ReferenceError("'delete super[expr]' is invalid"); })()
        `])
      : template$1.expression.ast`
        (function () { throw new ReferenceError("'delete super.prop' is invalid"); })()
      `;
  }
};
const looseHandlers = Object.assign({}, specHandlers, {
  prop(superMember) {
    const { property } = superMember.node;
    return this.memoiser.has(property) ? cloneNode$3(this.memoiser.get(property)) : cloneNode$3(property);
  },
  get(superMember) {
    const { isStatic, getSuperRef } = this,
      { computed } = superMember.node,
      prop = this.prop(superMember);
    let object;
    if (isStatic) {
      var _getSuperRef;
      object = (_getSuperRef = getSuperRef()) != null
        ? _getSuperRef
        : memberExpression$3(identifier$2("Function"), identifier$2("prototype"));
    } else {
      var _getSuperRef2;
      object = memberExpression$3(
        (_getSuperRef2 = getSuperRef()) != null ? _getSuperRef2 : identifier$2("Object"),
        identifier$2("prototype")
      );
    }
    return memberExpression$3(object, prop, computed);
  },
  set(superMember, value) {
    const { computed } = superMember.node,
      prop = this.prop(superMember);
    return assignmentExpression$4("=", memberExpression$3(thisExpression$1(), prop, computed), value);
  },
  destructureSet(superMember) {
    const { computed } = superMember.node,
      prop = this.prop(superMember);
    return memberExpression$3(thisExpression$1(), prop, computed);
  },
  call(superMember, args) {
    return optimiseCallExpression(this.get(superMember), thisExpression$1(), args, false);
  },
  optionalCall(superMember, args) {
    return optimiseCallExpression(this.get(superMember), thisExpression$1(), args, true);
  }
});
class ReplaceSupers {
  constructor(opts) {
    var _opts$constantSuper;
    const path = opts.methodPath;
    this.methodPath = path;
    this.isDerivedConstructor = path.isClassMethod({ kind: "constructor" }) && !!opts.superRef;
    this.isStatic =
      path.isObjectMethod() || path.node.static || (path.isStaticBlock == null ? void 0 : path.isStaticBlock());
    this.isPrivateMethod = path.isPrivate() && path.isMethod();
    this.file = opts.file;
    this.constantSuper = (_opts$constantSuper = opts.constantSuper) != null ? _opts$constantSuper : opts.isLoose;
    this.opts = opts;
  }
  getObjectRef() {
    return cloneNode$3(this.opts.objectRef || this.opts.getObjectRef());
  }
  getSuperRef() {
    return this.opts.superRef ? cloneNode$3(this.opts.superRef)
      : this.opts.getSuperRef
      ? cloneNode$3(this.opts.getSuperRef()) : void 0;
  }
  replace() {
    this.opts.refToPreserve &&
      this.methodPath.traverse(unshadowSuperBindingVisitor, { refName: this.opts.refToPreserve.name });

    const handler = this.constantSuper ? looseHandlers : specHandlers;
    memberExpressionToFunctions(this.methodPath, visitor$3, Object.assign({
      file: this.file,
      scope: this.methodPath.scope,
      isDerivedConstructor: this.isDerivedConstructor,
      isStatic: this.isStatic,
      isPrivateMethod: this.isPrivateMethod,
      getObjectRef: this.getObjectRef.bind(this),
      getSuperRef: this.getSuperRef.bind(this),
      boundGet: handler.get
    }, handler));
  }
}

const { addComment } = t$5,
  PURE_ANNOTATION = "#__PURE__",
  isPureAnnotated = ({ leadingComments }) =>
    !!leadingComments && leadingComments.some(comment => /[@#]__PURE__/.test(comment.value));
function annotateAsPure(pathOrNode) {
  const node = pathOrNode.node || pathOrNode;
  isPureAnnotated(node) || addComment(node, "leading", PURE_ANNOTATION);
}

const {
  isParenthesizedExpression,
  isTSAsExpression,
  isTSNonNullExpression,
  isTSSatisfiesExpression,
  isTSTypeAssertion,
  isTypeCastExpression
} = t$5;
function isTransparentExprWrapper(node) {
  return (
    isTSAsExpression(node) || isTSSatisfiesExpression(node) || isTSTypeAssertion(node) ||
    isTSNonNullExpression(node) || isTypeCastExpression(node) || isParenthesizedExpression(node)
  );
}
function skipTransparentExprWrappers(path) {
  while (isTransparentExprWrapper(path.node)) path = path.get("expression");

  return path;
}
function skipTransparentExprWrapperNodes(node) {
  while (isTransparentExprWrapper(node)) node = node.expression;

  return node;
}

function assertFieldTransformed(path) {
  if (path.node.declare)
    throw path.buildCodeFrameError(
      `TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.
If you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:
 - @babel/plugin-transform-class-properties
 - @babel/plugin-transform-private-methods
 - @babel/plugin-proposal-decorators`
    );
}

function buildPrivateNamesMap(props) {
  const privateNamesMap = new Map();
  for (const prop of props)
    if (prop.isPrivate()) {
      const { name } = prop.node.key.id;
      const update = privateNamesMap.has(name)
        ? privateNamesMap.get(name)
        : { id: prop.scope.generateUidIdentifier(name), static: prop.node.static, method: !prop.isProperty() };
      if (prop.isClassPrivateMethod())
        if (prop.node.kind === "get") update.getId = prop.scope.generateUidIdentifier("get_" + name);
        else if (prop.node.kind === "set") update.setId = prop.scope.generateUidIdentifier("set_" + name);
        else if (prop.node.kind === "method") update.methodId = prop.scope.generateUidIdentifier(name);

      privateNamesMap.set(name, update);
    }

  return privateNamesMap;
}
function buildPrivateNamesNodes(privateNamesMap, privateFieldsAsProperties, privateFieldsAsSymbols, state) {
  const initNodes = [];
  for (const [name, value] of privateNamesMap) {
    const { static: isStatic, method: isMethod, getId, setId } = value,
      isAccessor = getId || setId,
      id = t$5.cloneNode(value.id);
    let init;
    privateFieldsAsProperties
      ? (init = t$5.callExpression(state.addHelper("classPrivateFieldLooseKey"), [t$5.stringLiteral(name)]))
      : privateFieldsAsSymbols
      ? (init = t$5.callExpression(t$5.identifier("Symbol"), [t$5.stringLiteral(name)]))
      : isStatic || (init = t$5.newExpression(t$5.identifier(!isMethod || isAccessor ? "WeakMap" : "WeakSet"), []));

    if (init) {
      annotateAsPure(init);
      initNodes.push(template$1.statement.ast`var ${id} = ${init}`);
    }
  }
  return initNodes;
}
function privateNameVisitorFactory(visitor) {
  const nestedVisitor = traverse.visitors.merge([Object.assign({}, visitor), visitor$5]);
  const privateNameVisitor = Object.assign({}, visitor, {
    Class(path) {
      const { privateNamesMap } = this,
        body = path.get("body.body"),
        visiblePrivateNames = new Map(privateNamesMap),
        redeclared = [];
      for (const prop of body) {
        if (!prop.isPrivate()) continue;
        const { name } = prop.node.key.id;
        visiblePrivateNames.delete(name);
        redeclared.push(name);
      }
      if (!redeclared.length) return;

      path.get("body").traverse(nestedVisitor, Object.assign({}, this, { redeclared }));
      path.traverse(privateNameVisitor, Object.assign({}, this, { privateNamesMap: visiblePrivateNames }));
      path.skipKey("body");
    }
  });
  return privateNameVisitor;
}
const privateNameVisitor = privateNameVisitorFactory({
  PrivateName(path, { noDocumentAll }) {
    const { privateNamesMap, redeclared } = this,
      { node, parentPath } = path;
    if (!parentPath.isMemberExpression({ property: node }) && !parentPath.isOptionalMemberExpression({ property: node }))
      return;

    const { name } = node.id;
    !privateNamesMap.has(name) || (redeclared && redeclared.includes(name)) || this.handle(parentPath, noDocumentAll);
  }
});
function unshadow(name, scope, innerBinding) {
  while ((_scope = scope) != null && _scope.hasBinding(name) && !scope.bindingIdentifierEquals(name, innerBinding)) {
    var _scope;
    scope.rename(name);
    scope = scope.parent;
  }
}
function buildCheckInRHS(rhs, file, inRHSIsObject) {
  return inRHSIsObject || file.availableHelper == null || !file.availableHelper("checkInRHS")
    ? rhs
    : t$5.callExpression(file.addHelper("checkInRHS"), [rhs]);
}
const privateInVisitor = privateNameVisitorFactory({
  BinaryExpression(path, { file }) {
    const { operator, left, right } = path.node;
    if (operator !== "in" || !t$5.isPrivateName(left)) return;
    const { privateFieldsAsProperties, privateNamesMap, redeclared } = this,
      { name } = left.id;
    if (!privateNamesMap.has(name) || (redeclared && redeclared.includes(name))) return;
    unshadow(this.classRef.name, path.scope, this.innerBinding);
    if (privateFieldsAsProperties) {
      const { id } = privateNamesMap.get(name);
      path.replaceWith(template$1.expression.ast`
        Object.prototype.hasOwnProperty.call(${buildCheckInRHS(right, file)}, ${t$5.cloneNode(id)})
      `);
      return;
    }
    const { id, static: isStatic } = privateNamesMap.get(name);
    isStatic
      ? path.replaceWith(template$1.expression.ast`${buildCheckInRHS(right, file)} === ${t$5.cloneNode(this.classRef)}`)
      : path.replaceWith(template$1.expression.ast`${t$5.cloneNode(id)}.has(${buildCheckInRHS(right, file)})`);
  }
});
const privateNameHandlerSpec = {
  memoise(member, count) {
    const { scope } = member,
      { object } = member.node,
      memo = scope.maybeGenerateMemoised(object);

    memo && this.memoiser.set(object, memo, count);
  },
  receiver(member) {
    const { object } = member.node;
    return this.memoiser.has(object) ? t$5.cloneNode(this.memoiser.get(object)) : t$5.cloneNode(object);
  },
  get(member) {
    const { classRef, privateNamesMap, file, innerBinding } = this,
      { name } = member.node.property.id,
      { id, static: isStatic, method: isMethod, methodId, getId, setId } = privateNamesMap.get(name),
      isAccessor = getId || setId;
    if (isStatic) {
      const helperName = isMethod && !isAccessor ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
      unshadow(classRef.name, member.scope, innerBinding);
      return t$5.callExpression(file.addHelper(helperName), [
        this.receiver(member), t$5.cloneNode(classRef), t$5.cloneNode(id)
      ]);
    }
    if (isMethod) {
      if (isAccessor) {
        if (!getId && setId) {
          if (file.availableHelper("writeOnlyError"))
            return t$5.sequenceExpression([
              this.receiver(member),
              t$5.callExpression(file.addHelper("writeOnlyError"), [t$5.stringLiteral("#" + name)])
            ]);

          console.warn("@babel/helpers is outdated, update it to silence this warning.");
        }
        return t$5.callExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), t$5.cloneNode(id)]);
      }
      return t$5.callExpression(file.addHelper("classPrivateMethodGet"), [
        this.receiver(member), t$5.cloneNode(id), t$5.cloneNode(methodId)
      ]);
    }
    return t$5.callExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), t$5.cloneNode(id)]);
  },
  boundGet(member) {
    this.memoise(member, 1);
    return t$5.callExpression(t$5.memberExpression(this.get(member), t$5.identifier("bind")), [this.receiver(member)]);
  },
  set(member, value) {
    const { classRef, privateNamesMap, file } = this,
      { name } = member.node.property.id,
      { id, static: isStatic, method: isMethod, setId, getId } = privateNamesMap.get(name);
    if (isStatic) {
      const helperName =
        !isMethod || getId || setId ? "classStaticPrivateFieldSpecSet" : "classStaticPrivateMethodSet";
      return t$5.callExpression(file.addHelper(helperName), [
        this.receiver(member), t$5.cloneNode(classRef), t$5.cloneNode(id), value
      ]);
    }
    return isMethod
      ? setId
        ? t$5.callExpression(file.addHelper("classPrivateFieldSet"), [
            this.receiver(member), t$5.cloneNode(id), value
          ])
        : t$5.sequenceExpression([
            this.receiver(member), value,
            t$5.callExpression(file.addHelper("readOnlyError"), [t$5.stringLiteral("#" + name)])
          ])
      : t$5.callExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), t$5.cloneNode(id), value]);
  },
  destructureSet(member) {
    const { classRef, privateNamesMap, file } = this,
      { name } = member.node.property.id,
      { id, static: isStatic } = privateNamesMap.get(name);
    if (isStatic) {
      try {
        var helper = file.addHelper("classStaticPrivateFieldDestructureSet");
      } catch (_unused) {
        throw new Error(
          "Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version."
        );
      }
      return t$5.memberExpression(
        t$5.callExpression(helper, [this.receiver(member), t$5.cloneNode(classRef), t$5.cloneNode(id)]),
        t$5.identifier("value")
      );
    }
    return t$5.memberExpression(
      t$5.callExpression(file.addHelper("classPrivateFieldDestructureSet"), [this.receiver(member), t$5.cloneNode(id)]),
      t$5.identifier("value")
    );
  },
  call(member, args) {
    this.memoise(member, 1);
    return optimiseCallExpression(this.get(member), this.receiver(member), args, false);
  },
  optionalCall(member, args) {
    this.memoise(member, 1);
    return optimiseCallExpression(this.get(member), this.receiver(member), args, true);
  },
  delete() {
    throw new Error("Internal Babel error: deleting private elements is a parsing error.");
  }
};
const privateNameHandlerLoose = {
  get(member) {
    const { privateNamesMap, file } = this,
      { object } = member.node,
      { name } = member.node.property.id;
    return template$1.expression`BASE(REF, PROP)[PROP]`({
      BASE: file.addHelper("classPrivateFieldLooseBase"),
      REF: t$5.cloneNode(object),
      PROP: t$5.cloneNode(privateNamesMap.get(name).id)
    });
  },
  set() {
    throw new Error("private name handler with loose = true don't need set()");
  },
  boundGet(member) {
    return t$5.callExpression(t$5.memberExpression(this.get(member), t$5.identifier("bind")), [
      t$5.cloneNode(member.node.object)
    ]);
  },
  simpleSet(member) {
    return this.get(member);
  },
  destructureSet(member) {
    return this.get(member);
  },
  call(member, args) {
    return t$5.callExpression(this.get(member), args);
  },
  optionalCall(member, args) {
    return t$5.optionalCallExpression(this.get(member), args, true);
  },
  delete() {
    throw new Error("Internal Babel error: deleting private elements is a parsing error.");
  }
};
function transformPrivateNamesUsage(ref, path, privateNamesMap, {
  privateFieldsAsProperties,
  noDocumentAll,
  innerBinding
}, state) {
  if (!privateNamesMap.size) return;
  const body = path.get("body"),
    handler = privateFieldsAsProperties ? privateNameHandlerLoose : privateNameHandlerSpec;
  memberExpressionToFunctions(body, privateNameVisitor,
    Object.assign({ privateNamesMap, classRef: ref, file: state }, handler, { noDocumentAll, innerBinding })
  );
  body.traverse(privateInVisitor, {
    privateNamesMap,
    classRef: ref,
    file: state,
    privateFieldsAsProperties,
    innerBinding
  });
}
function buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {
  const { id } = privateNamesMap.get(prop.node.key.id.name),
    value = prop.node.value || prop.scope.buildUndefinedNode();
  return inheritPropComments(template$1.statement.ast`
      Object.defineProperty(${ref}, ${t$5.cloneNode(id)}, { writable: true, value: ${value} });
    `, prop);
}
function buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap, state) {
  const { id } = privateNamesMap.get(prop.node.key.id.name),
    value = prop.node.value || prop.scope.buildUndefinedNode();

  if (!state.availableHelper("classPrivateFieldInitSpec"))
    return inheritPropComments(template$1.statement.ast`
        ${t$5.cloneNode(id)}.set(${ref}, { writable: true, value: ${value} })
      `, prop);

  const helper = state.addHelper("classPrivateFieldInitSpec");
  return inheritPropComments(template$1.statement.ast`
      ${helper}(${t$5.thisExpression()}, ${t$5.cloneNode(id)}, { writable: true, value: ${value} })
    `, prop);
}
function buildPrivateStaticFieldInitSpec(prop, privateNamesMap) {
  const privateName = privateNamesMap.get(prop.node.key.id.name),
    { id, getId, setId, initAdded } = privateName,
    isAccessor = getId || setId;
  if (!prop.isProperty() && (initAdded || !isAccessor)) return;
  if (isAccessor) {
    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, { initAdded: true }));
    return inheritPropComments(template$1.statement.ast`
        var ${t$5.cloneNode(id)} = {
          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
        }
      `, prop);
  }
  const value = prop.node.value || prop.scope.buildUndefinedNode();
  return inheritPropComments(template$1.statement.ast`
      var ${t$5.cloneNode(id)} = { writable: true, value: ${value} };
    `, prop);
}
function buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {
  const privateName = privateNamesMap.get(prop.node.key.id.name),
    { methodId, id, getId, setId, initAdded } = privateName;
  if (initAdded) return;
  if (methodId)
    return inheritPropComments(template$1.statement.ast`
        Object.defineProperty(${ref}, ${id}, { value: ${methodId.name} });
      `, prop);

  if (getId || setId) {
    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, { initAdded: true }));
    return inheritPropComments(template$1.statement.ast`
        Object.defineProperty(${ref}, ${id}, {
          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
        });
      `, prop);
  }
}
function buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap, state) {
  const privateName = privateNamesMap.get(prop.node.key.id.name),
    { getId, setId, initAdded } = privateName;
  if (!initAdded)
    return getId || setId
      ? buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state)
      : buildPrivateInstanceMethodInitialization(ref, prop, privateNamesMap, state);
}
function buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state) {
  const privateName = privateNamesMap.get(prop.node.key.id.name),
    { id, getId, setId } = privateName;
  privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, { initAdded: true }));

  if (!state.availableHelper("classPrivateFieldInitSpec"))
    return inheritPropComments(template$1.statement.ast`
        ${id}.set(${ref}, {
          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
        });
      `, prop);

  const helper = state.addHelper("classPrivateFieldInitSpec");
  return inheritPropComments(template$1.statement.ast`
      ${helper}(${t$5.thisExpression()}, ${t$5.cloneNode(id)}, {
        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
      })
    `, prop);
}
function buildPrivateInstanceMethodInitialization(ref, prop, privateNamesMap, state) {
  const privateName = privateNamesMap.get(prop.node.key.id.name),
    { id } = privateName;

  if (!state.availableHelper("classPrivateMethodInitSpec"))
    return inheritPropComments(template$1.statement.ast`${id}.add(${ref})`, prop);

  const helper = state.addHelper("classPrivateMethodInitSpec");
  return inheritPropComments(template$1.statement.ast`
      ${helper}(${t$5.thisExpression()}, ${t$5.cloneNode(id)})
    `, prop);
}
function buildPublicFieldInitLoose(ref, prop) {
  const { key, computed } = prop.node,
    value = prop.node.value || prop.scope.buildUndefinedNode();
  return inheritPropComments(t$5.expressionStatement(
    t$5.assignmentExpression("=", t$5.memberExpression(ref, key, computed || t$5.isLiteral(key)), value)
  ), prop);
}
function buildPublicFieldInitSpec(ref, prop, state) {
  const { key, computed } = prop.node,
    value = prop.node.value || prop.scope.buildUndefinedNode();
  return inheritPropComments(t$5.expressionStatement(
    t$5.callExpression(state.addHelper("defineProperty"), [
      ref, computed || t$5.isLiteral(key) ? key : t$5.stringLiteral(key.name), value
    ])
  ), prop);
}
function buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {
  const privateName = privateNamesMap.get(prop.node.key.id.name),
    { id, methodId, getId, setId, initAdded } = privateName;
  if (initAdded) return;
  if (getId || setId) {
    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, { initAdded: true }));
    return inheritPropComments(template$1.statement.ast`
        Object.defineProperty(${ref}, ${id}, {
          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
        })
      `, prop);
  }
  return inheritPropComments(template$1.statement.ast`
      Object.defineProperty(${ref}, ${id}, { value: ${methodId.name} });
    `, prop);
}
function buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties = false) {
  const privateName = privateNamesMap.get(prop.node.key.id.name),
    { id, methodId, getId, setId, getterDeclared, setterDeclared, static: isStatic } = privateName,
    { params, body, generator, async } = prop.node,
    isGetter = getId && !getterDeclared && params.length === 0,
    isSetter = setId && !setterDeclared && params.length > 0;
  let declId = methodId;
  if (isGetter) {
    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, { getterDeclared: true }));
    declId = getId;
  } else if (isSetter) {
    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, { setterDeclared: true }));
    declId = setId;
  } else if (isStatic && !privateFieldsAsProperties) declId = id;

  return inheritPropComments(t$5.functionDeclaration(t$5.cloneNode(declId), params, body, generator, async), prop);
}
const thisContextVisitor = traverse.visitors.merge([{
  UnaryExpression(path) {
    const { node } = path;
    if (node.operator === "delete") {
      const argument = skipTransparentExprWrapperNodes(node.argument);
      t$5.isThisExpression(argument) && path.replaceWith(t$5.booleanLiteral(true));
    }
  },
  ThisExpression(path, state) {
    state.needsClassRef = true;
    path.replaceWith(t$5.cloneNode(state.classRef));
  },
  MetaProperty(path) {
    const { node, scope } = path;
    node.meta.name !== "new" || node.property.name !== "target" || path.replaceWith(scope.buildUndefinedNode());
  }
}, visitor$5]);
const innerReferencesVisitor = {
  ReferencedIdentifier(path, state) {
    if (path.scope.bindingIdentifierEquals(path.node.name, state.innerBinding)) {
      state.needsClassRef = true;
      path.node.name = state.classRef.name;
    }
  }
};
function replaceThisContext(path, ref, innerBindingRef) {
  var _state$classRef;
  const state = { classRef: ref, needsClassRef: false, innerBinding: innerBindingRef };
  path.isMethod() || path.traverse(thisContextVisitor, state);

  innerBindingRef != null && (_state$classRef = state.classRef) != null &&
    _state$classRef.name && state.classRef.name !== innerBindingRef.name &&
    path.traverse(innerReferencesVisitor, state);

  return state.needsClassRef;
}
function isNameOrLength({ key, computed }) {
  return key.type === "Identifier"
    ? !computed && (key.name === "name" || key.name === "length")
    : key.type === "StringLiteral" && (key.value === "name" || key.value === "length");
}
function inheritPropComments(node, prop) {
  t$5.inheritLeadingComments(node, prop.node);
  t$5.inheritInnerComments(node, prop.node);
  return node;
}
function buildFieldsInitNodes(
  ref,
  superRef,
  props,
  privateNamesMap,
  file,
  setPublicClassFields,
  privateFieldsAsProperties,
  constantSuper,
  innerBindingRef
) {
  var _ref;
  let injectSuperRef,
    classRefFlags = 0;
  const staticNodes = [],
    instanceNodes = [],
    pureStaticNodes = [];
  let classBindingNode = null;
  const getSuperRef = t$5.isIdentifier(superRef) ? () => superRef : () => {
    injectSuperRef != null || (injectSuperRef = props[0].scope.generateUidIdentifierBasedOnNode(superRef));
    return injectSuperRef;
  };
  const classRefForInnerBinding = (_ref = ref) != null ? _ref : props[0].scope.generateUidIdentifier("class");
  ref != null || (ref = t$5.cloneNode(innerBindingRef));
  for (const prop of props) {
    prop.isClassProperty() && assertFieldTransformed(prop);
    const isStatic = !(t$5.isStaticBlock != null && t$5.isStaticBlock(prop.node)) && prop.node.static,
      isInstance = !isStatic,
      isPrivate = prop.isPrivate(),
      isPublic = !isPrivate,
      isField = prop.isProperty(),
      isMethod = !isField,
      isStaticBlock = prop.isStaticBlock == null ? void 0 : prop.isStaticBlock();
    if (isStatic) classRefFlags |= 1;
    if (isStatic || (isMethod && isPrivate) || isStaticBlock) {
      new ReplaceSupers({
        methodPath: prop,
        constantSuper,
        file,
        refToPreserve: innerBindingRef,
        getSuperRef,
        getObjectRef() {
          classRefFlags |= 2;
          return isStatic || isStaticBlock
            ? classRefForInnerBinding
            : t$5.memberExpression(classRefForInnerBinding, t$5.identifier("prototype"));
        }
      }).replace();
      if (replaceThisContext(prop, classRefForInnerBinding, innerBindingRef)) classRefFlags |= 2;
    }
    switch (true) {
      case isStaticBlock:
        const blockBody = prop.node.body;
        blockBody.length === 1 && t$5.isExpressionStatement(blockBody[0])
          ? staticNodes.push(inheritPropComments(blockBody[0], prop))
          : staticNodes.push(t$5.inheritsComments(template$1.statement.ast`(() => { ${blockBody} })()`, prop.node));

        break;

      case isStatic && isPrivate && isField && privateFieldsAsProperties:
        staticNodes.push(buildPrivateFieldInitLoose(t$5.cloneNode(ref), prop, privateNamesMap));
        break;
      case isStatic && isPrivate && isField && !privateFieldsAsProperties:
        staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));
        break;
      case isStatic && isPublic && isField && setPublicClassFields:
        if (!isNameOrLength(prop.node)) {
          staticNodes.push(buildPublicFieldInitLoose(t$5.cloneNode(ref), prop));
          break;
        }
      case isStatic && isPublic && isField && !setPublicClassFields:
        staticNodes.push(buildPublicFieldInitSpec(t$5.cloneNode(ref), prop, file));
        break;
      case isInstance && isPrivate && isField && privateFieldsAsProperties:
        instanceNodes.push(buildPrivateFieldInitLoose(t$5.thisExpression(), prop, privateNamesMap));
        break;
      case isInstance && isPrivate && isField && !privateFieldsAsProperties:
        instanceNodes.push(buildPrivateInstanceFieldInitSpec(t$5.thisExpression(), prop, privateNamesMap, file));
        break;
      case isInstance && isPrivate && isMethod && privateFieldsAsProperties:
        instanceNodes.unshift(buildPrivateMethodInitLoose(t$5.thisExpression(), prop, privateNamesMap));
        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
        break;
      case isInstance && isPrivate && isMethod && !privateFieldsAsProperties:
        instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(t$5.thisExpression(), prop, privateNamesMap, file));
        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
        break;
      case isStatic && isPrivate && isMethod && !privateFieldsAsProperties:
        staticNodes.unshift(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));
        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
        break;
      case isStatic && isPrivate && isMethod && privateFieldsAsProperties:
        staticNodes.unshift(buildPrivateStaticMethodInitLoose(t$5.cloneNode(ref), prop, file, privateNamesMap));
        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
        break;
      case isInstance && isPublic && isField && setPublicClassFields:
        instanceNodes.push(buildPublicFieldInitLoose(t$5.thisExpression(), prop));
        break;
      case isInstance && isPublic && isField && !setPublicClassFields:
        instanceNodes.push(buildPublicFieldInitSpec(t$5.thisExpression(), prop, file));
        break;
      default:
        throw new Error("Unreachable.");
    }
  }
  if (classRefFlags & 2 && innerBindingRef != null)
    classBindingNode = t$5.expressionStatement(
      t$5.assignmentExpression("=", t$5.cloneNode(classRefForInnerBinding), t$5.cloneNode(innerBindingRef))
    );

  return {
    staticNodes: staticNodes.filter(Boolean),
    instanceNodes: instanceNodes.filter(Boolean),
    pureStaticNodes: pureStaticNodes.filter(Boolean),
    classBindingNode,
    wrapClass(path) {
      for (const prop of props) {
        prop.node.leadingComments = null;
        prop.remove();
      }
      if (injectSuperRef) {
        path.scope.push({ id: t$5.cloneNode(injectSuperRef) });
        path.set("superClass", t$5.assignmentExpression("=", injectSuperRef, path.node.superClass));
      }
      if (classRefFlags !== 0)
        if (path.isClassExpression()) {
          path.scope.push({ id: ref });
          path.replaceWith(t$5.assignmentExpression("=", t$5.cloneNode(ref), path.node));
        } else {
          if (innerBindingRef == null) path.node.id = ref;

          classBindingNode == null || path.scope.push({ id: classRefForInnerBinding });
        }

      return path;
    }
  };
}

function hasOwnDecorators(node) {
  var _node$decorators;
  return !((_node$decorators = node.decorators) == null || !_node$decorators.length);
}
function hasDecorators(node) {
  return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);
}
function prop(key, value) {
  return value ? t$5.objectProperty(t$5.identifier(key), value) : null;
}
function method(key, body) {
  return t$5.objectMethod("method", t$5.identifier(key), [], t$5.blockStatement(body));
}
function takeDecorators(node) {
  let result;
  if (node.decorators && node.decorators.length > 0)
    result = t$5.arrayExpression(node.decorators.map(decorator => decorator.expression));

  node.decorators = void 0;
  return result;
}
function getKey(node) {
  return node.computed
    ? node.key
    : t$5.isIdentifier(node.key)
    ? t$5.stringLiteral(node.key.name)
    : t$5.stringLiteral(String(node.key.value));
}
function extractElementDescriptor(file, classRef, superRef, path) {
  const isMethod = path.isClassMethod();
  if (path.isPrivate())
    throw path.buildCodeFrameError(
      `Private ${isMethod ? "methods" : "fields"} in decorated classes are not supported yet.`
    );

  if (path.node.type === "ClassAccessorProperty")
    throw path.buildCodeFrameError(
      'Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.'
    );

  if (path.node.type === "StaticBlock")
    throw path.buildCodeFrameError(
      'Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.'
    );

  const { node, scope } = path;
  path.isTSDeclareMethod() ||
    new ReplaceSupers({ methodPath: path, objectRef: classRef, superRef, file, refToPreserve: classRef }).replace();

  const properties = [
    prop("kind", t$5.stringLiteral(t$5.isClassMethod(node) ? node.kind : "field")),
    prop("decorators", takeDecorators(node)),
    prop("static", node.static && t$5.booleanLiteral(true)),
    prop("key", getKey(node))
  ].filter(Boolean);
  if (t$5.isClassMethod(node)) {
    const id = node.computed ? null : node.key,
      transformed = t$5.toExpression(node);
    properties.push(prop("value", nameFunction({ node: transformed, id, scope }) || transformed));
  } else
    t$5.isClassProperty(node) && node.value
      ? properties.push(method("value", template$1.statements.ast`return ${node.value}`))
      : properties.push(prop("value", scope.buildUndefinedNode()));

  path.remove();
  return t$5.objectExpression(properties);
}
function addDecorateHelper(file) {
  return file.addHelper("decorate");
}
function buildDecoratedClass(ref, path, elements, file) {
  const { node, scope } = path,
    initializeId = scope.generateUidIdentifier("initialize"),
    isDeclaration = node.id && path.isDeclaration(),
    isStrict = path.isInStrictMode(),
    { superClass } = node;
  node.type = "ClassDeclaration";
  node.id || (node.id = t$5.cloneNode(ref));
  let superId;
  if (superClass) {
    superId = scope.generateUidIdentifierBasedOnNode(node.superClass, "super");
    node.superClass = superId;
  }
  const classDecorators = takeDecorators(node);
  const definitions = t$5.arrayExpression(elements
    .filter(element => !element.node.abstract && element.node.type !== "TSIndexSignature")
    .map(path => extractElementDescriptor(file, node.id, superId, path))
  );
  const wrapperCall = template$1.expression.ast`
    ${addDecorateHelper(file)}(
      ${classDecorators || t$5.nullLiteral()},
      function (${initializeId}, ${superClass ? t$5.cloneNode(superId) : null}) {
        ${node}
        return { F: ${t$5.cloneNode(node.id)}, d: ${definitions} };
      },
      ${superClass}
    )
  `;
  isStrict || wrapperCall.arguments[1].body.directives.push(t$5.directive(t$5.directiveLiteral("use strict")));

  let replacement = wrapperCall,
    classPathDesc = "arguments.1.body.body.0";
  if (isDeclaration) {
    replacement = template$1.statement.ast`let ${ref} = ${wrapperCall}`;
    classPathDesc = "declarations.0.init." + classPathDesc;
  }
  return {
    instanceNodes: [template$1.statement.ast`${t$5.cloneNode(initializeId)}(this)`],
    wrapClass(path) {
      path.replaceWith(replacement);
      return path.get(classPathDesc);
    }
  };
}

const findBareSupers = traverse.visitors.merge([{
  Super(path) {
    const { node, parentPath } = path;
    parentPath.isCallExpression({ callee: node }) && this.push(parentPath);
  }
}, visitor$5]);
const referenceVisitor = {
  "TSTypeAnnotation|TypeAnnotation"(path) {
    path.skip();
  },
  ReferencedIdentifier(path, { scope }) {
    if (scope.hasOwnBinding(path.node.name)) {
      scope.rename(path.node.name);
      path.skip();
    }
  }
};
function handleClassTDZ(path, state) {
  if (state.classBinding && state.classBinding === path.scope.getBinding(path.node.name)) {
    const classNameTDZError = state.file.addHelper("classNameTDZError"),
      throwNode = t$5.callExpression(classNameTDZError, [t$5.stringLiteral(path.node.name)]);
    path.replaceWith(t$5.sequenceExpression([throwNode, path.node]));
    path.skip();
  }
}
const classFieldDefinitionEvaluationTDZVisitor = { ReferencedIdentifier: handleClassTDZ };
function injectInitialization(path, constructor, nodes, renamer) {
  if (!nodes.length) return;
  const isDerived = !!path.node.superClass;
  if (!constructor) {
    const newConstructor = t$5.classMethod("constructor", t$5.identifier("constructor"), [], t$5.blockStatement([]));
    if (isDerived) {
      newConstructor.params = [t$5.restElement(t$5.identifier("args"))];
      newConstructor.body.body.push(template$1.statement.ast`super(...args)`);
    }
    [constructor] = path.get("body").unshiftContainer("body", newConstructor);
  }
  renamer && renamer(referenceVisitor, { scope: constructor.scope });

  if (isDerived) {
    const bareSupers = [];
    constructor.traverse(findBareSupers, bareSupers);
    let isFirst = true;
    for (const bareSuper of bareSupers)
      if (isFirst) {
        bareSuper.insertAfter(nodes);
        isFirst = false;
      } else bareSuper.insertAfter(nodes.map(n => t$5.cloneNode(n)));
  } else constructor.get("body").unshiftContainer("body", nodes);
}
function extractComputedKeys(path, computedPaths, file) {
  const declarations = [],
    state = { classBinding: path.node.id && path.scope.getBinding(path.node.id.name), file };
  for (const computedPath of computedPaths) {
    const computedKey = computedPath.get("key");
    computedKey.isReferencedIdentifier()
      ? handleClassTDZ(computedKey, state)
      : computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);

    const computedNode = computedPath.node;
    if (!computedKey.isConstantExpression()) {
      const ident = path.scope.generateUidIdentifierBasedOnNode(computedNode.key);
      path.scope.push({ id: ident, kind: "let" });
      declarations.push(t$5.expressionStatement(t$5.assignmentExpression("=", t$5.cloneNode(ident), computedNode.key)));
      computedNode.key = t$5.cloneNode(ident);
    }
  }
  return declarations;
}

const FEATURES$1 = Object.freeze({
  fields: 2,
  privateMethods: 4,
  decorators: 8,
  privateIn: 16,
  staticBlocks: 32
});
const featuresSameLoose = new Map([
  [FEATURES$1.fields, "@babel/plugin-transform-class-properties"],
  [FEATURES$1.privateMethods, "@babel/plugin-transform-private-methods"],
  [FEATURES$1.privateIn, "@babel/plugin-transform-private-property-in-object"]
]);
const featuresKey$1 = "@babel/plugin-class-features/featuresKey",
  looseKey = "@babel/plugin-class-features/looseKey",
  looseLowPriorityKey =
    "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";
function enableFeature$1(file, feature, loose) {
  if (!hasFeature$1(file, feature) || canIgnoreLoose(file, feature)) {
    file.set(featuresKey$1, file.get(featuresKey$1) | feature);
    if (loose === "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error") {
      setLoose(file, feature, true);
      file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature);
    } else if (loose === "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error") {
      setLoose(file, feature, false);
      file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature);
    } else setLoose(file, feature, loose);
  }
  let resolvedLoose, higherPriorityPluginName;
  for (const [mask, name] of featuresSameLoose) {
    if (!hasFeature$1(file, mask)) continue;
    const loose = isLoose(file, mask);
    if (canIgnoreLoose(file, mask)) continue;
    if (resolvedLoose === !loose)
      throw new Error(
        "'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled)."
      );

    resolvedLoose = loose;
    higherPriorityPluginName = name;
  }
  if (resolvedLoose !== void 0)
    for (const [mask, name] of featuresSameLoose)
      if (hasFeature$1(file, mask) && isLoose(file, mask) !== resolvedLoose) {
        setLoose(file, mask, resolvedLoose);
        console.warn(`Though the "loose" option was set to "${!resolvedLoose}" in your @babel/preset-env config, it will not be used for ${name} since the "loose" mode option was set to "${resolvedLoose}" for ${higherPriorityPluginName}.
The "loose" option must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding
\t["${name}", { "loose": ${resolvedLoose} }]
to the "plugins" section of your Babel config.`);
      }
}
function hasFeature$1(file, feature) {
  return !!(file.get(featuresKey$1) & feature);
}
function isLoose(file, feature) {
  return !!(file.get(looseKey) & feature);
}
function setLoose(file, feature, loose) {
  loose ? file.set(looseKey, file.get(looseKey) | feature) : file.set(looseKey, file.get(looseKey) & ~feature);
  file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) & ~feature);
}
function canIgnoreLoose(file, feature) {
  return !!(file.get(looseLowPriorityKey) & feature);
}
function shouldTransform$2(path, file) {
  let decoratorPath = null,
    publicFieldPath = null,
    privateFieldPath = null,
    privateMethodPath = null,
    staticBlockPath = null;
  if (hasOwnDecorators(path.node)) decoratorPath = path.get("decorators.0");

  for (const el of path.get("body.body")) {
    if (!decoratorPath && hasOwnDecorators(el.node)) decoratorPath = el.get("decorators.0");

    if (!publicFieldPath && el.isClassProperty()) publicFieldPath = el;
    if (!privateFieldPath && el.isClassPrivateProperty()) privateFieldPath = el;

    if (!privateMethodPath && el.isClassPrivateMethod != null && el.isClassPrivateMethod()) privateMethodPath = el;

    if (!staticBlockPath && el.isStaticBlock != null && el.isStaticBlock()) staticBlockPath = el;
  }
  if (decoratorPath && privateFieldPath)
    throw privateFieldPath.buildCodeFrameError("Private fields in decorated classes are not supported yet.");

  if (decoratorPath && privateMethodPath)
    throw privateMethodPath.buildCodeFrameError("Private methods in decorated classes are not supported yet.");

  if (decoratorPath && !hasFeature$1(file, FEATURES$1.decorators))
    throw path.buildCodeFrameError(`Decorators are not enabled.
If you are using ["@babel/plugin-proposal-decorators", { "version": "legacy" }], make sure it comes *before* "@babel/plugin-transform-class-properties" and enable loose mode, like so:
\t["@babel/plugin-proposal-decorators", { "version": "legacy" }]
\t["@babel/plugin-transform-class-properties", { "loose": true }]`);

  if (privateMethodPath && !hasFeature$1(file, FEATURES$1.privateMethods))
    throw privateMethodPath.buildCodeFrameError(
      "Class private methods are not enabled. Please add `@babel/plugin-transform-private-methods` to your configuration."
    );

  if (
    (publicFieldPath || privateFieldPath) &&
    !hasFeature$1(file, FEATURES$1.fields) && !hasFeature$1(file, FEATURES$1.privateMethods)
  )
    throw path.buildCodeFrameError(
      "Class fields are not enabled. Please add `@babel/plugin-transform-class-properties` to your configuration."
    );

  if (staticBlockPath && !hasFeature$1(file, FEATURES$1.staticBlocks))
    throw path.buildCodeFrameError(
      "Static class blocks are not enabled. Please add `@babel/plugin-transform-class-static-block` to your configuration."
    );

  return (
    !!(decoratorPath || privateMethodPath || staticBlockPath) ||
    !((!publicFieldPath && !privateFieldPath) || !hasFeature$1(file, FEATURES$1.fields))
  );
}

const versionKey$1 = "@babel/plugin-class-features/version";
function createClassFeaturePlugin({ name, feature, loose, manipulateOptions, api, inherits }) {
  api != null || (api = { assumption: () => void 0 });

  const setPublicClassFields = api.assumption("setPublicClassFields"),
    privateFieldsAsSymbols = api.assumption("privateFieldsAsSymbols"),
    privateFieldsAsProperties = api.assumption("privateFieldsAsProperties"),
    constantSuper = api.assumption("constantSuper"),
    noDocumentAll = api.assumption("noDocumentAll");
  if (privateFieldsAsProperties && privateFieldsAsSymbols)
    throw new Error(
      'Cannot enable both the "privateFieldsAsProperties" and "privateFieldsAsSymbols" assumptions as the same time.'
    );

  const privateFieldsAsSymbolsOrProperties = privateFieldsAsProperties || privateFieldsAsSymbols;
  if (loose === true) {
    const explicit = [];
    setPublicClassFields === void 0 || explicit.push('"setPublicClassFields"');

    privateFieldsAsProperties === void 0 || explicit.push('"privateFieldsAsProperties"');
    privateFieldsAsSymbols === void 0 || explicit.push('"privateFieldsAsSymbols"');

    explicit.length > 0 &&
      console.warn(
        `[${name}]: You are using the "loose: true" option and you are explicitly setting a value for the ${explicit.join(" and ")} assumption${
          explicit.length > 1 ? "s" : ""
        }. The "loose" option can cause incompatibilities with the other class features plugins, so it's recommended that you replace it with the following top-level option:
\t"assumptions": {
\t\t"setPublicClassFields": true,
\t\t"privateFieldsAsSymbols": true
\t}`
      );
  }
  return {
    name,
    manipulateOptions,
    inherits,
    pre(file) {
      enableFeature$1(file, feature, loose);

      (typeof file.get(versionKey$1) != "number" &&
        file.get(versionKey$1) && !vendors.semver.lt(file.get(versionKey$1), "7.22.15")) ||
        file.set(versionKey$1, "7.22.15");
    },
    visitor: {
      Class(path, { file }) {
        var _ref;
        if (file.get(versionKey$1) !== "7.22.15" || !shouldTransform$2(path, file)) return;
        const pathIsClassDeclaration = path.isClassDeclaration();
        pathIsClassDeclaration && assertFieldTransformed(path);
        const loose = isLoose(file, feature);
        let constructor;
        const isDecorated = hasDecorators(path.node),
          props = [],
          elements = [],
          computedPaths = [],
          privateNames = new Set(),
          body = path.get("body");
        for (const path of body.get("body")) {
          (path.isClassProperty() || path.isClassMethod()) && path.node.computed && computedPaths.push(path);

          if (path.isPrivate()) {
            const { name } = path.node.key.id,
              getName = "get " + name,
              setName = "set " + name;
            if (path.isClassPrivateMethod()) {
              if (path.node.kind === "get") {
                if (privateNames.has(getName) || (privateNames.has(name) && !privateNames.has(setName)))
                  throw path.buildCodeFrameError("Duplicate private field");

                privateNames.add(getName).add(name);
              } else if (path.node.kind === "set") {
                if (privateNames.has(setName) || (privateNames.has(name) && !privateNames.has(getName)))
                  throw path.buildCodeFrameError("Duplicate private field");

                privateNames.add(setName).add(name);
              }
            } else {
              if (
                (privateNames.has(name) && !privateNames.has(getName) && !privateNames.has(setName)) ||
                (privateNames.has(name) && (privateNames.has(getName) || privateNames.has(setName)))
              )
                throw path.buildCodeFrameError("Duplicate private field");

              privateNames.add(name);
            }
          }
          if (path.isClassMethod({ kind: "constructor" })) constructor = path;
          else {
            elements.push(path);
            if (path.isProperty() || path.isPrivate() || (path.isStaticBlock != null && path.isStaticBlock()))
              props.push(path);
          }
        }

        if (!props.length && !isDecorated) return;

        const innerBinding = path.node.id;
        let ref;
        if (!innerBinding || !pathIsClassDeclaration) {
          nameFunction(path);
          ref = path.scope.generateUidIdentifier("class");
        }
        const classRefForDefine = (_ref = ref) != null ? _ref : t$5.cloneNode(innerBinding),
          privateNamesMap = buildPrivateNamesMap(props);
        const privateNamesNodes = buildPrivateNamesNodes(
          privateNamesMap,
          privateFieldsAsProperties != null ? privateFieldsAsProperties : loose,
          privateFieldsAsSymbols != null && privateFieldsAsSymbols, file
        );
        transformPrivateNamesUsage(classRefForDefine, path, privateNamesMap, {
          privateFieldsAsProperties:
            privateFieldsAsSymbolsOrProperties != null ? privateFieldsAsSymbolsOrProperties : loose,
          noDocumentAll,
          innerBinding
        }, file);
        let keysNodes, staticNodes, instanceNodes, pureStaticNodes, classBindingNode, wrapClass;

        if (isDecorated) {
          staticNodes = pureStaticNodes = keysNodes = [];
          ({ instanceNodes, wrapClass } = buildDecoratedClass(classRefForDefine, path, elements, file));
        } else {
          keysNodes = extractComputedKeys(path, computedPaths, file);
          ({ staticNodes, pureStaticNodes, instanceNodes, classBindingNode, wrapClass } = buildFieldsInitNodes(
            ref, path.node.superClass, props, privateNamesMap, file,
            setPublicClassFields != null ? setPublicClassFields : loose,
            privateFieldsAsSymbolsOrProperties != null ? privateFieldsAsSymbolsOrProperties : loose,
            constantSuper != null ? constantSuper : loose, innerBinding
          ));
        }

        instanceNodes.length > 0 &&
          injectInitialization(path, constructor, instanceNodes, (referenceVisitor, state) => {
            if (isDecorated) return;

            for (const prop of props)
              (t$5.isStaticBlock != null && t$5.isStaticBlock(prop.node)) || prop.node.static ||
                prop.traverse(referenceVisitor, state);
          });

        const wrappedPath = wrapClass(path);
        wrappedPath.insertBefore([...privateNamesNodes, ...keysNodes]);
        staticNodes.length > 0 && wrappedPath.insertAfter(staticNodes);

        pureStaticNodes.length > 0 &&
          wrappedPath.find(parent => parent.isStatement() || parent.isDeclaration()).insertAfter(pureStaticNodes);

        classBindingNode != null && pathIsClassDeclaration && wrappedPath.insertAfter(classBindingNode);
      },
      ExportDefaultDeclaration(path, { file }) {
        if (file.get(versionKey$1) !== "7.22.15") return;
        const decl = path.get("declaration");
        if (decl.isClassDeclaration() && hasDecorators(decl.node))
          decl.node.id ? splitExportDeclaration(path) : (decl.node.type = "ClassExpression");
      }
    }
  };
}

const ENUMS = new WeakMap();
const buildEnumWrapper = template$1.expression(`
    (function (ID) {
      ASSIGNMENTS;
      return ID;
    })(INIT)
  `);
function transpileEnum(path, t) {
  const { node, parentPath } = path;
  if (node.declare) {
    path.remove();
    return;
  }
  const name = node.id.name,
    { fill, data, isPure } = enumFill(path, t, node.id);
  switch (parentPath.type) {
    case "BlockStatement":
    case "ExportNamedDeclaration":
    case "Program":
      const isGlobal = t.isProgram(path.parent),
        isSeen = seen(parentPath);
      let init = t.objectExpression([]);
      if (isSeen || isGlobal) init = t.logicalExpression("||", t.cloneNode(fill.ID), init);

      const enumIIFE = buildEnumWrapper(Object.assign({}, fill, { INIT: init }));
      isPure && annotateAsPure(enumIIFE);
      isSeen
        ? (parentPath.isExportDeclaration() ? parentPath : path).replaceWith(
            t.expressionStatement(t.assignmentExpression("=", t.cloneNode(node.id), enumIIFE))
          )
        : path.scope.registerDeclaration(path.replaceWith(
            t.variableDeclaration(isGlobal ? "var" : "let", [t.variableDeclarator(node.id, enumIIFE)])
          )[0]);

      ENUMS.set(path.scope.getBindingIdentifier(name), data);
      break;

    default:
      throw new Error("Unexpected enum parent '" + path.parent.type);
  }
  function seen(parentPath) {
    if (parentPath.isExportDeclaration()) return seen(parentPath.parentPath);

    if (parentPath.getData(name)) return true;

    parentPath.setData(name, true);
    return false;
  }
}
const buildStringAssignment = template$1.default(`
  ENUM["NAME"] = VALUE;
`);
const buildNumericAssignment = template$1.default(`
  ENUM[(ENUM["NAME"] = VALUE)] = "NAME";
`);
const buildEnumMember = (isString, options) => (isString ? buildStringAssignment : buildNumericAssignment)(options);
function enumFill(path, t, id) {
  const { enumValues: x, data, isPure } = translateEnumValues(path, t);
  const assignments = x.map(([memberName, memberValue]) =>
    buildEnumMember(t.isStringLiteral(memberValue), { ENUM: t.cloneNode(id), NAME: memberName, VALUE: memberValue })
  );
  return { fill: { ID: t.cloneNode(id), ASSIGNMENTS: assignments }, data, isPure };
}
function ReferencedIdentifier(expr, state) {
  const { seen, path, t } = state,
    name = expr.node.name;
  if (seen.has(name) && !expr.scope.hasOwnBinding(name)) {
    expr.replaceWith(t.memberExpression(t.cloneNode(path.node.id), t.cloneNode(expr.node)));
    expr.skip();
  }
}
const enumSelfReferenceVisitor = { ReferencedIdentifier };
function translateEnumValues(path, t) {
  const seen = new Map();
  let lastName,
    constValue = -1,
    isPure = true;
  const enumValues = path.get("members").map(memberPath => {
    const member = memberPath.node,
      name = t.isIdentifier(member.id) ? member.id.name : member.id.value,
      initializerPath = memberPath.get("initializer");
    let value;
    if (member.initializer) {
      constValue = computeConstantValue(initializerPath, seen);
      if (constValue !== void 0) {
        seen.set(name, constValue);
        assert(typeof constValue == "number" || typeof constValue == "string");
        value = constValue === Infinity || Number.isNaN(constValue)
          ? t.identifier(String(constValue))
          : constValue === -Infinity
          ? t.unaryExpression("-", t.identifier("Infinity"))
          : t.valueToNode(constValue);
      } else {
        isPure && (isPure = initializerPath.isPure());
        initializerPath.isReferencedIdentifier()
          ? ReferencedIdentifier(initializerPath, { t, seen, path })
          : initializerPath.traverse(enumSelfReferenceVisitor, { t, seen, path });

        value = initializerPath.node;
        seen.set(name, void 0);
      }
    } else if (typeof constValue == "number") {
      constValue += 1;
      value = t.numericLiteral(constValue);
      seen.set(name, constValue);
    } else {
      if (typeof constValue == "string") throw path.buildCodeFrameError("Enum member must have initializer.");

      const lastRef = t.memberExpression(t.cloneNode(path.node.id), t.stringLiteral(lastName), true);
      value = t.binaryExpression("+", t.numericLiteral(1), lastRef);
      seen.set(name, void 0);
    }
    lastName = name;
    return [name, value];
  });
  return { isPure, data: seen, enumValues };
}
function computeConstantValue(path, prevMembers, seen = new Set()) {
  return evaluate(path);
  function evaluate(path) {
    const expr = path.node;
    switch (expr.type) {
      case "MemberExpression":
        return evaluateRef(path, prevMembers, seen);
      case "StringLiteral":
        return expr.value;
      case "UnaryExpression":
        return evalUnaryExpression(path);
      case "BinaryExpression":
        return evalBinaryExpression(path);
      case "NumericLiteral":
        return expr.value;
      case "ParenthesizedExpression":
        return evaluate(path.get("expression"));
      case "Identifier":
        return evaluateRef(path, prevMembers, seen);
      case "TemplateLiteral":
        if (expr.quasis.length === 1) return expr.quasis[0].value.cooked;

        const paths = path.get("expressions"),
          quasis = expr.quasis;
        let str = "";
        for (let i = 0; i < quasis.length; i++) {
          str += quasis[i].value.cooked;
          if (i + 1 < quasis.length) {
            const value = evaluateRef(paths[i], prevMembers, seen);
            if (value === void 0) return void 0;
            str += value;
          }
        }
        return str;

      default:
        return void 0;
    }
  }
  function evaluateRef(path, prevMembers, seen) {
    if (path.isMemberExpression()) {
      const expr = path.node,
        obj = expr.object,
        prop = expr.property;
      if (!t$5.isIdentifier(obj) || (expr.computed ? !t$5.isStringLiteral(prop) : !t$5.isIdentifier(prop))) return;

      const bindingIdentifier = path.scope.getBindingIdentifier(obj.name),
        data = ENUMS.get(bindingIdentifier);
      if (!data) return;
      return data.get(prop.computed ? prop.value : prop.name);
    }
    if (path.isIdentifier()) {
      const name = path.node.name;
      if (["Infinity", "NaN"].includes(name)) return Number(name);

      let value = prevMembers == null ? void 0 : prevMembers.get(name);
      if (value !== void 0) return value;

      if (seen.has(path.node)) return;
      const bindingInitPath = path.resolve();
      if (bindingInitPath) {
        seen.add(path.node);
        value = computeConstantValue(bindingInitPath, void 0, seen);
        prevMembers == null || prevMembers.set(name, value);
        return value;
      }
    }
  }
  function evalUnaryExpression(path) {
    const value = evaluate(path.get("argument"));
    if (value === void 0) return void 0;

    switch (path.node.operator) {
      case "+":
        return value;
      case "-":
        return -value;
      case "~":
        return ~value;
      default:
        return void 0;
    }
  }
  function evalBinaryExpression(path) {
    const left = evaluate(path.get("left"));
    if (left === void 0) return void 0;

    const right = evaluate(path.get("right"));
    if (right === void 0) return void 0;

    switch (path.node.operator) {
      case "|":
        return left | right;
      case "&":
        return left & right;
      case ">>":
        return left >> right;
      case ">>>":
        return left >>> right;
      case "<<":
        return left << right;
      case "^":
        return left ^ right;
      case "*":
        return left * right;
      case "/":
        return left / right;
      case "+":
        return left + right;
      case "-":
        return left - right;
      case "%":
        return left % right;
      case "**":
        return Math.pow(left, right);
      default:
        return void 0;
    }
  }
}

function transpileConstEnum(path, t) {
  const { name } = path.node.id,
    parentIsExport = path.parentPath.isExportNamedDeclaration();
  let isExported = parentIsExport;
  if (!isExported && t.isProgram(path.parent))
    isExported = path.parent.body.some(stmt =>
      t.isExportNamedDeclaration(stmt) && stmt.exportKind !== "type" && !stmt.source &&
      stmt.specifiers.some(spec => t.isExportSpecifier(spec) && spec.exportKind !== "type" && spec.local.name === name)
    );

  const { enumValues: entries } = translateEnumValues(path, t);
  if (isExported) {
    const obj = t.objectExpression(entries.map(([name, value]) =>
      t.objectProperty(t.isValidIdentifier(name) ? t.identifier(name) : t.stringLiteral(name), value)
    ));
    if (path.scope.hasOwnBinding(name))
      (parentIsExport ? path.parentPath : path).replaceWith(t.expressionStatement(
        t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("assign")), [path.node.id, obj])
      ));
    else {
      path.replaceWith(t.variableDeclaration("var", [t.variableDeclarator(path.node.id, obj)]));
      path.scope.registerDeclaration(path);
    }
    return;
  }
  const entriesMap = new Map(entries);
  path.scope.path.traverse({
    Scope(path) {
      path.scope.hasOwnBinding(name) && path.skip();
    },
    MemberExpression(path) {
      if (!t.isIdentifier(path.node.object, { name })) return;
      let key;
      if (path.node.computed) {
        if (!t.isStringLiteral(path.node.property)) return;

        key = path.node.property.value;
      } else if (t.isIdentifier(path.node.property)) key = path.node.property.name;
      else return;

      entriesMap.has(key) && path.replaceWith(t.cloneNode(entriesMap.get(key)));
    }
  });
  path.remove();
}

function transpileNamespace(path, allowNamespaces) {
  if (path.node.declare || path.node.id.type === "StringLiteral") {
    path.remove();
    return;
  }
  if (!allowNamespaces)
    throw path.get("id").buildCodeFrameError(
      "Namespace not marked type-only declare. Non-declarative namespaces are only supported experimentally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript"
    );

  const name = path.node.id.name,
    value = handleNested(path, t$5.cloneNode(path.node, true));
  value === null
    ? path.remove()
    : path.scope.hasOwnBinding(name)
    ? path.replaceWith(value)
    : path.scope.registerDeclaration(path.replaceWithMultiple([getDeclaration(name), value])[0]);
}
function getDeclaration(name) {
  return t$5.variableDeclaration("let", [t$5.variableDeclarator(t$5.identifier(name))]);
}
function getMemberExpression(name, itemName) {
  return t$5.memberExpression(t$5.identifier(name), t$5.identifier(itemName));
}
function handleVariableDeclaration(node, name, hub) {
  if (node.kind !== "const")
    throw hub.file.buildCodeFrameError(node,
      "Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babeljs.io/docs/en/babel-plugin-transform-typescript"
    );

  const { declarations } = node;
  if (declarations.every(declarator => t$5.isIdentifier(declarator.id))) {
    for (const declarator of declarations)
      declarator.init = t$5.assignmentExpression("=", getMemberExpression(name, declarator.id.name), declarator.init);

    return [node];
  }
  const bindingIdentifiers = t$5.getBindingIdentifiers(node),
    assignments = [];
  for (const idName in bindingIdentifiers)
    assignments.push(
      t$5.assignmentExpression("=", getMemberExpression(name, idName), t$5.cloneNode(bindingIdentifiers[idName]))
    );

  return [node, t$5.expressionStatement(t$5.sequenceExpression(assignments))];
}
function buildNestedAmbientModuleError(path, node) {
  return path.hub.buildError(node, "Ambient modules cannot be nested in other modules or namespaces.", Error);
}
function handleNested(path, node, parentExport) {
  const names = new Set(),
    realName = node.id;
  t$5.assertIdentifier(realName);
  const name = path.scope.generateUid(realName.name),
    namespaceTopLevel = t$5.isTSModuleBlock(node.body) ? node.body.body : [t$5.exportNamedDeclaration(node.body)];
  let isEmpty = true;
  for (let i = 0; i < namespaceTopLevel.length; i++) {
    const subNode = namespaceTopLevel[i];
    switch (subNode.type) {
      case "TSModuleDeclaration":
        if (!t$5.isIdentifier(subNode.id)) throw buildNestedAmbientModuleError(path, subNode);

        const transformed = handleNested(path, subNode);
        if (transformed !== null) {
          isEmpty = false;
          const moduleName = subNode.id.name;
          if (names.has(moduleName)) namespaceTopLevel[i] = transformed;
          else {
            names.add(moduleName);
            namespaceTopLevel.splice(i++, 1, getDeclaration(moduleName), transformed);
          }
        }
        continue;

      case "TSEnumDeclaration":
      case "FunctionDeclaration":
      case "ClassDeclaration":
        isEmpty = false;
        names.add(subNode.id.name);
        continue;
      case "VariableDeclaration":
        isEmpty = false;
        for (const name in t$5.getBindingIdentifiers(subNode)) names.add(name);

        continue;

      default:
        isEmpty && (isEmpty = t$5.isTypeScript(subNode));
        continue;
      case "ExportNamedDeclaration":
    }
    if ("declare" in subNode.declaration && subNode.declaration.declare) continue;

    switch (subNode.declaration.type) {
      case "TSEnumDeclaration":
      case "FunctionDeclaration":
      case "ClassDeclaration": {
        isEmpty = false;
        const itemName = subNode.declaration.id.name;
        names.add(itemName);
        namespaceTopLevel.splice(i++, 1, subNode.declaration,
          t$5.expressionStatement(
            t$5.assignmentExpression("=", getMemberExpression(name, itemName), t$5.identifier(itemName))
          )
        );
        break;
      }
      case "VariableDeclaration": {
        isEmpty = false;
        const nodes = handleVariableDeclaration(subNode.declaration, name, path.hub);
        namespaceTopLevel.splice(i, nodes.length, ...nodes);
        i += nodes.length - 1;
        break;
      }
      case "TSModuleDeclaration": {
        if (!t$5.isIdentifier(subNode.declaration.id)) throw buildNestedAmbientModuleError(path, subNode.declaration);

        const transformed = handleNested(path, subNode.declaration, t$5.identifier(name));
        if (transformed !== null) {
          isEmpty = false;
          const moduleName = subNode.declaration.id.name;
          if (names.has(moduleName)) namespaceTopLevel[i] = transformed;
          else {
            names.add(moduleName);
            namespaceTopLevel.splice(i++, 1, getDeclaration(moduleName), transformed);
          }
        } else {
          namespaceTopLevel.splice(i, 1);
          i--;
        }
      }
    }
  }
  if (isEmpty) return null;
  let fallthroughValue = t$5.objectExpression([]);
  if (parentExport) {
    const memberExpr = t$5.memberExpression(parentExport, realName);
    fallthroughValue = template$1.expression.ast`
      ${t$5.cloneNode(memberExpr)} || (${t$5.cloneNode(memberExpr)} = ${fallthroughValue})
    `;
  }
  return template$1.statement.ast`
    (function (${t$5.identifier(name)}) {
      ${namespaceTopLevel}
    })(${realName} || (${t$5.cloneNode(realName)} = ${fallthroughValue}));
  `;
}

function isInType(path) {
  switch (path.parent.type) {
    case "TSTypeReference":
    case "TSExpressionWithTypeArguments":
    case "TSTypeQuery":
      return true;
    case "TSQualifiedName":
      return path.parentPath.findParent(path => path.type !== "TSQualifiedName").type !== "TSImportEqualsDeclaration";
    case "ExportSpecifier":
      return path.parent.exportKind === "type" || path.parentPath.parent.exportKind === "type";
    default:
      return false;
  }
}
const GLOBAL_TYPES = new WeakMap(),
  NEEDS_EXPLICIT_ESM = new WeakMap(),
  PARSED_PARAMS = new WeakSet();
function isGlobalType({ scope }, name) {
  if (scope.hasBinding(name)) return false;
  if (GLOBAL_TYPES.get(scope).has(name)) return true;
  console.warn(
    `The exported identifier "${name}" is not declared in Babel's scope tracker
as a JavaScript value binding, and "@babel/plugin-transform-typescript"
never encountered it as a TypeScript type declaration.
It will be treated as a JavaScript value.\n
This problem is likely caused by another plugin injecting
"${name}" without registering it in the scope tracker. If you are the author
 of that plugin, please use "scope.registerDeclaration(declarationPath)".`
  );
  return false;
}
function registerGlobalType(programScope, name) {
  GLOBAL_TYPES.get(programScope).add(name);
}
function safeRemove(path) {
  const ids = path.getBindingIdentifiers();
  for (const name of Object.keys(ids)) {
    const binding = path.scope.getBinding(name);
    binding && binding.identifier === ids[name] && binding.scope.removeBinding(name);
  }
  path.opts.noScope = true;
  path.remove();
  path.opts.noScope = false;
}
function assertCjsTransformEnabled(path, pass, wrong, suggestion, extra = "") {
  if (pass.file.get("@babel/plugin-transform-modules-*") !== "commonjs")
    throw path.buildCodeFrameError(
      `\`${wrong}\` is only supported when compiling modules to CommonJS.
Please consider using \`${suggestion}\`${extra}, or add @babel/plugin-transform-modules-commonjs to your Babel config.`
    );
}
var transformTypescript = declare((api, opts) => {
  const { types: t, template } = api;
  api.assertVersion(7);
  const JSX_PRAGMA_REGEX = /\*?\s*@jsx((?:Frag)?)\s+([^\s]+)/;
  const {
    allowNamespaces = true,
    jsxPragma = "React.createElement",
    jsxPragmaFrag = "React.Fragment",
    onlyRemoveTypeImports = false,
    optimizeConstEnums = false
  } = opts;

  var { allowDeclareFields = false } = opts;

  const classMemberVisitors = {
    field(path) {
      const { node } = path;

      if (!allowDeclareFields && node.declare)
        throw path.buildCodeFrameError(
          "The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transform-typescript or @babel/preset-typescript is enabled."
        );

      if (node.declare) {
        if (node.value)
          throw path.buildCodeFrameError(
            "Fields with the 'declare' modifier cannot be initialized here, but only in the constructor"
          );

        node.decorators || path.remove();
      } else if (node.definite) {
        if (node.value)
          throw path.buildCodeFrameError(
            "Definitely assigned fields cannot be initialized here, but only in the constructor"
          );

        allowDeclareFields || node.decorators || t.isClassPrivateProperty(node) || path.remove();
      } else
        node.abstract
          ? path.remove()
          : allowDeclareFields || node.value || node.decorators || t.isClassPrivateProperty(node) || path.remove();

      if (node.accessibility) node.accessibility = null;
      if (node.abstract) node.abstract = null;
      if (node.readonly) node.readonly = null;
      if (node.optional) node.optional = null;
      if (node.typeAnnotation) node.typeAnnotation = null;
      if (node.definite) node.definite = null;
      if (node.declare) node.declare = null;
      if (node.override) node.override = null;
    },
    method({ node }) {
      if (node.accessibility) node.accessibility = null;
      if (node.abstract) node.abstract = null;
      if (node.optional) node.optional = null;
      if (node.override) node.override = null;
    },
    constructor(path, classPath) {
      if (path.node.accessibility) path.node.accessibility = null;
      const assigns = [],
        { scope } = path;
      for (const paramPath of path.get("params")) {
        const param = paramPath.node;
        if (param.type === "TSParameterProperty") {
          const parameter = param.parameter;
          if (PARSED_PARAMS.has(parameter)) continue;
          PARSED_PARAMS.add(parameter);
          let id;
          if (t.isIdentifier(parameter)) id = parameter;
          else if (t.isAssignmentPattern(parameter) && t.isIdentifier(parameter.left)) id = parameter.left;
          else throw paramPath.buildCodeFrameError("Parameter properties can not be destructuring patterns.");

          assigns.push(template.statement.ast`
          this.${t.cloneNode(id)} = ${t.cloneNode(id)}`);
          paramPath.replaceWith(paramPath.get("parameter"));
          scope.registerBinding("param", paramPath);
        }
      }
      injectInitialization(classPath, path, assigns);
    }
  };
  return {
    name: "transform-typescript",
    inherits: syntaxTypescript,
    visitor: {
      Pattern: visitPattern,
      Identifier: visitPattern,
      RestElement: visitPattern,
      Program: {
        enter(path, state) {
          const { file } = state;
          let fileJsxPragma = null,
            fileJsxPragmaFrag = null;
          const programScope = path.scope;
          GLOBAL_TYPES.has(programScope) || GLOBAL_TYPES.set(programScope, new Set());

          if (file.ast.comments)
            for (const comment of file.ast.comments) {
              const jsxMatches = JSX_PRAGMA_REGEX.exec(comment.value);
              if (jsxMatches) jsxMatches[1] ? (fileJsxPragmaFrag = jsxMatches[2]) : (fileJsxPragma = jsxMatches[2]);
            }

          let pragmaImportName = fileJsxPragma || jsxPragma;
          if (pragmaImportName) [pragmaImportName] = pragmaImportName.split(".");

          let pragmaFragImportName = fileJsxPragmaFrag || jsxPragmaFrag;
          if (pragmaFragImportName) [pragmaFragImportName] = pragmaFragImportName.split(".");

          for (let stmt of path.get("body")) {
            if (stmt.isImportDeclaration()) {
              NEEDS_EXPLICIT_ESM.has(state.file.ast.program) || NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);

              if (stmt.node.importKind === "type") {
                for (const specifier of stmt.node.specifiers) registerGlobalType(programScope, specifier.local.name);

                stmt.remove();
                continue;
              }
              const importsToRemove = new Set(),
                specifiersLength = stmt.node.specifiers.length,
                isAllSpecifiersElided = () => specifiersLength > 0 && specifiersLength === importsToRemove.size;
              for (const specifier of stmt.node.specifiers)
                if (specifier.type === "ImportSpecifier" && specifier.importKind === "type") {
                  registerGlobalType(programScope, specifier.local.name);
                  const binding = stmt.scope.getBinding(specifier.local.name);
                  binding && importsToRemove.add(binding.path);
                }

              if (onlyRemoveTypeImports) NEEDS_EXPLICIT_ESM.set(path.node, false);
              else {
                if (stmt.node.specifiers.length === 0) {
                  NEEDS_EXPLICIT_ESM.set(path.node, false);
                  continue;
                }
                for (const specifier of stmt.node.specifiers) {
                  const binding = stmt.scope.getBinding(specifier.local.name);
                  if (binding && !importsToRemove.has(binding.path))
                    isImportTypeOnly({ binding, programPath: path, pragmaImportName, pragmaFragImportName })
                      ? importsToRemove.add(binding.path)
                      : NEEDS_EXPLICIT_ESM.set(path.node, false);
                }
              }
              if (isAllSpecifiersElided() && !onlyRemoveTypeImports) stmt.remove();
              else for (const importPath of importsToRemove) importPath.remove();

              continue;
            }
            if (stmt.isExportDeclaration()) stmt = stmt.get("declaration");

            if (stmt.isVariableDeclaration({ declare: true }))
              for (const name of Object.keys(stmt.getBindingIdentifiers())) registerGlobalType(programScope, name);
            else
              (stmt.isTSTypeAliasDeclaration() ||
                (stmt.isTSDeclareFunction() && stmt.get("id").isIdentifier()) ||
                stmt.isTSInterfaceDeclaration() ||
                stmt.isClassDeclaration({ declare: true }) ||
                stmt.isTSEnumDeclaration({ declare: true }) ||
                (stmt.isTSModuleDeclaration({ declare: true }) && stmt.get("id").isIdentifier())) &&
                registerGlobalType(programScope, stmt.node.id.name);
          }
        },
        exit(path) {
          path.node.sourceType === "module" && NEEDS_EXPLICIT_ESM.get(path.node) &&
            path.pushContainer("body", t.exportNamedDeclaration());
        }
      },
      ExportNamedDeclaration(path, state) {
        NEEDS_EXPLICIT_ESM.has(state.file.ast.program) || NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);

        if (path.node.exportKind === "type") path.remove();
        else if (
          path.node.source && path.node.specifiers.length > 0 &&
          path.node.specifiers.every(
            specifier => specifier.type === "ExportSpecifier" && specifier.exportKind === "type"
          )
        )
          path.remove();
        else if (
          !path.node.source && path.node.specifiers.length > 0 &&
          path.node.specifiers.every(
            specifier => t.isExportSpecifier(specifier) && isGlobalType(path, specifier.local.name)
          )
        )
          path.remove();
        else {
          if (t.isTSModuleDeclaration(path.node.declaration)) {
            const namespace = path.node.declaration,
              { id } = namespace;
            if (t.isIdentifier(id))
              if (path.scope.hasOwnBinding(id.name)) path.replaceWith(namespace);
              else {
                const [newExport] = path.replaceWithMultiple([
                  t.exportNamedDeclaration(t.variableDeclaration("let", [t.variableDeclarator(t.cloneNode(id))])),
                  namespace
                ]);
                path.scope.registerDeclaration(newExport);
              }
          }
          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);
        }
      },
      ExportAllDeclaration(path) {
        path.node.exportKind !== "type" || path.remove();
      },
      ExportSpecifier(path) {
        if ((!path.parent.source && isGlobalType(path, path.node.local.name)) || path.node.exportKind === "type")
          path.remove();
      },
      ExportDefaultDeclaration(path, state) {
        NEEDS_EXPLICIT_ESM.has(state.file.ast.program) || NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);

        t.isIdentifier(path.node.declaration) && isGlobalType(path, path.node.declaration.name)
          ? path.remove()
          : NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);
      },
      TSDeclareFunction(path) {
        safeRemove(path);
      },
      TSDeclareMethod(path) {
        safeRemove(path);
      },
      VariableDeclaration(path) {
        path.node.declare && safeRemove(path);
      },
      VariableDeclarator({ node }) {
        if (node.definite) node.definite = null;
      },
      TSIndexSignature(path) {
        path.remove();
      },
      ClassDeclaration(path) {
        const { node } = path;
        node.declare && safeRemove(path);
      },
      Class(path) {
        const { node } = path;
        if (node.typeParameters) node.typeParameters = null;
        if (node.superTypeParameters) node.superTypeParameters = null;
        if (node.implements) node.implements = null;
        if (node.abstract) node.abstract = null;
        path.get("body.body").forEach(child => {
          child.isClassMethod() || child.isClassPrivateMethod()
            ? child.node.kind === "constructor"
              ? classMemberVisitors.constructor(child, path)
              : classMemberVisitors.method(child)
            : (child.isClassProperty() || child.isClassPrivateProperty() || child.isClassAccessorProperty()) &&
              classMemberVisitors.field(child);
        });
      },
      Function(path) {
        const { node } = path;
        if (node.typeParameters) node.typeParameters = null;
        if (node.returnType) node.returnType = null;
        const params = node.params;
        params.length > 0 && t.isIdentifier(params[0], { name: "this" }) && params.shift();
      },
      TSModuleDeclaration(path) {
        transpileNamespace(path, allowNamespaces);
      },
      TSInterfaceDeclaration(path) {
        path.remove();
      },
      TSTypeAliasDeclaration(path) {
        path.remove();
      },
      TSEnumDeclaration(path) {
        optimizeConstEnums && path.node.const ? transpileConstEnum(path, t) : transpileEnum(path, t);
      },
      TSImportEqualsDeclaration(path, pass) {
        const { id, moduleReference } = path.node;
        let init, varKind;
        if (t.isTSExternalModuleReference(moduleReference)) {
          assertCjsTransformEnabled(path, pass,
            `import ${id.name} = require(...);`, `import ${id.name} from '...';`,
            " alongside Typescript's --allowSyntheticDefaultImports option"
          );
          init = t.callExpression(t.identifier("require"), [moduleReference.expression]);
          varKind = "const";
        } else {
          init = entityNameToExpr(moduleReference);
          varKind = "var";
        }
        path.replaceWith(t.variableDeclaration(varKind, [t.variableDeclarator(id, init)]));
        path.scope.registerDeclaration(path);
      },
      TSExportAssignment(path, pass) {
        assertCjsTransformEnabled(path, pass, "export = <value>;", "export default <value>;");
        path.replaceWith(template.statement.ast`module.exports = ${path.node.expression}`);
      },
      TSTypeAssertion(path) {
        path.replaceWith(path.node.expression);
      },
      [`TSAsExpression${t.tsSatisfiesExpression ? "|TSSatisfiesExpression" : ""}`](path) {
        let { node } = path;
        do {
          node = node.expression;
        } while (t.isTSAsExpression(node) || (t.isTSSatisfiesExpression != null && t.isTSSatisfiesExpression(node)));
        path.replaceWith(node);
      },
      [api.types.tsInstantiationExpression ? "TSNonNullExpression|TSInstantiationExpression" : "TSNonNullExpression"](
        path
      ) {
        path.replaceWith(path.node.expression);
      },
      CallExpression(path) {
        path.node.typeParameters = null;
      },
      OptionalCallExpression(path) {
        path.node.typeParameters = null;
      },
      NewExpression(path) {
        path.node.typeParameters = null;
      },
      JSXOpeningElement(path) {
        path.node.typeParameters = null;
      },
      TaggedTemplateExpression(path) {
        path.node.typeParameters = null;
      }
    }
  };
  function entityNameToExpr(node) {
    return t.isTSQualifiedName(node) ? t.memberExpression(entityNameToExpr(node.left), node.right) : node;
  }
  function visitPattern({ node }) {
    if (node.typeAnnotation) node.typeAnnotation = null;
    if (t.isIdentifier(node) && node.optional) node.optional = null;
  }
  function isImportTypeOnly({ binding, programPath, pragmaImportName, pragmaFragImportName }) {
    for (const path of binding.referencePaths) if (!isInType(path)) return false;

    if (binding.identifier.name !== pragmaImportName && binding.identifier.name !== pragmaFragImportName) return true;

    let sourceFileHasJsx = false;
    programPath.traverse({
      "JSXElement|JSXFragment"(path) {
        sourceFileHasJsx = true;
        path.stop();
      }
    });
    return !sourceFileHasJsx;
  }
});

var syntaxJsx = declare(api => {
  api.assertVersion(7);
  return {
    name: "syntax-jsx",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.some(p => (Array.isArray(p) ? p[0] : p) === "typescript") || parserOpts.plugins.push("jsx");
    }
  };
});

const requireNoInterop = source => template$1.expression.ast`require(${source})`,
  requireInterop = (source, file) =>
    t$5.callExpression(file.addHelper("interopRequireWildcard"), [requireNoInterop(source)]);
function transformDynamicImport(path, noInterop, file) {
  const buildRequire = noInterop ? requireNoInterop : requireInterop;
  path.replaceWith(buildDynamicImport(path.node, true, false, specifier => buildRequire(specifier, file)));
}

var transformModulesCommonjs = declare((api, options) => {
  var _api$assumption, _api$assumption2, _api$assumption3;
  api.assertVersion(7);
  const {
    strictNamespace = false,
    mjsStrictNamespace = strictNamespace,
    allowTopLevelThis,
    strict,
    strictMode,
    noInterop,
    importInterop,
    lazy = false,
    allowCommonJSExports = true,
    loose = false
  } = options;
  const constantReexports = (_api$assumption = api.assumption("constantReexports")) != null ? _api$assumption : loose,
    enumerableModuleMeta =
      (_api$assumption2 = api.assumption("enumerableModuleMeta")) != null ? _api$assumption2 : loose,
    noIncompleteNsImportDetection =
      (_api$assumption3 = api.assumption("noIncompleteNsImportDetection")) != null && _api$assumption3;
  if (
    typeof lazy != "boolean" && typeof lazy != "function" &&
    !(Array.isArray(lazy) && lazy.every(item => typeof item == "string"))
  )
    throw new Error(".lazy must be a boolean, array of strings, or a function");

  if (typeof strictNamespace != "boolean") throw new Error(".strictNamespace must be a boolean, or undefined");

  if (typeof mjsStrictNamespace != "boolean") throw new Error(".mjsStrictNamespace must be a boolean, or undefined");

  const getAssertion = localName => template$1.expression.ast`
    (function() {
      throw new Error(
        "The CommonJS '${localName}' variable is not available in ES6 modules.Consider setting setting sourceType:script or sourceType:unambiguous in your Babel config for this file."
      );
    })()
  `;
  const moduleExportsVisitor = {
    ReferencedIdentifier(path) {
      const localName = path.node.name;
      if (localName !== "module" && localName !== "exports") return;
      const localBinding = path.scope.getBinding(localName);
      this.scope.getBinding(localName) !== localBinding ||
        (path.parentPath.isObjectProperty({ value: path.node }) && path.parentPath.parentPath.isObjectPattern()) ||
        path.parentPath.isAssignmentExpression({ left: path.node }) ||
        path.isAssignmentExpression({ left: path.node }) ||
        path.replaceWith(getAssertion(localName));
    },
    UpdateExpression(path) {
      const arg = path.get("argument");
      if (!arg.isIdentifier()) return;
      const localName = arg.node.name;
      if (localName !== "module" && localName !== "exports") return;
      const localBinding = path.scope.getBinding(localName);
      this.scope.getBinding(localName) !== localBinding ||
        path.replaceWith(t$5.assignmentExpression(path.node.operator[0] + "=", arg.node, getAssertion(localName)));
    },
    AssignmentExpression(path) {
      const left = path.get("left");
      if (left.isIdentifier()) {
        const localName = left.node.name;
        if (localName !== "module" && localName !== "exports") return;
        const localBinding = path.scope.getBinding(localName);
        if (this.scope.getBinding(localName) !== localBinding) return;
        const right = path.get("right");
        right.replaceWith(t$5.sequenceExpression([right.node, getAssertion(localName)]));
      } else if (left.isPattern()) {
        const ids = left.getOuterBindingIdentifiers();
        const localName = Object.keys(ids).filter(localName =>
          (localName === "module" || localName === "exports") &&
          this.scope.getBinding(localName) === path.scope.getBinding(localName)
        )[0];
        if (localName) {
          const right = path.get("right");
          right.replaceWith(t$5.sequenceExpression([right.node, getAssertion(localName)]));
        }
      }
    }
  };
  return {
    name: "transform-modules-commonjs",
    pre() {
      this.file.set("@babel/plugin-transform-modules-*", "commonjs");
    },
    visitor: {
      CallExpression(path) {
        if (!this.file.has("@babel/plugin-proposal-dynamic-import") || !t$5.isImport(path.node.callee)) return;
        let { scope } = path;
        do {
          scope.rename("require");
        } while ((scope = scope.parent));
        transformDynamicImport(path, noInterop, this.file);
      },
      Program: {
        exit(path, state) {
          if (!isModule(path)) return;
          path.scope.rename("exports");
          path.scope.rename("module");
          path.scope.rename("require");
          path.scope.rename("__filename");
          path.scope.rename("__dirname");
          if (!allowCommonJSExports) {
            simplifyAccess(path, new Set(["module", "exports"]), false);

            path.traverse(moduleExportsVisitor, { scope: path.scope });
          }
          let moduleName = getModuleName(this.file.opts, options);
          if (moduleName) moduleName = t$5.stringLiteral(moduleName);
          const { meta, headers } = rewriteModuleStatementsAndPrepareHeader(path, {
            exportName: "exports",
            constantReexports,
            enumerableModuleMeta,
            strict,
            strictMode,
            allowTopLevelThis,
            noInterop,
            importInterop,
            lazy,
            esNamespaceOnly:
              typeof state.filename == "string" && /\.mjs$/.test(state.filename) ? mjsStrictNamespace : strictNamespace,
            noIncompleteNsImportDetection,
            filename: this.file.opts.filename
          });
          for (const [source, metadata] of meta.source) {
            const loadExpr = t$5.callExpression(t$5.identifier("require"), [t$5.stringLiteral(source)]);
            let header;
            if (isSideEffectImport(metadata)) {
              if (metadata.lazy) throw new Error("Assertion failure");
              header = t$5.expressionStatement(loadExpr);
            } else {
              if (metadata.lazy && !metadata.referenced) continue;

              const init = wrapInterop(path, loadExpr, metadata.interop) || loadExpr;
              header = metadata.lazy
                ? template$1.statement.ast`
                  function ${metadata.name}() {
                    const data = ${init};
                    ${metadata.name} = function() { return data; };
                    return data;
                  }
                `
                : template$1.statement.ast`
                  var ${metadata.name} = ${init};
                `;
            }
            header.loc = metadata.loc;
            headers.push(header);
            headers.push(...buildNamespaceInitStatements(meta, metadata, constantReexports));
          }
          ensureStatementsHoisted(headers);
          path.unshiftContainer("body", headers);
          path.get("body").forEach(path => {
            headers.indexOf(path.node) < 0 || (path.isVariableDeclaration() && path.scope.registerDeclaration(path));
          });
        }
      }
    }
  };
});

const v$2 = new OptionValidator("@babel/preset-typescript");
function normalizeOptions$3(options = {}) {
  let { allowNamespaces = true, jsxPragma, onlyRemoveTypeImports } = options;
  const TopLevelOptions = {
    ignoreExtensions: "ignoreExtensions",
    allowNamespaces: "allowNamespaces",
    disallowAmbiguousJSXLike: "disallowAmbiguousJSXLike",
    jsxPragma: "jsxPragma",
    jsxPragmaFrag: "jsxPragmaFrag",
    onlyRemoveTypeImports: "onlyRemoveTypeImports",
    optimizeConstEnums: "optimizeConstEnums",
    allExtensions: "allExtensions",
    isTSX: "isTSX"
  };
  const jsxPragmaFrag = v$2.validateStringOption(TopLevelOptions.jsxPragmaFrag, options.jsxPragmaFrag, "React.Fragment");

  var allExtensions = v$2.validateBooleanOption(TopLevelOptions.allExtensions, options.allExtensions, false),
    isTSX = v$2.validateBooleanOption(TopLevelOptions.isTSX, options.isTSX, false);
  isTSX && v$2.invariant(allExtensions, "isTSX:true requires allExtensions:true");

  const ignoreExtensions = v$2.validateBooleanOption(TopLevelOptions.ignoreExtensions, options.ignoreExtensions, false);
  const disallowAmbiguousJSXLike = v$2.validateBooleanOption(
    TopLevelOptions.disallowAmbiguousJSXLike, options.disallowAmbiguousJSXLike, false
  );
  disallowAmbiguousJSXLike && v$2.invariant(allExtensions, "disallowAmbiguousJSXLike:true requires allExtensions:true");

  const normalized = {
    ignoreExtensions,
    allowNamespaces,
    disallowAmbiguousJSXLike,
    jsxPragma,
    jsxPragmaFrag,
    onlyRemoveTypeImports,
    optimizeConstEnums: v$2.validateBooleanOption(TopLevelOptions.optimizeConstEnums, options.optimizeConstEnums, false)
  };

  normalized.allExtensions = allExtensions;
  normalized.isTSX = isTSX;

  return normalized;
}

var presetTypescript = declare((api, opts) => {
  api.assertVersion(7);
  const {
    allExtensions,
    ignoreExtensions,
    allowNamespaces,
    disallowAmbiguousJSXLike,
    isTSX,
    jsxPragma,
    jsxPragmaFrag,
    onlyRemoveTypeImports,
    optimizeConstEnums
  } = normalizeOptions$3(opts);
  const pluginOptions = disallowAmbiguousJSXLike => ({
    allowDeclareFields: opts.allowDeclareFields,
    allowNamespaces,
    disallowAmbiguousJSXLike,
    jsxPragma,
    jsxPragmaFrag,
    onlyRemoveTypeImports,
    optimizeConstEnums
  });
  const getPlugins = (isTSX, disallowAmbiguousJSXLike) => [
    [transformTypescript, Object.assign({ isTSX }, pluginOptions(disallowAmbiguousJSXLike))]
  ];
  return {
    overrides: allExtensions || ignoreExtensions
      ? [{ plugins: getPlugins(isTSX, disallowAmbiguousJSXLike) }]
      : [
          { test: /\.ts$/, plugins: getPlugins(false, false) },
          { test: /\.mts$/, sourceType: "module", plugins: getPlugins(false, true) },
          {
            test: /\.cts$/,
            sourceType: "unambiguous",
            plugins: [
              [transformModulesCommonjs, { allowTopLevelThis: true }],
              [transformTypescript, pluginOptions(true)]
            ]
          },
          { test: /\.tsx$/, plugins: getPlugins(true, false) }
        ]
  };
});

const debug$2 = traverse.buildDebug("babel:config:loading:files:module-types");
let import_;
try {
  import_ = require("./import.cjs");
} catch (_unused) {}
const supportsESM = vendors.semver.satisfies(process.versions.node, "^12.17 || >=13.2");
function* loadCodeDefault(filepath, asyncError) {
  switch (path.extname(filepath)) {
    case ".cjs":
      return loadCjsDefault(filepath, arguments[2]);

    case ".mjs":
      break;
    case ".cts":
      return loadCtsDefault(filepath);
    default:
      try {
        return loadCjsDefault(filepath, arguments[2]);
      } catch (e) {
        if (e.code !== "ERR_REQUIRE_ESM") throw e;
      }
  }
  if (yield* isAsync()) return yield* waitFor(loadMjsDefault(filepath));

  throw new ConfigError(asyncError, filepath);
}
function loadCtsDefault(filepath) {
  const ext = ".cts",
    hasTsSupport = !!(require.extensions[".ts"] || require.extensions[".cts"] || require.extensions[".mts"]);
  let handler;
  if (!hasTsSupport) {
    const opts = {
      babelrc: false,
      configFile: false,
      sourceType: "unambiguous",
      sourceMaps: "inline",
      sourceFileName: path.basename(filepath),
      presets: [
        [getTSPreset(), {
          onlyRemoveTypeImports: true,
          optimizeConstEnums: true,
          allowDeclareFields: true
        }]
      ]
    };
    handler = function (m, filename) {
      if (handler && filename.endsWith(ext))
        try {
          return m._compile(transformFileSync(filename, Object.assign({}, opts, { filename })).code, filename);
        } catch (error) {
          hasTsSupport ||
            !vendors.semver.lt(version$2, "7.21.4") ||
            console.error("`.cts` configuration file failed to load, please try to update `@babel/preset-typescript`.");

          throw error;
        }

      return require.extensions[".js"](m, filename);
    };
    require.extensions[ext] = handler;
  }
  try {
    return loadCjsDefault(filepath);
  } finally {
    if (!hasTsSupport) {
      require.extensions[ext] !== handler || delete require.extensions[ext];
      handler = void 0;
    }
  }
}
const LOADING_CJS_FILES = new Set();
function loadCjsDefault(filepath) {
  if (LOADING_CJS_FILES.has(filepath)) {
    debug$2("Auto-ignoring usage of config %o.", filepath);
    return {};
  }
  let module;
  try {
    LOADING_CJS_FILES.add(filepath);
    module = endHiddenCallStack(require)(filepath);
  } finally {
    LOADING_CJS_FILES.delete(filepath);
  }

  var _module = module;
  return _module != null && _module.__esModule ? module.default || (arguments[1] ? module : void 0) : module;
}
function loadMjsDefault(filepath) {
  return import_
    ? endHiddenCallStack(import_)(url.pathToFileURL(filepath)).then(module => module.default)
    : Promise.reject(
        new ConfigError("Internal error: Native ECMAScript modules aren't supported by this platform.\n", filepath)
      );
}
function getTSPreset(filepath) {
  return presetTypescript;
}

const debug$1 = traverse.buildDebug("babel:config:loading:files:configuration");
const ROOT_CONFIG_FILENAMES = [
  "babel.config.js",
  "babel.config.cjs",
  "babel.config.mjs",
  "babel.config.json",
  "babel.config.cts"
];
const RELATIVE_CONFIG_FILENAMES = [
  ".babelrc",
  ".babelrc.js",
  ".babelrc.cjs",
  ".babelrc.mjs",
  ".babelrc.json",
  ".babelrc.cts"
];
const BABELIGNORE_FILENAME = ".babelignore";
const runConfig = makeWeakCache(function* (options, cache) {
  yield* [];
  return {
    options: endHiddenCallStack(options)(makeConfigAPI(cache)),
    cacheNeedsConfiguration: !cache.configured()
  };
});
function* readConfigCode(filepath, data) {
  if (!fs.existsSync(filepath)) return null;
  let options = yield* loadCodeDefault(filepath,
    "You appear to be using a native ECMAScript module configuration file, which is only supported when running Babel asynchronously."
  );
  let cacheNeedsConfiguration = false;
  if (typeof options == "function") ({ options, cacheNeedsConfiguration } = yield* runConfig(options, data));

  if (!options || typeof options != "object" || Array.isArray(options))
    throw new ConfigError("Configuration should be an exported JavaScript object.", filepath);

  if (typeof options.then == "function") {
    options.catch == null || options.catch(() => {});
    throw new ConfigError(
      "You appear to be using an async configuration, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously return your config.",
      filepath
    );
  }
  cacheNeedsConfiguration && throwConfigError(filepath);
  return buildConfigFileObject(options, filepath);
}
const cfboaf = new WeakMap();
function buildConfigFileObject(options, filepath) {
  let configFilesByFilepath = cfboaf.get(options);
  configFilesByFilepath || cfboaf.set(options, (configFilesByFilepath = new Map()));

  let configFile = configFilesByFilepath.get(filepath);
  if (!configFile) {
    configFile = { filepath, dirname: path.dirname(filepath), options };
    configFilesByFilepath.set(filepath, configFile);
  }
  return configFile;
}
const packageToBabelConfig = makeWeakCacheSync(file => {
  const babel = file.options.babel;
  if (babel === void 0) return null;
  if (typeof babel != "object" || Array.isArray(babel) || babel === null)
    throw new ConfigError(".babel property must be an object", file.filepath);

  return { filepath: file.filepath, dirname: file.dirname, options: babel };
});
const readConfigJSON5 = makeStaticFileCache((filepath, content) => {
  let options;
  try {
    options = vendors.json5parse(content);
  } catch (err) {
    throw new ConfigError("Error while parsing config - " + err.message, filepath);
  }
  if (!options) throw new ConfigError("No config detected", filepath);
  if (typeof options != "object") throw new ConfigError("Config returned typeof " + typeof options, filepath);

  if (Array.isArray(options)) throw new ConfigError("Expected config object but found array", filepath);

  delete options.$schema;
  return { filepath, dirname: path.dirname(filepath), options };
});
const readIgnoreConfig = makeStaticFileCache((filepath, content) => {
  const ignoreDir = path.dirname(filepath),
    ignorePatterns = content.split("\n").map(line => line.replace(/#(.*?)$/, "").trim()).filter(line => !!line);
  for (const pattern of ignorePatterns)
    if (pattern[0] === "!") throw new ConfigError("Negation of file paths is not supported.", filepath);

  return {
    filepath,
    dirname: path.dirname(filepath),
    ignore: ignorePatterns.map(pattern => pathToPattern(pattern, ignoreDir))
  };
});
function findConfigUpwards(rootDir) {
  for (let dirname = rootDir; ; ) {
    for (const filename of ROOT_CONFIG_FILENAMES) if (fs.existsSync(path.join(dirname, filename))) return dirname;

    const nextDir = path.dirname(dirname);
    if (dirname === nextDir) break;
    dirname = nextDir;
  }
  return null;
}
function* findRelativeConfig(packageData, envName, caller) {
  let config = null,
    ignore = null;
  const dirname = path.dirname(packageData.filepath);
  for (const loc of packageData.directories) {
    if (!config) {
      var _packageData$pkg;
      config = yield* loadOneConfig(
        RELATIVE_CONFIG_FILENAMES, loc, envName, caller,
        ((_packageData$pkg = packageData.pkg) == null ? void 0 : _packageData$pkg.dirname) === loc
          ? packageToBabelConfig(packageData.pkg) : null
      );
    }
    if (!ignore) {
      const ignoreLoc = path.join(loc, BABELIGNORE_FILENAME);
      ignore = yield* readIgnoreConfig(ignoreLoc);
      ignore && debug$1("Found ignore %o from %o.", ignore.filepath, dirname);
    }
  }
  return { config, ignore };
}
function findRootConfig(dirname, envName, caller) {
  return loadOneConfig(ROOT_CONFIG_FILENAMES, dirname, envName, caller);
}
function* loadOneConfig(names, dirname, envName, caller, previousConfig = null) {
  const config = (yield* gensync.all(
    names.map(filename => readConfig(path.join(dirname, filename), envName, caller))
  )).reduce((previousConfig, config) => {
    if (config && previousConfig)
      throw new ConfigError(`\
Multiple configuration files found. Please remove one:
 - ${path.basename(previousConfig.filepath)}
 - ${config.filepath}
from ${dirname}`);

    return config || previousConfig;
  }, previousConfig);
  config && debug$1("Found configuration %o from %o.", config.filepath, dirname);

  return config;
}
function* loadConfig(name, dirname, envName, caller) {
  const filepath = require.resolve(name, { paths: [dirname] }),
    conf = yield* readConfig(filepath, envName, caller);
  if (!conf) throw new ConfigError("Config file contains no configuration data", filepath);

  debug$1("Loaded config %o from %o.", name, dirname);
  return conf;
}
function readConfig(filepath, envName, caller) {
  switch (path.extname(filepath)) {
    case ".js":
    case ".cjs":
    case ".mjs":
    case ".cts":
      return readConfigCode(filepath, { envName, caller });
    default:
      return readConfigJSON5(filepath);
  }
}
function* resolveShowConfigPath(dirname) {
  const targetPath = process.env.BABEL_SHOW_CONFIG_FOR;
  if (targetPath != null) {
    const absolutePath = path.resolve(dirname, targetPath);
    if (!(yield* stat(absolutePath)).isFile())
      throw new Error(
        absolutePath + ": BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported."
      );

    return absolutePath;
  }
  return null;
}
function throwConfigError(filepath) {
  throw new ConfigError(`\
Caching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured
for various types of caching, using the first param of their handler functions:

module.exports = function(api) {
  // The API exposes the following:

  // Cache the returned value forever and don't call this function again.
  api.cache(true);

  // Don't cache at all. Not recommended because it will be very slow.
  api.cache(false);

  // Cached based on the value of some function. If this function returns a value different from
  // a previously-encountered value, the plugins will re-evaluate.
  var env = api.cache(() => "production");

  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for
  // any possible NODE_ENV value that might come up during plugin execution.
  var isProd = api.cache(() => "production" === "production");

  // .cache(fn) will perform a linear search though instances to find the matching plugin based
  // based on previous instantiated plugins. If you want to recreate the plugin and discard the
  // previous instance whenever something changes, you may use:
  var isProd = api.cache.invalidate(() => "production" === "production");

  // Note, we also expose the following more-verbose versions of the above examples:
  api.cache.forever(); // api.cache(true)
  api.cache.never();   // api.cache(false)
  api.cache.using(fn); // api.cache(fn)

  // Return the value that will be cached.
  return { };
};`, filepath);
}

const isWindows = process$1.platform === 'win32',
  own$1 = {}.hasOwnProperty,
  classRegExp = /^([A-Z][a-z\d]*)+$/,
  kTypes = new Set(['string', 'function', 'number', 'object', 'Function', 'Object', 'boolean', 'bigint', 'symbol']),
  codes = {};
function formatList(array, type = 'and') {
  return array.length < 3
    ? array.join(` ${type} `)
    : `${array.slice(0, -1).join(', ')}, ${type} ${array[array.length - 1]}`;
}
const messages = new Map(),
  nodeInternalPrefix = '__node_internal_';
let userStackTraceLimit;
codes.ERR_INVALID_ARG_TYPE = createError('ERR_INVALID_ARG_TYPE', (name, expected, actual) => {
  assert(typeof name == 'string', "'name' must be a string");
  Array.isArray(expected) || (expected = [expected]);

  let message = 'The ';
  if (name.endsWith(' argument')) message += name + ' ';
  else {
    const type = name.includes('.') ? 'property' : 'argument';
    message += `"${name}" ${type} `;
  }
  message += 'must be ';
  const types = [],
    instances = [],
    other = [];
  for (const value of expected) {
    assert(typeof value == 'string', 'All expected entries have to be of type string');
    if (kTypes.has(value)) types.push(value.toLowerCase());
    else if (classRegExp.exec(value) === null) {
      assert(value !== 'object', 'The value "object" should be written as "Object"');
      other.push(value);
    } else instances.push(value);
  }
  if (instances.length > 0) {
    const pos = types.indexOf('object');
    if (pos > -1) {
      types.slice(pos, 1);
      instances.push('Object');
    }
  }
  if (types.length > 0) {
    message += `${types.length > 1 ? 'one of type' : 'of type'} ${formatList(types, 'or')}`;
    if (instances.length > 0 || other.length > 0) message += ' or ';
  }
  if (instances.length > 0) {
    message += 'an instance of ' + formatList(instances, 'or');
    if (other.length > 0) message += ' or ';
  }
  if (other.length > 0)
    if (other.length > 1) message += 'one of ' + formatList(other, 'or');
    else {
      if (other[0].toLowerCase() !== other[0]) message += 'an ';
      message += '' + other[0];
    }

  message += '. Received ' + determineSpecificType(actual);
  return message;
}, TypeError);
codes.ERR_INVALID_MODULE_SPECIFIER = createError('ERR_INVALID_MODULE_SPECIFIER',
  (request, reason, base = void 0) => `Invalid module "${request}" ${reason}${base ? ' imported from ' + base : ''}`,
  TypeError);
codes.ERR_INVALID_PACKAGE_CONFIG = createError('ERR_INVALID_PACKAGE_CONFIG', (path, base, message) =>
    `Invalid package config ${path}${base ? ' while importing ' + base : ''}${message ? '. ' + message : ''}`,
  Error);
codes.ERR_INVALID_PACKAGE_TARGET = createError('ERR_INVALID_PACKAGE_TARGET', (pkgPath, key, target, isImport = false, base = void 0) => {
  const relError = typeof target == 'string' && !isImport && target.length > 0 && !target.startsWith('./');
  if (key === '.') {
    assert(isImport === false);
    return `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${pkgPath}package.json${
      base ? ' imported from ' + base : ''
    }${relError ? '; targets must start with "./"' : ''}`;
  }
  return `Invalid "${isImport ? 'imports' : 'exports'}" target ${JSON.stringify(
    target
  )} defined for '${key}' in the package config ${pkgPath}package.json${base ? ' imported from ' + base : ''}${
    relError ? '; targets must start with "./"' : ''
  }`;
}, Error);
codes.ERR_MODULE_NOT_FOUND = createError('ERR_MODULE_NOT_FOUND',
  (path, base, type = 'package') => `Cannot find ${type} '${path}' imported from ${base}`,
  Error);
codes.ERR_NETWORK_IMPORT_DISALLOWED = createError('ERR_NETWORK_IMPORT_DISALLOWED',
  "import of '%s' by %s is not supported: %s",
  Error);
codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError('ERR_PACKAGE_IMPORT_NOT_DEFINED', (specifier, packagePath, base) =>
    `Package import specifier "${specifier}" is not defined${
      packagePath ? ` in package ${packagePath}package.json` : ''
    } imported from ${base}`,
  TypeError);
codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError('ERR_PACKAGE_PATH_NOT_EXPORTED', (pkgPath, subpath, base = void 0) =>
  subpath === '.'
    ? `No "exports" main defined in ${pkgPath}package.json${base ? ' imported from ' + base : ''}`
    : `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${
        base ? ' imported from ' + base : ''
      }`,
  Error);
codes.ERR_UNSUPPORTED_DIR_IMPORT = createError('ERR_UNSUPPORTED_DIR_IMPORT',
  "Directory import '%s' is not supported resolving ES modules imported from %s",
  Error);
codes.ERR_UNKNOWN_FILE_EXTENSION = createError('ERR_UNKNOWN_FILE_EXTENSION',
  (ext, path) => `Unknown file extension "${ext}" for ${path}`,
  TypeError);
codes.ERR_INVALID_ARG_VALUE = createError('ERR_INVALID_ARG_VALUE', (name, value, reason = 'is invalid') => {
  let inspected = util.inspect(value);
  if (inspected.length > 128) inspected = inspected.slice(0, 128) + '...';

  return `The ${name.includes('.') ? 'property' : 'argument'} '${name}' ${reason}. Received ${inspected}`;
}, TypeError);
codes.ERR_UNSUPPORTED_ESM_URL_SCHEME = createError('ERR_UNSUPPORTED_ESM_URL_SCHEME', (url, supported) => {
  let message = `Only URLs with a scheme in: ${formatList(supported)} are supported by the default ESM loader`;
  if (isWindows && url.protocol.length === 2) message += '. On Windows, absolute paths must be valid file:// URLs';

  message += `. Received protocol '${url.protocol}'`;
  return message;
}, Error);
function createError(sym, value, def) {
  messages.set(sym, value);
  return makeNodeErrorWithCode(def, sym);
}
function makeNodeErrorWithCode(Base, key) {
  return NodeError;
  function NodeError(...args) {
    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
    const error = new Base();
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
    const message = getMessage(key, args, error);
    Object.defineProperties(error, {
      message: { value: message, enumerable: false, writable: true, configurable: true },
      toString: {
        value() {
          return `${this.name} [${key}]: ${this.message}`;
        },
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    captureLargerStackTrace(error);
    error.code = key;
    return error;
  }
}
function isErrorStackTraceLimitWritable() {
  try {
    if (v8.startupSnapshot.isBuildingSnapshot()) return false;
  } catch (_unused) {}
  const desc = Object.getOwnPropertyDescriptor(Error, 'stackTraceLimit');

  return desc === void 0
    ? Object.isExtensible(Error)
    : own$1.call(desc, 'writable') && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
}
function hideStackFrames(fn) {
  const hidden = nodeInternalPrefix + fn.name;
  Object.defineProperty(fn, 'name', { value: hidden });
  return fn;
}
const captureLargerStackTrace = hideStackFrames(function (error) {
  const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
  if (stackTraceLimitIsWritable) {
    userStackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = Number.POSITIVE_INFINITY;
  }
  Error.captureStackTrace(error);
  if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;
  return error;
});
function getMessage(key, args, self) {
  const message = messages.get(key);
  assert(message !== void 0, 'expected `message` to be found');
  if (typeof message == 'function') {
    assert(message.length <= args.length,
      `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${message.length}).`
    );
    return Reflect.apply(message, self, args);
  }
  const regex = /%[dfijoOs]/g;
  let expectedLength = 0;
  while (regex.exec(message) !== null) expectedLength++;
  assert(expectedLength === args.length,
    `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
  );
  if (args.length === 0) return message;
  args.unshift(message);
  return Reflect.apply(util.format, null, args);
}
function determineSpecificType(value) {
  if (value === null || value === void 0) return String(value);

  if (typeof value == 'function' && value.name) return 'function ' + value.name;

  if (typeof value == 'object')
    return value.constructor && value.constructor.name
      ? 'an instance of ' + value.constructor.name
      : '' + util.inspect(value, { depth: -1 });

  let inspected = util.inspect(value, { colors: false });
  if (inspected.length > 28) inspected = inspected.slice(0, 25) + '...';

  return `type ${typeof value} (${inspected})`;
}
const reader = { read };
var packageJsonReader = reader;
function read(jsonPath) {
  try {
    return {
      string: fs.readFileSync(path.toNamespacedPath(path.join(path.dirname(jsonPath), 'package.json')), 'utf8')
    };
  } catch (error) {
    const exception = error;
    if (exception.code === 'ENOENT') return { string: void 0 };

    throw exception;
  }
}
const { ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG$1 } = codes,
  packageJsonCache = new Map();
function getPackageConfig(path, specifier, base) {
  const existing = packageJsonCache.get(path);
  if (existing !== void 0) return existing;

  const source = packageJsonReader.read(path).string;
  if (source === void 0) {
    const packageConfig = {
      pjsonPath: path,
      exists: false,
      main: void 0,
      name: void 0,
      type: 'none',
      exports: void 0,
      imports: void 0
    };
    packageJsonCache.set(path, packageConfig);
    return packageConfig;
  }
  let packageJson;
  try {
    packageJson = JSON.parse(source);
  } catch (error) {
    const exception = error;
    throw new ERR_INVALID_PACKAGE_CONFIG$1(path,
      (base ? `"${specifier}" from ` : '') + url.fileURLToPath(base || specifier),
      exception.message);
  }
  const { exports, imports, main, name, type } = packageJson;
  const packageConfig = {
    pjsonPath: path,
    exists: true,
    main: typeof main == 'string' ? main : void 0,
    name: typeof name == 'string' ? name : void 0,
    type: type === 'module' || type === 'commonjs' ? type : 'none',
    exports,
    imports: imports && typeof imports == 'object' ? imports : void 0
  };
  packageJsonCache.set(path, packageConfig);
  return packageConfig;
}
function getPackageScopeConfig(resolved) {
  let packageJsonUrl = new url.URL('package.json', resolved);
  while (!packageJsonUrl.pathname.endsWith('node_modules/package.json')) {
    const packageConfig = getPackageConfig(url.fileURLToPath(packageJsonUrl), resolved);
    if (packageConfig.exists) return packageConfig;
    const lastPackageJsonUrl = packageJsonUrl;
    packageJsonUrl = new url.URL('../package.json', packageJsonUrl);
    if (packageJsonUrl.pathname === lastPackageJsonUrl.pathname) break;
  }
  const packageJsonPath = url.fileURLToPath(packageJsonUrl);
  const packageConfig = {
    pjsonPath: packageJsonPath,
    exists: false,
    main: void 0,
    name: void 0,
    type: 'none',
    exports: void 0,
    imports: void 0
  };
  packageJsonCache.set(packageJsonPath, packageConfig);
  return packageConfig;
}
function getPackageType(url) {
  return getPackageScopeConfig(url).type;
}
const { ERR_UNKNOWN_FILE_EXTENSION } = codes,
  hasOwnProperty = {}.hasOwnProperty;
const extensionFormatMap = {
  __proto__: null,
  '.cjs': 'commonjs',
  '.js': 'module',
  '.json': 'json',
  '.mjs': 'module'
};
function mimeToFormat(mime) {
  return mime && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime)
    ? 'module'
    : mime === 'application/json' ? 'json'
    : null;
}
const protocolHandlers = {
  __proto__: null,
  'data:': getDataProtocolModuleFormat,
  'file:': getFileProtocolModuleFormat,
  'http:': getHttpProtocolModuleFormat,
  'https:': getHttpProtocolModuleFormat,
  'node:': () => 'builtin'
};
function getDataProtocolModuleFormat(parsed) {
  const { 1: mime } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname) || [null, null, null];
  return mimeToFormat(mime);
}
function extname(url) {
  const pathname = url.pathname;
  for (let index = pathname.length; index--; ) {
    const code = pathname.codePointAt(index);
    if (code === 47) return '';

    if (code === 46) return pathname.codePointAt(index - 1) === 47 ? '' : pathname.slice(index);
  }
  return '';
}
function getFileProtocolModuleFormat(url$1, _context, ignoreErrors) {
  const ext = extname(url$1);
  if (ext === '.js') return getPackageType(url$1) === 'module' ? 'module' : 'commonjs';

  const format = extensionFormatMap[ext];
  if (format) return format;
  if (ignoreErrors) return void 0;

  const filepath = url.fileURLToPath(url$1);
  throw new ERR_UNKNOWN_FILE_EXTENSION(ext, filepath);
}
function getHttpProtocolModuleFormat() {}
function defaultGetFormatWithoutErrors(url, context) {
  return (
    (hasOwnProperty.call(protocolHandlers, url.protocol) && protocolHandlers[url.protocol](url, context, true)) || null
  );
}
const { ERR_INVALID_ARG_VALUE } = codes,
  DEFAULT_CONDITIONS = Object.freeze(['node', 'import']),
  DEFAULT_CONDITIONS_SET = new Set(DEFAULT_CONDITIONS);
function getDefaultConditions() {
  return DEFAULT_CONDITIONS;
}
function getDefaultConditionsSet() {
  return DEFAULT_CONDITIONS_SET;
}
function getConditionsSet(conditions) {
  if (conditions !== void 0 && conditions !== getDefaultConditions()) {
    if (!Array.isArray(conditions)) throw new ERR_INVALID_ARG_VALUE('conditions', conditions, 'expected an array');

    return new Set(conditions);
  }
  return getDefaultConditionsSet();
}
const RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace],
  experimentalNetworkImports = false;
const {
  ERR_NETWORK_IMPORT_DISALLOWED,
  ERR_INVALID_MODULE_SPECIFIER,
  ERR_INVALID_PACKAGE_CONFIG,
  ERR_INVALID_PACKAGE_TARGET,
  ERR_MODULE_NOT_FOUND,
  ERR_PACKAGE_IMPORT_NOT_DEFINED,
  ERR_PACKAGE_PATH_NOT_EXPORTED,
  ERR_UNSUPPORTED_DIR_IMPORT,
  ERR_UNSUPPORTED_ESM_URL_SCHEME
} = codes;
const own = {}.hasOwnProperty,
  invalidSegmentRegEx =
    /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i,
  deprecatedInvalidSegmentRegEx =
    /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i,
  invalidPackageNameRegEx = /^\.|%|\\/,
  patternRegEx = /\*/g,
  encodedSepRegEx = /%2f|%5c/i,
  emittedPackageWarnings = new Set(),
  doubleSlashRegEx = /[/\\]{2}/;
function emitInvalidSegmentDeprecation(target, request, match, packageJsonUrl, internal, base, isTarget) {
  const pjsonPath = url.fileURLToPath(packageJsonUrl),
    double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
  process$1.emitWarning(
    `Use of deprecated ${
      double ? 'double slash' : 'leading or trailing slash matching'
    } resolving "${target}" for module request "${request}" ${
      request === match ? '' : `matched to "${match}" `
    }in the "${internal ? 'imports' : 'exports'}" field module resolution of the package at ${pjsonPath}${
      base ? ' imported from ' + url.fileURLToPath(base) : ''
    }.`,
    'DeprecationWarning', 'DEP0166'
  );
}
function emitLegacyIndexDeprecation(url$1, packageJsonUrl, base, main) {
  if (defaultGetFormatWithoutErrors(url$1, { parentURL: base.href }) !== 'module') return;
  const path = url.fileURLToPath(url$1.href),
    pkgPath = url.fileURLToPath(new url.URL('.', packageJsonUrl)),
    basePath = url.fileURLToPath(base);
  main
    ? process$1.emitWarning(
        `Package ${pkgPath} has a "main" field set to ${JSON.stringify(
          main
        )}, excluding the full filename and extension to the resolved file at "${path.slice(
          pkgPath.length
        )}", imported from ${basePath}.\n Automatic extension resolution of the "main" field isdeprecated for ES modules.`,
        'DeprecationWarning', 'DEP0151'
      )
    : process$1.emitWarning(
        `No "main" or "exports" field defined in the package.json for ${pkgPath} resolving the main entry point "${path.slice(pkgPath.length)}", imported from ${basePath}.
Default "index" lookups for the main are deprecated for ES modules.`,
        'DeprecationWarning', 'DEP0151'
      );
}
function tryStatSync(path) {
  try {
    return fs.statSync(path);
  } catch (_unused2) {
    return new fs.Stats();
  }
}
function fileExists(url) {
  const stats = fs.statSync(url, { throwIfNoEntry: false }),
    isFile = stats ? stats.isFile() : void 0;
  return isFile !== null && isFile !== void 0 && isFile;
}
function legacyMainResolve(packageJsonUrl, packageConfig, base) {
  let guess;
  if (packageConfig.main !== void 0) {
    guess = new url.URL(packageConfig.main, packageJsonUrl);
    if (fileExists(guess)) return guess;
    const tries = [
      `./${packageConfig.main}.js`,
      `./${packageConfig.main}.json`,
      `./${packageConfig.main}.node`,
      `./${packageConfig.main}/index.js`,
      `./${packageConfig.main}/index.json`,
      `./${packageConfig.main}/index.node`
    ];
    for (let i = -1; ++i < tries.length; ) {
      guess = new url.URL(tries[i], packageJsonUrl);
      if (fileExists(guess)) break;
      guess = void 0;
    }
    if (guess) {
      emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
      return guess;
    }
  }
  const tries = ['./index.js', './index.json', './index.node'];
  for (let i = -1; ++i < tries.length; ) {
    guess = new url.URL(tries[i], packageJsonUrl);
    if (fileExists(guess)) break;
    guess = void 0;
  }
  if (guess) {
    emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
    return guess;
  }
  throw new ERR_MODULE_NOT_FOUND(url.fileURLToPath(new url.URL('.', packageJsonUrl)), url.fileURLToPath(base));
}
function finalizeResolution(resolved, base, preserveSymlinks) {
  if (encodedSepRegEx.exec(resolved.pathname) !== null)
    throw new ERR_INVALID_MODULE_SPECIFIER(
      resolved.pathname, 'must not include encoded "/" or "\\" characters', url.fileURLToPath(base)
    );
  const filePath = url.fileURLToPath(resolved),
    stats = tryStatSync(filePath.endsWith('/') ? filePath.slice(-1) : filePath);
  if (stats.isDirectory()) {
    const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, url.fileURLToPath(base));
    error.url = String(resolved);
    throw error;
  }
  if (!stats.isFile())
    throw new ERR_MODULE_NOT_FOUND(filePath || resolved.pathname, base && url.fileURLToPath(base), 'module');

  if (!preserveSymlinks) {
    const real = fs.realpathSync(filePath),
      { search, hash } = resolved;
    (resolved = url.pathToFileURL(real + (filePath.endsWith(path.sep) ? '/' : ''))).search = search;
    resolved.hash = hash;
  }
  return resolved;
}
function importNotDefined(specifier, packageJsonUrl, base) {
  return new ERR_PACKAGE_IMPORT_NOT_DEFINED(
    specifier, packageJsonUrl && url.fileURLToPath(new url.URL('.', packageJsonUrl)), url.fileURLToPath(base)
  );
}
function exportsNotFound(subpath, packageJsonUrl, base) {
  return new ERR_PACKAGE_PATH_NOT_EXPORTED(
    url.fileURLToPath(new url.URL('.', packageJsonUrl)), subpath, base && url.fileURLToPath(base)
  );
}
function throwInvalidSubpath(request, match, packageJsonUrl, internal, base) {
  const reason = `request is not a valid match in pattern "${match}" for the "${
    internal ? 'imports' : 'exports'
  }" resolution of ${url.fileURLToPath(packageJsonUrl)}`;
  throw new ERR_INVALID_MODULE_SPECIFIER(request, reason, base && url.fileURLToPath(base));
}
function invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
  target = typeof target == 'object' && target !== null ? JSON.stringify(target, null, '') : '' + target;
  return new ERR_INVALID_PACKAGE_TARGET(
    url.fileURLToPath(new url.URL('.', packageJsonUrl)), subpath, target, internal, base && url.fileURLToPath(base)
  );
}
function resolvePackageTargetString(
  target,
  subpath,
  match,
  packageJsonUrl,
  base,
  pattern,
  internal,
  isPathMap,
  conditions
) {
  if (subpath !== '' && !pattern && target[target.length - 1] !== '/')
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (!target.startsWith('./')) {
    if (internal && !target.startsWith('../') && !target.startsWith('/')) {
      let isURL = false;
      try {
        new url.URL(target);
        isURL = true;
      } catch (_unused3) {}
      if (!isURL)
        return packageResolve(
          pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () => subpath) : target + subpath,
          packageJsonUrl, conditions
        );
    }
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  }
  if (invalidSegmentRegEx.exec(target.slice(2)) !== null) {
    if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) !== null)
      throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);

    if (!isPathMap) {
      const request = pattern ? match.replace('*', () => subpath) : match + subpath;
      emitInvalidSegmentDeprecation(
        pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () => subpath) : target,
        request, match, packageJsonUrl, internal, base, true
      );
    }
  }
  const resolved = new url.URL(target, packageJsonUrl),
    resolvedPath = resolved.pathname,
    packagePath = new url.URL('.', packageJsonUrl).pathname;
  if (!resolvedPath.startsWith(packagePath)) throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (subpath === '') return resolved;
  if (invalidSegmentRegEx.exec(subpath) !== null) {
    const request = pattern ? match.replace('*', () => subpath) : match + subpath;
    deprecatedInvalidSegmentRegEx.exec(subpath) === null
      ? isPathMap ||
        emitInvalidSegmentDeprecation(
          pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () => subpath) : target,
          request, match, packageJsonUrl, internal, base, false
        )
      : throwInvalidSubpath(request, match, packageJsonUrl, internal, base);
  }
  return pattern
    ? new url.URL(RegExpPrototypeSymbolReplace.call(patternRegEx, resolved.href, () => subpath))
    : new url.URL(subpath, resolved);
}
function isArrayIndex(key) {
  const keyNumber = Number(key);
  return '' + keyNumber === key && keyNumber >= 0 && keyNumber < 0xffffffff;
}
function resolvePackageTarget(
  packageJsonUrl,
  target,
  subpath,
  packageSubpath,
  base,
  pattern,
  internal,
  isPathMap,
  conditions
) {
  if (typeof target == 'string')
    return resolvePackageTargetString(
      target, subpath, packageSubpath, packageJsonUrl, base, pattern, internal, isPathMap, conditions
    );

  if (Array.isArray(target)) {
    const targetList = target;
    if (targetList.length === 0) return null;
    let lastException;
    for (let i = -1; ++i < targetList.length; ) {
      const targetItem = targetList[i];
      let resolveResult;
      try {
        resolveResult = resolvePackageTarget(
          packageJsonUrl, targetItem, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions
        );
      } catch (error) {
        lastException = error;
        if (error.code === 'ERR_INVALID_PACKAGE_TARGET') continue;
        throw error;
      }
      if (resolveResult === void 0) continue;
      if (resolveResult !== null) return resolveResult;

      lastException = null;
    }
    if (lastException === void 0 || lastException === null) return null;

    throw lastException;
  }
  if (typeof target == 'object' && target !== null) {
    const keys = Object.getOwnPropertyNames(target);
    let i = -1;
    while (++i < keys.length)
      if (isArrayIndex(keys[i]))
        throw new ERR_INVALID_PACKAGE_CONFIG(
          url.fileURLToPath(packageJsonUrl), base, '"exports" cannot contain numeric property keys.'
        );

    for (i = -1; ++i < keys.length; ) {
      const key = keys[i];
      if (key === 'default' || (conditions && conditions.has(key))) {
        const resolveResult = resolvePackageTarget(
          packageJsonUrl, target[key], subpath, packageSubpath, base, pattern, internal, isPathMap, conditions
        );
        if (resolveResult === void 0) continue;
        return resolveResult;
      }
    }
    return null;
  }
  if (target === null) return null;

  throw invalidPackageTarget(packageSubpath, target, packageJsonUrl, internal, base);
}
function isConditionalExportsMainSugar(exports, packageJsonUrl, base) {
  if (typeof exports == 'string' || Array.isArray(exports)) return true;
  if (typeof exports != 'object' || exports === null) return false;
  const keys = Object.getOwnPropertyNames(exports);
  let isConditionalSugar = false;
  for (let i = 0, j = -1; ++j < keys.length; ) {
    const key = keys[j],
      curIsConditionalSugar = key === '' || key[0] !== '.';
    if (i++ == 0) isConditionalSugar = curIsConditionalSugar;
    else if (isConditionalSugar !== curIsConditionalSugar)
      throw new ERR_INVALID_PACKAGE_CONFIG(
        url.fileURLToPath(packageJsonUrl), base,
        '"exports" cannot contain some keys starting with \'.\' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.'
      );
  }
  return isConditionalSugar;
}
function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
  const pjsonPath = url.fileURLToPath(pjsonUrl);
  if (emittedPackageWarnings.has(pjsonPath + '|' + match)) return;
  emittedPackageWarnings.add(pjsonPath + '|' + match);
  process$1.emitWarning(
    `Use of deprecated trailing slash pattern mapping "${match}" in the "exports" field module resolution of the package at ${pjsonPath}${
      base ? ' imported from ' + url.fileURLToPath(base) : ''
    }. Mapping specifiers ending in "/" is no longer supported.`,
    'DeprecationWarning', 'DEP0155'
  );
}
function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
  let exports = packageConfig.exports;
  if (isConditionalExportsMainSugar(exports, packageJsonUrl, base)) exports = { '.': exports };

  if (own.call(exports, packageSubpath) && !packageSubpath.includes('*') && !packageSubpath.endsWith('/')) {
    const resolveResult = resolvePackageTarget(
      packageJsonUrl, exports[packageSubpath], '', packageSubpath, base, false, false, false, conditions
    );
    if (resolveResult === null || resolveResult === void 0)
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);

    return resolveResult;
  }
  let bestMatch = '',
    bestMatchSubpath = '';
  const keys = Object.getOwnPropertyNames(exports);
  for (let i = -1; ++i < keys.length; ) {
    const key = keys[i],
      patternIndex = key.indexOf('*');
    if (patternIndex > -1 && packageSubpath.startsWith(key.slice(0, patternIndex))) {
      packageSubpath.endsWith('/') && emitTrailingSlashPatternDeprecation(packageSubpath, packageJsonUrl, base);

      const patternTrailer = key.slice(patternIndex + 1);
      if (
        packageSubpath.length >= key.length &&
        packageSubpath.endsWith(patternTrailer) &&
        patternKeyCompare(bestMatch, key) === 1 &&
        key.lastIndexOf('*') === patternIndex
      ) {
        bestMatch = key;
        bestMatchSubpath = packageSubpath.slice(patternIndex, packageSubpath.length - patternTrailer.length);
      }
    }
  }
  if (bestMatch) {
    const resolveResult = resolvePackageTarget(
      packageJsonUrl, exports[bestMatch],
      bestMatchSubpath, bestMatch, base, true, false, packageSubpath.endsWith('/'), conditions
    );
    if (resolveResult === null || resolveResult === void 0)
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);

    return resolveResult;
  }
  throw exportsNotFound(packageSubpath, packageJsonUrl, base);
}
function patternKeyCompare(a, b) {
  const aPatternIndex = a.indexOf('*'),
    bPatternIndex = b.indexOf('*'),
    baseLengthA = aPatternIndex < 0 ? a.length : aPatternIndex + 1,
    baseLengthB = bPatternIndex < 0 ? b.length : bPatternIndex + 1;
  return baseLengthA > baseLengthB
    ? -1
    : baseLengthB > baseLengthA || aPatternIndex < 0
    ? 1
    : bPatternIndex < 0 || a.length > b.length
    ? -1
    : b.length > a.length
    ? 1
    : 0;
}
function packageImportsResolve(name, base, conditions) {
  if (name === '#' || name.startsWith('#/') || name.endsWith('/'))
    throw new ERR_INVALID_MODULE_SPECIFIER(
      name, 'is not a valid internal imports specifier name', url.fileURLToPath(base)
    );

  let packageJsonUrl;
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    packageJsonUrl = url.pathToFileURL(packageConfig.pjsonPath);
    const imports = packageConfig.imports;
    if (imports)
      if (own.call(imports, name) && !name.includes('*')) {
        const resolveResult = resolvePackageTarget(
          packageJsonUrl, imports[name], '', name, base, false, true, false, conditions
        );
        if (resolveResult !== null && resolveResult !== void 0) return resolveResult;
      } else {
        let bestMatch = '',
          bestMatchSubpath = '';
        const keys = Object.getOwnPropertyNames(imports);
        for (let i = -1; ++i < keys.length; ) {
          const key = keys[i],
            patternIndex = key.indexOf('*');
          if (patternIndex > -1 && name.startsWith(key.slice(0, -1))) {
            const patternTrailer = key.slice(patternIndex + 1);
            if (
              name.length >= key.length &&
              name.endsWith(patternTrailer) &&
              patternKeyCompare(bestMatch, key) === 1 &&
              key.lastIndexOf('*') === patternIndex
            ) {
              bestMatch = key;
              bestMatchSubpath = name.slice(patternIndex, name.length - patternTrailer.length);
            }
          }
        }
        if (bestMatch) {
          const resolveResult = resolvePackageTarget(
            packageJsonUrl, imports[bestMatch], bestMatchSubpath, bestMatch, base, true, true, false, conditions
          );
          if (resolveResult !== null && resolveResult !== void 0) return resolveResult;
        }
      }
  }
  throw importNotDefined(name, packageJsonUrl, base);
}
function parsePackageName(specifier, base) {
  let separatorIndex = specifier.indexOf('/'),
    validPackageName = true,
    isScoped = false;
  if (specifier[0] === '@') {
    isScoped = true;
    separatorIndex < 0 || specifier.length === 0
      ? (validPackageName = false)
      : (separatorIndex = specifier.indexOf('/', separatorIndex + 1));
  }
  const packageName = separatorIndex < 0 ? specifier : specifier.slice(0, separatorIndex);
  if (invalidPackageNameRegEx.exec(packageName) !== null) validPackageName = false;

  if (!validPackageName)
    throw new ERR_INVALID_MODULE_SPECIFIER(specifier, 'is not a valid package name', url.fileURLToPath(base));

  return { packageName, packageSubpath: '.' + (separatorIndex < 0 ? '' : specifier.slice(separatorIndex)), isScoped };
}
function packageResolve(specifier, base, conditions) {
  if (module$1.builtinModules.includes(specifier)) return new url.URL('node:' + specifier);

  const { packageName, packageSubpath, isScoped } = parsePackageName(specifier, base),
    packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    const packageJsonUrl = url.pathToFileURL(packageConfig.pjsonPath);
    if (packageConfig.name === packageName && packageConfig.exports !== void 0 && packageConfig.exports !== null)
      return packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions);
  }
  let lastPath,
    packageJsonUrl = new url.URL('./node_modules/' + packageName + '/package.json', base),
    packageJsonPath = url.fileURLToPath(packageJsonUrl);
  do {
    if (!tryStatSync(packageJsonPath.slice(0, -13)).isDirectory()) {
      lastPath = packageJsonPath;
      packageJsonUrl = new url.URL(
        (isScoped ? '../../../../node_modules/' : '../../../node_modules/') + packageName + '/package.json',
        packageJsonUrl
      );
      packageJsonPath = url.fileURLToPath(packageJsonUrl);
      continue;
    }
    const packageConfig = getPackageConfig(packageJsonPath, specifier, base);

    return packageConfig.exports !== void 0 && packageConfig.exports !== null
      ? packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions)
      : packageSubpath === '.'
      ? legacyMainResolve(packageJsonUrl, packageConfig, base)
      : new url.URL(packageSubpath, packageJsonUrl);
  } while (packageJsonPath.length !== lastPath.length);

  throw new ERR_MODULE_NOT_FOUND(packageName, url.fileURLToPath(base));
}
function isRelativeSpecifier(specifier) {
  if (specifier[0] === '.') {
    if (specifier.length === 1 || specifier[1] === '/') return true;
    if (specifier[1] === '.' && (specifier.length === 2 || specifier[2] === '/')) return true;
  }
  return false;
}
function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
  return specifier !== '' && (specifier[0] === '/' || isRelativeSpecifier(specifier));
}
function moduleResolve(specifier, base, conditions, preserveSymlinks) {
  const protocol = base.protocol,
    isRemote = protocol === 'http:' || protocol === 'https:';
  let resolved;
  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) resolved = new url.URL(specifier, base);
  else if (isRemote || specifier[0] !== '#')
    try {
      resolved = new url.URL(specifier);
    } catch (_unused4) {
      isRemote || (resolved = packageResolve(specifier, base, conditions));
    }
  else resolved = packageImportsResolve(specifier, base, conditions);

  assert(resolved !== void 0, 'expected to be defined');
  return resolved.protocol !== 'file:' ? resolved : finalizeResolution(resolved, base, preserveSymlinks);
}
function checkIfDisallowedImport(specifier, parsed, parsedParentURL) {
  if (parsedParentURL) {
    const parentProtocol = parsedParentURL.protocol;
    if (parentProtocol === 'http:' || parentProtocol === 'https:') {
      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
        const parsedProtocol = parsed == null ? void 0 : parsed.protocol;
        if (parsedProtocol && parsedProtocol !== 'https:' && parsedProtocol !== 'http:')
          throw new ERR_NETWORK_IMPORT_DISALLOWED(
            specifier, parsedParentURL, 'remote imports cannot import from a local location.'
          );

        return { url: (parsed == null ? void 0 : parsed.href) || '' };
      }
      if (module$1.builtinModules.includes(specifier))
        throw new ERR_NETWORK_IMPORT_DISALLOWED(
          specifier, parsedParentURL, 'remote imports cannot import from a local location.'
        );

      throw new ERR_NETWORK_IMPORT_DISALLOWED(
        specifier, parsedParentURL, 'only relative and absolute specifiers are supported.'
      );
    }
  }
}
function isURL(self) {
  return Boolean(
    self && typeof self == 'object' &&
    'href' in self && typeof self.href == 'string' &&
    'protocol' in self && typeof self.protocol == 'string' &&
    self.href && self.protocol
  );
}
function throwIfInvalidParentURL(parentURL) {
  if (parentURL !== void 0 && typeof parentURL != 'string' && !isURL(parentURL))
    throw new codes.ERR_INVALID_ARG_TYPE('parentURL', ['string', 'URL'], parentURL);
}
function throwIfUnsupportedURLProtocol(url) {
  const protocol = url.protocol;
  if (protocol !== 'file:' && protocol !== 'data:' && protocol !== 'node:')
    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(url);
}
function throwIfUnsupportedURLScheme(parsed, experimentalNetworkImports) {
  const protocol = parsed == null ? void 0 : parsed.protocol;
  if (
    protocol && protocol !== 'file:' && protocol !== 'data:' &&
    (!experimentalNetworkImports || (protocol !== 'https:' && protocol !== 'http:'))
  )
    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(
      parsed, ['file', 'data'].concat(experimentalNetworkImports ? ['https', 'http'] : [])
    );
}
function defaultResolve(specifier, context = {}) {
  const { parentURL } = context;
  assert(parentURL !== void 0, 'expected `parentURL` to be defined');
  throwIfInvalidParentURL(parentURL);
  let parsedParentURL, parsed;
  if (parentURL)
    try {
      parsedParentURL = new url.URL(parentURL);
    } catch (_unused5) {}

  try {
    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier)
      ? new url.URL(specifier, parsedParentURL)
      : new url.URL(specifier);
    const protocol = parsed.protocol;
    if (protocol === 'data:' || (experimentalNetworkImports && (protocol === 'https:' || protocol === 'http:')))
      return { url: parsed.href, format: null };
  } catch (_unused6) {}
  const maybeReturn = checkIfDisallowedImport(specifier, parsed, parsedParentURL);
  if (maybeReturn) return maybeReturn;
  if (parsed && parsed.protocol === 'node:') return { url: specifier };
  throwIfUnsupportedURLScheme(parsed, experimentalNetworkImports);
  const conditions = getConditionsSet(context.conditions),
    url$1 = moduleResolve(specifier, new url.URL(parentURL), conditions, false);
  throwIfUnsupportedURLProtocol(url$1);
  return { url: url$1.href, format: defaultGetFormatWithoutErrors(url$1, { parentURL }) };
}
function resolve$1(specifier, parent) {
  if (!parent) throw new Error('Please pass `parent`: `import-meta-resolve` cannot ponyfill that');

  try {
    return defaultResolve(specifier, { parentURL: parent }).url;
  } catch (error) {
    const exception = error;
    if (exception.code === 'ERR_UNSUPPORTED_DIR_IMPORT' && typeof exception.url == 'string') return exception.url;

    throw error;
  }
}

const debug = traverse.buildDebug("babel:config:loading:files:plugins"),
  EXACT_RE = /^module:/,
  BABEL_PLUGIN_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-plugin-)/,
  BABEL_PRESET_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-preset-)/,
  BABEL_PLUGIN_ORG_RE = /^(@babel\/)(?!plugin-|[^/]+\/)/,
  BABEL_PRESET_ORG_RE = /^(@babel\/)(?!preset-|[^/]+\/)/,
  OTHER_PLUGIN_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/,
  OTHER_PRESET_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/,
  OTHER_ORG_DEFAULT_RE = /^(@(?!babel$)[^/]+)$/,
  resolvePlugin = resolveStandardizedName.bind(null, "plugin"),
  resolvePreset = resolveStandardizedName.bind(null, "preset");
function* loadPlugin(name, dirname) {
  const filepath = resolvePlugin(name, dirname, yield* isAsync()),
    value = yield* requireModule("plugin", filepath);
  debug("Loaded plugin %o from %o.", name, dirname);
  return { filepath, value };
}
function* loadPreset(name, dirname) {
  const filepath = resolvePreset(name, dirname, yield* isAsync()),
    value = yield* requireModule("preset", filepath);
  debug("Loaded preset %o from %o.", name, dirname);
  return { filepath, value };
}
function standardizeName(type, name) {
  if (path.isAbsolute(name)) return name;
  const isPreset = type === "preset";
  return name
    .replace(isPreset ? BABEL_PRESET_PREFIX_RE : BABEL_PLUGIN_PREFIX_RE, `babel-${type}-`)
    .replace(isPreset ? BABEL_PRESET_ORG_RE : BABEL_PLUGIN_ORG_RE, `$1${type}-`)
    .replace(isPreset ? OTHER_PRESET_ORG_RE : OTHER_PLUGIN_ORG_RE, `$1babel-${type}-`)
    .replace(OTHER_ORG_DEFAULT_RE, "$1/babel-" + type)
    .replace(EXACT_RE, "");
}
function* resolveAlternativesHelper(type, name) {
  const standardizedName = standardizeName(type, name),
    { error, value } = yield standardizedName;
  if (!error) return value;
  if (error.code !== "MODULE_NOT_FOUND") throw error;
  standardizedName === name || (yield name).error ||
    (error.message += `\n- If you want to resolve "${name}", use "module:${name}"`);

  (yield standardizeName(type, "@babel/" + name)).error || (error.message += `\n- Did you mean "@babel/${name}"?`);

  const oppositeType = type === "preset" ? "plugin" : "preset";
  (yield standardizeName(oppositeType, name)).error ||
    (error.message += `\n- Did you accidentally pass a ${oppositeType} as a ${type}?`);

  if (type === "plugin") {
    const transformName = standardizedName.replace("-proposal-", "-transform-");
    transformName === standardizedName || (yield transformName).error ||
      (error.message += `\n- Did you mean "${transformName}"?`);
  }
  error.message += `\n
Make sure that all the Babel plugins and presets you are using
are defined as dependencies or devDependencies in your package.json
file. It's possible that the missing plugin is loaded by a preset
you are using that forgot to add the plugin to its dependencies: you
can workaround this problem by explicitly adding the missing package
to your top-level package.json.
`;
  throw error;
}
function tryRequireResolve(id, dirname) {
  try {
    return dirname
      ? { error: null, value: require.resolve(id, { paths: [dirname] }) }
      : { error: null, value: require.resolve(id) };
  } catch (error) {
    return { error, value: null };
  }
}
function tryImportMetaResolve(id, options) {
  try {
    return { error: null, value: resolve$1(id, options) };
  } catch (error) {
    return { error, value: null };
  }
}
function resolveStandardizedNameForRequire(type, name, dirname) {
  const it = resolveAlternativesHelper(type, name);
  let res = it.next();
  while (!res.done) res = it.next(tryRequireResolve(res.value, dirname));

  return res.value;
}
function resolveStandardizedNameForImport(type, name, dirname) {
  const parentUrl = url.pathToFileURL(path.join(dirname, "./babel-virtual-resolve-base.js")).href,
    it = resolveAlternativesHelper(type, name);
  let res = it.next();
  while (!res.done) res = it.next(tryImportMetaResolve(res.value, parentUrl));

  return url.fileURLToPath(res.value);
}
function resolveStandardizedName(type, name, dirname, resolveESM) {
  if (!supportsESM || !resolveESM) return resolveStandardizedNameForRequire(type, name, dirname);

  try {
    return resolveStandardizedNameForImport(type, name, dirname);
  } catch (e) {
    try {
      return resolveStandardizedNameForRequire(type, name, dirname);
    } catch (e2) {
      if (e.type === "MODULE_NOT_FOUND") throw e;
      if (e2.type === "MODULE_NOT_FOUND") throw e2;
      throw e;
    }
  }
}

var LOADING_MODULES = new Set();

function* requireModule(type, name) {
  if (!(yield* isAsync()) && LOADING_MODULES.has(name))
    throw new Error(
      `Reentrant ${type} detected trying to load "${name}". This module is not ignored and is trying to load itself while compiling itself, leading to a dependency cycle. We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.`
    );

  try {
    LOADING_MODULES.add(name);

    return yield* loadCodeDefault(name,
      `You appear to be using a native ECMAScript module ${type}, which is only supported when running Babel asynchronously.`,
      true);
  } catch (err) {
    err.message = `[BABEL]: ${err.message} (While processing: ${name})`;
    throw err;
  } finally {
    LOADING_MODULES.delete(name);
  }
}

const transformRunner = gensync(function* (code, opts) {
  const config = yield* loadConfig$1(opts);
  return config === null ? null : yield* run(config, code);
});
const transform$2 = function (code, optsOrCallback, maybeCallback) {
  let opts, callback;
  if (typeof optsOrCallback == "function") {
    callback = optsOrCallback;
    opts = void 0;
  } else {
    opts = optsOrCallback;
    callback = maybeCallback;
  }
  if (callback === void 0) return beginHiddenCallStack(transformRunner.sync)(code, opts);

  beginHiddenCallStack(transformRunner.errback)(code, opts, callback);
};
function transformSync(...args) {
  return beginHiddenCallStack(transformRunner.sync)(...args);
}
function transformAsync$1(...args) {
  return beginHiddenCallStack(transformRunner.async)(...args);
}

const transformFromAstRunner = gensync(function* (ast, code, opts) {
  const config = yield* loadConfig$1(opts);
  if (config === null) return null;
  if (!ast) throw new Error("No AST given");
  return yield* run(config, code, ast);
});
const transformFromAst$1 = function (ast, code, optsOrCallback, maybeCallback) {
  let opts, callback;
  if (typeof optsOrCallback == "function") {
    callback = optsOrCallback;
    opts = void 0;
  } else {
    opts = optsOrCallback;
    callback = maybeCallback;
  }
  if (callback === void 0) return beginHiddenCallStack(transformFromAstRunner.sync)(ast, code, opts);

  beginHiddenCallStack(transformFromAstRunner.errback)(ast, code, opts, callback);
};
function transformFromAstSync(...args) {
  return beginHiddenCallStack(transformFromAstRunner.sync)(...args);
}
function transformFromAstAsync$1(...args) {
  return beginHiddenCallStack(transformFromAstRunner.async)(...args);
}

const parseRunner = gensync(function* (code, opts) {
  const config = yield* loadConfig$1(opts);
  return config === null ? null : yield* parser(config.passes, normalizeOptions$4(config), code);
});
const parse = function (code, opts, callback) {
  if (typeof opts == "function") {
    callback = opts;
    opts = void 0;
  }
  if (callback === void 0) return beginHiddenCallStack(parseRunner.sync)(code, opts);

  beginHiddenCallStack(parseRunner.errback)(code, opts, callback);
};
function parseSync(...args) {
  return beginHiddenCallStack(parseRunner.sync)(...args);
}
function parseAsync(...args) {
  return beginHiddenCallStack(parseRunner.async)(...args);
}

const version$1 = "7.22.20",
  DEFAULT_EXTENSIONS = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]);

function makeNoopPlugin() {
  let p;
  return ((p = () => ({})).default = p);
}

var externalHelpers = declare((api, options) => {
  api.assertVersion(7);
  const { helperVersion = "7.0.0-beta.0", whitelist = false } = options;
  if (whitelist !== false && (!Array.isArray(whitelist) || whitelist.some(w => typeof w != "string")))
    throw new Error(".whitelist must be undefined, false, or an array of strings");

  const helperWhitelist = whitelist ? new Set(whitelist) : null;
  return {
    name: "external-helpers",
    pre(file) {
      file.set("helperGenerator", name => {
        if (
          (!file.availableHelper || file.availableHelper(name, helperVersion)) &&
          (!helperWhitelist || helperWhitelist.has(name))
        )
          return t$5.memberExpression(t$5.identifier("babelHelpers"), t$5.identifier(name));
      });
    }
  };
});

var syntaxDecimal = declare(api => {
  api.assertVersion(7);
  return {
    name: "syntax-decimal",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("decimal");
    }
  };
});

var syntaxDecorators = declare((api, options) => {
  api.assertVersion(7);
  let { version } = options;

  const { legacy } = options;
  if (legacy !== void 0) {
    if (typeof legacy != "boolean") throw new Error(".legacy must be a boolean.");

    if (version !== void 0) throw new Error("You can either use the .legacy or the .version option, not both.");
  }
  if (version === void 0) version = legacy ? "legacy" : "2018-09";
  else if (
    version !== "2023-05" && version !== "2023-01" &&
    version !== "2022-03" && version !== "2021-12" &&
    version !== "2018-09" && version !== "legacy"
  )
    throw new Error("Unsupported decorators version: " + version);

  var { decoratorsBeforeExport } = options;
  if (decoratorsBeforeExport === void 0) {
    if (version === "2021-12" || version === "2022-03") decoratorsBeforeExport = false;
    else if (version === "2018-09")
      throw new Error(
        "The decorators plugin, when .version is '2018-09' or not specified, requires a 'decoratorsBeforeExport' option, whose value must be a boolean."
      );
  } else {
    if (version === "legacy" || version === "2022-03" || version === "2023-01")
      throw new Error(`'decoratorsBeforeExport' can't be used with ${version} decorators.`);

    if (typeof decoratorsBeforeExport != "boolean") throw new Error("'decoratorsBeforeExport' must be a boolean.");
  }

  return {
    name: "syntax-decorators",
    manipulateOptions({ generatorOpts }, parserOpts) {
      if (version === "legacy") parserOpts.plugins.push("decorators-legacy");
      else if (version === "2023-01" || version === "2023-05")
        parserOpts.plugins.push(["decorators", { allowCallParenthesized: false }], "decoratorAutoAccessors");
      else if (version === "2022-03")
        parserOpts.plugins.push(
          ["decorators", { decoratorsBeforeExport: false, allowCallParenthesized: false }],
          "decoratorAutoAccessors"
        );
      else if (version === "2021-12") {
        parserOpts.plugins.push(["decorators", { decoratorsBeforeExport }], "decoratorAutoAccessors");
        generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;
      } else if (version === "2018-09") {
        parserOpts.plugins.push(["decorators", { decoratorsBeforeExport }]);
        generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;
      }
    }
  };
});

var syntaxDestructuringPrivate = declare(api => {
  api.assertVersion(7);
  return {
    name: "syntax-destructuring-private",
    manipulateOptions(_, parserOpts) {
      parserOpts.plugins.push("destructuringPrivate");
    }
  };
});

var syntaxDoExpressions = declare(api => {
  api.assertVersion(7);
  return {
    name: "syntax-do-expressions",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("doExpressions");
    }
  };
});

var syntaxExplicitResourceManagement = declare(api => {
  api.assertVersion(7);
  return {
    name: "syntax-explicit-resource-management",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("explicitResourceManagement");
    }
  };
});

var syntaxExportDefaultFrom = declare(api => {
  api.assertVersion(7);
  return {
    name: "syntax-export-default-from",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("exportDefaultFrom");
    }
  };
});

var syntaxFlow = declare((api, options) => {
  api.assertVersion(7);
  const { all, enums } = options;
  if (typeof all != "boolean" && all !== void 0) throw new Error(".all must be a boolean, or undefined");

  if (typeof enums != "boolean" && enums !== void 0) throw new Error(".enums must be a boolean, or undefined");

  return {
    name: "syntax-flow",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.some(p => (Array.isArray(p) ? p[0] : p) === "typescript") ||
        parserOpts.plugins.push(["flow", { all, enums }]);
    }
  };
});

var syntaxFunctionBind = declare(api => {
  api.assertVersion(7);
  return {
    name: "syntax-function-bind",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("functionBind");
    }
  };
});

var syntaxFunctionSent = declare(api => {
  api.assertVersion(7);
  return {
    name: "syntax-function-sent",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("functionSent");
    }
  };
});

var syntaxImportAssertions = declare(api => {
  api.assertVersion(7);
  return {
    name: "syntax-import-assertions",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("importAssertions");
    }
  };
});

var syntaxImportAttributes = declare((api, { deprecatedAssertSyntax }) => {
  api.assertVersion("^7.22.0");
  if (deprecatedAssertSyntax != null && typeof deprecatedAssertSyntax != "boolean")
    throw new Error("'deprecatedAssertSyntax' must be a boolean, if specified.");

  return {
    name: "syntax-import-attributes",
    manipulateOptions({ parserOpts, generatorOpts }) {
      generatorOpts.importAttributesKeyword != null || (generatorOpts.importAttributesKeyword = "with");
      parserOpts.plugins.push(["importAttributes", { deprecatedAssertSyntax: Boolean(deprecatedAssertSyntax) }]);
    }
  };
});

var syntaxImportReflection = declare(api => {
  api.assertVersion(7);
  return {
    name: "syntax-import-reflection",
    manipulateOptions(_, parserOpts) {
      parserOpts.plugins.push("importReflection");
    }
  };
});

var syntaxModuleBlocks = declare(api => {
  api.assertVersion(7);
  return {
    name: "syntax-module-blocks",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("moduleBlocks");
    }
  };
});

const PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"],
  TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"],
  documentationURL = "https://babeljs.io/docs/en/babel-plugin-proposal-pipeline-operator";
var syntaxPipelineOperator = declare((api, { proposal, topicToken }) => {
  api.assertVersion(7);
  if (typeof proposal != "string" || !PIPELINE_PROPOSALS.includes(proposal)) {
    const proposalList = PIPELINE_PROPOSALS.map(p => `"${p}"`).join(", ");
    throw new Error(
      `The pipeline plugin requires a "proposal" option. "proposal" must be one of: ${proposalList}. See <${documentationURL}>.`
    );
  }
  if (proposal === "hack" && !TOPIC_TOKENS.includes(topicToken)) {
    const topicTokenList = TOPIC_TOKENS.map(t => `"${t}"`).join(", ");
    throw new Error(
      `The pipeline plugin in "proposal": "hack" mode also requires a "topicToken" option. "topicToken" must be one of: ${topicTokenList}. See <${documentationURL}>.`
    );
  }
  return {
    name: "syntax-pipeline-operator",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push(["pipelineOperator", { proposal, topicToken }]);
      opts.generatorOpts.topicToken = topicToken;
    }
  };
});

var syntaxRecordAndTuple = declare((api, options) => {
  api.assertVersion(7);
  return {
    name: "syntax-record-and-tuple",
    manipulateOptions(opts, parserOpts) {
      opts.generatorOpts.recordAndTupleSyntaxType = options.syntaxType;
      parserOpts.plugins.push(["recordAndTuple", { syntaxType: options.syntaxType }]);
    }
  };
});

const {
  blockStatement,
  callExpression: callExpression$2,
  functionExpression,
  isAssignmentPattern: isAssignmentPattern$2,
  isFunctionDeclaration,
  isRestElement: isRestElement$1,
  returnStatement,
  isCallExpression: isCallExpression$1
} = t$5;
const buildAnonymousExpressionWrapper = template$1.expression(`
  (function () {
    var REF = FUNCTION;
    return function NAME(PARAMS) {
      return REF.apply(this, arguments);
    };
  })()
`);
const buildNamedExpressionWrapper = template$1.expression(`
  (function () {
    var REF = FUNCTION;
    function NAME(PARAMS) {
      return REF.apply(this, arguments);
    }
    return NAME;
  })()
`);
const buildLooseDeclaration = template$1.statement(`
  var NAME = FUNCTION;
`);
const buildDeclarationWrapper = template$1.statements(`
  function NAME(PARAMS) { return REF.apply(this, arguments); }
  function REF() {
    REF = FUNCTION;
    return REF.apply(this, arguments);
  }
`);
function classOrObjectMethod(path, callId) {
  const node = path.node,
    body = node.body,
    container = functionExpression(null, [], blockStatement(body.body), true);
  body.body = [returnStatement(callExpression$2(callExpression$2(callId, [container]), []))];
  node.async = false;
  node.generator = false;
  path.get("body.body.0.argument.callee.arguments.0").unwrapFunctionEnvironment();
}
function plainFunction(inPath, callId, noNewArrows, ignoreFunctionLength, loose) {
  let node,
    path = inPath,
    functionId = null;
  const nodeParams = inPath.node.params;
  if (path.isArrowFunctionExpression()) {
    var _path$arrowFunctionTo = path.arrowFunctionToExpression({ noNewArrows });
    path = _path$arrowFunctionTo != null ? _path$arrowFunctionTo : path;

    node = path.node;
  } else node = path.node;

  const isDeclaration = isFunctionDeclaration(node);
  let built = node;
  if (!isCallExpression$1(node)) {
    functionId = node.id;
    node.id = null;
    node.type = "FunctionExpression";
    built = callExpression$2(callId, [node]);
  }
  const params = [];
  for (const param of nodeParams) {
    if (isAssignmentPattern$2(param) || isRestElement$1(param)) break;

    params.push(path.scope.generateUidIdentifier("x"));
  }
  const wrapperArgs = {
    NAME: functionId || null,
    REF: path.scope.generateUidIdentifier(functionId ? functionId.name : "ref"),
    FUNCTION: built,
    PARAMS: params
  };
  if (isDeclaration) {
    if (loose) {
      path.replaceWith(buildLooseDeclaration({ NAME: functionId, FUNCTION: built }));
      return;
    }
    const container = buildDeclarationWrapper(wrapperArgs);
    path.replaceWith(container[0]);
    path.insertAfter(container[1]);
  } else {
    let container;
    if (functionId) container = buildNamedExpressionWrapper(wrapperArgs);
    else if (!loose) {
      container = buildAnonymousExpressionWrapper(wrapperArgs);
      const returnFn = container.callee.body.body[1].argument;
      nameFunction({ node: returnFn, parent: path.parent, scope: path.scope });
      functionId = returnFn.id;
    }
    functionId || (container && !ignoreFunctionLength && params.length)
      ? path.replaceWith(container)
      : path.replaceWith(built);
  }
}
function wrapFunction(path, callId, noNewArrows = true, ignoreFunctionLength = false, loose = false) {
  path.isMethod()
    ? classOrObjectMethod(path, callId)
    : plainFunction(path, callId, noNewArrows, ignoreFunctionLength, loose);
}

const {
  callExpression: callExpression$1,
  cloneNode: cloneNode$2,
  isIdentifier: isIdentifier$4,
  isThisExpression,
  yieldExpression
} = t$5;
const awaitVisitor$1 = traverse.visitors.merge([{
  ArrowFunctionExpression(path) {
    path.skip();
  },
  AwaitExpression(path, { wrapAwait }) {
    const argument = path.get("argument");
    path.replaceWith(
      yieldExpression(wrapAwait ? callExpression$1(cloneNode$2(wrapAwait), [argument.node]) : argument.node)
    );
  }
}, visitor$5]);
function remapAsyncToGenerator(path, helpers, noNewArrows, ignoreFunctionLength, loose) {
  path.traverse(awaitVisitor$1, { wrapAwait: helpers.wrapAwait });
  const isIIFE = checkIsIIFE(path);
  path.node.async = false;
  path.node.generator = true;
  wrapFunction(path, cloneNode$2(helpers.wrapAsync), noNewArrows, ignoreFunctionLength, loose);
  path.isObjectMethod() || path.isClassMethod() ||
    path.parentPath.isObjectProperty() || path.parentPath.isClassProperty() ||
    isIIFE || !path.isExpression() ||
    annotateAsPure(path);

  function checkIsIIFE(path) {
    if (path.parentPath.isCallExpression({ callee: path.node })) return true;

    const { parentPath } = path;
    if (parentPath.isMemberExpression() && isIdentifier$4(parentPath.node.property, { name: "bind" })) {
      const { parentPath: bindCall } = parentPath;
      return (
        bindCall.isCallExpression() &&
        bindCall.node.arguments.length === 1 && isThisExpression(bindCall.node.arguments[0]) &&
        bindCall.parentPath.isCallExpression({ callee: bindCall.node })
      );
    }
    return false;
  }
}

const buildForAwait = template$1.default(`
  async function wrapper() {
    var ITERATOR_ERROR_KEY,
      ITERATOR_ABRUPT_COMPLETION = false,
      ITERATOR_HAD_ERROR_KEY = false;
    try {
      for (
        var STEP_KEY, ITERATOR_KEY = GET_ITERATOR(OBJECT);
        ITERATOR_ABRUPT_COMPLETION = !(STEP_KEY = await ITERATOR_KEY.next()).done;
        ITERATOR_ABRUPT_COMPLETION = false
      );
    } catch (err) {
      ITERATOR_HAD_ERROR_KEY = true;
      ITERATOR_ERROR_KEY = err;
    } finally {
      try {
        if (ITERATOR_ABRUPT_COMPLETION && ITERATOR_KEY.return != null) await ITERATOR_KEY.return();
      } finally {
        if (ITERATOR_HAD_ERROR_KEY) throw ITERATOR_ERROR_KEY;
      }
    }
  }
`);
function rewriteForAwait(path, { getAsyncIterator }) {
  const { node, scope, parent } = path,
    stepKey = scope.generateUidIdentifier("step"),
    stepValue = t$5.memberExpression(stepKey, t$5.identifier("value")),
    left = node.left;
  let declar;
  if (t$5.isIdentifier(left) || t$5.isPattern(left) || t$5.isMemberExpression(left))
    declar = t$5.expressionStatement(t$5.assignmentExpression("=", left, stepValue));
  else if (t$5.isVariableDeclaration(left))
    declar = t$5.variableDeclaration(left.kind, [t$5.variableDeclarator(left.declarations[0].id, stepValue)]);

  let template = buildForAwait({
    ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
    ITERATOR_ABRUPT_COMPLETION: scope.generateUidIdentifier("iteratorAbruptCompletion"),
    ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
    ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
    GET_ITERATOR: getAsyncIterator,
    OBJECT: node.right,
    STEP_KEY: t$5.cloneNode(stepKey)
  });
  template = template.body.body;
  const isLabeledParent = t$5.isLabeledStatement(parent),
    tryBody = template[3].block.body,
    loop = tryBody[0];
  if (isLabeledParent) tryBody[0] = t$5.labeledStatement(parent.label, loop);

  return { replaceParent: isLabeledParent, node: template, declar, loop };
}

var proposalAsyncGeneratorFunctions = declare(api => {
  api.assertVersion(7);
  const yieldStarVisitor = traverse.visitors.merge([{
    ArrowFunctionExpression(path) {
      path.skip();
    },
    YieldExpression({ node }, state) {
      if (!node.delegate) return;
      const asyncIter = t$5.callExpression(state.addHelper("asyncIterator"), [node.argument]);
      node.argument = t$5.callExpression(state.addHelper("asyncGeneratorDelegate"), [
        asyncIter, state.addHelper("awaitAsyncGenerator")
      ]);
    }
  }, visitor$5]);
  const forAwaitVisitor = traverse.visitors.merge([{
    ArrowFunctionExpression(path) {
      path.skip();
    },
    ForOfStatement(path, { file }) {
      const { node } = path;
      if (!node.await) return;
      const build = rewriteForAwait(path, { getAsyncIterator: file.addHelper("asyncIterator") }),
        { declar, loop } = build,
        block = loop.body;
      path.ensureBlock();
      if (declar) {
        block.body.push(declar);
        path.node.body.body.length && block.body.push(t$5.blockStatement(path.node.body.body));
      } else block.body.push(...path.node.body.body);

      t$5.inherits(loop, node);
      t$5.inherits(loop.body, node.body);
      const p = build.replaceParent ? path.parentPath : path;
      p.replaceWithMultiple(build.node);
      p.scope.parent.crawl();
    }
  }, visitor$5]);
  const visitor = {
    Function(path, state) {
      if (!path.node.async) return;
      path.traverse(forAwaitVisitor, state);
      if (!path.node.generator) return;
      path.traverse(yieldStarVisitor, state);
      remapAsyncToGenerator(path, {
        wrapAsync: state.addHelper("wrapAsyncGenerator"),
        wrapAwait: state.addHelper("awaitAsyncGenerator")
      });
    }
  };
  return {
    name: "transform-async-generator-functions",
    inherits: void 0,
    visitor: {
      Program(path, state) {
        path.traverse(visitor, state);
      }
    }
  };
});

var proposalClassProperties = declare((api, options) => {
  api.assertVersion(7);
  return createClassFeaturePlugin({
    name: "transform-class-properties",
    api,
    feature: FEATURES$1.fields,
    loose: options.loose,
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("classProperties", "classPrivateProperties");
    }
  });
});

function generateUid(scope, denyList) {
  const name = "";
  let uid,
    i = 1;
  do {
    uid = scope._generateUid(name, i);
    i++;
  } while (denyList.has(uid));
  return uid;
}
var proposalClassStaticBlock = declare(({ types: t, template, assertVersion }) => {
  assertVersion("^7.12.0");
  return {
    name: "transform-class-static-block",
    inherits: void 0,
    pre() {
      enableFeature$1(this.file, FEATURES$1.staticBlocks, false);
    },
    visitor: {
      ClassBody(classBody) {
        const { scope } = classBody,
          privateNames = new Set(),
          body = classBody.get("body");
        for (const path of body) path.isPrivate() && privateNames.add(path.get("key.id").node.name);

        for (const path of body) {
          if (!path.isStaticBlock()) continue;
          const staticBlockPrivateId = generateUid(scope, privateNames);
          privateNames.add(staticBlockPrivateId);
          const staticBlockRef = t.privateName(t.identifier(staticBlockPrivateId)),
            blockBody = path.node.body;
          let replacement =
            blockBody.length === 1 && t.isExpressionStatement(blockBody[0])
              ? t.inheritsComments(blockBody[0].expression, blockBody[0])
              : template.expression.ast`(() => { ${blockBody} })()`;

          path.replaceWith(t.classPrivateProperty(staticBlockRef, replacement, [], true));
        }
      }
    }
  };
});

const buildClassDecorator = template$1.statement(`
  DECORATOR(CLASS_REF = INNER) || CLASS_REF;
`);
const buildClassPrototype = template$1.default(`
  CLASS_REF.prototype;
`);
const buildGetDescriptor = template$1.default(`
  Object.getOwnPropertyDescriptor(TARGET, PROPERTY);
`);
const buildGetObjectInitializer = template$1.default(`
  (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : void 0), {
    enumerable: true,
    configurable: true,
    writable: true,
    initializer: function() { return TEMP; }
  })
`);
const WARNING_CALLS = new WeakSet();
function applyEnsureOrdering(path) {
  const identDecorators = (path.isClass() ? [path, ...path.get("body.body")] : path.get("properties"))
    .reduce((acc, prop) => acc.concat(prop.node.decorators || []), [])
    .filter(decorator => !t$5.isIdentifier(decorator.expression));
  if (identDecorators.length !== 0)
    return t$5.sequenceExpression(
      identDecorators.map(decorator => {
        const expression = decorator.expression,
          id = (decorator.expression = path.scope.generateDeclaredUidIdentifier("dec"));
        return t$5.assignmentExpression("=", id, expression);
      }).concat([path.node])
    );
}
function applyClassDecorators(classPath) {
  if (!hasClassDecorators(classPath.node)) return;
  const decorators = classPath.node.decorators || [];
  classPath.node.decorators = null;
  const name = classPath.scope.generateDeclaredUidIdentifier("class");
  return decorators.map(dec => dec.expression).reverse().reduce(function (acc, decorator) {
    return buildClassDecorator({
      CLASS_REF: t$5.cloneNode(name),
      DECORATOR: t$5.cloneNode(decorator),
      INNER: acc
    }).expression;
  }, classPath.node);
}
function hasClassDecorators(classNode) {
  var _classNode$decorators;
  return !((_classNode$decorators = classNode.decorators) == null || !_classNode$decorators.length);
}
function applyMethodDecorators(path, state) {
  if (hasMethodDecorators(path.node.body.body)) return applyTargetDecorators(path, state, path.node.body.body);
}
function hasMethodDecorators(body) {
  return body.some(node => {
    var _node$decorators;
    return (_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length;
  });
}
function applyObjectDecorators(path, state) {
  if (hasMethodDecorators(path.node.properties))
    return applyTargetDecorators(path, state, path.node.properties.filter(prop => prop.type !== "SpreadElement"));
}
function applyTargetDecorators(path, state, decoratedProps) {
  const name = path.scope.generateDeclaredUidIdentifier(path.isClass() ? "class" : "obj");
  const exprs = decoratedProps.reduce(function (acc, node) {
    let decorators = [];
    if (node.decorators != null) {
      decorators = node.decorators;
      node.decorators = null;
    }
    if (decorators.length === 0) return acc;
    if (node.computed) throw path.buildCodeFrameError("Computed method/property decorators are not yet supported.");

    const property = t$5.isLiteral(node.key) ? node.key : t$5.stringLiteral(node.key.name),
      target = path.isClass() && !node.static ? buildClassPrototype({ CLASS_REF: name }).expression : name;
    if (t$5.isClassProperty(node, { static: false })) {
      const descriptor = path.scope.generateDeclaredUidIdentifier("descriptor");
      const initializer = node.value
        ? t$5.functionExpression(null, [], t$5.blockStatement([t$5.returnStatement(node.value)]))
        : t$5.nullLiteral();
      node.value = t$5.callExpression(state.addHelper("initializerWarningHelper"), [descriptor, t$5.thisExpression()]);
      WARNING_CALLS.add(node.value);
      acc.push(t$5.assignmentExpression("=",
        t$5.cloneNode(descriptor),
        t$5.callExpression(state.addHelper("applyDecoratedDescriptor"), [
          t$5.cloneNode(target), t$5.cloneNode(property),
          t$5.arrayExpression(decorators.map(dec => t$5.cloneNode(dec.expression))),
          t$5.objectExpression([
            t$5.objectProperty(t$5.identifier("configurable"), t$5.booleanLiteral(true)),
            t$5.objectProperty(t$5.identifier("enumerable"), t$5.booleanLiteral(true)),
            t$5.objectProperty(t$5.identifier("writable"), t$5.booleanLiteral(true)),
            t$5.objectProperty(t$5.identifier("initializer"), initializer)
          ])
        ])
      ));
    } else
      acc.push(t$5.callExpression(state.addHelper("applyDecoratedDescriptor"), [
        t$5.cloneNode(target), t$5.cloneNode(property),
        t$5.arrayExpression(decorators.map(dec => t$5.cloneNode(dec.expression))),
        t$5.isObjectProperty(node) || t$5.isClassProperty(node, { static: true })
          ? buildGetObjectInitializer({
              TEMP: path.scope.generateDeclaredUidIdentifier("init"),
              TARGET: t$5.cloneNode(target),
              PROPERTY: t$5.cloneNode(property)
            }).expression
          : buildGetDescriptor({ TARGET: t$5.cloneNode(target), PROPERTY: t$5.cloneNode(property) }).expression,
        t$5.cloneNode(target)
      ]));

    return acc;
  }, []);
  return t$5.sequenceExpression([
    t$5.assignmentExpression("=", t$5.cloneNode(name), path.node), t$5.sequenceExpression(exprs), t$5.cloneNode(name)
  ]);
}
function decoratedClassToExpression({ node, scope }) {
  if (!hasClassDecorators(node) && !hasMethodDecorators(node.body.body)) return;

  const ref = node.id ? t$5.cloneNode(node.id) : scope.generateUidIdentifier("class");
  return t$5.variableDeclaration("let", [t$5.variableDeclarator(ref, t$5.toExpression(node))]);
}
const visitor$2 = {
  ExportDefaultDeclaration(path) {
    const decl = path.get("declaration");
    if (!decl.isClassDeclaration()) return;
    const replacement = decoratedClassToExpression(decl);
    if (replacement) {
      const [varDeclPath] = path.replaceWithMultiple([
        replacement,
        t$5.exportNamedDeclaration(null, [
          t$5.exportSpecifier(t$5.cloneNode(replacement.declarations[0].id), t$5.identifier("default"))
        ])
      ]);
      decl.node.id || path.scope.registerDeclaration(varDeclPath);
    }
  },
  ClassDeclaration(path) {
    const replacement = decoratedClassToExpression(path);
    if (replacement) {
      const [newPath] = path.replaceWith(replacement),
        decl = newPath.get("declarations.0"),
        id = decl.node.id,
        binding = path.scope.getOwnBinding(id.name);
      binding.identifier = id;
      binding.path = decl;
    }
  },
  ClassExpression(path, state) {
    const decoratedClass = applyEnsureOrdering(path) || applyClassDecorators(path) || applyMethodDecorators(path, state);
    decoratedClass && path.replaceWith(decoratedClass);
  },
  ObjectExpression(path, state) {
    const decoratedObject = applyEnsureOrdering(path) || applyObjectDecorators(path, state);
    decoratedObject && path.replaceWith(decoratedObject);
  },
  AssignmentExpression(path, state) {
    WARNING_CALLS.has(path.node.right) &&
      path.replaceWith(t$5.callExpression(state.addHelper("initializerDefineProperty"), [
        t$5.cloneNode(path.get("left.object").node),
        t$5.stringLiteral(path.get("left.property").node.name || path.get("left.property").node.value),
        t$5.cloneNode(path.get("right.arguments")[0].node),
        t$5.cloneNode(path.get("right.arguments")[1].node)
      ]));
  },
  CallExpression(path, state) {
    path.node.arguments.length === 3 &&
      WARNING_CALLS.has(path.node.arguments[2]) &&
      path.node.callee.name === state.addHelper("defineProperty").name &&
      path.replaceWith(t$5.callExpression(state.addHelper("initializerDefineProperty"), [
        t$5.cloneNode(path.get("arguments")[0].node),
        t$5.cloneNode(path.get("arguments")[1].node),
        t$5.cloneNode(path.get("arguments.2.arguments")[0].node),
        t$5.cloneNode(path.get("arguments.2.arguments")[1].node)
      ]));
  }
};

function incrementId(id, idx = id.length - 1) {
  if (idx === -1) {
    id.unshift(65);
    return;
  }
  const current = id[idx];
  if (current === 90) id[idx] = 97;
  else if (current === 122) {
    id[idx] = 65;
    incrementId(id, idx - 1);
  } else id[idx] = current + 1;
}
function createPrivateUidGeneratorForClass(classPath) {
  const currentPrivateId = [],
    privateNames = new Set();
  classPath.traverse({
    PrivateName(path) {
      privateNames.add(path.node.id.name);
    }
  });
  return () => {
    let reifiedId;
    do {
      incrementId(currentPrivateId);
      reifiedId = String.fromCharCode(...currentPrivateId);
    } while (privateNames.has(reifiedId));
    return t$5.privateName(t$5.identifier(reifiedId));
  };
}
function createLazyPrivateUidGeneratorForClass(classPath) {
  let generator;
  return () => {
    generator || (generator = createPrivateUidGeneratorForClass(classPath));

    return generator();
  };
}
function replaceClassWithVar(path) {
  if (path.type === "ClassDeclaration") {
    const varId = path.scope.generateUidIdentifierBasedOnNode(path.node.id),
      classId = t$5.identifier(path.node.id.name);
    path.scope.rename(classId.name, varId.name);
    path.insertBefore(t$5.variableDeclaration("let", [t$5.variableDeclarator(varId)]));
    path.get("id").replaceWith(classId);
    return [t$5.cloneNode(varId), path];
  }
  //{
  let className, varId;
  if (path.node.id) {
    className = path.node.id.name;
    varId = path.scope.parent.generateDeclaredUidIdentifier(className);
    path.scope.rename(className, varId.name);
  } else if (path.parentPath.node.type === "VariableDeclarator" && path.parentPath.node.id.type === "Identifier") {
    className = path.parentPath.node.id.name;
    varId = path.scope.parent.generateDeclaredUidIdentifier(className);
  } else varId = path.scope.parent.generateDeclaredUidIdentifier("decorated_class");

  const newClassExpr = t$5.classExpression(className && t$5.identifier(className), path.node.superClass, path.node.body),
    [newPath] = path.replaceWith(t$5.sequenceExpression([newClassExpr, varId]));
  return [t$5.cloneNode(varId), newPath.get("expressions.0")];
  //}
}
function generateClassProperty(key, value, isStatic) {
  return key.type === "PrivateName"
    ? t$5.classPrivateProperty(key, value, void 0, isStatic)
    : t$5.classProperty(key, value, void 0, void 0, isStatic);
}
function addProxyAccessorsFor(className, element, originalKey, targetKey, version, isComputed = false) {
  const { static: isStatic } = element.node,
    thisArg = version === "2023-05" && isStatic ? className : t$5.thisExpression(),
    getterBody = t$5.blockStatement([
      t$5.returnStatement(t$5.memberExpression(t$5.cloneNode(thisArg), t$5.cloneNode(targetKey)))
    ]);
  const setterBody = t$5.blockStatement([
    t$5.expressionStatement(t$5.assignmentExpression("=",
      t$5.memberExpression(t$5.cloneNode(thisArg), t$5.cloneNode(targetKey)), t$5.identifier("v")
    ))
  ]);
  let getter, setter;
  if (originalKey.type === "PrivateName") {
    getter = t$5.classPrivateMethod("get", t$5.cloneNode(originalKey), [], getterBody, isStatic);
    setter = t$5.classPrivateMethod("set", t$5.cloneNode(originalKey), [t$5.identifier("v")], setterBody, isStatic);
  } else {
    getter = t$5.classMethod("get", t$5.cloneNode(originalKey), [], getterBody, isComputed, isStatic);
    setter = t$5.classMethod("set", t$5.cloneNode(originalKey), [t$5.identifier("v")], setterBody, isComputed, isStatic);
  }
  element.insertAfter(setter);
  element.insertAfter(getter);
}
function extractProxyAccessorsFor(targetKey, version) {
  return version !== "2023-05" && version !== "2023-01"
    ? [template$1.expression.ast`
        function () {
          return this.${t$5.cloneNode(targetKey)};
        }
      `, template$1.expression.ast`
        function (value) {
          this.${t$5.cloneNode(targetKey)} = value;
        }
      `]
    : [template$1.expression.ast`
      o => o.${t$5.cloneNode(targetKey)}
    `, template$1.expression.ast`
      (o, v) => o.${t$5.cloneNode(targetKey)} = v
    `];
}
const FIELD = 0,
  ACCESSOR = 1,
  METHOD = 2,
  GETTER = 3,
  SETTER = 4,
  STATIC_OLD_VERSION = 5,
  STATIC = 8,
  DECORATORS_HAVE_THIS = 16;
function getElementKind(element) {
  switch (element.node.type) {
    case "ClassProperty":
    case "ClassPrivateProperty":
      return FIELD;
    case "ClassAccessorProperty":
      return ACCESSOR;
    case "ClassMethod":
    case "ClassPrivateMethod":
      return element.node.kind === "get" ? GETTER : element.node.kind === "set" ? SETTER : METHOD;
  }
}
function isDecoratorInfo(info) {
  return "decorators" in info;
}
function filteredOrderedDecoratorInfo(info) {
  const filtered = info.filter(isDecoratorInfo);
  return [
    ...filtered.filter(el => el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER),
    ...filtered.filter(el => !el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER),
    ...filtered.filter(el => el.isStatic && el.kind === FIELD),
    ...filtered.filter(el => !el.isStatic && el.kind === FIELD)
  ];
}
function generateDecorationList(decorators, decoratorsThis, version) {
  const decsCount = decorators.length,
    hasOneThis = decoratorsThis.some(Boolean),
    decs = [];
  for (let i = 0; i < decsCount; i++) {
    version === "2023-05" && hasOneThis &&
      decs.push(decoratorsThis[i] || t$5.unaryExpression("void", t$5.numericLiteral(0)));

    decs.push(decorators[i]);
  }
  return { hasThis: hasOneThis, decs };
}
function generateDecorationExprs(info, version) {
  return t$5.arrayExpression(filteredOrderedDecoratorInfo(info).map(el => {
    const { decs, hasThis } = generateDecorationList(el.decorators, el.decoratorsThis, version);
    let flag = el.kind;
    if (el.isStatic) flag += version === "2023-05" ? STATIC : STATIC_OLD_VERSION;

    if (hasThis) flag += DECORATORS_HAVE_THIS;
    return t$5.arrayExpression([
      decs.length === 1 ? decs[0] : t$5.arrayExpression(decs),
      t$5.numericLiteral(flag), el.name,
      ...(el.privateMethods || [])
    ]);
  }));
}
function extractElementLocalAssignments(decorationInfo) {
  const localIds = [];
  for (const el of filteredOrderedDecoratorInfo(decorationInfo)) {
    const { locals } = el;
    Array.isArray(locals) ? localIds.push(...locals) : locals === void 0 || localIds.push(locals);
  }
  return localIds;
}
function addCallAccessorsFor(element, key, getId, setId) {
  element.insertAfter(t$5.classPrivateMethod(
    "get", t$5.cloneNode(key), [],
    t$5.blockStatement([t$5.returnStatement(t$5.callExpression(t$5.cloneNode(getId), [t$5.thisExpression()]))])
  ));
  element.insertAfter(t$5.classPrivateMethod(
    "set", t$5.cloneNode(key), [t$5.identifier("v")],
    t$5.blockStatement([
      t$5.expressionStatement(t$5.callExpression(t$5.cloneNode(setId), [t$5.thisExpression(), t$5.identifier("v")]))
    ])
  ));
}
function isNotTsParameter(node) {
  return node.type !== "TSParameterProperty";
}
function movePrivateAccessor(element, key, methodLocalVar, isStatic) {
  let params, block;
  if (element.node.kind === "set") {
    params = [t$5.identifier("v")];
    block = [t$5.expressionStatement(t$5.callExpression(methodLocalVar, [t$5.thisExpression(), t$5.identifier("v")]))];
  } else {
    params = [];
    block = [t$5.returnStatement(t$5.callExpression(methodLocalVar, [t$5.thisExpression()]))];
  }
  element.replaceWith(
    t$5.classPrivateMethod(element.node.kind, t$5.cloneNode(key), params, t$5.blockStatement(block), isStatic)
  );
}
function isClassDecoratableElementPath(path) {
  const { type } = path;
  return type !== "TSDeclareMethod" && type !== "TSIndexSignature" && type !== "StaticBlock";
}
function staticBlockToIIFE(block) {
  return t$5.callExpression(t$5.arrowFunctionExpression([], t$5.blockStatement(block.body)), []);
}
function maybeSequenceExpression(exprs) {
  return exprs.length === 0
    ? t$5.unaryExpression("void", t$5.numericLiteral(0))
    : exprs.length === 1
    ? exprs[0]
    : t$5.sequenceExpression(exprs);
}
function transformClass$1(path, state, constantSuper, version) {
  const body = path.get("body.body"),
    classDecorators = path.node.decorators;
  let hasElementDecorators = false;
  const generateClassPrivateUid = createLazyPrivateUidGeneratorForClass(path);
  for (const element of body)
    if (isClassDecoratableElementPath(element))
      if (element.node.decorators && element.node.decorators.length > 0) hasElementDecorators = true;
      else if (element.node.type === "ClassAccessorProperty") {
        const { key, value, static: isStatic, computed } = element.node,
          newId = generateClassPrivateUid(),
          newField = generateClassProperty(newId, value ? t$5.cloneNode(value) : void 0, isStatic),
          [newPath] = element.replaceWith(newField);
        addProxyAccessorsFor(path.node.id, newPath, key, newId, version, computed);
      }

  if (!classDecorators && !hasElementDecorators) return;
  const elementDecoratorInfo = [];
  let firstFieldPath,
    constructorPath,
    requiresProtoInit = false,
    requiresStaticInit = false;
  const decoratedPrivateMethods = new Set();
  let protoInitLocal, staticInitLocal, classInitLocal, classIdLocal;
  const assignments = [],
    scopeParent = path.scope.parent;
  const memoiseExpression = (expression, hint) => {
    const localEvaluatedId = scopeParent.generateDeclaredUidIdentifier(hint);
    assignments.push(t$5.assignmentExpression("=", localEvaluatedId, expression));
    return t$5.cloneNode(localEvaluatedId);
  };
  const decoratorsThis = new Map();
  const maybeExtractDecorator = decorator => {
    const { expression } = decorator;
    if (version === "2023-05" && t$5.isMemberExpression(expression)) {
      let object;
      if (t$5.isSuper(expression.object) || t$5.isThisExpression(expression.object))
        object = memoiseExpression(t$5.thisExpression(), "obj");
      else if (!scopeParent.isStatic(expression.object)) {
        object = memoiseExpression(expression.object, "obj");
        expression.object = object;
      } else object = expression.object;

      decoratorsThis.set(decorator, t$5.cloneNode(object));
    }
    scopeParent.isStatic(expression) || (decorator.expression = memoiseExpression(expression, "dec"));
  };
  if (classDecorators) {
    classInitLocal = scopeParent.generateDeclaredUidIdentifier("initClass");
    const [classId, classPath] = replaceClassWithVar(path);
    classIdLocal = classId;
    (path = classPath).node.decorators = null;
    for (const classDecorator of classDecorators) maybeExtractDecorator(classDecorator);
  } else {
    path.node.id || (path.node.id = path.scope.generateUidIdentifier("Class"));

    classIdLocal = t$5.cloneNode(path.node.id);
  }
  let lastInstancePrivateName,
    needsInstancePrivateBrandCheck = false;
  if (hasElementDecorators)
    for (const element of body) {
      if (!isClassDecoratableElementPath(element)) continue;

      const { node } = element,
        decorators = element.get("decorators"),
        hasDecorators = Array.isArray(decorators) && decorators.length > 0;
      if (hasDecorators) for (const decoratorPath of decorators) maybeExtractDecorator(decoratorPath.node);

      const isComputed = "computed" in element.node && element.node.computed === true;
      if (isComputed && !scopeParent.isStatic(node.key)) node.key = memoiseExpression(node.key, "computedKey");

      const kind = getElementKind(element),
        { key } = node,
        isPrivate = key.type === "PrivateName",
        isStatic = !!element.node.static;
      let name = "computedKey";
      isPrivate ? (name = key.id.name) : isComputed || key.type !== "Identifier" || (name = key.name);

      if (isPrivate && !isStatic) {
        if (hasDecorators) needsInstancePrivateBrandCheck = true;

        if (t$5.isClassPrivateProperty(node) || !lastInstancePrivateName) lastInstancePrivateName = key;
      }
      if (element.isClassMethod({ kind: "constructor" })) constructorPath = element;

      if (hasDecorators) {
        let locals, privateMethods;
        if (kind === ACCESSOR) {
          const { value } = element.node,
            params = [t$5.thisExpression()];
          value && params.push(t$5.cloneNode(value));

          const newId = generateClassPrivateUid(),
            newFieldInitId = element.scope.parent.generateDeclaredUidIdentifier("init_" + name),
            newValue = t$5.callExpression(t$5.cloneNode(newFieldInitId), params),
            newField = generateClassProperty(newId, newValue, isStatic),
            [newPath] = element.replaceWith(newField);
          if (isPrivate) {
            privateMethods = extractProxyAccessorsFor(newId, version);
            const getId = newPath.scope.parent.generateDeclaredUidIdentifier("get_" + name),
              setId = newPath.scope.parent.generateDeclaredUidIdentifier("set_" + name);
            addCallAccessorsFor(newPath, key, getId, setId);
            locals = [newFieldInitId, getId, setId];
          } else {
            addProxyAccessorsFor(path.node.id, newPath, key, newId, version, isComputed);
            locals = newFieldInitId;
          }
        } else if (kind === FIELD) {
          const initId = element.scope.parent.generateDeclaredUidIdentifier("init_" + name),
            valuePath = element.get("value");
          valuePath.replaceWith(
            t$5.callExpression(t$5.cloneNode(initId), [t$5.thisExpression(), valuePath.node].filter(v => v))
          );
          locals = initId;
          if (isPrivate) privateMethods = extractProxyAccessorsFor(key, version);
        } else if (isPrivate) {
          locals = element.scope.parent.generateDeclaredUidIdentifier("call_" + name);
          new ReplaceSupers({
            constantSuper,
            methodPath: element,
            objectRef: classIdLocal,
            superRef: path.node.superClass,
            file: state.file,
            refToPreserve: classIdLocal
          }).replace();
          const { params, body, async: isAsync } = element.node;
          privateMethods = [t$5.functionExpression(void 0, params.filter(isNotTsParameter), body, isAsync)];
          if (kind === GETTER || kind === SETTER)
            movePrivateAccessor(element, t$5.cloneNode(key), t$5.cloneNode(locals), isStatic);
          else {
            const node = element.node;
            path.node.body.body.unshift(t$5.classPrivateProperty(key, t$5.cloneNode(locals), [], node.static));
            decoratedPrivateMethods.add(key.id.name);
            element.remove();
          }
        }
        let nameExpr = isComputed
          ? t$5.cloneNode(key)
          : key.type === "PrivateName"
          ? t$5.stringLiteral(key.id.name)
          : key.type === "Identifier"
          ? t$5.stringLiteral(key.name)
          : t$5.cloneNode(key);

        elementDecoratorInfo.push({
          kind,
          decorators: decorators.map(d => d.node.expression),
          decoratorsThis: decorators.map(d => decoratorsThis.get(d.node)),
          name: nameExpr,
          isStatic,
          privateMethods,
          locals
        });
        if (kind !== FIELD) isStatic ? (requiresStaticInit = true) : (requiresProtoInit = true);

        if (element.node) element.node.decorators = null;

        firstFieldPath || isStatic || (kind !== FIELD && kind !== ACCESSOR) || (firstFieldPath = element);
      }
    }

  const elementDecorations = generateDecorationExprs(elementDecoratorInfo, version);
  let classDecorationsFlag = 0,
    classDecorations = [];
  if (classDecorators) {
    const { hasThis, decs } = generateDecorationList(
      classDecorators.map(el => el.expression), classDecorators.map(dec => decoratorsThis.get(dec)), version
    );
    classDecorationsFlag = hasThis ? 1 : 0;
    classDecorations = decs;
  }
  const elementLocals = extractElementLocalAssignments(elementDecoratorInfo);
  if (requiresProtoInit) {
    protoInitLocal = scopeParent.generateDeclaredUidIdentifier("initProto");
    elementLocals.push(protoInitLocal);
    const protoInitCall = t$5.callExpression(t$5.cloneNode(protoInitLocal), [t$5.thisExpression()]);
    if (firstFieldPath) {
      const value = firstFieldPath.get("value"),
        body = [protoInitCall];
      value.node && body.push(value.node);

      value.replaceWith(t$5.sequenceExpression(body));
    } else if (constructorPath)
      path.node.superClass
        ? path.traverse({
            CallExpression: {
              exit(path) {
                if (!path.get("callee").isSuper()) return;
                path.replaceWith(t$5.callExpression(t$5.cloneNode(protoInitLocal), [path.node]));
                path.skip();
              }
            }
          })
        : constructorPath.node.body.body.unshift(t$5.expressionStatement(protoInitCall));
    else {
      const body = [t$5.expressionStatement(protoInitCall)];
      path.node.superClass &&
        body.unshift(
          t$5.expressionStatement(t$5.callExpression(t$5.super(), [t$5.spreadElement(t$5.identifier("args"))]))
        );

      path.node.body.body.unshift(t$5.classMethod(
        "constructor", t$5.identifier("constructor"),
        [t$5.restElement(t$5.identifier("args"))], t$5.blockStatement(body)
      ));
    }
  }
  if (requiresStaticInit) {
    staticInitLocal = scopeParent.generateDeclaredUidIdentifier("initStatic");
    elementLocals.push(staticInitLocal);
  }
  decoratedPrivateMethods.size > 0 &&
    path.traverse({
      PrivateName(path) {
        if (!decoratedPrivateMethods.has(path.node.id.name)) return;
        const parentPath = path.parentPath,
          parentParentPath = parentPath.parentPath;
        if (
          (parentParentPath.node.type === "AssignmentExpression" && parentParentPath.node.left === parentPath.node) ||
          parentParentPath.node.type === "UpdateExpression" ||
          parentParentPath.node.type === "RestElement" ||
          parentParentPath.node.type === "ArrayPattern" ||
          (parentParentPath.node.type === "ObjectProperty" &&
            parentParentPath.node.value === parentPath.node &&
            parentParentPath.parentPath.type === "ObjectPattern") ||
          (parentParentPath.node.type === "ForOfStatement" && parentParentPath.node.left === parentPath.node)
        )
          throw path.buildCodeFrameError(
            `Decorated private methods are not updatable, but "#${path.node.id.name}" is updated via this expression.`
          );
      }
    });

  const classLocals = [];
  let classInitInjected = false;
  const classInitCall = classInitLocal && t$5.callExpression(t$5.cloneNode(classInitLocal), []),
    originalClass = path.node;
  if (classDecorators) {
    classLocals.push(classIdLocal, classInitLocal);
    const statics = [];
    let staticBlocks = [];
    path.get("body.body").forEach(element => {
      if (element.isStaticBlock()) {
        staticBlocks.push(element.node);
        element.remove();
        return;
      }
      const isProperty = element.isClassProperty() || element.isClassPrivateProperty();
      if ((isProperty || element.isClassPrivateMethod()) && element.node.static) {
        if (isProperty && staticBlocks.length > 0) {
          const allValues = staticBlocks.map(staticBlockToIIFE);
          element.node.value && allValues.push(element.node.value);
          element.node.value = maybeSequenceExpression(allValues);
          staticBlocks = [];
        }
        element.node.static = false;
        statics.push(element.node);
        element.remove();
      }
    });
    if (statics.length > 0 || staticBlocks.length > 0) {
      const staticsClass = template$1.expression.ast`
        class extends ${state.addHelper("identity")} {}
      `;
      staticsClass.body.body = [
        t$5.staticBlock([t$5.toStatement(originalClass, true) || t$5.expressionStatement(originalClass)]),
        ...statics
      ];
      const constructorBody = [],
        newExpr = t$5.newExpression(staticsClass, []);
      staticBlocks.length > 0 && constructorBody.push(...staticBlocks.map(staticBlockToIIFE));

      if (classInitCall) {
        classInitInjected = true;
        constructorBody.push(classInitCall);
      }
      if (constructorBody.length > 0) {
        constructorBody.unshift(t$5.callExpression(t$5.super(), [t$5.cloneNode(classIdLocal)]));
        staticsClass.body.body.push(t$5.classMethod(
          "constructor", t$5.identifier("constructor"), [],
          t$5.blockStatement([t$5.expressionStatement(t$5.sequenceExpression(constructorBody))])
        ));
      } else newExpr.arguments.push(t$5.cloneNode(classIdLocal));

      path.replaceWith(newExpr);
    }
  }
  classInitInjected || !classInitCall ||
    path.node.body.body.push(t$5.staticBlock([t$5.expressionStatement(classInitCall)]));

  originalClass.body.body.unshift(t$5.staticBlock([
    t$5.expressionStatement(createLocalsAssignment(
      elementLocals, classLocals, elementDecorations,
      t$5.arrayExpression(classDecorations), t$5.numericLiteral(classDecorationsFlag),
      needsInstancePrivateBrandCheck ? lastInstancePrivateName : null, state, version
    )),
    requiresStaticInit &&
      t$5.expressionStatement(t$5.callExpression(t$5.cloneNode(staticInitLocal), [t$5.thisExpression()]))
  ].filter(Boolean)));
  path.insertBefore(assignments.map(expr => t$5.expressionStatement(expr)));
  path.scope.crawl();
  return path;
}
function createLocalsAssignment(
  elementLocals,
  classLocals,
  elementDecorations,
  classDecorations,
  classDecorationsFlag,
  maybePrivateBranName,
  state,
  version
) {
  let lhs, rhs;
  const args = [t$5.thisExpression(), elementDecorations, classDecorations];

  if (version === "2021-12" || (version === "2022-03" && !state.availableHelper("applyDecs2203R"))) {
    const lhs = t$5.arrayPattern([...elementLocals, ...classLocals]),
      rhs = t$5.callExpression(state.addHelper(version === "2021-12" ? "applyDecs" : "applyDecs2203"), args);
    return t$5.assignmentExpression("=", lhs, rhs);
  }

  if (version === "2023-05") {
    if (maybePrivateBranName || classDecorationsFlag.value !== 0) args.push(classDecorationsFlag);

    maybePrivateBranName &&
      args.push(template$1.expression.ast`
          _ => ${t$5.cloneNode(maybePrivateBranName)} in _
        `);

    rhs = t$5.callExpression(state.addHelper("applyDecs2305"), args);
  } else if (version === "2023-01") {
    maybePrivateBranName &&
      args.push(template$1.expression.ast`
          _ => ${t$5.cloneNode(maybePrivateBranName)} in _
        `);

    rhs = t$5.callExpression(state.addHelper("applyDecs2301"), args);
  } else rhs = t$5.callExpression(state.addHelper("applyDecs2203R"), args);

  if (elementLocals.length > 0)
    if (classLocals.length > 0)
      lhs = t$5.objectPattern([
        t$5.objectProperty(t$5.identifier("e"), t$5.arrayPattern(elementLocals)),
        t$5.objectProperty(t$5.identifier("c"), t$5.arrayPattern(classLocals))
      ]);
    else {
      lhs = t$5.arrayPattern(elementLocals);
      rhs = t$5.memberExpression(rhs, t$5.identifier("e"), false, false);
    }
  else {
    lhs = t$5.arrayPattern(classLocals);
    rhs = t$5.memberExpression(rhs, t$5.identifier("c"), false, false);
  }
  return t$5.assignmentExpression("=", lhs, rhs);
}
function transformer2023_05({ assertVersion, assumption }, { loose }, version) {
  var _assumption;

  assertVersion(
    version === "2023-05" || version === "2023-01" ? "^7.21.0" : version === "2021-12" ? "^7.16.0" : "^7.19.0"
  );

  const VISITED = new WeakSet(),
    constantSuper = (_assumption = assumption("constantSuper")) != null ? _assumption : loose;
  return {
    name: "proposal-decorators",
    inherits: syntaxDecorators,
    visitor: {
      "ExportNamedDeclaration|ExportDefaultDeclaration"(path) {
        var _declaration$decorato;
        const { declaration } = path.node;
        (declaration == null ? void 0 : declaration.type) === "ClassDeclaration" &&
          ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 &&
          splitExportDeclaration(path);
      },
      Class(path, state) {
        if (VISITED.has(path)) return;
        const newPath = transformClass$1(path, state, constantSuper, version);
        newPath && VISITED.add(newPath);
      }
    }
  };
}

var proposalDecorators = declare((api, options) => {
  api.assertVersion(7);

  var { legacy } = options;

  const { version } = options;
  if (legacy || version === "legacy")
    return { name: "proposal-decorators", inherits: syntaxDecorators, visitor: visitor$2 };

  if (version === "2021-12" || version === "2022-03" || version === "2023-01" || version === "2023-05")
    return transformer2023_05(api, options, version);

  api.assertVersion("^7.0.2");
  return createClassFeaturePlugin({
    name: "proposal-decorators",
    api,
    feature: FEATURES$1.decorators,
    inherits: syntaxDecorators
  });
});

function isPureVoid(node) {
  return t$5.isUnaryExpression(node) && node.operator === "void" && t$5.isPureish(node.argument);
}
function unshiftForXStatementBody(statementPath, newStatements) {
  statementPath.ensureBlock();
  const { scope, node } = statementPath,
    bodyScopeBindings = statementPath.get("body").scope.bindings;
  Object.keys(bodyScopeBindings).some(name => scope.hasBinding(name))
    ? (node.body = t$5.blockStatement([...newStatements, node.body]))
    : node.body.body.unshift(...newStatements);
}
function hasArrayRest(pattern) {
  return pattern.elements.some(elem => t$5.isRestElement(elem));
}
function hasObjectRest(pattern) {
  return pattern.properties.some(prop => t$5.isRestElement(prop));
}
const STOP_TRAVERSAL = {};
const arrayUnpackVisitor = (node, ancestors, state) => {
  if (
    ancestors.length &&
    t$5.isIdentifier(node) && t$5.isReferenced(node, ancestors[ancestors.length - 1].node) && state.bindings[node.name]
  ) {
    state.deopt = true;
    throw STOP_TRAVERSAL;
  }
};
class DestructuringTransformer {
  constructor(opts) {
    this.blockHoist = void 0;
    this.operator = void 0;
    this.arrayRefSet = void 0;
    this.nodes = void 0;
    this.scope = void 0;
    this.kind = void 0;
    this.iterableIsArray = void 0;
    this.arrayLikeIsIterable = void 0;
    this.objectRestNoSymbols = void 0;
    this.useBuiltIns = void 0;
    this.addHelper = void 0;
    this.blockHoist = opts.blockHoist;
    this.operator = opts.operator;
    this.arrayRefSet = new Set();
    this.nodes = opts.nodes || [];
    this.scope = opts.scope;
    this.kind = opts.kind;
    this.iterableIsArray = opts.iterableIsArray;
    this.arrayLikeIsIterable = opts.arrayLikeIsIterable;
    this.objectRestNoSymbols = opts.objectRestNoSymbols;
    this.useBuiltIns = opts.useBuiltIns;
    this.addHelper = opts.addHelper;
  }
  getExtendsHelper() {
    return this.useBuiltIns
      ? t$5.memberExpression(t$5.identifier("Object"), t$5.identifier("assign"))
      : this.addHelper("extends");
  }
  buildVariableAssignment(id, init) {
    let node,
      op = this.operator;
    if (t$5.isMemberExpression(id)) op = "=";
    if (op)
      node = t$5.expressionStatement(
        t$5.assignmentExpression(op, id, t$5.cloneNode(init) || this.scope.buildUndefinedNode())
      );
    else {
      let nodeInit =
        (this.kind !== "const" && this.kind !== "using") || init !== null
          ? t$5.cloneNode(init)
          : this.scope.buildUndefinedNode();

      node = t$5.variableDeclaration(this.kind, [t$5.variableDeclarator(id, nodeInit)]);
    }
    node._blockHoist = this.blockHoist;
    return node;
  }
  buildVariableDeclaration(id, init) {
    const declar = t$5.variableDeclaration("var", [t$5.variableDeclarator(t$5.cloneNode(id), t$5.cloneNode(init))]);
    declar._blockHoist = this.blockHoist;
    return declar;
  }
  push(id, _init) {
    const init = t$5.cloneNode(_init);
    t$5.isObjectPattern(id)
      ? this.pushObjectPattern(id, init)
      : t$5.isArrayPattern(id)
      ? this.pushArrayPattern(id, init)
      : t$5.isAssignmentPattern(id)
      ? this.pushAssignmentPattern(id, init)
      : this.nodes.push(this.buildVariableAssignment(id, init));
  }
  toArray(node, count) {
    return this.iterableIsArray || (t$5.isIdentifier(node) && this.arrayRefSet.has(node.name))
      ? node
      : this.scope.toArray(node, count, this.arrayLikeIsIterable);
  }
  pushAssignmentPattern({ left, right }, valueRef) {
    if (isPureVoid(valueRef)) {
      this.push(left, right);
      return;
    }
    const tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);
    this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));
    const tempConditional = t$5.conditionalExpression(
      t$5.binaryExpression("===", t$5.cloneNode(tempId), this.scope.buildUndefinedNode()),
      right, t$5.cloneNode(tempId)
    );
    if (t$5.isPattern(left)) {
      let patternId, node;
      if (this.kind === "const" || this.kind === "let" || this.kind === "using") {
        patternId = this.scope.generateUidIdentifier(tempId.name);
        node = this.buildVariableDeclaration(patternId, tempConditional);
      } else {
        patternId = tempId;
        node = t$5.expressionStatement(t$5.assignmentExpression("=", t$5.cloneNode(tempId), tempConditional));
      }
      this.nodes.push(node);
      this.push(left, patternId);
    } else this.nodes.push(this.buildVariableAssignment(left, tempConditional));
  }
  pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {
    const value = buildObjectExcludingKeys(
      pattern.properties.slice(0, spreadPropIndex), objRef, this.scope,
      name => this.addHelper(name), this.objectRestNoSymbols, this.useBuiltIns
    );
    this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));
  }
  pushObjectProperty(prop, propRef) {
    if (t$5.isLiteral(prop.key)) prop.computed = true;
    const pattern = prop.value,
      objRef = t$5.memberExpression(t$5.cloneNode(propRef), prop.key, prop.computed);
    t$5.isPattern(pattern)
      ? this.push(pattern, objRef)
      : this.nodes.push(this.buildVariableAssignment(pattern, objRef));
  }
  pushObjectPattern(pattern, objRef) {
    if (!pattern.properties.length) {
      this.nodes.push(t$5.expressionStatement(
        t$5.callExpression(this.addHelper("objectDestructuringEmpty"), isPureVoid(objRef) ? [] : [objRef])
      ));
      return;
    }
    if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {
      const temp = this.scope.generateUidIdentifierBasedOnNode(objRef);
      this.nodes.push(this.buildVariableDeclaration(temp, objRef));
      objRef = temp;
    }
    if (hasObjectRest(pattern)) {
      let copiedPattern;
      for (let i = 0; i < pattern.properties.length; i++) {
        const prop = pattern.properties[i];
        if (t$5.isRestElement(prop)) break;

        const key = prop.key;
        if (prop.computed && !this.scope.isPure(key)) {
          const name = this.scope.generateUidIdentifierBasedOnNode(key);
          this.nodes.push(this.buildVariableDeclaration(name, key));
          copiedPattern ||
            (copiedPattern = pattern = Object.assign({}, pattern, { properties: pattern.properties.slice() }));

          copiedPattern.properties[i] = Object.assign({}, prop, { key: name });
        }
      }
    }
    for (let i = 0; i < pattern.properties.length; i++) {
      const prop = pattern.properties[i];
      t$5.isRestElement(prop) ? this.pushObjectRest(pattern, objRef, prop, i) : this.pushObjectProperty(prop, objRef);
    }
  }
  canUnpackArrayPattern(pattern, arr) {
    if (!t$5.isArrayExpression(arr)) return false;
    if (pattern.elements.length > arr.elements.length) return;
    if (pattern.elements.length < arr.elements.length && !hasArrayRest(pattern)) return false;

    for (const elem of pattern.elements)
      if (!elem || t$5.isMemberExpression(elem)) return false;

    for (const elem of arr.elements)
      if (t$5.isSpreadElement(elem) || t$5.isCallExpression(elem) || t$5.isMemberExpression(elem)) return false;

    const state = { deopt: false, bindings: t$5.getBindingIdentifiers(pattern) };
    try {
      t$5.traverse(arr, arrayUnpackVisitor, state);
    } catch (e) {
      if (e !== STOP_TRAVERSAL) throw e;
    }
    return !state.deopt;
  }
  pushUnpackedArrayPattern(pattern, arr) {
    const holeToUndefined = el => (el != null ? el : this.scope.buildUndefinedNode());
    for (let i = 0; i < pattern.elements.length; i++) {
      const elem = pattern.elements[i];
      t$5.isRestElement(elem)
        ? this.push(elem.argument, t$5.arrayExpression(arr.elements.slice(i).map(holeToUndefined)))
        : this.push(elem, holeToUndefined(arr.elements[i]));
    }
  }
  pushArrayPattern(pattern, arrayRef) {
    if (arrayRef === null) {
      this.nodes.push(t$5.expressionStatement(t$5.callExpression(this.addHelper("objectDestructuringEmpty"), [])));
      return;
    }
    if (!pattern.elements) return;
    if (this.canUnpackArrayPattern(pattern, arrayRef)) {
      this.pushUnpackedArrayPattern(pattern, arrayRef);
      return;
    }
    const count = !hasArrayRest(pattern) && pattern.elements.length,
      toArray = this.toArray(arrayRef, count);
    if (t$5.isIdentifier(toArray)) arrayRef = toArray;
    else {
      arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);
      this.arrayRefSet.add(arrayRef.name);
      this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));
    }
    for (let i = 0; i < pattern.elements.length; i++) {
      const elem = pattern.elements[i];
      if (!elem) continue;
      let elemRef;
      if (t$5.isRestElement(elem)) {
        elemRef = this.toArray(arrayRef);
        elemRef = t$5.callExpression(t$5.memberExpression(elemRef, t$5.identifier("slice")), [t$5.numericLiteral(i)]);
        this.push(elem.argument, elemRef);
      } else {
        elemRef = t$5.memberExpression(arrayRef, t$5.numericLiteral(i), true);
        this.push(elem, elemRef);
      }
    }
  }
  init(pattern, ref) {
    if (!t$5.isArrayExpression(ref) && !t$5.isMemberExpression(ref)) {
      const memo = this.scope.maybeGenerateMemoised(ref, true);
      if (memo) {
        this.nodes.push(this.buildVariableDeclaration(memo, t$5.cloneNode(ref)));
        ref = memo;
      }
    }
    this.push(pattern, ref);
    return this.nodes;
  }
}
function buildObjectExcludingKeys(excludedKeys, objRef, scope, addHelper, objectRestNoSymbols, useBuiltIns) {
  const keys = [];
  let value,
    allLiteral = true,
    hasTemplateLiteral = false;
  for (let i = 0; i < excludedKeys.length; i++) {
    const prop = excludedKeys[i],
      key = prop.key;
    if (t$5.isIdentifier(key) && !prop.computed) keys.push(t$5.stringLiteral(key.name));
    else if (t$5.isTemplateLiteral(key)) {
      keys.push(t$5.cloneNode(key));
      hasTemplateLiteral = true;
    } else if (t$5.isLiteral(key)) keys.push(t$5.stringLiteral(String(key.value)));
    else if (t$5.isPrivateName(key));
    else {
      keys.push(t$5.cloneNode(key));
      allLiteral = false;
    }
  }
  if (keys.length === 0) {
    const extendsHelper = useBuiltIns
      ? t$5.memberExpression(t$5.identifier("Object"), t$5.identifier("assign"))
      : addHelper("extends");
    value = t$5.callExpression(extendsHelper, [
      t$5.objectExpression([]),
      t$5.sequenceExpression([
        t$5.callExpression(addHelper("objectDestructuringEmpty"), [t$5.cloneNode(objRef)]),
        t$5.cloneNode(objRef)
      ])
    ]);
  } else {
    let keyExpression = t$5.arrayExpression(keys);
    if (!allLiteral)
      keyExpression = t$5.callExpression(t$5.memberExpression(keyExpression, t$5.identifier("map")), [
        addHelper("toPropertyKey")
      ]);
    else if (!hasTemplateLiteral && !t$5.isProgram(scope.block)) {
      const programScope = scope.getProgramParent(),
        id = programScope.generateUidIdentifier("excluded");
      programScope.push({ id, init: keyExpression, kind: "const" });
      keyExpression = t$5.cloneNode(id);
    }
    value = t$5.callExpression(addHelper(`objectWithoutProperties${objectRestNoSymbols ? "Loose" : ""}`), [
      t$5.cloneNode(objRef), keyExpression
    ]);
  }
  return value;
}
function convertVariableDeclaration(
  path,
  addHelper,
  arrayLikeIsIterable,
  iterableIsArray,
  objectRestNoSymbols,
  useBuiltIns
) {
  const { node, scope } = path,
    nodeKind = node.kind,
    nodeLoc = node.loc,
    nodes = [];
  for (let i = 0; i < node.declarations.length; i++) {
    const declar = node.declarations[i],
      patternId = declar.init,
      pattern = declar.id;
    const destructuring = new DestructuringTransformer({
      blockHoist: node._blockHoist,
      nodes,
      scope,
      kind: node.kind,
      iterableIsArray,
      arrayLikeIsIterable,
      useBuiltIns,
      objectRestNoSymbols,
      addHelper
    });
    if (t$5.isPattern(pattern)) {
      destructuring.init(pattern, patternId);
      +i == node.declarations.length - 1 || t$5.inherits(nodes[nodes.length - 1], declar);
    } else nodes.push(t$5.inherits(destructuring.buildVariableAssignment(pattern, patternId), declar));
  }
  let tail = null,
    nodesOut = [];
  for (const node of nodes) {
    if (t$5.isVariableDeclaration(node)) {
      if (tail !== null) {
        tail.declarations.push(...node.declarations);
        continue;
      }

      node.kind = nodeKind;
      tail = node;
    } else tail = null;

    node.loc || (node.loc = nodeLoc);
    nodesOut.push(node);
  }
  if (
    nodesOut.length === 2 &&
    t$5.isVariableDeclaration(nodesOut[0]) &&
    t$5.isExpressionStatement(nodesOut[1]) &&
    t$5.isCallExpression(nodesOut[1].expression) &&
    nodesOut[0].declarations.length === 1
  ) {
    const expr = nodesOut[1].expression;
    expr.arguments = [nodesOut[0].declarations[0].init];
    nodesOut = [expr];
  } else if (t$5.isForStatement(path.parent, { init: node }) && !nodesOut.some(v => t$5.isVariableDeclaration(v)))
    for (let i = 0; i < nodesOut.length; i++) {
      const node = nodesOut[i];
      if (t$5.isExpressionStatement(node)) nodesOut[i] = node.expression;
    }

  nodesOut.length === 1 ? path.replaceWith(nodesOut[0]) : path.replaceWithMultiple(nodesOut);

  scope.crawl();
}
function convertAssignmentExpression(
  path,
  addHelper,
  arrayLikeIsIterable,
  iterableIsArray,
  objectRestNoSymbols,
  useBuiltIns
) {
  const { node, scope, parentPath } = path,
    nodes = [];
  const destructuring = new DestructuringTransformer({
    operator: node.operator,
    scope,
    nodes,
    arrayLikeIsIterable,
    iterableIsArray,
    objectRestNoSymbols,
    useBuiltIns,
    addHelper
  });
  let ref;
  if ((!parentPath.isExpressionStatement() && !parentPath.isSequenceExpression()) || path.isCompletionRecord()) {
    ref = scope.generateUidIdentifierBasedOnNode(node.right, "ref");
    nodes.push(t$5.variableDeclaration("var", [t$5.variableDeclarator(ref, node.right)]));
    t$5.isArrayExpression(node.right) && destructuring.arrayRefSet.add(ref.name);
  }
  destructuring.init(node.left, ref || node.right);
  if (ref)
    if (parentPath.isArrowFunctionExpression()) {
      path.replaceWith(t$5.blockStatement([]));
      nodes.push(t$5.returnStatement(t$5.cloneNode(ref)));
    } else nodes.push(t$5.expressionStatement(t$5.cloneNode(ref)));

  path.replaceWithMultiple(nodes);
  scope.crawl();
}

function variableDeclarationHasPattern(node) {
  for (const declar of node.declarations) if (t$5.isPattern(declar.id)) return true;

  return false;
}
var transformDestructuring = declare((api, options) => {
  var _api$assumption, _options$allowArrayLi, _api$assumption2;
  api.assertVersion(7);
  const { useBuiltIns = false } = options;
  var _ref = (_api$assumption = api.assumption("iterableIsArray")) != null ? _api$assumption : options.loose;
  const iterableIsArray = _ref != null && _ref;
  var _ref2 = (_options$allowArrayLi = options.allowArrayLike) != null
    ? _options$allowArrayLi
    : api.assumption("arrayLikeIsIterable");
  const arrayLikeIsIterable = _ref2 != null && _ref2;
  var _ref3 = (_api$assumption2 = api.assumption("objectRestNoSymbols")) != null ? _api$assumption2 : options.loose;
  const objectRestNoSymbols = _ref3 != null && _ref3;
  return {
    name: "transform-destructuring",
    visitor: {
      ExportNamedDeclaration(path) {
        const declaration = path.get("declaration");
        if (!declaration.isVariableDeclaration() || !variableDeclarationHasPattern(declaration.node)) return;
        const specifiers = [];
        for (const name of Object.keys(path.getOuterBindingIdentifiers()))
          specifiers.push(t$5.exportSpecifier(t$5.identifier(name), t$5.identifier(name)));

        path.replaceWith(declaration.node);
        path.insertAfter(t$5.exportNamedDeclaration(null, specifiers));
        path.scope.crawl();
      },
      ForXStatement(path) {
        const { node, scope } = path,
          left = node.left;
        if (t$5.isPattern(left)) {
          const temp = scope.generateUidIdentifier("ref");
          node.left = t$5.variableDeclaration("var", [t$5.variableDeclarator(temp)]);
          path.ensureBlock();
          const nodes = [];
          path.node.body.body.length === 0 && path.isCompletionRecord() &&
            nodes.unshift(t$5.expressionStatement(scope.buildUndefinedNode()));

          nodes.unshift(t$5.expressionStatement(t$5.assignmentExpression("=", left, t$5.cloneNode(temp))));
          unshiftForXStatementBody(path, nodes);
          scope.crawl();
          return;
        }
        if (!t$5.isVariableDeclaration(left)) return;
        const pattern = left.declarations[0].id;
        if (!t$5.isPattern(pattern)) return;
        const key = scope.generateUidIdentifier("ref");
        node.left = t$5.variableDeclaration(left.kind, [t$5.variableDeclarator(key, null)]);
        const nodes = [];
        new DestructuringTransformer({
          kind: left.kind,
          scope,
          nodes,
          arrayLikeIsIterable,
          iterableIsArray,
          objectRestNoSymbols,
          useBuiltIns,
          addHelper: name => this.addHelper(name)
        }).init(pattern, key);
        unshiftForXStatementBody(path, nodes);
        scope.crawl();
      },
      CatchClause({ node, scope }) {
        const pattern = node.param;
        if (!t$5.isPattern(pattern)) return;
        const ref = scope.generateUidIdentifier("ref");
        node.param = ref;
        const nodes = [];
        new DestructuringTransformer({
          kind: "let",
          scope,
          nodes,
          arrayLikeIsIterable,
          iterableIsArray,
          objectRestNoSymbols,
          useBuiltIns,
          addHelper: name => this.addHelper(name)
        }).init(pattern, ref);
        node.body.body = [...nodes, ...node.body.body];
        scope.crawl();
      },
      AssignmentExpression(path, state) {
        t$5.isPattern(path.node.left) &&
          convertAssignmentExpression(
            path, name => state.addHelper(name), arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns
          );
      },
      VariableDeclaration(path, state) {
        const { node, parent } = path;
        !t$5.isForXStatement(parent) &&
          parent && path.container &&
          variableDeclarationHasPattern(node) &&
          convertVariableDeclaration(
            path, name => state.addHelper(name), arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns
          );
      }
    }
  };
});

const {
  assignmentExpression: assignmentExpression$3,
  binaryExpression,
  conditionalExpression,
  cloneNode: cloneNode$1,
  isObjectProperty: isObjectProperty$2,
  isPrivateName: isPrivateName$1,
  memberExpression: memberExpression$2,
  numericLiteral,
  objectPattern,
  restElement,
  variableDeclarator,
  variableDeclaration,
  unaryExpression
} = t$5;
function buildUndefinedNode() {
  return unaryExpression("void", numericLiteral(0));
}
function transformAssignmentPattern(initializer, tempId) {
  return conditionalExpression(
    binaryExpression("===", cloneNode$1(tempId), buildUndefinedNode()),
    initializer, cloneNode$1(tempId)
  );
}
function initRestExcludingKeys(pattern) {
  if (pattern.type === "ObjectPattern") {
    const { properties } = pattern;
    if (properties[properties.length - 1].type === "RestElement") return [];
  }
  return null;
}
function growRestExcludingKeys(excludingKeys, properties, scope) {
  if (excludingKeys === null) return;
  for (const property of properties) {
    const propertyKey = property.key;
    if (property.computed && !scope.isStatic(propertyKey)) {
      const tempId = scope.generateDeclaredUidIdentifier("m");
      property.key = assignmentExpression$3("=", tempId, propertyKey);
      excludingKeys.push({ key: tempId, computed: true });
    } else propertyKey.type === "PrivateName" || excludingKeys.push(property);
  }
}
function buildVariableDeclarationFromParams(params, scope) {
  const { elements, transformed } = buildAssignmentsFromPatternList(params, scope, false);
  return {
    params: elements,
    variableDeclaration: variableDeclaration("var",
      transformed.map(({ left, right }) => variableDeclarator(left, right))
    )
  };
}
function buildAssignmentsFromPatternList(elements, scope, isAssignment) {
  const newElements = [],
    transformed = [];
  for (let element of elements) {
    if (element === null) {
      newElements.push(null);
      transformed.push(null);
      continue;
    }
    const tempId = scope.generateUidIdentifier("p");
    isAssignment && scope.push({ id: cloneNode$1(tempId) });

    if (element.type === "RestElement") {
      newElements.push(restElement(tempId));
      element = element.argument;
    } else newElements.push(tempId);

    element.type === "AssignmentPattern"
      ? transformed.push({ left: element.left, right: transformAssignmentPattern(element.right, tempId) })
      : transformed.push({ left: element, right: cloneNode$1(tempId) });
  }
  return { elements: newElements, transformed };
}
function* traversePattern(root, visitor) {
  const stack = [];
  stack.push({ node: root, index: 0, depth: 0 });
  for (let item; (item = stack.pop()) !== void 0; ) {
    const { node, index } = item;
    if (node === null) continue;
    yield* visitor(node, index, item.depth);
    const depth = item.depth + 1;
    switch (node.type) {
      case "AssignmentPattern":
        stack.push({ node: node.left, index: 0, depth });
        break;
      case "ObjectProperty":
        stack.push({ node: node.value, index, depth: item.depth });
        break;
      case "RestElement":
        stack.push({ node: node.argument, index: 0, depth });
        break;
      case "ObjectPattern":
        for (let list = node.properties, i = list.length - 1; i >= 0; i--)
          stack.push({ node: list[i], index: i, depth });

        break;
      case "ArrayPattern":
        for (let list = node.elements, i = list.length - 1; i >= 0; i--)
          stack.push({ node: list[i], index: i, depth });

        break;
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        throw new Error(
          "TypeScript features must first be transformed by @babel/plugin-transform-typescript.\n\
If you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before @babel/plugin-proposal-destructuring-private."
        );
    }
  }
}
function hasPrivateKeys(pattern) {
  let result = false;
  traversePattern(pattern, function* (node) {
    if (isObjectProperty$2(node) && isPrivateName$1(node.key)) {
      result = true;
      yield;
    }
  }).next();
  return result;
}
function hasPrivateClassElement(node) {
  return node.body.some(element => isPrivateName$1(element.key));
}
function* privateKeyPathIterator(pattern) {
  const indexPath = [];
  yield* traversePattern(pattern, function* (node, index, depth) {
    indexPath[depth] = index;
    if (isObjectProperty$2(node) && isPrivateName$1(node.key)) yield indexPath.slice(1, depth + 1);
  });
}
function rightWillBeReferencedOnce(left) {
  switch (left.type) {
    case "Identifier":
    case "ArrayPattern":
      return true;
    case "ObjectPattern":
      return left.properties.length === 1;
    default:
      return false;
  }
}
function* transformPrivateKeyDestructuring(
  left,
  right,
  scope,
  isAssignment,
  shouldPreserveCompletion,
  addHelper,
  objectRestNoSymbols,
  useBuiltIns
) {
  const stack = [],
    rootRight = right;
  stack.push({ left, right, restExcludingKeys: initRestExcludingKeys(left) });
  for (let item; (item = stack.pop()) !== void 0; ) {
    const { restExcludingKeys } = item;
    let { left, right } = item;
    const searchPrivateKey = privateKeyPathIterator(left).next();
    if (searchPrivateKey.done)
      if ((restExcludingKeys == null ? void 0 : restExcludingKeys.length) > 0) {
        const { properties } = left;
        if (properties.length === 1) left = properties[0].argument;

        yield {
          left,
          right: buildObjectExcludingKeys(restExcludingKeys, right, scope, addHelper, objectRestNoSymbols, useBuiltIns)
        };
      } else yield { left, right };
    else {
      const indexPath = searchPrivateKey.value;
      for (
        let index, indexPathIndex = 0;
        (indexPathIndex < indexPath.length && (index = indexPath[indexPathIndex]) !== void 0) ||
        left.type === "AssignmentPattern";
        indexPathIndex++
      ) {
        if (
          (shouldPreserveCompletion && right === rootRight) ||
          (!rightWillBeReferencedOnce(left) && !scope.isStatic(right))
        ) {
          const tempId = scope.generateUidIdentifier("m");
          isAssignment && scope.push({ id: cloneNode$1(tempId) });

          yield { left: tempId, right };
          right = cloneNode$1(tempId);
        }
        switch (left.type) {
          case "ObjectPattern": {
            const { properties } = left;
            if (index > 0) {
              const propertiesSlice = properties.slice(0, index);
              yield { left: objectPattern(propertiesSlice), right: cloneNode$1(right) };
            }
            if (index < properties.length - 1) {
              const nextRestExcludingKeys = indexPathIndex === 0 ? restExcludingKeys : initRestExcludingKeys(left);
              growRestExcludingKeys(nextRestExcludingKeys, properties.slice(0, index + 1), scope);
              stack.push({
                left: objectPattern(properties.slice(index + 1)),
                right: cloneNode$1(right),
                restExcludingKeys: nextRestExcludingKeys
              });
            }
            const property = properties[index];
            left = property.value;
            const { key } = property,
              computed = property.computed || (key.type !== "Identifier" && key.type !== "PrivateName");
            right = memberExpression$2(right, key, computed);
            break;
          }
          case "AssignmentPattern":
            right = transformAssignmentPattern(left.right, right);
            left = left.left;
            break;

          case "ArrayPattern": {
            const leftElements = left.elements,
              leftElementsAfterIndex = leftElements.splice(index),
              { elements, transformed } = buildAssignmentsFromPatternList(leftElementsAfterIndex, scope, isAssignment);
            leftElements.push(...elements);
            yield { left, right: cloneNode$1(right) };
            for (let i = transformed.length - 1; i > 0; i--) transformed[i] === null || stack.push(transformed[i]);

            ({ left, right } = transformed[0]);
            break;
          }
        }
      }
      stack.push({ left, right, restExcludingKeys: initRestExcludingKeys(left) });
    }
  }
}

const iifeVisitor = {
  "ReferencedIdentifier|BindingIdentifier"(path, state) {
    const { scope, node } = path,
      { name } = node;
    if (
      name === "eval" ||
      (scope.getBinding(name) === state.scope.parent.getBinding(name) && state.scope.hasOwnBinding(name))
    ) {
      state.needsOuterBinding = true;
      path.stop();
    }
  },
  "TypeAnnotation|TSTypeAnnotation|TypeParameterDeclaration|TSTypeParameterDeclaration": path => path.skip()
};
function collectShadowedParamsNames(param, functionScope, shadowedParams) {
  for (const name of Object.keys(param.getBindingIdentifiers())) {
    var _functionScope$bindin = functionScope.bindings[name];
    const constantViolations = _functionScope$bindin == null ? void 0 : _functionScope$bindin.constantViolations;
    if (constantViolations)
      for (const redeclarator of constantViolations) {
        const node = redeclarator.node;
        switch (node.type) {
          case "VariableDeclarator":
            if (node.init === null) {
              const declaration = redeclarator.parentPath;
              if (!declaration.parentPath.isFor() || declaration.parentPath.get("body") === declaration) {
                redeclarator.remove();
                break;
              }
            }
            shadowedParams.add(name);
            break;

          case "FunctionDeclaration":
            shadowedParams.add(name);
            break;
        }
      }
  }
}
function buildScopeIIFE(shadowedParams, body) {
  const args = [],
    params = [];
  for (const name of shadowedParams) {
    args.push(t$5.identifier(name));
    params.push(t$5.identifier(name));
  }
  return t$5.returnStatement(t$5.callExpression(t$5.arrowFunctionExpression(params, body), args));
}

const buildDefaultParam = template$1.statement(`
  let VARIABLE_NAME =
    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== void 0
      ? arguments[ARGUMENT_KEY]
      : DEFAULT_VALUE;
`);
const buildLooseDefaultParam = template$1.statement(`
  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;
`);
const buildLooseDestructuredDefaultParam = template$1.statement(`
  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME !== UNDEFINED ? PARAMETER_NAME : DEFAULT_VALUE;
`);
const buildSafeArgumentsAccess = template$1.statement(`
  let $0 = arguments.length > $1 ? arguments[$1] : void 0;
`);
function convertFunctionParams(path, ignoreFunctionLength, shouldTransformParam, replaceRestElement) {
  const params = path.get("params");
  if (params.every(param => param.isIdentifier())) return false;
  const { node, scope } = path,
    body = [],
    shadowedParams = new Set();
  for (const param of params) collectShadowedParamsNames(param, scope, shadowedParams);

  const state = { needsOuterBinding: false, scope };
  if (shadowedParams.size === 0)
    for (const param of params) {
      param.isIdentifier() || param.traverse(iifeVisitor, state);
      if (state.needsOuterBinding) break;
    }

  let firstOptionalIndex = null;
  for (let i = 0; i < params.length; i++) {
    const param = params[i];
    if (shouldTransformParam && !shouldTransformParam(i)) continue;

    const transformedRestNodes = [];
    replaceRestElement && replaceRestElement(path, param, transformedRestNodes);

    const paramIsAssignmentPattern = param.isAssignmentPattern();
    if (paramIsAssignmentPattern && (ignoreFunctionLength || t$5.isMethod(node, { kind: "set" }))) {
      const left = param.get("left"),
        right = param.get("right"),
        undefinedNode = scope.buildUndefinedNode();
      if (left.isIdentifier()) {
        body.push(buildLooseDefaultParam({
          ASSIGNMENT_IDENTIFIER: t$5.cloneNode(left.node),
          DEFAULT_VALUE: right.node,
          UNDEFINED: undefinedNode
        }));
        param.replaceWith(left.node);
      } else if (left.isObjectPattern() || left.isArrayPattern()) {
        const paramName = scope.generateUidIdentifier();
        body.push(buildLooseDestructuredDefaultParam({
          ASSIGNMENT_IDENTIFIER: left.node,
          DEFAULT_VALUE: right.node,
          PARAMETER_NAME: t$5.cloneNode(paramName),
          UNDEFINED: undefinedNode
        }));
        param.replaceWith(paramName);
      }
    } else if (paramIsAssignmentPattern) {
      if (firstOptionalIndex === null) firstOptionalIndex = i;
      const left = param.get("left"),
        right = param.get("right");
      const defNode = buildDefaultParam({
        VARIABLE_NAME: left.node,
        DEFAULT_VALUE: right.node,
        ARGUMENT_KEY: t$5.numericLiteral(i)
      });
      body.push(defNode);
    } else if (firstOptionalIndex !== null) {
      const defNode = buildSafeArgumentsAccess([param.node, t$5.numericLiteral(i)]);
      body.push(defNode);
    } else if (param.isObjectPattern() || param.isArrayPattern()) {
      const uid = path.scope.generateUidIdentifier("ref");
      uid.typeAnnotation = param.node.typeAnnotation;
      const defNode = t$5.variableDeclaration("let", [t$5.variableDeclarator(param.node, uid)]);
      body.push(defNode);
      param.replaceWith(t$5.cloneNode(uid));
    }
    if (transformedRestNodes) for (const transformedNode of transformedRestNodes) body.push(transformedNode);
  }
  if (firstOptionalIndex !== null) node.params = node.params.slice(0, firstOptionalIndex);

  path.ensureBlock();
  const { async, generator } = node;
  if (generator || state.needsOuterBinding || shadowedParams.size > 0) {
    body.push(buildScopeIIFE(shadowedParams, path.node.body));
    path.set("body", t$5.blockStatement(body));
    const bodyPath = path.get("body.body"),
      arrowPath = bodyPath[bodyPath.length - 1].get("argument.callee");
    arrowPath.arrowFunctionToExpression();
    arrowPath.node.generator = generator;
    arrowPath.node.async = async;
    node.generator = false;
    node.async = false;
    if (async)
      path.node.body = template$1.statement.ast`{
        try {
          ${path.node.body.body}
        } catch (e) {
          return Promise.reject(e);
        }
      }`;
  } else path.get("body").unshiftContainer("body", body);

  return true;
}

const buildLooseRest = template$1.statement(`
  var ARRAY = Array.prototype.slice.call(ARGUMENTS, START);
`);
const buildRest = template$1.statement(`
  for (var LEN = ARGUMENTS.length, ARRAY = new Array(ARRAY_LEN), KEY = START; KEY < LEN; KEY++)
    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];
`);
const restIndex = template$1.expression(`
  INDEX < OFFSET || ARGUMENTS.length <= INDEX ? void 0 : ARGUMENTS[INDEX]
`);
const restIndexImpure = template$1.expression(`
  (REF = INDEX) < OFFSET || ARGUMENTS.length <= REF ? void 0 : ARGUMENTS[REF]
`);
const restLength = template$1.expression(`
  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET
`);
function referencesRest(path, state) {
  return path.node.name === state.name && path.scope.bindingIdentifierEquals(state.name, state.outerBinding);
}
const memberExpressionOptimisationVisitor = {
  Scope(path, state) {
    path.scope.bindingIdentifierEquals(state.name, state.outerBinding) || path.skip();
  },
  Flow(path) {
    path.isTypeCastExpression() || path.skip();
  },
  Function(path, state) {
    const oldNoOptimise = state.noOptimise;
    state.noOptimise = true;
    path.traverse(memberExpressionOptimisationVisitor, state);
    state.noOptimise = oldNoOptimise;
    path.skip();
  },
  ReferencedIdentifier(path, state) {
    const { node } = path;
    if (node.name === "arguments") state.deopted = true;

    if (!referencesRest(path, state)) return;
    if (state.noOptimise) state.deopted = true;
    else {
      const { parentPath } = path;
      if (parentPath.listKey === "params" && parentPath.key < state.offset) return;

      if (parentPath.isMemberExpression({ object: node })) {
        const grandparentPath = parentPath.parentPath;
        if (!state.deopted && !(
          (grandparentPath.isAssignmentExpression() && parentPath.node === grandparentPath.node.left) ||
          grandparentPath.isLVal() || grandparentPath.isForXStatement() || grandparentPath.isUpdateExpression() ||
          grandparentPath.isUnaryExpression({ operator: "delete" }) ||
          ((grandparentPath.isCallExpression() || grandparentPath.isNewExpression()) &&
            parentPath.node === grandparentPath.node.callee)
        ))
          if (parentPath.node.computed) {
            if (parentPath.get("property").isBaseType("number")) {
              state.candidates.push({ cause: "indexGetter", path });
              return;
            }
          } else if (parentPath.node.property.name === "length") {
            state.candidates.push({ cause: "lengthGetter", path });
            return;
          }
      }
      if (state.offset === 0 && parentPath.isSpreadElement()) {
        const call = parentPath.parentPath;
        if (call.isCallExpression() && call.node.arguments.length === 1) {
          state.candidates.push({ cause: "argSpread", path });
          return;
        }
      }
      state.references.push(path);
    }
  },
  BindingIdentifier(path, state) {
    if (referencesRest(path, state)) state.deopted = true;
  }
};
function getParamsCount(node) {
  let count = node.params.length;
  if (count > 0 && t$5.isIdentifier(node.params[0], { name: "this" })) count -= 1;

  return count;
}
function hasRest(node) {
  const length = node.params.length;
  return length > 0 && t$5.isRestElement(node.params[length - 1]);
}
function optimiseIndexGetter(path, argsId, offset) {
  const offsetLiteral = t$5.numericLiteral(offset),
    parent = path.parent;
  let index = t$5.isNumericLiteral(parent.property)
    ? t$5.numericLiteral(parent.property.value + offset)
    : offset === 0
    ? parent.property
    : t$5.binaryExpression("+", parent.property, t$5.cloneNode(offsetLiteral));

  const { scope, parentPath } = path;
  if (!scope.isPure(index)) {
    const temp = scope.generateUidIdentifierBasedOnNode(index);
    scope.push({ id: temp, kind: "var" });
    parentPath.replaceWith(
      restIndexImpure({ ARGUMENTS: argsId, OFFSET: offsetLiteral, INDEX: index, REF: t$5.cloneNode(temp) })
    );
  } else {
    parentPath.replaceWith(restIndex({ ARGUMENTS: argsId, OFFSET: offsetLiteral, INDEX: index }));
    const replacedParentPath = parentPath,
      offsetTestPath = replacedParentPath.get("test"),
      valRes = offsetTestPath.get("left").evaluate();
    if (valRes.confident)
      valRes.value === true
        ? replacedParentPath.replaceWith(scope.buildUndefinedNode())
        : offsetTestPath.replaceWith(offsetTestPath.get("right"));
  }
}
function optimiseLengthGetter(path, argsId, offset) {
  offset
    ? path.parentPath.replaceWith(restLength({ ARGUMENTS: argsId, OFFSET: t$5.numericLiteral(offset) }))
    : path.replaceWith(argsId);
}
function convertFunctionRest(path, loose = false) {
  const { node, scope } = path;
  if (!hasRest(node)) return false;
  const restPath = path.get(`params.${node.params.length - 1}.argument`);
  if (!restPath.isIdentifier()) {
    const shadowedParams = new Set();
    collectShadowedParamsNames(restPath, path.scope, shadowedParams);
    let needsIIFE = shadowedParams.size > 0;
    if (!needsIIFE) {
      const state = { needsOuterBinding: false, scope };
      restPath.traverse(iifeVisitor, state);
      needsIIFE = state.needsOuterBinding;
    }
    if (needsIIFE) {
      path.ensureBlock();
      path.set("body", t$5.blockStatement([buildScopeIIFE(shadowedParams, path.node.body)]));
    }
  }
  let rest = restPath.node;
  node.params.pop();
  if (t$5.isPattern(rest)) {
    const pattern = rest;
    rest = scope.generateUidIdentifier("ref");
    const declar = t$5.variableDeclaration("let", [t$5.variableDeclarator(pattern, rest)]);
    path.ensureBlock();
    node.body.body.unshift(declar);
  } else rest.name !== "arguments" || scope.rename(rest.name);

  const argsId = t$5.identifier("arguments"),
    paramsCount = getParamsCount(node);
  const state = {
    references: [],
    offset: paramsCount,
    argumentsNode: argsId,
    outerBinding: scope.getBindingIdentifier(rest.name),
    candidates: [],
    name: rest.name,
    deopted: false
  };
  path.traverse(memberExpressionOptimisationVisitor, state);
  if (!state.deopted && !state.references.length) {
    for (const { path, cause } of state.candidates) {
      const clonedArgsId = t$5.cloneNode(argsId);
      switch (cause) {
        case "indexGetter":
          optimiseIndexGetter(path, clonedArgsId, state.offset);
          break;
        case "lengthGetter":
          optimiseLengthGetter(path, clonedArgsId, state.offset);
          break;
        default:
          path.replaceWith(clonedArgsId);
      }
    }
    return true;
  }
  state.references.push(...state.candidates.map(({ path }) => path));
  const start = t$5.numericLiteral(paramsCount),
    key = scope.generateUidIdentifier("key"),
    len = scope.generateUidIdentifier("len");
  let arrKey, arrLen;
  if (paramsCount) {
    arrKey = t$5.binaryExpression("-", t$5.cloneNode(key), t$5.cloneNode(start));
    arrLen = t$5.conditionalExpression(
      t$5.binaryExpression(">", t$5.cloneNode(len), t$5.cloneNode(start)),
      t$5.binaryExpression("-", t$5.cloneNode(len), t$5.cloneNode(start)),
      t$5.numericLiteral(0)
    );
  } else {
    arrKey = t$5.identifier(key.name);
    arrLen = t$5.identifier(len.name);
  }
  const loop = loose
    ? buildLooseRest({ ARGUMENTS: argsId, START: start, ARRAY: rest })
    : buildRest({
        ARGUMENTS: argsId, ARRAY_KEY: arrKey, ARRAY_LEN: arrLen, START: start, ARRAY: rest, KEY: key, LEN: len
      });
  if (state.deopted) node.body.body.unshift(loop);
  else {
    let target = path.getEarliestCommonAncestorFrom(state.references).getStatementParent();
    target.findParent(path => {
      if (!path.isLoop()) return path.isFunction();

      target = path;
    });
    target.insertBefore(loop);
  }
  return true;
}

var transformParameters = declare((api, options) => {
  var _api$assumption, _api$assumption2;
  api.assertVersion(7);
  const ignoreFunctionLength =
      (_api$assumption = api.assumption("ignoreFunctionLength")) != null ? _api$assumption : options.loose,
    noNewArrows = (_api$assumption2 = api.assumption("noNewArrows")) == null || _api$assumption2;
  return {
    name: "transform-parameters",
    visitor: {
      Function(path) {
        if (
          path.isArrowFunctionExpression() &&
          path.get("params").some(param => param.isRestElement() || param.isAssignmentPattern())
        ) {
          path.arrowFunctionToExpression({ allowInsertArrowWithRest: false, noNewArrows });
          if (!path.isFunctionExpression()) return;
        }
        const convertedRest = convertFunctionRest(path, options.loose),
          convertedParams = convertFunctionParams(path, ignoreFunctionLength);
        if (convertedRest || convertedParams) path.scope.crawl();
      }
    }
  };
});

var proposalDestructuringPrivate = declare(function ({ assertVersion, assumption, types: t }) {
  assertVersion("^7.17.0");
  const {
    assignmentExpression,
    assignmentPattern,
    cloneNode,
    expressionStatement,
    isExpressionStatement,
    isIdentifier,
    isSequenceExpression,
    sequenceExpression,
    variableDeclaration,
    variableDeclarator
  } = t;
  const ignoreFunctionLength = assumption("ignoreFunctionLength"),
    objectRestNoSymbols = assumption("objectRestNoSymbols");
  const privateKeyDestructuringVisitor = {
    Function(path) {
      const firstPrivateIndex = path.node.params.findIndex(param => hasPrivateKeys(param));
      if (firstPrivateIndex < 0) return;
      convertFunctionParams(path, ignoreFunctionLength, () => false);
      const { node, scope } = path,
        { params } = node,
        firstAssignmentPatternIndex = ignoreFunctionLength
          ? -1
          : params.findIndex(param => param.type === "AssignmentPattern"),
        paramsAfterIndex = params.splice(firstPrivateIndex),
        { params: transformedParams, variableDeclaration } = buildVariableDeclarationFromParams(paramsAfterIndex, scope);
      path.get("body").unshiftContainer("body", variableDeclaration);
      params.push(...transformedParams);
      if (firstAssignmentPatternIndex >= firstPrivateIndex)
        params[firstAssignmentPatternIndex] = assignmentPattern(
          params[firstAssignmentPatternIndex], scope.buildUndefinedNode()
        );

      scope.crawl();
    },
    CatchClause(path) {
      const { node, scope } = path;
      if (!hasPrivateKeys(node.param)) return;
      const ref = scope.generateUidIdentifier("e");
      path.get("body").unshiftContainer("body", variableDeclaration("let", [variableDeclarator(node.param, ref)]));
      node.param = cloneNode(ref);
      scope.crawl();
    },
    ForXStatement(path) {
      const { node, scope } = path,
        leftPath = path.get("left");
      if (leftPath.isVariableDeclaration()) {
        const left = leftPath.node;
        if (!hasPrivateKeys(left.declarations[0].id)) return;
        const temp = scope.generateUidIdentifier("ref");
        node.left = variableDeclaration(left.kind, [variableDeclarator(temp, null)]);
        left.declarations[0].init = cloneNode(temp);
        unshiftForXStatementBody(path, [left]);
        scope.crawl();
      } else if (leftPath.isPattern()) {
        if (!hasPrivateKeys(leftPath.node)) return;
        const temp = scope.generateUidIdentifier("ref");
        node.left = variableDeclaration("const", [variableDeclarator(temp, null)]);
        unshiftForXStatementBody(path, [
          expressionStatement(assignmentExpression("=", leftPath.node, cloneNode(temp)))
        ]);
        scope.crawl();
      }
    },
    VariableDeclaration(path, state) {
      const { scope, node } = path,
        { declarations } = node;
      if (!declarations.some(declarator => hasPrivateKeys(declarator.id))) return;

      const newDeclarations = [];
      for (const declarator of declarations)
        for (const { left, right } of transformPrivateKeyDestructuring(
          declarator.id, declarator.init, scope, false, false, name => state.addHelper(name), objectRestNoSymbols, true
        ))
          newDeclarations.push(variableDeclarator(left, right));

      node.declarations = newDeclarations;
      scope.crawl();
    },
    AssignmentExpression(path, state) {
      const { node, scope, parent } = path;
      if (!hasPrivateKeys(node.left)) return;
      const assignments = [],
        shouldPreserveCompletion =
          (!isExpressionStatement(parent) && !isSequenceExpression(parent)) || path.isCompletionRecord();
      for (const { left, right } of transformPrivateKeyDestructuring(
        node.left, node.right, scope, true, shouldPreserveCompletion,
        name => state.addHelper(name), objectRestNoSymbols, true
      ))
        assignments.push(assignmentExpression("=", left, right));

      if (shouldPreserveCompletion) {
        const { left, right } = assignments[0];
        if (isIdentifier(left) && right === node.right)
          isIdentifier(assignments[assignments.length - 1].right, { name: left.name }) ||
            assignments.push(cloneNode(left));
        else {
          const tempId = scope.generateDeclaredUidIdentifier("m");
          assignments.unshift(assignmentExpression("=", tempId, cloneNode(node.right)));
          assignments.push(cloneNode(tempId));
        }
      }
      path.replaceWith(sequenceExpression(assignments));
      scope.crawl();
    }
  };
  return {
    name: "proposal-destructuring-private",
    inherits: syntaxDestructuringPrivate,
    visitor: {
      Class(path, state) {
        hasPrivateClassElement(path.node.body) && path.traverse(privateKeyDestructuringVisitor, state);
      }
    }
  };
});

var proposalDoExpressions = declare(api => {
  api.assertVersion(7);
  return {
    name: "proposal-do-expressions",
    inherits: syntaxDoExpressions,
    visitor: {
      DoExpression: {
        exit(path) {
          const { node } = path;
          if (node.async) return;

          const body = node.body.body;
          body.length
            ? path.replaceExpressionWithStatements(body)
            : path.replaceWith(path.scope.buildUndefinedNode());
        }
      }
    }
  };
});

const FEATURES = Object.freeze({
  unicodeFlag: 1,
  dotAllFlag: 2,
  unicodePropertyEscape: 4,
  namedCaptureGroups: 8,
  unicodeSetsFlag_syntax: 16,
  unicodeSetsFlag: 32,
  duplicateNamedCaptureGroups: 64,
  modifiers: 128
});
const featuresKey = "@babel/plugin-regexp-features/featuresKey",
  runtimeKey = "@babel/plugin-regexp-features/runtimeKey";
function enableFeature(features, feature) {
  return features | feature;
}
function hasFeature(features, feature) {
  return !!(features & feature);
}

function generateRegexpuOptions(pattern, toTransform) {
  const feat = (name, ok = "transform") => !!hasFeature(toTransform, FEATURES[name]) && ok;
  const featDuplicateNamedGroups = () => {
    if (!feat("duplicateNamedCaptureGroups")) return false;
    const regex = /\(\?<([^>]+)>/g,
      seen = new Set();
    for (let match; (match = regex.exec(pattern)); seen.add(match[1])) if (seen.has(match[1])) return "transform";

    return false;
  };
  return {
    unicodeFlag: feat("unicodeFlag"),
    unicodeSetsFlag: feat("unicodeSetsFlag") || "parse",
    dotAllFlag: feat("dotAllFlag"),
    unicodePropertyEscapes: feat("unicodePropertyEscape"),
    namedGroups: feat("namedCaptureGroups") || featDuplicateNamedGroups(),
    onNamedGroup: () => {},
    modifiers: feat("modifiers")
  };
}
function canSkipRegexpu(node, options) {
  const { flags, pattern } = node;
  if (flags.includes("v") && options.unicodeSetsFlag === "transform") return false;

  if (flags.includes("u")) {
    if (options.unicodeFlag === "transform") return false;
    if (options.unicodePropertyEscapes === "transform" && /\\[pP]{/.test(pattern)) return false;
  }
  return !(
    (flags.includes("s") && options.dotAllFlag === "transform") ||
    (options.namedGroups === "transform" && /\(\?<(?![=!])/.test(pattern)) ||
    (options.modifiers === "transform" && /\(\?[\w-]+:/.test(pattern))
  );
}
function transformFlags(regexpuOptions, flags) {
  if (regexpuOptions.unicodeSetsFlag === "transform") flags = flags.replace("v", "u");

  if (regexpuOptions.unicodeFlag === "transform") flags = flags.replace("u", "");
  if (regexpuOptions.dotAllFlag === "transform") flags = flags.replace("s", "");

  return flags;
}

const versionKey = "@babel/plugin-regexp-features/version";
function createRegExpFeaturePlugin({ name, feature, options = {}, manipulateOptions = () => {} }) {
  return {
    name,
    manipulateOptions,
    pre() {
      var _file$get;
      const { file } = this,
        features = (_file$get = file.get(featuresKey)) != null ? _file$get : 0;
      let newFeatures = enableFeature(features, FEATURES[feature]);
      const { useUnicodeFlag, runtime } = options;
      if (useUnicodeFlag === false) newFeatures = enableFeature(newFeatures, FEATURES.unicodeFlag);

      newFeatures === features || file.set(featuresKey, newFeatures);

      if (runtime !== void 0) {
        if (
          file.has(runtimeKey) && file.get(runtimeKey) !== runtime &&
          hasFeature(newFeatures, FEATURES.duplicateNamedCaptureGroups)
        )
          throw new Error(
            "The 'runtime' option must be the same for '@babel/plugin-transform-named-capturing-groups-regex' and '@babel/plugin-proposal-duplicate-named-capturing-groups-regex'."
          );

        (feature === "namedCaptureGroups" && runtime && file.has(runtimeKey)) || file.set(runtimeKey, runtime);
      }

      (typeof file.get(versionKey) != "number" &&
        file.get(versionKey) && !vendors.semver.lt(file.get(versionKey), "7.22.15")) ||
        file.set(versionKey, "7.22.15");
    },
    visitor: {
      RegExpLiteral(path) {
        var _file$get2, _newFlags;
        const { node } = path,
          { file } = this,
          features = file.get(featuresKey),
          runtime = (_file$get2 = file.get(runtimeKey)) == null || _file$get2,
          regexpuOptions = generateRegexpuOptions(node.pattern, features);
        if (canSkipRegexpu(node, regexpuOptions)) return;

        const namedCaptureGroups = { __proto__: null };
        if (regexpuOptions.namedGroups === "transform")
          regexpuOptions.onNamedGroup = (name, index) => {
            const prev = namedCaptureGroups[name];
            typeof prev == "number"
              ? (namedCaptureGroups[name] = [prev, index])
              : Array.isArray(prev)
              ? prev.push(index)
              : (namedCaptureGroups[name] = index);
          };

        let newFlags;
        if (regexpuOptions.modifiers === "transform")
          regexpuOptions.onNewFlags = flags => {
            newFlags = flags;
          };

        node.pattern = vendors.rewritePattern(node.pattern, node.flags, regexpuOptions);
        if (
          regexpuOptions.namedGroups === "transform" &&
          Object.keys(namedCaptureGroups).length > 0 && runtime && !isRegExpTest(path)
        ) {
          const call = t$5.callExpression(this.addHelper("wrapRegExp"), [node, t$5.valueToNode(namedCaptureGroups)]);
          annotateAsPure(call);
          path.replaceWith(call);
        }
        node.flags = transformFlags(regexpuOptions, (_newFlags = newFlags) != null ? _newFlags : node.flags);
      }
    }
  };
}
function isRegExpTest(path) {
  return (
    path.parentPath.isMemberExpression({ object: path.node, computed: false }) &&
    path.parentPath.get("property").isIdentifier({ name: "test" })
  );
}

var proposalDuplicateNamedCapturingGroupsRegex = declare((api, options) => {
  api.assertVersion("^7.19.0");
  const { runtime } = options;
  if (runtime !== void 0 && typeof runtime != "boolean") throw new Error("The 'runtime' option must be boolean");

  return createRegExpFeaturePlugin({
    name: "proposal-duplicate-named-capturing-groups-regex",
    feature: "duplicateNamedCaptureGroups",
    options: { runtime }
  });
});

const SUPPORTED_MODULES = ["commonjs", "amd", "systemjs"];
const MODULES_NOT_FOUND = `\
@babel/plugin-transform-dynamic-import depends on a modules
transform plugin. Supported plugins are:
 - @babel/plugin-transform-modules-commonjs ^7.4.0
 - @babel/plugin-transform-modules-amd ^7.4.0
 - @babel/plugin-transform-modules-systemjs ^7.4.0

If you are using Webpack or Rollup and thus don't want
Babel to transpile your imports and exports, you can use
the @babel/plugin-syntax-dynamic-import plugin and let your
bundler handle dynamic imports.
`;
var proposalDynamicImport = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-dynamic-import",
    inherits: void 0,
    pre() {
      this.file.set("@babel/plugin-proposal-dynamic-import", "7.22.11");
    },
    visitor: {
      Program() {
        const modules = this.file.get("@babel/plugin-transform-modules-*");
        if (!SUPPORTED_MODULES.includes(modules)) throw new Error(MODULES_NOT_FOUND);
      }
    }
  };
});

var proposalExportDefaultFrom = declare(api => {
  api.assertVersion(7);
  return {
    name: "proposal-export-default-from",
    inherits: syntaxExportDefaultFrom,
    visitor: {
      ExportNamedDeclaration(path) {
        const { node } = path,
          { specifiers, source } = node;
        if (!t$5.isExportDefaultSpecifier(specifiers[0])) return;
        const { exported } = specifiers.shift();

        specifiers.every(s => t$5.isExportSpecifier(s))
          ? specifiers.unshift(t$5.exportSpecifier(t$5.identifier("default"), exported))
          : path.insertBefore(t$5.exportNamedDeclaration(
              null, [t$5.exportSpecifier(t$5.identifier("default"), exported)], t$5.cloneNode(source)
            ));
      }
    }
  };
});

var proposalExportNamespaceFrom = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-export-namespace-from",
    inherits: void 0,
    visitor: {
      ExportNamedDeclaration(path) {
        var _exported$name;
        const { node, scope } = path,
          { specifiers } = node,
          index = t$5.isExportDefaultSpecifier(specifiers[0]) ? 1 : 0;
        if (!t$5.isExportNamespaceSpecifier(specifiers[index])) return;
        const nodes = [];
        index !== 1 || nodes.push(t$5.exportNamedDeclaration(null, [specifiers.shift()], node.source));

        const specifier = specifiers.shift(),
          { exported } = specifier,
          uid = scope.generateUidIdentifier(
            (_exported$name = exported.name) != null ? _exported$name : exported.value
          );
        nodes.push(
          t$5.importDeclaration([t$5.importNamespaceSpecifier(uid)], t$5.cloneNode(node.source)),
          t$5.exportNamedDeclaration(null, [t$5.exportSpecifier(t$5.cloneNode(uid), exported)])
        );
        node.specifiers.length >= 1 && nodes.push(node);

        const [importDeclaration] = path.replaceWithMultiple(nodes);
        path.scope.registerDeclaration(importDeclaration);
      }
    }
  };
});

var proposalFunctionBind = declare(api => {
  api.assertVersion(7);
  function getTempId(scope) {
    let id = scope.path.getData("functionBind");
    if (id) return t$5.cloneNode(id);
    id = scope.generateDeclaredUidIdentifier("context");
    return scope.path.setData("functionBind", id);
  }
  function getObject(bind) {
    return t$5.isExpression(bind.object) ? bind.object : bind.callee.object;
  }
  function getStaticContext(bind, scope) {
    const object = getObject(bind);
    return scope.isStatic(object) && (t$5.isSuper(object) ? t$5.thisExpression() : object);
  }
  function inferBindContext(bind, scope) {
    const staticContext = getStaticContext(bind, scope);
    if (staticContext) return t$5.cloneNode(staticContext);
    const tempId = getTempId(scope);
    if (bind.object)
      bind.callee = t$5.sequenceExpression([t$5.assignmentExpression("=", tempId, bind.object), bind.callee]);
    else if (t$5.isMemberExpression(bind.callee))
      bind.callee.object = t$5.assignmentExpression("=", tempId, bind.callee.object);

    return t$5.cloneNode(tempId);
  }
  return {
    name: "proposal-function-bind",
    inherits: syntaxFunctionBind,
    visitor: {
      CallExpression({ node, scope }) {
        const bind = node.callee;
        if (!t$5.isBindExpression(bind)) return;
        const context = inferBindContext(bind, scope);
        node.callee = t$5.memberExpression(bind.callee, t$5.identifier("call"));
        node.arguments.unshift(context);
      },
      BindExpression(path) {
        const { node, scope } = path,
          context = inferBindContext(node, scope);
        path.replaceWith(t$5.callExpression(t$5.memberExpression(node.callee, t$5.identifier("bind")), [context]));
      }
    }
  };
});

var proposalFunctionSent = declare(api => {
  api.assertVersion(7);
  const isFunctionSent = node =>
    t$5.isIdentifier(node.meta, { name: "function" }) && t$5.isIdentifier(node.property, { name: "sent" });
  const hasBeenReplaced = (node, sentId) =>
    t$5.isAssignmentExpression(node) && t$5.isIdentifier(node.left, { name: sentId });
  const yieldVisitor = {
    Function(path) {
      path.skip();
    },
    YieldExpression(path) {
      hasBeenReplaced(path.parent, this.sentId) ||
        path.replaceWith(t$5.assignmentExpression("=", t$5.identifier(this.sentId), path.node));
    },
    MetaProperty(path) {
      isFunctionSent(path.node) && path.replaceWith(t$5.identifier(this.sentId));
    }
  };
  return {
    name: "proposal-function-sent",
    inherits: syntaxFunctionSent,
    visitor: {
      MetaProperty(path, state) {
        if (!isFunctionSent(path.node)) return;
        const fnPath = path.getFunctionParent();
        if (!fnPath.node.generator) throw new Error("Parent generator function not found");

        const sentId = path.scope.generateUid("function.sent");
        fnPath.traverse(yieldVisitor, { sentId });
        fnPath.node.body.body.unshift(
          t$5.variableDeclaration("let", [t$5.variableDeclarator(t$5.identifier(sentId), t$5.yieldExpression())])
        );
        wrapFunction(fnPath, state.addHelper("skipFirstGeneratorNext"));
      }
    }
  };
});

var proposalJsonStrings = declare(api => {
  api.assertVersion(7);
  const regex = /(\\*)([\u2028\u2029])/g;
  function replace(match, escapes, separator) {
    return escapes.length % 2 == 1 ? match : `${escapes}\\u${separator.charCodeAt(0).toString(16)}`;
  }
  return {
    name: "transform-json-strings",
    inherits: void 0,
    visitor: {
      "DirectiveLiteral|StringLiteral"({ node }) {
        const { extra } = node;
        if (extra != null && extra.raw) extra.raw = extra.raw.replace(regex, replace);
      }
    }
  };
});

var proposalLogicalAssignmentOperators = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-logical-assignment-operators",
    inherits: void 0,
    visitor: {
      AssignmentExpression(path) {
        const { node, scope } = path,
          { operator, left, right } = node,
          operatorTrunc = operator.slice(0, -1);
        if (!t$5.LOGICAL_OPERATORS.includes(operatorTrunc)) return;

        const lhs = t$5.cloneNode(left);
        if (t$5.isMemberExpression(left)) {
          const { object, property, computed } = left,
            memo = scope.maybeGenerateMemoised(object);
          if (memo) {
            left.object = memo;
            lhs.object = t$5.assignmentExpression("=", t$5.cloneNode(memo), object);
          }
          if (computed) {
            const memo = scope.maybeGenerateMemoised(property);
            if (memo) {
              left.property = memo;
              lhs.property = t$5.assignmentExpression("=", t$5.cloneNode(memo), property);
            }
          }
        }
        path.replaceWith(t$5.logicalExpression(operatorTrunc, lhs, t$5.assignmentExpression("=", left, right)));
      }
    }
  };
});

var proposalNullishCoalescingOperator = declare((api, { loose = false }) => {
  var _api$assumption;
  api.assertVersion(7);
  const noDocumentAll = (_api$assumption = api.assumption("noDocumentAll")) != null ? _api$assumption : loose;
  return {
    name: "transform-nullish-coalescing-operator",
    inherits: void 0,
    visitor: {
      LogicalExpression(path) {
        const { node, scope } = path;
        if (node.operator !== "??") return;

        let ref, assignment;
        if (scope.isStatic(node.left)) {
          ref = node.left;
          assignment = t$5.cloneNode(node.left);
        } else if (scope.path.isPattern()) {
          path.replaceWith(template$1.statement.ast`(() => ${path.node})()`);
          return;
        } else {
          ref = scope.generateUidIdentifierBasedOnNode(node.left);
          scope.push({ id: t$5.cloneNode(ref) });
          assignment = t$5.assignmentExpression("=", ref, node.left);
        }
        path.replaceWith(t$5.conditionalExpression(
          noDocumentAll
            ? t$5.binaryExpression("!=", assignment, t$5.nullLiteral())
            : t$5.logicalExpression("&&",
                t$5.binaryExpression("!==", assignment, t$5.nullLiteral()),
                t$5.binaryExpression("!==", t$5.cloneNode(ref), scope.buildUndefinedNode())
              ),
          t$5.cloneNode(ref), node.right
        ));
      }
    }
  };
});

function remover({ node }) {
  var _extra$raw;
  const { extra } = node;
  if (extra != null && (_extra$raw = extra.raw) != null && _extra$raw.includes("_"))
    extra.raw = extra.raw.replace(/_/g, "");
}
var proposalNumericSeparator = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-numeric-separator",
    inherits: void 0,
    visitor: { NumericLiteral: remover, BigIntLiteral: remover }
  };
});

var require$$0$4 = {
  "es6.array.copy-within": {
    chrome: "45",
    opera: "32",
    edge: "12",
    firefox: "32",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "5",
    rhino: "1.7.13",
    opera_mobile: "32",
    electron: "0.31"
  },
  "es6.array.every": {
    chrome: "5",
    opera: "10.10",
    edge: "12",
    firefox: "2",
    safari: "3.1",
    node: "0.4",
    deno: "1",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    opera_mobile: "10.1",
    electron: "0.20"
  },
  "es6.array.fill": {
    chrome: "45",
    opera: "32",
    edge: "12",
    firefox: "31",
    safari: "7.1",
    node: "4",
    deno: "1",
    ios: "8",
    samsung: "5",
    rhino: "1.7.13",
    opera_mobile: "32",
    electron: "0.31"
  },
  "es6.array.filter": {
    chrome: "51",
    opera: "38",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "es6.array.find": {
    chrome: "45",
    opera: "32",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "4",
    deno: "1",
    ios: "8",
    samsung: "5",
    rhino: "1.7.13",
    opera_mobile: "32",
    electron: "0.31"
  },
  "es6.array.find-index": {
    chrome: "45",
    opera: "32",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "4",
    deno: "1",
    ios: "8",
    samsung: "5",
    rhino: "1.7.13",
    opera_mobile: "32",
    electron: "0.31"
  },
  "es7.array.flat-map": {
    chrome: "69",
    opera: "56",
    edge: "79",
    firefox: "62",
    safari: "12",
    node: "11",
    deno: "1",
    ios: "12",
    samsung: "10",
    opera_mobile: "48",
    electron: "4.0"
  },
  "es6.array.for-each": {
    chrome: "5",
    opera: "10.10",
    edge: "12",
    firefox: "2",
    safari: "3.1",
    node: "0.4",
    deno: "1",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    opera_mobile: "10.1",
    electron: "0.20"
  },
  "es6.array.from": {
    chrome: "51",
    opera: "38",
    edge: "15",
    firefox: "36",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "es7.array.includes": {
    chrome: "47",
    opera: "34",
    edge: "14",
    firefox: "102",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "34",
    electron: "0.36"
  },
  "es6.array.index-of": {
    chrome: "5",
    opera: "10.10",
    edge: "12",
    firefox: "2",
    safari: "3.1",
    node: "0.4",
    deno: "1",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    opera_mobile: "10.1",
    electron: "0.20"
  },
  "es6.array.is-array": {
    chrome: "5",
    opera: "10.50",
    edge: "12",
    firefox: "4",
    safari: "4",
    node: "0.4",
    deno: "1",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    opera_mobile: "10.1",
    electron: "0.20"
  },
  "es6.array.iterator": {
    chrome: "66",
    opera: "53",
    edge: "12",
    firefox: "60",
    safari: "9",
    node: "10",
    deno: "1",
    ios: "9",
    samsung: "9",
    rhino: "1.7.13",
    opera_mobile: "47",
    electron: "3.0"
  },
  "es6.array.last-index-of": {
    chrome: "5",
    opera: "10.10",
    edge: "12",
    firefox: "2",
    safari: "3.1",
    node: "0.4",
    deno: "1",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    opera_mobile: "10.1",
    electron: "0.20"
  },
  "es6.array.map": {
    chrome: "51",
    opera: "38",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "es6.array.of": {
    chrome: "45",
    opera: "32",
    edge: "12",
    firefox: "25",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "5",
    rhino: "1.7.13",
    opera_mobile: "32",
    electron: "0.31"
  },
  "es6.array.reduce": {
    chrome: "5",
    opera: "10.50",
    edge: "12",
    firefox: "3",
    safari: "4",
    node: "0.4",
    deno: "1",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    opera_mobile: "10.1",
    electron: "0.20"
  },
  "es6.array.reduce-right": {
    chrome: "5",
    opera: "10.50",
    edge: "12",
    firefox: "3",
    safari: "4",
    node: "0.4",
    deno: "1",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    opera_mobile: "10.1",
    electron: "0.20"
  },
  "es6.array.slice": {
    chrome: "51",
    opera: "38",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "es6.array.some": {
    chrome: "5",
    opera: "10.10",
    edge: "12",
    firefox: "2",
    safari: "3.1",
    node: "0.4",
    deno: "1",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    opera_mobile: "10.1",
    electron: "0.20"
  },
  "es6.array.sort": {
    chrome: "63",
    opera: "50",
    edge: "12",
    firefox: "5",
    safari: "12",
    node: "10",
    deno: "1",
    ie: "9",
    ios: "12",
    samsung: "8",
    rhino: "1.7.13",
    opera_mobile: "46",
    electron: "3.0"
  },
  "es6.array.species": {
    chrome: "51",
    opera: "38",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "es6.date.now": {
    chrome: "5",
    opera: "10.50",
    edge: "12",
    firefox: "2",
    safari: "4",
    node: "0.4",
    deno: "1",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    opera_mobile: "10.1",
    electron: "0.20"
  },
  "es6.date.to-iso-string": {
    chrome: "5",
    opera: "10.50",
    edge: "12",
    firefox: "3.5",
    safari: "4",
    node: "0.4",
    deno: "1",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    opera_mobile: "10.1",
    electron: "0.20"
  },
  "es6.date.to-json": {
    chrome: "5",
    opera: "12.10",
    edge: "12",
    firefox: "4",
    safari: "10",
    node: "0.4",
    deno: "1",
    ie: "9",
    android: "4",
    ios: "10",
    samsung: "1",
    rhino: "1.7.13",
    opera_mobile: "12.1",
    electron: "0.20"
  },
  "es6.date.to-primitive": {
    chrome: "47",
    opera: "34",
    edge: "15",
    firefox: "44",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "34",
    electron: "0.36"
  },
  "es6.date.to-string": {
    chrome: "5",
    opera: "10.50",
    edge: "12",
    firefox: "2",
    safari: "3.1",
    node: "0.4",
    deno: "1",
    ie: "10",
    android: "4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    opera_mobile: "10.1",
    electron: "0.20"
  },
  "es6.function.bind": {
    chrome: "7",
    opera: "12",
    edge: "12",
    firefox: "4",
    safari: "5.1",
    node: "0.4",
    deno: "1",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    opera_mobile: "12",
    electron: "0.20"
  },
  "es6.function.has-instance": {
    chrome: "51",
    opera: "38",
    edge: "15",
    firefox: "50",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "es6.function.name": {
    chrome: "5",
    opera: "10.50",
    edge: "14",
    firefox: "2",
    safari: "4",
    node: "0.4",
    deno: "1",
    android: "4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    opera_mobile: "10.1",
    electron: "0.20"
  },
  "es6.map": {
    chrome: "51",
    opera: "38",
    edge: "15",
    firefox: "53",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "es6.math.acosh": {
    chrome: "38",
    opera: "25",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    deno: "1",
    ios: "8",
    samsung: "3",
    rhino: "1.7.13",
    opera_mobile: "25",
    electron: "0.20"
  },
  "es6.math.asinh": {
    chrome: "38",
    opera: "25",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    deno: "1",
    ios: "8",
    samsung: "3",
    rhino: "1.7.13",
    opera_mobile: "25",
    electron: "0.20"
  },
  "es6.math.atanh": {
    chrome: "38",
    opera: "25",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    deno: "1",
    ios: "8",
    samsung: "3",
    rhino: "1.7.13",
    opera_mobile: "25",
    electron: "0.20"
  },
  "es6.math.cbrt": {
    chrome: "38",
    opera: "25",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    deno: "1",
    ios: "8",
    samsung: "3",
    rhino: "1.7.13",
    opera_mobile: "25",
    electron: "0.20"
  },
  "es6.math.clz32": {
    chrome: "38",
    opera: "25",
    edge: "12",
    firefox: "31",
    safari: "9",
    node: "0.12",
    deno: "1",
    ios: "9",
    samsung: "3",
    rhino: "1.7.13",
    opera_mobile: "25",
    electron: "0.20"
  },
  "es6.math.cosh": {
    chrome: "38",
    opera: "25",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    deno: "1",
    ios: "8",
    samsung: "3",
    rhino: "1.7.13",
    opera_mobile: "25",
    electron: "0.20"
  },
  "es6.math.expm1": {
    chrome: "38",
    opera: "25",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    deno: "1",
    ios: "8",
    samsung: "3",
    rhino: "1.7.13",
    opera_mobile: "25",
    electron: "0.20"
  },
  "es6.math.fround": {
    chrome: "38",
    opera: "25",
    edge: "12",
    firefox: "26",
    safari: "7.1",
    node: "0.12",
    deno: "1",
    ios: "8",
    samsung: "3",
    rhino: "1.7.13",
    opera_mobile: "25",
    electron: "0.20"
  },
  "es6.math.hypot": {
    chrome: "38",
    opera: "25",
    edge: "12",
    firefox: "27",
    safari: "7.1",
    node: "0.12",
    deno: "1",
    ios: "8",
    samsung: "3",
    rhino: "1.7.13",
    opera_mobile: "25",
    electron: "0.20"
  },
  "es6.math.imul": {
    chrome: "30",
    opera: "17",
    edge: "12",
    firefox: "23",
    safari: "7",
    node: "0.12",
    deno: "1",
    android: "4.4",
    ios: "7",
    samsung: "2",
    rhino: "1.7.13",
    opera_mobile: "18",
    electron: "0.20"
  },
  "es6.math.log1p": {
    chrome: "38",
    opera: "25",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    deno: "1",
    ios: "8",
    samsung: "3",
    rhino: "1.7.13",
    opera_mobile: "25",
    electron: "0.20"
  },
  "es6.math.log10": {
    chrome: "38",
    opera: "25",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    deno: "1",
    ios: "8",
    samsung: "3",
    rhino: "1.7.13",
    opera_mobile: "25",
    electron: "0.20"
  },
  "es6.math.log2": {
    chrome: "38",
    opera: "25",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    deno: "1",
    ios: "8",
    samsung: "3",
    rhino: "1.7.13",
    opera_mobile: "25",
    electron: "0.20"
  },
  "es6.math.sign": {
    chrome: "38",
    opera: "25",
    edge: "12",
    firefox: "25",
    safari: "9",
    node: "0.12",
    deno: "1",
    ios: "9",
    samsung: "3",
    rhino: "1.7.13",
    opera_mobile: "25",
    electron: "0.20"
  },
  "es6.math.sinh": {
    chrome: "38",
    opera: "25",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    deno: "1",
    ios: "8",
    samsung: "3",
    rhino: "1.7.13",
    opera_mobile: "25",
    electron: "0.20"
  },
  "es6.math.tanh": {
    chrome: "38",
    opera: "25",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    deno: "1",
    ios: "8",
    samsung: "3",
    rhino: "1.7.13",
    opera_mobile: "25",
    electron: "0.20"
  },
  "es6.math.trunc": {
    chrome: "38",
    opera: "25",
    edge: "12",
    firefox: "25",
    safari: "7.1",
    node: "0.12",
    deno: "1",
    ios: "8",
    samsung: "3",
    rhino: "1.7.13",
    opera_mobile: "25",
    electron: "0.20"
  },
  "es6.number.constructor": {
    chrome: "41",
    opera: "28",
    edge: "12",
    firefox: "36",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "3.4",
    rhino: "1.7.13",
    opera_mobile: "28",
    electron: "0.21"
  },
  "es6.number.epsilon": {
    chrome: "34",
    opera: "21",
    edge: "12",
    firefox: "25",
    safari: "9",
    node: "0.12",
    deno: "1",
    ios: "9",
    samsung: "2",
    rhino: "1.7.14",
    opera_mobile: "21",
    electron: "0.20"
  },
  "es6.number.is-finite": {
    chrome: "19",
    opera: "15",
    edge: "12",
    firefox: "16",
    safari: "9",
    node: "0.8",
    deno: "1",
    android: "4.1",
    ios: "9",
    samsung: "1.5",
    rhino: "1.7.13",
    opera_mobile: "14",
    electron: "0.20"
  },
  "es6.number.is-integer": {
    chrome: "34",
    opera: "21",
    edge: "12",
    firefox: "16",
    safari: "9",
    node: "0.12",
    deno: "1",
    ios: "9",
    samsung: "2",
    rhino: "1.7.13",
    opera_mobile: "21",
    electron: "0.20"
  },
  "es6.number.is-nan": {
    chrome: "19",
    opera: "15",
    edge: "12",
    firefox: "15",
    safari: "9",
    node: "0.8",
    deno: "1",
    android: "4.1",
    ios: "9",
    samsung: "1.5",
    rhino: "1.7.13",
    opera_mobile: "14",
    electron: "0.20"
  },
  "es6.number.is-safe-integer": {
    chrome: "34",
    opera: "21",
    edge: "12",
    firefox: "32",
    safari: "9",
    node: "0.12",
    deno: "1",
    ios: "9",
    samsung: "2",
    rhino: "1.7.13",
    opera_mobile: "21",
    electron: "0.20"
  },
  "es6.number.max-safe-integer": {
    chrome: "34",
    opera: "21",
    edge: "12",
    firefox: "31",
    safari: "9",
    node: "0.12",
    deno: "1",
    ios: "9",
    samsung: "2",
    rhino: "1.7.13",
    opera_mobile: "21",
    electron: "0.20"
  },
  "es6.number.min-safe-integer": {
    chrome: "34",
    opera: "21",
    edge: "12",
    firefox: "31",
    safari: "9",
    node: "0.12",
    deno: "1",
    ios: "9",
    samsung: "2",
    rhino: "1.7.13",
    opera_mobile: "21",
    electron: "0.20"
  },
  "es6.number.parse-float": {
    chrome: "34",
    opera: "21",
    edge: "12",
    firefox: "25",
    safari: "9",
    node: "0.12",
    deno: "1",
    ios: "9",
    samsung: "2",
    rhino: "1.7.14",
    opera_mobile: "21",
    electron: "0.20"
  },
  "es6.number.parse-int": {
    chrome: "34",
    opera: "21",
    edge: "12",
    firefox: "25",
    safari: "9",
    node: "0.12",
    deno: "1",
    ios: "9",
    samsung: "2",
    rhino: "1.7.14",
    opera_mobile: "21",
    electron: "0.20"
  },
  "es6.object.assign": {
    chrome: "49",
    opera: "36",
    edge: "13",
    firefox: "36",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "36",
    electron: "0.37"
  },
  "es6.object.create": {
    chrome: "5",
    opera: "12",
    edge: "12",
    firefox: "4",
    safari: "4",
    node: "0.4",
    deno: "1",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    opera_mobile: "12",
    electron: "0.20"
  },
  "es7.object.define-getter": {
    chrome: "62",
    opera: "49",
    edge: "16",
    firefox: "48",
    safari: "9",
    node: "8.10",
    deno: "1",
    ios: "9",
    samsung: "8",
    opera_mobile: "46",
    electron: "3.0"
  },
  "es7.object.define-setter": {
    chrome: "62",
    opera: "49",
    edge: "16",
    firefox: "48",
    safari: "9",
    node: "8.10",
    deno: "1",
    ios: "9",
    samsung: "8",
    opera_mobile: "46",
    electron: "3.0"
  },
  "es6.object.define-property": {
    chrome: "5",
    opera: "12",
    edge: "12",
    firefox: "4",
    safari: "5.1",
    node: "0.4",
    deno: "1",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    opera_mobile: "12",
    electron: "0.20"
  },
  "es6.object.define-properties": {
    chrome: "5",
    opera: "12",
    edge: "12",
    firefox: "4",
    safari: "4",
    node: "0.4",
    deno: "1",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    opera_mobile: "12",
    electron: "0.20"
  },
  "es7.object.entries": {
    chrome: "54",
    opera: "41",
    edge: "14",
    firefox: "47",
    safari: "10.1",
    node: "7",
    deno: "1",
    ios: "10.3",
    samsung: "6",
    rhino: "1.7.14",
    opera_mobile: "41",
    electron: "1.4"
  },
  "es6.object.freeze": {
    chrome: "44",
    opera: "31",
    edge: "12",
    firefox: "35",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "4",
    rhino: "1.7.13",
    opera_mobile: "32",
    electron: "0.30"
  },
  "es6.object.get-own-property-descriptor": {
    chrome: "44",
    opera: "31",
    edge: "12",
    firefox: "35",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "4",
    rhino: "1.7.13",
    opera_mobile: "32",
    electron: "0.30"
  },
  "es7.object.get-own-property-descriptors": {
    chrome: "54",
    opera: "41",
    edge: "15",
    firefox: "50",
    safari: "10.1",
    node: "7",
    deno: "1",
    ios: "10.3",
    samsung: "6",
    opera_mobile: "41",
    electron: "1.4"
  },
  "es6.object.get-own-property-names": {
    chrome: "40",
    opera: "27",
    edge: "12",
    firefox: "33",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "3.4",
    rhino: "1.7.13",
    opera_mobile: "27",
    electron: "0.21"
  },
  "es6.object.get-prototype-of": {
    chrome: "44",
    opera: "31",
    edge: "12",
    firefox: "35",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "4",
    rhino: "1.7.13",
    opera_mobile: "32",
    electron: "0.30"
  },
  "es7.object.lookup-getter": {
    chrome: "62",
    opera: "49",
    edge: "79",
    firefox: "36",
    safari: "9",
    node: "8.10",
    deno: "1",
    ios: "9",
    samsung: "8",
    opera_mobile: "46",
    electron: "3.0"
  },
  "es7.object.lookup-setter": {
    chrome: "62",
    opera: "49",
    edge: "79",
    firefox: "36",
    safari: "9",
    node: "8.10",
    deno: "1",
    ios: "9",
    samsung: "8",
    opera_mobile: "46",
    electron: "3.0"
  },
  "es6.object.prevent-extensions": {
    chrome: "44",
    opera: "31",
    edge: "12",
    firefox: "35",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "4",
    rhino: "1.7.13",
    opera_mobile: "32",
    electron: "0.30"
  },
  "es6.object.to-string": {
    chrome: "57",
    opera: "44",
    edge: "15",
    firefox: "51",
    safari: "10",
    node: "8",
    deno: "1",
    ios: "10",
    samsung: "7",
    opera_mobile: "43",
    electron: "1.7"
  },
  "es6.object.is": {
    chrome: "19",
    opera: "15",
    edge: "12",
    firefox: "22",
    safari: "9",
    node: "0.8",
    deno: "1",
    android: "4.1",
    ios: "9",
    samsung: "1.5",
    rhino: "1.7.13",
    opera_mobile: "14",
    electron: "0.20"
  },
  "es6.object.is-frozen": {
    chrome: "44",
    opera: "31",
    edge: "12",
    firefox: "35",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "4",
    rhino: "1.7.13",
    opera_mobile: "32",
    electron: "0.30"
  },
  "es6.object.is-sealed": {
    chrome: "44",
    opera: "31",
    edge: "12",
    firefox: "35",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "4",
    rhino: "1.7.13",
    opera_mobile: "32",
    electron: "0.30"
  },
  "es6.object.is-extensible": {
    chrome: "44",
    opera: "31",
    edge: "12",
    firefox: "35",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "4",
    rhino: "1.7.13",
    opera_mobile: "32",
    electron: "0.30"
  },
  "es6.object.keys": {
    chrome: "40",
    opera: "27",
    edge: "12",
    firefox: "35",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "3.4",
    rhino: "1.7.13",
    opera_mobile: "27",
    electron: "0.21"
  },
  "es6.object.seal": {
    chrome: "44",
    opera: "31",
    edge: "12",
    firefox: "35",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "4",
    rhino: "1.7.13",
    opera_mobile: "32",
    electron: "0.30"
  },
  "es6.object.set-prototype-of": {
    chrome: "34",
    opera: "21",
    edge: "12",
    firefox: "31",
    safari: "9",
    node: "0.12",
    deno: "1",
    ie: "11",
    ios: "9",
    samsung: "2",
    rhino: "1.7.13",
    opera_mobile: "21",
    electron: "0.20"
  },
  "es7.object.values": {
    chrome: "54",
    opera: "41",
    edge: "14",
    firefox: "47",
    safari: "10.1",
    node: "7",
    deno: "1",
    ios: "10.3",
    samsung: "6",
    rhino: "1.7.14",
    opera_mobile: "41",
    electron: "1.4"
  },
  "es6.promise": {
    chrome: "51",
    opera: "38",
    edge: "14",
    firefox: "45",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "es7.promise.finally": {
    chrome: "63",
    opera: "50",
    edge: "18",
    firefox: "58",
    safari: "11.1",
    node: "10",
    deno: "1",
    ios: "11.3",
    samsung: "8",
    opera_mobile: "46",
    electron: "3.0"
  },
  "es6.reflect.apply": {
    chrome: "49",
    opera: "36",
    edge: "12",
    firefox: "42",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "36",
    electron: "0.37"
  },
  "es6.reflect.construct": {
    chrome: "49",
    opera: "36",
    edge: "13",
    firefox: "49",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "36",
    electron: "0.37"
  },
  "es6.reflect.define-property": {
    chrome: "49",
    opera: "36",
    edge: "13",
    firefox: "42",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "36",
    electron: "0.37"
  },
  "es6.reflect.delete-property": {
    chrome: "49",
    opera: "36",
    edge: "12",
    firefox: "42",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "36",
    electron: "0.37"
  },
  "es6.reflect.get": {
    chrome: "49",
    opera: "36",
    edge: "12",
    firefox: "42",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "36",
    electron: "0.37"
  },
  "es6.reflect.get-own-property-descriptor": {
    chrome: "49",
    opera: "36",
    edge: "12",
    firefox: "42",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "36",
    electron: "0.37"
  },
  "es6.reflect.get-prototype-of": {
    chrome: "49",
    opera: "36",
    edge: "12",
    firefox: "42",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "36",
    electron: "0.37"
  },
  "es6.reflect.has": {
    chrome: "49",
    opera: "36",
    edge: "12",
    firefox: "42",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "36",
    electron: "0.37"
  },
  "es6.reflect.is-extensible": {
    chrome: "49",
    opera: "36",
    edge: "12",
    firefox: "42",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "36",
    electron: "0.37"
  },
  "es6.reflect.own-keys": {
    chrome: "49",
    opera: "36",
    edge: "12",
    firefox: "42",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "36",
    electron: "0.37"
  },
  "es6.reflect.prevent-extensions": {
    chrome: "49",
    opera: "36",
    edge: "12",
    firefox: "42",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "36",
    electron: "0.37"
  },
  "es6.reflect.set": {
    chrome: "49",
    opera: "36",
    edge: "12",
    firefox: "42",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "36",
    electron: "0.37"
  },
  "es6.reflect.set-prototype-of": {
    chrome: "49",
    opera: "36",
    edge: "12",
    firefox: "42",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "36",
    electron: "0.37"
  },
  "es6.regexp.constructor": {
    chrome: "50",
    opera: "37",
    edge: "79",
    firefox: "40",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "37",
    electron: "1.1"
  },
  "es6.regexp.flags": {
    chrome: "49",
    opera: "36",
    edge: "79",
    firefox: "37",
    safari: "9",
    node: "6",
    deno: "1",
    ios: "9",
    samsung: "5",
    opera_mobile: "36",
    electron: "0.37"
  },
  "es6.regexp.match": {
    chrome: "50",
    opera: "37",
    edge: "79",
    firefox: "49",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    rhino: "1.7.13",
    opera_mobile: "37",
    electron: "1.1"
  },
  "es6.regexp.replace": {
    chrome: "50",
    opera: "37",
    edge: "79",
    firefox: "49",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "37",
    electron: "1.1"
  },
  "es6.regexp.split": {
    chrome: "50",
    opera: "37",
    edge: "79",
    firefox: "49",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "37",
    electron: "1.1"
  },
  "es6.regexp.search": {
    chrome: "50",
    opera: "37",
    edge: "79",
    firefox: "49",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    rhino: "1.7.13",
    opera_mobile: "37",
    electron: "1.1"
  },
  "es6.regexp.to-string": {
    chrome: "50",
    opera: "37",
    edge: "79",
    firefox: "39",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "37",
    electron: "1.1"
  },
  "es6.set": {
    chrome: "51",
    opera: "38",
    edge: "15",
    firefox: "53",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "es6.symbol": {
    chrome: "51",
    opera: "38",
    edge: "79",
    firefox: "51",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "es7.symbol.async-iterator": {
    chrome: "63",
    opera: "50",
    edge: "79",
    firefox: "57",
    safari: "12",
    node: "10",
    deno: "1",
    ios: "12",
    samsung: "8",
    opera_mobile: "46",
    electron: "3.0"
  },
  "es6.string.anchor": {
    chrome: "5",
    opera: "15",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.4",
    deno: "1",
    android: "4",
    ios: "7",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.14",
    opera_mobile: "14",
    electron: "0.20"
  },
  "es6.string.big": {
    chrome: "5",
    opera: "15",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.4",
    deno: "1",
    android: "4",
    ios: "7",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.14",
    opera_mobile: "14",
    electron: "0.20"
  },
  "es6.string.blink": {
    chrome: "5",
    opera: "15",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.4",
    deno: "1",
    android: "4",
    ios: "7",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.14",
    opera_mobile: "14",
    electron: "0.20"
  },
  "es6.string.bold": {
    chrome: "5",
    opera: "15",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.4",
    deno: "1",
    android: "4",
    ios: "7",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.14",
    opera_mobile: "14",
    electron: "0.20"
  },
  "es6.string.code-point-at": {
    chrome: "41",
    opera: "28",
    edge: "12",
    firefox: "29",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "3.4",
    rhino: "1.7.13",
    opera_mobile: "28",
    electron: "0.21"
  },
  "es6.string.ends-with": {
    chrome: "41",
    opera: "28",
    edge: "12",
    firefox: "29",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "3.4",
    rhino: "1.7.13",
    opera_mobile: "28",
    electron: "0.21"
  },
  "es6.string.fixed": {
    chrome: "5",
    opera: "15",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.4",
    deno: "1",
    android: "4",
    ios: "7",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.14",
    opera_mobile: "14",
    electron: "0.20"
  },
  "es6.string.fontcolor": {
    chrome: "5",
    opera: "15",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.4",
    deno: "1",
    android: "4",
    ios: "7",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.14",
    opera_mobile: "14",
    electron: "0.20"
  },
  "es6.string.fontsize": {
    chrome: "5",
    opera: "15",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.4",
    deno: "1",
    android: "4",
    ios: "7",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.14",
    opera_mobile: "14",
    electron: "0.20"
  },
  "es6.string.from-code-point": {
    chrome: "41",
    opera: "28",
    edge: "12",
    firefox: "29",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "3.4",
    rhino: "1.7.13",
    opera_mobile: "28",
    electron: "0.21"
  },
  "es6.string.includes": {
    chrome: "41",
    opera: "28",
    edge: "12",
    firefox: "40",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "3.4",
    rhino: "1.7.13",
    opera_mobile: "28",
    electron: "0.21"
  },
  "es6.string.italics": {
    chrome: "5",
    opera: "15",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.4",
    deno: "1",
    android: "4",
    ios: "7",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.14",
    opera_mobile: "14",
    electron: "0.20"
  },
  "es6.string.iterator": {
    chrome: "38",
    opera: "25",
    edge: "12",
    firefox: "36",
    safari: "9",
    node: "0.12",
    deno: "1",
    ios: "9",
    samsung: "3",
    rhino: "1.7.13",
    opera_mobile: "25",
    electron: "0.20"
  },
  "es6.string.link": {
    chrome: "5",
    opera: "15",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.4",
    deno: "1",
    android: "4",
    ios: "7",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.14",
    opera_mobile: "14",
    electron: "0.20"
  },
  "es7.string.pad-start": {
    chrome: "57",
    opera: "44",
    edge: "15",
    firefox: "48",
    safari: "10",
    node: "8",
    deno: "1",
    ios: "10",
    samsung: "7",
    rhino: "1.7.13",
    opera_mobile: "43",
    electron: "1.7"
  },
  "es7.string.pad-end": {
    chrome: "57",
    opera: "44",
    edge: "15",
    firefox: "48",
    safari: "10",
    node: "8",
    deno: "1",
    ios: "10",
    samsung: "7",
    rhino: "1.7.13",
    opera_mobile: "43",
    electron: "1.7"
  },
  "es6.string.raw": {
    chrome: "41",
    opera: "28",
    edge: "12",
    firefox: "34",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "3.4",
    rhino: "1.7.14",
    opera_mobile: "28",
    electron: "0.21"
  },
  "es6.string.repeat": {
    chrome: "41",
    opera: "28",
    edge: "12",
    firefox: "24",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "3.4",
    rhino: "1.7.13",
    opera_mobile: "28",
    electron: "0.21"
  },
  "es6.string.small": {
    chrome: "5",
    opera: "15",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.4",
    deno: "1",
    android: "4",
    ios: "7",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.14",
    opera_mobile: "14",
    electron: "0.20"
  },
  "es6.string.starts-with": {
    chrome: "41",
    opera: "28",
    edge: "12",
    firefox: "29",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "3.4",
    rhino: "1.7.13",
    opera_mobile: "28",
    electron: "0.21"
  },
  "es6.string.strike": {
    chrome: "5",
    opera: "15",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.4",
    deno: "1",
    android: "4",
    ios: "7",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.14",
    opera_mobile: "14",
    electron: "0.20"
  },
  "es6.string.sub": {
    chrome: "5",
    opera: "15",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.4",
    deno: "1",
    android: "4",
    ios: "7",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.14",
    opera_mobile: "14",
    electron: "0.20"
  },
  "es6.string.sup": {
    chrome: "5",
    opera: "15",
    edge: "12",
    firefox: "17",
    safari: "6",
    node: "0.4",
    deno: "1",
    android: "4",
    ios: "7",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.14",
    opera_mobile: "14",
    electron: "0.20"
  },
  "es6.string.trim": {
    chrome: "5",
    opera: "10.50",
    edge: "12",
    firefox: "3.5",
    safari: "4",
    node: "0.4",
    deno: "1",
    ie: "9",
    android: "4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    opera_mobile: "10.1",
    electron: "0.20"
  },
  "es7.string.trim-left": {
    chrome: "66",
    opera: "53",
    edge: "79",
    firefox: "61",
    safari: "12",
    node: "10",
    deno: "1",
    ios: "12",
    samsung: "9",
    rhino: "1.7.13",
    opera_mobile: "47",
    electron: "3.0"
  },
  "es7.string.trim-right": {
    chrome: "66",
    opera: "53",
    edge: "79",
    firefox: "61",
    safari: "12",
    node: "10",
    deno: "1",
    ios: "12",
    samsung: "9",
    rhino: "1.7.13",
    opera_mobile: "47",
    electron: "3.0"
  },
  "es6.typed.array-buffer": {
    chrome: "51",
    opera: "38",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "es6.typed.data-view": {
    chrome: "5",
    opera: "12",
    edge: "12",
    firefox: "15",
    safari: "5.1",
    node: "0.4",
    deno: "1",
    ie: "10",
    android: "4",
    ios: "6",
    phantom: "1.9",
    samsung: "1",
    rhino: "1.7.13",
    opera_mobile: "12",
    electron: "0.20"
  },
  "es6.typed.int8-array": {
    chrome: "51",
    opera: "38",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "es6.typed.uint8-array": {
    chrome: "51",
    opera: "38",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "es6.typed.uint8-clamped-array": {
    chrome: "51",
    opera: "38",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "es6.typed.int16-array": {
    chrome: "51",
    opera: "38",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "es6.typed.uint16-array": {
    chrome: "51",
    opera: "38",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "es6.typed.int32-array": {
    chrome: "51",
    opera: "38",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "es6.typed.uint32-array": {
    chrome: "51",
    opera: "38",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "es6.typed.float32-array": {
    chrome: "51",
    opera: "38",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "es6.typed.float64-array": {
    chrome: "51",
    opera: "38",
    edge: "13",
    firefox: "48",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "es6.weak-map": {
    chrome: "51",
    opera: "38",
    edge: "15",
    firefox: "53",
    safari: "9",
    node: "6.5",
    deno: "1",
    ios: "9",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "es6.weak-set": {
    chrome: "51",
    opera: "38",
    edge: "15",
    firefox: "53",
    safari: "9",
    node: "6.5",
    deno: "1",
    ios: "9",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  }
};

var corejs2BuiltIns = require$$0$4;

const {
  isObjectProperty: isObjectProperty$1,
  isArrayPattern,
  isObjectPattern,
  isAssignmentPattern: isAssignmentPattern$1,
  isRestElement,
  isIdentifier: isIdentifier$3
} = t$5;
function shouldStoreRHSInTemporaryVariable(node) {
  if (isArrayPattern(node)) {
    const nonNullElements = node.elements.filter(element => element !== null);
    return nonNullElements.length > 1 || shouldStoreRHSInTemporaryVariable(nonNullElements[0]);
  }
  if (isObjectPattern(node)) {
    const { properties } = node;
    if (properties.length > 1) return true;
    if (properties.length === 0) return false;

    const firstProperty = properties[0];
    return isObjectProperty$1(firstProperty)
      ? shouldStoreRHSInTemporaryVariable(firstProperty.value)
      : shouldStoreRHSInTemporaryVariable(firstProperty);
  }
  return isAssignmentPattern$1(node)
    ? shouldStoreRHSInTemporaryVariable(node.left)
    : !!isRestElement(node) && (!!isIdentifier$3(node.argument) || shouldStoreRHSInTemporaryVariable(node.argument));
}

const { isAssignmentPattern, isObjectProperty } = t$5;
{
  const node = t$5.identifier("a"),
    property = t$5.objectProperty(t$5.identifier("key"), node),
    pattern = t$5.objectPattern([property]);
  var ZERO_REFS = t$5.isReferenced(node, property, pattern) ? 1 : 0;
}
var proposalObjectRestSpread = declare((api, opts) => {
  var _api$assumption, _api$assumption2, _api$assumption3, _api$assumption4;
  api.assertVersion(7);
  const supportsObjectAssign = !isRequired("es6.object.assign", api.targets(), { compatData: corejs2BuiltIns }),
    { useBuiltIns = supportsObjectAssign, loose = false } = opts;
  if (typeof loose != "boolean") throw new Error(".loose must be a boolean, or undefined");

  const ignoreFunctionLength =
      (_api$assumption = api.assumption("ignoreFunctionLength")) != null ? _api$assumption : loose,
    objectRestNoSymbols = (_api$assumption2 = api.assumption("objectRestNoSymbols")) != null ? _api$assumption2 : loose,
    pureGetters = (_api$assumption3 = api.assumption("pureGetters")) != null ? _api$assumption3 : loose,
    setSpreadProperties = (_api$assumption4 = api.assumption("setSpreadProperties")) != null ? _api$assumption4 : loose;
  function getExtendsHelper(file) {
    return useBuiltIns
      ? t$5.memberExpression(t$5.identifier("Object"), t$5.identifier("assign"))
      : file.addHelper("extends");
  }
  function hasRestElement(path) {
    let foundRestElement = false;
    visitRestElements(path, restElement => {
      foundRestElement = true;
      restElement.stop();
    });
    return foundRestElement;
  }
  function hasObjectPatternRestElement(path) {
    let foundRestElement = false;
    visitRestElements(path, restElement => {
      if (restElement.parentPath.isObjectPattern()) {
        foundRestElement = true;
        restElement.stop();
      }
    });
    return foundRestElement;
  }
  function visitRestElements(path, visitor) {
    path.traverse({
      Expression(path) {
        const { parent, key } = path;
        ((isAssignmentPattern(parent) && key === "right") ||
          (isObjectProperty(parent) && parent.computed && key === "key")) &&
          path.skip();
      },
      RestElement: visitor
    });
  }
  function hasSpread(node) {
    for (const prop of node.properties) if (t$5.isSpreadElement(prop)) return true;

    return false;
  }
  function extractNormalizedKeys(node) {
    const props = node.properties,
      keys = [];
    let allLiteral = true,
      hasTemplateLiteral = false;
    for (const prop of props)
      if (t$5.isIdentifier(prop.key) && !prop.computed) keys.push(t$5.stringLiteral(prop.key.name));
      else if (t$5.isTemplateLiteral(prop.key)) {
        keys.push(t$5.cloneNode(prop.key));
        hasTemplateLiteral = true;
      } else if (t$5.isLiteral(prop.key)) keys.push(t$5.stringLiteral(String(prop.key.value)));
      else {
        keys.push(t$5.cloneNode(prop.key));
        allLiteral = false;
      }

    return { keys, allLiteral, hasTemplateLiteral };
  }
  function replaceImpureComputedKeys(properties, scope) {
    const impureComputedPropertyDeclarators = [];
    for (const propPath of properties) {
      const key = propPath.get("key");
      if (propPath.node.computed && !key.isPure()) {
        const name = scope.generateUidBasedOnNode(key.node),
          declarator = t$5.variableDeclarator(t$5.identifier(name), key.node);
        impureComputedPropertyDeclarators.push(declarator);
        key.replaceWith(t$5.identifier(name));
      }
    }
    return impureComputedPropertyDeclarators;
  }
  function removeUnusedExcludedKeys(path) {
    const bindings = path.getOuterBindingIdentifierPaths();
    Object.keys(bindings).forEach(bindingName => {
      const bindingParentPath = bindings[bindingName].parentPath;
      path.scope.getBinding(bindingName).references > ZERO_REFS || !bindingParentPath.isObjectProperty() ||
        bindingParentPath.remove();
    });
  }
  function createObjectRest(path, file, objRef) {
    const props = path.get("properties"),
      last = props[props.length - 1];
    t$5.assertRestElement(last.node);
    const restElement = t$5.cloneNode(last.node);
    last.remove();
    const impureComputedPropertyDeclarators = replaceImpureComputedKeys(path.get("properties"), path.scope),
      { keys, allLiteral, hasTemplateLiteral } = extractNormalizedKeys(path.node);
    if (keys.length === 0)
      return [
        impureComputedPropertyDeclarators,
        restElement.argument,
        t$5.callExpression(getExtendsHelper(file), [
          t$5.objectExpression([]),
          t$5.sequenceExpression([
            t$5.callExpression(file.addHelper("objectDestructuringEmpty"), [t$5.cloneNode(objRef)]),
            t$5.cloneNode(objRef)
          ])
        ])
      ];

    let keyExpression;
    if (allLiteral) {
      keyExpression = t$5.arrayExpression(keys);
      if (!loose && !hasTemplateLiteral && !t$5.isProgram(path.scope.block)) {
        const program = path.findParent(path => path.isProgram()),
          id = path.scope.generateUidIdentifier("excluded");
        program.scope.push({ id, init: keyExpression, kind: "const" });
        keyExpression = t$5.cloneNode(id);
      }
    } else
      keyExpression = t$5.callExpression(t$5.memberExpression(t$5.arrayExpression(keys), t$5.identifier("map")), [
        file.addHelper("toPropertyKey")
      ]);

    return [
      impureComputedPropertyDeclarators,
      restElement.argument,
      t$5.callExpression(file.addHelper(`objectWithoutProperties${objectRestNoSymbols ? "Loose" : ""}`), [
        t$5.cloneNode(objRef), keyExpression
      ])
    ];
  }
  function replaceRestElement(parentPath, paramPath, container) {
    if (paramPath.isAssignmentPattern()) {
      replaceRestElement(parentPath, paramPath.get("left"), container);
      return;
    }
    if (paramPath.isArrayPattern() && hasRestElement(paramPath)) {
      const elements = paramPath.get("elements");
      for (let i = 0; i < elements.length; i++) replaceRestElement(parentPath, elements[i], container);
    }
    if (paramPath.isObjectPattern() && hasRestElement(paramPath)) {
      const uid = parentPath.scope.generateUidIdentifier("ref"),
        declar = t$5.variableDeclaration("let", [t$5.variableDeclarator(paramPath.node, uid)]);
      if (container) container.push(declar);
      else {
        parentPath.ensureBlock();
        parentPath.get("body").unshiftContainer("body", declar);
      }
      paramPath.replaceWith(t$5.cloneNode(uid));
    }
  }
  return {
    name: "transform-object-rest-spread",
    inherits: void 0,
    visitor: {
      Function(path) {
        const params = path.get("params"),
          paramsWithRestElement = new Set(),
          idsInRestParams = new Set();
        for (let i = 0; i < params.length; ++i) {
          const param = params[i];
          if (hasRestElement(param)) {
            paramsWithRestElement.add(i);
            for (const name of Object.keys(param.getBindingIdentifiers())) idsInRestParams.add(name);
          }
        }
        let idInRest = false;
        const IdentifierHandler = function (path, functionScope) {
          const name = path.node.name;
          if (path.scope.getBinding(name) === functionScope.getBinding(name) && idsInRestParams.has(name)) {
            idInRest = true;
            path.stop();
          }
        };
        let i;
        for (i = 0; i < params.length && !idInRest; ++i) {
          const param = params[i];
          paramsWithRestElement.has(i) ||
            (param.isReferencedIdentifier() || param.isBindingIdentifier()
              ? IdentifierHandler(param, path.scope)
              : param.traverse({
                  "Scope|TypeAnnotation|TSTypeAnnotation": path => path.skip(),
                  "ReferencedIdentifier|BindingIdentifier": IdentifierHandler
                }, path.scope));
        }
        if (!idInRest)
          for (let i = 0; i < params.length; ++i) {
            const param = params[i];
            paramsWithRestElement.has(i) && replaceRestElement(path, param);
          }
        else
          convertFunctionParams(
            path, ignoreFunctionLength, idx => idx >= i - 1 || paramsWithRestElement.has(idx), replaceRestElement
          );
      },
      VariableDeclarator(path, file) {
        if (!path.get("id").isObjectPattern()) return;

        let insertionPath = path;
        const originalPath = path;
        visitRestElements(path.get("id"), path => {
          if (!path.parentPath.isObjectPattern()) return;

          if (shouldStoreRHSInTemporaryVariable(originalPath.node.id) && !t$5.isIdentifier(originalPath.node.init)) {
            const initRef = path.scope.generateUidIdentifierBasedOnNode(originalPath.node.init, "ref");
            originalPath.insertBefore(t$5.variableDeclarator(initRef, originalPath.node.init));
            originalPath.replaceWith(t$5.variableDeclarator(originalPath.node.id, t$5.cloneNode(initRef)));
            return;
          }
          let ref = originalPath.node.init;
          const refPropertyPath = [];
          let kind;
          path.findParent(path => {
            if (path.isObjectProperty()) refPropertyPath.unshift(path);
            else if (path.isVariableDeclarator()) {
              kind = path.parentPath.node.kind;
              return true;
            }
          });
          const impureObjRefComputedDeclarators = replaceImpureComputedKeys(refPropertyPath, path.scope);
          refPropertyPath.forEach(prop => {
            const { node } = prop;
            ref = t$5.memberExpression(ref, t$5.cloneNode(node.key), node.computed || t$5.isLiteral(node.key));
          });
          const objectPatternPath = path.findParent(path => path.isObjectPattern());
          const [impureComputedPropertyDeclarators, argument, callExpression] = createObjectRest(
            objectPatternPath, file, ref
          );
          pureGetters && removeUnusedExcludedKeys(objectPatternPath);

          t$5.assertIdentifier(argument);
          insertionPath.insertBefore(impureComputedPropertyDeclarators);
          insertionPath.insertBefore(impureObjRefComputedDeclarators);
          insertionPath = insertionPath.insertAfter(t$5.variableDeclarator(argument, callExpression))[0];
          path.scope.registerBinding(kind, insertionPath);
          objectPatternPath.node.properties.length !== 0 ||
            objectPatternPath.findParent(path => path.isObjectProperty() || path.isVariableDeclarator()).remove();
        });
      },
      ExportNamedDeclaration(path) {
        const declaration = path.get("declaration");
        if (!declaration.isVariableDeclaration()) return;
        if (!declaration.get("declarations").some(path => hasObjectPatternRestElement(path.get("id")))) return;
        const specifiers = [];
        for (const name of Object.keys(path.getOuterBindingIdentifiers(true)))
          specifiers.push(t$5.exportSpecifier(t$5.identifier(name), t$5.identifier(name)));

        path.replaceWith(declaration.node);
        path.insertAfter(t$5.exportNamedDeclaration(null, specifiers));
      },
      CatchClause(path) {
        const paramPath = path.get("param");
        replaceRestElement(path, paramPath);
      },
      AssignmentExpression(path, file) {
        const leftPath = path.get("left");
        if (leftPath.isObjectPattern() && hasRestElement(leftPath)) {
          const nodes = [],
            refName = path.scope.generateUidBasedOnNode(path.node.right, "ref");
          nodes.push(t$5.variableDeclaration("var", [t$5.variableDeclarator(t$5.identifier(refName), path.node.right)]));
          const [impureComputedPropertyDeclarators, argument, callExpression] = createObjectRest(
            leftPath, file, t$5.identifier(refName)
          );
          impureComputedPropertyDeclarators.length > 0 &&
            nodes.push(t$5.variableDeclaration("var", impureComputedPropertyDeclarators));

          const nodeWithoutSpread = t$5.cloneNode(path.node);
          nodeWithoutSpread.right = t$5.identifier(refName);
          nodes.push(t$5.expressionStatement(nodeWithoutSpread));
          nodes.push(t$5.expressionStatement(t$5.assignmentExpression("=", argument, callExpression)));
          nodes.push(t$5.expressionStatement(t$5.identifier(refName)));
          path.replaceWithMultiple(nodes);
        }
      },
      ForXStatement(path) {
        const { node, scope } = path,
          leftPath = path.get("left"),
          left = node.left;
        if (!hasObjectPatternRestElement(leftPath)) return;

        if (!t$5.isVariableDeclaration(left)) {
          const temp = scope.generateUidIdentifier("ref");
          node.left = t$5.variableDeclaration("var", [t$5.variableDeclarator(temp)]);
          path.ensureBlock();
          const body = path.node.body;
          body.body.length === 0 && path.isCompletionRecord() &&
            body.body.unshift(t$5.expressionStatement(scope.buildUndefinedNode()));

          body.body.unshift(t$5.expressionStatement(t$5.assignmentExpression("=", left, t$5.cloneNode(temp))));
        } else {
          const pattern = left.declarations[0].id,
            key = scope.generateUidIdentifier("ref");
          node.left = t$5.variableDeclaration(left.kind, [t$5.variableDeclarator(key, null)]);
          path.ensureBlock();
          node.body.body.unshift(
            t$5.variableDeclaration(node.left.kind, [t$5.variableDeclarator(pattern, t$5.cloneNode(key))])
          );
        }
      },
      ArrayPattern(path) {
        const objectPatterns = [];
        visitRestElements(path, path => {
          if (!path.parentPath.isObjectPattern()) return;

          const objectPattern = path.parentPath,
            uid = path.scope.generateUidIdentifier("ref");
          objectPatterns.push(t$5.variableDeclarator(objectPattern.node, uid));
          objectPattern.replaceWith(t$5.cloneNode(uid));
          path.skip();
        });
        if (objectPatterns.length > 0) {
          const statementPath = path.getStatementParent(),
            statementNode = statementPath.node,
            kind = statementNode.type === "VariableDeclaration" ? statementNode.kind : "var";
          statementPath.insertAfter(t$5.variableDeclaration(kind, objectPatterns));
        }
      },
      ObjectExpression(path, file) {
        if (!hasSpread(path.node)) return;
        let helper;
        if (setSpreadProperties) helper = getExtendsHelper(file);
        else
          try {
            helper = file.addHelper("objectSpread2");
          } catch (_unused) {
            this.file.declarations.objectSpread2 = null;
            helper = file.addHelper("objectSpread");
          }

        let exp = null,
          props = [];
        function make() {
          const hadProps = props.length > 0,
            obj = t$5.objectExpression(props);
          props = [];
          !exp
            ? (exp = t$5.callExpression(helper, [obj]))
            : pureGetters
            ? hadProps && exp.arguments.push(obj)
            : (exp = t$5.callExpression(t$5.cloneNode(helper), [
                exp, ...(hadProps ? [t$5.objectExpression([]), obj] : [])
              ]));
        }
        for (const prop of path.node.properties)
          if (t$5.isSpreadElement(prop)) {
            make();
            exp.arguments.push(prop.argument);
          } else props.push(prop);

        props.length && make();
        path.replaceWith(exp);
      }
    }
  };
});

var proposalOptionalCatchBinding = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-optional-catch-binding",
    inherits: void 0,
    visitor: {
      CatchClause(path) {
        if (!path.node.param) {
          const uid = path.scope.generateUidIdentifier("unused");
          path.get("param").replaceWith(uid);
        }
      }
    }
  };
});

function willPathCastToBoolean(path) {
  const maybeWrapped = findOutermostTransparentParent(path),
    { node, parentPath } = maybeWrapped;
  if (parentPath.isLogicalExpression()) {
    const { operator, right } = parentPath.node;
    if (operator === "&&" || operator === "||" || (operator === "??" && node === right))
      return willPathCastToBoolean(parentPath);
  }
  if (parentPath.isSequenceExpression()) {
    const { expressions } = parentPath.node;
    return expressions[expressions.length - 1] !== node || willPathCastToBoolean(parentPath);
  }
  return (
    parentPath.isConditional({ test: node }) ||
    parentPath.isUnaryExpression({ operator: "!" }) ||
    parentPath.isLoop({ test: node })
  );
}
function findOutermostTransparentParent(path) {
  let maybeWrapped = path;
  path.findParent(p => {
    if (!isTransparentExprWrapper(p.node)) return true;
    maybeWrapped = p;
  });
  return maybeWrapped;
}

const last = arr => arr[arr.length - 1];
function isSimpleMemberExpression(expression) {
  expression = skipTransparentExprWrapperNodes(expression);
  return (
    t$5.isIdentifier(expression) || t$5.isSuper(expression) ||
    (t$5.isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object))
  );
}
function needsMemoize(path) {
  let optionalPath = path;
  const { scope } = path;
  while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {
    const { node } = optionalPath;
    const childPath = skipTransparentExprWrappers(
      optionalPath.isOptionalMemberExpression() ? optionalPath.get("object") : optionalPath.get("callee")
    );
    if (node.optional) return !scope.isStatic(childPath.node);

    optionalPath = childPath;
  }
}
const NULLISH_CHECK = template$1.expression("%%check%% === null || %%ref%% === void 0"),
  NULLISH_CHECK_NO_DDA = template$1.expression("%%check%% == null"),
  NULLISH_CHECK_NEG = template$1.expression("%%check%% !== null && %%ref%% !== void 0"),
  NULLISH_CHECK_NO_DDA_NEG = template$1.expression("%%check%% != null");
function transformOptionalChain(path, { pureGetters, noDocumentAll }, replacementPath, ifNullish, wrapLast) {
  const { scope } = path;
  if (scope.path.isPattern() && needsMemoize(path)) {
    replacementPath.replaceWith(template$1.expression.ast`(() => ${replacementPath.node})()`);
    return;
  }
  const optionals = [];
  let optionalPath = path;
  while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {
    const { node } = optionalPath;
    node.optional && optionals.push(node);

    if (optionalPath.isOptionalMemberExpression()) {
      optionalPath.node.type = "MemberExpression";
      optionalPath = skipTransparentExprWrappers(optionalPath.get("object"));
    } else if (optionalPath.isOptionalCallExpression()) {
      optionalPath.node.type = "CallExpression";
      optionalPath = skipTransparentExprWrappers(optionalPath.get("callee"));
    }
  }
  if (optionals.length === 0) return;

  const checks = [];
  for (let tmpVar, i = optionals.length - 1; i >= 0; i--) {
    const node = optionals[i],
      isCall = t$5.isCallExpression(node),
      chainWithTypes = isCall ? node.callee : node.object,
      chain = skipTransparentExprWrapperNodes(chainWithTypes);
    let ref, check;
    if (isCall && t$5.isIdentifier(chain, { name: "eval" })) {
      check = ref = chain;
      node.callee = t$5.sequenceExpression([t$5.numericLiteral(0), ref]);
    } else if (pureGetters && isCall && isSimpleMemberExpression(chain)) check = ref = node.callee;
    else if (scope.isStatic(chain)) check = ref = chainWithTypes;
    else {
      if (!tmpVar || isCall) {
        tmpVar = scope.generateUidIdentifierBasedOnNode(chain);
        scope.push({ id: t$5.cloneNode(tmpVar) });
      }
      ref = tmpVar;
      check = t$5.assignmentExpression("=", t$5.cloneNode(tmpVar), chainWithTypes);
      isCall ? (node.callee = ref) : (node.object = ref);
    }
    if (isCall && t$5.isMemberExpression(chain))
      if (pureGetters && isSimpleMemberExpression(chain)) node.callee = chainWithTypes;
      else {
        const { object } = chain;
        let context;
        if (t$5.isSuper(object)) context = t$5.thisExpression();
        else {
          const memoized = scope.maybeGenerateMemoised(object);
          if (memoized) {
            context = memoized;
            chain.object = t$5.assignmentExpression("=", memoized, object);
          } else context = object;
        }
        node.arguments.unshift(t$5.cloneNode(context));
        node.callee = t$5.memberExpression(node.callee, t$5.identifier("call"));
      }

    const data = { check: t$5.cloneNode(check), ref: t$5.cloneNode(ref) };
    Object.defineProperty(data, "ref", { enumerable: false });
    checks.push(data);
  }
  let result = replacementPath.node;
  if (wrapLast) result = wrapLast(result);
  const ifNullishBoolean = t$5.isBooleanLiteral(ifNullish),
    ifNullishFalse = ifNullishBoolean && ifNullish.value === false,
    ifNullishVoid = !ifNullishBoolean && t$5.isUnaryExpression(ifNullish, { operator: "void" });
  const isEvaluationValueIgnored =
    (t$5.isExpressionStatement(replacementPath.parent) && !replacementPath.isCompletionRecord()) ||
    (t$5.isSequenceExpression(replacementPath.parent) &&
      last(replacementPath.parent.expressions) !== replacementPath.node);
  const tpl = ifNullishFalse
    ? (noDocumentAll ? NULLISH_CHECK_NO_DDA_NEG : NULLISH_CHECK_NEG)
    : noDocumentAll ? NULLISH_CHECK_NO_DDA : NULLISH_CHECK;
  const logicalOp = ifNullishFalse ? "&&" : "||",
    check = checks.map(tpl).reduce((expr, check) => t$5.logicalExpression(logicalOp, expr, check));
  replacementPath.replaceWith(
    ifNullishBoolean || (ifNullishVoid && isEvaluationValueIgnored)
      ? t$5.logicalExpression(logicalOp, check, result)
      : t$5.conditionalExpression(check, ifNullish, result)
  );
}
function transform$1(path, assumptions) {
  const { scope } = path,
    maybeWrapped = findOutermostTransparentParent(path),
    { parentPath } = maybeWrapped;
  if (parentPath.isUnaryExpression({ operator: "delete" }))
    transformOptionalChain(path, assumptions, parentPath, t$5.booleanLiteral(true));
  else {
    let wrapLast;
    if (parentPath.isCallExpression({ callee: maybeWrapped.node }) && path.isOptionalMemberExpression())
      wrapLast = replacement => {
        var _baseRef;
        const object = skipTransparentExprWrapperNodes(replacement.object);
        let baseRef;
        if (!assumptions.pureGetters || !isSimpleMemberExpression(object)) {
          baseRef = scope.maybeGenerateMemoised(object);
          if (baseRef) replacement.object = t$5.assignmentExpression("=", baseRef, object);
        }
        return t$5.callExpression(t$5.memberExpression(replacement, t$5.identifier("bind")), [
          t$5.cloneNode((_baseRef = baseRef) != null ? _baseRef : object)
        ]);
      };

    transformOptionalChain(
      path, assumptions, path,
      willPathCastToBoolean(maybeWrapped) ? t$5.booleanLiteral(false) : scope.buildUndefinedNode(),
      wrapLast
    );
  }
}

var proposalOptionalChaining = declare((api, options) => {
  var _api$assumption, _api$assumption2;
  api.assertVersion(7);
  const { loose = false } = options,
    noDocumentAll = (_api$assumption = api.assumption("noDocumentAll")) != null ? _api$assumption : loose,
    pureGetters = (_api$assumption2 = api.assumption("pureGetters")) != null ? _api$assumption2 : loose;
  return {
    name: "transform-optional-chaining",
    inherits: void 0,
    visitor: {
      "OptionalCallExpression|OptionalMemberExpression"(path) {
        transform$1(path, { noDocumentAll, pureGetters });
      }
    }
  };
});

function isConciseArrowExpression(node) {
  return t$5.isArrowFunctionExpression(node) && t$5.isExpression(node.body) && !node.async;
}
const buildOptimizedSequenceExpression = ({ call, path, placeholder }) => {
  const { callee: calledExpression } = call,
    pipelineLeft = path.node.left,
    assign = t$5.assignmentExpression("=", t$5.cloneNode(placeholder), pipelineLeft);
  if (isConciseArrowExpression(calledExpression)) {
    let param,
      optimizeArrow = true;
    const { params } = calledExpression;
    if (params.length === 1 && t$5.isIdentifier(params[0])) param = params[0];
    else if (params.length > 0) optimizeArrow = false;

    if (optimizeArrow && !param) return t$5.sequenceExpression([pipelineLeft, calledExpression.body]);
    if (param) {
      path.scope.push({ id: t$5.cloneNode(placeholder) });
      path.get("right").scope.rename(param.name, placeholder.name);
      return t$5.sequenceExpression([assign, calledExpression.body]);
    }
  } else if (t$5.isIdentifier(calledExpression, { name: "eval" })) {
    const evalSequence = t$5.sequenceExpression([t$5.numericLiteral(0), calledExpression]);
    call.callee = evalSequence;
  }
  path.scope.push({ id: t$5.cloneNode(placeholder) });
  return t$5.sequenceExpression([assign, call]);
};

const minimalVisitor = {
  BinaryExpression(path) {
    const { scope, node } = path,
      { operator, left, right } = node;
    if (operator !== "|>") return;
    const placeholder = scope.generateUidIdentifierBasedOnNode(left),
      call = t$5.callExpression(right, [t$5.cloneNode(placeholder)]);
    path.replaceWith(buildOptimizedSequenceExpression({ placeholder, call, path }));
  }
};

const topicReferenceVisitor = {
  exit(path, state) {
    path.isTopicReference()
      ? state.topicReferences.push(path)
      : state.topicReferences.length !== 0 || state.sideEffectsBeforeFirstTopicReference || path.isPure() ||
        (state.sideEffectsBeforeFirstTopicReference = true);
  },
  "ClassBody|Function"(_, state) {
    if (state.topicReferences.length === 0) state.sideEffectsBeforeFirstTopicReference = true;
  }
};
const visitor$1 = {
  BinaryExpression: {
    exit(path) {
      const { scope, node } = path;
      if (node.operator !== "|>") return;

      const pipeBodyPath = path.get("right");
      if (pipeBodyPath.node.type === "TopicReference") {
        path.replaceWith(node.left);
        return;
      }
      const visitorState = { topicReferences: [], sideEffectsBeforeFirstTopicReference: pipeBodyPath.isFunction() };
      pipeBodyPath.traverse(topicReferenceVisitor, visitorState);
      if (
        visitorState.topicReferences.length === 1 &&
        (!visitorState.sideEffectsBeforeFirstTopicReference || path.scope.isPure(node.left, true))
      ) {
        visitorState.topicReferences[0].replaceWith(node.left);
        path.replaceWith(node.right);
        return;
      }
      const topicVariable = scope.generateUidIdentifierBasedOnNode(node);
      scope.push({ id: topicVariable });
      visitorState.topicReferences.forEach(path => path.replaceWith(t$5.cloneNode(topicVariable)));
      path.replaceWith(
        t$5.sequenceExpression([t$5.assignmentExpression("=", t$5.cloneNode(topicVariable), node.left), node.right])
      );
    }
  }
};

const fsharpVisitor = {
  BinaryExpression(path) {
    const { scope, node } = path,
      { operator, left, right } = node;
    if (operator !== "|>") return;
    const placeholder = scope.generateUidIdentifierBasedOnNode(left);
    const call = right.type === "AwaitExpression"
      ? t$5.awaitExpression(t$5.cloneNode(placeholder))
      : t$5.callExpression(right, [t$5.cloneNode(placeholder)]);
    const sequence = buildOptimizedSequenceExpression({ placeholder, call, path });
    path.replaceWith(sequence);
  }
};

const updateTopicReferenceVisitor = {
  PipelinePrimaryTopicReference(path) {
    path.replaceWith(t$5.cloneNode(this.topicId));
  },
  PipelineTopicExpression(path) {
    path.skip();
  }
};
const smartVisitor = {
  BinaryExpression(path) {
    const { scope } = path,
      { node } = path,
      { operator, left, right } = node;
    if (operator !== "|>") return;
    const placeholder = scope.generateUidIdentifierBasedOnNode(left);
    scope.push({ id: placeholder });
    let call;
    if (t$5.isPipelineTopicExpression(right)) {
      path.get("right").traverse(updateTopicReferenceVisitor, { topicId: placeholder });
      call = right.expression;
    } else {
      let callee = right.callee;
      if (t$5.isIdentifier(callee, { name: "eval" }))
        callee = t$5.sequenceExpression([t$5.numericLiteral(0), callee]);

      call = t$5.callExpression(callee, [t$5.cloneNode(placeholder)]);
    }
    path.replaceWith(t$5.sequenceExpression([t$5.assignmentExpression("=", t$5.cloneNode(placeholder), left), call]));
  }
};

const visitorsPerProposal = {
  minimal: minimalVisitor,
  hack: visitor$1,
  fsharp: fsharpVisitor,
  smart: smartVisitor
};
var proposalPipelineOperator = declare((api, options) => {
  api.assertVersion(7);
  const { proposal } = options;
  proposal !== "smart" || console.warn('The smart-mix pipe operator is deprecated. Use "proposal": "hack" instead.');

  return {
    name: "proposal-pipeline-operator",
    inherits: syntaxPipelineOperator,
    visitor: visitorsPerProposal[options.proposal]
  };
});

var proposalPrivateMethods = declare((api, options) => {
  api.assertVersion(7);
  return createClassFeaturePlugin({
    name: "transform-private-methods",
    api,
    feature: FEATURES$1.privateMethods,
    loose: options.loose,
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("classPrivateMethods");
    }
  });
});

var proposalPrivatePropertyInObject = declare((api, opt) => {
  api.assertVersion(7);
  const { types: t, template } = api,
    { loose } = opt,
    classWeakSets = new WeakMap(),
    fieldsWeakSets = new WeakMap();
  function unshadow(name, targetScope, scope) {
    while (scope !== targetScope) {
      scope.hasOwnBinding(name) && scope.rename(name);
      scope = scope.parent;
    }
  }
  function injectToFieldInit(fieldPath, expr, before = false) {
    if (fieldPath.node.value) {
      const value = fieldPath.get("value");
      before ? value.insertBefore(expr) : value.insertAfter(expr);
    } else fieldPath.set("value", t.unaryExpression("void", expr));
  }
  function injectInitialization$1(classPath, init) {
    let firstFieldPath, constructorPath;
    for (const el of classPath.get("body.body")) {
      if ((el.isClassProperty() || el.isClassPrivateProperty()) && !el.node.static) {
        firstFieldPath = el;
        break;
      }
      if (!constructorPath && el.isClassMethod({ kind: "constructor" })) constructorPath = el;
    }
    firstFieldPath
      ? injectToFieldInit(firstFieldPath, init, true)
      : injectInitialization(classPath, constructorPath, [t.expressionStatement(init)]);
  }
  function getWeakSetId(weakSets, outerClass, reference, name = "", inject) {
    let id = weakSets.get(reference.node);
    if (!id) {
      id = outerClass.scope.generateUidIdentifier(`${name || ""} brandCheck`);
      weakSets.set(reference.node, id);
      inject(reference, template.expression.ast`${t.cloneNode(id)}.add(this)`);
      const newExpr = t.newExpression(t.identifier("WeakSet"), []);
      annotateAsPure(newExpr);
      outerClass.insertBefore(template.ast`var ${id} = ${newExpr}`);
    }
    return t.cloneNode(id);
  }
  return {
    name: "transform-private-property-in-object",
    inherits: void 0,
    pre() {
      enableFeature$1(this.file, FEATURES$1.privateIn, loose);
    },
    visitor: {
      BinaryExpression(path, state) {
        const { node } = path,
          { file } = state;
        if (node.operator !== "in" || !t.isPrivateName(node.left)) return;
        const { name } = node.left.id;
        let privateElement;
        const outerClass = path.findParent(path => {
          if (!path.isClass()) return false;
          privateElement = path.get("body.body").find(({ node }) => t.isPrivate(node) && node.key.id.name === name);
          return !!privateElement;
        });
        if (outerClass.parentPath.scope.path.isPattern())
          outerClass.replaceWith(template.ast`(() => ${outerClass.node})()`);
        else if (privateElement.node.type === "ClassPrivateMethod")
          if (privateElement.node.static) {
            outerClass.node.id
              ? unshadow(outerClass.node.id.name, outerClass.scope, path.scope)
              : outerClass.set("id", path.scope.generateUidIdentifier("class"));

            path.replaceWith(template.expression.ast`
                ${t.cloneNode(outerClass.node.id)} === ${buildCheckInRHS(node.right, file)}
              `);
          } else {
            var _outerClass$node$id;
            const id = getWeakSetId(
              classWeakSets, outerClass, outerClass,
              (_outerClass$node$id = outerClass.node.id) == null ? void 0 : _outerClass$node$id.name,
              injectInitialization$1
            );
            path.replaceWith(template.expression.ast`${id}.has(${buildCheckInRHS(node.right, file)})`);
          }
        else {
          const id = getWeakSetId(
            fieldsWeakSets, outerClass, privateElement, privateElement.node.key.id.name, injectToFieldInit
          );
          path.replaceWith(template.expression.ast`${id}.has(${buildCheckInRHS(node.right, file)})`);
        }
      }
    }
  };
});

const v$1 = new OptionValidator("@babel/plugin-proposal-record-and-tuple");
var proposalRecordAndTuple = declare((api, options) => {
  api.assertVersion(7);
  const polyfillModuleName = v$1.validateStringOption(
    "polyfillModuleName", options.polyfillModuleName, "@bloomberg/record-tuple-polyfill"
  );
  const shouldImportPolyfill = v$1.validateBooleanOption(
    "importPolyfill", options.importPolyfill, !!options.polyfillModuleName
  );
  const importCaches = new WeakMap();
  function getOr(map, key, getDefault) {
    let value = map.get(key);
    value || map.set(key, (value = getDefault()));
    return value;
  }
  function getBuiltIn(name, programPath) {
    if (!shouldImportPolyfill) return t$5.identifier(name);
    if (!programPath) throw new Error("Internal error: unable to find the Program node.");

    const cacheKey = `${name}:${isModule(programPath)}`,
      cache = getOr(importCaches, programPath.node, () => new Map());
    const localBindingName = getOr(cache, cacheKey, () =>
      addNamed(programPath, name, polyfillModuleName, { importedInterop: "uncompiled" }).name
    );
    return t$5.identifier(localBindingName);
  }
  return {
    name: "proposal-record-and-tuple",
    inherits: syntaxRecordAndTuple,
    visitor: {
      Program(path, state) {
        state.programPath = path;
      },
      RecordExpression(path, state) {
        const record = getBuiltIn("Record", state.programPath),
          object = t$5.objectExpression(path.node.properties),
          wrapped = t$5.callExpression(record, [object]);
        path.replaceWith(wrapped);
      },
      TupleExpression(path, state) {
        const tuple = getBuiltIn("Tuple", state.programPath),
          wrapped = t$5.callExpression(tuple, path.node.elements);
        path.replaceWith(wrapped);
      }
    }
  };
});

var proposalRegexpModifiers = declare(api => {
  api.assertVersion("^7.19.0");
  return createRegExpFeaturePlugin({ name: "proposal-regexp-modifiers", feature: "modifiers" });
});

var syntaxThrowExpressions = declare(api => {
  api.assertVersion(7);
  return {
    name: "syntax-throw-expressions",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("throwExpressions");
    }
  };
});

var proposalThrowExpressions = declare(api => {
  api.assertVersion(7);
  return {
    name: "proposal-throw-expressions",
    inherits: syntaxThrowExpressions,
    visitor: {
      UnaryExpression(path) {
        const { operator, argument } = path.node;
        if (operator !== "throw") return;
        const arrow = t$5.functionExpression(
          null, [t$5.identifier("e")], t$5.blockStatement([t$5.throwStatement(t$5.identifier("e"))])
        );
        path.replaceWith(t$5.callExpression(arrow, [argument]));
      }
    }
  };
});

var proposalUnicodePropertyRegex = declare((api, options) => {
  api.assertVersion(7);
  const { useUnicodeFlag = true } = options;
  if (typeof useUnicodeFlag != "boolean") throw new Error(".useUnicodeFlag must be a boolean, or undefined");

  return createRegExpFeaturePlugin({
    name: "transform-unicode-property-regex",
    feature: "unicodePropertyEscape",
    options: { useUnicodeFlag }
  });
});

var transformUnicodeSetsRegex = declare(api => {
  api.assertVersion(7);
  return createRegExpFeaturePlugin({
    name: "transform-unicode-sets-regex",
    feature: "unicodeSetsFlag",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("regexpUnicodeSets");
    }
  });
});

var transformAsyncToGenerator = declare((api, options) => {
  var _api$assumption, _api$assumption2;
  api.assertVersion(7);
  const { method, module, loose = false } = options,
    noNewArrows = (_api$assumption = api.assumption("noNewArrows")) == null || _api$assumption,
    ignoreFunctionLength =
      (_api$assumption2 = api.assumption("ignoreFunctionLength")) != null ? _api$assumption2 : loose;

  return method && module ? {
    name: "transform-async-to-generator",
    visitor: {
      Function(path, state) {
        if (!path.node.async || path.node.generator) return;
        let wrapAsync = state.methodWrapper;
        wrapAsync = wrapAsync ? t$5.cloneNode(wrapAsync) : (state.methodWrapper = addNamed(path, method, module));

        remapAsyncToGenerator(path, { wrapAsync }, noNewArrows, ignoreFunctionLength, loose);
      }
    }
  } : {
    name: "transform-async-to-generator",
    visitor: {
      Function(path, state) {
        !path.node.async || path.node.generator ||
          remapAsyncToGenerator(
            path, { wrapAsync: state.addHelper("asyncToGenerator") }, noNewArrows, ignoreFunctionLength, loose
          );
      }
    }
  };
});

var transformArrowFunctions = declare((api, options) => {
  var _api$assumption;
  api.assertVersion(7);
  const noNewArrows = (_api$assumption = api.assumption("noNewArrows")) != null ? _api$assumption : !options.spec;
  return {
    name: "transform-arrow-functions",
    visitor: {
      ArrowFunctionExpression(path) {
        path.isArrowFunctionExpression() &&
          path.arrowFunctionToExpression({ allowInsertArrow: false, noNewArrows, specCompliant: !noNewArrows });
      }
    }
  };
});

var transformBlockScopedFunctions = declare(api => {
  api.assertVersion(7);
  function transformStatementList(paths) {
    for (const path of paths) {
      if (!path.isFunctionDeclaration()) continue;
      const func = path.node,
        declar = t$5.variableDeclaration("let", [t$5.variableDeclarator(func.id, t$5.toExpression(func))]);
      declar._blockHoist = 2;
      func.id = null;
      path.replaceWith(declar);
    }
  }
  return {
    name: "transform-block-scoped-functions",
    visitor: {
      BlockStatement(path) {
        const { node, parent } = path;
        t$5.isFunction(parent, { body: node }) || t$5.isExportDeclaration(parent) ||
          transformStatementList(path.get("body"));
      },
      SwitchCase(path) {
        transformStatementList(path.get("consequent"));
      }
    }
  };
});

const collectLoopBodyBindingsVisitor = {
  "Expression|Declaration|Loop"(path) {
    path.skip();
  },
  Scope(path, state) {
    path.isFunctionParent() && path.skip();
    const { bindings } = path.scope;
    for (const name of Object.keys(bindings)) {
      const binding = bindings[name];
      (binding.kind !== "let" && binding.kind !== "const" && binding.kind !== "hoisted") ||
        state.blockScoped.push(binding);
    }
  }
};
function getLoopBodyBindings(loopPath) {
  const state = { blockScoped: [] };
  loopPath.traverse(collectLoopBodyBindingsVisitor, state);
  return state.blockScoped;
}
function getUsageInBody(binding, loopPath) {
  const seen = new WeakSet();
  let capturedInClosure = false;
  const constantViolations = filterMap(binding.constantViolations, path => {
    const { inBody, inClosure } = relativeLoopLocation(path, loopPath);
    if (!inBody) return null;
    capturedInClosure || (capturedInClosure = inClosure);
    const id = path.isUpdateExpression() ? path.get("argument")
      : path.isAssignmentExpression() ? path.get("left") : null;
    id && seen.add(id.node);
    return id;
  });
  const references = filterMap(binding.referencePaths, path => {
    if (seen.has(path.node)) return null;
    const { inBody, inClosure } = relativeLoopLocation(path, loopPath);
    if (!inBody) return null;
    capturedInClosure || (capturedInClosure = inClosure);
    return path;
  });
  return {
    capturedInClosure,
    hasConstantViolations: constantViolations.length > 0,
    usages: references.concat(constantViolations)
  };
}
function relativeLoopLocation(path, loopPath) {
  const bodyPath = loopPath.get("body");
  for (let inClosure = false, currPath = path; currPath; currPath = currPath.parentPath) {
    if (currPath.isFunction() || currPath.isClass()) inClosure = true;
    if (currPath === bodyPath) return { inBody: true, inClosure };
    if (currPath === loopPath) return { inBody: false, inClosure };
  }
  throw new Error("Internal Babel error: path is not in loop. Please report this as a bug.");
}
const collectCompletionsAndVarsVisitor = {
  Function(path) {
    path.skip();
  },
  LabeledStatement: {
    enter({ node }, state) {
      state.labelsStack.push(node.label.name);
    },
    exit({ node }, state) {
      if (state.labelsStack.pop() !== node.label.name)
        throw new Error("Assertion failure. Please report this bug to Babel.");
    }
  },
  Loop: {
    enter(_, state) {
      state.labellessContinueTargets++;
      state.labellessBreakTargets++;
    },
    exit(_, state) {
      state.labellessContinueTargets--;
      state.labellessBreakTargets--;
    }
  },
  SwitchStatement: {
    enter(_, state) {
      state.labellessBreakTargets++;
    },
    exit(_, state) {
      state.labellessBreakTargets--;
    }
  },
  "BreakStatement|ContinueStatement"(path, state) {
    const { label } = path.node;
    if (label) {
      if (state.labelsStack.includes(label.name)) return;
    } else if (path.isBreakStatement() ? state.labellessBreakTargets > 0 : state.labellessContinueTargets > 0)
      return;

    state.breaksContinues.push(path);
  },
  ReturnStatement(path, state) {
    state.returns.push(path);
  },
  VariableDeclaration(path, state) {
    (path.parent === state.loopNode && isVarInLoopHead(path)) || path.node.kind !== "var" || state.vars.push(path);
  }
};
function wrapLoopBody(loopPath, captured, updatedBindingsUsages) {
  const loopNode = loopPath.node;
  const state = {
    breaksContinues: [],
    returns: [],
    labelsStack: [],
    labellessBreakTargets: 0,
    labellessContinueTargets: 0,
    vars: [],
    loopNode
  };
  loopPath.traverse(collectCompletionsAndVarsVisitor, state);
  const callArgs = [],
    closureParams = [],
    updater = [];
  for (const [name, updatedUsage] of updatedBindingsUsages) {
    callArgs.push(t$5.identifier(name));
    const innerName = loopPath.scope.generateUid(name);
    closureParams.push(t$5.identifier(innerName));
    updater.push(t$5.assignmentExpression("=", t$5.identifier(name), t$5.identifier(innerName)));
    for (const path of updatedUsage) path.replaceWith(t$5.identifier(innerName));
  }
  for (const name of captured)
    if (!updatedBindingsUsages.has(name)) {
      callArgs.push(t$5.identifier(name));
      closureParams.push(t$5.identifier(name));
    }
  const id = loopPath.scope.generateUid("loop"),
    fn = t$5.functionExpression(null, closureParams, t$5.toBlock(loopNode.body));
  let call = t$5.callExpression(t$5.identifier(id), callArgs);
  const fnParent = loopPath.findParent(p => p.isFunction());
  if (fnParent) {
    const { async, generator } = fnParent.node;
    fn.async = async;
    fn.generator = generator;
    if (generator) call = t$5.yieldExpression(call, true);
    else if (async) call = t$5.awaitExpression(call);
  }
  const updaterNode = updater.length > 0 ? t$5.expressionStatement(t$5.sequenceExpression(updater)) : null;
  updaterNode && fn.body.body.push(updaterNode);
  const [varPath] = loopPath.insertBefore(
    t$5.variableDeclaration("var", [t$5.variableDeclarator(t$5.identifier(id), fn)])
  );
  const bodyStmts = [],
    varNames = [];
  for (const varPath of state.vars) {
    const assign = [];
    for (const decl of varPath.node.declarations) {
      varNames.push(...Object.keys(t$5.getBindingIdentifiers(decl.id)));
      decl.init && assign.push(t$5.assignmentExpression("=", decl.id, decl.init));
    }
    if (assign.length > 0) {
      let replacement = assign.length === 1 ? assign[0] : t$5.sequenceExpression(assign);
      t$5.isForStatement(varPath.parent, { init: varPath.node }) ||
        t$5.isForXStatement(varPath.parent, { left: varPath.node }) ||
        (replacement = t$5.expressionStatement(replacement));

      varPath.replaceWith(replacement);
    } else varPath.remove();
  }
  varNames.length &&
    varPath.pushContainer("declarations", varNames.map(name => t$5.variableDeclarator(t$5.identifier(name))));

  const labelNum = state.breaksContinues.length,
    returnNum = state.returns.length;
  if (labelNum + returnNum === 0) bodyStmts.push(t$5.expressionStatement(call));
  else if (labelNum === 1 && returnNum === 0)
    for (const path of state.breaksContinues) {
      const { node } = path,
        { type, label } = node;
      let name = type === "BreakStatement" ? "break" : "continue";
      if (label) name += " " + label.name;
      path.replaceWith(t$5.addComment(t$5.returnStatement(t$5.numericLiteral(1)), "trailing", " " + name, true));
      updaterNode && path.insertBefore(t$5.cloneNode(updaterNode));
      bodyStmts.push(template$1.statement.ast`
        if (${call}) ${node}
      `);
    }
  else {
    const completionId = loopPath.scope.generateUid("ret");
    if (varPath.isVariableDeclaration()) {
      varPath.pushContainer("declarations", [t$5.variableDeclarator(t$5.identifier(completionId))]);
      bodyStmts.push(t$5.expressionStatement(t$5.assignmentExpression("=", t$5.identifier(completionId), call)));
    } else
      bodyStmts.push(t$5.variableDeclaration("var", [t$5.variableDeclarator(t$5.identifier(completionId), call)]));

    const injected = [];
    for (const path of state.breaksContinues) {
      const { node } = path,
        { type, label } = node;
      let name = type === "BreakStatement" ? "break" : "continue";
      if (label) name += " " + label.name;
      let i = injected.indexOf(name);
      const hasInjected = i > -1;
      if (!hasInjected) {
        injected.push(name);
        i = injected.length - 1;
      }
      path.replaceWith(t$5.addComment(t$5.returnStatement(t$5.numericLiteral(i)), "trailing", " " + name, true));
      updaterNode && path.insertBefore(t$5.cloneNode(updaterNode));
      hasInjected ||
        bodyStmts.push(template$1.statement.ast`
        if (${t$5.identifier(completionId)} === ${t$5.numericLiteral(i)}) ${node}
      `);
    }
    if (returnNum) {
      for (const path of state.returns) {
        const arg = path.node.argument || path.scope.buildUndefinedNode();
        path.replaceWith(template$1.statement.ast`
          return { v: ${arg} };
        `);
      }
      bodyStmts.push(template$1.statement.ast`
          if (${t$5.identifier(completionId)}) return ${t$5.identifier(completionId)}.v;
        `);
    }
  }
  loopNode.body = t$5.blockStatement(bodyStmts);
  return varPath;
}
function isVarInLoopHead(path) {
  return t$5.isForStatement(path.parent) ? path.key === "init"
    : !!t$5.isForXStatement(path.parent) && path.key === "left";
}
function filterMap(list, fn) {
  const result = [];
  for (const item of list) {
    const mapped = fn(item);
    mapped && result.push(mapped);
  }
  return result;
}

function validateUsage(path, state, tdzEnabled) {
  const dynamicTDZNames = [];
  for (const name of Object.keys(path.getBindingIdentifiers())) {
    const binding = path.scope.getBinding(name);
    if (binding) {
      tdzEnabled && injectTDZChecks(binding, state) && dynamicTDZNames.push(name);

      path.node.kind !== "const" || disallowConstantViolations(name, binding, state);
    }
  }
  return dynamicTDZNames;
}
function disallowConstantViolations(name, binding, state) {
  for (const violation of binding.constantViolations) {
    const readOnlyError = state.addHelper("readOnlyError"),
      throwNode = t$5.callExpression(readOnlyError, [t$5.stringLiteral(name)]);
    if (violation.isAssignmentExpression()) {
      const { operator, left, right } = violation.node;
      if (operator === "=") {
        const exprs = [right];
        exprs.push(throwNode);
        violation.replaceWith(t$5.sequenceExpression(exprs));
      } else ["&&=", "||=", "??="].includes(operator)
        ? violation.replaceWith(
            t$5.logicalExpression(operator.slice(0, -1), left, t$5.sequenceExpression([right, throwNode]))
          )
        : violation.replaceWith(
            t$5.sequenceExpression([t$5.binaryExpression(operator.slice(0, -1), left, right), throwNode])
          );
    } else if (violation.isUpdateExpression())
      violation.replaceWith(
        t$5.sequenceExpression([t$5.unaryExpression("+", violation.get("argument").node), throwNode])
      );
    else if (violation.isForXStatement()) {
      violation.ensureBlock();
      violation.get("left").replaceWith(
        t$5.variableDeclaration("var", [t$5.variableDeclarator(violation.scope.generateUidIdentifier(name))])
      );
      violation.node.body.body.unshift(t$5.expressionStatement(throwNode));
    }
  }
}
function getTDZStatus(refPath, bindingPath) {
  const executionStatus = bindingPath._guessExecutionStatusRelativeTo(refPath);
  return executionStatus === "before" ? "outside" : executionStatus === "after" ? "inside" : "maybe";
}
const skipTDZChecks = new WeakSet();
function buildTDZAssert(status, node, state) {
  if (status === "maybe") {
    const clone = t$5.cloneNode(node);
    skipTDZChecks.add(clone);
    return t$5.callExpression(state.addHelper("temporalRef"), [clone, t$5.stringLiteral(node.name)]);
  }

  return t$5.callExpression(state.addHelper("tdz"), [t$5.stringLiteral(node.name)]);
}
function getTDZReplacement(path, state, id = path.node) {
  var _path$scope$getBindin;
  if (skipTDZChecks.has(id)) return;
  skipTDZChecks.add(id);
  const bindingPath =
    (_path$scope$getBindin = path.scope.getBinding(id.name)) == null ? void 0 : _path$scope$getBindin.path;
  if (!bindingPath || bindingPath.isFunctionDeclaration()) return;
  const status = getTDZStatus(path, bindingPath);
  if (status === "outside") return;
  if (status === "maybe") bindingPath.parent._tdzThis = true;

  return { status, node: buildTDZAssert(status, id, state) };
}
function injectTDZChecks(binding, state) {
  const allUsages = new Set(binding.referencePaths);
  binding.constantViolations.forEach(allUsages.add, allUsages);
  let dynamicTdz = false;
  for (const path of binding.constantViolations) {
    const { node } = path;
    if (skipTDZChecks.has(node)) continue;
    skipTDZChecks.add(node);
    if (path.isUpdateExpression()) {
      const arg = path.get("argument"),
        replacement = getTDZReplacement(path, state, arg.node);
      if (!replacement) continue;
      if (replacement.status === "maybe") {
        dynamicTdz = true;
        path.insertBefore(replacement.node);
      } else path.replaceWith(replacement.node);
    } else if (path.isAssignmentExpression()) {
      const nodes = [],
        ids = path.getBindingIdentifiers();
      for (const name of Object.keys(ids)) {
        const replacement = getTDZReplacement(path, state, ids[name]);
        if (replacement) {
          nodes.push(t$5.expressionStatement(replacement.node));
          if (replacement.status === "inside") break;
          if (replacement.status === "maybe") dynamicTdz = true;
        }
      }
      nodes.length > 0 && path.insertBefore(nodes);
    }
  }
  for (const path of binding.referencePaths) {
    if (path.parentPath.isUpdateExpression() || path.parentPath.isFor({ left: path.node })) continue;
    const replacement = getTDZReplacement(path, state);
    if (replacement) {
      if (replacement.status === "maybe") dynamicTdz = true;
      path.replaceWith(replacement.node);
    }
  }
  return dynamicTdz;
}

const annexB33FunctionsVisitor = {
  VariableDeclaration(path) {
    isStrict(path) ||
      path.node.kind !== "var" ||
      (path.scope.getFunctionParent() || path.scope.getProgramParent()).path.traverse(functionsToVarVisitor, {
        names: Object.keys(path.getBindingIdentifiers())
      });
  },
  BlockStatement(path) {
    isStrict(path) || t$5.isFunction(path.parent, { body: path.node }) || transformStatementList(path.get("body"));
  },
  SwitchCase(path) {
    isStrict(path) || transformStatementList(path.get("consequent"));
  }
};
function transformStatementList(paths) {
  outer: for (const path of paths) {
    if (!path.isFunctionDeclaration()) continue;
    if (path.node.async || path.node.generator) return;
    const { scope } = path.parentPath;
    if (isVarScope(scope)) return;
    const { name } = path.node.id;
    let currScope = scope;
    do {
      if (currScope.parent.hasOwnBinding(name)) continue outer;
      currScope = currScope.parent;
    } while (!isVarScope(currScope));
    maybeTransformBlockScopedFunction(path);
  }
}
function maybeTransformBlockScopedFunction(path) {
  const { node, parentPath: { scope } } = path,
    { id } = node;
  scope.removeOwnBinding(id.name);
  node.id = null;
  const varNode = t$5.variableDeclaration("var", [t$5.variableDeclarator(id, t$5.toExpression(node))]);
  varNode._blockHoist = 2;
  const [varPath] = path.replaceWith(varNode);
  scope.registerDeclaration(varPath);
}
const functionsToVarVisitor = {
  Scope(path, { names }) {
    for (const name of names) {
      const binding = path.scope.getOwnBinding(name);
      binding && binding.kind === "hoisted" && maybeTransformBlockScopedFunction(binding.path);
    }
  },
  "Expression|Declaration"(path) {
    path.skip();
  }
};
function isVarScope(scope) {
  return scope.path.isFunctionParent() || scope.path.isProgram();
}
function isStrict(path) {
  return !!path.find(({ node }) => {
    var _node$directives;
    if (t$5.isProgram(node)) {
      if (node.sourceType === "module") return true;
    } else if (t$5.isClass(node)) return true;
    else if (!t$5.isBlockStatement(node)) return false;

    return (_node$directives = node.directives) == null ? void 0
      : _node$directives.some(directive => directive.value.value === "use strict");
  });
}

var transformBlockScoping = declare((api, opts) => {
  api.assertVersion(7);
  const { throwIfClosureRequired = false, tdz: tdzEnabled = false } = opts;
  if (typeof throwIfClosureRequired != "boolean")
    throw new Error(".throwIfClosureRequired must be a boolean, or undefined");

  if (typeof tdzEnabled != "boolean") throw new Error(".tdz must be a boolean, or undefined");

  return {
    name: "transform-block-scoping",
    visitor: traverse.visitors.merge([annexB33FunctionsVisitor, {
      Loop(path, state) {
        const isForStatement = path.isForStatement(),
          headPath = isForStatement ? path.get("init") : path.isForXStatement() ? path.get("left") : null;
        let needsBodyWrap = false;
        const markNeedsBodyWrap = () => {
          if (throwIfClosureRequired)
            throw path.buildCodeFrameError(
              "Compiling let/const in this block would add a closure (throwIfClosureRequired)."
            );

          needsBodyWrap = true;
        };
        const body = path.get("body");
        let bodyScope;
        if (body.isBlockStatement()) {
          bodyScope = body.scope;
          const bindings = getLoopBodyBindings(path);
          for (const binding of bindings) {
            const { capturedInClosure } = getUsageInBody(binding, path);
            capturedInClosure && markNeedsBodyWrap();
          }
        }
        const captured = [],
          updatedBindingsUsages = new Map();
        if (headPath && isBlockScoped(headPath.node)) {
          const names = Object.keys(headPath.getBindingIdentifiers()),
            headScope = headPath.scope;
          for (let name of names) {
            var _bodyScope;
            if ((_bodyScope = bodyScope) != null && _bodyScope.hasOwnBinding(name)) continue;
            let binding = headScope.getOwnBinding(name);
            if (!binding) {
              headScope.crawl();
              binding = headScope.getOwnBinding(name);
            }
            const { usages, capturedInClosure, hasConstantViolations } = getUsageInBody(binding, path);
            if (headScope.parent.hasBinding(name) || headScope.parent.hasGlobal(name)) {
              const newName = headScope.generateUid(name);
              headScope.rename(name, newName);
              name = newName;
            }
            if (capturedInClosure) {
              markNeedsBodyWrap();
              captured.push(name);
            }
            isForStatement && hasConstantViolations && updatedBindingsUsages.set(name, usages);
          }
        }
        if (needsBodyWrap) {
          const varPath = wrapLoopBody(path, captured, updatedBindingsUsages);
          headPath != null && headPath.isVariableDeclaration() &&
            transformBlockScopedVariable(headPath, state, tdzEnabled);

          varPath.get("declarations.0.init").unwrapFunctionEnvironment();
        }
      },
      VariableDeclaration(path, state) {
        transformBlockScopedVariable(path, state, tdzEnabled);
      },
      ClassDeclaration(path) {
        const { id } = path.node;
        if (!id) return;
        const { scope } = path.parentPath;
        isVarScope(scope) || !scope.parent.hasBinding(id.name, { noUids: true }) || path.scope.rename(id.name);
      }
    }])
  };
});
const conflictingFunctionsVisitor = {
  Scope(path, { names }) {
    for (const name of names) {
      const binding = path.scope.getOwnBinding(name);
      binding && binding.kind === "hoisted" && path.scope.rename(name);
    }
  },
  "Expression|Declaration"(path) {
    path.skip();
  }
};
function transformBlockScopedVariable(path, state, tdzEnabled) {
  if (!isBlockScoped(path.node)) return;
  const dynamicTDZNames = validateUsage(path, state, tdzEnabled);
  path.node.kind = "var";
  const bindingNames = Object.keys(path.getBindingIdentifiers());
  for (const name of bindingNames) {
    const binding = path.scope.getOwnBinding(name);
    if (binding) binding.kind = "var";
  }
  if ((isInLoop(path) && !isVarInLoopHead(path)) || dynamicTDZNames.length > 0)
    for (const decl of path.node.declarations) decl.init != null || (decl.init = path.scope.buildUndefinedNode());

  const blockScope = path.scope,
    varScope = blockScope.getFunctionParent() || blockScope.getProgramParent();
  if (varScope !== blockScope)
    for (const name of bindingNames) {
      let newName = name;
      if (blockScope.parent.hasBinding(name, { noUids: true }) || blockScope.parent.hasGlobal(name)) {
        newName = blockScope.generateUid(name);
        blockScope.rename(name, newName);
      }
      blockScope.moveBindingTo(newName, varScope);
    }

  blockScope.path.traverse(conflictingFunctionsVisitor, { names: bindingNames });
  for (const name of dynamicTDZNames)
    path.scope.push({ id: t$5.identifier(name), init: state.addHelper("temporalUndefined") });
}
function isLetOrConst(kind) {
  return kind === "let" || kind === "const";
}
function isInLoop(path) {
  return (
    !!path.parentPath &&
    (!!path.parentPath.isLoop() || (!path.parentPath.isFunctionParent() && isInLoop(path.parentPath)))
  );
}
function isBlockScoped(node) {
  return !(
    !t$5.isVariableDeclaration(node) ||
    (!node[t$5.BLOCK_SCOPED_SYMBOL] && !isLetOrConst(node.kind) && node.kind !== "using")
  );
}

const helper$1 = template$1.statement`
  function CREATE_SUPER(Derived) {
    function isNativeReflectConstruct() {
      if (typeof Reflect == "undefined" || !Reflect.construct || Reflect.construct.sham) return false;

      if (typeof Proxy == "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
        return true;
      } catch (_e) {
        return false;
      }
    }

    return function () {
      var result, Super = GET_PROTOTYPE_OF(Derived);
      if (isNativeReflectConstruct()) {
        var NewTarget = GET_PROTOTYPE_OF(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else result = Super.apply(this, arguments);

      return POSSIBLE_CONSTRUCTOR_RETURN(this, result);
    }
  }
`;
const helperIDs = new WeakMap();
function addCreateSuperHelper(file) {
  if (helperIDs.has(file)) return (t$5.cloneNode || t$5.clone)(helperIDs.get(file));

  try {
    return file.addHelper("createSuper");
  } catch (_unused) {}
  const id = file.scope.generateUidIdentifier("createSuper");
  helperIDs.set(file, id);
  const fn = helper$1({
    CREATE_SUPER: id,
    GET_PROTOTYPE_OF: file.addHelper("getPrototypeOf"),
    POSSIBLE_CONSTRUCTOR_RETURN: file.addHelper("possibleConstructorReturn")
  });
  file.path.unshiftContainer("body", [fn]);
  file.scope.registerDeclaration(file.path.get("body.0"));
  return t$5.cloneNode(id);
}

function buildConstructor(classRef, constructorBody, node) {
  const func = t$5.functionDeclaration(t$5.cloneNode(classRef), [], constructorBody);
  t$5.inherits(func, node);
  return func;
}
function transformClass(path, file, builtinClasses, isLoose, assumptions, supportUnicodeId) {
  const classState = {
    parent: void 0,
    scope: void 0,
    node: void 0,
    path: void 0,
    file: void 0,
    classId: void 0,
    classRef: void 0,
    superFnId: void 0,
    superName: null,
    superReturns: [],
    isDerived: false,
    extendsNative: false,
    construct: void 0,
    constructorBody: void 0,
    userConstructor: void 0,
    userConstructorPath: void 0,
    hasConstructor: false,
    body: [],
    superThises: [],
    pushedConstructor: false,
    pushedInherits: false,
    pushedCreateClass: false,
    protoAlias: null,
    isLoose: false,
    dynamicKeys: new Map(),
    methods: {
      instance: { hasComputed: false, list: [], map: new Map() },
      static: { hasComputed: false, list: [], map: new Map() }
    }
  };
  const setState = newState => {
    Object.assign(classState, newState);
  };
  const findThisesVisitor = traverse.visitors.merge([visitor$5, {
    ThisExpression(path) {
      classState.superThises.push(path);
    }
  }]);
  function createClassHelper(args) {
    return t$5.callExpression(classState.file.addHelper("createClass"), args);
  }
  function maybeCreateConstructor() {
    const classBodyPath = classState.path.get("body");
    for (const path of classBodyPath.get("body")) if (path.isClassMethod({ kind: "constructor" })) return;

    let params, body;
    if (classState.isDerived) {
      const constructor = template$1.expression.ast`
        (function () {
          super(...arguments);
        })
      `;
      params = constructor.params;
      body = constructor.body;
    } else {
      params = [];
      body = t$5.blockStatement([]);
    }
    classBodyPath.unshiftContainer("body", t$5.classMethod("constructor", t$5.identifier("constructor"), params, body));
  }
  function buildBody() {
    maybeCreateConstructor();
    pushBody();
    verifyConstructor();
    if (classState.userConstructor) {
      const { constructorBody, userConstructor, construct } = classState;
      constructorBody.body.push(...userConstructor.body.body);
      t$5.inherits(construct, userConstructor);
      t$5.inherits(constructorBody, userConstructor.body);
    }
    pushDescriptors();
  }
  function pushBody() {
    const classBodyPaths = classState.path.get("body.body");
    for (const path of classBodyPaths) {
      const node = path.node;
      if (path.isClassProperty()) throw path.buildCodeFrameError("Missing class properties transform.");

      if (node.decorators)
        throw path.buildCodeFrameError("Method has decorators, put the decorator plugin before the classes one.");

      if (t$5.isClassMethod(node)) {
        const isConstructor = node.kind === "constructor";
        new ReplaceSupers({
          methodPath: path,
          objectRef: classState.classRef,
          superRef: classState.superName,
          constantSuper: assumptions.constantSuper,
          file: classState.file,
          refToPreserve: classState.classRef
        }).replace();
        const superReturns = [];
        path.traverse(
          traverse.visitors.merge([visitor$5, {
            ReturnStatement(path) {
              path.getFunctionParent().isArrowFunctionExpression() || superReturns.push(path);
            }
          }])
        );
        isConstructor ? pushConstructor(superReturns, node, path) : pushMethod(node, path);
      }
    }
  }
  function pushDescriptors() {
    pushInheritsToBody();
    const { body } = classState,
      props = { instance: null, static: null };
    for (const placement of ["static", "instance"])
      if (classState.methods[placement].list.length)
        props[placement] = classState.methods[placement].list.map(desc => {
          const obj = t$5.objectExpression([t$5.objectProperty(t$5.identifier("key"), desc.key)]);
          for (const kind of ["get", "set", "value"])
            desc[kind] == null || obj.properties.push(t$5.objectProperty(t$5.identifier(kind), desc[kind]));

          return obj;
        });

    if (props.instance || props.static) {
      let args = [
        t$5.cloneNode(classState.classRef),
        props.instance ? t$5.arrayExpression(props.instance) : t$5.nullLiteral(),
        props.static ? t$5.arrayExpression(props.static) : t$5.nullLiteral()
      ];
      let lastNonNullIndex = 0;
      for (let i = 0; i < args.length; i++) t$5.isNullLiteral(args[i]) || (lastNonNullIndex = i);

      args = args.slice(0, lastNonNullIndex + 1);
      body.push(t$5.expressionStatement(createClassHelper(args)));
      classState.pushedCreateClass = true;
    }
  }
  function wrapSuperCall(bareSuper, superRef, thisRef, body) {
    const bareSuperNode = bareSuper.node;
    let call;
    if (assumptions.superIsCallableConstructor) {
      bareSuperNode.arguments.unshift(t$5.thisExpression());
      if (
        bareSuperNode.arguments.length === 2 &&
        t$5.isSpreadElement(bareSuperNode.arguments[1]) &&
        t$5.isIdentifier(bareSuperNode.arguments[1].argument, { name: "arguments" })
      ) {
        bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;
        bareSuperNode.callee = t$5.memberExpression(t$5.cloneNode(superRef), t$5.identifier("apply"));
      } else bareSuperNode.callee = t$5.memberExpression(t$5.cloneNode(superRef), t$5.identifier("call"));

      call = t$5.logicalExpression("||", bareSuperNode, t$5.thisExpression());
    } else
      call = optimiseCallExpression(
        t$5.cloneNode(classState.superFnId), t$5.thisExpression(), bareSuperNode.arguments, false
      );

    if (
      bareSuper.parentPath.isExpressionStatement() &&
      bareSuper.parentPath.container === body.node.body &&
      body.node.body.length - 1 === bareSuper.parentPath.key
    ) {
      if (classState.superThises.length) call = t$5.assignmentExpression("=", thisRef(), call);

      bareSuper.parentPath.replaceWith(t$5.returnStatement(call));
    } else bareSuper.replaceWith(t$5.assignmentExpression("=", thisRef(), call));
  }
  function verifyConstructor() {
    if (!classState.isDerived) return;
    const path = classState.userConstructorPath,
      body = path.get("body");
    path.traverse(findThisesVisitor);
    let thisRef = function () {
      const ref = path.scope.generateDeclaredUidIdentifier("this");
      thisRef = () => t$5.cloneNode(ref);
      return ref;
    };
    for (const thisPath of classState.superThises) {
      const { node, parentPath } = thisPath;
      parentPath.isMemberExpression({ object: node })
        ? thisPath.replaceWith(thisRef())
        : thisPath.replaceWith(t$5.callExpression(classState.file.addHelper("assertThisInitialized"), [thisRef()]));
    }
    const bareSupers = [];
    path.traverse(
      traverse.visitors.merge([visitor$5, {
        Super(path) {
          const { node, parentPath } = path;
          parentPath.isCallExpression({ callee: node }) && bareSupers.unshift(parentPath);
        }
      }])
    );
    let guaranteedSuperBeforeFinish = !!bareSupers.length;
    for (const bareSuper of bareSupers) {
      wrapSuperCall(bareSuper, classState.superName, thisRef, body);
      guaranteedSuperBeforeFinish &&
        bareSuper.find(function (parentPath) {
          if (parentPath === path) return true;

          if (parentPath.isLoop() || parentPath.isConditional() || parentPath.isArrowFunctionExpression()) {
            guaranteedSuperBeforeFinish = false;
            return true;
          }
        });
    }
    let wrapReturn = classState.isLoose
      ? returnArg => {
          const thisExpr = t$5.callExpression(classState.file.addHelper("assertThisInitialized"), [thisRef()]);
          return returnArg ? t$5.logicalExpression("||", returnArg, thisExpr) : thisExpr;
        }
      : returnArg => {
          const returnParams = [thisRef()];
          returnArg == null || returnParams.push(returnArg);

          return t$5.callExpression(classState.file.addHelper("possibleConstructorReturn"), returnParams);
        };

    const bodyPaths = body.get("body");
    (bodyPaths.length && bodyPaths.pop().isReturnStatement()) ||
      body.pushContainer("body", t$5.returnStatement(guaranteedSuperBeforeFinish ? thisRef() : wrapReturn()));

    for (const returnPath of classState.superReturns)
      returnPath.get("argument").replaceWith(wrapReturn(returnPath.node.argument));
  }
  function pushMethod(node, path) {
    const scope = path ? path.scope : classState.scope;
    if (node.kind === "method" && processMethod(node, scope)) return;

    const placement = node.static ? "static" : "instance",
      methods = classState.methods[placement],
      descKey = node.kind === "method" ? "value" : node.kind;
    const key = t$5.isNumericLiteral(node.key) || t$5.isBigIntLiteral(node.key)
      ? t$5.stringLiteral(String(node.key.value))
      : t$5.toComputedKey(node);
    let descriptor,
      fn = t$5.toExpression(node);
    if (t$5.isStringLiteral(key)) {
      if (node.kind === "method") {
        var _nameFunction = nameFunction({ id: key, node, scope }, void 0, supportUnicodeId);
        fn = _nameFunction != null ? _nameFunction : fn;
      }
    } else methods.hasComputed = true;

    if (!methods.hasComputed && methods.map.has(key.value)) {
      descriptor = methods.map.get(key.value);
      descriptor[descKey] = fn;
      if (descKey === "value") {
        descriptor.get = null;
        descriptor.set = null;
      } else descriptor.value = null;
    } else {
      descriptor = { key, [descKey]: fn };
      methods.list.push(descriptor);
      methods.hasComputed || methods.map.set(key.value, descriptor);
    }
  }
  function processMethod(node, scope) {
    if (assumptions.setClassMethods && !node.decorators) {
      let { classRef } = classState;
      if (!node.static) {
        insertProtoAliasOnce();
        classRef = classState.protoAlias;
      }
      const methodName = t$5.memberExpression(
        t$5.cloneNode(classRef), node.key, node.computed || t$5.isLiteral(node.key)
      );
      let func = t$5.functionExpression(null, node.params, node.body, node.generator, node.async);
      t$5.inherits(func, node);
      const key = t$5.toComputedKey(node, node.key);
      if (t$5.isStringLiteral(key)) {
        var _nameFunction2 = nameFunction({ node: func, id: key, scope }, void 0, supportUnicodeId);
        func = _nameFunction2 != null ? _nameFunction2 : func;
      }
      const expr = t$5.expressionStatement(t$5.assignmentExpression("=", methodName, func));
      t$5.inheritsComments(expr, node);
      classState.body.push(expr);
      return true;
    }
    return false;
  }
  function insertProtoAliasOnce() {
    if (classState.protoAlias === null) {
      setState({ protoAlias: classState.scope.generateUidIdentifier("proto") });
      const classProto = t$5.memberExpression(classState.classRef, t$5.identifier("prototype")),
        protoDeclaration = t$5.variableDeclaration("var", [t$5.variableDeclarator(classState.protoAlias, classProto)]);
      classState.body.push(protoDeclaration);
    }
  }
  function pushConstructor(superReturns, method, path) {
    setState({ userConstructorPath: path, userConstructor: method, hasConstructor: true, superReturns });
    const { construct } = classState;
    t$5.inheritsComments(construct, method);
    construct.params = method.params;
    t$5.inherits(construct.body, method.body);
    construct.body.directives = method.body.directives;
    pushConstructorToBody();
  }
  function pushConstructorToBody() {
    if (classState.pushedConstructor) return;
    classState.pushedConstructor = true;
    if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) pushDescriptors();

    classState.body.push(classState.construct);
    pushInheritsToBody();
  }
  function pushInheritsToBody() {
    if (!classState.isDerived || classState.pushedInherits) return;
    const superFnId = path.scope.generateUidIdentifier("super");
    setState({ pushedInherits: true, superFnId });
    assumptions.superIsCallableConstructor ||
      classState.body.unshift(t$5.variableDeclaration("var", [
        t$5.variableDeclarator(
          superFnId,
          t$5.callExpression(addCreateSuperHelper(classState.file), [t$5.cloneNode(classState.classRef)])
        )
      ]));

    classState.body.unshift(t$5.expressionStatement(
      t$5.callExpression(classState.file.addHelper(classState.isLoose ? "inheritsLoose" : "inherits"), [
        t$5.cloneNode(classState.classRef), t$5.cloneNode(classState.superName)
      ])
    ));
  }
  function extractDynamicKeys() {
    const { dynamicKeys, node, scope } = classState;
    for (const elem of node.body.body) {
      if (!t$5.isClassMethod(elem) || !elem.computed || scope.isPure(elem.key, true)) continue;
      const id = scope.generateUidIdentifierBasedOnNode(elem.key);
      dynamicKeys.set(id.name, elem.key);
      elem.key = id;
    }
  }
  function setupClosureParamsArgs() {
    const { superName, dynamicKeys } = classState,
      closureParams = [],
      closureArgs = [];
    if (classState.isDerived) {
      let arg = t$5.cloneNode(superName);
      if (classState.extendsNative) {
        arg = t$5.callExpression(classState.file.addHelper("wrapNativeSuper"), [arg]);
        annotateAsPure(arg);
      }
      const param = classState.scope.generateUidIdentifierBasedOnNode(superName);
      closureParams.push(param);
      closureArgs.push(arg);
      setState({ superName: t$5.cloneNode(param) });
    }
    for (const [name, value] of dynamicKeys) {
      closureParams.push(t$5.identifier(name));
      closureArgs.push(value);
    }
    return { closureParams, closureArgs };
  }
  function classTransformer(path, file, builtinClasses, isLoose) {
    setState({ parent: path.parent, scope: path.scope, node: path.node, path, file, isLoose });
    setState({
      classId: classState.node.id,
      classRef: classState.node.id
        ? t$5.identifier(classState.node.id.name)
        : classState.scope.generateUidIdentifier("class"),
      superName: classState.node.superClass,
      isDerived: !!classState.node.superClass,
      constructorBody: t$5.blockStatement([])
    });
    setState({
      extendsNative:
        t$5.isIdentifier(classState.superName) &&
        builtinClasses.has(classState.superName.name) &&
        !classState.scope.hasBinding(classState.superName.name, true)
    });
    const { classRef, node, constructorBody } = classState;
    setState({ construct: buildConstructor(classRef, constructorBody, node) });
    extractDynamicKeys();
    const { body } = classState,
      { closureParams, closureArgs } = setupClosureParamsArgs();
    buildBody();
    assumptions.noClassCalls ||
      constructorBody.body.unshift(t$5.expressionStatement(
        t$5.callExpression(classState.file.addHelper("classCallCheck"), [
          t$5.thisExpression(), t$5.cloneNode(classState.classRef)
        ])
      ));

    const isStrict = path.isInStrictMode();
    let constructorOnly = classState.classId && body.length === 1;
    if (constructorOnly && !isStrict)
      for (const param of classState.construct.params)
        if (!t$5.isIdentifier(param)) {
          constructorOnly = false;
          break;
        }

    const directives = constructorOnly ? body[0].body.directives : [];
    isStrict || directives.push(t$5.directive(t$5.directiveLiteral("use strict")));

    if (constructorOnly) {
      const expr = t$5.toExpression(body[0]);
      return classState.isLoose ? expr : createClassHelper([expr]);
    }
    let returnArg = t$5.cloneNode(classState.classRef);
    classState.pushedCreateClass || classState.isLoose || (returnArg = createClassHelper([returnArg]));

    body.push(t$5.returnStatement(returnArg));
    const container = t$5.arrowFunctionExpression(closureParams, t$5.blockStatement(body, directives));
    return t$5.callExpression(container, closureArgs);
  }
  return classTransformer(path, file, builtinClasses, isLoose);
}

const getBuiltinClasses = category => Object.keys(traverse.globals[category]).filter(name => /^[A-Z]/.test(name)),
  builtinClasses = new Set([...getBuiltinClasses("builtin"), ...getBuiltinClasses("browser")]);
var transformClasses = declare((api, options) => {
  var _api$assumption, _api$assumption2, _api$assumption3, _api$assumption4;
  api.assertVersion(7);
  const { loose = false } = options,
    setClassMethods = (_api$assumption = api.assumption("setClassMethods")) != null ? _api$assumption : loose,
    constantSuper = (_api$assumption2 = api.assumption("constantSuper")) != null ? _api$assumption2 : loose,
    superIsCallableConstructor =
      (_api$assumption3 = api.assumption("superIsCallableConstructor")) != null ? _api$assumption3 : loose,
    noClassCalls = (_api$assumption4 = api.assumption("noClassCalls")) != null ? _api$assumption4 : loose,
    supportUnicodeId = !isRequired("transform-unicode-escapes", api.targets()),
    VISITED = new WeakSet();
  return {
    name: "transform-classes",
    visitor: {
      ExportDefaultDeclaration(path) {
        path.get("declaration").isClassDeclaration() && splitExportDeclaration(path);
      },
      ClassDeclaration(path) {
        const { node } = path,
          ref = node.id || path.scope.generateUidIdentifier("class");
        path.replaceWith(t$5.variableDeclaration("let", [t$5.variableDeclarator(ref, t$5.toExpression(node))]));
      },
      ClassExpression(path, state) {
        const { node } = path;
        if (VISITED.has(node)) return;
        const inferred = nameFunction(path, void 0, supportUnicodeId);
        if (inferred && inferred !== node) {
          path.replaceWith(inferred);
          return;
        }
        VISITED.add(node);
        const [replacedPath] = path.replaceWith(transformClass(
          path, state.file, builtinClasses, loose,
          { setClassMethods, constantSuper, superIsCallableConstructor, noClassCalls },
          supportUnicodeId
        ));
        if (replacedPath.isCallExpression()) {
          annotateAsPure(replacedPath);
          const callee = replacedPath.get("callee");
          callee.isArrowFunctionExpression() && callee.arrowFunctionToExpression();
        }
      }
    }
  };
});

var DefineAccessorHelper = template$1.expression.ast`
  function (type, obj, key, fn) {
    var desc = { configurable: true, enumerable: true };
    desc[type] = fn;
    return Object.defineProperty(obj, key, desc);
  }
`;
DefineAccessorHelper._compact = true;

var transformComputedProperties = declare((api, options) => {
  api.assertVersion(7);
  var _api$assumption = api.assumption("setComputedProperties");
  const pushComputedProps = (_api$assumption != null ? _api$assumption : options.loose)
    ? pushComputedPropsLoose
    : pushComputedPropsSpec;
  function buildDefineAccessor(state, type, obj, key, fn) {
    let helper;
    if (state.availableHelper("defineAccessor")) helper = state.addHelper("defineAccessor");
    else {
      const file = state.file;
      helper = file.get("fallbackDefineAccessorHelper");
      if (!helper) {
        const id = file.scope.generateUidIdentifier("defineAccessor");
        file.scope.push({ id, init: DefineAccessorHelper });
        file.set("fallbackDefineAccessorHelper", (helper = id));
      }
      helper = t$5.cloneNode(helper);
    }
    return t$5.callExpression(helper, [t$5.stringLiteral(type), obj, key, fn]);
  }
  function getValue(prop) {
    return t$5.isObjectProperty(prop)
      ? prop.value
      : t$5.isObjectMethod(prop)
      ? t$5.functionExpression(null, prop.params, prop.body, prop.generator, prop.async)
      : void 0;
  }
  function pushAssign(objId, prop, body) {
    body.push(t$5.expressionStatement(
      t$5.assignmentExpression("=",
        t$5.memberExpression(t$5.cloneNode(objId), prop.key, prop.computed || t$5.isLiteral(prop.key)),
        getValue(prop)
      )
    ));
  }
  function pushAccessorDefine({ body, computedProps, initPropExpression, objId, state }, prop) {
    const kind = prop.kind,
      key = !prop.computed && t$5.isIdentifier(prop.key) ? t$5.stringLiteral(prop.key.name) : prop.key,
      value = getValue(prop);
    if (computedProps.length === 1) return buildDefineAccessor(state, kind, initPropExpression, key, value);

    body.push(t$5.expressionStatement(buildDefineAccessor(state, kind, t$5.cloneNode(objId), key, value)));
  }
  function pushComputedPropsLoose(info) {
    for (const prop of info.computedProps)
      if (t$5.isObjectMethod(prop) && (prop.kind === "get" || prop.kind === "set")) {
        const single = pushAccessorDefine(info, prop);
        if (single) return single;
      } else pushAssign(t$5.cloneNode(info.objId), prop, info.body);
  }
  function pushComputedPropsSpec(info) {
    const { objId, body, computedProps, state } = info;
    for (const prop of computedProps) {
      const key = t$5.toComputedKey(prop);
      if (!t$5.isObjectMethod(prop) || (prop.kind !== "get" && prop.kind !== "set")) {
        const value = getValue(prop);
        if (computedProps.length === 1)
          return t$5.callExpression(state.addHelper("defineProperty"), [info.initPropExpression, key, value]);

        body.push(t$5.expressionStatement(
          t$5.callExpression(state.addHelper("defineProperty"), [t$5.cloneNode(objId), key, value])
        ));
      } else {
        const single = pushAccessorDefine(info, prop);
        if (single) return single;
      }
    }
  }
  return {
    name: "transform-computed-properties",
    visitor: {
      ObjectExpression: {
        exit(path, state) {
          const { node, parent, scope } = path;
          let hasComputed = false;
          for (const prop of node.properties) {
            hasComputed = prop.computed === true;
            if (hasComputed) break;
          }
          if (!hasComputed) return;
          const initProps = [],
            computedProps = [];
          let foundComputed = false;
          for (const prop of node.properties)
            if (!t$5.isSpreadElement(prop)) {
              if (prop.computed) foundComputed = true;

              foundComputed ? computedProps.push(prop) : initProps.push(prop);
            }
          const objId = scope.generateUidIdentifierBasedOnNode(parent),
            initPropExpression = t$5.objectExpression(initProps),
            body = [];
          body.push(t$5.variableDeclaration("var", [t$5.variableDeclarator(objId, initPropExpression)]));
          const single = pushComputedProps({ scope, objId, body, computedProps, initPropExpression, state });
          if (single) path.replaceWith(single);
          else {
            body.push(t$5.expressionStatement(t$5.cloneNode(objId)));
            path.replaceWithMultiple(body);
          }
        }
      }
    }
  };
});

var transformDotallRegex = declare(api => {
  api.assertVersion(7);
  return createRegExpFeaturePlugin({ name: "transform-dotall-regex", feature: "dotAllFlag" });
});

function getName(key) {
  return t$5.isIdentifier(key) ? key.name : key.value.toString();
}
var transformDuplicateKeys = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-duplicate-keys",
    visitor: {
      ObjectExpression(path) {
        const { node } = path,
          plainProps = node.properties.filter(prop => !t$5.isSpreadElement(prop) && !prop.computed),
          alreadySeenData = Object.create(null),
          alreadySeenGetters = Object.create(null),
          alreadySeenSetters = Object.create(null);
        for (const prop of plainProps) {
          const name = getName(prop.key);
          let isDuplicate = false;
          switch (prop.kind) {
            case "get":
              if (alreadySeenData[name] || alreadySeenGetters[name]) isDuplicate = true;

              alreadySeenGetters[name] = true;
              break;
            case "set":
              if (alreadySeenData[name] || alreadySeenSetters[name]) isDuplicate = true;

              alreadySeenSetters[name] = true;
              break;
            default:
              if (alreadySeenData[name] || alreadySeenGetters[name] || alreadySeenSetters[name]) isDuplicate = true;

              alreadySeenData[name] = true;
          }
          if (isDuplicate) {
            prop.computed = true;
            prop.key = t$5.stringLiteral(name);
          }
        }
      }
    }
  };
});

const {
  assignmentExpression: assignmentExpression$2,
  cloneNode,
  isIdentifier: isIdentifier$2,
  isLiteral,
  isMemberExpression,
  isPrivateName,
  isPureish,
  isSuper,
  memberExpression: memberExpression$1,
  toComputedKey
} = t$5;
function getObjRef(node, nodes, scope) {
  let ref;
  if (isIdentifier$2(node)) {
    if (scope.hasBinding(node.name)) return node;

    ref = node;
  } else {
    if (!isMemberExpression(node)) throw new Error("We can't explode this node type " + node.type);

    ref = node.object;
    if (isSuper(ref) || (isIdentifier$2(ref) && scope.hasBinding(ref.name))) return ref;
  }
  const temp = scope.generateUidIdentifierBasedOnNode(ref);
  scope.push({ id: temp });
  nodes.push(assignmentExpression$2("=", cloneNode(temp), cloneNode(ref)));
  return temp;
}
function getPropRef(node, nodes, scope) {
  const prop = node.property;
  if (isPrivateName(prop))
    throw new Error(
      "We can't generate property ref for private name, please install `@babel/plugin-transform-class-properties`"
    );

  const key = toComputedKey(node, prop);
  if (isLiteral(key) && isPureish(key)) return key;
  const temp = scope.generateUidIdentifierBasedOnNode(prop);
  scope.push({ id: temp });
  nodes.push(assignmentExpression$2("=", cloneNode(temp), cloneNode(prop)));
  return temp;
}
function explode(node, nodes, scope) {
  const obj = getObjRef(node, nodes, scope);
  let ref, uid;
  if (isIdentifier$2(node)) {
    ref = cloneNode(node);
    uid = obj;
  } else {
    const prop = getPropRef(node, nodes, scope),
      computed = node.computed || isLiteral(prop);
    uid = memberExpression$1(cloneNode(obj), cloneNode(prop), computed);
    ref = memberExpression$1(cloneNode(obj), cloneNode(prop), computed);
  }
  return { uid, ref };
}

const { assignmentExpression: assignmentExpression$1, sequenceExpression } = t$5;
function build(opts) {
  const { build, operator } = opts;
  return {
    AssignmentExpression(path) {
      const { node, scope } = path;
      if (node.operator !== operator + "=") return;
      const nodes = [],
        exploded = explode(node.left, nodes, scope);
      nodes.push(assignmentExpression$1("=", exploded.ref, build(exploded.uid, node.right)));
      path.replaceWith(sequenceExpression(nodes));
    },
    BinaryExpression(path) {
      const { node } = path;
      node.operator !== operator || path.replaceWith(build(node.left, node.right));
    }
  };
}

var transformExponentialOperator = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-exponentiation-operator",
    visitor: build({
      operator: "**",
      build: (left, right) =>
        t$5.callExpression(t$5.memberExpression(t$5.identifier("Math"), t$5.identifier("pow")), [left, right])
    })
  };
});

var transformFlowComments = declare(api => {
  api.assertVersion(7);
  function commentFromString(comment) {
    return typeof comment == "string" ? { type: "CommentBlock", value: comment } : comment;
  }
  function attachComment({
    ofPath,
    toPath,
    where = "trailing",
    optional = false,
    comments = generateComment(ofPath, optional),
    keepType = false
  }) {
    var _toPath;
    if ((_toPath = toPath) == null || !_toPath.node) {
      toPath = ofPath.getPrevSibling();
      where = "trailing";
    }
    if (!toPath.node) {
      toPath = ofPath.getNextSibling();
      where = "leading";
    }
    if (!toPath.node) {
      toPath = ofPath.parentPath;
      where = "inner";
    }
    Array.isArray(comments) || (comments = [comments]);

    const newComments = comments.map(commentFromString);
    if (!keepType && ofPath != null && ofPath.node) {
      const node = ofPath.node,
        parent = ofPath.parentPath,
        prev = ofPath.getPrevSibling(),
        next = ofPath.getNextSibling(),
        isSingleChild = !(prev.node || next.node),
        leading = node.leadingComments,
        trailing = node.trailingComments;
      isSingleChild && leading && parent.addComments("inner", leading);

      toPath.addComments(where, newComments);
      ofPath.remove();
      isSingleChild && trailing && parent.addComments("inner", trailing);
    } else toPath.addComments(where, newComments);
  }
  function wrapInFlowComment(path) {
    attachComment({ ofPath: path, comments: generateComment(path, path.parent.optional) });
  }
  function generateComment(path, optional) {
    let comment = path.getSource().replace(/\*-\//g, "*-ESCAPED/").replace(/\*\//g, "*-/");
    if (optional) comment = "?" + comment;
    if (comment[0] !== ":") comment = ":: " + comment;
    return comment;
  }
  function isTypeImport(importKind) {
    return importKind === "type" || importKind === "typeof";
  }
  return {
    name: "transform-flow-comments",
    inherits: syntaxFlow,
    visitor: {
      TypeCastExpression(path) {
        const { node } = path;
        attachComment({ ofPath: path.get("typeAnnotation"), toPath: path.get("expression"), keepType: true });
        path.replaceWith(t$5.parenthesizedExpression(node.expression));
      },
      Identifier(path) {
        if (path.parentPath.isFlow()) return;
        const { node } = path;
        if (node.typeAnnotation) {
          attachComment({
            ofPath: path.get("typeAnnotation"),
            toPath: path,
            optional: node.optional || node.typeAnnotation.optional
          });
          if (node.optional) node.optional = false;
        } else if (node.optional) {
          attachComment({ toPath: path, comments: ":: ?" });
          node.optional = false;
        }
      },
      AssignmentPattern: {
        exit({ node }) {
          const { left } = node;
          if (left.optional) left.optional = false;
        }
      },
      Function(path) {
        if (path.isDeclareFunction()) return;
        const { node } = path;
        node.typeParameters &&
          attachComment({
            ofPath: path.get("typeParameters"),
            toPath: path.get("id"),
            optional: node.typeParameters.optional
          });

        node.returnType &&
          attachComment({
            ofPath: path.get("returnType"),
            toPath: path.get("body"),
            where: "leading",
            optional: node.returnType.typeAnnotation.optional
          });
      },
      ClassProperty(path) {
        const { node } = path;
        node.value
          ? node.typeAnnotation &&
            attachComment({
              ofPath: path.get("typeAnnotation"),
              toPath: path.get("key"),
              optional: node.typeAnnotation.optional
            })
          : wrapInFlowComment(path);
      },
      ExportNamedDeclaration(path) {
        const { node } = path;
        if (node.exportKind === "type" || t$5.isFlow(node.declaration)) wrapInFlowComment(path);
      },
      ImportDeclaration(path) {
        const { node } = path;
        if (isTypeImport(node.importKind)) {
          wrapInFlowComment(path);
          return;
        }
        const typeSpecifiers = node.specifiers.filter(
          specifier => specifier.type === "ImportSpecifier" && isTypeImport(specifier.importKind)
        );
        const nonTypeSpecifiers = node.specifiers.filter(
          specifier => specifier.type !== "ImportSpecifier" || !isTypeImport(specifier.importKind)
        );
        node.specifiers = nonTypeSpecifiers;
        if (typeSpecifiers.length > 0) {
          const typeImportNode = t$5.cloneNode(node);
          typeImportNode.specifiers = typeSpecifiers;
          const comment = ":: " + generate.default(typeImportNode).code;
          nonTypeSpecifiers.length > 0
            ? attachComment({ toPath: path, comments: comment })
            : attachComment({ ofPath: path, comments: comment });
        }
      },
      ObjectPattern(path) {
        const { node } = path;
        node.typeAnnotation &&
          attachComment({
            ofPath: path.get("typeAnnotation"),
            toPath: path,
            optional: node.optional || node.typeAnnotation.optional
          });
      },
      Flow(path) {
        wrapInFlowComment(path);
      },
      Class(path) {
        const { node } = path;
        let comments = [];
        if (node.typeParameters) {
          const typeParameters = path.get("typeParameters");
          comments.push(generateComment(typeParameters, node.typeParameters.optional));
          const trailingComments = node.typeParameters.trailingComments;
          trailingComments && comments.push(...trailingComments);

          typeParameters.remove();
        }
        if (node.superClass) {
          if (comments.length > 0) {
            attachComment({ toPath: path.get("id"), comments });
            comments = [];
          }
          if (node.superTypeParameters) {
            const superTypeParameters = path.get("superTypeParameters");
            comments.push(generateComment(superTypeParameters, superTypeParameters.node.optional));
            superTypeParameters.remove();
          }
        }
        if (node.implements) {
          const comment =
            "implements " + path.get("implements").map(impl => generateComment(impl).replace(/^:: /, "")).join(", ");
          delete node.implements;
          comments.length === 1 ? (comments[0] += " " + comment) : comments.push(":: " + comment);
        }
        comments.length > 0 && attachComment({ toPath: path.get("body"), where: "leading", comments });
      }
    }
  };
});

var transformFlowStripTypes = declare((api, opts) => {
  api.assertVersion(7);
  const FLOW_DIRECTIVE = /(@flow(\s+(strict(-local)?|weak))?|@noflow)/;
  let skipStrip = false;
  const { requireDirective = false } = opts;

  var { allowDeclareFields = false } = opts;

  return {
    name: "transform-flow-strip-types",
    inherits: syntaxFlow,
    visitor: {
      Program(path, {
        file: { ast: { comments } }
      }) {
        skipStrip = false;
        let directiveFound = false;
        if (comments)
          for (const comment of comments)
            if (FLOW_DIRECTIVE.test(comment.value)) {
              directiveFound = true;
              comment.value = comment.value.replace(FLOW_DIRECTIVE, "");
              comment.value.replace(/\*/g, "").trim() || (comment.ignore = true);
            }

        if (!directiveFound && requireDirective) skipStrip = true;
      },
      ImportDeclaration(path) {
        if (skipStrip || !path.node.specifiers.length) return;
        let typeCount = 0;
        path.node.specifiers.forEach(({ importKind }) => {
          (importKind !== "type" && importKind !== "typeof") || typeCount++;
        });
        typeCount !== path.node.specifiers.length || path.remove();
      },
      Flow(path) {
        if (skipStrip)
          throw path.buildCodeFrameError(
            "A @flow directive is required when using Flow annotations with the `requireDirective` option."
          );

        path.remove();
      },
      ClassPrivateProperty(path) {
        skipStrip || (path.node.typeAnnotation = null);
      },
      Class(path) {
        if (skipStrip) return;
        path.node.implements = null;
        path.get("body.body").forEach(child => {
          if (child.isClassProperty()) {
            const { node } = child;

            if (!allowDeclareFields && node.declare)
              throw child.buildCodeFrameError(
                "The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transform-flow-strip-types or @babel/preset-flow is enabled."
              );

            if (node.declare) child.remove();
            else {
              if (!allowDeclareFields && !node.value && !node.decorators) {
                child.remove();
                return;
              }

              node.variance = null;
              node.typeAnnotation = null;
            }
          }
        });
      },
      AssignmentPattern({ node }) {
        if (!skipStrip && node.left.optional) node.left.optional = false;
      },
      Function({ node }) {
        if (skipStrip) return;
        node.params.length > 0 && node.params[0].type === "Identifier" && node.params[0].name === "this" &&
          node.params.shift();

        for (let i = 0; i < node.params.length; i++) {
          let param = node.params[i];
          if (param.type === "AssignmentPattern") param = param.left;

          if (param.optional) param.optional = false;
        }
        t$5.isMethod(node) || (node.predicate = null);
      },
      TypeCastExpression(path) {
        if (skipStrip) return;
        let { node } = path;
        do {
          node = node.expression;
        } while (t$5.isTypeCastExpression(node));
        path.replaceWith(node);
      },
      CallExpression({ node }) {
        skipStrip || (node.typeArguments = null);
      },
      OptionalCallExpression({ node }) {
        skipStrip || (node.typeArguments = null);
      },
      NewExpression({ node }) {
        skipStrip || (node.typeArguments = null);
      }
    }
  };
});

function transformWithoutHelper(loose, path, state) {
  const pushComputedProps = loose ? pushComputedPropsLoose : pushComputedPropsSpec,
    { node } = path,
    build = pushComputedProps(path, state),
    declar = build.declar,
    loop = build.loop,
    block = loop.body;
  path.ensureBlock();
  declar && block.body.push(declar);

  block.body.push(...node.body.body);
  t$5.inherits(loop, node);
  t$5.inherits(loop.body, node.body);
  if (build.replaceParent) {
    path.parentPath.replaceWithMultiple(build.node);
    path.remove();
  } else path.replaceWithMultiple(build.node);
}
const buildForOfLoose = template$1.statement(`
  for (
    var LOOP_OBJECT = OBJECT,
      IS_ARRAY = Array.isArray(LOOP_OBJECT),
      INDEX = 0,
      LOOP_OBJECT = IS_ARRAY ? LOOP_OBJECT : LOOP_OBJECT[Symbol.iterator]();
    ;
  ) {
    INTERMEDIATE;
    if (IS_ARRAY) {
      if (INDEX >= LOOP_OBJECT.length) break;
      ID = LOOP_OBJECT[INDEX++];
    } else {
      INDEX = LOOP_OBJECT.next();
      if (INDEX.done) break;
      ID = INDEX.value;
    }
  }
`);
const buildForOf = template$1.statements(`
  var ITERATOR_COMPLETION = true,
    ITERATOR_HAD_ERROR_KEY = false,
    ITERATOR_ERROR_KEY = void 0;
  try {
    for (
      var STEP_KEY, ITERATOR_KEY = OBJECT[Symbol.iterator]();
      !(ITERATOR_COMPLETION = (STEP_KEY = ITERATOR_KEY.next()).done);
      ITERATOR_COMPLETION = true
    );
  } catch (err) {
    ITERATOR_HAD_ERROR_KEY = true;
    ITERATOR_ERROR_KEY = err;
  } finally {
    try {
      ITERATOR_COMPLETION || ITERATOR_KEY.return == null || ITERATOR_KEY.return();
    } finally {
      if (ITERATOR_HAD_ERROR_KEY) throw ITERATOR_ERROR_KEY;
    }
  }
`);
function pushComputedPropsLoose(path, state) {
  const { node, scope, parent } = path,
    { left } = node;
  let declar, id, intermediate;
  if (t$5.isIdentifier(left) || t$5.isPattern(left) || t$5.isMemberExpression(left)) {
    id = left;
    intermediate = null;
  } else if (t$5.isVariableDeclaration(left)) {
    id = scope.generateUidIdentifier("ref");
    declar = t$5.variableDeclaration(left.kind, [
      t$5.variableDeclarator(left.declarations[0].id, t$5.identifier(id.name))
    ]);
    intermediate = t$5.variableDeclaration("var", [t$5.variableDeclarator(t$5.identifier(id.name))]);
  } else throw state.buildCodeFrameError(left, `Unknown node type ${left.type} in ForStatement`);

  const iteratorKey = scope.generateUidIdentifier("iterator"),
    isArrayKey = scope.generateUidIdentifier("isArray");
  const loop = buildForOfLoose({
    LOOP_OBJECT: iteratorKey,
    IS_ARRAY: isArrayKey,
    OBJECT: node.right,
    INDEX: scope.generateUidIdentifier("i"),
    ID: id,
    INTERMEDIATE: intermediate
  });
  const isLabeledParent = t$5.isLabeledStatement(parent);
  let labeled;
  if (isLabeledParent) labeled = t$5.labeledStatement(parent.label, loop);

  return { replaceParent: isLabeledParent, declar, node: labeled || loop, loop };
}
function pushComputedPropsSpec(path, state) {
  const { node, scope, parent } = path,
    left = node.left;
  let declar;
  const stepKey = scope.generateUid("step"),
    stepValue = t$5.memberExpression(t$5.identifier(stepKey), t$5.identifier("value"));
  if (t$5.isIdentifier(left) || t$5.isPattern(left) || t$5.isMemberExpression(left))
    declar = t$5.expressionStatement(t$5.assignmentExpression("=", left, stepValue));
  else if (t$5.isVariableDeclaration(left))
    declar = t$5.variableDeclaration(left.kind, [t$5.variableDeclarator(left.declarations[0].id, stepValue)]);
  else throw state.buildCodeFrameError(left, `Unknown node type ${left.type} in ForStatement`);

  const template = buildForOf({
    ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
    ITERATOR_COMPLETION: scope.generateUidIdentifier("iteratorNormalCompletion"),
    ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
    ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
    STEP_KEY: t$5.identifier(stepKey),
    OBJECT: node.right
  });
  const isLabeledParent = t$5.isLabeledStatement(parent),
    tryBody = template[3].block.body,
    loop = tryBody[0];
  if (isLabeledParent) tryBody[0] = t$5.labeledStatement(parent.label, loop);

  return { replaceParent: isLabeledParent, declar, loop, node: template };
}

function buildLoopBody(path, declar, newBody) {
  let block;
  const bodyPath = path.get("body"),
    body = newBody != null ? newBody : bodyPath.node;
  if (
    t$5.isBlockStatement(body) &&
    Object.keys(path.getBindingIdentifiers()).some(id => bodyPath.scope.hasOwnBinding(id))
  )
    block = t$5.blockStatement([declar, body]);
  else {
    block = t$5.toBlock(body);
    block.body.unshift(declar);
  }
  return block;
}
var transformForOf = declare((api, options) => {
  var _options$assumeArray, _options$allowArrayLi, _api$assumption;
  api.assertVersion(7);
  {
    const { assumeArray, allowArrayLike, loose } = options;
    if (loose === true && assumeArray === true)
      throw new Error("The loose and assumeArray options cannot be used together in @babel/plugin-transform-for-of");

    if (assumeArray === true && allowArrayLike === true)
      throw new Error(
        "The assumeArray and allowArrayLike options cannot be used together in @babel/plugin-transform-for-of"
      );

    if (allowArrayLike && /^7\.\d\./.test(api.version))
      throw new Error("The allowArrayLike is only supported when using @babel/core@^7.10.0");
  }
  const iterableIsArray = (_options$assumeArray = options.assumeArray) != null
    ? _options$assumeArray
    : !options.loose && api.assumption("iterableIsArray");
  const arrayLikeIsIterable = (_options$allowArrayLi = options.allowArrayLike) != null
    ? _options$allowArrayLi
    : api.assumption("arrayLikeIsIterable");
  const skipIteratorClosing =
    (_api$assumption = api.assumption("skipForOfIteratorClosing")) != null ? _api$assumption : options.loose;
  if (iterableIsArray && arrayLikeIsIterable)
    throw new Error('The "iterableIsArray" and "arrayLikeIsIterable" assumptions are not compatible.');

  if (iterableIsArray)
    return {
      name: "transform-for-of",
      visitor: {
        ForOfStatement(path) {
          const { scope } = path,
            { left, right, await: isAwait } = path.node;
          if (isAwait) return;

          const i = scope.generateUidIdentifier("i");
          let array = scope.maybeGenerateMemoised(right, true);
          const inits = [t$5.variableDeclarator(i, t$5.numericLiteral(0))];
          array ? inits.push(t$5.variableDeclarator(array, right)) : (array = right);

          const item = t$5.memberExpression(t$5.cloneNode(array), t$5.cloneNode(i), true);
          let assignment;
          if (t$5.isVariableDeclaration(left)) {
            assignment = left;
            assignment.declarations[0].init = item;
          } else assignment = t$5.expressionStatement(t$5.assignmentExpression("=", left, item));

          path.replaceWith(t$5.forStatement(
            t$5.variableDeclaration("let", inits),
            t$5.binaryExpression(
              "<", t$5.cloneNode(i), t$5.memberExpression(t$5.cloneNode(array), t$5.identifier("length"))
            ),
            t$5.updateExpression("++", t$5.cloneNode(i)),
            buildLoopBody(path, assignment)
          ));
        }
      }
    };

  const buildForOfArray = template$1.default`
    for (var KEY = 0, NAME = ARR; KEY < NAME.length; KEY++) BODY;
  `;
  const buildForOfNoIteratorClosing = template$1.statements`
    for (var STEP_KEY, ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ARRAY_LIKE_IS_ITERABLE);
        !(STEP_KEY = ITERATOR_HELPER()).done; ) BODY;
  `;
  const buildForOf = template$1.statements`
    var STEP_KEY, ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ARRAY_LIKE_IS_ITERABLE);
    try {
      for (ITERATOR_HELPER.s(); !(STEP_KEY = ITERATOR_HELPER.n()).done; ) BODY;
    } catch (err) {
      ITERATOR_HELPER.e(err);
    } finally {
      ITERATOR_HELPER.f();
    }
  `;
  const builder = skipIteratorClosing
    ? { build: buildForOfNoIteratorClosing, helper: "createForOfIteratorHelperLoose", getContainer: nodes => nodes }
    : { build: buildForOf, helper: "createForOfIteratorHelper", getContainer: nodes => nodes[1].block.body };
  function _ForOfStatementArray(path) {
    const { node, scope } = path,
      right = scope.generateUidIdentifierBasedOnNode(node.right, "arr"),
      iterationKey = scope.generateUidIdentifier("i"),
      loop = buildForOfArray({ BODY: node.body, KEY: iterationKey, NAME: right, ARR: node.right });
    t$5.inherits(loop, node);
    const iterationValue = t$5.memberExpression(t$5.cloneNode(right), t$5.cloneNode(iterationKey), true);
    let declar;
    const left = node.left;
    if (t$5.isVariableDeclaration(left)) {
      left.declarations[0].init = iterationValue;
      declar = left;
    } else declar = t$5.expressionStatement(t$5.assignmentExpression("=", left, iterationValue));

    loop.body = buildLoopBody(path, declar, loop.body);
    return loop;
  }
  return {
    name: "transform-for-of",
    visitor: {
      ForOfStatement(path, state) {
        const right = path.get("right");
        if (
          right.isArrayExpression() || right.isGenericType("Array") ||
          t$5.isArrayTypeAnnotation(right.getTypeAnnotation())
        ) {
          path.replaceWith(_ForOfStatementArray(path));
          return;
        }

        if (!state.availableHelper(builder.helper)) {
          transformWithoutHelper(skipIteratorClosing, path, state);
          return;
        }

        const { node, parent, scope } = path,
          left = node.left;
        let declar;
        const stepKey = scope.generateUid("step"),
          stepValue = t$5.memberExpression(t$5.identifier(stepKey), t$5.identifier("value"));
        declar = t$5.isVariableDeclaration(left)
          ? t$5.variableDeclaration(left.kind, [t$5.variableDeclarator(left.declarations[0].id, stepValue)])
          : t$5.expressionStatement(t$5.assignmentExpression("=", left, stepValue));

        const nodes = builder.build({
          CREATE_ITERATOR_HELPER: state.addHelper(builder.helper),
          ITERATOR_HELPER: scope.generateUidIdentifier("iterator"),
          ARRAY_LIKE_IS_ITERABLE: arrayLikeIsIterable ? t$5.booleanLiteral(true) : null,
          STEP_KEY: t$5.identifier(stepKey),
          OBJECT: node.right,
          BODY: buildLoopBody(path, declar)
        });
        const container = builder.getContainer(nodes);
        t$5.inherits(container[0], node);
        t$5.inherits(container[0].body, node.body);
        if (t$5.isLabeledStatement(parent)) {
          container[0] = t$5.labeledStatement(parent.label, container[0]);
          path.parentPath.replaceWithMultiple(nodes);
          path.skip();
        } else path.replaceWithMultiple(nodes);
      }
    }
  };
});

var transformFunctionName = declare(api => {
  api.assertVersion(7);
  const supportUnicodeId = !isRequired("transform-unicode-escapes", api.targets());
  return {
    name: "transform-function-name",
    visitor: {
      FunctionExpression: {
        exit(path) {
          if (path.key !== "value" && !path.parentPath.isObjectProperty()) {
            const replacement = nameFunction(path);
            replacement && path.replaceWith(replacement);
          }
        }
      },
      ObjectProperty(path) {
        const value = path.get("value");
        if (value.isFunction()) {
          const newNode = nameFunction(value, false, supportUnicodeId);
          newNode && value.replaceWith(newNode);
        }
      }
    }
  };
});

var transformInstanceof = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-instanceof",
    visitor: {
      BinaryExpression(path) {
        const { node } = path;
        if (node.operator === "instanceof") {
          const helper = this.addHelper("instanceof");
          if (
            path.findParent(path =>
              (path.isVariableDeclarator() && path.node.id === helper) ||
              (path.isFunctionDeclaration() && path.node.id && path.node.id.name === helper.name)
            )
          )
            return;

          path.replaceWith(t$5.callExpression(helper, [node.left, node.right]));
        }
      }
    }
  };
});

var transformJscript = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-jscript",
    visitor: {
      FunctionExpression: {
        exit(path) {
          const { node } = path;
          node.id &&
            path.replaceWith(t$5.callExpression(t$5.functionExpression(
              null, [], t$5.blockStatement([t$5.toStatement(node), t$5.returnStatement(t$5.cloneNode(node.id))])
            ), []));
        }
      }
    }
  };
});

var transformLiterals = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-literals",
    visitor: {
      NumericLiteral({ node }) {
        if (node.extra && /^0[ob]/i.test(node.extra.raw)) node.extra = void 0;
      },
      StringLiteral({ node }) {
        if (node.extra && /\\[u]/gi.test(node.extra.raw)) node.extra = void 0;
      }
    }
  };
});

var transformMemberExpressionLiterals = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-member-expression-literals",
    visitor: {
      MemberExpression: {
        exit({ node }) {
          const prop = node.property;
          if (!node.computed && t$5.isIdentifier(prop) && !t$5.isValidES3Identifier(prop.name)) {
            node.property = t$5.stringLiteral(prop.name);
            node.computed = true;
          }
        }
      }
    }
  };
});

const buildWrapper$1 = template$1.statement(`
  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {
  })
`);
const buildAnonymousWrapper = template$1.statement(`
  define(["require"], function(REQUIRE) {
  })
`);
function injectWrapper(path, wrapper) {
  const { body, directives } = path.node;
  path.node.directives = [];
  path.node.body = [];
  const amdFactoryCallArgs = path.pushContainer("body", wrapper)[0].get("expression").get("arguments"),
    amdFactory = amdFactoryCallArgs[amdFactoryCallArgs.length - 1].get("body");
  amdFactory.pushContainer("directives", directives);
  amdFactory.pushContainer("body", body);
}
var transformModulesAmd = declare((api, options) => {
  var _api$assumption, _api$assumption2;
  api.assertVersion(7);
  const { allowTopLevelThis, strict, strictMode, importInterop, noInterop } = options,
    constantReexports =
      (_api$assumption = api.assumption("constantReexports")) != null ? _api$assumption : options.loose,
    enumerableModuleMeta =
      (_api$assumption2 = api.assumption("enumerableModuleMeta")) != null ? _api$assumption2 : options.loose;
  return {
    name: "transform-modules-amd",
    pre() {
      this.file.set("@babel/plugin-transform-modules-*", "amd");
    },
    visitor: {
      CallExpression(path, state) {
        if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
        if (!path.get("callee").isImport()) return;
        let { requireId, resolveId, rejectId } = state;
        if (!requireId) {
          requireId = path.scope.generateUidIdentifier("require");
          state.requireId = requireId;
        }
        if (!resolveId || !rejectId) {
          resolveId = path.scope.generateUidIdentifier("resolve");
          rejectId = path.scope.generateUidIdentifier("reject");
          state.resolveId = resolveId;
          state.rejectId = rejectId;
        }
        let result = t$5.identifier("imported");
        noInterop || (result = wrapInterop(path, result, "namespace"));
        path.replaceWith(
          buildDynamicImport(path.node, false, false, specifier => template$1.expression.ast`
              new Promise((${resolveId}, ${rejectId}) =>
                ${requireId}(
                  [${specifier}],
                  imported => ${t$5.cloneNode(resolveId)}(${result}),
                  ${t$5.cloneNode(rejectId)}
                )
              )
            `)
        );
      },
      Program: {
        exit(path, { requireId }) {
          if (!isModule(path)) {
            requireId && injectWrapper(path, buildAnonymousWrapper({ REQUIRE: t$5.cloneNode(requireId) }));

            return;
          }
          const amdArgs = [],
            importNames = [];
          if (requireId) {
            amdArgs.push(t$5.stringLiteral("require"));
            importNames.push(t$5.cloneNode(requireId));
          }
          let moduleName = getModuleName(this.file.opts, options);
          if (moduleName) moduleName = t$5.stringLiteral(moduleName);
          const { meta, headers } = rewriteModuleStatementsAndPrepareHeader(path, {
            enumerableModuleMeta,
            constantReexports,
            strict,
            strictMode,
            allowTopLevelThis,
            importInterop,
            noInterop,
            filename: this.file.opts.filename
          });
          if (hasExports(meta)) {
            amdArgs.push(t$5.stringLiteral("exports"));
            importNames.push(t$5.identifier(meta.exportName));
          }
          for (const [source, metadata] of meta.source) {
            amdArgs.push(t$5.stringLiteral(source));
            importNames.push(t$5.identifier(metadata.name));
            if (!isSideEffectImport(metadata)) {
              const interop = wrapInterop(path, t$5.identifier(metadata.name), metadata.interop);
              if (interop) {
                const header = t$5.expressionStatement(
                  t$5.assignmentExpression("=", t$5.identifier(metadata.name), interop)
                );
                header.loc = metadata.loc;
                headers.push(header);
              }
            }
            headers.push(...buildNamespaceInitStatements(meta, metadata, constantReexports));
          }
          ensureStatementsHoisted(headers);
          path.unshiftContainer("body", headers);
          injectWrapper(path, buildWrapper$1({
            MODULE_NAME: moduleName,
            AMD_ARGUMENTS: t$5.arrayExpression(amdArgs),
            IMPORT_NAMES: importNames
          }));
        }
      }
    }
  };
});

const { assignmentExpression, expressionStatement, identifier: identifier$1 } = t$5;
const visitor = {
  Scope(path, state) {
    state.kind !== "let" || path.skip();
  },
  FunctionParent(path) {
    path.skip();
  },
  VariableDeclaration(path, state) {
    if (state.kind && path.node.kind !== state.kind) return;
    const nodes = [],
      declarations = path.get("declarations");
    let firstId;
    for (const declar of declarations) {
      firstId = declar.node.id;
      declar.node.init &&
        nodes.push(expressionStatement(assignmentExpression("=", declar.node.id, declar.node.init)));

      for (const name of Object.keys(declar.getBindingIdentifiers()))
        state.emit(identifier$1(name), name, declar.node.init !== null);
    }
    path.parentPath.isFor({ left: path.node }) ? path.replaceWith(firstId) : path.replaceWithMultiple(nodes);
  }
};
function hoistVariables(path, emit, kind = "var") {
  path.traverse(visitor, { kind, emit });
}

const buildTemplate = template$1.statement(`
  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {
    "use strict";
    BEFORE_BODY;
    return { setters: SETTERS, execute: EXECUTE };
  });
`);
const buildExportAll = template$1.statement(`
  for (var KEY in TARGET)
    if (KEY !== "default" && KEY !== "__esModule") EXPORT_OBJ[KEY] = TARGET[KEY];
`);
const MISSING_PLUGIN_WARNING = `\
WARNING: Dynamic import() transformation must be enabled using the
         @babel/plugin-transform-dynamic-import plugin. Babel 8 will
         no longer transform import() without using that plugin.
`;
function getExportSpecifierName(node, stringSpecifiers) {
  if (node.type === "Identifier") return node.name;
  if (node.type === "StringLiteral") {
    const stringValue = node.value;
    common.isIdentifierName(stringValue) || stringSpecifiers.add(stringValue);

    return stringValue;
  }
  throw new Error("Expected export specifier to be either Identifier or StringLiteral, got " + node.type);
}
function constructExportCall(path, exportIdent, exportNames, exportValues, exportStarTarget, stringSpecifiers) {
  const statements = [];
  if (exportStarTarget) {
    const exportObj = path.scope.generateUid("exportObj");
    statements.push(
      t$5.variableDeclaration("var", [t$5.variableDeclarator(t$5.identifier(exportObj), t$5.objectExpression([]))])
    );
    statements.push(buildExportAll({
      KEY: path.scope.generateUidIdentifier("key"),
      EXPORT_OBJ: t$5.identifier(exportObj),
      TARGET: exportStarTarget
    }));
    for (let i = 0; i < exportNames.length; i++) {
      const exportName = exportNames[i],
        exportValue = exportValues[i];
      statements.push(
        t$5.expressionStatement(t$5.assignmentExpression(
          "=", t$5.memberExpression(t$5.identifier(exportObj), t$5.identifier(exportName)), exportValue
        ))
      );
    }
    statements.push(t$5.expressionStatement(t$5.callExpression(exportIdent, [t$5.identifier(exportObj)])));
  } else if (exportNames.length === 1)
    statements.push(
      t$5.expressionStatement(t$5.callExpression(exportIdent, [t$5.stringLiteral(exportNames[0]), exportValues[0]]))
    );
  else {
    const objectProperties = [];
    for (let i = 0; i < exportNames.length; i++) {
      const exportName = exportNames[i],
        exportValue = exportValues[i];
      objectProperties.push(t$5.objectProperty(
        stringSpecifiers.has(exportName) ? t$5.stringLiteral(exportName) : t$5.identifier(exportName),
        exportValue
      ));
    }
    statements.push(t$5.expressionStatement(t$5.callExpression(exportIdent, [t$5.objectExpression(objectProperties)])));
  }
  return statements;
}
var transformModulesSystemjs = declare((api, options) => {
  api.assertVersion(7);
  const { systemGlobal = "System", allowTopLevelThis = false } = options,
    reassignmentVisited = new WeakSet();
  const reassignmentVisitor = {
    "AssignmentExpression|UpdateExpression"(path) {
      if (reassignmentVisited.has(path.node)) return;
      reassignmentVisited.add(path.node);
      const arg = path.isAssignmentExpression() ? path.get("left") : path.get("argument");
      if (arg.isObjectPattern() || arg.isArrayPattern()) {
        const exprs = [path.node];
        for (const name of Object.keys(arg.getBindingIdentifiers())) {
          if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;

          const exportedNames = this.exports[name];
          if (exportedNames)
            for (const exportedName of exportedNames)
              exprs.push(this.buildCall(exportedName, t$5.identifier(name)).expression);
        }
        path.replaceWith(t$5.sequenceExpression(exprs));
        return;
      }
      if (!arg.isIdentifier()) return;
      const name = arg.node.name;
      if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;
      const exportedNames = this.exports[name];
      if (!exportedNames) return;
      let node = path.node;
      const isPostUpdateExpression = t$5.isUpdateExpression(node, { prefix: false });
      if (isPostUpdateExpression)
        node = t$5.binaryExpression(
          node.operator[0], t$5.unaryExpression("+", t$5.cloneNode(node.argument)), t$5.numericLiteral(1)
        );

      for (const exportedName of exportedNames) node = this.buildCall(exportedName, node).expression;

      if (isPostUpdateExpression) node = t$5.sequenceExpression([node, path.node]);

      path.replaceWith(node);
    }
  };
  return {
    name: "transform-modules-systemjs",
    pre() {
      this.file.set("@babel/plugin-transform-modules-*", "systemjs");
    },
    visitor: {
      CallExpression(path, state) {
        if (t$5.isImport(path.node.callee)) {
          this.file.has("@babel/plugin-proposal-dynamic-import") || console.warn(MISSING_PLUGIN_WARNING);

          path.replaceWith(buildDynamicImport(path.node, false, true, specifier =>
            t$5.callExpression(t$5.memberExpression(t$5.identifier(state.contextIdent), t$5.identifier("import")), [
              specifier
            ])
          ));
        }
      },
      MetaProperty(path, state) {
        path.node.meta.name !== "import" || path.node.property.name !== "meta" ||
          path.replaceWith(t$5.memberExpression(t$5.identifier(state.contextIdent), t$5.identifier("meta")));
      },
      ReferencedIdentifier(path, state) {
        path.node.name !== "__moduleName" || path.scope.hasBinding("__moduleName") ||
          path.replaceWith(t$5.memberExpression(t$5.identifier(state.contextIdent), t$5.identifier("id")));
      },
      Program: {
        enter(path, state) {
          state.contextIdent = path.scope.generateUid("context");
          state.stringSpecifiers = new Set();
          allowTopLevelThis || rewriteThis(path);
        },
        exit(path, state) {
          const scope = path.scope,
            exportIdent = scope.generateUid("export"),
            { contextIdent, stringSpecifiers } = state,
            exportMap = Object.create(null),
            modules = [],
            beforeBody = [],
            setters = [],
            sources = [],
            variableIds = [],
            removedPaths = [];
          function addExportName(key, val) {
            exportMap[key] = exportMap[key] || [];
            exportMap[key].push(val);
          }
          function pushModule(source, key, specifiers) {
            let module;
            modules.forEach(function (m) {
              if (m.key === source) module = m;
            });
            module || modules.push((module = { key: source, imports: [], exports: [] }));

            module[key] = module[key].concat(specifiers);
          }
          function buildExportCall(name, val) {
            return t$5.expressionStatement(
              t$5.callExpression(t$5.identifier(exportIdent), [t$5.stringLiteral(name), val])
            );
          }
          const exportNames = [],
            exportValues = [],
            body = path.get("body");
          for (const path of body)
            if (path.isFunctionDeclaration()) {
              beforeBody.push(path.node);
              removedPaths.push(path);
            } else if (path.isClassDeclaration()) {
              variableIds.push(t$5.cloneNode(path.node.id));
              path.replaceWith(t$5.expressionStatement(
                t$5.assignmentExpression("=", t$5.cloneNode(path.node.id), t$5.toExpression(path.node))
              ));
            } else if (path.isVariableDeclaration()) path.node.kind = "var";
            else if (path.isImportDeclaration()) {
              pushModule(path.node.source.value, "imports", path.node.specifiers);
              for (const name of Object.keys(path.getBindingIdentifiers())) {
                scope.removeBinding(name);
                variableIds.push(t$5.identifier(name));
              }
              path.remove();
            } else if (path.isExportAllDeclaration()) {
              pushModule(path.node.source.value, "exports", path.node);
              path.remove();
            } else if (path.isExportDefaultDeclaration()) {
              const declar = path.node.declaration;
              if (t$5.isClassDeclaration(declar)) {
                const id = declar.id;
                if (id) {
                  exportNames.push("default");
                  exportValues.push(scope.buildUndefinedNode());
                  variableIds.push(t$5.cloneNode(id));
                  addExportName(id.name, "default");
                  path.replaceWith(t$5.expressionStatement(
                    t$5.assignmentExpression("=", t$5.cloneNode(id), t$5.toExpression(declar))
                  ));
                } else {
                  exportNames.push("default");
                  exportValues.push(t$5.toExpression(declar));
                  removedPaths.push(path);
                }
              } else if (t$5.isFunctionDeclaration(declar)) {
                const id = declar.id;
                if (id) {
                  beforeBody.push(declar);
                  exportNames.push("default");
                  exportValues.push(t$5.cloneNode(id));
                  addExportName(id.name, "default");
                } else {
                  exportNames.push("default");
                  exportValues.push(t$5.toExpression(declar));
                }
                removedPaths.push(path);
              } else path.replaceWith(buildExportCall("default", declar));
            } else if (path.isExportNamedDeclaration()) {
              const declar = path.node.declaration;
              if (declar) {
                path.replaceWith(declar);
                if (t$5.isFunction(declar)) {
                  const name = declar.id.name;
                  addExportName(name, name);
                  beforeBody.push(declar);
                  exportNames.push(name);
                  exportValues.push(t$5.cloneNode(declar.id));
                  removedPaths.push(path);
                } else if (t$5.isClass(declar)) {
                  const name = declar.id.name;
                  exportNames.push(name);
                  exportValues.push(scope.buildUndefinedNode());
                  variableIds.push(t$5.cloneNode(declar.id));
                  path.replaceWith(t$5.expressionStatement(
                    t$5.assignmentExpression("=", t$5.cloneNode(declar.id), t$5.toExpression(declar))
                  ));
                  addExportName(name, name);
                } else {
                  if (t$5.isVariableDeclaration(declar)) declar.kind = "var";

                  for (const name of Object.keys(t$5.getBindingIdentifiers(declar))) addExportName(name, name);
                }
              } else {
                const specifiers = path.node.specifiers;
                if (specifiers != null && specifiers.length)
                  if (path.node.source) {
                    pushModule(path.node.source.value, "exports", specifiers);
                    path.remove();
                  } else {
                    const nodes = [];
                    for (const specifier of specifiers) {
                      const { local, exported } = specifier,
                        binding = scope.getBinding(local.name),
                        exportedName = getExportSpecifierName(exported, stringSpecifiers);
                      if (binding && t$5.isFunctionDeclaration(binding.path.node)) {
                        exportNames.push(exportedName);
                        exportValues.push(t$5.cloneNode(local));
                      } else binding || nodes.push(buildExportCall(exportedName, local));

                      addExportName(local.name, exportedName);
                    }
                    path.replaceWithMultiple(nodes);
                  }
                else path.remove();
              }
            }

          modules.forEach(function (specifiers) {
            const setterBody = [],
              target = scope.generateUid(specifiers.key);
            for (let specifier of specifiers.imports) {
              if (t$5.isImportNamespaceSpecifier(specifier))
                setterBody.push(
                  t$5.expressionStatement(t$5.assignmentExpression("=", specifier.local, t$5.identifier(target)))
                );
              else if (t$5.isImportDefaultSpecifier(specifier))
                specifier = t$5.importSpecifier(specifier.local, t$5.identifier("default"));

              if (t$5.isImportSpecifier(specifier)) {
                const { imported } = specifier;
                setterBody.push(t$5.expressionStatement(t$5.assignmentExpression(
                  "=", specifier.local,
                  t$5.memberExpression(t$5.identifier(target), specifier.imported, imported.type === "StringLiteral")
                )));
              }
            }
            if (specifiers.exports.length) {
              const exportNames = [],
                exportValues = [];
              let hasExportStar = false;
              for (const node of specifiers.exports)
                if (t$5.isExportAllDeclaration(node)) hasExportStar = true;
                else if (t$5.isExportSpecifier(node)) {
                  const exportedName = getExportSpecifierName(node.exported, stringSpecifiers);
                  exportNames.push(exportedName);
                  exportValues.push(
                    t$5.memberExpression(t$5.identifier(target), node.local, t$5.isStringLiteral(node.local))
                  );
                } //else;

              setterBody.push(...constructExportCall(
                path, t$5.identifier(exportIdent), exportNames, exportValues,
                hasExportStar ? t$5.identifier(target) : null, stringSpecifiers
              ));
            }
            sources.push(t$5.stringLiteral(specifiers.key));
            setters.push(t$5.functionExpression(null, [t$5.identifier(target)], t$5.blockStatement(setterBody)));
          });
          let moduleName = getModuleName(this.file.opts, options);
          if (moduleName) moduleName = t$5.stringLiteral(moduleName);
          hoistVariables(path, (id, name, hasInit) => {
            variableIds.push(id);
            if (!hasInit && name in exportMap)
              for (const exported of exportMap[name]) {
                exportNames.push(exported);
                exportValues.push(scope.buildUndefinedNode());
              }
          });
          variableIds.length &&
            beforeBody.unshift(t$5.variableDeclaration("var", variableIds.map(id => t$5.variableDeclarator(id))));

          exportNames.length &&
            beforeBody.push(...constructExportCall(
              path, t$5.identifier(exportIdent), exportNames, exportValues, null, stringSpecifiers
            ));

          path.traverse(reassignmentVisitor, { exports: exportMap, buildCall: buildExportCall, scope });
          for (const path of removedPaths) path.remove();

          let hasTLA = false;
          path.traverse({
            AwaitExpression(path) {
              hasTLA = true;
              path.stop();
            },
            Function(path) {
              path.skip();
            },
            noScope: true
          });
          path.node.body = [buildTemplate({
            SYSTEM_REGISTER: t$5.memberExpression(t$5.identifier(systemGlobal), t$5.identifier("register")),
            BEFORE_BODY: beforeBody,
            MODULE_NAME: moduleName,
            SETTERS: t$5.arrayExpression(setters),
            EXECUTE: t$5.functionExpression(null, [], t$5.blockStatement(path.node.body), false, hasTLA),
            SOURCES: t$5.arrayExpression(sources),
            EXPORT_IDENTIFIER: t$5.identifier(exportIdent),
            CONTEXT_IDENTIFIER: t$5.identifier(contextIdent)
          })];
        }
      }
    }
  };
});

const buildPrerequisiteAssignment = template$1.default(`
  GLOBAL_REFERENCE = GLOBAL_REFERENCE || {}
`);
const buildWrapper = template$1.default(`
  (function (global, factory) {
    if (typeof exports != "undefined") factory(COMMONJS_ARGUMENTS);
    else if (typeof define == "function" && define.amd) define(MODULE_NAME, AMD_ARGUMENTS, factory);
    else {
      var mod = { exports: {} };
      factory(BROWSER_ARGUMENTS);

      GLOBAL_TO_ASSIGN;
    }
  })(
    typeof globalThis != "undefined" ? globalThis : typeof self != "undefined" ? self : this,
    function(IMPORT_NAMES) {
  })
`);
var transformModulesUmd = declare((api, options) => {
  var _api$assumption, _api$assumption2;
  api.assertVersion(7);
  const { globals, exactGlobals, allowTopLevelThis, strict, strictMode, noInterop, importInterop } = options,
    constantReexports =
      (_api$assumption = api.assumption("constantReexports")) != null ? _api$assumption : options.loose,
    enumerableModuleMeta =
      (_api$assumption2 = api.assumption("enumerableModuleMeta")) != null ? _api$assumption2 : options.loose;
  function buildBrowserInit(browserGlobals, exactGlobals, filename, moduleName) {
    const moduleNameOrBasename = moduleName ? moduleName.value : path.basename(filename, path.extname(filename));
    let globalToAssign = t$5.memberExpression(
      t$5.identifier("global"), t$5.identifier(t$5.toIdentifier(moduleNameOrBasename))
    );
    let initAssignments = [];
    if (exactGlobals) {
      const globalName = browserGlobals[moduleNameOrBasename];
      if (globalName) {
        initAssignments = [];
        const members = globalName.split(".");
        globalToAssign = members.slice(1).reduce((accum, curr) => {
          initAssignments.push(buildPrerequisiteAssignment({ GLOBAL_REFERENCE: t$5.cloneNode(accum) }));
          return t$5.memberExpression(accum, t$5.identifier(curr));
        }, t$5.memberExpression(t$5.identifier("global"), t$5.identifier(members[0])));
      }
    }
    initAssignments.push(t$5.expressionStatement(t$5.assignmentExpression(
      "=", globalToAssign, t$5.memberExpression(t$5.identifier("mod"), t$5.identifier("exports"))
    )));
    return initAssignments;
  }
  function buildBrowserArg(browserGlobals, exactGlobals, source) {
    let memberExpression;
    if (exactGlobals) {
      const globalRef = browserGlobals[source];
      memberExpression = globalRef
        ? globalRef
            .split(".")
            .reduce((accum, curr) => t$5.memberExpression(accum, t$5.identifier(curr)), t$5.identifier("global"))
        : t$5.memberExpression(t$5.identifier("global"), t$5.identifier(t$5.toIdentifier(source)));
    } else {
      const requireName = path.basename(source, path.extname(source)),
        globalName = browserGlobals[requireName] || requireName;
      memberExpression = t$5.memberExpression(t$5.identifier("global"), t$5.identifier(t$5.toIdentifier(globalName)));
    }
    return memberExpression;
  }
  return {
    name: "transform-modules-umd",
    visitor: {
      Program: {
        exit(path) {
          if (!isModule(path)) return;
          const browserGlobals = globals || {},
            moduleName = getModuleName(this.file.opts, options);
          let moduleNameLiteral;
          if (moduleName) moduleNameLiteral = t$5.stringLiteral(moduleName);
          const { meta, headers } = rewriteModuleStatementsAndPrepareHeader(path, {
            constantReexports,
            enumerableModuleMeta,
            strict,
            strictMode,
            allowTopLevelThis,
            noInterop,
            importInterop,
            filename: this.file.opts.filename
          });
          const amdArgs = [],
            commonjsArgs = [],
            browserArgs = [],
            importNames = [];
          if (hasExports(meta)) {
            amdArgs.push(t$5.stringLiteral("exports"));
            commonjsArgs.push(t$5.identifier("exports"));
            browserArgs.push(t$5.memberExpression(t$5.identifier("mod"), t$5.identifier("exports")));
            importNames.push(t$5.identifier(meta.exportName));
          }
          for (const [source, metadata] of meta.source) {
            amdArgs.push(t$5.stringLiteral(source));
            commonjsArgs.push(t$5.callExpression(t$5.identifier("require"), [t$5.stringLiteral(source)]));
            browserArgs.push(buildBrowserArg(browserGlobals, exactGlobals, source));
            importNames.push(t$5.identifier(metadata.name));
            if (!isSideEffectImport(metadata)) {
              const interop = wrapInterop(path, t$5.identifier(metadata.name), metadata.interop);
              if (interop) {
                const header = t$5.expressionStatement(
                  t$5.assignmentExpression("=", t$5.identifier(metadata.name), interop)
                );
                header.loc = meta.loc;
                headers.push(header);
              }
            }
            headers.push(...buildNamespaceInitStatements(meta, metadata, constantReexports));
          }
          ensureStatementsHoisted(headers);
          path.unshiftContainer("body", headers);
          const { body, directives } = path.node;
          path.node.directives = [];
          path.node.body = [];
          const umdFactory = path.pushContainer("body", [
            buildWrapper({
              MODULE_NAME: moduleNameLiteral,
              AMD_ARGUMENTS: t$5.arrayExpression(amdArgs),
              COMMONJS_ARGUMENTS: commonjsArgs,
              BROWSER_ARGUMENTS: browserArgs,
              IMPORT_NAMES: importNames,
              GLOBAL_TO_ASSIGN: buildBrowserInit(
                browserGlobals, exactGlobals, this.filename || "unknown", moduleNameLiteral
              )
            })
          ])[0].get("expression.arguments")[1].get("body");
          umdFactory.pushContainer("directives", directives);
          umdFactory.pushContainer("body", body);
        }
      }
    }
  };
});

var transformNamedCapturingGroupsRegex = declare((api, options) => {
  const { runtime } = options;
  if (runtime !== void 0 && typeof runtime != "boolean") throw new Error("The 'runtime' option must be boolean");

  return createRegExpFeaturePlugin({
    name: "transform-named-capturing-groups-regex",
    feature: "namedCaptureGroups",
    options: { runtime }
  });
});

var transformNewTarget = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-new-target",
    visitor: {
      MetaProperty(path) {
        const meta = path.get("meta"),
          property = path.get("property"),
          { scope } = path;
        if (meta.isIdentifier({ name: "new" }) && property.isIdentifier({ name: "target" })) {
          const func = path.findParent(path => !(
            !path.isClass() &&
            (!path.isFunction() || path.isArrowFunctionExpression() || path.isClassMethod({ kind: "constructor" }))
          ));
          if (!func) throw path.buildCodeFrameError("new.target must be under a (non-arrow) function or a class.");

          const { node } = func;
          if (t$5.isMethod(node)) {
            path.replaceWith(scope.buildUndefinedNode());
            return;
          }
          const constructor = t$5.memberExpression(t$5.thisExpression(), t$5.identifier("constructor"));
          if (func.isClass()) {
            path.replaceWith(constructor);
            return;
          }
          if (node.id) {
            let scope = path.scope;
            const name = node.id.name;
            while (scope !== func.parentPath.scope) {
              !scope.hasOwnBinding(name) || scope.bindingIdentifierEquals(name, node.id) || scope.rename(name);

              scope = scope.parent;
            }
          } else node.id = scope.generateUidIdentifier("target");

          path.replaceWith(t$5.conditionalExpression(
            t$5.binaryExpression("instanceof", t$5.thisExpression(), t$5.cloneNode(node.id)),
            constructor, scope.buildUndefinedNode()
          ));
        }
      }
    }
  };
});

var transformObjectAssign = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-object-assign",
    visitor: {
      CallExpression: function (path, file) {
        if (path.get("callee").matchesPattern("Object.assign")) path.node.callee = file.addHelper("extends");
      }
    }
  };
});

function replacePropertySuper(path, getObjectRef, file) {
  new ReplaceSupers({ getObjectRef, methodPath: path, file }).replace();
}
var transformObjectSuper = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-object-super",
    visitor: {
      ObjectExpression(path, state) {
        let objectRef;
        const getObjectRef = () => (objectRef = objectRef || path.scope.generateUidIdentifier("obj"));
        path.get("properties").forEach(propPath => {
          propPath.isMethod() && replacePropertySuper(propPath, getObjectRef, state.file);
        });
        if (objectRef) {
          path.scope.push({ id: t$5.cloneNode(objectRef) });
          path.replaceWith(t$5.assignmentExpression("=", t$5.cloneNode(objectRef), path.node));
        }
      }
    }
  };
});

var transformObjectSetPrototypeOfToAssign = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-object-set-prototype-of-to-assign",
    visitor: {
      CallExpression(path, file) {
        if (path.get("callee").matchesPattern("Object.setPrototypeOf")) path.node.callee = file.addHelper("defaults");
      }
    }
  };
});

var transformPropertyLiterals = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-property-literals",
    visitor: {
      ObjectProperty: {
        exit({ node }) {
          const key = node.key;
          node.computed || !t$5.isIdentifier(key) || t$5.isValidES3Identifier(key.name) ||
            (node.key = t$5.stringLiteral(key.name));
        }
      }
    }
  };
});

function pushAccessor(mutatorMap, node) {
  const alias = t$5.toKeyAlias(node);
  var _mutatorMap$alias = mutatorMap[alias];
  const map = _mutatorMap$alias != null ? _mutatorMap$alias : (mutatorMap[alias] = { _inherits: [], _key: node.key });
  map._inherits.push(node);
  const value = t$5.functionExpression(null, node.params, node.body, node.generator, node.async);
  value.returnType = node.returnType;
  t$5.inheritsComments(value, node);
  map[node.kind] = value;
  return map;
}
function toDefineObject(mutatorMap) {
  const objExpr = t$5.objectExpression([]);
  Object.keys(mutatorMap).forEach(function (mutatorMapKey) {
    const map = mutatorMap[mutatorMapKey];
    map.configurable = t$5.booleanLiteral(true);
    map.enumerable = t$5.booleanLiteral(true);
    const mapNode = t$5.objectExpression([]),
      propNode = t$5.objectProperty(map._key, mapNode, map._computed);
    Object.keys(map).forEach(function (key) {
      const node = map[key];
      if (key[0] === "_") return;
      const prop = t$5.objectProperty(t$5.identifier(key), node);
      t$5.inheritsComments(prop, node);
      t$5.removeComments(node);
      mapNode.properties.push(prop);
    });
    objExpr.properties.push(propNode);
  });
  return objExpr;
}

var transformPropertyMutators = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-property-mutators",
    visitor: {
      ObjectExpression(path) {
        const { node } = path;
        let mutatorMap;
        const newProperties = node.properties.filter(function (prop) {
          if (t$5.isObjectMethod(prop) && !prop.computed && (prop.kind === "get" || prop.kind === "set")) {
            var _mutatorMap;
            pushAccessor((_mutatorMap = mutatorMap) != null ? _mutatorMap : (mutatorMap = {}), prop);
            return false;
          }
          return true;
        });
        if (mutatorMap === void 0) return;

        node.properties = newProperties;
        path.replaceWith(
          t$5.callExpression(t$5.memberExpression(t$5.identifier("Object"), t$5.identifier("defineProperties")), [
            node, toDefineObject(mutatorMap)
          ])
        );
      }
    }
  };
});

var transformProtoToAssign = declare(api => {
  api.assertVersion(7);
  function isProtoKey(node) {
    return !t$5.isSpreadElement(node) && t$5.isStringLiteral(t$5.toComputedKey(node, node.key), { value: "__proto__" });
  }
  function isProtoAssignmentExpression(node) {
    const left = node;
    return (
      t$5.isMemberExpression(left) &&
      t$5.isStringLiteral(t$5.toComputedKey(left, left.property), { value: "__proto__" })
    );
  }
  function buildDefaultsCallExpression(expr, ref, file) {
    return t$5.expressionStatement(t$5.callExpression(file.addHelper("defaults"), [ref, expr.right]));
  }
  return {
    name: "transform-proto-to-assign",
    visitor: {
      AssignmentExpression(path, { file }) {
        if (!isProtoAssignmentExpression(path.node.left)) return;
        const nodes = [],
          left = path.node.left.object,
          temp = path.scope.maybeGenerateMemoised(left);
        temp && nodes.push(t$5.expressionStatement(t$5.assignmentExpression("=", temp, left)));

        nodes.push(buildDefaultsCallExpression(path.node, t$5.cloneNode(temp || left), file));
        temp && nodes.push(t$5.cloneNode(temp));
        path.replaceWithMultiple(nodes);
      },
      ExpressionStatement(path, { file }) {
        const expr = path.node.expression;
        t$5.isAssignmentExpression(expr, { operator: "=" }) &&
          isProtoAssignmentExpression(expr.left) &&
          path.replaceWith(buildDefaultsCallExpression(expr, expr.left.object, file));
      },
      ObjectExpression(path, { file }) {
        let proto;
        const { node } = path,
          { properties } = node;
        for (let i = 0; i < properties.length; i++) {
          const prop = properties[i];
          if (isProtoKey(prop)) {
            proto = prop.value;
            properties.splice(i, 1);
            break;
          }
        }
        if (proto) {
          const args = [t$5.objectExpression([]), proto];
          node.properties.length && args.push(node);
          path.replaceWith(t$5.callExpression(file.addHelper("extends"), args));
        }
      }
    }
  };
});

var transformReactConstantElements = declare((api, options) => {
  api.assertVersion(7);
  const { allowMutablePropsOnTags } = options;
  if (allowMutablePropsOnTags != null && !Array.isArray(allowMutablePropsOnTags))
    throw new Error(".allowMutablePropsOnTags must be an array, null, or undefined.");

  const HOISTED = new WeakMap();
  function declares(node, scope) {
    if (
      t$5.isJSXIdentifier(node, { name: "this" }) ||
      t$5.isJSXIdentifier(node, { name: "arguments" }) ||
      t$5.isJSXIdentifier(node, { name: "super" }) ||
      t$5.isJSXIdentifier(node, { name: "new" })
    ) {
      const { path } = scope;
      return path.isFunctionParent() && !path.isArrowFunctionExpression();
    }
    return scope.hasOwnBinding(node.name);
  }
  function isHoistingScope({ path }) {
    return path.isFunctionParent() || path.isLoop() || path.isProgram();
  }
  function getHoistingScope(scope) {
    while (!isHoistingScope(scope)) scope = scope.parent;
    return scope;
  }
  const targetScopeVisitor = {
    ReferencedIdentifier(path, state) {
      const { node } = path;
      let { scope } = path;
      while (scope !== state.jsxScope) {
        if (declares(node, scope)) return;
        scope = scope.parent;
      }
      while (scope) {
        if (scope === state.targetScope) return;
        if (declares(node, scope)) break;
        scope = scope.parent;
      }
      state.targetScope = getHoistingScope(scope);
    }
  };
  const immutabilityVisitor = {
    enter(path, state) {
      var _expressionResult$deo;
      const stop = () => {
        state.isImmutable = false;
        path.stop();
      };
      const skip = () => {
        path.skip();
      };
      if (path.isJSXClosingElement()) {
        skip();
        return;
      }
      if (path.isJSXIdentifier({ name: "ref" }) && path.parentPath.isJSXAttribute({ name: path.node })) {
        stop();
        return;
      }
      if (path.isJSXIdentifier() || path.isJSXMemberExpression() || path.isJSXNamespacedName() || path.isImmutable())
        return;

      if (path.isIdentifier()) {
        const binding = path.scope.getBinding(path.node.name);
        if (binding && binding.constant) return;
      }
      const { mutablePropsAllowed } = state;
      if (mutablePropsAllowed && path.isFunction()) {
        path.traverse(targetScopeVisitor, state);
        skip();
        return;
      }
      if (!path.isPure()) {
        stop();
        return;
      }
      const expressionResult = path.evaluate();
      if (expressionResult.confident) {
        const { value } = expressionResult;
        if (mutablePropsAllowed || value === null || (typeof value != "object" && typeof value != "function")) {
          skip();
          return;
        }
      } else if ((_expressionResult$deo = expressionResult.deopt) != null && _expressionResult$deo.isIdentifier())
        return;

      stop();
    }
  };
  const hoistingVisitor = Object.assign({}, immutabilityVisitor, targetScopeVisitor);
  return {
    name: "transform-react-constant-elements",
    visitor: {
      JSXElement(path) {
        if (HOISTED.has(path.node)) return;
        const name = path.node.openingElement.name;
        let jsxScope,
          mutablePropsAllowed = false;
        if (allowMutablePropsOnTags != null) {
          let lastSegment = name;
          while (t$5.isJSXMemberExpression(lastSegment)) lastSegment = lastSegment.property;

          const elementName = lastSegment.name;
          mutablePropsAllowed = allowMutablePropsOnTags.includes(elementName);
        }
        for (let current = path; !jsxScope && current.parentPath.isJSX(); ) {
          current = current.parentPath;
          jsxScope = HOISTED.get(current.node);
        }
        jsxScope != null || (jsxScope = path.scope);
        HOISTED.set(path.node, jsxScope);
        const visitorState = {
          isImmutable: true,
          mutablePropsAllowed,
          jsxScope,
          targetScope: path.scope.getProgramParent()
        };
        path.traverse(hoistingVisitor, visitorState);
        if (!visitorState.isImmutable) return;
        const { targetScope } = visitorState;
        for (let currentScope = jsxScope; ; ) {
          if (targetScope === currentScope) return;
          if (isHoistingScope(currentScope)) break;
          currentScope = currentScope.parent;
          if (!currentScope)
            throw new Error(
              "Internal @babel/plugin-transform-react-constant-elements error: targetScope must be an ancestor of jsxScope. This is a Babel bug, please report it."
            );
        }
        const id = path.scope.generateUidBasedOnNode(name);
        targetScope.push({ id: t$5.identifier(id) });
        HOISTED.set(path.node, targetScope);
        let replacement = template$1.expression.ast`
          ${t$5.identifier(id)} || (${t$5.identifier(id)} = ${path.node})
        `;
        if (path.parentPath.isJSXElement() || path.parentPath.isJSXAttribute())
          replacement = t$5.jsxExpressionContainer(replacement);

        path.replaceWith(replacement);
      }
    }
  };
});

var transformReactDisplayName = declare(api => {
  api.assertVersion(7);
  function addDisplayName(id, call) {
    const props = call.arguments[0].properties;
    let safe = true;
    for (let i = 0; i < props.length; i++) {
      const prop = props[i];
      if (t$5.isSpreadElement(prop)) continue;

      const key = t$5.toComputedKey(prop);
      if (t$5.isStringLiteral(key, { value: "displayName" })) {
        safe = false;
        break;
      }
    }
    safe && props.unshift(t$5.objectProperty(t$5.identifier("displayName"), t$5.stringLiteral(id)));
  }
  const isCreateClassCallExpression = t$5.buildMatchMemberExpression("React.createClass"),
    isCreateClassAddon = callee => t$5.isIdentifier(callee, { name: "createReactClass" });
  function isCreateClass(node) {
    if (!node || !t$5.isCallExpression(node)) return false;
    if (!isCreateClassCallExpression(node.callee) && !isCreateClassAddon(node.callee)) return false;

    const args = node.arguments;
    if (args.length !== 1) return false;
    const first = args[0];
    return !!t$5.isObjectExpression(first);
  }
  return {
    name: "transform-react-display-name",
    visitor: {
      ExportDefaultDeclaration({ node }, state) {
        if (isCreateClass(node.declaration)) {
          const filename = state.filename || "unknown";
          let displayName = path.basename(filename, path.extname(filename));
          if (displayName === "index") displayName = path.basename(path.dirname(filename));

          addDisplayName(displayName, node.declaration);
        }
      },
      CallExpression(path) {
        const { node } = path;
        if (!isCreateClass(node)) return;
        let id;
        path.find(function (path) {
          if (path.isAssignmentExpression()) id = path.node.left;
          else if (path.isObjectProperty()) id = path.node.key;
          else if (path.isVariableDeclarator()) id = path.node.id;
          else if (path.isStatement()) return true;

          if (id) return true;
        });
        if (!id) return;
        if (t$5.isMemberExpression(id)) id = id.property;

        t$5.isIdentifier(id) && addDisplayName(id.name, node);
      }
    }
  };
});

const {
  booleanLiteral,
  callExpression,
  identifier,
  inherits,
  isIdentifier: isIdentifier$1,
  isJSXExpressionContainer,
  isJSXIdentifier,
  isJSXMemberExpression,
  isJSXNamespacedName,
  isJSXSpreadAttribute,
  isObjectExpression,
  isReferenced,
  isStringLiteral: isStringLiteral$1,
  isValidIdentifier,
  memberExpression,
  nullLiteral,
  objectExpression,
  objectProperty,
  react,
  spreadElement,
  stringLiteral,
  thisExpression
} = t$5;
function helper(opts) {
  const visitor = {
    JSXNamespacedName: function (path) {
      if (opts.throwIfNamespace)
        throw path.buildCodeFrameError(
          "Namespace tags are not supported by default. React's JSX doesn't support namespace tags. You can set `throwIfNamespace: false` to bypass this warning."
        );
    },
    JSXSpreadChild: function (path) {
      throw path.buildCodeFrameError("Spread children are not supported in React.");
    }
  };
  visitor.JSXElement = {
    exit(path, state) {
      const callExpr = buildElementCall(path, state);
      callExpr && path.replaceWith(inherits(callExpr, path.node));
    }
  };
  visitor.JSXFragment = {
    exit(path, state) {
      if (opts.compat) throw path.buildCodeFrameError("Fragment tags are only supported in React 16 and up.");

      const callExpr = buildFragmentCall(path, state);
      callExpr && path.replaceWith(inherits(callExpr, path.node));
    }
  };
  return visitor;
  function convertJSXIdentifier(node, parent) {
    if (isJSXIdentifier(node)) {
      if (node.name === "this" && isReferenced(node, parent)) return thisExpression();
      if (isValidIdentifier(node.name, false)) {
        node.type = "Identifier";
        return node;
      }

      return stringLiteral(node.name);
    }
    return isJSXMemberExpression(node)
      ? memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node))
      : isJSXNamespacedName(node)
      ? stringLiteral(`${node.namespace.name}:${node.name.name}`)
      : node;
  }
  function convertAttributeValue(node) {
    return isJSXExpressionContainer(node) ? node.expression : node;
  }
  function convertAttribute(node) {
    if (isJSXSpreadAttribute(node)) return spreadElement(node.argument);

    const value = convertAttributeValue(node.value || booleanLiteral(true));
    if (isStringLiteral$1(value) && !isJSXExpressionContainer(node.value)) {
      var _value$extra;
      value.value = value.value.replace(/\n\s+/g, " ");
      (_value$extra = value.extra) == null || delete _value$extra.raw;
    }
    isJSXNamespacedName(node.name)
      ? (node.name = stringLiteral(node.name.namespace.name + ":" + node.name.name.name))
      : isValidIdentifier(node.name.name, false)
      ? (node.name.type = "Identifier")
      : (node.name = stringLiteral(node.name.name));

    return inherits(objectProperty(node.name, value), node);
  }
  function buildElementCall(path, pass) {
    if (opts.filter && !opts.filter(path.node, pass)) return;
    const openingPath = path.get("openingElement");
    path.node.children = react.buildChildren(path.node);
    const tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node),
      args = [];
    let tagName;
    if (isIdentifier$1(tagExpr)) tagName = tagExpr.name;
    else if (isStringLiteral$1(tagExpr)) tagName = tagExpr.value;

    const state = { tagExpr, tagName, args, pure: false };
    opts.pre && opts.pre(state, pass);

    const attribs = openingPath.node.attributes;
    let convertedAttributes = attribs.length ? buildOpeningElementAttributes(attribs, pass) : nullLiteral();

    args.push(convertedAttributes, ...path.node.children);
    opts.post && opts.post(state, pass);

    const call = state.call || callExpression(state.callee, args);
    state.pure && annotateAsPure(call);
    return call;
  }
  function pushProps(_props, objs) {
    if (!_props.length) return _props;
    objs.push(objectExpression(_props));
    return [];
  }
  function buildOpeningElementAttributes(attribs, pass) {
    let _props = [];
    const objs = [],
      { useSpread = false } = pass.opts;
    if (typeof useSpread != "boolean")
      throw new Error("transform-react-jsx currently only accepts a boolean option for useSpread (defaults to false)");

    const useBuiltIns = pass.opts.useBuiltIns || false;
    if (typeof useBuiltIns != "boolean")
      throw new Error("transform-react-jsx currently only accepts a boolean option for useBuiltIns (defaults to false)");

    if (useSpread && useBuiltIns)
      throw new Error("transform-react-jsx currently only accepts useBuiltIns or useSpread but not both");

    if (useSpread) {
      const props = attribs.map(convertAttribute);
      return objectExpression(props);
    }
    while (attribs.length) {
      const prop = attribs.shift();
      if (isJSXSpreadAttribute(prop)) {
        _props = pushProps(_props, objs);
        objs.push(prop.argument);
      } else _props.push(convertAttribute(prop));
    }
    pushProps(_props, objs);
    let convertedAttribs;
    if (objs.length === 1) convertedAttribs = objs[0];
    else {
      isObjectExpression(objs[0]) || objs.unshift(objectExpression([]));

      const helper = useBuiltIns
        ? memberExpression(identifier("Object"), identifier("assign"))
        : pass.addHelper("extends");
      convertedAttribs = callExpression(helper, objs);
    }
    return convertedAttribs;
  }
  function buildFragmentCall(path, pass) {
    if (opts.filter && !opts.filter(path.node, pass)) return;
    path.node.children = react.buildChildren(path.node);
    const args = [],
      tagName = null,
      state = { tagExpr: pass.get("jsxFragIdentifier")(), tagName, args, pure: false };
    opts.pre && opts.pre(state, pass);

    args.push(nullLiteral(), ...path.node.children);
    opts.post && opts.post(state, pass);

    pass.set("usedFragment", true);
    const call = state.call || callExpression(state.callee, args);
    state.pure && annotateAsPure(call);
    return call;
  }
}

var transformReactInlineElements = declare(api => {
  api.assertVersion(7);
  function hasRefOrSpread(attrs) {
    for (let i = 0; i < attrs.length; i++) {
      const attr = attrs[i];
      if (t$5.isJSXSpreadAttribute(attr) || isJSXAttributeOfName(attr, "ref")) return true;
    }
    return false;
  }
  function isJSXAttributeOfName(attr, name) {
    return t$5.isJSXAttribute(attr) && t$5.isJSXIdentifier(attr.name, { name });
  }
  const visitor = helper({
    filter: node => node.type === "JSXElement" && !hasRefOrSpread(node.openingElement.attributes),
    pre(state) {
      const tagName = state.tagName,
        args = state.args;
      t$5.react.isCompatTag(tagName) ? args.push(t$5.stringLiteral(tagName)) : args.push(state.tagExpr);
    },
    post(state, pass) {
      state.callee = pass.addHelper("jsx");
      const props = state.args[1];
      let hasKey = false;
      if (t$5.isObjectExpression(props)) {
        const keyIndex = props.properties.findIndex(prop => t$5.isIdentifier(prop.key, { name: "key" }));
        if (keyIndex > -1) {
          state.args.splice(2, 0, props.properties[keyIndex].value);
          props.properties.splice(keyIndex, 1);
          hasKey = true;
        }
      } else t$5.isNullLiteral(props) && state.args.splice(1, 1, t$5.objectExpression([]));

      !hasKey && state.args.length > 2 && state.args.splice(2, 0, t$5.unaryExpression("void", t$5.numericLiteral(0)));

      state.pure = true;
    }
  });
  return { name: "transform-react-inline-elements", visitor };
});

const DEFAULT = {
  importSource: "react",
  runtime: "automatic",
  pragma: "React.createElement",
  pragmaFrag: "React.Fragment"
};
const JSX_SOURCE_ANNOTATION_REGEX = /^\s*\*?\s*@jsxImportSource\s+([^\s]+)\s*$/m,
  JSX_RUNTIME_ANNOTATION_REGEX = /^\s*\*?\s*@jsxRuntime\s+([^\s]+)\s*$/m,
  JSX_ANNOTATION_REGEX = /^\s*\*?\s*@jsx\s+([^\s]+)\s*$/m,
  JSX_FRAG_ANNOTATION_REGEX = /^\s*\*?\s*@jsxFrag\s+([^\s]+)\s*$/m,
  get = (pass, name) => pass.get("@babel/plugin-react-jsx/" + name),
  set = (pass, name, v) => pass.set("@babel/plugin-react-jsx/" + name, v);
function hasProto(node) {
  return node.properties.some(value =>
    t$5.isObjectProperty(value, { computed: false, shorthand: false }) &&
    (t$5.isIdentifier(value.key, { name: "__proto__" }) || t$5.isStringLiteral(value.key, { value: "__proto__" }))
  );
}
function createPlugin({ name, development }) {
  return declare((_, options) => {
    const {
      pure: PURE_ANNOTATION,
      throwIfNamespace = true,
      filter,
      runtime: RUNTIME_DEFAULT = development ? "automatic" : "classic",
      importSource: IMPORT_SOURCE_DEFAULT = DEFAULT.importSource,
      pragma: PRAGMA_DEFAULT = DEFAULT.pragma,
      pragmaFrag: PRAGMA_FRAG_DEFAULT = DEFAULT.pragmaFrag
    } = options;

    var { useSpread = false, useBuiltIns = false } = options;
    if (RUNTIME_DEFAULT === "classic") {
      if (typeof useSpread != "boolean")
        throw new Error("transform-react-jsx currently only accepts a boolean option for useSpread (defaults to false)");

      if (typeof useBuiltIns != "boolean")
        throw new Error(
          "transform-react-jsx currently only accepts a boolean option for useBuiltIns (defaults to false)"
        );

      if (useSpread && useBuiltIns)
        throw new Error("transform-react-jsx currently only accepts useBuiltIns or useSpread but not both");
    }

    const injectMetaPropertiesVisitor = {
      JSXOpeningElement(path, state) {
        const attributes = [];
        isThisAllowed(path.scope) &&
          attributes.push(
            t$5.jsxAttribute(t$5.jsxIdentifier("__self"), t$5.jsxExpressionContainer(t$5.thisExpression()))
          );

        attributes.push(
          t$5.jsxAttribute(t$5.jsxIdentifier("__source"), t$5.jsxExpressionContainer(makeSource(path, state)))
        );
        path.pushContainer("attributes", attributes);
      }
    };
    return {
      name,
      inherits: syntaxJsx,
      visitor: {
        JSXNamespacedName(path) {
          if (throwIfNamespace)
            throw path.buildCodeFrameError(
              "Namespace tags are not supported by default. React's JSX doesn't support namespace tags. You can set `throwIfNamespace: false` to bypass this warning."
            );
        },
        JSXSpreadChild(path) {
          throw path.buildCodeFrameError("Spread children are not supported in React.");
        },
        Program: {
          enter(path, state) {
            const { file } = state;
            let runtime = RUNTIME_DEFAULT,
              source = IMPORT_SOURCE_DEFAULT,
              pragma = PRAGMA_DEFAULT,
              pragmaFrag = PRAGMA_FRAG_DEFAULT,
              sourceSet = !!options.importSource,
              pragmaSet = !!options.pragma,
              pragmaFragSet = !!options.pragmaFrag;
            if (file.ast.comments)
              for (const comment of file.ast.comments) {
                const sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);
                if (sourceMatches) {
                  source = sourceMatches[1];
                  sourceSet = true;
                }
                const runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(comment.value);
                if (runtimeMatches) runtime = runtimeMatches[1];

                const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);
                if (jsxMatches) {
                  pragma = jsxMatches[1];
                  pragmaSet = true;
                }
                const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);
                if (jsxFragMatches) {
                  pragmaFrag = jsxFragMatches[1];
                  pragmaFragSet = true;
                }
              }

            set(state, "runtime", runtime);
            if (runtime === "classic") {
              if (sourceSet) throw path.buildCodeFrameError("importSource cannot be set when runtime is classic.");

              const createElement = toMemberExpression(pragma),
                fragment = toMemberExpression(pragmaFrag);
              set(state, "id/createElement", () => t$5.cloneNode(createElement));
              set(state, "id/fragment", () => t$5.cloneNode(fragment));
              set(state, "defaultPure", pragma === DEFAULT.pragma);
            } else if (runtime === "automatic") {
              if (pragmaSet || pragmaFragSet)
                throw path.buildCodeFrameError("pragma and pragmaFrag cannot be set when runtime is automatic.");

              const define = (name, id) => set(state, name, createImportLazily(state, path, id, source));
              define("id/jsx", development ? "jsxDEV" : "jsx");
              define("id/jsxs", development ? "jsxDEV" : "jsxs");
              define("id/createElement", "createElement");
              define("id/fragment", "Fragment");
              set(state, "defaultPure", source === DEFAULT.importSource);
            } else throw path.buildCodeFrameError('Runtime must be either "classic" or "automatic".');

            development && path.traverse(injectMetaPropertiesVisitor, state);
          }
        },
        JSXFragment: {
          exit(path, file) {
            let callExpr =
              get(file, "runtime") === "classic"
                ? buildCreateElementFragmentCall(path, file)
                : buildJSXFragmentCall(path, file);

            path.replaceWith(t$5.inherits(callExpr, path.node));
          }
        },
        JSXElement: {
          exit(path, file) {
            let callExpr =
              get(file, "runtime") === "classic" || shouldUseCreateElement(path)
                ? buildCreateElementCall(path, file)
                : buildJSXElementCall(path, file);

            path.replaceWith(t$5.inherits(callExpr, path.node));
          }
        },
        JSXAttribute(path) {
          if (t$5.isJSXElement(path.node.value)) path.node.value = t$5.jsxExpressionContainer(path.node.value);
        }
      }
    };
    function isDerivedClass(classPath) {
      return classPath.node.superClass !== null;
    }
    function isThisAllowed(scope) {
      do {
        const { path } = scope;
        if (path.isFunctionParent() && !path.isArrowFunctionExpression())
          return !path.isMethod() || path.node.kind !== "constructor" || !isDerivedClass(path.parentPath.parentPath);

        if (path.isTSModuleBlock()) return false;
      } while ((scope = scope.parent));
      return true;
    }
    function call(pass, name, args) {
      const node = t$5.callExpression(get(pass, "id/" + name)(), args);
      if (PURE_ANNOTATION != null ? PURE_ANNOTATION : get(pass, "defaultPure")) annotateAsPure(node);
      return node;
    }
    function shouldUseCreateElement(path) {
      const attributes = path.get("openingElement").node.attributes;
      let seenPropsSpread = false;
      for (let i = 0; i < attributes.length; i++) {
        const attr = attributes[i];
        if (seenPropsSpread && t$5.isJSXAttribute(attr) && attr.name.name === "key") return true;

        if (t$5.isJSXSpreadAttribute(attr)) seenPropsSpread = true;
      }
      return false;
    }
    function convertJSXIdentifier(node, parent) {
      if (t$5.isJSXIdentifier(node)) {
        if (node.name === "this" && t$5.isReferenced(node, parent)) return t$5.thisExpression();
        if (t$5.isValidIdentifier(node.name, false)) {
          node.type = "Identifier";
          return node;
        }

        return t$5.stringLiteral(node.name);
      }
      return t$5.isJSXMemberExpression(node)
        ? t$5.memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node))
        : t$5.isJSXNamespacedName(node)
        ? t$5.stringLiteral(`${node.namespace.name}:${node.name.name}`)
        : node;
    }
    function convertAttributeValue(node) {
      return t$5.isJSXExpressionContainer(node) ? node.expression : node;
    }
    function accumulateAttribute(array, attribute) {
      if (t$5.isJSXSpreadAttribute(attribute.node)) {
        const arg = attribute.node.argument;
        t$5.isObjectExpression(arg) && !hasProto(arg)
          ? array.push(...arg.properties)
          : array.push(t$5.spreadElement(arg));

        return array;
      }
      const value = convertAttributeValue(
        attribute.node.name.name !== "key" ? attribute.node.value || t$5.booleanLiteral(true) : attribute.node.value
      );
      if (attribute.node.name.name === "key" && value === null)
        throw attribute.buildCodeFrameError(
          'Please provide an explicit key value. Using "key" as a shorthand for "key={true}" is not allowed.'
        );

      if (t$5.isStringLiteral(value) && !t$5.isJSXExpressionContainer(attribute.node.value)) {
        var _value$extra;
        value.value = value.value.replace(/\n\s+/g, " ");
        (_value$extra = value.extra) == null || delete _value$extra.raw;
      }
      t$5.isJSXNamespacedName(attribute.node.name)
        ? (attribute.node.name = t$5.stringLiteral(
            attribute.node.name.namespace.name + ":" + attribute.node.name.name.name
          ))
        : t$5.isValidIdentifier(attribute.node.name.name, false)
        ? (attribute.node.name.type = "Identifier")
        : (attribute.node.name = t$5.stringLiteral(attribute.node.name.name));

      array.push(t$5.inherits(t$5.objectProperty(attribute.node.name, value), attribute.node));
      return array;
    }
    function buildChildrenProperty(children) {
      let childrenNode;
      if (children.length === 1) childrenNode = children[0];
      else if (children.length > 1) childrenNode = t$5.arrayExpression(children);
      else return void 0;

      return t$5.objectProperty(t$5.identifier("children"), childrenNode);
    }
    function buildJSXElementCall(path, file) {
      const openingPath = path.get("openingElement"),
        args = [getTag(openingPath)],
        attribsArray = [],
        extracted = Object.create(null);
      for (const attr of openingPath.get("attributes"))
        if (attr.isJSXAttribute() && t$5.isJSXIdentifier(attr.node.name)) {
          const { name } = attr.node.name;
          switch (name) {
            case "__source":
            case "__self":
              if (extracted[name]) throw sourceSelfError(path, name);
            case "key":
              const keyValue = convertAttributeValue(attr.node.value);
              if (keyValue === null)
                throw attr.buildCodeFrameError(
                  'Please provide an explicit key value. Using "key" as a shorthand for "key={true}" is not allowed.'
                );

              extracted[name] = keyValue;
              break;

            default:
              attribsArray.push(attr);
          }
        } else attribsArray.push(attr);

      const children = t$5.react.buildChildren(path.node);
      let attribs =
        attribsArray.length || children.length
          ? buildJSXOpeningElementAttributes(attribsArray, children)
          : t$5.objectExpression([]);

      args.push(attribs);
      if (development) {
        var _extracted$key;
        args.push(
          (_extracted$key = extracted.key) != null ? _extracted$key : path.scope.buildUndefinedNode(),
          t$5.booleanLiteral(children.length > 1)
        );
        if (extracted.__source) {
          args.push(extracted.__source);
          extracted.__self && args.push(extracted.__self);
        } else extracted.__self && args.push(path.scope.buildUndefinedNode(), extracted.__self);
      } else extracted.key === void 0 || args.push(extracted.key);

      return call(file, children.length > 1 ? "jsxs" : "jsx", args);
    }
    function buildJSXOpeningElementAttributes(attribs, children) {
      const props = attribs.reduce(accumulateAttribute, []);
      (children == null ? void 0 : children.length) > 0 && props.push(buildChildrenProperty(children));

      return t$5.objectExpression(props);
    }
    function buildJSXFragmentCall(path, file) {
      const args = [get(file, "id/fragment")()],
        children = t$5.react.buildChildren(path.node);
      args.push(t$5.objectExpression(children.length > 0 ? [buildChildrenProperty(children)] : []));
      development && args.push(path.scope.buildUndefinedNode(), t$5.booleanLiteral(children.length > 1));

      return call(file, children.length > 1 ? "jsxs" : "jsx", args);
    }
    function buildCreateElementFragmentCall(path, file) {
      if (!filter || filter(path.node, file))
        return call(file, "createElement", [
          get(file, "id/fragment")(), t$5.nullLiteral(), ...t$5.react.buildChildren(path.node)
        ]);
    }
    function buildCreateElementCall(path, file) {
      const openingPath = path.get("openingElement");
      return call(file, "createElement", [
        getTag(openingPath),
        buildCreateElementOpeningElementAttributes(file, path, openingPath.get("attributes")),
        ...t$5.react.buildChildren(path.node)
      ]);
    }
    function getTag(openingPath) {
      const tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);
      let tagName;
      if (t$5.isIdentifier(tagExpr)) tagName = tagExpr.name;
      else if (t$5.isStringLiteral(tagExpr)) tagName = tagExpr.value;

      return t$5.react.isCompatTag(tagName) ? t$5.stringLiteral(tagName) : tagExpr;
    }
    function buildCreateElementOpeningElementAttributes(file, path, attribs) {
      const runtime = get(file, "runtime");

      if (runtime !== "automatic") {
        const objs = [],
          props = attribs.reduce(accumulateAttribute, []);
        if (!useSpread) {
          let start = 0;
          props.forEach((prop, i) => {
            if (t$5.isSpreadElement(prop)) {
              i > start && objs.push(t$5.objectExpression(props.slice(start, i)));

              objs.push(prop.argument);
              start = i + 1;
            }
          });
          props.length > start && objs.push(t$5.objectExpression(props.slice(start)));
        } else props.length && objs.push(t$5.objectExpression(props));

        if (!objs.length) return t$5.nullLiteral();

        if (!(objs.length !== 1 || (t$5.isSpreadElement(props[0]) && t$5.isObjectExpression(props[0].argument))))
          return objs[0];

        t$5.isObjectExpression(objs[0]) || objs.unshift(t$5.objectExpression([]));

        const helper = useBuiltIns
          ? t$5.memberExpression(t$5.identifier("Object"), t$5.identifier("assign"))
          : file.addHelper("extends");
        return t$5.callExpression(helper, objs);
      }

      const props = [],
        found = Object.create(null);
      for (const attr of attribs) {
        const { node } = attr,
          name = t$5.isJSXAttribute(node) && t$5.isJSXIdentifier(node.name) && node.name.name;
        if (runtime === "automatic" && (name === "__source" || name === "__self")) {
          if (found[name]) throw sourceSelfError(path, name);
          found[name] = true;
        }
        accumulateAttribute(props, attr);
      }
      return props.length === 1 && t$5.isSpreadElement(props[0]) && !t$5.isObjectExpression(props[0].argument)
        ? props[0].argument
        : props.length > 0 ? t$5.objectExpression(props) : t$5.nullLiteral();
    }
  });
  function getSource(source, importName) {
    switch (importName) {
      case "Fragment":
        return `${source}/${development ? "jsx-dev-runtime" : "jsx-runtime"}`;
      case "jsxDEV":
        return source + "/jsx-dev-runtime";
      case "jsx":
      case "jsxs":
        return source + "/jsx-runtime";
      case "createElement":
        return source;
    }
  }
  function createImportLazily(pass, path, importName, source) {
    return () => {
      const actualSource = getSource(source, importName);
      if (isModule(path)) {
        let reference = get(pass, "imports/" + importName);
        if (reference) return t$5.cloneNode(reference);
        reference = addNamed(path, importName, actualSource, {
          importedInterop: "uncompiled",
          importPosition: "after"
        });
        set(pass, "imports/" + importName, reference);
        return reference;
      }
      //{
      let reference = get(pass, "requires/" + actualSource);
      if (reference) reference = t$5.cloneNode(reference);
      else {
        reference = addNamespace(path, actualSource, { importedInterop: "uncompiled" });
        set(pass, "requires/" + actualSource, reference);
      }
      return t$5.memberExpression(reference, t$5.identifier(importName));
      //}
    };
  }
}
function toMemberExpression(id) {
  return id
    .split(".")
    .map(name => t$5.identifier(name))
    .reduce((object, property) => t$5.memberExpression(object, property));
}
function makeSource(path, state) {
  const location = path.node.loc;
  if (!location) return path.scope.buildUndefinedNode();

  if (!state.fileNameIdentifier) {
    const { filename = "" } = state,
      fileNameIdentifier = path.scope.generateUidIdentifier("_jsxFileName");
    path.scope.getProgramParent().push({ id: fileNameIdentifier, init: t$5.stringLiteral(filename) });
    state.fileNameIdentifier = fileNameIdentifier;
  }
  return makeTrace(t$5.cloneNode(state.fileNameIdentifier), location.start.line, location.start.column);
}
function makeTrace(fileNameIdentifier, lineNumber, column0Based) {
  const fileLineLiteral = lineNumber != null ? t$5.numericLiteral(lineNumber) : t$5.nullLiteral(),
    fileColumnLiteral = column0Based != null ? t$5.numericLiteral(column0Based + 1) : t$5.nullLiteral();
  return template$1.expression.ast`{
    fileName: ${fileNameIdentifier},
    lineNumber: ${fileLineLiteral},
    columnNumber: ${fileColumnLiteral}
  }`;
}
function sourceSelfError(path, name) {
  const pluginName = "transform-react-jsx-" + name.slice(2);
  return path.buildCodeFrameError(
    `Duplicate ${name} prop found. You are most likely using the deprecated ${pluginName} Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.`
  );
}

var transformReactJSX = createPlugin({ name: "transform-react-jsx", development: false });

var transformReactJsxCompat = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-react-jsx-compat",
    manipulateOptions(_, parserOpts) {
      parserOpts.plugins.push("jsx");
    },
    visitor: helper({
      pre(state) {
        state.callee = state.tagExpr;
      },
      post(state) {
        if (t$5.react.isCompatTag(state.tagName))
          state.call = t$5.callExpression(
            t$5.memberExpression(
              t$5.memberExpression(t$5.identifier("React"), t$5.identifier("DOM")),
              state.tagExpr, t$5.isLiteral(state.tagExpr)
            ),
            state.args
          );
      },
      compat: true
    })
  };
});

var transformReactJSXDevelopment = createPlugin({ name: "transform-react-jsx/development", development: true });

const TRACE_ID$1 = "__self";
function getThisFunctionParent(path) {
  let scope = path.scope;
  do {
    const { path } = scope;
    if (path.isFunctionParent() && !path.isArrowFunctionExpression()) return path;
  } while ((scope = scope.parent));
  return null;
}
function isDerivedClass(classPath) {
  return classPath.node.superClass !== null;
}
function isThisAllowed(path) {
  const parentMethodOrFunction = getThisFunctionParent(path);
  return (
    parentMethodOrFunction === null ||
    !parentMethodOrFunction.isMethod() ||
    parentMethodOrFunction.node.kind !== "constructor" ||
    !isDerivedClass(parentMethodOrFunction.parentPath.parentPath)
  );
}
var transformReactJsxSelf = declare(api => {
  api.assertVersion(7);
  const visitor = {
    JSXOpeningElement(path) {
      if (!isThisAllowed(path)) return;

      const node = path.node,
        id = t$5.jsxIdentifier(TRACE_ID$1),
        trace = t$5.thisExpression();
      node.attributes.push(t$5.jsxAttribute(id, t$5.jsxExpressionContainer(trace)));
    }
  };
  return {
    name: "transform-react-jsx-self",
    visitor: {
      Program(path) {
        path.traverse(visitor);
      }
    }
  };
});

const TRACE_ID = "__source",
  FILE_NAME_VAR = "_jsxFileName",
  createNodeFromNullish = (val, fn) => (val == null ? t$5.nullLiteral() : fn(val));
var transformReactJsxSource = declare(api => {
  api.assertVersion(7);
  function makeTrace(fileNameIdentifier, { line, column }) {
    const fileLineLiteral = createNodeFromNullish(line, t$5.numericLiteral),
      fileColumnLiteral = createNodeFromNullish(column, c => t$5.numericLiteral(c + 1));
    return template$1.expression.ast`{
      fileName: ${fileNameIdentifier},
      lineNumber: ${fileLineLiteral},
      columnNumber: ${fileColumnLiteral}
    }`;
  }
  const isSourceAttr = attr => t$5.isJSXAttribute(attr) && attr.name.name === TRACE_ID;
  return {
    name: "transform-react-jsx-source",
    visitor: {
      JSXOpeningElement(path, state) {
        const { node } = path;
        if (!node.loc || path.node.attributes.some(isSourceAttr)) return;

        if (!state.fileNameIdentifier) {
          const fileNameId = path.scope.generateUidIdentifier(FILE_NAME_VAR);
          state.fileNameIdentifier = fileNameId;
          path.scope.getProgramParent().push({ id: fileNameId, init: t$5.stringLiteral(state.filename || "") });
        }
        node.attributes.push(t$5.jsxAttribute(
          t$5.jsxIdentifier(TRACE_ID),
          t$5.jsxExpressionContainer(makeTrace(t$5.cloneNode(state.fileNameIdentifier), node.loc.start))
        ));
      }
    }
  };
});

let currentTypes = null;
function wrapWithTypes(types, fn) {
  return function (...args) {
    const oldTypes = currentTypes;
    currentTypes = types;
    try {
      return fn.apply(this, args);
    } finally {
      currentTypes = oldTypes;
    }
  };
}
function getTypes() {
  return currentTypes;
}
function runtimeProperty(name) {
  const t = getTypes();
  return t.memberExpression(t.identifier("regeneratorRuntime"), t.identifier(name), false);
}
function isReference(path) {
  return path.isReferenced() || path.parentPath.isAssignmentExpression({ left: path.node });
}
function replaceWithOrRemove(path, replacement) {
  replacement ? path.replaceWith(replacement) : path.remove();
}

let hasOwn$2 = Object.prototype.hasOwnProperty;
function hoist$1(funPath) {
  const t = getTypes();
  t.assertFunction(funPath.node);
  let vars = {};
  function varDeclToExpr({ node: vdec, scope }, includeIdentifiers) {
    t.assertVariableDeclaration(vdec);
    let exprs = [];
    vdec.declarations.forEach(function (dec) {
      vars[dec.id.name] = t.identifier(dec.id.name);
      scope.removeBinding(dec.id.name);
      dec.init ? exprs.push(t.assignmentExpression("=", dec.id, dec.init)) : includeIdentifiers && exprs.push(dec.id);
    });
    return exprs.length === 0 ? null : exprs.length === 1 ? exprs[0] : t.sequenceExpression(exprs);
  }
  funPath.get("body").traverse({
    VariableDeclaration: {
      exit: function (path) {
        let expr = varDeclToExpr(path, false);
        expr === null ? path.remove() : replaceWithOrRemove(path, t.expressionStatement(expr));

        path.skip();
      }
    },
    ForStatement: function (path) {
      let init = path.get("init");
      init.isVariableDeclaration() && replaceWithOrRemove(init, varDeclToExpr(init, false));
    },
    ForXStatement: function (path) {
      let left = path.get("left");
      left.isVariableDeclaration() && replaceWithOrRemove(left, varDeclToExpr(left, true));
    },
    FunctionDeclaration: function (path) {
      let node = path.node;
      vars[node.id.name] = node.id;
      let assignment = t.expressionStatement(t.assignmentExpression(
        "=", t.clone(node.id),
        t.functionExpression(
          path.scope.generateUidIdentifierBasedOnNode(node), node.params, node.body, node.generator, node.expression
        )
      ));
      if (path.parentPath.isBlockStatement()) {
        path.parentPath.unshiftContainer("body", assignment);
        path.remove();
      } else replaceWithOrRemove(path, assignment);

      path.scope.removeBinding(node.id.name);
      path.skip();
    },
    FunctionExpression: function (path) {
      path.skip();
    },
    ArrowFunctionExpression: function (path) {
      path.skip();
    }
  });
  let paramNames = {};
  funPath.get("params").forEach(function (paramPath) {
    let param = paramPath.node;
    if (t.isIdentifier(param)) paramNames[param.name] = param;
  });
  let declarations = [];
  Object.keys(vars).forEach(function (name) {
    hasOwn$2.call(paramNames, name) || declarations.push(t.variableDeclarator(vars[name], null));
  });

  return declarations.length === 0 ? null : t.variableDeclaration("var", declarations);
}

function Entry() {
  assert.ok(this instanceof Entry);
}
function FunctionEntry(returnLoc) {
  Entry.call(this);
  getTypes().assertLiteral(returnLoc);
  this.returnLoc = returnLoc;
}
util.inherits(FunctionEntry, Entry);
function LoopEntry(breakLoc, continueLoc, label) {
  Entry.call(this);
  const t = getTypes();
  t.assertLiteral(breakLoc);
  t.assertLiteral(continueLoc);
  label ? t.assertIdentifier(label) : (label = null);

  this.breakLoc = breakLoc;
  this.continueLoc = continueLoc;
  this.label = label;
}
util.inherits(LoopEntry, Entry);
function SwitchEntry(breakLoc) {
  Entry.call(this);
  getTypes().assertLiteral(breakLoc);
  this.breakLoc = breakLoc;
}
util.inherits(SwitchEntry, Entry);
function TryEntry(firstLoc, catchEntry, finallyEntry) {
  Entry.call(this);
  getTypes().assertLiteral(firstLoc);
  catchEntry ? assert.ok(catchEntry instanceof CatchEntry) : (catchEntry = null);

  finallyEntry ? assert.ok(finallyEntry instanceof FinallyEntry) : (finallyEntry = null);

  assert.ok(catchEntry || finallyEntry);
  this.firstLoc = firstLoc;
  this.catchEntry = catchEntry;
  this.finallyEntry = finallyEntry;
}
util.inherits(TryEntry, Entry);
function CatchEntry(firstLoc, paramId) {
  Entry.call(this);
  const t = getTypes();
  t.assertLiteral(firstLoc);
  t.assertIdentifier(paramId);
  this.firstLoc = firstLoc;
  this.paramId = paramId;
}
util.inherits(CatchEntry, Entry);
function FinallyEntry(firstLoc, afterLoc) {
  Entry.call(this);
  const t = getTypes();
  t.assertLiteral(firstLoc);
  t.assertLiteral(afterLoc);
  this.firstLoc = firstLoc;
  this.afterLoc = afterLoc;
}
util.inherits(FinallyEntry, Entry);
function LabeledEntry(breakLoc, label) {
  Entry.call(this);
  const t = getTypes();
  t.assertLiteral(breakLoc);
  t.assertIdentifier(label);
  this.breakLoc = breakLoc;
  this.label = label;
}
util.inherits(LabeledEntry, Entry);
function LeapManager(emitter) {
  assert.ok(this instanceof LeapManager);
  assert.ok(emitter instanceof Emitter);
  this.emitter = emitter;
  this.entryStack = [new FunctionEntry(emitter.finalLoc)];
}
let LMp = LeapManager.prototype;
LMp.withEntry = function (entry, callback) {
  assert.ok(entry instanceof Entry);
  this.entryStack.push(entry);
  try {
    callback.call(this.emitter);
  } finally {
    let popped = this.entryStack.pop();
    assert.strictEqual(popped, entry);
  }
};
LMp._findLeapLocation = function (property, label) {
  for (let i = this.entryStack.length - 1; i >= 0; --i) {
    let entry = this.entryStack[i],
      loc = entry[property];
    if (loc)
      if (label) {
        if (entry.label && entry.label.name === label.name) return loc;
      } else if (!(entry instanceof LabeledEntry)) return loc;
  }
  return null;
};
LMp.getBreakLoc = function (label) {
  return this._findLeapLocation("breakLoc", label);
};
LMp.getContinueLoc = function (label) {
  return this._findLeapLocation("continueLoc", label);
};

const mMap = new WeakMap();
function m(node) {
  mMap.has(node) || mMap.set(node, {});

  return mMap.get(node);
}
const hasOwn$1 = Object.prototype.hasOwnProperty;
function makePredicate(propertyName, knownTypes) {
  function onlyChildren(node) {
    const t = getTypes();
    t.assertNode(node);
    let result = false;
    function check(child) {
      if (result);
      else if (Array.isArray(child)) child.some(check);
      else if (t.isNode(child)) {
        assert.strictEqual(result, false);
        result = predicate(child);
      }
      return result;
    }
    let keys = t.VISITOR_KEYS[node.type];
    if (keys) for (let i = 0; i < keys.length; i++) check(node[keys[i]]);

    return result;
  }
  function predicate(node) {
    getTypes().assertNode(node);
    let meta = m(node);
    return hasOwn$1.call(meta, propertyName) ? meta[propertyName]
      : hasOwn$1.call(opaqueTypes, node.type) ? (meta[propertyName] = false)
      : hasOwn$1.call(knownTypes, node.type) ? (meta[propertyName] = true)
      : (meta[propertyName] = onlyChildren(node));
  }
  predicate.onlyChildren = onlyChildren;
  return predicate;
}
let opaqueTypes = {
  FunctionExpression: true,
  ArrowFunctionExpression: true
};
let sideEffectTypes = {
  CallExpression: true,
  ForInStatement: true,
  UnaryExpression: true,
  BinaryExpression: true,
  AssignmentExpression: true,
  UpdateExpression: true,
  NewExpression: true
};
let leapTypes = {
  YieldExpression: true,
  BreakStatement: true,
  ContinueStatement: true,
  ReturnStatement: true,
  ThrowStatement: true
};
for (let type in leapTypes) if (hasOwn$1.call(leapTypes, type)) sideEffectTypes[type] = leapTypes[type];

makePredicate("hasSideEffects", sideEffectTypes);
const containsLeap = makePredicate("containsLeap", leapTypes);

let hasOwn = Object.prototype.hasOwnProperty;
function Emitter(contextId) {
  assert.ok(this instanceof Emitter);
  getTypes().assertIdentifier(contextId);
  this.nextTempId = 0;
  this.contextId = contextId;
  this.listing = [];
  this.marked = [true];
  this.insertedLocs = new Set();
  this.finalLoc = this.loc();
  this.tryEntries = [];
  this.leapManager = new LeapManager(this);
}
let Ep = Emitter.prototype;
const PENDING_LOCATION = Number.MAX_VALUE;
Ep.loc = function () {
  const l = getTypes().numericLiteral(PENDING_LOCATION);
  this.insertedLocs.add(l);
  return l;
};
Ep.getInsertedLocs = function () {
  return this.insertedLocs;
};
Ep.getContextId = function () {
  return getTypes().clone(this.contextId);
};
Ep.mark = function (loc) {
  getTypes().assertLiteral(loc);
  let index = this.listing.length;
  loc.value === PENDING_LOCATION ? (loc.value = index) : assert.strictEqual(loc.value, index);

  this.marked[index] = true;
  return loc;
};
Ep.emit = function (node) {
  const t = getTypes();
  if (t.isExpression(node)) node = t.expressionStatement(node);

  t.assertStatement(node);
  this.listing.push(node);
};
Ep.emitAssign = function (lhs, rhs) {
  this.emit(this.assign(lhs, rhs));
  return lhs;
};
Ep.assign = function (lhs, rhs) {
  const t = getTypes();
  return t.expressionStatement(t.assignmentExpression("=", t.cloneDeep(lhs), rhs));
};
Ep.contextProperty = function (name, computed) {
  const t = getTypes();
  return t.memberExpression(this.getContextId(), computed ? t.stringLiteral(name) : t.identifier(name), !!computed);
};
Ep.stop = function (rval) {
  rval && this.setReturnValue(rval);

  this.jump(this.finalLoc);
};
Ep.setReturnValue = function (valuePath) {
  getTypes().assertExpression(valuePath.value);
  this.emitAssign(this.contextProperty("rval"), this.explodeExpression(valuePath));
};
Ep.clearPendingException = function (tryLoc, assignee) {
  const t = getTypes();
  t.assertLiteral(tryLoc);
  let catchCall = t.callExpression(this.contextProperty("catch", true), [t.clone(tryLoc)]);
  assignee ? this.emitAssign(assignee, catchCall) : this.emit(catchCall);
};
Ep.jump = function (toLoc) {
  this.emitAssign(this.contextProperty("next"), toLoc);
  this.emit(getTypes().breakStatement());
};
Ep.jumpIf = function (test, toLoc) {
  const t = getTypes();
  t.assertExpression(test);
  t.assertLiteral(toLoc);
  this.emit(
    t.ifStatement(test, t.blockStatement([this.assign(this.contextProperty("next"), toLoc), t.breakStatement()]))
  );
};
Ep.jumpIfNot = function (test, toLoc) {
  const t = getTypes();
  t.assertExpression(test);
  t.assertLiteral(toLoc);
  let negatedTest = t.isUnaryExpression(test) && test.operator === "!" ? test.argument : t.unaryExpression("!", test);

  this.emit(
    t.ifStatement(negatedTest, t.blockStatement([this.assign(this.contextProperty("next"), toLoc), t.breakStatement()]))
  );
};
Ep.makeTempVar = function () {
  return this.contextProperty("t" + this.nextTempId++);
};
Ep.getContextFunction = function (id) {
  const t = getTypes();
  return t.functionExpression(
    id || null, [this.getContextId()], t.blockStatement([this.getDispatchLoop()]), false, false
  );
};
Ep.getDispatchLoop = function () {
  const self = this,
    t = getTypes();
  let current,
    cases = [],
    alreadyEnded = false;
  self.listing.forEach(function (stmt, i) {
    if (self.marked.hasOwnProperty(i)) {
      cases.push(t.switchCase(t.numericLiteral(i), (current = [])));
      alreadyEnded = false;
    }
    if (!alreadyEnded) {
      current.push(stmt);
      if (t.isCompletionStatement(stmt)) alreadyEnded = true;
    }
  });
  this.finalLoc.value = this.listing.length;
  cases.push(
    t.switchCase(this.finalLoc, []),
    t.switchCase(t.stringLiteral("end"), [t.returnStatement(t.callExpression(this.contextProperty("stop"), []))])
  );
  return t.whileStatement(
    t.numericLiteral(1),
    t.switchStatement(t.assignmentExpression("=", this.contextProperty("prev"), this.contextProperty("next")), cases)
  );
};
Ep.getTryLocsList = function () {
  if (this.tryEntries.length === 0) return null;

  const t = getTypes();
  let lastLocValue = 0;
  return t.arrayExpression(this.tryEntries.map(function (tryEntry) {
    let thisLocValue = tryEntry.firstLoc.value;
    assert.ok(thisLocValue >= lastLocValue, "try entries out of order");
    lastLocValue = thisLocValue;
    let ce = tryEntry.catchEntry,
      fe = tryEntry.finallyEntry,
      locs = [tryEntry.firstLoc, ce ? ce.firstLoc : null];
    if (fe) {
      locs[2] = fe.firstLoc;
      locs[3] = fe.afterLoc;
    }
    return t.arrayExpression(locs.map(loc => loc && t.clone(loc)));
  }));
};
Ep.explode = function (path, ignoreResult) {
  const t = getTypes();
  let node = path.node,
    self = this;
  t.assertNode(node);
  if (t.isDeclaration(node)) throw getDeclError(node);
  if (t.isStatement(node)) return self.explodeStatement(path);
  if (t.isExpression(node)) return self.explodeExpression(path, ignoreResult);
  switch (node.type) {
    case "Program":
      return path.get("body").map(self.explodeStatement, self);
    case "VariableDeclarator":
      throw getDeclError(node);
    case "Property":
    case "SwitchCase":
    case "CatchClause":
      throw new Error(node.type + " nodes should be handled by their parents");
    default:
      throw new Error("unknown Node of type " + JSON.stringify(node.type));
  }
};
function getDeclError(node) {
  return new Error(
    "all declarations should have been transformed into assignments before the Exploder began its work: " +
      JSON.stringify(node)
  );
}
Ep.explodeStatement = function (path, labelId) {
  const t = getTypes();
  let stmt = path.node,
    self = this;
  let before, after, head;
  t.assertStatement(stmt);
  labelId ? t.assertIdentifier(labelId) : (labelId = null);

  if (t.isBlockStatement(stmt)) {
    path.get("body").forEach(function (path) {
      self.explodeStatement(path);
    });
    return;
  }
  if (!containsLeap(stmt)) {
    self.emit(stmt);
    return;
  }
  switch (stmt.type) {
    case "ExpressionStatement":
      self.explodeExpression(path.get("expression"), true);
      break;
    case "LabeledStatement":
      after = this.loc();
      self.leapManager.withEntry(new LabeledEntry(after, stmt.label), function () {
        self.explodeStatement(path.get("body"), stmt.label);
      });
      self.mark(after);
      break;
    case "WhileStatement":
      before = this.loc();
      after = this.loc();
      self.mark(before);
      self.jumpIfNot(self.explodeExpression(path.get("test")), after);
      self.leapManager.withEntry(new LoopEntry(after, before, labelId), function () {
        self.explodeStatement(path.get("body"));
      });
      self.jump(before);
      self.mark(after);
      break;
    case "DoWhileStatement":
      let first = this.loc(),
        test = this.loc();
      after = this.loc();
      self.mark(first);
      self.leapManager.withEntry(new LoopEntry(after, test, labelId), function () {
        self.explode(path.get("body"));
      });
      self.mark(test);
      self.jumpIf(self.explodeExpression(path.get("test")), first);
      self.mark(after);
      break;
    case "ForStatement":
      head = this.loc();
      let update = this.loc();
      after = this.loc();
      stmt.init && self.explode(path.get("init"), true);

      self.mark(head);
      stmt.test && self.jumpIfNot(self.explodeExpression(path.get("test")), after);

      self.leapManager.withEntry(new LoopEntry(after, update, labelId), function () {
        self.explodeStatement(path.get("body"));
      });
      self.mark(update);
      stmt.update && self.explode(path.get("update"), true);

      self.jump(head);
      self.mark(after);
      break;
    case "TypeCastExpression":
      return self.explodeExpression(path.get("expression"));
    case "ForInStatement":
      head = this.loc();
      after = this.loc();
      let keyIterNextFn = self.makeTempVar();
      self.emitAssign(
        keyIterNextFn, t.callExpression(runtimeProperty("keys"), [self.explodeExpression(path.get("right"))])
      );
      self.mark(head);
      let keyInfoTmpVar = self.makeTempVar();
      self.jumpIf(
        t.memberExpression(
          t.assignmentExpression("=", keyInfoTmpVar, t.callExpression(t.cloneDeep(keyIterNextFn), [])),
          t.identifier("done"), false
        ),
        after
      );
      self.emitAssign(stmt.left, t.memberExpression(t.cloneDeep(keyInfoTmpVar), t.identifier("value"), false));
      self.leapManager.withEntry(new LoopEntry(after, head, labelId), function () {
        self.explodeStatement(path.get("body"));
      });
      self.jump(head);
      self.mark(after);
      break;
    case "BreakStatement":
      self.emitAbruptCompletion({ type: "break", target: self.leapManager.getBreakLoc(stmt.label) });
      break;
    case "ContinueStatement":
      self.emitAbruptCompletion({ type: "continue", target: self.leapManager.getContinueLoc(stmt.label) });
      break;
    case "SwitchStatement":
      let disc = self.emitAssign(self.makeTempVar(), self.explodeExpression(path.get("discriminant")));
      after = this.loc();
      let defaultLoc = this.loc(),
        condition = defaultLoc,
        caseLocs = [],
        cases = stmt.cases || [];
      for (let i = cases.length - 1; i >= 0; --i) {
        let c = cases[i];
        t.assertSwitchCase(c);
        c.test
          ? (condition = t.conditionalExpression(
              t.binaryExpression("===", t.cloneDeep(disc), c.test), (caseLocs[i] = this.loc()), condition
            ))
          : (caseLocs[i] = defaultLoc);
      }
      let discriminant = path.get("discriminant");
      replaceWithOrRemove(discriminant, condition);
      self.jump(self.explodeExpression(discriminant));
      self.leapManager.withEntry(new SwitchEntry(after), function () {
        path.get("cases").forEach(function (casePath) {
          let i = casePath.key;
          self.mark(caseLocs[i]);
          casePath.get("consequent").forEach(function (path) {
            self.explodeStatement(path);
          });
        });
      });
      self.mark(after);
      if (defaultLoc.value === PENDING_LOCATION) {
        self.mark(defaultLoc);
        assert.strictEqual(after.value, defaultLoc.value);
      }
      break;
    case "IfStatement":
      let elseLoc = stmt.alternate && this.loc();
      after = this.loc();
      self.jumpIfNot(self.explodeExpression(path.get("test")), elseLoc || after);
      self.explodeStatement(path.get("consequent"));
      if (elseLoc) {
        self.jump(after);
        self.mark(elseLoc);
        self.explodeStatement(path.get("alternate"));
      }
      self.mark(after);
      break;
    case "ReturnStatement":
      self.emitAbruptCompletion({ type: "return", value: self.explodeExpression(path.get("argument")) });
      break;
    case "WithStatement":
      throw new Error("WithStatement not supported in generator functions.");
    case "TryStatement":
      after = this.loc();
      let handler = stmt.handler,
        catchLoc = handler && this.loc(),
        catchEntry = catchLoc && new CatchEntry(catchLoc, handler.param),
        finallyLoc = stmt.finalizer && this.loc(),
        finallyEntry = finallyLoc && new FinallyEntry(finallyLoc, after),
        tryEntry = new TryEntry(self.getUnmarkedCurrentLoc(), catchEntry, finallyEntry);
      self.tryEntries.push(tryEntry);
      self.updateContextPrevLoc(tryEntry.firstLoc);
      self.leapManager.withEntry(tryEntry, function () {
        self.explodeStatement(path.get("block"));
        if (catchLoc) {
          finallyLoc ? self.jump(finallyLoc) : self.jump(after);

          self.updateContextPrevLoc(self.mark(catchLoc));
          let bodyPath = path.get("handler.body"),
            safeParam = self.makeTempVar();
          self.clearPendingException(tryEntry.firstLoc, safeParam);
          bodyPath.traverse(catchParamVisitor, {
            getSafeParam: () => t.cloneDeep(safeParam),
            catchParamName: handler.param.name
          });
          self.leapManager.withEntry(catchEntry, function () {
            self.explodeStatement(bodyPath);
          });
        }
        if (finallyLoc) {
          self.updateContextPrevLoc(self.mark(finallyLoc));
          self.leapManager.withEntry(finallyEntry, function () {
            self.explodeStatement(path.get("finalizer"));
          });
          self.emit(t.returnStatement(t.callExpression(self.contextProperty("finish"), [finallyEntry.firstLoc])));
        }
      });
      self.mark(after);
      break;
    case "ThrowStatement":
      self.emit(t.throwStatement(self.explodeExpression(path.get("argument"))));
      break;
    case "ClassDeclaration":
      self.emit(self.explodeClass(path));
      break;
    default:
      throw new Error("unknown Statement of type " + JSON.stringify(stmt.type));
  }
};
let catchParamVisitor = {
  Identifier: function (path, state) {
    path.node.name === state.catchParamName && isReference(path) && replaceWithOrRemove(path, state.getSafeParam());
  },
  Scope: function (path, state) {
    path.scope.hasOwnBinding(state.catchParamName) && path.skip();
  }
};
Ep.emitAbruptCompletion = function (record) {
  isValidCompletion(record) || assert.ok(false, "invalid completion record: " + JSON.stringify(record));

  assert.notStrictEqual(record.type, "normal", "normal completions are not abrupt");
  const t = getTypes();
  let abruptArgs = [t.stringLiteral(record.type)];
  if (record.type === "break" || record.type === "continue") {
    t.assertLiteral(record.target);
    abruptArgs[1] = this.insertedLocs.has(record.target) ? record.target : t.cloneDeep(record.target);
  } else if ((record.type === "return" || record.type === "throw") && record.value) {
    t.assertExpression(record.value);
    abruptArgs[1] = this.insertedLocs.has(record.value) ? record.value : t.cloneDeep(record.value);
  }
  this.emit(t.returnStatement(t.callExpression(this.contextProperty("abrupt"), abruptArgs)));
};
function isValidCompletion(record) {
  let type = record.type;
  return type === "normal"
    ? !hasOwn.call(record, "target")
    : type === "break" || type === "continue"
    ? !hasOwn.call(record, "value") && getTypes().isLiteral(record.target)
    : (type === "return" || type === "throw") && hasOwn.call(record, "value") && !hasOwn.call(record, "target");
}
Ep.getUnmarkedCurrentLoc = function () {
  return getTypes().numericLiteral(this.listing.length);
};
Ep.updateContextPrevLoc = function (loc) {
  const t = getTypes();
  if (loc) {
    t.assertLiteral(loc);
    loc.value === PENDING_LOCATION
      ? (loc.value = this.listing.length)
      : assert.strictEqual(loc.value, this.listing.length);
  } else loc = this.getUnmarkedCurrentLoc();

  this.emitAssign(this.contextProperty("prev"), loc);
};
Ep.explodeViaTempVar = function (tempVar, childPath, hasLeapingChildren, ignoreChildResult) {
  assert.ok(
    !ignoreChildResult || !tempVar,
    "Ignoring the result of a child expression but forcing it to be assigned to a temporary variable?"
  );
  const t = getTypes();
  let result = this.explodeExpression(childPath, ignoreChildResult);
  if (ignoreChildResult);
  else if (tempVar || (hasLeapingChildren && !t.isLiteral(result)))
    result = this.emitAssign(tempVar || this.makeTempVar(), result);

  return result;
};
Ep.explodeExpression = function (path, ignoreResult) {
  const t = getTypes();
  let expr = path.node;
  if (!expr) return expr;

  t.assertExpression(expr);

  let result,
    after,
    self = this;
  function finish(expr) {
    t.assertExpression(expr);
    ignoreResult && self.emit(expr);

    return expr;
  }
  if (!containsLeap(expr)) return finish(expr);

  let hasLeapingChildren = containsLeap.onlyChildren(expr);
  switch (expr.type) {
    case "MemberExpression":
      return finish(t.memberExpression(
        self.explodeExpression(path.get("object")),
        expr.computed ? self.explodeViaTempVar(null, path.get("property"), hasLeapingChildren) : expr.property,
        expr.computed
      ));
    case "CallExpression":
      let newCallee,
        newArgs,
        calleePath = path.get("callee"),
        argsPath = path.get("arguments"),
        hasLeapingArgs = argsPath.some(argPath => containsLeap(argPath.node)),
        injectFirstArg = null;
      if (t.isMemberExpression(calleePath.node))
        if (hasLeapingArgs) {
          let newObject = self.explodeViaTempVar(self.makeTempVar(), calleePath.get("object"), hasLeapingChildren);
          let newProperty = calleePath.node.computed
            ? self.explodeViaTempVar(null, calleePath.get("property"), hasLeapingChildren)
            : calleePath.node.property;
          injectFirstArg = newObject;
          newCallee = t.memberExpression(
            t.memberExpression(t.cloneDeep(newObject), newProperty, calleePath.node.computed),
            t.identifier("call"), false
          );
        } else newCallee = self.explodeExpression(calleePath);
      else {
        newCallee = self.explodeViaTempVar(null, calleePath, hasLeapingChildren);
        if (t.isMemberExpression(newCallee))
          newCallee = t.sequenceExpression([t.numericLiteral(0), t.cloneDeep(newCallee)]);
      }
      if (hasLeapingArgs) {
        newArgs = argsPath.map(argPath => self.explodeViaTempVar(null, argPath, hasLeapingChildren));
        injectFirstArg && newArgs.unshift(injectFirstArg);
        newArgs = newArgs.map(arg => t.cloneDeep(arg));
      } else newArgs = path.node.arguments;

      return finish(t.callExpression(newCallee, newArgs));
    case "NewExpression":
      return finish(t.newExpression(
        self.explodeViaTempVar(null, path.get("callee"), hasLeapingChildren),
        path.get("arguments").map(function (argPath) {
          return self.explodeViaTempVar(null, argPath, hasLeapingChildren);
        })
      ));
    case "ObjectExpression":
      return finish(t.objectExpression(
        path.get("properties").map(function (propPath) {
          return propPath.isObjectProperty()
            ? t.objectProperty(
                propPath.node.key,
                self.explodeViaTempVar(null, propPath.get("value"), hasLeapingChildren),
                propPath.node.computed
              )
            : propPath.node;
        })
      ));
    case "ArrayExpression":
      return finish(t.arrayExpression(
        path.get("elements").map(function (elemPath) {
          return !elemPath.node
            ? null
            : elemPath.isSpreadElement()
            ? t.spreadElement(self.explodeViaTempVar(null, elemPath.get("argument"), hasLeapingChildren))
            : self.explodeViaTempVar(null, elemPath, hasLeapingChildren);
        })
      ));
    case "SequenceExpression":
      let lastIndex = expr.expressions.length - 1;
      path.get("expressions").forEach(function (exprPath) {
        exprPath.key === lastIndex
          ? (result = self.explodeExpression(exprPath, ignoreResult))
          : self.explodeExpression(exprPath, true);
      });
      return result;
    case "LogicalExpression":
      after = this.loc();
      ignoreResult || (result = self.makeTempVar());

      let left = self.explodeViaTempVar(result, path.get("left"), hasLeapingChildren);
      if (expr.operator === "&&") self.jumpIfNot(left, after);
      else {
        assert.strictEqual(expr.operator, "||");
        self.jumpIf(left, after);
      }
      self.explodeViaTempVar(result, path.get("right"), hasLeapingChildren, ignoreResult);
      self.mark(after);
      return result;
    case "ConditionalExpression":
      let elseLoc = this.loc();
      after = this.loc();
      let test = self.explodeExpression(path.get("test"));
      self.jumpIfNot(test, elseLoc);
      ignoreResult || (result = self.makeTempVar());

      self.explodeViaTempVar(result, path.get("consequent"), hasLeapingChildren, ignoreResult);
      self.jump(after);
      self.mark(elseLoc);
      self.explodeViaTempVar(result, path.get("alternate"), hasLeapingChildren, ignoreResult);
      self.mark(after);
      return result;
    case "UnaryExpression":
      return finish(t.unaryExpression(expr.operator, self.explodeExpression(path.get("argument")), !!expr.prefix));
    case "BinaryExpression":
      return finish(t.binaryExpression(
        expr.operator,
        self.explodeViaTempVar(null, path.get("left"), hasLeapingChildren),
        self.explodeViaTempVar(null, path.get("right"), hasLeapingChildren)
      ));
    case "AssignmentExpression":
      if (expr.operator === "=")
        return finish(t.assignmentExpression(
          expr.operator, self.explodeExpression(path.get("left")), self.explodeExpression(path.get("right"))
        ));

      const lhs = self.explodeExpression(path.get("left")),
        temp = self.emitAssign(self.makeTempVar(), lhs);
      return finish(t.assignmentExpression(
        "=", t.cloneDeep(lhs),
        t.assignmentExpression(expr.operator, t.cloneDeep(temp), self.explodeExpression(path.get("right")))
      ));
    case "UpdateExpression":
      return finish(t.updateExpression(expr.operator, self.explodeExpression(path.get("argument")), expr.prefix));
    case "YieldExpression":
      after = this.loc();
      let arg = expr.argument && self.explodeExpression(path.get("argument"));
      if (arg && expr.delegate) {
        let result = self.makeTempVar();
        let ret = t.returnStatement(
          t.callExpression(self.contextProperty("delegateYield"), [arg, t.stringLiteral(result.property.name), after])
        );
        ret.loc = expr.loc;
        self.emit(ret);
        self.mark(after);
        return result;
      }
      self.emitAssign(self.contextProperty("next"), after);
      let ret = t.returnStatement(t.cloneDeep(arg) || null);
      ret.loc = expr.loc;
      self.emit(ret);
      self.mark(after);
      return self.contextProperty("sent");
    case "ClassExpression":
      return finish(self.explodeClass(path));
    default:
      throw new Error("unknown Expression of type " + JSON.stringify(expr.type));
  }
};
Ep.explodeClass = function (path) {
  const explodingChildren = [];
  path.node.superClass && explodingChildren.push(path.get("superClass"));

  path.get("body.body").forEach(member => {
    member.node.computed && explodingChildren.push(member.get("key"));
  });
  const hasLeapingChildren = explodingChildren.some(child => containsLeap(child));
  for (let i = 0; i < explodingChildren.length; i++) {
    const child = explodingChildren[i];
    i === explodingChildren.length - 1
      ? child.replaceWith(this.explodeExpression(child))
      : child.replaceWith(this.explodeViaTempVar(null, child, hasLeapingChildren));
  }
  return path.node;
};

function replaceShorthandObjectMethod(path) {
  const t = getTypes();
  if (!path.node || !t.isFunction(path.node))
    throw new Error("replaceShorthandObjectMethod can only be called on Function AST node paths.");

  if (!t.isObjectMethod(path.node) || !path.node.generator) return path;

  const parameters = path.node.params.map(function (param) {
    return t.cloneDeep(param);
  });
  const functionExpression = t.functionExpression(
    null, parameters, t.cloneDeep(path.node.body), path.node.generator, path.node.async
  );
  replaceWithOrRemove(
    path,
    t.objectProperty(t.cloneDeep(path.node.key), functionExpression, path.node.computed, false)
  );
  return path.get("value");
}

const getVisitor = ({ types: t }) => ({
  Method(path, state) {
    let node = path.node;
    if (!shouldRegenerate(node, state)) return;
    const container = t.functionExpression(null, [], t.cloneNode(node.body, false), node.generator, node.async);
    path.get("body").set("body", [t.returnStatement(t.callExpression(container, []))]);
    node.async = false;
    node.generator = false;
    path.get("body.body.0.argument.callee").unwrapFunctionEnvironment();
  },
  Function: {
    exit: wrapWithTypes(t, function (path, state) {
      let node = path.node;
      if (!shouldRegenerate(node, state)) return;
      node = (path = replaceShorthandObjectMethod(path)).node;
      let contextId = path.scope.generateUidIdentifier("context"),
        argsId = path.scope.generateUidIdentifier("args");
      path.ensureBlock();
      let bodyBlockPath = path.get("body");
      node.async && bodyBlockPath.traverse(awaitVisitor);

      bodyBlockPath.traverse(functionSentVisitor, { context: contextId });
      let outerBody = [],
        innerBody = [];
      bodyBlockPath.get("body").forEach(function (childPath) {
        let node = childPath.node;
        (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) || (node && node._blockHoist != null)
          ? outerBody.push(node)
          : innerBody.push(node);
      });
      if (outerBody.length > 0) bodyBlockPath.node.body = innerBody;

      let outerFnExpr = getOuterFnExpr(path);
      t.assertIdentifier(node.id);
      let innerFnId = t.identifier(node.id.name + "$"),
        vars = hoist$1(path),
        context = { usesThis: false, usesArguments: false, getArgsId: () => t.clone(argsId) };
      path.traverse(argumentsThisVisitor, context);
      if (context.usesArguments) {
        vars = vars || t.variableDeclaration("var", []);
        vars.declarations.push(t.variableDeclarator(t.clone(argsId), t.identifier("arguments")));
      }
      let emitter = new Emitter(contextId);
      emitter.explode(path.get("body"));
      vars && vars.declarations.length > 0 && outerBody.push(vars);

      let wrapArgs = [emitter.getContextFunction(innerFnId)],
        tryLocsList = emitter.getTryLocsList();
      node.generator
        ? wrapArgs.push(outerFnExpr)
        : (context.usesThis || tryLocsList || node.async) && wrapArgs.push(t.nullLiteral());

      context.usesThis
        ? wrapArgs.push(t.thisExpression())
        : (tryLocsList || node.async) && wrapArgs.push(t.nullLiteral());

      tryLocsList ? wrapArgs.push(tryLocsList) : node.async && wrapArgs.push(t.nullLiteral());

      if (node.async) {
        let currentScope = path.scope;
        do {
          currentScope.hasOwnBinding("Promise") && currentScope.rename("Promise");
        } while ((currentScope = currentScope.parent));
        wrapArgs.push(t.identifier("Promise"));
      }
      let wrapCall = t.callExpression(runtimeProperty(node.async ? "async" : "wrap"), wrapArgs);
      outerBody.push(t.returnStatement(wrapCall));
      node.body = t.blockStatement(outerBody);
      path.get("body.body").forEach(p => p.scope.registerDeclaration(p));
      const oldDirectives = bodyBlockPath.node.directives;
      if (oldDirectives) node.body.directives = oldDirectives;

      let wasGeneratorFunction = node.generator;
      if (wasGeneratorFunction) node.generator = false;

      if (node.async) node.async = false;

      if (wasGeneratorFunction && t.isExpression(node)) {
        replaceWithOrRemove(path, t.callExpression(runtimeProperty("mark"), [node]));
        path.addComment("leading", "#__PURE__");
      }
      const insertedLocs = emitter.getInsertedLocs();
      path.traverse({
        NumericLiteral(path) {
          insertedLocs.has(path.node) && path.replaceWith(t.numericLiteral(path.node.value));
        }
      });
      path.requeue();
    })
  }
});
function shouldRegenerate(node, state) {
  return node.generator
    ? node.async
      ? state.opts.asyncGenerators !== false
      : state.opts.generators !== false
    : !!node.async && state.opts.async !== false;
}
function getOuterFnExpr(funPath) {
  const t = getTypes();
  let node = funPath.node;
  t.assertFunction(node);
  node.id || (node.id = funPath.scope.parent.generateUidIdentifier("callee"));

  return node.generator && t.isFunctionDeclaration(node) ? getMarkedFunctionId(funPath) : t.clone(node.id);
}
const markInfo = new WeakMap();
function getMarkInfo(node) {
  markInfo.has(node) || markInfo.set(node, {});

  return markInfo.get(node);
}
function getMarkedFunctionId(funPath) {
  const t = getTypes(),
    node = funPath.node;
  t.assertIdentifier(node.id);
  const blockPath = funPath.findParent(function (path) {
    return path.isProgram() || path.isBlockStatement();
  });
  if (!blockPath) return node.id;

  const block = blockPath.node;
  assert.ok(Array.isArray(block.body));
  const info = getMarkInfo(block);
  if (!info.decl) {
    info.decl = t.variableDeclaration("var", []);
    blockPath.unshiftContainer("body", info.decl);
    info.declPath = blockPath.get("body.0");
  }
  assert.strictEqual(info.declPath.node, info.decl);
  const markedId = blockPath.scope.generateUidIdentifier("marked"),
    markCallExp = t.callExpression(runtimeProperty("mark"), [t.clone(node.id)]),
    index = info.decl.declarations.push(t.variableDeclarator(markedId, markCallExp)) - 1,
    markCallExpPath = info.declPath.get("declarations." + index + ".init");
  assert.strictEqual(markCallExpPath.node, markCallExp);
  markCallExpPath.addComment("leading", "#__PURE__");
  return t.clone(markedId);
}
let argumentsThisVisitor = {
  "FunctionExpression|FunctionDeclaration|Method": function (path) {
    path.skip();
  },
  Identifier: function (path, state) {
    if (path.node.name === "arguments" && isReference(path)) {
      replaceWithOrRemove(path, state.getArgsId());
      state.usesArguments = true;
    }
  },
  ThisExpression: function (path, state) {
    state.usesThis = true;
  }
};
let functionSentVisitor = {
  MetaProperty(path) {
    let { node } = path;
    if (node.meta.name === "function" && node.property.name === "sent") {
      const t = getTypes();
      replaceWithOrRemove(path, t.memberExpression(t.clone(this.context), t.identifier("_sent")));
    }
  }
};
let awaitVisitor = {
  Function: function (path) {
    path.skip();
  },
  AwaitExpression: function (path) {
    const t = getTypes();
    let argument = path.node.argument;
    replaceWithOrRemove(path, t.yieldExpression(t.callExpression(runtimeProperty("awrap"), [argument]), false));
  }
};

function regeneratorTransform(context) {
  const plugin = { visitor: getVisitor(context) },
    version = context && context.version;
  if (version && parseInt(version, 10) >= 7) plugin.name = "regenerator-transform";

  return plugin;
}

var transformRegenerator = declare(({ types: t, assertVersion }) => {
  assertVersion(7);
  return {
    name: "transform-regenerator",
    inherits: regeneratorTransform.default,
    visitor: {
      MemberExpression(path) {
        var _this$availableHelper = this.availableHelper;
        if (_this$availableHelper == null || !_this$availableHelper.call(this, "regeneratorRuntime")) return;

        const obj = path.get("object");
        if (obj.isIdentifier({ name: "regeneratorRuntime" })) {
          const helper = this.addHelper("regeneratorRuntime");

          if (t.isArrowFunctionExpression(helper)) {
            obj.replaceWith(helper.body);
            return;
          }

          obj.replaceWith(t.callExpression(helper, []));
        }
      }
    }
  };
});

var transformReservedWords = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-reserved-words",
    visitor: {
      "BindingIdentifier|ReferencedIdentifier"(path) {
        t$5.isValidES3Identifier(path.node.name) || path.scope.rename(path.node.name);
      }
    }
  };
});

function hasMinVersion$1(minVersion, runtimeVersion) {
  if (!runtimeVersion) return true;
  if (vendors.semver.valid(runtimeVersion)) runtimeVersion = "^" + runtimeVersion;
  return (
    !vendors.semver.intersects("<" + minVersion, runtimeVersion) && !vendors.semver.intersects(">=8.0.0", runtimeVersion)
  );
}

function getRuntimePath(moduleName, dirname, absoluteRuntime) {
  return absoluteRuntime === false
    ? moduleName
    : resolveAbsoluteRuntime(moduleName, path.resolve(dirname, absoluteRuntime === true ? "." : absoluteRuntime));
}
function resolveAbsoluteRuntime(moduleName, dirname) {
  try {
    return path.dirname(require.resolve(moduleName + "/package.json", { paths: [dirname] })).replace(/\\/g, "/");
  } catch (err) {
    if (err.code !== "MODULE_NOT_FOUND") throw err;
    throw Object.assign(new Error(`Failed to resolve "${moduleName}" relative to "${dirname}"`), {
      code: "BABEL_RUNTIME_NOT_FOUND",
      runtime: moduleName,
      dirname
    });
  }
}
function resolveFSPath(path) {
  return require.resolve(path).replace(/\\/g, "/");
}

const { types: t$1$1, template } = _babel;
function intersection$2(a, b) {
  const result = new Set();
  a.forEach(v => b.has(v) && result.add(v));
  return result;
}
function has$1$1(object, key) {
  return Object.prototype.hasOwnProperty.call(object, key);
}
function getType(target) {
  return Object.prototype.toString.call(target).slice(8, -1);
}
function resolveId(path) {
  if (path.isIdentifier() && !path.scope.hasBinding(path.node.name, true)) return path.node.name;

  const { deopt } = path.evaluate();
  return deopt && deopt.isIdentifier() ? deopt.node.name : void 0;
}
function resolveKey(path, computed = false) {
  const { scope } = path;
  if (path.isStringLiteral()) return path.node.value;
  const isIdentifier = path.isIdentifier();
  if (isIdentifier && !computed && !path.parent.computed) return path.node.name;

  if (
    computed && path.isMemberExpression() &&
    path.get("object").isIdentifier({ name: "Symbol" }) && !scope.hasBinding("Symbol", true)
  ) {
    const sym = resolveKey(path.get("property"), path.node.computed);
    if (sym) return "Symbol." + sym;
  }
  if (!isIdentifier || scope.hasBinding(path.node.name, true)) {
    const { value } = path.evaluate();
    if (typeof value == "string") return value;
  }
}
function resolveSource(obj) {
  if (obj.isMemberExpression() && obj.get("property").isIdentifier({ name: "prototype" })) {
    const id = resolveId(obj.get("object"));
    return id ? { id, placement: "prototype" } : { id: null, placement: null };
  }
  const id = resolveId(obj);
  if (id) return { id, placement: "static" };

  const { value } = obj.evaluate();
  return value !== void 0
    ? { id: getType(value), placement: "prototype" }
    : obj.isRegExpLiteral()
    ? { id: "RegExp", placement: "prototype" }
    : obj.isFunction()
    ? { id: "Function", placement: "prototype" }
    : { id: null, placement: null };
}
function getImportSource$1({ node }) {
  if (node.specifiers.length === 0) return node.source.value;
}
function getRequireSource$1({ node }) {
  if (!t$1$1.isExpressionStatement(node)) return;
  const { expression } = node;
  if (
    t$1$1.isCallExpression(expression) &&
    t$1$1.isIdentifier(expression.callee) && expression.callee.name === "require" &&
    expression.arguments.length === 1 && t$1$1.isStringLiteral(expression.arguments[0])
  )
    return expression.arguments[0].value;
}
function hoist(node) {
  node._blockHoist = 3;
  return node;
}
function createUtilsGetter(cache) {
  return path => {
    const prog = path.findParent(p => p.isProgram());
    return {
      injectGlobalImport(url) {
        cache.storeAnonymous(prog, url, (isScript, source) =>
          isScript ? template.statement.ast`require(${source})` : t$1$1.importDeclaration([], source)
        );
      },
      injectNamedImport: (url, name, hint = name) =>
        cache.storeNamed(prog, url, name, (isScript, source, name) => {
          const id = prog.scope.generateUidIdentifier(hint);
          return {
            node: isScript
              ? hoist(template.statement.ast`
                  var ${id} = require(${source}).${name}
                `)
              : t$1$1.importDeclaration([t$1$1.importSpecifier(id, name)], source),
            name: id.name
          };
        }),
      injectDefaultImport: (url, hint = url) =>
        cache.storeNamed(prog, url, "default", (isScript, source) => {
          const id = prog.scope.generateUidIdentifier(hint);
          return {
            node: isScript
              ? hoist(template.statement.ast`var ${id} = require(${source})`)
              : t$1$1.importDeclaration([t$1$1.importDefaultSpecifier(id)], source),
            name: id.name
          };
        })
    };
  };
}
const { types: t$4 } = _babel;
class ImportsCache {
  constructor(resolver) {
    this._imports = new WeakMap();
    this._anonymousImports = new WeakMap();
    this._lastImports = new WeakMap();
    this._resolver = resolver;
  }
  storeAnonymous(programPath, url, getVal) {
    const key = this._normalizeKey(programPath, url),
      imports = this._ensure(this._anonymousImports, programPath, Set);
    if (imports.has(key)) return;
    const node = getVal(programPath.node.sourceType === "script", t$4.stringLiteral(this._resolver(url)));
    imports.add(key);
    this._injectImport(programPath, node);
  }
  storeNamed(programPath, url, name, getVal) {
    const key = this._normalizeKey(programPath, url, name),
      imports = this._ensure(this._imports, programPath, Map);
    if (!imports.has(key)) {
      const { node, name: id } = getVal(
        programPath.node.sourceType === "script", t$4.stringLiteral(this._resolver(url)), t$4.identifier(name)
      );
      imports.set(key, id);
      this._injectImport(programPath, node);
    }
    return t$4.identifier(imports.get(key));
  }
  _injectImport(programPath, node) {
    const lastImport = this._lastImports.get(programPath);
    let newNodes =
      lastImport && lastImport.node && lastImport.parent === programPath.node &&
      lastImport.container === programPath.node.body
        ? lastImport.insertAfter(node)
        : programPath.unshiftContainer("body", node);

    const newNode = newNodes[newNodes.length - 1];
    this._lastImports.set(programPath, newNode);
  }
  _ensure(map, programPath, Collection) {
    let collection = map.get(programPath);
    if (!collection) {
      collection = new Collection();
      map.set(programPath, collection);
    }
    return collection;
  }
  _normalizeKey(programPath, url, name = "") {
    const { sourceType } = programPath.node;
    return `${name && sourceType}::${url}::${name}`;
  }
}
const presetEnvSilentDebugHeader = "#__secret_key__@babel/preset-env__don't_log_debug_header_and_resolved_targets";
function stringifyTargetsMultiline(targets) {
  return JSON.stringify(prettifyTargets(targets), null, 2);
}
function patternToRegExp(pattern) {
  if (pattern instanceof RegExp) return pattern;
  try {
    return new RegExp(`^${pattern}$`);
  } catch (_unused) {
    return null;
  }
}
function buildUnusedError(label, unused) {
  return unused.length
    ? `  - The following "${label}" patterns didn't match any polyfill:\n` +
        unused.map(original => `    ${String(original)}\n`).join("")
    : "";
}
function buldDuplicatesError(duplicates) {
  return duplicates.size
    ? '  - The following polyfills were matched both by "include" and "exclude" patterns:\n' +
        Array.from(duplicates, name => `    ${name}\n`).join("")
    : "";
}
function validateIncludeExclude(provider, polyfills, includePatterns, excludePatterns) {
  let current;
  const filter = pattern => {
    const regexp = patternToRegExp(pattern);
    if (!regexp) return false;
    let matched = false;
    for (const polyfill of polyfills)
      if (regexp.test(polyfill)) {
        matched = true;
        current.add(polyfill);
      }

    return !matched;
  };
  const include = (current = new Set()),
    unusedInclude = Array.from(includePatterns).filter(filter),
    exclude = (current = new Set()),
    unusedExclude = Array.from(excludePatterns).filter(filter),
    duplicates = intersection$2(include, exclude);
  if (duplicates.size > 0 || unusedInclude.length > 0 || unusedExclude.length > 0)
    throw new Error(
      `Error while validating the "${provider}" provider options:\n` +
        buildUnusedError("include", unusedInclude) +
        buildUnusedError("exclude", unusedExclude) +
        buldDuplicatesError(duplicates)
    );

  return { include, exclude };
}
function applyMissingDependenciesDefaults(options, babelApi) {
  const { missingDependencies = {} } = options;
  if (missingDependencies === false) return false;
  const caller = babelApi.caller(caller => (caller == null ? void 0 : caller.name));
  const {
    log = "deferred",
    inject = caller === "rollup-plugin-babel" ? "throw" : "import",
    all = false
  } = missingDependencies;
  return { log, inject, all };
}
var usage = callProvider => {
  function property(object, key, placement, path) {
    return callProvider({ kind: "property", object, key, placement }, path);
  }
  return {
    ReferencedIdentifier(path) {
      const { node: { name }, scope } = path;
      scope.getBindingIdentifier(name) || callProvider({ kind: "global", name }, path);
    },
    MemberExpression(path) {
      const key = resolveKey(path.get("property"), path.node.computed);
      if (!key || key === "prototype") return;
      const object = path.get("object");
      if (object.isIdentifier()) {
        const binding = object.scope.getBinding(object.node.name);
        if (binding && binding.path.isImportNamespaceSpecifier()) return;
      }
      const source = resolveSource(object);
      return property(source.id, key, source.placement, path);
    },
    ObjectPattern(path) {
      const { parentPath, parent } = path;
      let obj;
      if (parentPath.isVariableDeclarator()) obj = parentPath.get("init");
      else if (parentPath.isAssignmentExpression()) obj = parentPath.get("right");
      else if (parentPath.isFunction()) {
        const grand = parentPath.parentPath;
        if ((grand.isCallExpression() || grand.isNewExpression()) && grand.node.callee === parent)
          obj = grand.get("arguments")[path.key];
      }
      let id = null,
        placement = null;
      if (obj) ({ id, placement } = resolveSource(obj));
      for (const prop of path.get("properties"))
        if (prop.isObjectProperty()) {
          const key = resolveKey(prop.get("key"));
          key && property(id, key, placement, prop);
        }
    },
    BinaryExpression(path) {
      if (path.node.operator !== "in") return;
      const source = resolveSource(path.get("right")),
        key = resolveKey(path.get("left"), true);
      key && callProvider({ kind: "in", object: source.id, key, placement: source.placement }, path);
    }
  };
};
var entry = callProvider => ({
  ImportDeclaration(path) {
    const source = getImportSource$1(path);
    source && callProvider({ kind: "import", source }, path);
  },
  Program(path) {
    path.get("body").forEach(bodyPath => {
      const source = getRequireSource$1(bodyPath);
      source && callProvider({ kind: "import", source }, bodyPath);
    });
  }
});
function myResolve(name, basedir) {
  return require.resolve(name, { paths: [basedir] }).replace(/\\/g, "/");
}
function resolve(dirname, moduleName, absoluteImports) {
  if (absoluteImports === false) return moduleName;
  let basedir = dirname;
  if (typeof absoluteImports == "string") basedir = path.resolve(basedir, absoluteImports);

  try {
    return myResolve(moduleName, basedir);
  } catch (err) {
    if (err.code !== "MODULE_NOT_FOUND") throw err;
    throw Object.assign(new Error(`Failed to resolve "${moduleName}" relative to "${dirname}"`), {
      code: "BABEL_POLYFILL_NOT_FOUND",
      polyfill: moduleName,
      dirname
    });
  }
}
function has$3(basedir, name) {
  try {
    myResolve(name, basedir);
    return true;
  } catch (_unused2) {
    return false;
  }
}
function logMissing(missingDeps) {
  if (missingDeps.size === 0) return;
  const deps = Array.from(missingDeps).sort().join(" ");
  console.warn(`
Some polyfills have been added but are not present in your dependencies.
Please run one of the following commands:
\tnpm install --save ${deps}
\tyarn add ${deps}
`);
  process.exitCode = 1;
}
let allMissingDeps = new Set();
const laterLogMissingDependencies = () => setTimeout(() => {
  logMissing(allMissingDeps);
  allMissingDeps = new Set();
}, 100);
function laterLogMissing(missingDeps) {
  if (missingDeps.size === 0) return;
  missingDeps.forEach(name => allMissingDeps.add(name));
  laterLogMissingDependencies();
}
const PossibleGlobalObjects = new Set(["global", "globalThis", "self", "window"]);
function createMetaResolver(polyfills) {
  const { static: staticP, instance: instanceP, global: globalP } = polyfills;
  return meta => {
    if (meta.kind === "global" && globalP && has$1$1(globalP, meta.name))
      return { kind: "global", desc: globalP[meta.name], name: meta.name };

    if (meta.kind === "property" || meta.kind === "in") {
      const { placement, object, key } = meta;
      if (object && placement === "static") {
        if (globalP && PossibleGlobalObjects.has(object) && has$1$1(globalP, key))
          return { kind: "global", desc: globalP[key], name: key };

        if (staticP && has$1$1(staticP, object) && has$1$1(staticP[object], key))
          return { kind: "static", desc: staticP[object][key], name: `${object}$${key}` };
      }
      if (instanceP && has$1$1(instanceP, key)) return { kind: "instance", desc: instanceP[key], name: "" + key };
    }
  };
}
const getTargets = getTargets$1.default || getTargets$1;
function resolveOptions(options, babelApi) {
  const {
    method,
    targets: targetsOption,
    ignoreBrowserslistConfig,
    configPath,
    debug,
    shouldInjectPolyfill,
    absoluteImports
  } = options;
  const providerOptions = _objectWithoutPropertiesLoose(options, [
    "method", "targets", "ignoreBrowserslistConfig", "configPath", "debug", "shouldInjectPolyfill", "absoluteImports"
  ]);
  if (isEmpty(options))
    throw new Error(`\
This plugin requires options, for example:
    {
      "plugins": [
        ["<plugin name>", { method: "usage-pure" }]
      ]
    }

See more options at https://github.com/babel/babel-polyfills/blob/main/docs/usage.md`);

  let methodName, targets;
  if (method === "usage-global") methodName = "usageGlobal";
  else if (method === "entry-global") methodName = "entryGlobal";
  else if (method === "usage-pure") methodName = "usagePure";
  else
    throw typeof method != "string"
      ? new Error(".method must be a string")
      : new Error(
          `.method must be one of "entry-global", "usage-global" or "usage-pure" (received ${JSON.stringify(method)})`
        );

  if (typeof shouldInjectPolyfill == "function") {
    if (options.include || options.exclude)
      throw new Error(".include and .exclude are not supported when using the .shouldInjectPolyfill function.");
  } else if (shouldInjectPolyfill != null)
    throw new Error(
      `.shouldInjectPolyfill must be a function, or undefined (received ${JSON.stringify(shouldInjectPolyfill)})`
    );

  if (absoluteImports != null && typeof absoluteImports != "boolean" && typeof absoluteImports != "string")
    throw new Error(
      `.absoluteImports must be a boolean, a string, or undefined (received ${JSON.stringify(absoluteImports)})`
    );

  if (targetsOption || configPath || ignoreBrowserslistConfig) {
    const targetsObj =
      typeof targetsOption == "string" || Array.isArray(targetsOption) ? { browsers: targetsOption } : targetsOption;
    targets = getTargets(targetsObj, { ignoreBrowserslistConfig, configPath });
  } else targets = babelApi.targets();

  return {
    method,
    methodName,
    targets,
    absoluteImports: absoluteImports != null && absoluteImports,
    shouldInjectPolyfill,
    debug: !!debug,
    providerOptions
  };
}
function instantiateProvider(factory, options, missingDependencies, dirname, debugLog, babelApi) {
  const { method, methodName, targets, debug, shouldInjectPolyfill, providerOptions, absoluteImports } = resolveOptions(
    options,
    babelApi
  );
  const getUtils = createUtilsGetter(new ImportsCache(moduleName => resolve(dirname, moduleName, absoluteImports)));
  let include, exclude, polyfillsSupport, polyfillsNames, filterPolyfills;
  const depsCache = new Map();
  const api = {
    babel: babelApi,
    getUtils,
    method: options.method,
    targets,
    createMetaResolver,
    shouldInjectPolyfill(name) {
      if (polyfillsNames === void 0)
        throw new Error(
          `Internal error in the ${factory.name} provider: shouldInjectPolyfill() can't be called during initialization.`
        );

      polyfillsNames.has(name) ||
        console.warn(`Internal error in the ${providerName} provider: unknown polyfill "${name}".`);

      if (filterPolyfills && !filterPolyfills(name)) return false;
      let shouldInject = isRequired(name, targets, {
        compatData: polyfillsSupport,
        includes: include,
        excludes: exclude
      });
      if (shouldInjectPolyfill) {
        shouldInject = shouldInjectPolyfill(name, shouldInject);
        if (typeof shouldInject != "boolean") throw new Error(".shouldInjectPolyfill must return a boolean.");
      }
      return shouldInject;
    },
    debug(name) {
      var _debugLog;
      debugLog().found = true;
      if (!debug || !name || debugLog().polyfills.has(providerName)) return;
      debugLog().polyfills.add(name);
      (_debugLog = debugLog()).polyfillsSupport != null || (_debugLog.polyfillsSupport = polyfillsSupport);
    },
    assertDependency(name, version = "*") {
      if (missingDependencies === false || absoluteImports) return;

      const dep = version === "*" ? name : `${name}@^${version}`;
      (!missingDependencies.all && mapGetOr(depsCache, `${name} :: ${dirname}`, () => has$3(dirname, name))) ||
        debugLog().missingDeps.add(dep);
    }
  };
  const provider = factory(api, providerOptions, dirname),
    providerName = provider.name || factory.name;
  if (typeof provider[methodName] != "function")
    throw new Error(`The "${providerName}" provider doesn't support the "${method}" polyfilling method.`);

  if (Array.isArray(provider.polyfills)) {
    polyfillsNames = new Set(provider.polyfills);
    filterPolyfills = provider.filterPolyfills;
  } else if (provider.polyfills) {
    polyfillsNames = new Set(Object.keys(provider.polyfills));
    polyfillsSupport = provider.polyfills;
    filterPolyfills = provider.filterPolyfills;
  } else polyfillsNames = new Set();

  ({ include, exclude } = validateIncludeExclude(
    providerName, polyfillsNames, providerOptions.include || [], providerOptions.exclude || []
  ));
  return {
    debug,
    method,
    targets,
    provider,
    providerName,
    callProvider(payload, path) {
      const utils = getUtils(path);
      provider[methodName](payload, utils, path);
    }
  };
}
function definePolyfillProvider(factory) {
  return declare((babelApi, options, dirname) => {
    babelApi.assertVersion(7);
    const { traverse } = babelApi;
    let debugLog;
    const missingDependencies = applyMissingDependenciesDefaults(options, babelApi);
    const { debug, method, targets, provider, providerName, callProvider } = instantiateProvider(
      factory,
      options,
      missingDependencies,
      dirname,
      () => debugLog,
      babelApi
    );
    const createVisitor = method === "entry-global" ? entry : usage;
    const visitor = provider.visitor
      ? traverse.visitors.merge([createVisitor(callProvider), provider.visitor])
      : createVisitor(callProvider);
    if (debug && debug !== presetEnvSilentDebugHeader) {
      console.log(providerName + ": `DEBUG` option");
      console.log("\nUsing targets: " + stringifyTargetsMultiline(targets));
      console.log(`\nUsing polyfills with \`${method}\` method:`);
    }
    const { runtimeName } = provider;
    return {
      name: "inject-polyfills",
      visitor,
      pre(file) {
        var _provider$pre;
        if (runtimeName)
          if (file.get("runtimeHelpersModuleName") && file.get("runtimeHelpersModuleName") !== runtimeName)
            console.warn(
              `Two different polyfill providers (${file.get(
                "runtimeHelpersModuleProvider"
              )} and ${providerName}) are trying to define two conflicting @babel/runtime alternatives: ${file.get(
                "runtimeHelpersModuleName"
              )} and ${runtimeName}. The second one will be ignored.`
            );
          else {
            file.set("runtimeHelpersModuleName", runtimeName);
            file.set("runtimeHelpersModuleProvider", providerName);
          }

        debugLog = {
          polyfills: new Set(),
          polyfillsSupport: void 0,
          found: false,
          providers: new Set(),
          missingDeps: new Set()
        };
        (_provider$pre = provider.pre) == null || _provider$pre.apply(this, arguments);
      },
      post() {
        var _provider$post;
        (_provider$post = provider.post) == null || _provider$post.apply(this, arguments);
        if (missingDependencies !== false)
          missingDependencies.log === "per-file"
            ? logMissing(debugLog.missingDeps)
            : laterLogMissing(debugLog.missingDeps);

        if (!debug) return;
        this.filename && console.log(`\n[${this.filename}]`);
        if (debugLog.polyfills.size === 0) {
          console.log(
            method === "entry-global"
              ? debugLog.found
                ? `Based on your targets, the ${providerName} polyfill did not add any polyfill.`
                : `The entry point for the ${providerName} polyfill has not been found.`
              : `Based on your code and targets, the ${providerName} polyfill did not add any polyfill.`
          );
          return;
        }
        method === "entry-global"
          ? console.log(`The ${providerName} polyfill entry has been replaced with the following polyfills:`)
          : console.log(`The ${providerName} polyfill added the following polyfills:`);

        for (const name of debugLog.polyfills) {
          var _debugLog$polyfillsSu2;
          if ((_debugLog$polyfillsSu2 = debugLog.polyfillsSupport) != null && _debugLog$polyfillsSu2[name]) {
            const filteredTargets = getInclusionReasons(name, targets, debugLog.polyfillsSupport);
            const formattedTargets = JSON.stringify(filteredTargets)
              .replace(/,/g, ", ").replace(/^\{"/, '{ "').replace(/"\}$/, '" }');
            console.log(`  ${name} ${formattedTargets}`);
          } else console.log("  " + name);
        }
      }
    };
  });
}
function mapGetOr(map, key, getDefault) {
  let val = map.get(key);
  if (val === void 0) {
    val = getDefault();
    map.set(key, val);
  }
  return val;
}
function isEmpty(obj) {
  return Object.keys(obj).length === 0;
}

const define$1 = (name, pure, global = [], meta) => ({ name, pure, global, meta }),
  pureAndGlobal = (pure, global, minRuntimeVersion = null) => define$1(global[0], pure, global, { minRuntimeVersion }),
  globalOnly = global => define$1(global[0], null, global),
  pureOnly = (pure, name) => define$1(name, pure, []),
  ArrayNatureIterators$1 = ["es6.object.to-string", "es6.array.iterator", "web.dom.iterable"],
  CommonIterators$1 = ["es6.string.iterator", ...ArrayNatureIterators$1],
  PromiseDependencies$1 = ["es6.object.to-string", "es6.promise"];
const BuiltIns$1 = {
  DataView: globalOnly(["es6.typed.data-view"]),
  Float32Array: globalOnly(["es6.typed.float32-array"]),
  Float64Array: globalOnly(["es6.typed.float64-array"]),
  Int8Array: globalOnly(["es6.typed.int8-array"]),
  Int16Array: globalOnly(["es6.typed.int16-array"]),
  Int32Array: globalOnly(["es6.typed.int32-array"]),
  Map: pureAndGlobal("map", ["es6.map", ...CommonIterators$1]),
  Number: globalOnly(["es6.number.constructor"]),
  Promise: pureAndGlobal("promise", PromiseDependencies$1),
  RegExp: globalOnly(["es6.regexp.constructor"]),
  Set: pureAndGlobal("set", ["es6.set", ...CommonIterators$1]),
  Symbol: pureAndGlobal("symbol/index", ["es6.symbol"]),
  Uint8Array: globalOnly(["es6.typed.uint8-array"]),
  Uint8ClampedArray: globalOnly(["es6.typed.uint8-clamped-array"]),
  Uint16Array: globalOnly(["es6.typed.uint16-array"]),
  Uint32Array: globalOnly(["es6.typed.uint32-array"]),
  WeakMap: pureAndGlobal("weak-map", ["es6.weak-map", ...CommonIterators$1]),
  WeakSet: pureAndGlobal("weak-set", ["es6.weak-set", ...CommonIterators$1]),
  setImmediate: pureOnly("set-immediate", "web.immediate"),
  clearImmediate: pureOnly("clear-immediate", "web.immediate"),
  parseFloat: pureOnly("parse-float", "es6.parse-float"),
  parseInt: pureOnly("parse-int", "es6.parse-int")
};
const InstanceProperties$1 = {
  __defineGetter__: globalOnly(["es7.object.define-getter"]),
  __defineSetter__: globalOnly(["es7.object.define-setter"]),
  __lookupGetter__: globalOnly(["es7.object.lookup-getter"]),
  __lookupSetter__: globalOnly(["es7.object.lookup-setter"]),
  anchor: globalOnly(["es6.string.anchor"]),
  big: globalOnly(["es6.string.big"]),
  bind: globalOnly(["es6.function.bind"]),
  blink: globalOnly(["es6.string.blink"]),
  bold: globalOnly(["es6.string.bold"]),
  codePointAt: globalOnly(["es6.string.code-point-at"]),
  copyWithin: globalOnly(["es6.array.copy-within"]),
  endsWith: globalOnly(["es6.string.ends-with"]),
  entries: globalOnly(ArrayNatureIterators$1),
  every: globalOnly(["es6.array.every"]),
  fill: globalOnly(["es6.array.fill"]),
  filter: globalOnly(["es6.array.filter"]),
  finally: globalOnly(["es7.promise.finally", ...PromiseDependencies$1]),
  find: globalOnly(["es6.array.find"]),
  findIndex: globalOnly(["es6.array.find-index"]),
  fixed: globalOnly(["es6.string.fixed"]),
  flags: globalOnly(["es6.regexp.flags"]),
  flatMap: globalOnly(["es7.array.flat-map"]),
  fontcolor: globalOnly(["es6.string.fontcolor"]),
  fontsize: globalOnly(["es6.string.fontsize"]),
  forEach: globalOnly(["es6.array.for-each"]),
  includes: globalOnly(["es6.string.includes", "es7.array.includes"]),
  indexOf: globalOnly(["es6.array.index-of"]),
  italics: globalOnly(["es6.string.italics"]),
  keys: globalOnly(ArrayNatureIterators$1),
  lastIndexOf: globalOnly(["es6.array.last-index-of"]),
  link: globalOnly(["es6.string.link"]),
  map: globalOnly(["es6.array.map"]),
  match: globalOnly(["es6.regexp.match"]),
  name: globalOnly(["es6.function.name"]),
  padStart: globalOnly(["es7.string.pad-start"]),
  padEnd: globalOnly(["es7.string.pad-end"]),
  reduce: globalOnly(["es6.array.reduce"]),
  reduceRight: globalOnly(["es6.array.reduce-right"]),
  repeat: globalOnly(["es6.string.repeat"]),
  replace: globalOnly(["es6.regexp.replace"]),
  search: globalOnly(["es6.regexp.search"]),
  small: globalOnly(["es6.string.small"]),
  some: globalOnly(["es6.array.some"]),
  sort: globalOnly(["es6.array.sort"]),
  split: globalOnly(["es6.regexp.split"]),
  startsWith: globalOnly(["es6.string.starts-with"]),
  strike: globalOnly(["es6.string.strike"]),
  sub: globalOnly(["es6.string.sub"]),
  sup: globalOnly(["es6.string.sup"]),
  toISOString: globalOnly(["es6.date.to-iso-string"]),
  toJSON: globalOnly(["es6.date.to-json"]),
  toString: globalOnly(["es6.object.to-string", "es6.date.to-string", "es6.regexp.to-string"]),
  trim: globalOnly(["es6.string.trim"]),
  trimEnd: globalOnly(["es7.string.trim-right"]),
  trimLeft: globalOnly(["es7.string.trim-left"]),
  trimRight: globalOnly(["es7.string.trim-right"]),
  trimStart: globalOnly(["es7.string.trim-left"]),
  values: globalOnly(ArrayNatureIterators$1)
};
if ("es6.array.slice" in corejs2BuiltIns) InstanceProperties$1.slice = globalOnly(["es6.array.slice"]);

const StaticProperties$1 = {
  Array: {
    from: pureAndGlobal("array/from", ["es6.symbol", "es6.array.from", ...CommonIterators$1]),
    isArray: pureAndGlobal("array/is-array", ["es6.array.is-array"]),
    of: pureAndGlobal("array/of", ["es6.array.of"])
  },
  Date: { now: pureAndGlobal("date/now", ["es6.date.now"]) },
  JSON: { stringify: pureOnly("json/stringify", "es6.symbol") },
  Math: {
    acosh: pureAndGlobal("math/acosh", ["es6.math.acosh"], "7.0.1"),
    asinh: pureAndGlobal("math/asinh", ["es6.math.asinh"], "7.0.1"),
    atanh: pureAndGlobal("math/atanh", ["es6.math.atanh"], "7.0.1"),
    cbrt: pureAndGlobal("math/cbrt", ["es6.math.cbrt"], "7.0.1"),
    clz32: pureAndGlobal("math/clz32", ["es6.math.clz32"], "7.0.1"),
    cosh: pureAndGlobal("math/cosh", ["es6.math.cosh"], "7.0.1"),
    expm1: pureAndGlobal("math/expm1", ["es6.math.expm1"], "7.0.1"),
    fround: pureAndGlobal("math/fround", ["es6.math.fround"], "7.0.1"),
    hypot: pureAndGlobal("math/hypot", ["es6.math.hypot"], "7.0.1"),
    imul: pureAndGlobal("math/imul", ["es6.math.imul"], "7.0.1"),
    log1p: pureAndGlobal("math/log1p", ["es6.math.log1p"], "7.0.1"),
    log10: pureAndGlobal("math/log10", ["es6.math.log10"], "7.0.1"),
    log2: pureAndGlobal("math/log2", ["es6.math.log2"], "7.0.1"),
    sign: pureAndGlobal("math/sign", ["es6.math.sign"], "7.0.1"),
    sinh: pureAndGlobal("math/sinh", ["es6.math.sinh"], "7.0.1"),
    tanh: pureAndGlobal("math/tanh", ["es6.math.tanh"], "7.0.1"),
    trunc: pureAndGlobal("math/trunc", ["es6.math.trunc"], "7.0.1")
  },
  Number: {
    EPSILON: pureAndGlobal("number/epsilon", ["es6.number.epsilon"]),
    MIN_SAFE_INTEGER: pureAndGlobal("number/min-safe-integer", ["es6.number.min-safe-integer"]),
    MAX_SAFE_INTEGER: pureAndGlobal("number/max-safe-integer", ["es6.number.max-safe-integer"]),
    isFinite: pureAndGlobal("number/is-finite", ["es6.number.is-finite"]),
    isInteger: pureAndGlobal("number/is-integer", ["es6.number.is-integer"]),
    isSafeInteger: pureAndGlobal("number/is-safe-integer", ["es6.number.is-safe-integer"]),
    isNaN: pureAndGlobal("number/is-nan", ["es6.number.is-nan"]),
    parseFloat: pureAndGlobal("number/parse-float", ["es6.number.parse-float"]),
    parseInt: pureAndGlobal("number/parse-int", ["es6.number.parse-int"])
  },
  Object: {
    assign: pureAndGlobal("object/assign", ["es6.object.assign"]),
    create: pureAndGlobal("object/create", ["es6.object.create"]),
    defineProperties: pureAndGlobal("object/define-properties", ["es6.object.define-properties"]),
    defineProperty: pureAndGlobal("object/define-property", ["es6.object.define-property"]),
    entries: pureAndGlobal("object/entries", ["es7.object.entries"]),
    freeze: pureAndGlobal("object/freeze", ["es6.object.freeze"]),
    getOwnPropertyDescriptor: pureAndGlobal("object/get-own-property-descriptor", [
      "es6.object.get-own-property-descriptor"
    ]),
    getOwnPropertyDescriptors: pureAndGlobal("object/get-own-property-descriptors", [
      "es7.object.get-own-property-descriptors"
    ]),
    getOwnPropertyNames: pureAndGlobal("object/get-own-property-names", ["es6.object.get-own-property-names"]),
    getOwnPropertySymbols: pureAndGlobal("object/get-own-property-symbols", ["es6.symbol"]),
    getPrototypeOf: pureAndGlobal("object/get-prototype-of", ["es6.object.get-prototype-of"]),
    is: pureAndGlobal("object/is", ["es6.object.is"]),
    isExtensible: pureAndGlobal("object/is-extensible", ["es6.object.is-extensible"]),
    isFrozen: pureAndGlobal("object/is-frozen", ["es6.object.is-frozen"]),
    isSealed: pureAndGlobal("object/is-sealed", ["es6.object.is-sealed"]),
    keys: pureAndGlobal("object/keys", ["es6.object.keys"]),
    preventExtensions: pureAndGlobal("object/prevent-extensions", ["es6.object.prevent-extensions"]),
    seal: pureAndGlobal("object/seal", ["es6.object.seal"]),
    setPrototypeOf: pureAndGlobal("object/set-prototype-of", ["es6.object.set-prototype-of"]),
    values: pureAndGlobal("object/values", ["es7.object.values"])
  },
  Promise: { all: globalOnly(CommonIterators$1), race: globalOnly(CommonIterators$1) },
  Reflect: {
    apply: pureAndGlobal("reflect/apply", ["es6.reflect.apply"]),
    construct: pureAndGlobal("reflect/construct", ["es6.reflect.construct"]),
    defineProperty: pureAndGlobal("reflect/define-property", ["es6.reflect.define-property"]),
    deleteProperty: pureAndGlobal("reflect/delete-property", ["es6.reflect.delete-property"]),
    get: pureAndGlobal("reflect/get", ["es6.reflect.get"]),
    getOwnPropertyDescriptor: pureAndGlobal("reflect/get-own-property-descriptor", [
      "es6.reflect.get-own-property-descriptor"
    ]),
    getPrototypeOf: pureAndGlobal("reflect/get-prototype-of", ["es6.reflect.get-prototype-of"]),
    has: pureAndGlobal("reflect/has", ["es6.reflect.has"]),
    isExtensible: pureAndGlobal("reflect/is-extensible", ["es6.reflect.is-extensible"]),
    ownKeys: pureAndGlobal("reflect/own-keys", ["es6.reflect.own-keys"]),
    preventExtensions: pureAndGlobal("reflect/prevent-extensions", ["es6.reflect.prevent-extensions"]),
    set: pureAndGlobal("reflect/set", ["es6.reflect.set"]),
    setPrototypeOf: pureAndGlobal("reflect/set-prototype-of", ["es6.reflect.set-prototype-of"])
  },
  String: {
    at: pureOnly("string/at", "es7.string.at"),
    fromCodePoint: pureAndGlobal("string/from-code-point", ["es6.string.from-code-point"]),
    raw: pureAndGlobal("string/raw", ["es6.string.raw"])
  },
  Symbol: {
    asyncIterator: globalOnly(["es6.symbol", "es7.symbol.async-iterator"]),
    for: pureOnly("symbol/for", "es6.symbol"),
    hasInstance: pureOnly("symbol/has-instance", "es6.symbol"),
    isConcatSpreadable: pureOnly("symbol/is-concat-spreadable", "es6.symbol"),
    iterator: define$1("es6.symbol", "symbol/iterator", CommonIterators$1),
    keyFor: pureOnly("symbol/key-for", "es6.symbol"),
    match: pureAndGlobal("symbol/match", ["es6.regexp.match"]),
    replace: pureOnly("symbol/replace", "es6.symbol"),
    search: pureOnly("symbol/search", "es6.symbol"),
    species: pureOnly("symbol/species", "es6.symbol"),
    split: pureOnly("symbol/split", "es6.symbol"),
    toPrimitive: pureOnly("symbol/to-primitive", "es6.symbol"),
    toStringTag: pureOnly("symbol/to-string-tag", "es6.symbol"),
    unscopables: pureOnly("symbol/unscopables", "es6.symbol")
  }
};
const webPolyfills = {
  "web.timers": {},
  "web.immediate": {},
  "web.dom.iterable": {}
};
const purePolyfills = {
  "es6.parse-float": {},
  "es6.parse-int": {},
  "es7.string.at": {}
};
function addPlatformSpecificPolyfills(targets, method, polyfills) {
  const targetNames = Object.keys(targets),
    isAnyTarget = !targetNames.length,
    isWebTarget = targetNames.some(name => name !== "node");
  return Object.assign({},
    polyfills,
    method === "usage-pure" ? purePolyfills : null,
    isAnyTarget || isWebTarget ? webPolyfills : null
  );
}
function hasMinVersion(minVersion, runtimeVersion) {
  if (!runtimeVersion || !minVersion) return true;
  if (vendors.semver.valid(runtimeVersion)) runtimeVersion = "^" + runtimeVersion;
  return (
    !vendors.semver.intersects("<" + minVersion, runtimeVersion) && !vendors.semver.intersects(">=8.0.0", runtimeVersion)
  );
}
const { types: t$3 } = _babel,
  BABEL_RUNTIME$1 = "@babel/runtime-corejs2",
  presetEnvCompat$1 = "#__secret_key__@babel/preset-env__compatibility",
  runtimeCompat$2 = "#__secret_key__@babel/runtime__compatibility",
  has$2 = Function.call.bind(Object.hasOwnProperty);
var index$2 = definePolyfillProvider(function (api, {
  [presetEnvCompat$1]: { entryInjectRegenerator = false, noRuntimeName = false } = {},
  [runtimeCompat$2]: { useBabelRuntime = false, runtimeVersion = "", ext = ".js" } = {}
}) {
  const resolve = api.createMetaResolver({
    global: BuiltIns$1,
    static: StaticProperties$1,
    instance: InstanceProperties$1
  });
  const { debug, shouldInjectPolyfill, method } = api,
    polyfills = addPlatformSpecificPolyfills(api.targets, method, corejs2BuiltIns);
  const coreJSBase = useBabelRuntime
    ? BABEL_RUNTIME$1 + "/core-js"
    : method === "usage-pure" ? "core-js/library/fn" : "core-js/modules";
  function inject(name, utils) {
    if (typeof name != "string") name.forEach(name => inject(name, utils));
    else if (has$2(polyfills, name) && shouldInjectPolyfill(name)) {
      debug(name);
      utils.injectGlobalImport(`${coreJSBase}/${name}.js`);
    }
  }
  function maybeInjectPure(desc, hint, utils) {
    let { pure, meta, name } = desc;
    if (
      !pure || !shouldInjectPolyfill(name) ||
      (runtimeVersion && meta && meta.minRuntimeVersion &&
        !hasMinVersion(meta && meta.minRuntimeVersion, runtimeVersion))
    )
      return;

    if (useBabelRuntime && pure === "symbol/index") pure = "symbol";
    return utils.injectDefaultImport(`${coreJSBase}/${pure}${ext}`, hint);
  }
  return {
    name: "corejs2",
    runtimeName: noRuntimeName ? null : BABEL_RUNTIME$1,
    polyfills,
    entryGlobal(meta, utils, path) {
      if (meta.kind === "import" && meta.source === "core-js") {
        debug(null);
        inject(Object.keys(polyfills), utils);
        entryInjectRegenerator && utils.injectGlobalImport("regenerator-runtime/runtime.js");

        path.remove();
      }
    },
    usageGlobal(meta, utils) {
      const resolved = resolve(meta);
      if (!resolved) return;
      let deps = resolved.desc.global;
      if (resolved.kind !== "global" && "object" in meta && meta.object && meta.placement === "prototype") {
        const low = meta.object.toLowerCase();
        deps = deps.filter(m => m.includes(low));
      }
      inject(deps, utils);
    },
    usagePure(meta, utils, path) {
      if (meta.kind === "in") {
        meta.key !== "Symbol.iterator" ||
          path.replaceWith(
            t$3.callExpression(utils.injectDefaultImport(`${coreJSBase}/is-iterable${ext}`, "isIterable"), [
              path.node.right
            ])
          );

        return;
      }
      if (path.parentPath.isUnaryExpression({ operator: "delete" })) return;
      if (meta.kind === "property") {
        if (!path.isMemberExpression() || !path.isReferenced()) return;
        if (
          meta.key === "Symbol.iterator" && shouldInjectPolyfill("es6.symbol") &&
          path.parentPath.isCallExpression({ callee: path.node }) && path.parentPath.node.arguments.length === 0
        ) {
          path.parentPath.replaceWith(
            t$3.callExpression(utils.injectDefaultImport(`${coreJSBase}/get-iterator${ext}`, "getIterator"), [
              path.node.object
            ])
          );
          path.skip();
          return;
        }
      }
      const resolved = resolve(meta);
      if (!resolved) return;
      const id = maybeInjectPure(resolved.desc, resolved.name, utils);
      id && path.replaceWith(id);
    },
    visitor: method === "usage-global" && {
      YieldExpression(path) {
        path.node.delegate && inject("web.dom.iterable", api.getUtils(path));
      },
      "ForOfStatement|ArrayPattern"(path) {
        CommonIterators$1.forEach(name => inject(name, api.getUtils(path)));
      }
    }
  };
});

var require$$0$3 = {
  "es.symbol": {
    android: "49",
    bun: "0.1.1",
    chrome: "49",
    "chrome-android": "49",
    deno: "1.0",
    edge: "15",
    electron: "0.37",
    firefox: "51",
    "firefox-android": "51",
    hermes: "0.1",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "36",
    "opera-android": "36",
    opera_mobile: "36",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.symbol.description": {
    android: "70",
    bun: "0.1.1",
    chrome: "70",
    "chrome-android": "70",
    deno: "1.0",
    edge: "79",
    electron: "5.0",
    firefox: "63",
    "firefox-android": "63",
    ios: "12.2",
    node: "11.0",
    oculus: "6.0",
    opera: "57",
    "opera-android": "49",
    opera_mobile: "49",
    quest: "6.0",
    safari: "12.1",
    samsung: "10.0"
  },
  "es.symbol.async-iterator": {
    android: "63",
    bun: "0.1.1",
    chrome: "63",
    "chrome-android": "63",
    deno: "1.0",
    edge: "79",
    electron: "3.0",
    firefox: "55",
    "firefox-android": "55",
    ios: "12.0",
    node: "10.0",
    oculus: "5.0",
    opera: "50",
    "opera-android": "46",
    opera_mobile: "46",
    quest: "5.0",
    safari: "12.0",
    samsung: "8.0"
  },
  "es.symbol.has-instance": {
    android: "50",
    bun: "0.1.1",
    chrome: "50",
    "chrome-android": "50",
    deno: "1.0",
    edge: "15",
    electron: "1.1",
    firefox: "49",
    "firefox-android": "49",
    hermes: "0.1",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "37",
    "opera-android": "37",
    opera_mobile: "37",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.symbol.is-concat-spreadable": {
    android: "48",
    bun: "0.1.1",
    chrome: "48",
    "chrome-android": "48",
    deno: "1.0",
    edge: "15",
    electron: "0.37",
    firefox: "48",
    "firefox-android": "48",
    hermes: "0.1",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "35",
    "opera-android": "35",
    opera_mobile: "35",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.symbol.iterator": {
    android: "41",
    bun: "0.1.1",
    chrome: "41",
    "chrome-android": "41",
    deno: "1.0",
    edge: "13",
    electron: "0.21",
    firefox: "36",
    "firefox-android": "36",
    hermes: "0.1",
    ios: "9.0",
    node: "1.0",
    oculus: "3.0",
    opera: "28",
    "opera-android": "28",
    opera_mobile: "28",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "3.4"
  },
  "es.symbol.match": {
    android: "50",
    bun: "0.1.1",
    chrome: "50",
    "chrome-android": "50",
    deno: "1.0",
    edge: "79",
    electron: "1.1",
    firefox: "40",
    "firefox-android": "40",
    hermes: "0.1",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "37",
    "opera-android": "37",
    opera_mobile: "37",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.symbol.match-all": {
    android: "73",
    bun: "0.1.1",
    chrome: "73",
    "chrome-android": "73",
    deno: "1.0",
    edge: "79",
    electron: "5.0",
    firefox: "67",
    "firefox-android": "67",
    hermes: "0.6",
    ios: "13.0",
    node: "12.0",
    oculus: "6.0",
    opera: "60",
    "opera-android": "52",
    opera_mobile: "52",
    quest: "6.0",
    "react-native": "0.69",
    safari: "13",
    samsung: "11.0"
  },
  "es.symbol.replace": {
    android: "50",
    bun: "0.1.1",
    chrome: "50",
    "chrome-android": "50",
    deno: "1.0",
    edge: "79",
    electron: "1.1",
    firefox: "49",
    "firefox-android": "49",
    hermes: "0.1",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "37",
    "opera-android": "37",
    opera_mobile: "37",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.symbol.search": {
    android: "50",
    bun: "0.1.1",
    chrome: "50",
    "chrome-android": "50",
    deno: "1.0",
    edge: "79",
    electron: "1.1",
    firefox: "49",
    "firefox-android": "49",
    hermes: "0.1",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "37",
    "opera-android": "37",
    opera_mobile: "37",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.symbol.species": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "13",
    electron: "1.2",
    firefox: "41",
    "firefox-android": "41",
    ios: "10.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    rhino: "1.7.13",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.symbol.split": {
    android: "50",
    bun: "0.1.1",
    chrome: "50",
    "chrome-android": "50",
    deno: "1.0",
    edge: "79",
    electron: "1.1",
    firefox: "49",
    "firefox-android": "49",
    hermes: "0.1",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "37",
    "opera-android": "37",
    opera_mobile: "37",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.symbol.to-primitive": {
    android: "47",
    bun: "0.1.1",
    chrome: "47",
    "chrome-android": "47",
    deno: "1.0",
    edge: "15",
    electron: "0.36",
    firefox: "44",
    "firefox-android": "44",
    hermes: "0.1",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "34",
    "opera-android": "34",
    opera_mobile: "34",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.symbol.to-string-tag": {
    android: "49",
    bun: "0.1.1",
    chrome: "49",
    "chrome-android": "49",
    deno: "1.0",
    edge: "15",
    electron: "0.37",
    firefox: "51",
    "firefox-android": "51",
    hermes: "0.1",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "36",
    "opera-android": "36",
    opera_mobile: "36",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.symbol.unscopables": {
    android: "41",
    bun: "0.1.1",
    chrome: "41",
    "chrome-android": "41",
    deno: "1.0",
    edge: "13",
    electron: "0.21",
    firefox: "48",
    "firefox-android": "48",
    ios: "9.0",
    node: "1.0",
    oculus: "3.0",
    opera: "28",
    "opera-android": "28",
    opera_mobile: "28",
    quest: "3.0",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "3.4"
  },
  "es.error.cause": {
    android: "94",
    bun: "0.1.1",
    chrome: "94",
    "chrome-android": "94",
    deno: "1.14",
    edge: "94",
    electron: "15.0",
    firefox: "91",
    "firefox-android": "91",
    hermes: "0.8",
    ios: "15.0",
    node: "16.11",
    oculus: "18.0",
    opera: "80",
    "opera-android": "66",
    opera_mobile: "66",
    quest: "18.0",
    "react-native": "0.69",
    safari: "15.0",
    samsung: "17.0"
  },
  "es.error.to-string": {
    android: "4.4.3",
    bun: "0.1.1",
    chrome: "33",
    "chrome-android": "33",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "11",
    "firefox-android": "11",
    hermes: "0.1",
    ie: "9",
    ios: "9.0",
    node: "0.11.13",
    oculus: "3.0",
    opera: "20",
    "opera-android": "20",
    opera_mobile: "20",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.14",
    safari: "8.0",
    samsung: "2.0"
  },
  "es.aggregate-error": {
    android: "85",
    bun: "0.1.1",
    chrome: "85",
    "chrome-android": "85",
    deno: "1.2",
    edge: "85",
    electron: "10.0",
    firefox: "79",
    "firefox-android": "79",
    ios: "14.0",
    node: "15.0",
    oculus: "12.0",
    opera: "71",
    "opera-android": "60",
    opera_mobile: "60",
    quest: "12.0",
    safari: "14.0",
    samsung: "14.0"
  },
  "es.aggregate-error.cause": {
    android: "94",
    bun: "0.1.1",
    chrome: "94",
    "chrome-android": "94",
    deno: "1.14",
    edge: "94",
    electron: "15.0",
    firefox: "91",
    "firefox-android": "91",
    ios: "15.0",
    node: "16.11",
    oculus: "18.0",
    opera: "80",
    "opera-android": "66",
    opera_mobile: "66",
    quest: "18.0",
    safari: "15.0",
    samsung: "17.0"
  },
  "es.array.at": {
    android: "92",
    bun: "0.1.1",
    chrome: "92",
    "chrome-android": "92",
    deno: "1.12",
    edge: "92",
    electron: "14.0",
    firefox: "90",
    "firefox-android": "90",
    ios: "15.4",
    node: "16.6",
    oculus: "17.0",
    opera: "78",
    "opera-android": "65",
    opera_mobile: "65",
    quest: "17.0",
    "react-native": "0.71",
    safari: "15.4",
    samsung: "16.0"
  },
  "es.array.concat": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "15",
    electron: "1.2",
    firefox: "48",
    "firefox-android": "48",
    ios: "10.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.array.copy-within": {
    android: "45",
    bun: "0.1.1",
    chrome: "45",
    "chrome-android": "45",
    deno: "1.0",
    edge: "12",
    electron: "0.31",
    firefox: "48",
    "firefox-android": "48",
    ios: "9.0",
    node: "4.0",
    oculus: "3.0",
    opera: "32",
    "opera-android": "32",
    opera_mobile: "32",
    quest: "3.0",
    safari: "9.0",
    samsung: "5.0"
  },
  "es.array.every": {
    android: "4.4",
    bun: "0.1.1",
    chrome: "26",
    "chrome-android": "26",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "4",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "9",
    ios: "8.0",
    node: "0.11.0",
    oculus: "3.0",
    opera: "15",
    "opera-android": "15",
    opera_mobile: "15",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "1.5"
  },
  "es.array.fill": {
    android: "45",
    bun: "0.1.1",
    chrome: "45",
    "chrome-android": "45",
    deno: "1.0",
    edge: "12",
    electron: "0.31",
    firefox: "48",
    "firefox-android": "48",
    ios: "9.0",
    node: "4.0",
    oculus: "3.0",
    opera: "32",
    "opera-android": "32",
    opera_mobile: "32",
    quest: "3.0",
    safari: "9.0",
    samsung: "5.0"
  },
  "es.array.filter": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "15",
    electron: "1.2",
    firefox: "48",
    "firefox-android": "48",
    ios: "10.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.array.find": {
    android: "45",
    bun: "0.1.1",
    chrome: "45",
    "chrome-android": "45",
    deno: "1.0",
    edge: "13",
    electron: "0.31",
    firefox: "48",
    "firefox-android": "48",
    ios: "9.0",
    node: "4.0",
    oculus: "3.0",
    opera: "32",
    "opera-android": "32",
    opera_mobile: "32",
    quest: "3.0",
    safari: "9.0",
    samsung: "5.0"
  },
  "es.array.find-index": {
    android: "45",
    bun: "0.1.1",
    chrome: "45",
    "chrome-android": "45",
    deno: "1.0",
    edge: "13",
    electron: "0.31",
    firefox: "48",
    "firefox-android": "48",
    ios: "9.0",
    node: "4.0",
    oculus: "3.0",
    opera: "32",
    "opera-android": "32",
    opera_mobile: "32",
    quest: "3.0",
    safari: "9.0",
    samsung: "5.0"
  },
  "es.array.find-last": {
    android: "97",
    bun: "0.1.1",
    chrome: "97",
    "chrome-android": "97",
    deno: "1.16",
    edge: "97",
    electron: "17.0",
    firefox: "104",
    "firefox-android": "104",
    hermes: "0.11",
    ios: "15.4",
    node: "18.0",
    oculus: "20.0",
    opera: "83",
    "opera-android": "68",
    opera_mobile: "68",
    quest: "20.0",
    "react-native": "0.69",
    safari: "15.4",
    samsung: "18.0"
  },
  "es.array.find-last-index": {
    android: "97",
    bun: "0.1.1",
    chrome: "97",
    "chrome-android": "97",
    deno: "1.16",
    edge: "97",
    electron: "17.0",
    firefox: "104",
    "firefox-android": "104",
    hermes: "0.11",
    ios: "15.4",
    node: "18.0",
    oculus: "20.0",
    opera: "83",
    "opera-android": "68",
    opera_mobile: "68",
    quest: "20.0",
    "react-native": "0.69",
    safari: "15.4",
    samsung: "18.0"
  },
  "es.array.flat": {
    android: "69",
    bun: "0.1.1",
    chrome: "69",
    "chrome-android": "69",
    deno: "1.0",
    edge: "79",
    electron: "4.0",
    firefox: "62",
    "firefox-android": "62",
    hermes: "0.4",
    ios: "12.0",
    node: "11.0",
    oculus: "6.0",
    opera: "56",
    "opera-android": "48",
    opera_mobile: "48",
    quest: "6.0",
    "react-native": "0.69",
    safari: "12.0",
    samsung: "10.0"
  },
  "es.array.flat-map": {
    android: "69",
    bun: "0.1.1",
    chrome: "69",
    "chrome-android": "69",
    deno: "1.0",
    edge: "79",
    electron: "4.0",
    firefox: "62",
    "firefox-android": "62",
    hermes: "0.4",
    ios: "12.0",
    node: "11.0",
    oculus: "6.0",
    opera: "56",
    "opera-android": "48",
    opera_mobile: "48",
    quest: "6.0",
    "react-native": "0.69",
    safari: "12.0",
    samsung: "10.0"
  },
  "es.array.for-each": {
    android: "4.4",
    bun: "0.1.1",
    chrome: "26",
    "chrome-android": "26",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "4",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "9",
    ios: "8.0",
    node: "0.11.0",
    oculus: "3.0",
    opera: "15",
    "opera-android": "15",
    opera_mobile: "15",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "1.5"
  },
  "es.array.from": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "15",
    electron: "1.2",
    firefox: "53",
    "firefox-android": "53",
    ios: "9.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "5.0"
  },
  "es.array.includes": {
    android: "53",
    bun: "0.1.1",
    chrome: "53",
    "chrome-android": "53",
    deno: "1.0",
    edge: "14",
    electron: "1.4",
    firefox: "102",
    "firefox-android": "102",
    ios: "10.0",
    node: "7.0",
    oculus: "3.0",
    opera: "40",
    "opera-android": "40",
    opera_mobile: "40",
    quest: "3.0",
    safari: "10.0",
    samsung: "6.0"
  },
  "es.array.index-of": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "12",
    electron: "1.2",
    firefox: "47",
    "firefox-android": "47",
    hermes: "0.1",
    ie: "9",
    ios: "8.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "5.0"
  },
  "es.array.is-array": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "5",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "4",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "9",
    ios: "3.0",
    node: "0.1.27",
    oculus: "3.0",
    opera: "10.50",
    "opera-android": "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "4.0",
    samsung: "1.0"
  },
  "es.array.iterator": {
    android: "66",
    bun: "0.1.1",
    chrome: "66",
    "chrome-android": "66",
    deno: "1.0",
    edge: "15",
    electron: "3.0",
    firefox: "60",
    "firefox-android": "60",
    ios: "10.0",
    node: "10.0",
    oculus: "5.0",
    opera: "53",
    "opera-android": "47",
    opera_mobile: "47",
    quest: "5.0",
    safari: "10.0",
    samsung: "9.0"
  },
  "es.array.join": {
    android: "4.4",
    bun: "0.1.1",
    chrome: "26",
    "chrome-android": "26",
    deno: "1.0",
    edge: "13",
    electron: "0.20",
    firefox: "4",
    "firefox-android": "4",
    hermes: "0.1",
    ios: "8.0",
    node: "0.11.0",
    oculus: "3.0",
    opera: "15",
    "opera-android": "15",
    opera_mobile: "15",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "1.5"
  },
  "es.array.last-index-of": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "12",
    electron: "1.2",
    firefox: "47",
    "firefox-android": "47",
    hermes: "0.1",
    ie: "9",
    ios: "8.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "5.0"
  },
  "es.array.map": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "13",
    electron: "1.2",
    firefox: "50",
    "firefox-android": "50",
    ios: "10.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.array.of": {
    android: "45",
    bun: "0.1.1",
    chrome: "45",
    "chrome-android": "45",
    deno: "1.0",
    edge: "13",
    electron: "0.31",
    firefox: "25",
    "firefox-android": "25",
    hermes: "0.1",
    ios: "9.0",
    node: "4.0",
    oculus: "3.0",
    opera: "32",
    "opera-android": "32",
    opera_mobile: "32",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "5.0"
  },
  "es.array.push": {
    bun: "0.1.1",
    firefox: "55",
    "firefox-android": "55",
    hermes: "0.2",
    ios: "16.0",
    "react-native": "0.69",
    safari: "16.0"
  },
  "es.array.reduce": {
    android: "83",
    bun: "0.1.1",
    chrome: "83",
    "chrome-android": "83",
    deno: "1.0",
    edge: "12",
    electron: "9.0",
    firefox: "4",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "9",
    ios: "8.0",
    node: "6.0",
    oculus: "10.0",
    opera: "69",
    "opera-android": "59",
    opera_mobile: "59",
    quest: "10.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "13.0"
  },
  "es.array.reduce-right": {
    android: "83",
    bun: "0.1.1",
    chrome: "83",
    "chrome-android": "83",
    deno: "1.0",
    edge: "12",
    electron: "9.0",
    firefox: "4",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "9",
    ios: "8.0",
    node: "6.0",
    oculus: "10.0",
    opera: "69",
    "opera-android": "59",
    opera_mobile: "59",
    quest: "10.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "13.0"
  },
  "es.array.reverse": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "1",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "1",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "5.5",
    ios: "12.2",
    node: "0.0.3",
    oculus: "3.0",
    opera: "10.50",
    "opera-android": "10.50",
    opera_mobile: "10.50",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "12.0.2",
    samsung: "1.0"
  },
  "es.array.slice": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "13",
    electron: "1.2",
    firefox: "48",
    "firefox-android": "48",
    ios: "10.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.array.some": {
    android: "4.4",
    bun: "0.1.1",
    chrome: "26",
    "chrome-android": "26",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "4",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "9",
    ios: "8.0",
    node: "0.11.0",
    oculus: "3.0",
    opera: "15",
    "opera-android": "15",
    opera_mobile: "15",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "1.5"
  },
  "es.array.sort": {
    android: "70",
    bun: "0.1.1",
    chrome: "70",
    "chrome-android": "70",
    deno: "1.0",
    edge: "79",
    electron: "5.0",
    firefox: "4",
    "firefox-android": "4",
    hermes: "0.10",
    ios: "12.0",
    node: "11.0",
    oculus: "6.0",
    opera: "57",
    "opera-android": "49",
    opera_mobile: "49",
    quest: "6.0",
    "react-native": "0.69",
    safari: "12.0",
    samsung: "10.0"
  },
  "es.array.species": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "13",
    electron: "1.2",
    firefox: "48",
    "firefox-android": "48",
    ios: "10.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.array.splice": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "13",
    electron: "1.2",
    firefox: "49",
    "firefox-android": "49",
    ios: "10.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.array.to-reversed": {
    android: "110",
    bun: "0.1.1",
    chrome: "110",
    "chrome-android": "110",
    deno: "1.27",
    edge: "110",
    electron: "23.0",
    firefox: "115",
    "firefox-android": "115",
    ios: "16.0",
    node: "20.0",
    oculus: "26.0",
    opera: "96",
    "opera-android": "74",
    opera_mobile: "74",
    quest: "26.0",
    safari: "16.0",
    samsung: "21.0"
  },
  "es.array.to-sorted": {
    android: "110",
    bun: "0.1.1",
    chrome: "110",
    "chrome-android": "110",
    deno: "1.27",
    edge: "110",
    electron: "23.0",
    firefox: "115",
    "firefox-android": "115",
    ios: "16.0",
    node: "20.0",
    oculus: "26.0",
    opera: "96",
    "opera-android": "74",
    opera_mobile: "74",
    quest: "26.0",
    safari: "16.0",
    samsung: "21.0"
  },
  "es.array.to-spliced": {
    android: "110",
    bun: "0.1.1",
    chrome: "110",
    "chrome-android": "110",
    deno: "1.27",
    edge: "110",
    electron: "23.0",
    firefox: "115",
    "firefox-android": "115",
    ios: "16.0",
    node: "20.0",
    oculus: "26.0",
    opera: "96",
    "opera-android": "74",
    opera_mobile: "74",
    quest: "26.0",
    safari: "16.0",
    samsung: "21.0"
  },
  "es.array.unscopables.flat": {
    android: "73",
    bun: "0.1.1",
    chrome: "73",
    "chrome-android": "73",
    deno: "1.0",
    edge: "79",
    electron: "5.0",
    firefox: "67",
    "firefox-android": "67",
    ios: "13.0",
    node: "12.0",
    oculus: "6.0",
    opera: "60",
    "opera-android": "52",
    opera_mobile: "52",
    quest: "6.0",
    safari: "13",
    samsung: "11.0"
  },
  "es.array.unscopables.flat-map": {
    android: "73",
    bun: "0.1.1",
    chrome: "73",
    "chrome-android": "73",
    deno: "1.0",
    edge: "79",
    electron: "5.0",
    firefox: "67",
    "firefox-android": "67",
    ios: "13.0",
    node: "12.0",
    oculus: "6.0",
    opera: "60",
    "opera-android": "52",
    opera_mobile: "52",
    quest: "6.0",
    safari: "13",
    samsung: "11.0"
  },
  "es.array.unshift": {
    android: "71",
    bun: "0.1.1",
    chrome: "71",
    "chrome-android": "71",
    deno: "1.0",
    edge: "12",
    electron: "5.0",
    firefox: "23",
    "firefox-android": "23",
    hermes: "0.1",
    ie: "9",
    ios: "16.0",
    node: "12.0",
    oculus: "6.0",
    opera: "58",
    "opera-android": "50",
    opera_mobile: "50",
    quest: "6.0",
    "react-native": "0.69",
    safari: "16.0",
    samsung: "10.0"
  },
  "es.array.with": {
    android: "110",
    bun: "0.1.1",
    chrome: "110",
    "chrome-android": "110",
    deno: "1.27",
    edge: "110",
    electron: "23.0",
    firefox: "115",
    "firefox-android": "115",
    ios: "16.0",
    node: "20.0",
    oculus: "26.0",
    opera: "96",
    "opera-android": "74",
    opera_mobile: "74",
    quest: "26.0",
    safari: "16.0",
    samsung: "21.0"
  },
  "es.array-buffer.constructor": {
    android: "4.4",
    bun: "0.1.1",
    chrome: "28",
    "chrome-android": "28",
    deno: "1.0",
    edge: "14",
    electron: "0.20",
    firefox: "44",
    "firefox-android": "44",
    hermes: "0.1",
    ios: "12.0",
    node: "0.11.1",
    oculus: "3.0",
    opera: "15",
    "opera-android": "15",
    opera_mobile: "15",
    quest: "3.0",
    "react-native": "0.69",
    safari: "12.0",
    samsung: "1.5"
  },
  "es.array-buffer.is-view": {
    android: "4.4.3",
    bun: "0.1.1",
    chrome: "32",
    "chrome-android": "32",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "29",
    "firefox-android": "29",
    hermes: "0.1",
    ie: "11",
    ios: "8.0",
    node: "0.11.9",
    oculus: "3.0",
    opera: "19",
    "opera-android": "19",
    opera_mobile: "19",
    quest: "3.0",
    "react-native": "0.69",
    safari: "7.1",
    samsung: "2.0"
  },
  "es.array-buffer.slice": {
    android: "4.4.3",
    bun: "0.1.1",
    chrome: "31",
    "chrome-android": "31",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "46",
    "firefox-android": "46",
    hermes: "0.1",
    ie: "11",
    ios: "12.2",
    node: "0.11.8",
    oculus: "3.0",
    opera: "18",
    "opera-android": "18",
    opera_mobile: "18",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "12.1",
    samsung: "2.0"
  },
  "es.data-view": {
    android: "4.4",
    bun: "0.1.1",
    chrome: "26",
    "chrome-android": "26",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "15",
    "firefox-android": "15",
    hermes: "0.1",
    ie: "10",
    ios: "8.0",
    node: "0.11.0",
    oculus: "3.0",
    opera: "15",
    "opera-android": "15",
    opera_mobile: "15",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "1.5"
  },
  "es.date.get-year": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "1",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "1",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "9",
    ios: "1.0",
    node: "0.0.3",
    oculus: "3.0",
    opera: "3",
    "opera-android": "3",
    opera_mobile: "3",
    phantom: "1.9",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "1",
    samsung: "1.0"
  },
  "es.date.now": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "5",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "9",
    ios: "3.0",
    node: "0.1.27",
    oculus: "3.0",
    opera: "10.50",
    "opera-android": "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "4.0",
    samsung: "1.0"
  },
  "es.date.set-year": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "1",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "1",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "3",
    ios: "1.0",
    node: "0.0.3",
    oculus: "3.0",
    opera: "3",
    "opera-android": "3",
    opera_mobile: "3",
    phantom: "1.9",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "1",
    samsung: "1.0"
  },
  "es.date.to-gmt-string": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "1",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "1",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "3",
    ios: "1.0",
    node: "0.0.3",
    oculus: "3.0",
    opera: "3",
    "opera-android": "3",
    opera_mobile: "3",
    phantom: "1.9",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "1",
    samsung: "1.0"
  },
  "es.date.to-iso-string": {
    android: "4.4",
    bun: "0.1.1",
    chrome: "26",
    "chrome-android": "26",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "7",
    "firefox-android": "7",
    hermes: "0.1",
    ie: "9",
    ios: "8.0",
    node: "0.11.0",
    oculus: "3.0",
    opera: "15",
    "opera-android": "15",
    opera_mobile: "15",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "1.5"
  },
  "es.date.to-json": {
    android: "4.4",
    bun: "0.1.1",
    chrome: "26",
    "chrome-android": "26",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "4",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "9",
    ios: "10.0",
    node: "0.11.0",
    oculus: "3.0",
    opera: "15",
    "opera-android": "15",
    opera_mobile: "15",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "10.0",
    samsung: "1.5"
  },
  "es.date.to-primitive": {
    android: "47",
    bun: "0.1.1",
    chrome: "47",
    "chrome-android": "47",
    deno: "1.0",
    edge: "15",
    electron: "0.36",
    firefox: "44",
    "firefox-android": "44",
    hermes: "0.1",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "34",
    "opera-android": "34",
    opera_mobile: "34",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.date.to-string": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "5",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "9",
    ios: "2.0",
    node: "0.1.27",
    oculus: "3.0",
    opera: "10.50",
    "opera-android": "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "3.1",
    samsung: "1.0"
  },
  "es.escape": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "1",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "1",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "3",
    ios: "1.0",
    node: "0.0.3",
    oculus: "3.0",
    opera: "3",
    "opera-android": "3",
    opera_mobile: "3",
    phantom: "1.9",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "1",
    samsung: "1.0"
  },
  "es.function.bind": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "7",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "4",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "9",
    ios: "5.0",
    node: "0.1.101",
    oculus: "3.0",
    opera: "12",
    "opera-android": "12",
    opera_mobile: "12",
    phantom: "2.0",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "5.1",
    samsung: "1.0"
  },
  "es.function.has-instance": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "15",
    electron: "1.2",
    firefox: "50",
    "firefox-android": "50",
    hermes: "0.1",
    ios: "10.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.function.name": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "5",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    "firefox-android": "4",
    hermes: "0.1",
    ios: "3.0",
    node: "0.1.27",
    oculus: "3.0",
    opera: "10.50",
    "opera-android": "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "4.0",
    samsung: "1.0"
  },
  "es.global-this": {
    android: "71",
    bun: "0.1.1",
    chrome: "71",
    "chrome-android": "71",
    deno: "1.0",
    edge: "79",
    electron: "5.0",
    firefox: "65",
    "firefox-android": "65",
    hermes: "0.2",
    ios: "12.2",
    node: "12.0",
    oculus: "6.0",
    opera: "58",
    "opera-android": "50",
    opera_mobile: "50",
    quest: "6.0",
    "react-native": "0.69",
    rhino: "1.7.14",
    safari: "12.1",
    samsung: "10.0"
  },
  "es.json.stringify": {
    android: "72",
    bun: "0.1.1",
    chrome: "72",
    "chrome-android": "72",
    deno: "1.0",
    edge: "79",
    electron: "5.0",
    firefox: "64",
    "firefox-android": "64",
    ios: "12.2",
    node: "12.0",
    oculus: "6.0",
    opera: "59",
    "opera-android": "51",
    opera_mobile: "51",
    quest: "6.0",
    safari: "12.1",
    samsung: "11.0"
  },
  "es.json.to-string-tag": {
    android: "50",
    bun: "0.1.1",
    chrome: "50",
    "chrome-android": "50",
    deno: "1.0",
    edge: "15",
    electron: "1.1",
    firefox: "51",
    "firefox-android": "51",
    hermes: "0.1",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "37",
    "opera-android": "37",
    opera_mobile: "37",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.map": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "15",
    electron: "1.2",
    firefox: "53",
    "firefox-android": "53",
    ios: "10.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    rhino: "1.7.13",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.math.acosh": {
    android: "54",
    bun: "0.1.1",
    chrome: "54",
    "chrome-android": "54",
    deno: "1.0",
    edge: "13",
    electron: "1.4",
    firefox: "25",
    "firefox-android": "25",
    hermes: "0.1",
    ios: "8.0",
    node: "7.0",
    oculus: "3.0",
    opera: "41",
    "opera-android": "41",
    opera_mobile: "41",
    quest: "3.0",
    "react-native": "0.69",
    safari: "7.1",
    samsung: "6.0"
  },
  "es.math.asinh": {
    android: "38",
    bun: "0.1.1",
    chrome: "38",
    "chrome-android": "38",
    deno: "1.0",
    edge: "13",
    electron: "0.20",
    firefox: "25",
    "firefox-android": "25",
    hermes: "0.1",
    ios: "8.0",
    node: "0.11.15",
    oculus: "3.0",
    opera: "25",
    "opera-android": "25",
    opera_mobile: "25",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "3.0"
  },
  "es.math.atanh": {
    android: "38",
    bun: "0.1.1",
    chrome: "38",
    "chrome-android": "38",
    deno: "1.0",
    edge: "13",
    electron: "0.20",
    firefox: "25",
    "firefox-android": "25",
    hermes: "0.1",
    ios: "8.0",
    node: "0.11.15",
    oculus: "3.0",
    opera: "25",
    "opera-android": "25",
    opera_mobile: "25",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "3.0"
  },
  "es.math.cbrt": {
    android: "38",
    bun: "0.1.1",
    chrome: "38",
    "chrome-android": "38",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "25",
    "firefox-android": "25",
    hermes: "0.1",
    ios: "8.0",
    node: "0.11.15",
    oculus: "3.0",
    opera: "25",
    "opera-android": "25",
    opera_mobile: "25",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "3.0"
  },
  "es.math.clz32": {
    android: "38",
    bun: "0.1.1",
    chrome: "38",
    "chrome-android": "38",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "31",
    "firefox-android": "31",
    hermes: "0.1",
    ios: "9.0",
    node: "0.11.15",
    oculus: "3.0",
    opera: "25",
    "opera-android": "25",
    opera_mobile: "25",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "3.0"
  },
  "es.math.cosh": {
    android: "39",
    bun: "0.1.1",
    chrome: "39",
    "chrome-android": "39",
    deno: "1.0",
    edge: "13",
    electron: "0.20",
    firefox: "25",
    "firefox-android": "25",
    hermes: "0.1",
    ios: "8.0",
    node: "1.0",
    oculus: "3.0",
    opera: "26",
    "opera-android": "26",
    opera_mobile: "26",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "3.4"
  },
  "es.math.expm1": {
    android: "39",
    bun: "0.1.1",
    chrome: "39",
    "chrome-android": "39",
    deno: "1.0",
    edge: "13",
    electron: "0.20",
    firefox: "46",
    "firefox-android": "46",
    hermes: "0.1",
    ios: "8.0",
    node: "1.0",
    oculus: "3.0",
    opera: "26",
    "opera-android": "26",
    opera_mobile: "26",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "3.4"
  },
  "es.math.fround": {
    android: "38",
    bun: "0.1.1",
    chrome: "38",
    "chrome-android": "38",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "26",
    "firefox-android": "26",
    hermes: "0.1",
    ios: "8.0",
    node: "0.11.15",
    oculus: "3.0",
    opera: "25",
    "opera-android": "25",
    opera_mobile: "25",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "3.0"
  },
  "es.math.hypot": {
    android: "78",
    bun: "0.1.1",
    chrome: "78",
    "chrome-android": "78",
    deno: "1.0",
    edge: "12",
    electron: "7.0",
    firefox: "27",
    "firefox-android": "27",
    hermes: "0.1",
    ios: "8.0",
    node: "13.0",
    oculus: "8.0",
    opera: "65",
    "opera-android": "56",
    opera_mobile: "56",
    quest: "8.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "12.0"
  },
  "es.math.imul": {
    android: "4.4",
    bun: "0.1.1",
    chrome: "28",
    "chrome-android": "28",
    deno: "1.0",
    edge: "13",
    electron: "0.20",
    firefox: "20",
    "firefox-android": "20",
    hermes: "0.1",
    ios: "9.0",
    node: "0.11.1",
    oculus: "3.0",
    opera: "15",
    "opera-android": "15",
    opera_mobile: "15",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "1.5"
  },
  "es.math.log10": {
    android: "38",
    bun: "0.1.1",
    chrome: "38",
    "chrome-android": "38",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "25",
    "firefox-android": "25",
    hermes: "0.1",
    ios: "8.0",
    node: "0.11.15",
    oculus: "3.0",
    opera: "25",
    "opera-android": "25",
    opera_mobile: "25",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "3.0"
  },
  "es.math.log1p": {
    android: "38",
    bun: "0.1.1",
    chrome: "38",
    "chrome-android": "38",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "25",
    "firefox-android": "25",
    hermes: "0.1",
    ios: "8.0",
    node: "0.11.15",
    oculus: "3.0",
    opera: "25",
    "opera-android": "25",
    opera_mobile: "25",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "3.0"
  },
  "es.math.log2": {
    android: "38",
    bun: "0.1.1",
    chrome: "38",
    "chrome-android": "38",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "25",
    "firefox-android": "25",
    hermes: "0.1",
    ios: "8.0",
    node: "0.11.15",
    oculus: "3.0",
    opera: "25",
    "opera-android": "25",
    opera_mobile: "25",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "3.0"
  },
  "es.math.sign": {
    android: "38",
    bun: "0.1.1",
    chrome: "38",
    "chrome-android": "38",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "25",
    "firefox-android": "25",
    hermes: "0.1",
    ios: "9.0",
    node: "0.11.15",
    oculus: "3.0",
    opera: "25",
    "opera-android": "25",
    opera_mobile: "25",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "3.0"
  },
  "es.math.sinh": {
    android: "39",
    bun: "0.1.1",
    chrome: "39",
    "chrome-android": "39",
    deno: "1.0",
    edge: "13",
    electron: "0.20",
    firefox: "25",
    "firefox-android": "25",
    hermes: "0.1",
    ios: "8.0",
    node: "1.0",
    oculus: "3.0",
    opera: "26",
    "opera-android": "26",
    opera_mobile: "26",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "3.4"
  },
  "es.math.tanh": {
    android: "38",
    bun: "0.1.1",
    chrome: "38",
    "chrome-android": "38",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "25",
    "firefox-android": "25",
    hermes: "0.1",
    ios: "8.0",
    node: "0.11.15",
    oculus: "3.0",
    opera: "25",
    "opera-android": "25",
    opera_mobile: "25",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "3.0"
  },
  "es.math.to-string-tag": {
    android: "50",
    bun: "0.1.1",
    chrome: "50",
    "chrome-android": "50",
    deno: "1.0",
    edge: "15",
    electron: "1.1",
    firefox: "51",
    "firefox-android": "51",
    hermes: "0.1",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "37",
    "opera-android": "37",
    opera_mobile: "37",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.math.trunc": {
    android: "38",
    bun: "0.1.1",
    chrome: "38",
    "chrome-android": "38",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "25",
    "firefox-android": "25",
    hermes: "0.1",
    ios: "8.0",
    node: "0.11.15",
    oculus: "3.0",
    opera: "25",
    "opera-android": "25",
    opera_mobile: "25",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "3.0"
  },
  "es.number.constructor": {
    android: "41",
    bun: "0.1.1",
    chrome: "41",
    "chrome-android": "41",
    deno: "1.0",
    edge: "13",
    electron: "0.21",
    firefox: "46",
    "firefox-android": "46",
    hermes: "0.5",
    ios: "9.0",
    node: "1.0",
    oculus: "3.0",
    opera: "28",
    "opera-android": "28",
    opera_mobile: "28",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "3.4"
  },
  "es.number.epsilon": {
    android: "37",
    bun: "0.1.1",
    chrome: "34",
    "chrome-android": "34",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "25",
    "firefox-android": "25",
    hermes: "0.1",
    ios: "9.0",
    node: "0.11.13",
    oculus: "3.0",
    opera: "21",
    "opera-android": "21",
    opera_mobile: "21",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.14",
    safari: "9.0",
    samsung: "2.0"
  },
  "es.number.is-finite": {
    android: "4.1",
    bun: "0.1.1",
    chrome: "19",
    "chrome-android": "25",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "16",
    "firefox-android": "16",
    hermes: "0.1",
    ios: "9.0",
    node: "0.7.3",
    oculus: "3.0",
    opera: "15",
    "opera-android": "15",
    opera_mobile: "15",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "1.5"
  },
  "es.number.is-integer": {
    android: "37",
    bun: "0.1.1",
    chrome: "34",
    "chrome-android": "34",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "16",
    "firefox-android": "16",
    hermes: "0.1",
    ios: "9.0",
    node: "0.11.13",
    oculus: "3.0",
    opera: "21",
    "opera-android": "21",
    opera_mobile: "21",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "2.0"
  },
  "es.number.is-nan": {
    android: "4.1",
    bun: "0.1.1",
    chrome: "19",
    "chrome-android": "25",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "15",
    "firefox-android": "15",
    hermes: "0.1",
    ios: "9.0",
    node: "0.7.3",
    oculus: "3.0",
    opera: "15",
    "opera-android": "15",
    opera_mobile: "15",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "1.5"
  },
  "es.number.is-safe-integer": {
    android: "37",
    bun: "0.1.1",
    chrome: "34",
    "chrome-android": "34",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "32",
    "firefox-android": "32",
    hermes: "0.1",
    ios: "9.0",
    node: "0.11.13",
    oculus: "3.0",
    opera: "21",
    "opera-android": "21",
    opera_mobile: "21",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "2.0"
  },
  "es.number.max-safe-integer": {
    android: "37",
    bun: "0.1.1",
    chrome: "34",
    "chrome-android": "34",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "31",
    "firefox-android": "31",
    hermes: "0.1",
    ios: "9.0",
    node: "0.11.13",
    oculus: "3.0",
    opera: "21",
    "opera-android": "21",
    opera_mobile: "21",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "2.0"
  },
  "es.number.min-safe-integer": {
    android: "37",
    bun: "0.1.1",
    chrome: "34",
    "chrome-android": "34",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "31",
    "firefox-android": "31",
    hermes: "0.1",
    ios: "9.0",
    node: "0.11.13",
    oculus: "3.0",
    opera: "21",
    "opera-android": "21",
    opera_mobile: "21",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "2.0"
  },
  "es.number.parse-float": {
    android: "37",
    bun: "0.1.1",
    chrome: "35",
    "chrome-android": "35",
    deno: "1.0",
    edge: "79",
    electron: "0.20",
    firefox: "39",
    "firefox-android": "39",
    hermes: "0.1",
    ios: "11.0",
    node: "0.11.13",
    oculus: "3.0",
    opera: "22",
    "opera-android": "22",
    opera_mobile: "22",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.14",
    safari: "11.0",
    samsung: "3.0"
  },
  "es.number.parse-int": {
    android: "37",
    bun: "0.1.1",
    chrome: "35",
    "chrome-android": "35",
    deno: "1.0",
    edge: "79",
    electron: "0.20",
    firefox: "39",
    "firefox-android": "39",
    hermes: "0.1",
    ios: "9.0",
    node: "0.11.13",
    oculus: "3.0",
    opera: "22",
    "opera-android": "22",
    opera_mobile: "22",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.14",
    safari: "9.0",
    samsung: "3.0"
  },
  "es.number.to-exponential": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "18",
    electron: "1.2",
    firefox: "87",
    "firefox-android": "87",
    hermes: "0.1",
    ios: "11.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.14",
    safari: "11",
    samsung: "5.0"
  },
  "es.number.to-fixed": {
    android: "4.4",
    bun: "0.1.1",
    chrome: "26",
    "chrome-android": "26",
    deno: "1.0",
    edge: "79",
    electron: "0.20",
    firefox: "4",
    "firefox-android": "4",
    hermes: "0.1",
    ios: "8.0",
    node: "0.11.0",
    oculus: "3.0",
    opera: "15",
    "opera-android": "15",
    opera_mobile: "15",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "1.5"
  },
  "es.number.to-precision": {
    android: "4.4",
    bun: "0.1.1",
    chrome: "26",
    "chrome-android": "26",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "4",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "8",
    ios: "8.0",
    node: "0.11.0",
    oculus: "3.0",
    opera: "15",
    "opera-android": "15",
    opera_mobile: "15",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "1.5"
  },
  "es.object.assign": {
    android: "49",
    bun: "0.1.1",
    chrome: "49",
    "chrome-android": "49",
    deno: "1.0",
    edge: "79",
    electron: "0.37",
    firefox: "36",
    "firefox-android": "36",
    hermes: "0.4",
    ios: "9.0",
    node: "6.0",
    oculus: "3.0",
    opera: "36",
    "opera-android": "36",
    opera_mobile: "36",
    quest: "3.0",
    "react-native": "0.69",
    safari: "9.0",
    samsung: "5.0"
  },
  "es.object.create": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "5",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "4",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "9",
    ios: "3.0",
    node: "0.1.27",
    oculus: "3.0",
    opera: "12",
    "opera-android": "12",
    opera_mobile: "12",
    phantom: "1.9",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "4.0",
    samsung: "1.0"
  },
  "es.object.define-getter": {
    android: "62",
    bun: "0.1.1",
    chrome: "62",
    "chrome-android": "62",
    deno: "1.0",
    edge: "16",
    electron: "3.0",
    firefox: "48",
    "firefox-android": "48",
    hermes: "0.1",
    ios: "8.0",
    node: "8.10",
    oculus: "5.0",
    opera: "49",
    "opera-android": "46",
    opera_mobile: "46",
    quest: "5.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "8.0"
  },
  "es.object.define-properties": {
    android: "37",
    bun: "0.1.1",
    chrome: "37",
    "chrome-android": "37",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "4",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "9",
    ios: "5.0",
    node: "0.11.15",
    oculus: "3.0",
    opera: "12",
    "opera-android": "12",
    opera_mobile: "12",
    phantom: "2.0",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "5.1",
    samsung: "3.0"
  },
  "es.object.define-property": {
    android: "37",
    bun: "0.1.1",
    chrome: "37",
    "chrome-android": "37",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "4",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "9",
    ios: "5.0",
    node: "0.11.15",
    oculus: "3.0",
    opera: "12",
    "opera-android": "12",
    opera_mobile: "12",
    phantom: "2.0",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "5.1",
    samsung: "3.0"
  },
  "es.object.define-setter": {
    android: "62",
    bun: "0.1.1",
    chrome: "62",
    "chrome-android": "62",
    deno: "1.0",
    edge: "16",
    electron: "3.0",
    firefox: "48",
    "firefox-android": "48",
    hermes: "0.1",
    ios: "8.0",
    node: "8.10",
    oculus: "5.0",
    opera: "49",
    "opera-android": "46",
    opera_mobile: "46",
    quest: "5.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "8.0"
  },
  "es.object.entries": {
    android: "54",
    bun: "0.1.1",
    chrome: "54",
    "chrome-android": "54",
    deno: "1.0",
    edge: "14",
    electron: "1.4",
    firefox: "47",
    "firefox-android": "47",
    hermes: "0.1",
    ios: "10.3",
    node: "7.0",
    oculus: "3.0",
    opera: "41",
    "opera-android": "41",
    opera_mobile: "41",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.14",
    safari: "10.1",
    samsung: "6.0"
  },
  "es.object.freeze": {
    android: "44",
    bun: "0.1.1",
    chrome: "44",
    "chrome-android": "44",
    deno: "1.0",
    edge: "13",
    electron: "0.30",
    firefox: "35",
    "firefox-android": "35",
    hermes: "0.1",
    ios: "9.0",
    node: "3.0",
    oculus: "3.0",
    opera: "31",
    "opera-android": "31",
    opera_mobile: "31",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "4.0"
  },
  "es.object.from-entries": {
    android: "73",
    bun: "0.1.1",
    chrome: "73",
    "chrome-android": "73",
    deno: "1.0",
    edge: "79",
    electron: "5.0",
    firefox: "63",
    "firefox-android": "63",
    hermes: "0.4",
    ios: "12.2",
    node: "12.0",
    oculus: "6.0",
    opera: "60",
    "opera-android": "52",
    opera_mobile: "52",
    quest: "6.0",
    "react-native": "0.69",
    rhino: "1.7.14",
    safari: "12.1",
    samsung: "11.0"
  },
  "es.object.get-own-property-descriptor": {
    android: "44",
    bun: "0.1.1",
    chrome: "44",
    "chrome-android": "44",
    deno: "1.0",
    edge: "13",
    electron: "0.30",
    firefox: "35",
    "firefox-android": "35",
    hermes: "0.1",
    ios: "9.0",
    node: "3.0",
    oculus: "3.0",
    opera: "31",
    "opera-android": "31",
    opera_mobile: "31",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "4.0"
  },
  "es.object.get-own-property-descriptors": {
    android: "54",
    bun: "0.1.1",
    chrome: "54",
    "chrome-android": "54",
    deno: "1.0",
    edge: "15",
    electron: "1.4",
    firefox: "50",
    "firefox-android": "50",
    hermes: "0.6",
    ios: "10.0",
    node: "7.0",
    oculus: "3.0",
    opera: "41",
    "opera-android": "41",
    opera_mobile: "41",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "6.0"
  },
  "es.object.get-own-property-names": {
    android: "40",
    bun: "0.1.1",
    chrome: "40",
    "chrome-android": "40",
    deno: "1.0",
    edge: "13",
    electron: "0.21",
    firefox: "34",
    "firefox-android": "34",
    hermes: "0.1",
    ios: "9.0",
    node: "1.0",
    oculus: "3.0",
    opera: "27",
    "opera-android": "27",
    opera_mobile: "27",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "3.4"
  },
  "es.object.get-prototype-of": {
    android: "44",
    bun: "0.1.1",
    chrome: "44",
    "chrome-android": "44",
    deno: "1.0",
    edge: "13",
    electron: "0.30",
    firefox: "35",
    "firefox-android": "35",
    hermes: "0.1",
    ios: "9.0",
    node: "3.0",
    oculus: "3.0",
    opera: "31",
    "opera-android": "31",
    opera_mobile: "31",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "4.0"
  },
  "es.object.has-own": {
    android: "93",
    bun: "0.1.1",
    chrome: "93",
    "chrome-android": "93",
    deno: "1.13",
    edge: "93",
    electron: "14.0",
    firefox: "92",
    "firefox-android": "92",
    hermes: "0.10",
    ios: "15.4",
    node: "16.9",
    oculus: "17.0",
    opera: "79",
    "opera-android": "66",
    opera_mobile: "66",
    quest: "17.0",
    "react-native": "0.69",
    safari: "15.4",
    samsung: "17.0"
  },
  "es.object.is": {
    android: "4.1",
    bun: "0.1.1",
    chrome: "19",
    "chrome-android": "25",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "22",
    "firefox-android": "22",
    hermes: "0.1",
    ios: "9.0",
    node: "0.7.3",
    oculus: "3.0",
    opera: "15",
    "opera-android": "15",
    opera_mobile: "15",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "1.5"
  },
  "es.object.is-extensible": {
    android: "44",
    bun: "0.1.1",
    chrome: "44",
    "chrome-android": "44",
    deno: "1.0",
    edge: "13",
    electron: "0.30",
    firefox: "35",
    "firefox-android": "35",
    hermes: "0.1",
    ios: "9.0",
    node: "3.0",
    oculus: "3.0",
    opera: "31",
    "opera-android": "31",
    opera_mobile: "31",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "4.0"
  },
  "es.object.is-frozen": {
    android: "44",
    bun: "0.1.1",
    chrome: "44",
    "chrome-android": "44",
    deno: "1.0",
    edge: "13",
    electron: "0.30",
    firefox: "35",
    "firefox-android": "35",
    hermes: "0.1",
    ios: "9.0",
    node: "3.0",
    oculus: "3.0",
    opera: "31",
    "opera-android": "31",
    opera_mobile: "31",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "4.0"
  },
  "es.object.is-sealed": {
    android: "44",
    bun: "0.1.1",
    chrome: "44",
    "chrome-android": "44",
    deno: "1.0",
    edge: "13",
    electron: "0.30",
    firefox: "35",
    "firefox-android": "35",
    hermes: "0.1",
    ios: "9.0",
    node: "3.0",
    oculus: "3.0",
    opera: "31",
    "opera-android": "31",
    opera_mobile: "31",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "4.0"
  },
  "es.object.keys": {
    android: "40",
    bun: "0.1.1",
    chrome: "40",
    "chrome-android": "40",
    deno: "1.0",
    edge: "13",
    electron: "0.21",
    firefox: "35",
    "firefox-android": "35",
    hermes: "0.1",
    ios: "9.0",
    node: "1.0",
    oculus: "3.0",
    opera: "27",
    "opera-android": "27",
    opera_mobile: "27",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "3.4"
  },
  "es.object.lookup-getter": {
    android: "62",
    bun: "0.1.1",
    chrome: "62",
    "chrome-android": "62",
    deno: "1.0",
    edge: "16",
    electron: "3.0",
    firefox: "48",
    "firefox-android": "48",
    hermes: "0.1",
    ios: "8.0",
    node: "8.10",
    oculus: "5.0",
    opera: "49",
    "opera-android": "46",
    opera_mobile: "46",
    quest: "5.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "8.0"
  },
  "es.object.lookup-setter": {
    android: "62",
    bun: "0.1.1",
    chrome: "62",
    "chrome-android": "62",
    deno: "1.0",
    edge: "16",
    electron: "3.0",
    firefox: "48",
    "firefox-android": "48",
    hermes: "0.1",
    ios: "8.0",
    node: "8.10",
    oculus: "5.0",
    opera: "49",
    "opera-android": "46",
    opera_mobile: "46",
    quest: "5.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "8.0"
  },
  "es.object.prevent-extensions": {
    android: "44",
    bun: "0.1.1",
    chrome: "44",
    "chrome-android": "44",
    deno: "1.0",
    edge: "13",
    electron: "0.30",
    firefox: "35",
    "firefox-android": "35",
    hermes: "0.1",
    ios: "9.0",
    node: "3.0",
    oculus: "3.0",
    opera: "31",
    "opera-android": "31",
    opera_mobile: "31",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "4.0"
  },
  "es.object.proto": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "5",
    "chrome-android": "18",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "11",
    ios: "2.0",
    node: "0.1.27",
    oculus: "3.0",
    opera: "10.50",
    "opera-android": "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    quest: "3.0",
    "react-native": "0.69",
    safari: "3.1",
    samsung: "1.0"
  },
  "es.object.seal": {
    android: "44",
    bun: "0.1.1",
    chrome: "44",
    "chrome-android": "44",
    deno: "1.0",
    edge: "13",
    electron: "0.30",
    firefox: "35",
    "firefox-android": "35",
    hermes: "0.1",
    ios: "9.0",
    node: "3.0",
    oculus: "3.0",
    opera: "31",
    "opera-android": "31",
    opera_mobile: "31",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "4.0"
  },
  "es.object.set-prototype-of": {
    android: "37",
    bun: "0.1.1",
    chrome: "34",
    "chrome-android": "34",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "31",
    "firefox-android": "31",
    hermes: "0.1",
    ie: "11",
    ios: "9.0",
    node: "0.11.13",
    oculus: "3.0",
    opera: "21",
    "opera-android": "21",
    opera_mobile: "21",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "2.0"
  },
  "es.object.to-string": {
    android: "49",
    bun: "0.1.1",
    chrome: "49",
    "chrome-android": "49",
    deno: "1.0",
    edge: "15",
    electron: "0.37",
    firefox: "51",
    "firefox-android": "51",
    hermes: "0.1",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "36",
    "opera-android": "36",
    opera_mobile: "36",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.object.values": {
    android: "54",
    bun: "0.1.1",
    chrome: "54",
    "chrome-android": "54",
    deno: "1.0",
    edge: "14",
    electron: "1.4",
    firefox: "47",
    "firefox-android": "47",
    hermes: "0.1",
    ios: "10.3",
    node: "7.0",
    oculus: "3.0",
    opera: "41",
    "opera-android": "41",
    opera_mobile: "41",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.14",
    safari: "10.1",
    samsung: "6.0"
  },
  "es.parse-float": {
    android: "37",
    bun: "0.1.1",
    chrome: "35",
    "chrome-android": "35",
    deno: "1.0",
    edge: "74",
    electron: "0.20",
    firefox: "8",
    "firefox-android": "8",
    hermes: "0.1",
    ie: "8",
    ios: "8.0",
    node: "0.11.13",
    oculus: "3.0",
    opera: "22",
    "opera-android": "22",
    opera_mobile: "22",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "3.0"
  },
  "es.parse-int": {
    android: "37",
    bun: "0.1.1",
    chrome: "35",
    "chrome-android": "35",
    deno: "1.0",
    edge: "74",
    electron: "0.20",
    firefox: "21",
    "firefox-android": "21",
    hermes: "0.1",
    ie: "9",
    ios: "8.0",
    node: "0.11.13",
    oculus: "3.0",
    opera: "22",
    "opera-android": "22",
    opera_mobile: "22",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "7.1",
    samsung: "3.0"
  },
  "es.promise": {
    android: "67",
    bun: "0.1.1",
    chrome: "67",
    "chrome-android": "67",
    deno: "1.24",
    edge: "79",
    electron: "4.0",
    firefox: "69",
    "firefox-android": "69",
    ios: "11.0",
    node: "10.4",
    oculus: "6.0",
    opera: "54",
    "opera-android": "48",
    opera_mobile: "48",
    quest: "6.0",
    rhino: "1.7.14",
    safari: "11.0",
    samsung: "9.0"
  },
  "es.promise.all-settled": {
    android: "76",
    bun: "0.1.1",
    chrome: "76",
    "chrome-android": "76",
    deno: "1.24",
    edge: "79",
    electron: "6.0",
    firefox: "71",
    "firefox-android": "71",
    ios: "13.0",
    node: "12.9",
    oculus: "7.0",
    opera: "63",
    "opera-android": "54",
    opera_mobile: "54",
    quest: "7.0",
    safari: "13",
    samsung: "12.0"
  },
  "es.promise.any": {
    android: "85",
    bun: "0.1.1",
    chrome: "85",
    "chrome-android": "85",
    deno: "1.24",
    edge: "85",
    electron: "10.0",
    firefox: "79",
    "firefox-android": "79",
    ios: "14.0",
    node: "15.0",
    oculus: "12.0",
    opera: "71",
    "opera-android": "60",
    opera_mobile: "60",
    quest: "12.0",
    safari: "14.0",
    samsung: "14.0"
  },
  "es.promise.finally": {
    android: "67",
    bun: "0.1.1",
    chrome: "67",
    "chrome-android": "67",
    deno: "1.24",
    edge: "79",
    electron: "4.0",
    firefox: "69",
    "firefox-android": "69",
    ios: "13.2.3",
    node: "10.4",
    oculus: "6.0",
    opera: "54",
    "opera-android": "48",
    opera_mobile: "48",
    quest: "6.0",
    rhino: "1.7.14",
    safari: "13.0.3",
    samsung: "9.0"
  },
  "es.reflect.apply": {
    android: "49",
    bun: "0.1.1",
    chrome: "49",
    "chrome-android": "49",
    deno: "1.0",
    edge: "15",
    electron: "0.37",
    firefox: "42",
    "firefox-android": "42",
    hermes: "0.7",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "36",
    "opera-android": "36",
    opera_mobile: "36",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.reflect.construct": {
    android: "49",
    bun: "0.1.1",
    chrome: "49",
    "chrome-android": "49",
    deno: "1.0",
    edge: "15",
    electron: "0.37",
    firefox: "44",
    "firefox-android": "44",
    hermes: "0.7",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "36",
    "opera-android": "36",
    opera_mobile: "36",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.reflect.define-property": {
    android: "49",
    bun: "0.1.1",
    chrome: "49",
    "chrome-android": "49",
    deno: "1.0",
    edge: "13",
    electron: "0.37",
    firefox: "42",
    "firefox-android": "42",
    hermes: "0.7",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "36",
    "opera-android": "36",
    opera_mobile: "36",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.reflect.delete-property": {
    android: "49",
    bun: "0.1.1",
    chrome: "49",
    "chrome-android": "49",
    deno: "1.0",
    edge: "12",
    electron: "0.37",
    firefox: "42",
    "firefox-android": "42",
    hermes: "0.7",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "36",
    "opera-android": "36",
    opera_mobile: "36",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.reflect.get": {
    android: "49",
    bun: "0.1.1",
    chrome: "49",
    "chrome-android": "49",
    deno: "1.0",
    edge: "12",
    electron: "0.37",
    firefox: "42",
    "firefox-android": "42",
    hermes: "0.7",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "36",
    "opera-android": "36",
    opera_mobile: "36",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.reflect.get-own-property-descriptor": {
    android: "49",
    bun: "0.1.1",
    chrome: "49",
    "chrome-android": "49",
    deno: "1.0",
    edge: "12",
    electron: "0.37",
    firefox: "42",
    "firefox-android": "42",
    hermes: "0.7",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "36",
    "opera-android": "36",
    opera_mobile: "36",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.reflect.get-prototype-of": {
    android: "49",
    bun: "0.1.1",
    chrome: "49",
    "chrome-android": "49",
    deno: "1.0",
    edge: "12",
    electron: "0.37",
    firefox: "42",
    "firefox-android": "42",
    hermes: "0.7",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "36",
    "opera-android": "36",
    opera_mobile: "36",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.reflect.has": {
    android: "49",
    bun: "0.1.1",
    chrome: "49",
    "chrome-android": "49",
    deno: "1.0",
    edge: "12",
    electron: "0.37",
    firefox: "42",
    "firefox-android": "42",
    hermes: "0.7",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "36",
    "opera-android": "36",
    opera_mobile: "36",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.reflect.is-extensible": {
    android: "49",
    bun: "0.1.1",
    chrome: "49",
    "chrome-android": "49",
    deno: "1.0",
    edge: "12",
    electron: "0.37",
    firefox: "42",
    "firefox-android": "42",
    hermes: "0.7",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "36",
    "opera-android": "36",
    opera_mobile: "36",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.reflect.own-keys": {
    android: "49",
    bun: "0.1.1",
    chrome: "49",
    "chrome-android": "49",
    deno: "1.0",
    edge: "12",
    electron: "0.37",
    firefox: "42",
    "firefox-android": "42",
    hermes: "0.7",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "36",
    "opera-android": "36",
    opera_mobile: "36",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.reflect.prevent-extensions": {
    android: "49",
    bun: "0.1.1",
    chrome: "49",
    "chrome-android": "49",
    deno: "1.0",
    edge: "12",
    electron: "0.37",
    firefox: "42",
    "firefox-android": "42",
    hermes: "0.7",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "36",
    "opera-android": "36",
    opera_mobile: "36",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.reflect.set": {
    android: "49",
    bun: "0.1.1",
    chrome: "49",
    "chrome-android": "49",
    deno: "1.0",
    edge: "79",
    electron: "0.37",
    firefox: "42",
    "firefox-android": "42",
    hermes: "0.7",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "36",
    "opera-android": "36",
    opera_mobile: "36",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.reflect.set-prototype-of": {
    android: "49",
    bun: "0.1.1",
    chrome: "49",
    "chrome-android": "49",
    deno: "1.0",
    edge: "12",
    electron: "0.37",
    firefox: "42",
    "firefox-android": "42",
    hermes: "0.7",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "36",
    "opera-android": "36",
    opera_mobile: "36",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.reflect.to-string-tag": {
    android: "86",
    bun: "0.1.1",
    chrome: "86",
    "chrome-android": "86",
    deno: "1.3",
    edge: "86",
    electron: "11.0",
    firefox: "82",
    "firefox-android": "82",
    hermes: "0.7",
    ios: "14.0",
    node: "15.0",
    oculus: "12.0",
    opera: "72",
    "opera-android": "61",
    opera_mobile: "61",
    quest: "12.0",
    "react-native": "0.69",
    safari: "14.0",
    samsung: "14.0"
  },
  "es.regexp.constructor": {
    android: "64",
    bun: "0.1.1",
    chrome: "64",
    "chrome-android": "64",
    deno: "1.0",
    edge: "79",
    electron: "3.0",
    firefox: "78",
    "firefox-android": "78",
    ios: "11.3",
    node: "10.0",
    oculus: "5.0",
    opera: "51",
    "opera-android": "47",
    opera_mobile: "47",
    quest: "5.0",
    safari: "11.1",
    samsung: "9.0"
  },
  "es.regexp.dot-all": {
    android: "62",
    bun: "0.1.1",
    chrome: "62",
    "chrome-android": "62",
    deno: "1.0",
    edge: "79",
    electron: "3.0",
    firefox: "78",
    "firefox-android": "78",
    hermes: "0.4",
    ios: "11.3",
    node: "8.10",
    oculus: "5.0",
    opera: "49",
    "opera-android": "46",
    opera_mobile: "46",
    quest: "5.0",
    "react-native": "0.69",
    safari: "11.1",
    samsung: "8.0"
  },
  "es.regexp.exec": {
    android: "64",
    bun: "0.1.1",
    chrome: "64",
    "chrome-android": "64",
    deno: "1.0",
    edge: "79",
    electron: "3.0",
    firefox: "78",
    "firefox-android": "78",
    ios: "11.3",
    node: "10.0",
    oculus: "5.0",
    opera: "51",
    "opera-android": "47",
    opera_mobile: "47",
    quest: "5.0",
    "react-native": "0.71",
    safari: "11.1",
    samsung: "9.0"
  },
  "es.regexp.flags": {
    android: "111",
    bun: "0.1.1",
    chrome: "111",
    "chrome-android": "111",
    deno: "1.32",
    edge: "111",
    electron: "24.0",
    firefox: "78",
    "firefox-android": "78",
    hermes: "0.4",
    ios: "11.3",
    node: "20.0",
    oculus: "27.0",
    opera: "97",
    "opera-android": "75",
    opera_mobile: "75",
    quest: "27.0",
    "react-native": "0.69",
    safari: "11.1",
    samsung: "22.0"
  },
  "es.regexp.sticky": {
    android: "49",
    bun: "0.1.1",
    chrome: "49",
    "chrome-android": "49",
    deno: "1.0",
    edge: "13",
    electron: "0.37",
    firefox: "3",
    "firefox-android": "4",
    hermes: "0.3",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "36",
    "opera-android": "36",
    opera_mobile: "36",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.regexp.test": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "79",
    electron: "1.2",
    firefox: "46",
    "firefox-android": "46",
    ios: "10.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.regexp.to-string": {
    android: "50",
    bun: "0.1.1",
    chrome: "50",
    "chrome-android": "50",
    deno: "1.0",
    edge: "79",
    electron: "1.1",
    firefox: "46",
    "firefox-android": "46",
    hermes: "0.1",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "37",
    "opera-android": "37",
    opera_mobile: "37",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.set": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "15",
    electron: "1.2",
    firefox: "53",
    "firefox-android": "53",
    ios: "10.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    rhino: "1.7.13",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.string.at-alternative": {
    android: "92",
    bun: "0.1.1",
    chrome: "92",
    "chrome-android": "92",
    deno: "1.12",
    edge: "92",
    electron: "14.0",
    firefox: "90",
    "firefox-android": "90",
    ios: "15.4",
    node: "16.6",
    oculus: "17.0",
    opera: "78",
    "opera-android": "65",
    opera_mobile: "65",
    quest: "17.0",
    "react-native": "0.71",
    safari: "15.4",
    samsung: "16.0"
  },
  "es.string.code-point-at": {
    android: "41",
    bun: "0.1.1",
    chrome: "41",
    "chrome-android": "41",
    deno: "1.0",
    edge: "13",
    electron: "0.21",
    firefox: "29",
    "firefox-android": "29",
    hermes: "0.1",
    ios: "9.0",
    node: "1.0",
    oculus: "3.0",
    opera: "28",
    "opera-android": "28",
    opera_mobile: "28",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "3.4"
  },
  "es.string.ends-with": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "79",
    electron: "1.2",
    firefox: "40",
    "firefox-android": "40",
    hermes: "0.1",
    ios: "10.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.string.from-code-point": {
    android: "41",
    bun: "0.1.1",
    chrome: "41",
    "chrome-android": "41",
    deno: "1.0",
    edge: "13",
    electron: "0.21",
    firefox: "29",
    "firefox-android": "29",
    hermes: "0.1",
    ios: "9.0",
    node: "1.0",
    oculus: "3.0",
    opera: "28",
    "opera-android": "28",
    opera_mobile: "28",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "3.4"
  },
  "es.string.includes": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "79",
    electron: "1.2",
    firefox: "40",
    "firefox-android": "40",
    hermes: "0.1",
    ios: "10.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.string.is-well-formed": {
    android: "111",
    bun: "0.4.0",
    chrome: "111",
    "chrome-android": "111",
    deno: "1.32",
    edge: "111",
    electron: "24.0",
    ios: "16.4",
    node: "20.0",
    oculus: "27.0",
    opera: "97",
    "opera-android": "75",
    opera_mobile: "75",
    quest: "27.0",
    safari: "16.4",
    samsung: "22.0"
  },
  "es.string.iterator": {
    android: "41",
    bun: "0.1.1",
    chrome: "41",
    "chrome-android": "41",
    deno: "1.0",
    edge: "13",
    electron: "0.21",
    firefox: "36",
    "firefox-android": "36",
    hermes: "0.1",
    ios: "9.0",
    node: "1.0",
    oculus: "3.0",
    opera: "28",
    "opera-android": "28",
    opera_mobile: "28",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "3.4"
  },
  "es.string.match": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "79",
    electron: "1.2",
    firefox: "49",
    "firefox-android": "49",
    hermes: "0.1",
    ios: "10.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.string.match-all": {
    android: "80",
    bun: "0.1.1",
    chrome: "80",
    "chrome-android": "80",
    deno: "1.0",
    edge: "80",
    electron: "8.0",
    firefox: "73",
    "firefox-android": "73",
    hermes: "0.6",
    ios: "13.4",
    node: "14.0",
    oculus: "9.0",
    opera: "67",
    "opera-android": "57",
    opera_mobile: "57",
    quest: "9.0",
    "react-native": "0.69",
    safari: "13.1",
    samsung: "13.0"
  },
  "es.string.pad-end": {
    android: "57",
    bun: "0.1.1",
    chrome: "57",
    "chrome-android": "57",
    deno: "1.0",
    edge: "15",
    electron: "1.7",
    firefox: "48",
    "firefox-android": "48",
    hermes: "0.1",
    ios: "11.0",
    node: "8.0",
    oculus: "3.0",
    opera: "44",
    "opera-android": "43",
    opera_mobile: "43",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "11.0",
    samsung: "7.0"
  },
  "es.string.pad-start": {
    android: "57",
    bun: "0.1.1",
    chrome: "57",
    "chrome-android": "57",
    deno: "1.0",
    edge: "15",
    electron: "1.7",
    firefox: "48",
    "firefox-android": "48",
    hermes: "0.1",
    ios: "11.0",
    node: "8.0",
    oculus: "3.0",
    opera: "44",
    "opera-android": "43",
    opera_mobile: "43",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "11.0",
    samsung: "7.0"
  },
  "es.string.raw": {
    android: "41",
    bun: "0.1.1",
    chrome: "41",
    "chrome-android": "41",
    deno: "1.0",
    edge: "13",
    electron: "0.21",
    firefox: "34",
    "firefox-android": "34",
    hermes: "0.1",
    ios: "9.0",
    node: "1.0",
    oculus: "3.0",
    opera: "28",
    "opera-android": "28",
    opera_mobile: "28",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.14",
    safari: "9.0",
    samsung: "3.4"
  },
  "es.string.repeat": {
    android: "41",
    bun: "0.1.1",
    chrome: "41",
    "chrome-android": "41",
    deno: "1.0",
    edge: "13",
    electron: "0.21",
    firefox: "24",
    "firefox-android": "24",
    hermes: "0.1",
    ios: "9.0",
    node: "1.0",
    oculus: "3.0",
    opera: "28",
    "opera-android": "28",
    opera_mobile: "28",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "9.0",
    samsung: "3.4"
  },
  "es.string.replace": {
    android: "64",
    bun: "0.1.1",
    chrome: "64",
    "chrome-android": "64",
    deno: "1.0",
    edge: "79",
    electron: "3.0",
    firefox: "78",
    "firefox-android": "78",
    ios: "14.0",
    node: "10.0",
    oculus: "5.0",
    opera: "51",
    "opera-android": "47",
    opera_mobile: "47",
    quest: "5.0",
    "react-native": "0.71",
    safari: "14.0",
    samsung: "9.0"
  },
  "es.string.replace-all": {
    android: "85",
    bun: "0.1.1",
    chrome: "85",
    "chrome-android": "85",
    deno: "1.2",
    edge: "85",
    electron: "10.0",
    firefox: "77",
    "firefox-android": "77",
    hermes: "0.7",
    ios: "13.4",
    node: "15.0",
    oculus: "12.0",
    opera: "71",
    "opera-android": "60",
    opera_mobile: "60",
    quest: "12.0",
    "react-native": "0.69",
    safari: "13.1",
    samsung: "14.0"
  },
  "es.string.search": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "79",
    electron: "1.2",
    firefox: "49",
    "firefox-android": "49",
    hermes: "0.1",
    ios: "10.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.string.split": {
    android: "54",
    bun: "0.1.1",
    chrome: "54",
    "chrome-android": "54",
    deno: "1.0",
    edge: "79",
    electron: "1.4",
    firefox: "49",
    "firefox-android": "49",
    ios: "10.0",
    node: "7.0",
    oculus: "3.0",
    opera: "41",
    "opera-android": "41",
    opera_mobile: "41",
    quest: "3.0",
    safari: "10.0",
    samsung: "6.0"
  },
  "es.string.starts-with": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "79",
    electron: "1.2",
    firefox: "40",
    "firefox-android": "40",
    hermes: "0.1",
    ios: "10.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.string.substr": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "1",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "1",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "9",
    ios: "1.0",
    node: "0.0.3",
    oculus: "3.0",
    opera: "4",
    "opera-android": "4",
    opera_mobile: "4",
    phantom: "1.9",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "1",
    samsung: "1.0"
  },
  "es.string.to-well-formed": {
    android: "111",
    bun: "0.5.7",
    chrome: "111",
    "chrome-android": "111",
    deno: "1.32",
    edge: "111",
    electron: "24.0",
    ios: "16.4",
    node: "20.0",
    oculus: "27.0",
    opera: "97",
    "opera-android": "75",
    opera_mobile: "75",
    quest: "27.0",
    safari: "16.4",
    samsung: "22.0"
  },
  "es.string.trim": {
    android: "59",
    bun: "0.1.1",
    chrome: "59",
    "chrome-android": "59",
    deno: "1.0",
    edge: "15",
    electron: "1.8",
    firefox: "52",
    "firefox-android": "52",
    hermes: "0.1",
    ios: "12.2",
    node: "8.3",
    oculus: "4.0",
    opera: "46",
    "opera-android": "43",
    opera_mobile: "43",
    quest: "4.0",
    "react-native": "0.69",
    safari: "12.1",
    samsung: "7.0"
  },
  "es.string.trim-end": {
    android: "66",
    bun: "0.1.1",
    chrome: "66",
    "chrome-android": "66",
    deno: "1.0",
    edge: "79",
    electron: "3.0",
    firefox: "61",
    "firefox-android": "61",
    hermes: "0.3",
    ios: "12.2",
    node: "10.0",
    oculus: "5.0",
    opera: "53",
    "opera-android": "47",
    opera_mobile: "47",
    quest: "5.0",
    "react-native": "0.69",
    safari: "12.1",
    samsung: "9.0"
  },
  "es.string.trim-start": {
    android: "66",
    bun: "0.1.1",
    chrome: "66",
    "chrome-android": "66",
    deno: "1.0",
    edge: "79",
    electron: "3.0",
    firefox: "61",
    "firefox-android": "61",
    hermes: "0.3",
    ios: "12.0",
    node: "10.0",
    oculus: "5.0",
    opera: "53",
    "opera-android": "47",
    opera_mobile: "47",
    quest: "5.0",
    "react-native": "0.69",
    safari: "12.0",
    samsung: "9.0"
  },
  "es.string.anchor": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "5",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "17",
    "firefox-android": "17",
    ios: "6.0",
    node: "0.1.27",
    oculus: "3.0",
    opera: "15",
    "opera-android": "15",
    opera_mobile: "15",
    phantom: "2.0",
    quest: "3.0",
    rhino: "1.7.14",
    safari: "6.0",
    samsung: "1.0"
  },
  "es.string.big": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "5",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    "firefox-android": "4",
    ios: "2.0",
    node: "0.1.27",
    oculus: "3.0",
    opera: "10.50",
    "opera-android": "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    quest: "3.0",
    rhino: "1.7.13",
    safari: "3.1",
    samsung: "1.0"
  },
  "es.string.blink": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "5",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    "firefox-android": "4",
    ios: "2.0",
    node: "0.1.27",
    oculus: "3.0",
    opera: "10.50",
    "opera-android": "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    quest: "3.0",
    rhino: "1.7.13",
    safari: "3.1",
    samsung: "1.0"
  },
  "es.string.bold": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "5",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    "firefox-android": "4",
    ios: "2.0",
    node: "0.1.27",
    oculus: "3.0",
    opera: "10.50",
    "opera-android": "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    quest: "3.0",
    rhino: "1.7.13",
    safari: "3.1",
    samsung: "1.0"
  },
  "es.string.fixed": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "5",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    "firefox-android": "4",
    ios: "2.0",
    node: "0.1.27",
    oculus: "3.0",
    opera: "10.50",
    "opera-android": "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    quest: "3.0",
    rhino: "1.7.13",
    safari: "3.1",
    samsung: "1.0"
  },
  "es.string.fontcolor": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "5",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "17",
    "firefox-android": "17",
    ios: "6.0",
    node: "0.1.27",
    oculus: "3.0",
    opera: "15",
    "opera-android": "15",
    opera_mobile: "15",
    phantom: "2.0",
    quest: "3.0",
    rhino: "1.7.14",
    safari: "6.0",
    samsung: "1.0"
  },
  "es.string.fontsize": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "5",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "17",
    "firefox-android": "17",
    ios: "6.0",
    node: "0.1.27",
    oculus: "3.0",
    opera: "15",
    "opera-android": "15",
    opera_mobile: "15",
    phantom: "2.0",
    quest: "3.0",
    rhino: "1.7.14",
    safari: "6.0",
    samsung: "1.0"
  },
  "es.string.italics": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "5",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    "firefox-android": "4",
    ios: "2.0",
    node: "0.1.27",
    oculus: "3.0",
    opera: "10.50",
    "opera-android": "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    quest: "3.0",
    rhino: "1.7.13",
    safari: "3.1",
    samsung: "1.0"
  },
  "es.string.link": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "5",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "17",
    "firefox-android": "17",
    ios: "6.0",
    node: "0.1.27",
    oculus: "3.0",
    opera: "15",
    "opera-android": "15",
    opera_mobile: "15",
    phantom: "2.0",
    quest: "3.0",
    rhino: "1.7.14",
    safari: "6.0",
    samsung: "1.0"
  },
  "es.string.small": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "5",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    "firefox-android": "4",
    ios: "2.0",
    node: "0.1.27",
    oculus: "3.0",
    opera: "10.50",
    "opera-android": "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    quest: "3.0",
    rhino: "1.7.13",
    safari: "3.1",
    samsung: "1.0"
  },
  "es.string.strike": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "5",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    "firefox-android": "4",
    ios: "2.0",
    node: "0.1.27",
    oculus: "3.0",
    opera: "10.50",
    "opera-android": "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    quest: "3.0",
    rhino: "1.7.13",
    safari: "3.1",
    samsung: "1.0"
  },
  "es.string.sub": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "5",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    "firefox-android": "4",
    ios: "2.0",
    node: "0.1.27",
    oculus: "3.0",
    opera: "10.50",
    "opera-android": "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    quest: "3.0",
    rhino: "1.7.13",
    safari: "3.1",
    samsung: "1.0"
  },
  "es.string.sup": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "5",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "2",
    "firefox-android": "4",
    ios: "2.0",
    node: "0.1.27",
    oculus: "3.0",
    opera: "10.50",
    "opera-android": "10.50",
    opera_mobile: "10.50",
    phantom: "1.9",
    quest: "3.0",
    rhino: "1.7.13",
    safari: "3.1",
    samsung: "1.0"
  },
  "es.typed-array.float32-array": {
    android: "54",
    bun: "0.1.1",
    chrome: "54",
    "chrome-android": "54",
    deno: "1.0",
    edge: "15",
    electron: "1.4",
    firefox: "55",
    "firefox-android": "55",
    ios: "14.0",
    node: "7.0",
    oculus: "3.0",
    opera: "41",
    "opera-android": "41",
    opera_mobile: "41",
    quest: "3.0",
    safari: "14.0",
    samsung: "6.0"
  },
  "es.typed-array.float64-array": {
    android: "54",
    bun: "0.1.1",
    chrome: "54",
    "chrome-android": "54",
    deno: "1.0",
    edge: "15",
    electron: "1.4",
    firefox: "55",
    "firefox-android": "55",
    ios: "14.0",
    node: "7.0",
    oculus: "3.0",
    opera: "41",
    "opera-android": "41",
    opera_mobile: "41",
    quest: "3.0",
    safari: "14.0",
    samsung: "6.0"
  },
  "es.typed-array.int8-array": {
    android: "54",
    bun: "0.1.1",
    chrome: "54",
    "chrome-android": "54",
    deno: "1.0",
    edge: "15",
    electron: "1.4",
    firefox: "55",
    "firefox-android": "55",
    ios: "14.0",
    node: "7.0",
    oculus: "3.0",
    opera: "41",
    "opera-android": "41",
    opera_mobile: "41",
    quest: "3.0",
    safari: "14.0",
    samsung: "6.0"
  },
  "es.typed-array.int16-array": {
    android: "54",
    bun: "0.1.1",
    chrome: "54",
    "chrome-android": "54",
    deno: "1.0",
    edge: "15",
    electron: "1.4",
    firefox: "55",
    "firefox-android": "55",
    ios: "14.0",
    node: "7.0",
    oculus: "3.0",
    opera: "41",
    "opera-android": "41",
    opera_mobile: "41",
    quest: "3.0",
    safari: "14.0",
    samsung: "6.0"
  },
  "es.typed-array.int32-array": {
    android: "54",
    bun: "0.1.1",
    chrome: "54",
    "chrome-android": "54",
    deno: "1.0",
    edge: "15",
    electron: "1.4",
    firefox: "55",
    "firefox-android": "55",
    ios: "14.0",
    node: "7.0",
    oculus: "3.0",
    opera: "41",
    "opera-android": "41",
    opera_mobile: "41",
    quest: "3.0",
    safari: "14.0",
    samsung: "6.0"
  },
  "es.typed-array.uint8-array": {
    android: "54",
    bun: "0.1.1",
    chrome: "54",
    "chrome-android": "54",
    deno: "1.0",
    edge: "15",
    electron: "1.4",
    firefox: "55",
    "firefox-android": "55",
    ios: "14.0",
    node: "7.0",
    oculus: "3.0",
    opera: "41",
    "opera-android": "41",
    opera_mobile: "41",
    quest: "3.0",
    safari: "14.0",
    samsung: "6.0"
  },
  "es.typed-array.uint8-clamped-array": {
    android: "54",
    bun: "0.1.1",
    chrome: "54",
    "chrome-android": "54",
    deno: "1.0",
    edge: "15",
    electron: "1.4",
    firefox: "55",
    "firefox-android": "55",
    ios: "14.0",
    node: "7.0",
    oculus: "3.0",
    opera: "41",
    "opera-android": "41",
    opera_mobile: "41",
    quest: "3.0",
    safari: "14.0",
    samsung: "6.0"
  },
  "es.typed-array.uint16-array": {
    android: "54",
    bun: "0.1.1",
    chrome: "54",
    "chrome-android": "54",
    deno: "1.0",
    edge: "15",
    electron: "1.4",
    firefox: "55",
    "firefox-android": "55",
    ios: "14.0",
    node: "7.0",
    oculus: "3.0",
    opera: "41",
    "opera-android": "41",
    opera_mobile: "41",
    quest: "3.0",
    safari: "14.0",
    samsung: "6.0"
  },
  "es.typed-array.uint32-array": {
    android: "54",
    bun: "0.1.1",
    chrome: "54",
    "chrome-android": "54",
    deno: "1.0",
    edge: "15",
    electron: "1.4",
    firefox: "55",
    "firefox-android": "55",
    ios: "14.0",
    node: "7.0",
    oculus: "3.0",
    opera: "41",
    "opera-android": "41",
    opera_mobile: "41",
    quest: "3.0",
    safari: "14.0",
    samsung: "6.0"
  },
  "es.typed-array.at": {
    android: "92",
    bun: "0.1.1",
    chrome: "92",
    "chrome-android": "92",
    deno: "1.12",
    edge: "92",
    electron: "14.0",
    firefox: "90",
    "firefox-android": "90",
    ios: "15.4",
    node: "16.6",
    oculus: "17.0",
    opera: "78",
    "opera-android": "65",
    opera_mobile: "65",
    quest: "17.0",
    "react-native": "0.71",
    safari: "15.4",
    samsung: "16.0"
  },
  "es.typed-array.copy-within": {
    android: "45",
    bun: "0.1.1",
    chrome: "45",
    "chrome-android": "45",
    deno: "1.0",
    edge: "13",
    electron: "0.31",
    firefox: "34",
    "firefox-android": "34",
    hermes: "0.1",
    ios: "10.0",
    node: "4.0",
    oculus: "3.0",
    opera: "32",
    "opera-android": "32",
    opera_mobile: "32",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.typed-array.every": {
    android: "45",
    bun: "0.1.1",
    chrome: "45",
    "chrome-android": "45",
    deno: "1.0",
    edge: "13",
    electron: "0.31",
    firefox: "37",
    "firefox-android": "37",
    hermes: "0.1",
    ios: "10.0",
    node: "4.0",
    oculus: "3.0",
    opera: "32",
    "opera-android": "32",
    opera_mobile: "32",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.typed-array.fill": {
    android: "58",
    bun: "0.1.1",
    chrome: "58",
    "chrome-android": "58",
    deno: "1.0",
    edge: "79",
    electron: "1.7",
    firefox: "55",
    "firefox-android": "55",
    hermes: "0.1",
    ios: "14.5",
    node: "8.0",
    oculus: "4.0",
    opera: "45",
    "opera-android": "43",
    opera_mobile: "43",
    quest: "4.0",
    "react-native": "0.69",
    safari: "14.1",
    samsung: "7.0"
  },
  "es.typed-array.filter": {
    android: "45",
    bun: "0.1.1",
    chrome: "45",
    "chrome-android": "45",
    deno: "1.0",
    edge: "13",
    electron: "0.31",
    firefox: "38",
    "firefox-android": "38",
    hermes: "0.1",
    ios: "10.0",
    node: "4.0",
    oculus: "3.0",
    opera: "32",
    "opera-android": "32",
    opera_mobile: "32",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.typed-array.find": {
    android: "45",
    bun: "0.1.1",
    chrome: "45",
    "chrome-android": "45",
    deno: "1.0",
    edge: "13",
    electron: "0.31",
    firefox: "37",
    "firefox-android": "37",
    hermes: "0.1",
    ios: "10.0",
    node: "4.0",
    oculus: "3.0",
    opera: "32",
    "opera-android": "32",
    opera_mobile: "32",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.typed-array.find-index": {
    android: "45",
    bun: "0.1.1",
    chrome: "45",
    "chrome-android": "45",
    deno: "1.0",
    edge: "13",
    electron: "0.31",
    firefox: "37",
    "firefox-android": "37",
    hermes: "0.1",
    ios: "10.0",
    node: "4.0",
    oculus: "3.0",
    opera: "32",
    "opera-android": "32",
    opera_mobile: "32",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.typed-array.find-last": {
    android: "97",
    bun: "0.1.1",
    chrome: "97",
    "chrome-android": "97",
    deno: "1.16",
    edge: "97",
    electron: "17.0",
    firefox: "104",
    "firefox-android": "104",
    hermes: "0.11",
    ios: "15.4",
    node: "18.0",
    oculus: "20.0",
    opera: "83",
    "opera-android": "68",
    opera_mobile: "68",
    quest: "20.0",
    "react-native": "0.69",
    safari: "15.4",
    samsung: "18.0"
  },
  "es.typed-array.find-last-index": {
    android: "97",
    bun: "0.1.1",
    chrome: "97",
    "chrome-android": "97",
    deno: "1.16",
    edge: "97",
    electron: "17.0",
    firefox: "104",
    "firefox-android": "104",
    hermes: "0.11",
    ios: "15.4",
    node: "18.0",
    oculus: "20.0",
    opera: "83",
    "opera-android": "68",
    opera_mobile: "68",
    quest: "20.0",
    "react-native": "0.69",
    safari: "15.4",
    samsung: "18.0"
  },
  "es.typed-array.for-each": {
    android: "45",
    bun: "0.1.1",
    chrome: "45",
    "chrome-android": "45",
    deno: "1.0",
    edge: "13",
    electron: "0.31",
    firefox: "38",
    "firefox-android": "38",
    hermes: "0.1",
    ios: "10.0",
    node: "4.0",
    oculus: "3.0",
    opera: "32",
    "opera-android": "32",
    opera_mobile: "32",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.typed-array.from": {
    android: "54",
    bun: "0.1.1",
    chrome: "54",
    "chrome-android": "54",
    deno: "1.0",
    edge: "15",
    electron: "1.4",
    firefox: "55",
    "firefox-android": "55",
    ios: "14.0",
    node: "7.0",
    oculus: "3.0",
    opera: "41",
    "opera-android": "41",
    opera_mobile: "41",
    quest: "3.0",
    safari: "14.0",
    samsung: "6.0"
  },
  "es.typed-array.includes": {
    android: "49",
    bun: "0.1.1",
    chrome: "49",
    "chrome-android": "49",
    deno: "1.0",
    edge: "14",
    electron: "0.37",
    firefox: "43",
    "firefox-android": "43",
    hermes: "0.1",
    ios: "10.0",
    node: "6.0",
    oculus: "3.0",
    opera: "36",
    "opera-android": "36",
    opera_mobile: "36",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.typed-array.index-of": {
    android: "45",
    bun: "0.1.1",
    chrome: "45",
    "chrome-android": "45",
    deno: "1.0",
    edge: "13",
    electron: "0.31",
    firefox: "37",
    "firefox-android": "37",
    hermes: "0.1",
    ios: "10.0",
    node: "4.0",
    oculus: "3.0",
    opera: "32",
    "opera-android": "32",
    opera_mobile: "32",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.typed-array.iterator": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "13",
    electron: "1.2",
    firefox: "37",
    "firefox-android": "37",
    hermes: "0.1",
    ios: "10.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.typed-array.join": {
    android: "45",
    bun: "0.1.1",
    chrome: "45",
    "chrome-android": "45",
    deno: "1.0",
    edge: "13",
    electron: "0.31",
    firefox: "37",
    "firefox-android": "37",
    hermes: "0.1",
    ios: "10.0",
    node: "4.0",
    oculus: "3.0",
    opera: "32",
    "opera-android": "32",
    opera_mobile: "32",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.typed-array.last-index-of": {
    android: "45",
    bun: "0.1.1",
    chrome: "45",
    "chrome-android": "45",
    deno: "1.0",
    edge: "13",
    electron: "0.31",
    firefox: "37",
    "firefox-android": "37",
    hermes: "0.1",
    ios: "10.0",
    node: "4.0",
    oculus: "3.0",
    opera: "32",
    "opera-android": "32",
    opera_mobile: "32",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.typed-array.map": {
    android: "45",
    bun: "0.1.1",
    chrome: "45",
    "chrome-android": "45",
    deno: "1.0",
    edge: "13",
    electron: "0.31",
    firefox: "38",
    "firefox-android": "38",
    hermes: "0.1",
    ios: "10.0",
    node: "4.0",
    oculus: "3.0",
    opera: "32",
    "opera-android": "32",
    opera_mobile: "32",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.typed-array.of": {
    android: "54",
    bun: "0.1.1",
    chrome: "54",
    "chrome-android": "54",
    deno: "1.0",
    edge: "15",
    electron: "1.4",
    firefox: "55",
    "firefox-android": "55",
    ios: "14.0",
    node: "7.0",
    oculus: "3.0",
    opera: "41",
    "opera-android": "41",
    opera_mobile: "41",
    quest: "3.0",
    safari: "14.0",
    samsung: "6.0"
  },
  "es.typed-array.reduce": {
    android: "45",
    bun: "0.1.1",
    chrome: "45",
    "chrome-android": "45",
    deno: "1.0",
    edge: "13",
    electron: "0.31",
    firefox: "37",
    "firefox-android": "37",
    hermes: "0.1",
    ios: "10.0",
    node: "4.0",
    oculus: "3.0",
    opera: "32",
    "opera-android": "32",
    opera_mobile: "32",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.typed-array.reduce-right": {
    android: "45",
    bun: "0.1.1",
    chrome: "45",
    "chrome-android": "45",
    deno: "1.0",
    edge: "13",
    electron: "0.31",
    firefox: "37",
    "firefox-android": "37",
    hermes: "0.1",
    ios: "10.0",
    node: "4.0",
    oculus: "3.0",
    opera: "32",
    "opera-android": "32",
    opera_mobile: "32",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.typed-array.reverse": {
    android: "45",
    bun: "0.1.1",
    chrome: "45",
    "chrome-android": "45",
    deno: "1.0",
    edge: "13",
    electron: "0.31",
    firefox: "37",
    "firefox-android": "37",
    hermes: "0.1",
    ios: "10.0",
    node: "4.0",
    oculus: "3.0",
    opera: "32",
    "opera-android": "32",
    opera_mobile: "32",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.typed-array.set": {
    android: "95",
    bun: "0.1.1",
    chrome: "95",
    "chrome-android": "95",
    deno: "1.15",
    edge: "95",
    electron: "16.0",
    firefox: "54",
    "firefox-android": "54",
    hermes: "0.1",
    ios: "14.5",
    node: "17.0",
    oculus: "18.0",
    opera: "81",
    "opera-android": "67",
    opera_mobile: "67",
    quest: "18.0",
    "react-native": "0.69",
    safari: "14.1",
    samsung: "17.0"
  },
  "es.typed-array.slice": {
    android: "45",
    bun: "0.1.1",
    chrome: "45",
    "chrome-android": "45",
    deno: "1.0",
    edge: "13",
    electron: "0.31",
    firefox: "38",
    "firefox-android": "38",
    hermes: "0.1",
    ios: "10.0",
    node: "4.0",
    oculus: "3.0",
    opera: "32",
    "opera-android": "32",
    opera_mobile: "32",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.typed-array.some": {
    android: "45",
    bun: "0.1.1",
    chrome: "45",
    "chrome-android": "45",
    deno: "1.0",
    edge: "13",
    electron: "0.31",
    firefox: "37",
    "firefox-android": "37",
    hermes: "0.1",
    ios: "10.0",
    node: "4.0",
    oculus: "3.0",
    opera: "32",
    "opera-android": "32",
    opera_mobile: "32",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.typed-array.sort": {
    android: "74",
    bun: "0.1.1",
    chrome: "74",
    "chrome-android": "74",
    deno: "1.0",
    edge: "79",
    electron: "6.0",
    firefox: "67",
    "firefox-android": "67",
    hermes: "0.10",
    ios: "14.5",
    node: "12.0",
    oculus: "6.0",
    opera: "61",
    "opera-android": "53",
    opera_mobile: "53",
    quest: "6.0",
    "react-native": "0.69",
    safari: "14.1",
    samsung: "11.0"
  },
  "es.typed-array.subarray": {
    android: "4.4",
    bun: "0.1.1",
    chrome: "26",
    "chrome-android": "26",
    deno: "1.0",
    edge: "13",
    electron: "0.20",
    firefox: "15",
    "firefox-android": "15",
    hermes: "0.1",
    ios: "8.0",
    node: "0.11.0",
    oculus: "3.0",
    opera: "15",
    "opera-android": "15",
    opera_mobile: "15",
    quest: "3.0",
    "react-native": "0.69",
    safari: "7.1",
    samsung: "1.5"
  },
  "es.typed-array.to-locale-string": {
    android: "45",
    bun: "0.1.1",
    chrome: "45",
    "chrome-android": "45",
    deno: "1.0",
    edge: "79",
    electron: "0.31",
    firefox: "51",
    "firefox-android": "51",
    hermes: "0.1",
    ios: "10.0",
    node: "4.0",
    oculus: "3.0",
    opera: "32",
    "opera-android": "32",
    opera_mobile: "32",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.typed-array.to-reversed": {
    android: "110",
    bun: "0.1.1",
    chrome: "110",
    "chrome-android": "110",
    deno: "1.27",
    edge: "110",
    electron: "23.0",
    firefox: "115",
    "firefox-android": "115",
    ios: "16.0",
    node: "20.0",
    oculus: "26.0",
    opera: "96",
    "opera-android": "74",
    opera_mobile: "74",
    quest: "26.0",
    safari: "16.0",
    samsung: "21.0"
  },
  "es.typed-array.to-sorted": {
    android: "110",
    bun: "0.1.1",
    chrome: "110",
    "chrome-android": "110",
    deno: "1.27",
    edge: "110",
    electron: "23.0",
    firefox: "115",
    "firefox-android": "115",
    ios: "16.0",
    node: "20.0",
    oculus: "26.0",
    opera: "96",
    "opera-android": "74",
    opera_mobile: "74",
    quest: "26.0",
    safari: "16.0",
    samsung: "21.0"
  },
  "es.typed-array.to-string": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "13",
    electron: "1.2",
    firefox: "51",
    "firefox-android": "51",
    hermes: "0.1",
    ios: "10.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    "react-native": "0.69",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.typed-array.with": {
    android: "110",
    bun: "0.1.9",
    chrome: "110",
    "chrome-android": "110",
    deno: "1.27",
    edge: "110",
    electron: "23.0",
    firefox: "115",
    "firefox-android": "115",
    ios: "16.4",
    node: "20.0",
    oculus: "26.0",
    opera: "96",
    "opera-android": "74",
    opera_mobile: "74",
    quest: "26.0",
    safari: "16.4",
    samsung: "21.0"
  },
  "es.unescape": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "1",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "1",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "3",
    ios: "1.0",
    node: "0.0.3",
    oculus: "3.0",
    opera: "3",
    "opera-android": "3",
    opera_mobile: "3",
    phantom: "1.9",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "1",
    samsung: "1.0"
  },
  "es.weak-map": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "79",
    electron: "1.2",
    firefox: "53",
    "firefox-android": "53",
    ios: "10.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    rhino: "1.7.13",
    safari: "10.0",
    samsung: "5.0"
  },
  "es.weak-set": {
    android: "51",
    bun: "0.1.1",
    chrome: "51",
    "chrome-android": "51",
    deno: "1.0",
    edge: "15",
    electron: "1.2",
    firefox: "53",
    "firefox-android": "53",
    ios: "10.0",
    node: "6.5",
    oculus: "3.0",
    opera: "38",
    "opera-android": "38",
    opera_mobile: "38",
    quest: "3.0",
    rhino: "1.7.13",
    safari: "10.0",
    samsung: "5.0"
  },
  "esnext.aggregate-error": {
    android: "85",
    bun: "0.1.1",
    chrome: "85",
    "chrome-android": "85",
    deno: "1.2",
    edge: "85",
    electron: "10.0",
    firefox: "79",
    "firefox-android": "79",
    ios: "14.0",
    node: "15.0",
    oculus: "12.0",
    opera: "71",
    "opera-android": "60",
    opera_mobile: "60",
    quest: "12.0",
    safari: "14.0",
    samsung: "14.0"
  },
  "esnext.suppressed-error.constructor": {},
  "esnext.array.from-async": { bun: "0.3.0", firefox: "115", "firefox-android": "115", ios: "16.4", safari: "16.4" },
  "esnext.array.at": {
    android: "92",
    bun: "0.1.1",
    chrome: "92",
    "chrome-android": "92",
    deno: "1.12",
    edge: "92",
    electron: "14.0",
    firefox: "90",
    "firefox-android": "90",
    ios: "15.4",
    node: "16.6",
    oculus: "17.0",
    opera: "78",
    "opera-android": "65",
    opera_mobile: "65",
    quest: "17.0",
    "react-native": "0.71",
    safari: "15.4",
    samsung: "16.0"
  },
  "esnext.array.filter-out": {},
  "esnext.array.filter-reject": {},
  "esnext.array.find-last": {
    android: "97",
    bun: "0.1.1",
    chrome: "97",
    "chrome-android": "97",
    deno: "1.16",
    edge: "97",
    electron: "17.0",
    firefox: "104",
    "firefox-android": "104",
    hermes: "0.11",
    ios: "15.4",
    node: "18.0",
    oculus: "20.0",
    opera: "83",
    "opera-android": "68",
    opera_mobile: "68",
    quest: "20.0",
    "react-native": "0.69",
    safari: "15.4",
    samsung: "18.0"
  },
  "esnext.array.find-last-index": {
    android: "97",
    bun: "0.1.1",
    chrome: "97",
    "chrome-android": "97",
    deno: "1.16",
    edge: "97",
    electron: "17.0",
    firefox: "104",
    "firefox-android": "104",
    hermes: "0.11",
    ios: "15.4",
    node: "18.0",
    oculus: "20.0",
    opera: "83",
    "opera-android": "68",
    opera_mobile: "68",
    quest: "20.0",
    "react-native": "0.69",
    safari: "15.4",
    samsung: "18.0"
  },
  "esnext.array.group": {},
  "esnext.array.group-by": {},
  "esnext.array.group-by-to-map": {},
  "esnext.array.group-to-map": {},
  "esnext.array.is-template-object": {},
  "esnext.array.last-index": {},
  "esnext.array.last-item": {},
  "esnext.array.to-reversed": {
    android: "110",
    bun: "0.1.1",
    chrome: "110",
    "chrome-android": "110",
    deno: "1.27",
    edge: "110",
    electron: "23.0",
    firefox: "115",
    "firefox-android": "115",
    ios: "16.0",
    node: "20.0",
    oculus: "26.0",
    opera: "96",
    "opera-android": "74",
    opera_mobile: "74",
    quest: "26.0",
    safari: "16.0",
    samsung: "21.0"
  },
  "esnext.array.to-sorted": {
    android: "110",
    bun: "0.1.1",
    chrome: "110",
    "chrome-android": "110",
    deno: "1.27",
    edge: "110",
    electron: "23.0",
    firefox: "115",
    "firefox-android": "115",
    ios: "16.0",
    node: "20.0",
    oculus: "26.0",
    opera: "96",
    "opera-android": "74",
    opera_mobile: "74",
    quest: "26.0",
    safari: "16.0",
    samsung: "21.0"
  },
  "esnext.array.to-spliced": {
    android: "110",
    bun: "0.1.1",
    chrome: "110",
    "chrome-android": "110",
    deno: "1.27",
    edge: "110",
    electron: "23.0",
    firefox: "115",
    "firefox-android": "115",
    ios: "16.0",
    node: "20.0",
    oculus: "26.0",
    opera: "96",
    "opera-android": "74",
    opera_mobile: "74",
    quest: "26.0",
    safari: "16.0",
    samsung: "21.0"
  },
  "esnext.array.unique-by": {},
  "esnext.array.with": {
    android: "110",
    bun: "0.1.1",
    chrome: "110",
    "chrome-android": "110",
    deno: "1.27",
    edge: "110",
    electron: "23.0",
    firefox: "115",
    "firefox-android": "115",
    ios: "16.0",
    node: "20.0",
    oculus: "26.0",
    opera: "96",
    "opera-android": "74",
    opera_mobile: "74",
    quest: "26.0",
    safari: "16.0",
    samsung: "21.0"
  },
  "esnext.array-buffer.detached": {
    android: "114",
    chrome: "114",
    "chrome-android": "114",
    deno: "1.33",
    edge: "114",
    electron: "25.0",
    opera: "100"
  },
  "esnext.array-buffer.transfer": {
    android: "114",
    chrome: "114",
    "chrome-android": "114",
    deno: "1.33",
    edge: "114",
    electron: "25.0",
    opera: "100"
  },
  "esnext.array-buffer.transfer-to-fixed-length": {
    android: "114",
    chrome: "114",
    "chrome-android": "114",
    deno: "1.33",
    edge: "114",
    electron: "25.0",
    opera: "100"
  },
  "esnext.async-disposable-stack.constructor": {},
  "esnext.async-iterator.constructor": {},
  "esnext.async-iterator.as-indexed-pairs": {},
  "esnext.async-iterator.async-dispose": {},
  "esnext.async-iterator.drop": {},
  "esnext.async-iterator.every": {},
  "esnext.async-iterator.filter": {},
  "esnext.async-iterator.find": {},
  "esnext.async-iterator.flat-map": {},
  "esnext.async-iterator.for-each": {},
  "esnext.async-iterator.from": {},
  "esnext.async-iterator.indexed": {},
  "esnext.async-iterator.map": {},
  "esnext.async-iterator.reduce": {},
  "esnext.async-iterator.some": {},
  "esnext.async-iterator.take": {},
  "esnext.async-iterator.to-array": {},
  "esnext.bigint.range": {},
  "esnext.composite-key": {},
  "esnext.composite-symbol": {},
  "esnext.disposable-stack.constructor": {},
  "esnext.function.demethodize": {},
  "esnext.function.is-callable": {},
  "esnext.function.is-constructor": {},
  "esnext.function.metadata": {},
  "esnext.function.un-this": {},
  "esnext.global-this": {
    android: "71",
    bun: "0.1.1",
    chrome: "71",
    "chrome-android": "71",
    deno: "1.0",
    edge: "79",
    electron: "5.0",
    firefox: "65",
    "firefox-android": "65",
    hermes: "0.2",
    ios: "12.2",
    node: "12.0",
    oculus: "6.0",
    opera: "58",
    "opera-android": "50",
    opera_mobile: "50",
    quest: "6.0",
    "react-native": "0.69",
    rhino: "1.7.14",
    safari: "12.1",
    samsung: "10.0"
  },
  "esnext.iterator.constructor": {},
  "esnext.iterator.as-indexed-pairs": {},
  "esnext.iterator.dispose": {},
  "esnext.iterator.drop": {},
  "esnext.iterator.every": {},
  "esnext.iterator.filter": {},
  "esnext.iterator.find": {},
  "esnext.iterator.flat-map": {},
  "esnext.iterator.for-each": {},
  "esnext.iterator.from": {},
  "esnext.iterator.indexed": {},
  "esnext.iterator.map": {},
  "esnext.iterator.range": {},
  "esnext.iterator.reduce": {},
  "esnext.iterator.some": {},
  "esnext.iterator.take": {},
  "esnext.iterator.to-array": {},
  "esnext.iterator.to-async": {},
  "esnext.json.is-raw-json": {
    android: "114",
    chrome: "114",
    "chrome-android": "114",
    deno: "1.33",
    edge: "114",
    electron: "25.0",
    opera: "100"
  },
  "esnext.json.parse": {
    android: "114",
    chrome: "114",
    "chrome-android": "114",
    deno: "1.33",
    edge: "114",
    electron: "25.0",
    opera: "100"
  },
  "esnext.json.raw-json": {
    android: "114",
    chrome: "114",
    "chrome-android": "114",
    deno: "1.33",
    edge: "114",
    electron: "25.0",
    opera: "100"
  },
  "esnext.map.delete-all": {},
  "esnext.map.emplace": {},
  "esnext.map.every": {},
  "esnext.map.filter": {},
  "esnext.map.find": {},
  "esnext.map.find-key": {},
  "esnext.map.from": {},
  "esnext.map.group-by": {},
  "esnext.map.includes": {},
  "esnext.map.key-by": {},
  "esnext.map.key-of": {},
  "esnext.map.map-keys": {},
  "esnext.map.map-values": {},
  "esnext.map.merge": {},
  "esnext.map.of": {},
  "esnext.map.reduce": {},
  "esnext.map.some": {},
  "esnext.map.update": {},
  "esnext.map.update-or-insert": {},
  "esnext.map.upsert": {},
  "esnext.math.clamp": {},
  "esnext.math.deg-per-rad": {},
  "esnext.math.degrees": {},
  "esnext.math.fscale": {},
  "esnext.math.iaddh": {},
  "esnext.math.imulh": {},
  "esnext.math.isubh": {},
  "esnext.math.rad-per-deg": {},
  "esnext.math.radians": {},
  "esnext.math.scale": {},
  "esnext.math.seeded-prng": {},
  "esnext.math.signbit": {},
  "esnext.math.umulh": {},
  "esnext.number.from-string": {},
  "esnext.number.range": {},
  "esnext.object.has-own": {
    android: "93",
    bun: "0.1.1",
    chrome: "93",
    "chrome-android": "93",
    deno: "1.13",
    edge: "93",
    electron: "14.0",
    firefox: "92",
    "firefox-android": "92",
    hermes: "0.10",
    ios: "15.4",
    node: "16.9",
    oculus: "17.0",
    opera: "79",
    "opera-android": "66",
    opera_mobile: "66",
    quest: "17.0",
    "react-native": "0.69",
    safari: "15.4",
    samsung: "17.0"
  },
  "esnext.object.iterate-entries": {},
  "esnext.object.iterate-keys": {},
  "esnext.object.iterate-values": {},
  "esnext.object.group-by": {},
  "esnext.observable": {},
  "esnext.promise.all-settled": {
    android: "76",
    bun: "0.1.1",
    chrome: "76",
    "chrome-android": "76",
    deno: "1.24",
    edge: "79",
    electron: "6.0",
    firefox: "71",
    "firefox-android": "71",
    ios: "13.0",
    node: "12.9",
    oculus: "7.0",
    opera: "63",
    "opera-android": "54",
    opera_mobile: "54",
    quest: "7.0",
    safari: "13",
    samsung: "12.0"
  },
  "esnext.promise.any": {
    android: "85",
    bun: "0.1.1",
    chrome: "85",
    "chrome-android": "85",
    deno: "1.24",
    edge: "85",
    electron: "10.0",
    firefox: "79",
    "firefox-android": "79",
    ios: "14.0",
    node: "15.0",
    oculus: "12.0",
    opera: "71",
    "opera-android": "60",
    opera_mobile: "60",
    quest: "12.0",
    safari: "14.0",
    samsung: "14.0"
  },
  "esnext.promise.try": {},
  "esnext.promise.with-resolvers": {},
  "esnext.reflect.define-metadata": {},
  "esnext.reflect.delete-metadata": {},
  "esnext.reflect.get-metadata": {},
  "esnext.reflect.get-metadata-keys": {},
  "esnext.reflect.get-own-metadata": {},
  "esnext.reflect.get-own-metadata-keys": {},
  "esnext.reflect.has-metadata": {},
  "esnext.reflect.has-own-metadata": {},
  "esnext.reflect.metadata": {},
  "esnext.set.add-all": {},
  "esnext.set.delete-all": {},
  "esnext.set.difference.v2": { bun: "0.6.0" },
  "esnext.set.difference": {},
  "esnext.set.every": {},
  "esnext.set.filter": {},
  "esnext.set.find": {},
  "esnext.set.from": {},
  "esnext.set.intersection.v2": { bun: "0.5.7" },
  "esnext.set.intersection": {},
  "esnext.set.is-disjoint-from.v2": { bun: "0.5.7" },
  "esnext.set.is-disjoint-from": {},
  "esnext.set.is-subset-of.v2": { bun: "0.5.7" },
  "esnext.set.is-subset-of": {},
  "esnext.set.is-superset-of.v2": { bun: "0.5.7" },
  "esnext.set.is-superset-of": {},
  "esnext.set.join": {},
  "esnext.set.map": {},
  "esnext.set.of": {},
  "esnext.set.reduce": {},
  "esnext.set.some": {},
  "esnext.set.symmetric-difference.v2": { bun: "0.5.7" },
  "esnext.set.symmetric-difference": {},
  "esnext.set.union.v2": { bun: "0.5.7" },
  "esnext.set.union": {},
  "esnext.string.at": {},
  "esnext.string.cooked": {},
  "esnext.string.code-points": {},
  "esnext.string.dedent": {},
  "esnext.string.is-well-formed": {
    android: "111",
    bun: "0.4.0",
    chrome: "111",
    "chrome-android": "111",
    deno: "1.32",
    edge: "111",
    electron: "24.0",
    ios: "16.4",
    node: "20.0",
    oculus: "27.0",
    opera: "97",
    "opera-android": "75",
    opera_mobile: "75",
    quest: "27.0",
    safari: "16.4",
    samsung: "22.0"
  },
  "esnext.string.match-all": {
    android: "80",
    bun: "0.1.1",
    chrome: "80",
    "chrome-android": "80",
    deno: "1.0",
    edge: "80",
    electron: "8.0",
    firefox: "73",
    "firefox-android": "73",
    hermes: "0.6",
    ios: "13.4",
    node: "14.0",
    oculus: "9.0",
    opera: "67",
    "opera-android": "57",
    opera_mobile: "57",
    quest: "9.0",
    "react-native": "0.69",
    safari: "13.1",
    samsung: "13.0"
  },
  "esnext.string.replace-all": {
    android: "85",
    bun: "0.1.1",
    chrome: "85",
    "chrome-android": "85",
    deno: "1.2",
    edge: "85",
    electron: "10.0",
    firefox: "77",
    "firefox-android": "77",
    hermes: "0.7",
    ios: "13.4",
    node: "15.0",
    oculus: "12.0",
    opera: "71",
    "opera-android": "60",
    opera_mobile: "60",
    quest: "12.0",
    "react-native": "0.69",
    safari: "13.1",
    samsung: "14.0"
  },
  "esnext.string.to-well-formed": {
    android: "111",
    bun: "0.5.7",
    chrome: "111",
    "chrome-android": "111",
    deno: "1.32",
    edge: "111",
    electron: "24.0",
    ios: "16.4",
    node: "20.0",
    oculus: "27.0",
    opera: "97",
    "opera-android": "75",
    opera_mobile: "75",
    quest: "27.0",
    safari: "16.4",
    samsung: "22.0"
  },
  "esnext.symbol.async-dispose": {},
  "esnext.symbol.dispose": {},
  "esnext.symbol.is-registered-symbol": {},
  "esnext.symbol.is-registered": {},
  "esnext.symbol.is-well-known-symbol": {},
  "esnext.symbol.is-well-known": {},
  "esnext.symbol.matcher": {},
  "esnext.symbol.metadata": {},
  "esnext.symbol.metadata-key": {},
  "esnext.symbol.observable": {},
  "esnext.symbol.pattern-match": {},
  "esnext.symbol.replace-all": {},
  "esnext.typed-array.from-async": {},
  "esnext.typed-array.at": {
    android: "92",
    bun: "0.1.1",
    chrome: "92",
    "chrome-android": "92",
    deno: "1.12",
    edge: "92",
    electron: "14.0",
    firefox: "90",
    "firefox-android": "90",
    ios: "15.4",
    node: "16.6",
    oculus: "17.0",
    opera: "78",
    "opera-android": "65",
    opera_mobile: "65",
    quest: "17.0",
    "react-native": "0.71",
    safari: "15.4",
    samsung: "16.0"
  },
  "esnext.typed-array.filter-out": {},
  "esnext.typed-array.filter-reject": {},
  "esnext.typed-array.find-last": {
    android: "97",
    bun: "0.1.1",
    chrome: "97",
    "chrome-android": "97",
    deno: "1.16",
    edge: "97",
    electron: "17.0",
    firefox: "104",
    "firefox-android": "104",
    hermes: "0.11",
    ios: "15.4",
    node: "18.0",
    oculus: "20.0",
    opera: "83",
    "opera-android": "68",
    opera_mobile: "68",
    quest: "20.0",
    "react-native": "0.69",
    safari: "15.4",
    samsung: "18.0"
  },
  "esnext.typed-array.find-last-index": {
    android: "97",
    bun: "0.1.1",
    chrome: "97",
    "chrome-android": "97",
    deno: "1.16",
    edge: "97",
    electron: "17.0",
    firefox: "104",
    "firefox-android": "104",
    hermes: "0.11",
    ios: "15.4",
    node: "18.0",
    oculus: "20.0",
    opera: "83",
    "opera-android": "68",
    opera_mobile: "68",
    quest: "20.0",
    "react-native": "0.69",
    safari: "15.4",
    samsung: "18.0"
  },
  "esnext.typed-array.group-by": {},
  "esnext.typed-array.to-reversed": {
    android: "110",
    bun: "0.1.1",
    chrome: "110",
    "chrome-android": "110",
    deno: "1.27",
    edge: "110",
    electron: "23.0",
    firefox: "115",
    "firefox-android": "115",
    ios: "16.0",
    node: "20.0",
    oculus: "26.0",
    opera: "96",
    "opera-android": "74",
    opera_mobile: "74",
    quest: "26.0",
    safari: "16.0",
    samsung: "21.0"
  },
  "esnext.typed-array.to-sorted": {
    android: "110",
    bun: "0.1.1",
    chrome: "110",
    "chrome-android": "110",
    deno: "1.27",
    edge: "110",
    electron: "23.0",
    firefox: "115",
    "firefox-android": "115",
    ios: "16.0",
    node: "20.0",
    oculus: "26.0",
    opera: "96",
    "opera-android": "74",
    opera_mobile: "74",
    quest: "26.0",
    safari: "16.0",
    samsung: "21.0"
  },
  "esnext.typed-array.to-spliced": {},
  "esnext.typed-array.unique-by": {},
  "esnext.typed-array.with": {
    android: "110",
    bun: "0.1.9",
    chrome: "110",
    "chrome-android": "110",
    deno: "1.27",
    edge: "110",
    electron: "23.0",
    firefox: "115",
    "firefox-android": "115",
    ios: "16.4",
    node: "20.0",
    oculus: "26.0",
    opera: "96",
    "opera-android": "74",
    opera_mobile: "74",
    quest: "26.0",
    safari: "16.4",
    samsung: "21.0"
  },
  "esnext.weak-map.delete-all": {},
  "esnext.weak-map.from": {},
  "esnext.weak-map.of": {},
  "esnext.weak-map.emplace": {},
  "esnext.weak-map.upsert": {},
  "esnext.weak-set.add-all": {},
  "esnext.weak-set.delete-all": {},
  "esnext.weak-set.from": {},
  "esnext.weak-set.of": {},
  "web.atob": {
    android: "37",
    bun: "0.1.1",
    chrome: "34",
    "chrome-android": "34",
    deno: "1.0",
    edge: "16",
    electron: "0.20",
    firefox: "27",
    "firefox-android": "27",
    ios: "10.3",
    node: "18.0",
    oculus: "3.0",
    opera: "10.5",
    "opera-android": "10.5",
    opera_mobile: "10.5",
    quest: "3.0",
    safari: "10.1",
    samsung: "2.0"
  },
  "web.btoa": {
    android: "3.0",
    bun: "0.1.1",
    chrome: "4",
    "chrome-android": "18",
    deno: "1.0",
    edge: "16",
    electron: "0.20",
    firefox: "27",
    "firefox-android": "27",
    ios: "1.0",
    node: "17.5",
    oculus: "3.0",
    opera: "10.5",
    "opera-android": "10.5",
    opera_mobile: "10.5",
    phantom: "1.9",
    quest: "3.0",
    safari: "3.0",
    samsung: "1.0"
  },
  "web.dom-collections.for-each": {
    android: "58",
    bun: "0.1.1",
    chrome: "58",
    "chrome-android": "58",
    deno: "1.0",
    edge: "16",
    electron: "1.7",
    firefox: "50",
    "firefox-android": "50",
    hermes: "0.1",
    ios: "10.0",
    node: "0.0.1",
    oculus: "4.0",
    opera: "45",
    "opera-android": "43",
    opera_mobile: "43",
    quest: "4.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "10.0",
    samsung: "7.0"
  },
  "web.dom-collections.iterator": {
    android: "66",
    bun: "0.1.1",
    chrome: "66",
    "chrome-android": "66",
    deno: "1.0",
    edge: "79",
    electron: "3.0",
    firefox: "60",
    "firefox-android": "60",
    hermes: "0.1",
    ios: "13.4",
    node: "0.0.1",
    oculus: "5.0",
    opera: "53",
    "opera-android": "47",
    opera_mobile: "47",
    quest: "5.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "13.1",
    samsung: "9.0"
  },
  "web.dom-exception.constructor": {
    android: "46",
    bun: "0.1.1",
    chrome: "46",
    "chrome-android": "46",
    deno: "1.7",
    edge: "79",
    electron: "0.36",
    firefox: "37",
    "firefox-android": "37",
    ios: "11.3",
    node: "17.0",
    oculus: "3.0",
    opera: "33",
    "opera-android": "33",
    opera_mobile: "33",
    quest: "3.0",
    safari: "11.1",
    samsung: "5.0"
  },
  "web.dom-exception.stack": { deno: "1.15", firefox: "37", "firefox-android": "37", node: "17.0" },
  "web.dom-exception.to-string-tag": {
    android: "49",
    bun: "0.1.1",
    chrome: "49",
    "chrome-android": "49",
    deno: "1.7",
    edge: "79",
    electron: "0.37",
    firefox: "51",
    "firefox-android": "51",
    ios: "11.3",
    node: "17.0",
    oculus: "3.0",
    opera: "36",
    "opera-android": "36",
    opera_mobile: "36",
    quest: "3.0",
    safari: "11.1",
    samsung: "5.0"
  },
  "web.immediate": { bun: "0.4.0", ie: "10", node: "0.9.1" },
  "web.queue-microtask": {
    android: "71",
    bun: "0.1.1",
    chrome: "71",
    "chrome-android": "71",
    deno: "1.0",
    edge: "79",
    electron: "5.0",
    firefox: "69",
    "firefox-android": "69",
    ios: "12.2",
    node: "12.0",
    oculus: "6.0",
    opera: "58",
    "opera-android": "50",
    opera_mobile: "50",
    quest: "6.0",
    safari: "12.1",
    samsung: "10.0"
  },
  "web.self": {
    android: "86",
    chrome: "86",
    "chrome-android": "86",
    deno: "1.29.3",
    edge: "86",
    electron: "11.0",
    firefox: "31",
    "firefox-android": "31",
    ios: "10.0",
    oculus: "12.0",
    opera: "72",
    "opera-android": "61",
    opera_mobile: "61",
    quest: "12.0",
    safari: "10",
    samsung: "14.0"
  },
  "web.structured-clone": {},
  "web.timers": {
    android: "1.5",
    bun: "0.4.0",
    chrome: "1",
    "chrome-android": "18",
    deno: "1.0",
    edge: "12",
    electron: "0.20",
    firefox: "1",
    "firefox-android": "4",
    hermes: "0.1",
    ie: "10",
    ios: "1.0",
    node: "0.0.1",
    oculus: "3.0",
    opera: "7",
    "opera-android": "7",
    opera_mobile: "7",
    phantom: "1.9",
    quest: "3.0",
    "react-native": "0.69",
    rhino: "1.7.13",
    safari: "1.0",
    samsung: "1.0"
  },
  "web.url": {
    android: "67",
    bun: "0.1.1",
    chrome: "67",
    "chrome-android": "67",
    deno: "1.0",
    edge: "79",
    electron: "4.0",
    firefox: "57",
    "firefox-android": "57",
    ios: "14.0",
    node: "10.0",
    oculus: "6.0",
    opera: "54",
    "opera-android": "48",
    opera_mobile: "48",
    quest: "6.0",
    safari: "14.0",
    samsung: "9.0"
  },
  "web.url.can-parse": { deno: "1.33.2", firefox: "115", "firefox-android": "115", node: "20.1.0" },
  "web.url.to-json": {
    android: "71",
    bun: "0.1.1",
    chrome: "71",
    "chrome-android": "71",
    deno: "1.0",
    edge: "79",
    electron: "5.0",
    firefox: "57",
    "firefox-android": "57",
    ios: "14.0",
    node: "10.0",
    oculus: "6.0",
    opera: "58",
    "opera-android": "50",
    opera_mobile: "50",
    quest: "6.0",
    safari: "14.0",
    samsung: "10.0"
  },
  "web.url-search-params": {
    android: "67",
    bun: "0.1.1",
    chrome: "67",
    "chrome-android": "67",
    deno: "1.0",
    edge: "79",
    electron: "4.0",
    firefox: "57",
    "firefox-android": "57",
    ios: "14.0",
    node: "10.0",
    oculus: "6.0",
    opera: "54",
    "opera-android": "48",
    opera_mobile: "48",
    quest: "6.0",
    safari: "14.0",
    samsung: "9.0"
  },
  "web.url-search-params.delete": { firefox: "115", "firefox-android": "115", node: "20.2.0" },
  "web.url-search-params.has": { firefox: "115", "firefox-android": "115", node: "20.2.0" },
  "web.url-search-params.size": {
    android: "113",
    chrome: "113",
    "chrome-android": "113",
    deno: "1.32",
    edge: "113",
    electron: "25.0",
    firefox: "112",
    "firefox-android": "112",
    node: "19.8.0",
    opera: "99",
    "opera-android": "76",
    opera_mobile: "76"
  }
};

var data = require$$0$3;

const has$1 = Object.hasOwn || Function.call.bind({}.hasOwnProperty);
function semver$1(input) {
  if (input instanceof semver$1) return input;
  if (!(this instanceof semver$1)) return new semver$1(input);
  const match = /(\d+)(?:\.(\d+))?(?:\.(\d+))?/.exec(input);
  if (!match) throw TypeError('Invalid version: ' + input);
  const [, $major, $minor, $patch] = match;
  this.major = +$major;
  this.minor = $minor ? +$minor : 0;
  this.patch = $patch ? +$patch : 0;
}
semver$1.prototype.toString = function () {
  return `${this.major}.${this.minor}.${this.patch}`;
};
function compare$1($a, operator, $b) {
  const a = semver$1($a),
    b = semver$1($b);
  for (const component of ['major', 'minor', 'patch']) {
    if (a[component] < b[component]) return operator === '<' || operator === '<=' || operator === '!=';
    if (a[component] > b[component]) return operator === '>' || operator === '>=' || operator === '!=';
  }
  return operator === '==' || operator === '<=' || operator === '>=';
}
function filterOutStabilizedProposals(modules) {
  const modulesSet = new Set(modules);
  for (const $module of modulesSet)
    $module.startsWith('esnext.') && modulesSet.has($module.replace(/^esnext\./, 'es.')) && modulesSet.delete($module);

  return [...modulesSet];
}
function intersection$1(list, order) {
  const set = list instanceof Set ? list : new Set(list);
  return order.filter(name => set.has(name));
}
function sortObjectByKey(object, fn) {
  return Object.keys(object).sort(fn).reduce((memo, key) => {
    memo[key] = object[key];
    return memo;
  }, {});
}
var helpers = {
  compare: compare$1,
  filterOutStabilizedProposals,
  has: has$1,
  intersection: intersection$1,
  semver: semver$1,
  sortObjectByKey
};

var require$$1 = {
  "3.0": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.data-view",
    "es.date.now",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string",
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name",
    "es.json.to-string-tag",
    "es.map",
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc",
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-fixed",
    "es.number.to-precision",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.parse-float",
    "es.parse-int",
    "es.promise",
    "es.promise.finally",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.regexp.constructor",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.to-string",
    "es.set",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-string",
    "es.weak-map",
    "es.weak-set",
    "esnext.aggregate-error",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.global-this",
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.code-points",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.symbol.dispose",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator",
    "web.immediate",
    "web.queue-microtask",
    "web.timers",
    "web.url",
    "web.url.to-json",
    "web.url-search-params"
  ],
  3.1: ["es.string.match-all", "es.symbol.match-all", "esnext.symbol.replace-all"],
  3.2: [
    "es.promise.all-settled",
    "esnext.array.is-template-object",
    "esnext.map.update-or-insert",
    "esnext.symbol.async-dispose"
  ],
  3.3: [
    "es.global-this",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.map.upsert",
    "esnext.weak-map.upsert"
  ],
  3.4: ["es.json.stringify"],
  3.5: ["esnext.object.iterate-entries", "esnext.object.iterate-keys", "esnext.object.iterate-values"],
  3.6: ["es.regexp.sticky", "es.regexp.test"],
  3.7: [
    "es.aggregate-error",
    "es.promise.any",
    "es.reflect.to-string-tag",
    "es.string.replace-all",
    "esnext.map.emplace",
    "esnext.weak-map.emplace"
  ],
  3.8: [
    "esnext.array.at",
    "esnext.array.filter-out",
    "esnext.array.unique-by",
    "esnext.bigint.range",
    "esnext.number.range",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out"
  ],
  3.9: [
    "esnext.array.find-last",
    "esnext.array.find-last-index",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.unique-by"
  ],
  3.11: ["esnext.object.has-own"],
  3.12: ["esnext.symbol.matcher", "esnext.symbol.metadata"],
  3.15: [
    "es.date.get-year",
    "es.date.set-year",
    "es.date.to-gmt-string",
    "es.escape",
    "es.regexp.dot-all",
    "es.string.substr",
    "es.unescape"
  ],
  3.16: [
    "esnext.array.filter-reject",
    "esnext.array.group-by",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.group-by"
  ],
  3.17: ["es.array.at", "es.object.has-own", "es.string.at-alternative", "es.typed-array.at"],
  3.18: ["esnext.array.from-async", "esnext.typed-array.from-async"],
  "3.20": [
    "es.error.cause",
    "es.error.to-string",
    "es.aggregate-error.cause",
    "es.number.to-exponential",
    "esnext.array.group-by-to-map",
    "esnext.array.to-reversed",
    "esnext.array.to-sorted",
    "esnext.array.to-spliced",
    "esnext.array.with",
    "esnext.function.is-callable",
    "esnext.function.is-constructor",
    "esnext.function.un-this",
    "esnext.iterator.to-async",
    "esnext.string.cooked",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.with",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag",
    "web.structured-clone"
  ],
  3.21: ["web.atob", "web.btoa"],
  3.23: [
    "es.array.find-last",
    "es.array.find-last-index",
    "es.array.push",
    "es.array.unshift",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "esnext.array.group",
    "esnext.array.group-to-map",
    "esnext.symbol.metadata-key"
  ],
  3.24: ["esnext.async-iterator.indexed", "esnext.iterator.indexed"],
  3.25: ["es.object.proto"],
  3.26: ["esnext.string.is-well-formed", "esnext.string.to-well-formed", "web.self"],
  3.27: [
    "esnext.suppressed-error.constructor",
    "esnext.async-disposable-stack.constructor",
    "esnext.async-iterator.async-dispose",
    "esnext.disposable-stack.constructor",
    "esnext.iterator.dispose",
    "esnext.set.difference.v2",
    "esnext.set.intersection.v2",
    "esnext.set.is-disjoint-from.v2",
    "esnext.set.is-subset-of.v2",
    "esnext.set.is-superset-of.v2",
    "esnext.set.symmetric-difference.v2",
    "esnext.set.union.v2",
    "esnext.string.dedent"
  ],
  3.28: [
    "es.array.to-reversed",
    "es.array.to-sorted",
    "es.array.to-spliced",
    "es.array.with",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.with",
    "esnext.array-buffer.detached",
    "esnext.array-buffer.transfer",
    "esnext.array-buffer.transfer-to-fixed-length",
    "esnext.function.demethodize",
    "esnext.iterator.range",
    "esnext.json.is-raw-json",
    "esnext.json.parse",
    "esnext.json.raw-json",
    "esnext.symbol.is-registered",
    "esnext.symbol.is-well-known"
  ],
  3.29: ["web.url-search-params.size"],
  "3.30": ["web.url.can-parse"],
  3.31: [
    "es.string.is-well-formed",
    "es.string.to-well-formed",
    "esnext.function.metadata",
    "esnext.object.group-by",
    "esnext.promise.with-resolvers",
    "esnext.symbol.is-registered-symbol",
    "esnext.symbol.is-well-known-symbol",
    "web.url-search-params.delete",
    "web.url-search-params.has"
  ]
};

var require$$2 = [
  "es.symbol",
  "es.symbol.description",
  "es.symbol.async-iterator",
  "es.symbol.has-instance",
  "es.symbol.is-concat-spreadable",
  "es.symbol.iterator",
  "es.symbol.match",
  "es.symbol.match-all",
  "es.symbol.replace",
  "es.symbol.search",
  "es.symbol.species",
  "es.symbol.split",
  "es.symbol.to-primitive",
  "es.symbol.to-string-tag",
  "es.symbol.unscopables",
  "es.error.cause",
  "es.error.to-string",
  "es.aggregate-error",
  "es.aggregate-error.cause",
  "es.array.at",
  "es.array.concat",
  "es.array.copy-within",
  "es.array.every",
  "es.array.fill",
  "es.array.filter",
  "es.array.find",
  "es.array.find-index",
  "es.array.find-last",
  "es.array.find-last-index",
  "es.array.flat",
  "es.array.flat-map",
  "es.array.for-each",
  "es.array.from",
  "es.array.includes",
  "es.array.index-of",
  "es.array.is-array",
  "es.array.iterator",
  "es.array.join",
  "es.array.last-index-of",
  "es.array.map",
  "es.array.of",
  "es.array.push",
  "es.array.reduce",
  "es.array.reduce-right",
  "es.array.reverse",
  "es.array.slice",
  "es.array.some",
  "es.array.sort",
  "es.array.species",
  "es.array.splice",
  "es.array.to-reversed",
  "es.array.to-sorted",
  "es.array.to-spliced",
  "es.array.unscopables.flat",
  "es.array.unscopables.flat-map",
  "es.array.unshift",
  "es.array.with",
  "es.array-buffer.constructor",
  "es.array-buffer.is-view",
  "es.array-buffer.slice",
  "es.data-view",
  "es.date.get-year",
  "es.date.now",
  "es.date.set-year",
  "es.date.to-gmt-string",
  "es.date.to-iso-string",
  "es.date.to-json",
  "es.date.to-primitive",
  "es.date.to-string",
  "es.escape",
  "es.function.bind",
  "es.function.has-instance",
  "es.function.name",
  "es.global-this",
  "es.json.stringify",
  "es.json.to-string-tag",
  "es.map",
  "es.math.acosh",
  "es.math.asinh",
  "es.math.atanh",
  "es.math.cbrt",
  "es.math.clz32",
  "es.math.cosh",
  "es.math.expm1",
  "es.math.fround",
  "es.math.hypot",
  "es.math.imul",
  "es.math.log10",
  "es.math.log1p",
  "es.math.log2",
  "es.math.sign",
  "es.math.sinh",
  "es.math.tanh",
  "es.math.to-string-tag",
  "es.math.trunc",
  "es.number.constructor",
  "es.number.epsilon",
  "es.number.is-finite",
  "es.number.is-integer",
  "es.number.is-nan",
  "es.number.is-safe-integer",
  "es.number.max-safe-integer",
  "es.number.min-safe-integer",
  "es.number.parse-float",
  "es.number.parse-int",
  "es.number.to-exponential",
  "es.number.to-fixed",
  "es.number.to-precision",
  "es.object.assign",
  "es.object.create",
  "es.object.define-getter",
  "es.object.define-properties",
  "es.object.define-property",
  "es.object.define-setter",
  "es.object.entries",
  "es.object.freeze",
  "es.object.from-entries",
  "es.object.get-own-property-descriptor",
  "es.object.get-own-property-descriptors",
  "es.object.get-own-property-names",
  "es.object.get-prototype-of",
  "es.object.has-own",
  "es.object.is",
  "es.object.is-extensible",
  "es.object.is-frozen",
  "es.object.is-sealed",
  "es.object.keys",
  "es.object.lookup-getter",
  "es.object.lookup-setter",
  "es.object.prevent-extensions",
  "es.object.proto",
  "es.object.seal",
  "es.object.set-prototype-of",
  "es.object.to-string",
  "es.object.values",
  "es.parse-float",
  "es.parse-int",
  "es.promise",
  "es.promise.all-settled",
  "es.promise.any",
  "es.promise.finally",
  "es.reflect.apply",
  "es.reflect.construct",
  "es.reflect.define-property",
  "es.reflect.delete-property",
  "es.reflect.get",
  "es.reflect.get-own-property-descriptor",
  "es.reflect.get-prototype-of",
  "es.reflect.has",
  "es.reflect.is-extensible",
  "es.reflect.own-keys",
  "es.reflect.prevent-extensions",
  "es.reflect.set",
  "es.reflect.set-prototype-of",
  "es.reflect.to-string-tag",
  "es.regexp.constructor",
  "es.regexp.dot-all",
  "es.regexp.exec",
  "es.regexp.flags",
  "es.regexp.sticky",
  "es.regexp.test",
  "es.regexp.to-string",
  "es.set",
  "es.string.at-alternative",
  "es.string.code-point-at",
  "es.string.ends-with",
  "es.string.from-code-point",
  "es.string.includes",
  "es.string.is-well-formed",
  "es.string.iterator",
  "es.string.match",
  "es.string.match-all",
  "es.string.pad-end",
  "es.string.pad-start",
  "es.string.raw",
  "es.string.repeat",
  "es.string.replace",
  "es.string.replace-all",
  "es.string.search",
  "es.string.split",
  "es.string.starts-with",
  "es.string.substr",
  "es.string.to-well-formed",
  "es.string.trim",
  "es.string.trim-end",
  "es.string.trim-start",
  "es.string.anchor",
  "es.string.big",
  "es.string.blink",
  "es.string.bold",
  "es.string.fixed",
  "es.string.fontcolor",
  "es.string.fontsize",
  "es.string.italics",
  "es.string.link",
  "es.string.small",
  "es.string.strike",
  "es.string.sub",
  "es.string.sup",
  "es.typed-array.float32-array",
  "es.typed-array.float64-array",
  "es.typed-array.int8-array",
  "es.typed-array.int16-array",
  "es.typed-array.int32-array",
  "es.typed-array.uint8-array",
  "es.typed-array.uint8-clamped-array",
  "es.typed-array.uint16-array",
  "es.typed-array.uint32-array",
  "es.typed-array.at",
  "es.typed-array.copy-within",
  "es.typed-array.every",
  "es.typed-array.fill",
  "es.typed-array.filter",
  "es.typed-array.find",
  "es.typed-array.find-index",
  "es.typed-array.find-last",
  "es.typed-array.find-last-index",
  "es.typed-array.for-each",
  "es.typed-array.from",
  "es.typed-array.includes",
  "es.typed-array.index-of",
  "es.typed-array.iterator",
  "es.typed-array.join",
  "es.typed-array.last-index-of",
  "es.typed-array.map",
  "es.typed-array.of",
  "es.typed-array.reduce",
  "es.typed-array.reduce-right",
  "es.typed-array.reverse",
  "es.typed-array.set",
  "es.typed-array.slice",
  "es.typed-array.some",
  "es.typed-array.sort",
  "es.typed-array.subarray",
  "es.typed-array.to-locale-string",
  "es.typed-array.to-reversed",
  "es.typed-array.to-sorted",
  "es.typed-array.to-string",
  "es.typed-array.with",
  "es.unescape",
  "es.weak-map",
  "es.weak-set",
  "esnext.aggregate-error",
  "esnext.suppressed-error.constructor",
  "esnext.array.from-async",
  "esnext.array.at",
  "esnext.array.filter-out",
  "esnext.array.filter-reject",
  "esnext.array.find-last",
  "esnext.array.find-last-index",
  "esnext.array.group",
  "esnext.array.group-by",
  "esnext.array.group-by-to-map",
  "esnext.array.group-to-map",
  "esnext.array.is-template-object",
  "esnext.array.last-index",
  "esnext.array.last-item",
  "esnext.array.to-reversed",
  "esnext.array.to-sorted",
  "esnext.array.to-spliced",
  "esnext.array.unique-by",
  "esnext.array.with",
  "esnext.array-buffer.detached",
  "esnext.array-buffer.transfer",
  "esnext.array-buffer.transfer-to-fixed-length",
  "esnext.async-disposable-stack.constructor",
  "esnext.async-iterator.constructor",
  "esnext.async-iterator.as-indexed-pairs",
  "esnext.async-iterator.async-dispose",
  "esnext.async-iterator.drop",
  "esnext.async-iterator.every",
  "esnext.async-iterator.filter",
  "esnext.async-iterator.find",
  "esnext.async-iterator.flat-map",
  "esnext.async-iterator.for-each",
  "esnext.async-iterator.from",
  "esnext.async-iterator.indexed",
  "esnext.async-iterator.map",
  "esnext.async-iterator.reduce",
  "esnext.async-iterator.some",
  "esnext.async-iterator.take",
  "esnext.async-iterator.to-array",
  "esnext.bigint.range",
  "esnext.composite-key",
  "esnext.composite-symbol",
  "esnext.disposable-stack.constructor",
  "esnext.function.demethodize",
  "esnext.function.is-callable",
  "esnext.function.is-constructor",
  "esnext.function.metadata",
  "esnext.function.un-this",
  "esnext.global-this",
  "esnext.iterator.constructor",
  "esnext.iterator.as-indexed-pairs",
  "esnext.iterator.dispose",
  "esnext.iterator.drop",
  "esnext.iterator.every",
  "esnext.iterator.filter",
  "esnext.iterator.find",
  "esnext.iterator.flat-map",
  "esnext.iterator.for-each",
  "esnext.iterator.from",
  "esnext.iterator.indexed",
  "esnext.iterator.map",
  "esnext.iterator.range",
  "esnext.iterator.reduce",
  "esnext.iterator.some",
  "esnext.iterator.take",
  "esnext.iterator.to-array",
  "esnext.iterator.to-async",
  "esnext.json.is-raw-json",
  "esnext.json.parse",
  "esnext.json.raw-json",
  "esnext.map.delete-all",
  "esnext.map.emplace",
  "esnext.map.every",
  "esnext.map.filter",
  "esnext.map.find",
  "esnext.map.find-key",
  "esnext.map.from",
  "esnext.map.group-by",
  "esnext.map.includes",
  "esnext.map.key-by",
  "esnext.map.key-of",
  "esnext.map.map-keys",
  "esnext.map.map-values",
  "esnext.map.merge",
  "esnext.map.of",
  "esnext.map.reduce",
  "esnext.map.some",
  "esnext.map.update",
  "esnext.map.update-or-insert",
  "esnext.map.upsert",
  "esnext.math.clamp",
  "esnext.math.deg-per-rad",
  "esnext.math.degrees",
  "esnext.math.fscale",
  "esnext.math.iaddh",
  "esnext.math.imulh",
  "esnext.math.isubh",
  "esnext.math.rad-per-deg",
  "esnext.math.radians",
  "esnext.math.scale",
  "esnext.math.seeded-prng",
  "esnext.math.signbit",
  "esnext.math.umulh",
  "esnext.number.from-string",
  "esnext.number.range",
  "esnext.object.has-own",
  "esnext.object.iterate-entries",
  "esnext.object.iterate-keys",
  "esnext.object.iterate-values",
  "esnext.object.group-by",
  "esnext.observable",
  "esnext.promise.all-settled",
  "esnext.promise.any",
  "esnext.promise.try",
  "esnext.promise.with-resolvers",
  "esnext.reflect.define-metadata",
  "esnext.reflect.delete-metadata",
  "esnext.reflect.get-metadata",
  "esnext.reflect.get-metadata-keys",
  "esnext.reflect.get-own-metadata",
  "esnext.reflect.get-own-metadata-keys",
  "esnext.reflect.has-metadata",
  "esnext.reflect.has-own-metadata",
  "esnext.reflect.metadata",
  "esnext.set.add-all",
  "esnext.set.delete-all",
  "esnext.set.difference.v2",
  "esnext.set.difference",
  "esnext.set.every",
  "esnext.set.filter",
  "esnext.set.find",
  "esnext.set.from",
  "esnext.set.intersection.v2",
  "esnext.set.intersection",
  "esnext.set.is-disjoint-from.v2",
  "esnext.set.is-disjoint-from",
  "esnext.set.is-subset-of.v2",
  "esnext.set.is-subset-of",
  "esnext.set.is-superset-of.v2",
  "esnext.set.is-superset-of",
  "esnext.set.join",
  "esnext.set.map",
  "esnext.set.of",
  "esnext.set.reduce",
  "esnext.set.some",
  "esnext.set.symmetric-difference.v2",
  "esnext.set.symmetric-difference",
  "esnext.set.union.v2",
  "esnext.set.union",
  "esnext.string.at",
  "esnext.string.cooked",
  "esnext.string.code-points",
  "esnext.string.dedent",
  "esnext.string.is-well-formed",
  "esnext.string.match-all",
  "esnext.string.replace-all",
  "esnext.string.to-well-formed",
  "esnext.symbol.async-dispose",
  "esnext.symbol.dispose",
  "esnext.symbol.is-registered-symbol",
  "esnext.symbol.is-registered",
  "esnext.symbol.is-well-known-symbol",
  "esnext.symbol.is-well-known",
  "esnext.symbol.matcher",
  "esnext.symbol.metadata",
  "esnext.symbol.metadata-key",
  "esnext.symbol.observable",
  "esnext.symbol.pattern-match",
  "esnext.symbol.replace-all",
  "esnext.typed-array.from-async",
  "esnext.typed-array.at",
  "esnext.typed-array.filter-out",
  "esnext.typed-array.filter-reject",
  "esnext.typed-array.find-last",
  "esnext.typed-array.find-last-index",
  "esnext.typed-array.group-by",
  "esnext.typed-array.to-reversed",
  "esnext.typed-array.to-sorted",
  "esnext.typed-array.to-spliced",
  "esnext.typed-array.unique-by",
  "esnext.typed-array.with",
  "esnext.weak-map.delete-all",
  "esnext.weak-map.from",
  "esnext.weak-map.of",
  "esnext.weak-map.emplace",
  "esnext.weak-map.upsert",
  "esnext.weak-set.add-all",
  "esnext.weak-set.delete-all",
  "esnext.weak-set.from",
  "esnext.weak-set.of",
  "web.atob",
  "web.btoa",
  "web.dom-collections.for-each",
  "web.dom-collections.iterator",
  "web.dom-exception.constructor",
  "web.dom-exception.stack",
  "web.dom-exception.to-string-tag",
  "web.immediate",
  "web.queue-microtask",
  "web.self",
  "web.structured-clone",
  "web.timers",
  "web.url",
  "web.url.can-parse",
  "web.url.to-json",
  "web.url-search-params",
  "web.url-search-params.delete",
  "web.url-search-params.has",
  "web.url-search-params.size"
];

const { compare, intersection, semver } = helpers,
  modulesByVersions = require$$1,
  modules = require$$2;
var getModulesListForTargetVersion$1 = function (raw) {
  const corejs = semver(raw);
  if (corejs.major !== 3) throw RangeError('This version of `core-js-compat` works only with `core-js@3`.');

  const result = [];
  for (const version of Object.keys(modulesByVersions))
    compare(version, '<=', corejs) && result.push(...modulesByVersions[version]);

  return intersection(result, modules);
};

var getModulesListForTargetVersion = getModulesListForTargetVersion$1;

var require$$0$2 = {
  "core-js": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.error.cause",
    "es.error.to-string",
    "es.aggregate-error",
    "es.aggregate-error.cause",
    "es.array.at",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.find-last",
    "es.array.find-last-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.push",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.to-reversed",
    "es.array.to-sorted",
    "es.array.to-spliced",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array.unshift",
    "es.array.with",
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.data-view",
    "es.date.get-year",
    "es.date.now",
    "es.date.set-year",
    "es.date.to-gmt-string",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string",
    "es.escape",
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name",
    "es.global-this",
    "es.json.stringify",
    "es.json.to-string-tag",
    "es.map",
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc",
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-exponential",
    "es.number.to-fixed",
    "es.number.to-precision",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.has-own",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.proto",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.parse-float",
    "es.parse-int",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.any",
    "es.promise.finally",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.reflect.to-string-tag",
    "es.regexp.constructor",
    "es.regexp.dot-all",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.sticky",
    "es.regexp.test",
    "es.regexp.to-string",
    "es.set",
    "es.string.at-alternative",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.is-well-formed",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.replace-all",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.substr",
    "es.string.to-well-formed",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "es.unescape",
    "es.weak-map",
    "es.weak-set",
    "esnext.aggregate-error",
    "esnext.suppressed-error.constructor",
    "esnext.array.from-async",
    "esnext.array.at",
    "esnext.array.filter-out",
    "esnext.array.filter-reject",
    "esnext.array.find-last",
    "esnext.array.find-last-index",
    "esnext.array.group",
    "esnext.array.group-by",
    "esnext.array.group-by-to-map",
    "esnext.array.group-to-map",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.array.to-reversed",
    "esnext.array.to-sorted",
    "esnext.array.to-spliced",
    "esnext.array.unique-by",
    "esnext.array.with",
    "esnext.array-buffer.detached",
    "esnext.array-buffer.transfer",
    "esnext.array-buffer.transfer-to-fixed-length",
    "esnext.async-disposable-stack.constructor",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.async-dispose",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.indexed",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.bigint.range",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.disposable-stack.constructor",
    "esnext.function.demethodize",
    "esnext.function.is-callable",
    "esnext.function.is-constructor",
    "esnext.function.metadata",
    "esnext.function.un-this",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.dispose",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.indexed",
    "esnext.iterator.map",
    "esnext.iterator.range",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.iterator.to-async",
    "esnext.json.is-raw-json",
    "esnext.json.parse",
    "esnext.json.raw-json",
    "esnext.map.delete-all",
    "esnext.map.emplace",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.number.range",
    "esnext.object.has-own",
    "esnext.object.iterate-entries",
    "esnext.object.iterate-keys",
    "esnext.object.iterate-values",
    "esnext.object.group-by",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.promise.with-resolvers",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference.v2",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection.v2",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from.v2",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of.v2",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of.v2",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference.v2",
    "esnext.set.symmetric-difference",
    "esnext.set.union.v2",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.cooked",
    "esnext.string.code-points",
    "esnext.string.dedent",
    "esnext.string.is-well-formed",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.string.to-well-formed",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.is-registered-symbol",
    "esnext.symbol.is-registered",
    "esnext.symbol.is-well-known-symbol",
    "esnext.symbol.is-well-known",
    "esnext.symbol.matcher",
    "esnext.symbol.metadata",
    "esnext.symbol.metadata-key",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.emplace",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.atob",
    "web.btoa",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag",
    "web.immediate",
    "web.queue-microtask",
    "web.self",
    "web.structured-clone",
    "web.timers",
    "web.url",
    "web.url.can-parse",
    "web.url.to-json",
    "web.url-search-params",
    "web.url-search-params.delete",
    "web.url-search-params.has",
    "web.url-search-params.size"
  ],
  "core-js/actual": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.error.cause",
    "es.error.to-string",
    "es.aggregate-error",
    "es.aggregate-error.cause",
    "es.array.at",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.find-last",
    "es.array.find-last-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.push",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.to-reversed",
    "es.array.to-sorted",
    "es.array.to-spliced",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array.unshift",
    "es.array.with",
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.data-view",
    "es.date.get-year",
    "es.date.now",
    "es.date.set-year",
    "es.date.to-gmt-string",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string",
    "es.escape",
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name",
    "es.global-this",
    "es.json.stringify",
    "es.json.to-string-tag",
    "es.map",
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc",
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-exponential",
    "es.number.to-fixed",
    "es.number.to-precision",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.has-own",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.proto",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.parse-float",
    "es.parse-int",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.any",
    "es.promise.finally",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.reflect.to-string-tag",
    "es.regexp.constructor",
    "es.regexp.dot-all",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.sticky",
    "es.regexp.test",
    "es.regexp.to-string",
    "es.set",
    "es.string.at-alternative",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.is-well-formed",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.replace-all",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.substr",
    "es.string.to-well-formed",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "es.unescape",
    "es.weak-map",
    "es.weak-set",
    "esnext.aggregate-error",
    "esnext.suppressed-error.constructor",
    "esnext.array.from-async",
    "esnext.array.at",
    "esnext.array.find-last",
    "esnext.array.find-last-index",
    "esnext.array.group",
    "esnext.array.group-by",
    "esnext.array.group-by-to-map",
    "esnext.array.group-to-map",
    "esnext.array.to-reversed",
    "esnext.array.to-sorted",
    "esnext.array.to-spliced",
    "esnext.array.with",
    "esnext.array-buffer.detached",
    "esnext.array-buffer.transfer",
    "esnext.array-buffer.transfer-to-fixed-length",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.disposable-stack.constructor",
    "esnext.function.metadata",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.dispose",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.iterator.to-async",
    "esnext.json.is-raw-json",
    "esnext.json.parse",
    "esnext.json.raw-json",
    "esnext.object.has-own",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.set.difference.v2",
    "esnext.set.intersection.v2",
    "esnext.set.is-disjoint-from.v2",
    "esnext.set.is-subset-of.v2",
    "esnext.set.is-superset-of.v2",
    "esnext.set.symmetric-difference.v2",
    "esnext.set.union.v2",
    "esnext.string.is-well-formed",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.string.to-well-formed",
    "esnext.symbol.dispose",
    "esnext.symbol.metadata",
    "esnext.typed-array.at",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.with",
    "web.atob",
    "web.btoa",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag",
    "web.immediate",
    "web.queue-microtask",
    "web.self",
    "web.structured-clone",
    "web.timers",
    "web.url",
    "web.url.can-parse",
    "web.url.to-json",
    "web.url-search-params",
    "web.url-search-params.delete",
    "web.url-search-params.has",
    "web.url-search-params.size"
  ],
  "core-js/actual/aggregate-error": [
    "es.error.cause",
    "es.aggregate-error",
    "es.aggregate-error.cause",
    "es.array.iterator",
    "es.string.iterator",
    "esnext.aggregate-error",
    "web.dom-collections.iterator"
  ],
  "core-js/actual/array": [
    "es.array.at",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.find-last",
    "es.array.find-last-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.push",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.to-reversed",
    "es.array.to-sorted",
    "es.array.to-spliced",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array.unshift",
    "es.array.with",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.array.from-async",
    "esnext.array.find-last",
    "esnext.array.find-last-index",
    "esnext.array.group",
    "esnext.array.group-by",
    "esnext.array.group-by-to-map",
    "esnext.array.group-to-map",
    "esnext.array.to-reversed",
    "esnext.array.to-sorted",
    "esnext.array.to-spliced",
    "esnext.array.with"
  ],
  "core-js/actual/array-buffer": [
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.object.to-string",
    "esnext.array-buffer.detached",
    "esnext.array-buffer.transfer",
    "esnext.array-buffer.transfer-to-fixed-length"
  ],
  "core-js/actual/array-buffer/constructor": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "esnext.array-buffer.detached",
    "esnext.array-buffer.transfer",
    "esnext.array-buffer.transfer-to-fixed-length"
  ],
  "core-js/actual/array-buffer/detached": [
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.object.to-string",
    "esnext.array-buffer.detached"
  ],
  "core-js/actual/array-buffer/is-view": ["es.array-buffer.is-view"],
  "core-js/actual/array-buffer/slice": ["es.array-buffer.slice"],
  "core-js/actual/array-buffer/transfer": [
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.object.to-string",
    "esnext.array-buffer.transfer"
  ],
  "core-js/actual/array-buffer/transfer-to-fixed-length": [
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.object.to-string",
    "esnext.array-buffer.transfer-to-fixed-length"
  ],
  "core-js/actual/array/at": ["es.array.at"],
  "core-js/actual/array/concat": ["es.array.concat"],
  "core-js/actual/array/copy-within": ["es.array.copy-within"],
  "core-js/actual/array/entries": ["es.array.iterator", "es.object.to-string"],
  "core-js/actual/array/every": ["es.array.every"],
  "core-js/actual/array/fill": ["es.array.fill"],
  "core-js/actual/array/filter": ["es.array.filter"],
  "core-js/actual/array/find": ["es.array.find"],
  "core-js/actual/array/find-index": ["es.array.find-index"],
  "core-js/actual/array/find-last": ["es.array.find-last", "esnext.array.find-last"],
  "core-js/actual/array/find-last-index": ["es.array.find-last-index", "esnext.array.find-last-index"],
  "core-js/actual/array/flat": ["es.array.flat", "es.array.unscopables.flat"],
  "core-js/actual/array/flat-map": ["es.array.flat-map", "es.array.unscopables.flat-map"],
  "core-js/actual/array/for-each": ["es.array.for-each"],
  "core-js/actual/array/from": ["es.array.from", "es.string.iterator"],
  "core-js/actual/array/from-async": [
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.array.from-async"
  ],
  "core-js/actual/array/group": ["esnext.array.group"],
  "core-js/actual/array/group-by": ["esnext.array.group-by"],
  "core-js/actual/array/group-by-to-map": ["es.map", "es.object.to-string", "esnext.array.group-by-to-map"],
  "core-js/actual/array/group-to-map": ["es.map", "es.object.to-string", "esnext.array.group-to-map"],
  "core-js/actual/array/includes": ["es.array.includes"],
  "core-js/actual/array/index-of": ["es.array.index-of"],
  "core-js/actual/array/is-array": ["es.array.is-array"],
  "core-js/actual/array/iterator": ["es.array.iterator", "es.object.to-string"],
  "core-js/actual/array/join": ["es.array.join"],
  "core-js/actual/array/keys": ["es.array.iterator", "es.object.to-string"],
  "core-js/actual/array/last-index-of": ["es.array.last-index-of"],
  "core-js/actual/array/map": ["es.array.map"],
  "core-js/actual/array/of": ["es.array.of"],
  "core-js/actual/array/push": ["es.array.push"],
  "core-js/actual/array/reduce": ["es.array.reduce"],
  "core-js/actual/array/reduce-right": ["es.array.reduce-right"],
  "core-js/actual/array/reverse": ["es.array.reverse"],
  "core-js/actual/array/slice": ["es.array.slice"],
  "core-js/actual/array/some": ["es.array.some"],
  "core-js/actual/array/sort": ["es.array.sort"],
  "core-js/actual/array/splice": ["es.array.splice"],
  "core-js/actual/array/to-reversed": ["es.array.to-reversed", "esnext.array.to-reversed"],
  "core-js/actual/array/to-sorted": ["es.array.sort", "es.array.to-sorted", "esnext.array.to-sorted"],
  "core-js/actual/array/to-spliced": ["es.array.to-spliced", "esnext.array.to-spliced"],
  "core-js/actual/array/unshift": ["es.array.unshift"],
  "core-js/actual/array/values": ["es.array.iterator", "es.object.to-string"],
  "core-js/actual/array/virtual": [
    "es.array.at",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.find-last",
    "es.array.find-last-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.includes",
    "es.array.index-of",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.push",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.to-reversed",
    "es.array.to-sorted",
    "es.array.to-spliced",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array.unshift",
    "es.array.with",
    "es.map",
    "es.object.to-string",
    "esnext.array.find-last",
    "esnext.array.find-last-index",
    "esnext.array.group",
    "esnext.array.group-by",
    "esnext.array.group-by-to-map",
    "esnext.array.group-to-map",
    "esnext.array.to-reversed",
    "esnext.array.to-sorted",
    "esnext.array.to-spliced",
    "esnext.array.with"
  ],
  "core-js/actual/array/virtual/at": ["es.array.at"],
  "core-js/actual/array/virtual/concat": ["es.array.concat"],
  "core-js/actual/array/virtual/copy-within": ["es.array.copy-within"],
  "core-js/actual/array/virtual/entries": ["es.array.iterator", "es.object.to-string"],
  "core-js/actual/array/virtual/every": ["es.array.every"],
  "core-js/actual/array/virtual/fill": ["es.array.fill"],
  "core-js/actual/array/virtual/filter": ["es.array.filter"],
  "core-js/actual/array/virtual/find": ["es.array.find"],
  "core-js/actual/array/virtual/find-index": ["es.array.find-index"],
  "core-js/actual/array/virtual/find-last": ["es.array.find-last", "esnext.array.find-last"],
  "core-js/actual/array/virtual/find-last-index": ["es.array.find-last-index", "esnext.array.find-last-index"],
  "core-js/actual/array/virtual/flat": ["es.array.flat", "es.array.unscopables.flat"],
  "core-js/actual/array/virtual/flat-map": ["es.array.flat-map", "es.array.unscopables.flat-map"],
  "core-js/actual/array/virtual/for-each": ["es.array.for-each"],
  "core-js/actual/array/virtual/group": ["esnext.array.group"],
  "core-js/actual/array/virtual/group-by": ["esnext.array.group-by"],
  "core-js/actual/array/virtual/group-by-to-map": ["es.map", "es.object.to-string", "esnext.array.group-by-to-map"],
  "core-js/actual/array/virtual/group-to-map": ["es.map", "es.object.to-string", "esnext.array.group-to-map"],
  "core-js/actual/array/virtual/includes": ["es.array.includes"],
  "core-js/actual/array/virtual/index-of": ["es.array.index-of"],
  "core-js/actual/array/virtual/iterator": ["es.array.iterator", "es.object.to-string"],
  "core-js/actual/array/virtual/join": ["es.array.join"],
  "core-js/actual/array/virtual/keys": ["es.array.iterator", "es.object.to-string"],
  "core-js/actual/array/virtual/last-index-of": ["es.array.last-index-of"],
  "core-js/actual/array/virtual/map": ["es.array.map"],
  "core-js/actual/array/virtual/push": ["es.array.push"],
  "core-js/actual/array/virtual/reduce": ["es.array.reduce"],
  "core-js/actual/array/virtual/reduce-right": ["es.array.reduce-right"],
  "core-js/actual/array/virtual/reverse": ["es.array.reverse"],
  "core-js/actual/array/virtual/slice": ["es.array.slice"],
  "core-js/actual/array/virtual/some": ["es.array.some"],
  "core-js/actual/array/virtual/sort": ["es.array.sort"],
  "core-js/actual/array/virtual/splice": ["es.array.splice"],
  "core-js/actual/array/virtual/to-reversed": ["es.array.to-reversed", "esnext.array.to-reversed"],
  "core-js/actual/array/virtual/to-sorted": ["es.array.sort", "es.array.to-sorted", "esnext.array.to-sorted"],
  "core-js/actual/array/virtual/to-spliced": ["es.array.to-spliced", "esnext.array.to-spliced"],
  "core-js/actual/array/virtual/unshift": ["es.array.unshift"],
  "core-js/actual/array/virtual/values": ["es.array.iterator", "es.object.to-string"],
  "core-js/actual/array/virtual/with": ["es.array.with", "esnext.array.with"],
  "core-js/actual/array/with": ["es.array.with", "esnext.array.with"],
  "core-js/actual/async-iterator": [
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "web.dom-collections.iterator"
  ],
  "core-js/actual/async-iterator/drop": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.drop"
  ],
  "core-js/actual/async-iterator/every": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.every"
  ],
  "core-js/actual/async-iterator/filter": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.filter"
  ],
  "core-js/actual/async-iterator/find": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.find"
  ],
  "core-js/actual/async-iterator/flat-map": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.flat-map"
  ],
  "core-js/actual/async-iterator/for-each": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.for-each"
  ],
  "core-js/actual/async-iterator/from": [
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "web.dom-collections.iterator"
  ],
  "core-js/actual/async-iterator/map": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.map"
  ],
  "core-js/actual/async-iterator/reduce": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.reduce"
  ],
  "core-js/actual/async-iterator/some": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.some"
  ],
  "core-js/actual/async-iterator/take": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.take"
  ],
  "core-js/actual/async-iterator/to-array": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.to-array"
  ],
  "core-js/actual/atob": [
    "es.error.to-string",
    "es.object.to-string",
    "web.atob",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag"
  ],
  "core-js/actual/btoa": [
    "es.error.to-string",
    "es.object.to-string",
    "web.btoa",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag"
  ],
  "core-js/actual/clear-immediate": ["web.immediate"],
  "core-js/actual/data-view": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.data-view",
    "es.object.to-string"
  ],
  "core-js/actual/date": [
    "es.date.get-year",
    "es.date.now",
    "es.date.set-year",
    "es.date.to-gmt-string",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string"
  ],
  "core-js/actual/date/get-year": ["es.date.get-year"],
  "core-js/actual/date/now": ["es.date.now"],
  "core-js/actual/date/set-year": ["es.date.set-year"],
  "core-js/actual/date/to-gmt-string": ["es.date.to-gmt-string"],
  "core-js/actual/date/to-iso-string": ["es.date.to-iso-string", "es.date.to-json"],
  "core-js/actual/date/to-json": ["es.date.to-json"],
  "core-js/actual/date/to-primitive": ["es.date.to-primitive"],
  "core-js/actual/date/to-string": ["es.date.to-string"],
  "core-js/actual/disposable-stack": [
    "es.error.cause",
    "es.error.to-string",
    "es.object.to-string",
    "esnext.suppressed-error.constructor",
    "esnext.disposable-stack.constructor",
    "esnext.iterator.dispose"
  ],
  "core-js/actual/disposable-stack/constructor": [
    "es.error.cause",
    "es.error.to-string",
    "es.object.to-string",
    "esnext.suppressed-error.constructor",
    "esnext.disposable-stack.constructor",
    "esnext.iterator.dispose"
  ],
  "core-js/actual/dom-collections": [
    "es.array.iterator",
    "es.object.to-string",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator"
  ],
  "core-js/actual/dom-collections/for-each": ["web.dom-collections.for-each"],
  "core-js/actual/dom-collections/iterator": ["es.object.to-string", "web.dom-collections.iterator"],
  "core-js/actual/dom-exception": [
    "es.error.to-string",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag"
  ],
  "core-js/actual/dom-exception/constructor": [
    "es.error.to-string",
    "web.dom-exception.constructor",
    "web.dom-exception.stack"
  ],
  "core-js/actual/dom-exception/to-string-tag": ["web.dom-exception.to-string-tag"],
  "core-js/actual/error": ["es.error.cause", "es.error.to-string"],
  "core-js/actual/error/constructor": ["es.error.cause"],
  "core-js/actual/error/to-string": ["es.error.to-string"],
  "core-js/actual/escape": ["es.escape"],
  "core-js/actual/function": [
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name",
    "esnext.function.metadata"
  ],
  "core-js/actual/function/bind": ["es.function.bind"],
  "core-js/actual/function/has-instance": ["es.function.has-instance"],
  "core-js/actual/function/metadata": ["esnext.function.metadata"],
  "core-js/actual/function/name": ["es.function.name"],
  "core-js/actual/function/virtual": ["es.function.bind"],
  "core-js/actual/function/virtual/bind": ["es.function.bind"],
  "core-js/actual/get-iterator": ["es.array.iterator", "es.string.iterator", "web.dom-collections.iterator"],
  "core-js/actual/get-iterator-method": ["es.array.iterator", "es.string.iterator", "web.dom-collections.iterator"],
  "core-js/actual/global-this": ["es.global-this"],
  "core-js/actual/instance/at": ["es.array.at", "es.string.at-alternative"],
  "core-js/actual/instance/bind": ["es.function.bind"],
  "core-js/actual/instance/code-point-at": ["es.string.code-point-at"],
  "core-js/actual/instance/concat": ["es.array.concat"],
  "core-js/actual/instance/copy-within": ["es.array.copy-within"],
  "core-js/actual/instance/ends-with": ["es.string.ends-with"],
  "core-js/actual/instance/entries": ["es.array.iterator", "es.object.to-string", "web.dom-collections.iterator"],
  "core-js/actual/instance/every": ["es.array.every"],
  "core-js/actual/instance/fill": ["es.array.fill"],
  "core-js/actual/instance/filter": ["es.array.filter"],
  "core-js/actual/instance/find": ["es.array.find"],
  "core-js/actual/instance/find-index": ["es.array.find-index"],
  "core-js/actual/instance/find-last": ["es.array.find-last", "esnext.array.find-last"],
  "core-js/actual/instance/find-last-index": ["es.array.find-last-index", "esnext.array.find-last-index"],
  "core-js/actual/instance/flags": ["es.regexp.flags"],
  "core-js/actual/instance/flat": ["es.array.flat", "es.array.unscopables.flat"],
  "core-js/actual/instance/flat-map": ["es.array.flat-map", "es.array.unscopables.flat-map"],
  "core-js/actual/instance/for-each": ["es.array.for-each", "web.dom-collections.iterator"],
  "core-js/actual/instance/group": ["esnext.array.group"],
  "core-js/actual/instance/group-by": ["esnext.array.group-by"],
  "core-js/actual/instance/group-by-to-map": ["es.map", "es.object.to-string", "esnext.array.group-by-to-map"],
  "core-js/actual/instance/group-to-map": ["es.map", "es.object.to-string", "esnext.array.group-to-map"],
  "core-js/actual/instance/includes": ["es.array.includes", "es.string.includes"],
  "core-js/actual/instance/index-of": ["es.array.index-of"],
  "core-js/actual/instance/is-well-formed": ["es.string.is-well-formed"],
  "core-js/actual/instance/keys": ["es.array.iterator", "es.object.to-string", "web.dom-collections.iterator"],
  "core-js/actual/instance/last-index-of": ["es.array.last-index-of"],
  "core-js/actual/instance/map": ["es.array.map"],
  "core-js/actual/instance/match-all": ["es.object.to-string", "es.regexp.exec", "es.string.match-all"],
  "core-js/actual/instance/pad-end": ["es.string.pad-end"],
  "core-js/actual/instance/pad-start": ["es.string.pad-start"],
  "core-js/actual/instance/push": ["es.array.push"],
  "core-js/actual/instance/reduce": ["es.array.reduce"],
  "core-js/actual/instance/reduce-right": ["es.array.reduce-right"],
  "core-js/actual/instance/repeat": ["es.string.repeat"],
  "core-js/actual/instance/replace-all": ["es.regexp.exec", "es.string.replace", "es.string.replace-all"],
  "core-js/actual/instance/reverse": ["es.array.reverse"],
  "core-js/actual/instance/slice": ["es.array.slice"],
  "core-js/actual/instance/some": ["es.array.some"],
  "core-js/actual/instance/sort": ["es.array.sort"],
  "core-js/actual/instance/splice": ["es.array.splice"],
  "core-js/actual/instance/starts-with": ["es.string.starts-with"],
  "core-js/actual/instance/to-reversed": ["es.array.to-reversed", "esnext.array.to-reversed"],
  "core-js/actual/instance/to-sorted": ["es.array.sort", "es.array.to-sorted", "esnext.array.to-sorted"],
  "core-js/actual/instance/to-spliced": ["es.array.to-spliced", "esnext.array.to-spliced"],
  "core-js/actual/instance/to-well-formed": ["es.string.to-well-formed"],
  "core-js/actual/instance/trim": ["es.string.trim"],
  "core-js/actual/instance/trim-end": ["es.string.trim-end"],
  "core-js/actual/instance/trim-left": ["es.string.trim-start"],
  "core-js/actual/instance/trim-right": ["es.string.trim-end"],
  "core-js/actual/instance/trim-start": ["es.string.trim-start"],
  "core-js/actual/instance/unshift": ["es.array.unshift"],
  "core-js/actual/instance/values": ["es.array.iterator", "es.object.to-string", "web.dom-collections.iterator"],
  "core-js/actual/instance/with": ["es.array.with", "esnext.array.with"],
  "core-js/actual/is-iterable": ["es.array.iterator", "es.string.iterator", "web.dom-collections.iterator"],
  "core-js/actual/iterator": [
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.dispose",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.iterator.to-async",
    "web.dom-collections.iterator"
  ],
  "core-js/actual/iterator/dispose": ["esnext.iterator.dispose"],
  "core-js/actual/iterator/drop": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.drop"],
  "core-js/actual/iterator/every": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.every"],
  "core-js/actual/iterator/filter": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.filter"],
  "core-js/actual/iterator/find": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.find"],
  "core-js/actual/iterator/flat-map": [
    "es.object.to-string",
    "esnext.iterator.constructor",
    "esnext.iterator.flat-map"
  ],
  "core-js/actual/iterator/for-each": [
    "es.object.to-string",
    "esnext.iterator.constructor",
    "esnext.iterator.for-each"
  ],
  "core-js/actual/iterator/from": [
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.dispose",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.iterator.to-async",
    "web.dom-collections.iterator"
  ],
  "core-js/actual/iterator/map": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.map"],
  "core-js/actual/iterator/reduce": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.reduce"],
  "core-js/actual/iterator/some": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.some"],
  "core-js/actual/iterator/take": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.take"],
  "core-js/actual/iterator/to-array": [
    "es.object.to-string",
    "esnext.iterator.constructor",
    "esnext.iterator.to-array"
  ],
  "core-js/actual/iterator/to-async": [
    "es.object.to-string",
    "es.promise",
    "esnext.iterator.constructor",
    "esnext.iterator.to-async"
  ],
  "core-js/actual/json": [
    "es.json.stringify",
    "es.json.to-string-tag",
    "es.object.create",
    "es.object.freeze",
    "es.object.keys",
    "esnext.json.is-raw-json",
    "esnext.json.parse",
    "esnext.json.raw-json"
  ],
  "core-js/actual/json/is-raw-json": ["esnext.json.is-raw-json"],
  "core-js/actual/json/parse": ["es.object.keys", "esnext.json.parse"],
  "core-js/actual/json/raw-json": ["es.object.create", "es.object.freeze", "esnext.json.raw-json"],
  "core-js/actual/json/stringify": ["es.json.stringify"],
  "core-js/actual/json/to-string-tag": ["es.json.to-string-tag"],
  "core-js/actual/map": [
    "es.array.iterator",
    "es.map",
    "es.object.to-string",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/actual/math": [
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc"
  ],
  "core-js/actual/math/acosh": ["es.math.acosh"],
  "core-js/actual/math/asinh": ["es.math.asinh"],
  "core-js/actual/math/atanh": ["es.math.atanh"],
  "core-js/actual/math/cbrt": ["es.math.cbrt"],
  "core-js/actual/math/clz32": ["es.math.clz32"],
  "core-js/actual/math/cosh": ["es.math.cosh"],
  "core-js/actual/math/expm1": ["es.math.expm1"],
  "core-js/actual/math/fround": ["es.math.fround"],
  "core-js/actual/math/hypot": ["es.math.hypot"],
  "core-js/actual/math/imul": ["es.math.imul"],
  "core-js/actual/math/log10": ["es.math.log10"],
  "core-js/actual/math/log1p": ["es.math.log1p"],
  "core-js/actual/math/log2": ["es.math.log2"],
  "core-js/actual/math/sign": ["es.math.sign"],
  "core-js/actual/math/sinh": ["es.math.sinh"],
  "core-js/actual/math/tanh": ["es.math.tanh"],
  "core-js/actual/math/to-string-tag": ["es.math.to-string-tag"],
  "core-js/actual/math/trunc": ["es.math.trunc"],
  "core-js/actual/number": [
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-exponential",
    "es.number.to-fixed",
    "es.number.to-precision"
  ],
  "core-js/actual/number/constructor": ["es.number.constructor"],
  "core-js/actual/number/epsilon": ["es.number.epsilon"],
  "core-js/actual/number/is-finite": ["es.number.is-finite"],
  "core-js/actual/number/is-integer": ["es.number.is-integer"],
  "core-js/actual/number/is-nan": ["es.number.is-nan"],
  "core-js/actual/number/is-safe-integer": ["es.number.is-safe-integer"],
  "core-js/actual/number/max-safe-integer": ["es.number.max-safe-integer"],
  "core-js/actual/number/min-safe-integer": ["es.number.min-safe-integer"],
  "core-js/actual/number/parse-float": ["es.number.parse-float"],
  "core-js/actual/number/parse-int": ["es.number.parse-int"],
  "core-js/actual/number/to-exponential": ["es.number.to-exponential"],
  "core-js/actual/number/to-fixed": ["es.number.to-fixed"],
  "core-js/actual/number/to-precision": ["es.number.to-precision"],
  "core-js/actual/number/virtual": ["es.number.to-exponential", "es.number.to-fixed", "es.number.to-precision"],
  "core-js/actual/number/virtual/to-exponential": ["es.number.to-exponential"],
  "core-js/actual/number/virtual/to-fixed": ["es.number.to-fixed"],
  "core-js/actual/number/virtual/to-precision": ["es.number.to-precision"],
  "core-js/actual/object": [
    "es.symbol",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.has-own",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.proto",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.reflect.to-string-tag",
    "web.dom-collections.iterator"
  ],
  "core-js/actual/object/assign": ["es.object.assign"],
  "core-js/actual/object/create": ["es.object.create"],
  "core-js/actual/object/define-getter": ["es.object.define-getter"],
  "core-js/actual/object/define-properties": ["es.object.define-properties"],
  "core-js/actual/object/define-property": ["es.object.define-property"],
  "core-js/actual/object/define-setter": ["es.object.define-setter"],
  "core-js/actual/object/entries": ["es.object.entries"],
  "core-js/actual/object/freeze": ["es.object.freeze"],
  "core-js/actual/object/from-entries": ["es.array.iterator", "es.object.from-entries", "web.dom-collections.iterator"],
  "core-js/actual/object/get-own-property-descriptor": ["es.object.get-own-property-descriptor"],
  "core-js/actual/object/get-own-property-descriptors": ["es.object.get-own-property-descriptors"],
  "core-js/actual/object/get-own-property-names": ["es.object.get-own-property-names"],
  "core-js/actual/object/get-own-property-symbols": ["es.symbol"],
  "core-js/actual/object/get-prototype-of": ["es.object.get-prototype-of"],
  "core-js/actual/object/has-own": ["es.object.has-own"],
  "core-js/actual/object/is": ["es.object.is"],
  "core-js/actual/object/is-extensible": ["es.object.is-extensible"],
  "core-js/actual/object/is-frozen": ["es.object.is-frozen"],
  "core-js/actual/object/is-sealed": ["es.object.is-sealed"],
  "core-js/actual/object/keys": ["es.object.keys"],
  "core-js/actual/object/lookup-getter": ["es.object.lookup-getter"],
  "core-js/actual/object/lookup-setter": ["es.object.lookup-setter"],
  "core-js/actual/object/prevent-extensions": ["es.object.prevent-extensions"],
  "core-js/actual/object/proto": ["es.object.proto"],
  "core-js/actual/object/seal": ["es.object.seal"],
  "core-js/actual/object/set-prototype-of": ["es.object.set-prototype-of"],
  "core-js/actual/object/to-string": [
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string",
    "es.reflect.to-string-tag"
  ],
  "core-js/actual/object/values": ["es.object.values"],
  "core-js/actual/parse-float": ["es.parse-float"],
  "core-js/actual/parse-int": ["es.parse-int"],
  "core-js/actual/promise": [
    "es.aggregate-error",
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.any",
    "es.promise.finally",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/actual/promise/all-settled": [
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.promise.all-settled",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/actual/promise/any": [
    "es.aggregate-error",
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.promise.any",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/actual/promise/finally": ["es.object.to-string", "es.promise", "es.promise.finally"],
  "core-js/actual/queue-microtask": ["web.queue-microtask"],
  "core-js/actual/reflect": [
    "es.object.to-string",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.reflect.to-string-tag"
  ],
  "core-js/actual/reflect/apply": ["es.reflect.apply"],
  "core-js/actual/reflect/construct": ["es.reflect.construct"],
  "core-js/actual/reflect/define-property": ["es.reflect.define-property"],
  "core-js/actual/reflect/delete-property": ["es.reflect.delete-property"],
  "core-js/actual/reflect/get": ["es.reflect.get"],
  "core-js/actual/reflect/get-own-property-descriptor": ["es.reflect.get-own-property-descriptor"],
  "core-js/actual/reflect/get-prototype-of": ["es.reflect.get-prototype-of"],
  "core-js/actual/reflect/has": ["es.reflect.has"],
  "core-js/actual/reflect/is-extensible": ["es.reflect.is-extensible"],
  "core-js/actual/reflect/own-keys": ["es.reflect.own-keys"],
  "core-js/actual/reflect/prevent-extensions": ["es.reflect.prevent-extensions"],
  "core-js/actual/reflect/set": ["es.reflect.set"],
  "core-js/actual/reflect/set-prototype-of": ["es.reflect.set-prototype-of"],
  "core-js/actual/reflect/to-string-tag": ["es.reflect.to-string-tag"],
  "core-js/actual/regexp": [
    "es.regexp.constructor",
    "es.regexp.dot-all",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.sticky",
    "es.regexp.test",
    "es.regexp.to-string",
    "es.string.match",
    "es.string.replace",
    "es.string.search",
    "es.string.split"
  ],
  "core-js/actual/regexp/constructor": [
    "es.regexp.constructor",
    "es.regexp.dot-all",
    "es.regexp.exec",
    "es.regexp.sticky"
  ],
  "core-js/actual/regexp/dot-all": ["es.regexp.constructor", "es.regexp.dot-all", "es.regexp.exec"],
  "core-js/actual/regexp/flags": ["es.regexp.flags"],
  "core-js/actual/regexp/match": ["es.regexp.exec", "es.string.match"],
  "core-js/actual/regexp/replace": ["es.regexp.exec", "es.string.replace"],
  "core-js/actual/regexp/search": ["es.regexp.exec", "es.string.search"],
  "core-js/actual/regexp/split": ["es.regexp.exec", "es.string.split"],
  "core-js/actual/regexp/sticky": ["es.regexp.constructor", "es.regexp.exec", "es.regexp.sticky"],
  "core-js/actual/regexp/test": ["es.regexp.exec", "es.regexp.test"],
  "core-js/actual/regexp/to-string": ["es.regexp.to-string"],
  "core-js/actual/self": ["web.self"],
  "core-js/actual/set": [
    "es.array.iterator",
    "es.object.to-string",
    "es.set",
    "es.string.iterator",
    "esnext.set.difference.v2",
    "esnext.set.intersection.v2",
    "esnext.set.is-disjoint-from.v2",
    "esnext.set.is-subset-of.v2",
    "esnext.set.is-superset-of.v2",
    "esnext.set.symmetric-difference.v2",
    "esnext.set.union.v2",
    "web.dom-collections.iterator"
  ],
  "core-js/actual/set-immediate": ["web.immediate"],
  "core-js/actual/set-interval": ["web.timers"],
  "core-js/actual/set-timeout": ["web.timers"],
  "core-js/actual/set/difference": ["es.set", "esnext.set.difference.v2"],
  "core-js/actual/set/intersection": ["es.set", "esnext.set.intersection.v2"],
  "core-js/actual/set/is-disjoint-from": ["es.set", "esnext.set.is-disjoint-from.v2"],
  "core-js/actual/set/is-subset-of": ["es.set", "esnext.set.is-subset-of.v2"],
  "core-js/actual/set/is-superset-of": ["es.set", "esnext.set.is-superset-of.v2"],
  "core-js/actual/set/symmetric-difference": ["es.set", "esnext.set.symmetric-difference.v2"],
  "core-js/actual/set/union": ["es.set", "esnext.set.union.v2"],
  "core-js/actual/string": [
    "es.object.to-string",
    "es.regexp.exec",
    "es.string.at-alternative",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.is-well-formed",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.replace-all",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.substr",
    "es.string.to-well-formed",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "esnext.string.is-well-formed",
    "esnext.string.to-well-formed"
  ],
  "core-js/actual/string/anchor": ["es.string.anchor"],
  "core-js/actual/string/at": ["es.string.at-alternative"],
  "core-js/actual/string/big": ["es.string.big"],
  "core-js/actual/string/blink": ["es.string.blink"],
  "core-js/actual/string/bold": ["es.string.bold"],
  "core-js/actual/string/code-point-at": ["es.string.code-point-at"],
  "core-js/actual/string/ends-with": ["es.string.ends-with"],
  "core-js/actual/string/fixed": ["es.string.fixed"],
  "core-js/actual/string/fontcolor": ["es.string.fontcolor"],
  "core-js/actual/string/fontsize": ["es.string.fontsize"],
  "core-js/actual/string/from-code-point": ["es.string.from-code-point"],
  "core-js/actual/string/includes": ["es.string.includes"],
  "core-js/actual/string/is-well-formed": ["es.string.is-well-formed", "esnext.string.is-well-formed"],
  "core-js/actual/string/italics": ["es.string.italics"],
  "core-js/actual/string/iterator": ["es.object.to-string", "es.string.iterator"],
  "core-js/actual/string/link": ["es.string.link"],
  "core-js/actual/string/match": ["es.regexp.exec", "es.string.match"],
  "core-js/actual/string/match-all": ["es.object.to-string", "es.regexp.exec", "es.string.match-all"],
  "core-js/actual/string/pad-end": ["es.string.pad-end"],
  "core-js/actual/string/pad-start": ["es.string.pad-start"],
  "core-js/actual/string/raw": ["es.string.raw"],
  "core-js/actual/string/repeat": ["es.string.repeat"],
  "core-js/actual/string/replace": ["es.regexp.exec", "es.string.replace"],
  "core-js/actual/string/replace-all": ["es.regexp.exec", "es.string.replace", "es.string.replace-all"],
  "core-js/actual/string/search": ["es.regexp.exec", "es.string.search"],
  "core-js/actual/string/small": ["es.string.small"],
  "core-js/actual/string/split": ["es.regexp.exec", "es.string.split"],
  "core-js/actual/string/starts-with": ["es.string.starts-with"],
  "core-js/actual/string/strike": ["es.string.strike"],
  "core-js/actual/string/sub": ["es.string.sub"],
  "core-js/actual/string/substr": ["es.string.substr"],
  "core-js/actual/string/sup": ["es.string.sup"],
  "core-js/actual/string/to-well-formed": ["es.string.to-well-formed", "esnext.string.to-well-formed"],
  "core-js/actual/string/trim": ["es.string.trim"],
  "core-js/actual/string/trim-end": ["es.string.trim-end"],
  "core-js/actual/string/trim-left": ["es.string.trim-start"],
  "core-js/actual/string/trim-right": ["es.string.trim-end"],
  "core-js/actual/string/trim-start": ["es.string.trim-start"],
  "core-js/actual/string/virtual": [
    "es.object.to-string",
    "es.regexp.exec",
    "es.string.at-alternative",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.repeat",
    "es.string.replace",
    "es.string.replace-all",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.substr",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "esnext.string.is-well-formed",
    "esnext.string.to-well-formed"
  ],
  "core-js/actual/string/virtual/anchor": ["es.string.anchor"],
  "core-js/actual/string/virtual/at": ["es.string.at-alternative"],
  "core-js/actual/string/virtual/big": ["es.string.big"],
  "core-js/actual/string/virtual/blink": ["es.string.blink"],
  "core-js/actual/string/virtual/bold": ["es.string.bold"],
  "core-js/actual/string/virtual/code-point-at": ["es.string.code-point-at"],
  "core-js/actual/string/virtual/ends-with": ["es.string.ends-with"],
  "core-js/actual/string/virtual/fixed": ["es.string.fixed"],
  "core-js/actual/string/virtual/fontcolor": ["es.string.fontcolor"],
  "core-js/actual/string/virtual/fontsize": ["es.string.fontsize"],
  "core-js/actual/string/virtual/includes": ["es.string.includes"],
  "core-js/actual/string/virtual/is-well-formed": ["es.string.is-well-formed", "esnext.string.is-well-formed"],
  "core-js/actual/string/virtual/italics": ["es.string.italics"],
  "core-js/actual/string/virtual/iterator": ["es.object.to-string", "es.string.iterator"],
  "core-js/actual/string/virtual/link": ["es.string.link"],
  "core-js/actual/string/virtual/match-all": ["es.object.to-string", "es.regexp.exec", "es.string.match-all"],
  "core-js/actual/string/virtual/pad-end": ["es.string.pad-end"],
  "core-js/actual/string/virtual/pad-start": ["es.string.pad-start"],
  "core-js/actual/string/virtual/repeat": ["es.string.repeat"],
  "core-js/actual/string/virtual/replace-all": ["es.regexp.exec", "es.string.replace", "es.string.replace-all"],
  "core-js/actual/string/virtual/small": ["es.string.small"],
  "core-js/actual/string/virtual/starts-with": ["es.string.starts-with"],
  "core-js/actual/string/virtual/strike": ["es.string.strike"],
  "core-js/actual/string/virtual/sub": ["es.string.sub"],
  "core-js/actual/string/virtual/substr": ["es.string.substr"],
  "core-js/actual/string/virtual/sup": ["es.string.sup"],
  "core-js/actual/string/virtual/to-well-formed": ["es.string.to-well-formed", "esnext.string.to-well-formed"],
  "core-js/actual/string/virtual/trim": ["es.string.trim"],
  "core-js/actual/string/virtual/trim-end": ["es.string.trim-end"],
  "core-js/actual/string/virtual/trim-left": ["es.string.trim-start"],
  "core-js/actual/string/virtual/trim-right": ["es.string.trim-end"],
  "core-js/actual/string/virtual/trim-start": ["es.string.trim-start"],
  "core-js/actual/structured-clone": [
    "es.error.to-string",
    "es.array.iterator",
    "es.map",
    "es.object.keys",
    "es.object.to-string",
    "es.set",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag",
    "web.structured-clone"
  ],
  "core-js/actual/suppressed-error": ["es.error.cause", "es.error.to-string", "esnext.suppressed-error.constructor"],
  "core-js/actual/symbol": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string",
    "es.reflect.to-string-tag",
    "esnext.function.metadata",
    "esnext.symbol.dispose",
    "esnext.symbol.metadata",
    "web.dom-collections.iterator"
  ],
  "core-js/actual/symbol/async-iterator": ["es.symbol.async-iterator"],
  "core-js/actual/symbol/description": ["es.symbol.description"],
  "core-js/actual/symbol/dispose": ["esnext.symbol.dispose"],
  "core-js/actual/symbol/for": ["es.symbol"],
  "core-js/actual/symbol/has-instance": ["es.symbol.has-instance", "es.function.has-instance"],
  "core-js/actual/symbol/is-concat-spreadable": ["es.symbol.is-concat-spreadable", "es.array.concat"],
  "core-js/actual/symbol/iterator": [
    "es.symbol.iterator",
    "es.array.iterator",
    "es.object.to-string",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/actual/symbol/key-for": ["es.symbol"],
  "core-js/actual/symbol/match": ["es.symbol.match", "es.regexp.exec", "es.string.match"],
  "core-js/actual/symbol/match-all": [
    "es.symbol.match-all",
    "es.object.to-string",
    "es.regexp.exec",
    "es.string.match-all"
  ],
  "core-js/actual/symbol/metadata": ["esnext.function.metadata", "esnext.symbol.metadata"],
  "core-js/actual/symbol/replace": ["es.symbol.replace", "es.regexp.exec", "es.string.replace"],
  "core-js/actual/symbol/search": ["es.symbol.search", "es.regexp.exec", "es.string.search"],
  "core-js/actual/symbol/species": ["es.symbol.species"],
  "core-js/actual/symbol/split": ["es.symbol.split", "es.regexp.exec", "es.string.split"],
  "core-js/actual/symbol/to-primitive": ["es.symbol.to-primitive", "es.date.to-primitive"],
  "core-js/actual/symbol/to-string-tag": [
    "es.symbol.to-string-tag",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string",
    "es.reflect.to-string-tag"
  ],
  "core-js/actual/symbol/unscopables": ["es.symbol.unscopables"],
  "core-js/actual/typed-array": [
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.with"
  ],
  "core-js/actual/typed-array/at": ["es.typed-array.at"],
  "core-js/actual/typed-array/copy-within": ["es.typed-array.copy-within"],
  "core-js/actual/typed-array/entries": ["es.object.to-string", "es.typed-array.iterator"],
  "core-js/actual/typed-array/every": ["es.typed-array.every"],
  "core-js/actual/typed-array/fill": ["es.typed-array.fill"],
  "core-js/actual/typed-array/filter": ["es.typed-array.filter"],
  "core-js/actual/typed-array/find": ["es.typed-array.find"],
  "core-js/actual/typed-array/find-index": ["es.typed-array.find-index"],
  "core-js/actual/typed-array/find-last": ["es.typed-array.find-last", "esnext.typed-array.find-last"],
  "core-js/actual/typed-array/find-last-index": [
    "es.typed-array.find-last-index",
    "esnext.typed-array.find-last-index"
  ],
  "core-js/actual/typed-array/float32-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.float32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.with"
  ],
  "core-js/actual/typed-array/float64-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.float64-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.with"
  ],
  "core-js/actual/typed-array/for-each": ["es.typed-array.for-each"],
  "core-js/actual/typed-array/from": ["es.typed-array.from"],
  "core-js/actual/typed-array/includes": ["es.typed-array.includes"],
  "core-js/actual/typed-array/index-of": ["es.typed-array.index-of"],
  "core-js/actual/typed-array/int16-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.int16-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.with"
  ],
  "core-js/actual/typed-array/int32-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.int32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.with"
  ],
  "core-js/actual/typed-array/int8-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.int8-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.with"
  ],
  "core-js/actual/typed-array/iterator": ["es.object.to-string", "es.typed-array.iterator"],
  "core-js/actual/typed-array/join": ["es.typed-array.join"],
  "core-js/actual/typed-array/keys": ["es.object.to-string", "es.typed-array.iterator"],
  "core-js/actual/typed-array/last-index-of": ["es.typed-array.last-index-of"],
  "core-js/actual/typed-array/map": ["es.typed-array.map"],
  "core-js/actual/typed-array/methods": [
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.with"
  ],
  "core-js/actual/typed-array/of": ["es.typed-array.of"],
  "core-js/actual/typed-array/reduce": ["es.typed-array.reduce"],
  "core-js/actual/typed-array/reduce-right": ["es.typed-array.reduce-right"],
  "core-js/actual/typed-array/reverse": ["es.typed-array.reverse"],
  "core-js/actual/typed-array/set": ["es.typed-array.set"],
  "core-js/actual/typed-array/slice": ["es.typed-array.slice"],
  "core-js/actual/typed-array/some": ["es.typed-array.some"],
  "core-js/actual/typed-array/sort": ["es.typed-array.sort"],
  "core-js/actual/typed-array/subarray": ["es.typed-array.subarray"],
  "core-js/actual/typed-array/to-locale-string": ["es.typed-array.to-locale-string"],
  "core-js/actual/typed-array/to-reversed": ["es.typed-array.to-reversed", "esnext.typed-array.to-reversed"],
  "core-js/actual/typed-array/to-sorted": [
    "es.typed-array.sort",
    "es.typed-array.to-sorted",
    "esnext.typed-array.to-sorted"
  ],
  "core-js/actual/typed-array/to-spliced": ["esnext.typed-array.to-spliced"],
  "core-js/actual/typed-array/to-string": ["es.typed-array.to-string"],
  "core-js/actual/typed-array/uint16-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.uint16-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.with"
  ],
  "core-js/actual/typed-array/uint32-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.uint32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.with"
  ],
  "core-js/actual/typed-array/uint8-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.uint8-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.with"
  ],
  "core-js/actual/typed-array/uint8-clamped-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.with"
  ],
  "core-js/actual/typed-array/values": ["es.object.to-string", "es.typed-array.iterator"],
  "core-js/actual/typed-array/with": ["es.typed-array.with", "esnext.typed-array.with"],
  "core-js/actual/unescape": ["es.unescape"],
  "core-js/actual/url": [
    "web.url",
    "web.url.can-parse",
    "web.url.to-json",
    "web.url-search-params",
    "web.url-search-params.delete",
    "web.url-search-params.has",
    "web.url-search-params.size"
  ],
  "core-js/actual/url-search-params": [
    "web.dom-collections.iterator",
    "web.url-search-params",
    "web.url-search-params.delete",
    "web.url-search-params.has",
    "web.url-search-params.size"
  ],
  "core-js/actual/url/can-parse": ["web.url", "web.url.can-parse"],
  "core-js/actual/url/to-json": ["web.url.to-json"],
  "core-js/actual/weak-map": [
    "es.array.iterator",
    "es.object.to-string",
    "es.weak-map",
    "web.dom-collections.iterator"
  ],
  "core-js/actual/weak-set": [
    "es.array.iterator",
    "es.object.to-string",
    "es.weak-set",
    "web.dom-collections.iterator"
  ],
  "core-js/es": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.error.cause",
    "es.error.to-string",
    "es.aggregate-error",
    "es.aggregate-error.cause",
    "es.array.at",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.find-last",
    "es.array.find-last-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.push",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.to-reversed",
    "es.array.to-sorted",
    "es.array.to-spliced",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array.unshift",
    "es.array.with",
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.data-view",
    "es.date.get-year",
    "es.date.now",
    "es.date.set-year",
    "es.date.to-gmt-string",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string",
    "es.escape",
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name",
    "es.global-this",
    "es.json.stringify",
    "es.json.to-string-tag",
    "es.map",
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc",
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-exponential",
    "es.number.to-fixed",
    "es.number.to-precision",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.has-own",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.proto",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.parse-float",
    "es.parse-int",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.any",
    "es.promise.finally",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.reflect.to-string-tag",
    "es.regexp.constructor",
    "es.regexp.dot-all",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.sticky",
    "es.regexp.test",
    "es.regexp.to-string",
    "es.set",
    "es.string.at-alternative",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.is-well-formed",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.replace-all",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.substr",
    "es.string.to-well-formed",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "es.unescape",
    "es.weak-map",
    "es.weak-set"
  ],
  "core-js/es/aggregate-error": [
    "es.error.cause",
    "es.aggregate-error",
    "es.aggregate-error.cause",
    "es.array.iterator",
    "es.string.iterator"
  ],
  "core-js/es/array": [
    "es.array.at",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.find-last",
    "es.array.find-last-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.push",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.to-reversed",
    "es.array.to-sorted",
    "es.array.to-spliced",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array.unshift",
    "es.array.with",
    "es.object.to-string",
    "es.string.iterator"
  ],
  "core-js/es/array-buffer": [
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.object.to-string"
  ],
  "core-js/es/array-buffer/constructor": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string"
  ],
  "core-js/es/array-buffer/is-view": ["es.array-buffer.is-view"],
  "core-js/es/array-buffer/slice": ["es.array-buffer.slice"],
  "core-js/es/array/at": ["es.array.at"],
  "core-js/es/array/concat": ["es.array.concat"],
  "core-js/es/array/copy-within": ["es.array.copy-within"],
  "core-js/es/array/entries": ["es.array.iterator", "es.object.to-string"],
  "core-js/es/array/every": ["es.array.every"],
  "core-js/es/array/fill": ["es.array.fill"],
  "core-js/es/array/filter": ["es.array.filter"],
  "core-js/es/array/find": ["es.array.find"],
  "core-js/es/array/find-index": ["es.array.find-index"],
  "core-js/es/array/find-last": ["es.array.find-last"],
  "core-js/es/array/find-last-index": ["es.array.find-last-index"],
  "core-js/es/array/flat": ["es.array.flat", "es.array.unscopables.flat"],
  "core-js/es/array/flat-map": ["es.array.flat-map", "es.array.unscopables.flat-map"],
  "core-js/es/array/for-each": ["es.array.for-each"],
  "core-js/es/array/from": ["es.array.from", "es.string.iterator"],
  "core-js/es/array/includes": ["es.array.includes"],
  "core-js/es/array/index-of": ["es.array.index-of"],
  "core-js/es/array/is-array": ["es.array.is-array"],
  "core-js/es/array/iterator": ["es.array.iterator", "es.object.to-string"],
  "core-js/es/array/join": ["es.array.join"],
  "core-js/es/array/keys": ["es.array.iterator", "es.object.to-string"],
  "core-js/es/array/last-index-of": ["es.array.last-index-of"],
  "core-js/es/array/map": ["es.array.map"],
  "core-js/es/array/of": ["es.array.of"],
  "core-js/es/array/push": ["es.array.push"],
  "core-js/es/array/reduce": ["es.array.reduce"],
  "core-js/es/array/reduce-right": ["es.array.reduce-right"],
  "core-js/es/array/reverse": ["es.array.reverse"],
  "core-js/es/array/slice": ["es.array.slice"],
  "core-js/es/array/some": ["es.array.some"],
  "core-js/es/array/sort": ["es.array.sort"],
  "core-js/es/array/splice": ["es.array.splice"],
  "core-js/es/array/to-reversed": ["es.array.to-reversed"],
  "core-js/es/array/to-sorted": ["es.array.sort", "es.array.to-sorted"],
  "core-js/es/array/to-spliced": ["es.array.to-spliced"],
  "core-js/es/array/unshift": ["es.array.unshift"],
  "core-js/es/array/values": ["es.array.iterator", "es.object.to-string"],
  "core-js/es/array/virtual": [
    "es.array.at",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.find-last",
    "es.array.find-last-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.includes",
    "es.array.index-of",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.push",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.to-reversed",
    "es.array.to-sorted",
    "es.array.to-spliced",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array.unshift",
    "es.array.with",
    "es.object.to-string"
  ],
  "core-js/es/array/virtual/at": ["es.array.at"],
  "core-js/es/array/virtual/concat": ["es.array.concat"],
  "core-js/es/array/virtual/copy-within": ["es.array.copy-within"],
  "core-js/es/array/virtual/entries": ["es.array.iterator", "es.object.to-string"],
  "core-js/es/array/virtual/every": ["es.array.every"],
  "core-js/es/array/virtual/fill": ["es.array.fill"],
  "core-js/es/array/virtual/filter": ["es.array.filter"],
  "core-js/es/array/virtual/find": ["es.array.find"],
  "core-js/es/array/virtual/find-index": ["es.array.find-index"],
  "core-js/es/array/virtual/find-last": ["es.array.find-last"],
  "core-js/es/array/virtual/find-last-index": ["es.array.find-last-index"],
  "core-js/es/array/virtual/flat": ["es.array.flat", "es.array.unscopables.flat"],
  "core-js/es/array/virtual/flat-map": ["es.array.flat-map", "es.array.unscopables.flat-map"],
  "core-js/es/array/virtual/for-each": ["es.array.for-each"],
  "core-js/es/array/virtual/includes": ["es.array.includes"],
  "core-js/es/array/virtual/index-of": ["es.array.index-of"],
  "core-js/es/array/virtual/iterator": ["es.array.iterator", "es.object.to-string"],
  "core-js/es/array/virtual/join": ["es.array.join"],
  "core-js/es/array/virtual/keys": ["es.array.iterator", "es.object.to-string"],
  "core-js/es/array/virtual/last-index-of": ["es.array.last-index-of"],
  "core-js/es/array/virtual/map": ["es.array.map"],
  "core-js/es/array/virtual/push": ["es.array.push"],
  "core-js/es/array/virtual/reduce": ["es.array.reduce"],
  "core-js/es/array/virtual/reduce-right": ["es.array.reduce-right"],
  "core-js/es/array/virtual/reverse": ["es.array.reverse"],
  "core-js/es/array/virtual/slice": ["es.array.slice"],
  "core-js/es/array/virtual/some": ["es.array.some"],
  "core-js/es/array/virtual/sort": ["es.array.sort"],
  "core-js/es/array/virtual/splice": ["es.array.splice"],
  "core-js/es/array/virtual/to-reversed": ["es.array.to-reversed"],
  "core-js/es/array/virtual/to-sorted": ["es.array.sort", "es.array.to-sorted"],
  "core-js/es/array/virtual/to-spliced": ["es.array.to-spliced"],
  "core-js/es/array/virtual/unshift": ["es.array.unshift"],
  "core-js/es/array/virtual/values": ["es.array.iterator", "es.object.to-string"],
  "core-js/es/array/virtual/with": ["es.array.with"],
  "core-js/es/array/with": ["es.array.with"],
  "core-js/es/data-view": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.data-view",
    "es.object.to-string"
  ],
  "core-js/es/date": [
    "es.date.get-year",
    "es.date.now",
    "es.date.set-year",
    "es.date.to-gmt-string",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string"
  ],
  "core-js/es/date/get-year": ["es.date.get-year"],
  "core-js/es/date/now": ["es.date.now"],
  "core-js/es/date/set-year": ["es.date.set-year"],
  "core-js/es/date/to-gmt-string": ["es.date.to-gmt-string"],
  "core-js/es/date/to-iso-string": ["es.date.to-iso-string", "es.date.to-json"],
  "core-js/es/date/to-json": ["es.date.to-json"],
  "core-js/es/date/to-primitive": ["es.date.to-primitive"],
  "core-js/es/date/to-string": ["es.date.to-string"],
  "core-js/es/error": ["es.error.cause", "es.error.to-string"],
  "core-js/es/error/constructor": ["es.error.cause"],
  "core-js/es/error/to-string": ["es.error.to-string"],
  "core-js/es/escape": ["es.escape"],
  "core-js/es/function": ["es.function.bind", "es.function.has-instance", "es.function.name"],
  "core-js/es/function/bind": ["es.function.bind"],
  "core-js/es/function/has-instance": ["es.function.has-instance"],
  "core-js/es/function/name": ["es.function.name"],
  "core-js/es/function/virtual": ["es.function.bind"],
  "core-js/es/function/virtual/bind": ["es.function.bind"],
  "core-js/es/get-iterator": ["es.array.iterator", "es.string.iterator"],
  "core-js/es/get-iterator-method": ["es.array.iterator", "es.string.iterator"],
  "core-js/es/global-this": ["es.global-this"],
  "core-js/es/instance/at": ["es.array.at", "es.string.at-alternative"],
  "core-js/es/instance/bind": ["es.function.bind"],
  "core-js/es/instance/code-point-at": ["es.string.code-point-at"],
  "core-js/es/instance/concat": ["es.array.concat"],
  "core-js/es/instance/copy-within": ["es.array.copy-within"],
  "core-js/es/instance/ends-with": ["es.string.ends-with"],
  "core-js/es/instance/entries": ["es.array.iterator", "es.object.to-string"],
  "core-js/es/instance/every": ["es.array.every"],
  "core-js/es/instance/fill": ["es.array.fill"],
  "core-js/es/instance/filter": ["es.array.filter"],
  "core-js/es/instance/find": ["es.array.find"],
  "core-js/es/instance/find-index": ["es.array.find-index"],
  "core-js/es/instance/find-last": ["es.array.find-last"],
  "core-js/es/instance/find-last-index": ["es.array.find-last-index"],
  "core-js/es/instance/flags": ["es.regexp.flags"],
  "core-js/es/instance/flat": ["es.array.flat", "es.array.unscopables.flat"],
  "core-js/es/instance/flat-map": ["es.array.flat-map", "es.array.unscopables.flat-map"],
  "core-js/es/instance/for-each": ["es.array.for-each"],
  "core-js/es/instance/includes": ["es.array.includes", "es.string.includes"],
  "core-js/es/instance/index-of": ["es.array.index-of"],
  "core-js/es/instance/is-well-formed": ["es.string.is-well-formed"],
  "core-js/es/instance/keys": ["es.array.iterator", "es.object.to-string"],
  "core-js/es/instance/last-index-of": ["es.array.last-index-of"],
  "core-js/es/instance/map": ["es.array.map"],
  "core-js/es/instance/match-all": ["es.object.to-string", "es.regexp.exec", "es.string.match-all"],
  "core-js/es/instance/pad-end": ["es.string.pad-end"],
  "core-js/es/instance/pad-start": ["es.string.pad-start"],
  "core-js/es/instance/push": ["es.array.push"],
  "core-js/es/instance/reduce": ["es.array.reduce"],
  "core-js/es/instance/reduce-right": ["es.array.reduce-right"],
  "core-js/es/instance/repeat": ["es.string.repeat"],
  "core-js/es/instance/replace-all": ["es.regexp.exec", "es.string.replace", "es.string.replace-all"],
  "core-js/es/instance/reverse": ["es.array.reverse"],
  "core-js/es/instance/slice": ["es.array.slice"],
  "core-js/es/instance/some": ["es.array.some"],
  "core-js/es/instance/sort": ["es.array.sort"],
  "core-js/es/instance/splice": ["es.array.splice"],
  "core-js/es/instance/starts-with": ["es.string.starts-with"],
  "core-js/es/instance/to-reversed": ["es.array.to-reversed"],
  "core-js/es/instance/to-sorted": ["es.array.sort", "es.array.to-sorted"],
  "core-js/es/instance/to-spliced": ["es.array.to-spliced"],
  "core-js/es/instance/to-well-formed": ["es.string.to-well-formed"],
  "core-js/es/instance/trim": ["es.string.trim"],
  "core-js/es/instance/trim-end": ["es.string.trim-end"],
  "core-js/es/instance/trim-left": ["es.string.trim-start"],
  "core-js/es/instance/trim-right": ["es.string.trim-end"],
  "core-js/es/instance/trim-start": ["es.string.trim-start"],
  "core-js/es/instance/unshift": ["es.array.unshift"],
  "core-js/es/instance/values": ["es.array.iterator", "es.object.to-string"],
  "core-js/es/instance/with": ["es.array.with"],
  "core-js/es/is-iterable": ["es.array.iterator", "es.string.iterator"],
  "core-js/es/json": ["es.json.stringify", "es.json.to-string-tag"],
  "core-js/es/json/stringify": ["es.json.stringify"],
  "core-js/es/json/to-string-tag": ["es.json.to-string-tag"],
  "core-js/es/map": ["es.array.iterator", "es.map", "es.object.to-string", "es.string.iterator"],
  "core-js/es/math": [
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc"
  ],
  "core-js/es/math/acosh": ["es.math.acosh"],
  "core-js/es/math/asinh": ["es.math.asinh"],
  "core-js/es/math/atanh": ["es.math.atanh"],
  "core-js/es/math/cbrt": ["es.math.cbrt"],
  "core-js/es/math/clz32": ["es.math.clz32"],
  "core-js/es/math/cosh": ["es.math.cosh"],
  "core-js/es/math/expm1": ["es.math.expm1"],
  "core-js/es/math/fround": ["es.math.fround"],
  "core-js/es/math/hypot": ["es.math.hypot"],
  "core-js/es/math/imul": ["es.math.imul"],
  "core-js/es/math/log10": ["es.math.log10"],
  "core-js/es/math/log1p": ["es.math.log1p"],
  "core-js/es/math/log2": ["es.math.log2"],
  "core-js/es/math/sign": ["es.math.sign"],
  "core-js/es/math/sinh": ["es.math.sinh"],
  "core-js/es/math/tanh": ["es.math.tanh"],
  "core-js/es/math/to-string-tag": ["es.math.to-string-tag"],
  "core-js/es/math/trunc": ["es.math.trunc"],
  "core-js/es/number": [
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-exponential",
    "es.number.to-fixed",
    "es.number.to-precision"
  ],
  "core-js/es/number/constructor": ["es.number.constructor"],
  "core-js/es/number/epsilon": ["es.number.epsilon"],
  "core-js/es/number/is-finite": ["es.number.is-finite"],
  "core-js/es/number/is-integer": ["es.number.is-integer"],
  "core-js/es/number/is-nan": ["es.number.is-nan"],
  "core-js/es/number/is-safe-integer": ["es.number.is-safe-integer"],
  "core-js/es/number/max-safe-integer": ["es.number.max-safe-integer"],
  "core-js/es/number/min-safe-integer": ["es.number.min-safe-integer"],
  "core-js/es/number/parse-float": ["es.number.parse-float"],
  "core-js/es/number/parse-int": ["es.number.parse-int"],
  "core-js/es/number/to-exponential": ["es.number.to-exponential"],
  "core-js/es/number/to-fixed": ["es.number.to-fixed"],
  "core-js/es/number/to-precision": ["es.number.to-precision"],
  "core-js/es/number/virtual": ["es.number.to-exponential", "es.number.to-fixed", "es.number.to-precision"],
  "core-js/es/number/virtual/to-exponential": ["es.number.to-exponential"],
  "core-js/es/number/virtual/to-fixed": ["es.number.to-fixed"],
  "core-js/es/number/virtual/to-precision": ["es.number.to-precision"],
  "core-js/es/object": [
    "es.symbol",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.has-own",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.proto",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.reflect.to-string-tag"
  ],
  "core-js/es/object/assign": ["es.object.assign"],
  "core-js/es/object/create": ["es.object.create"],
  "core-js/es/object/define-getter": ["es.object.define-getter"],
  "core-js/es/object/define-properties": ["es.object.define-properties"],
  "core-js/es/object/define-property": ["es.object.define-property"],
  "core-js/es/object/define-setter": ["es.object.define-setter"],
  "core-js/es/object/entries": ["es.object.entries"],
  "core-js/es/object/freeze": ["es.object.freeze"],
  "core-js/es/object/from-entries": ["es.array.iterator", "es.object.from-entries"],
  "core-js/es/object/get-own-property-descriptor": ["es.object.get-own-property-descriptor"],
  "core-js/es/object/get-own-property-descriptors": ["es.object.get-own-property-descriptors"],
  "core-js/es/object/get-own-property-names": ["es.object.get-own-property-names"],
  "core-js/es/object/get-own-property-symbols": ["es.symbol"],
  "core-js/es/object/get-prototype-of": ["es.object.get-prototype-of"],
  "core-js/es/object/has-own": ["es.object.has-own"],
  "core-js/es/object/is": ["es.object.is"],
  "core-js/es/object/is-extensible": ["es.object.is-extensible"],
  "core-js/es/object/is-frozen": ["es.object.is-frozen"],
  "core-js/es/object/is-sealed": ["es.object.is-sealed"],
  "core-js/es/object/keys": ["es.object.keys"],
  "core-js/es/object/lookup-getter": ["es.object.lookup-getter"],
  "core-js/es/object/lookup-setter": ["es.object.lookup-setter"],
  "core-js/es/object/prevent-extensions": ["es.object.prevent-extensions"],
  "core-js/es/object/proto": ["es.object.proto"],
  "core-js/es/object/seal": ["es.object.seal"],
  "core-js/es/object/set-prototype-of": ["es.object.set-prototype-of"],
  "core-js/es/object/to-string": [
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string",
    "es.reflect.to-string-tag"
  ],
  "core-js/es/object/values": ["es.object.values"],
  "core-js/es/parse-float": ["es.parse-float"],
  "core-js/es/parse-int": ["es.parse-int"],
  "core-js/es/promise": [
    "es.aggregate-error",
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.any",
    "es.promise.finally",
    "es.string.iterator"
  ],
  "core-js/es/promise/all-settled": [
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.promise.all-settled",
    "es.string.iterator"
  ],
  "core-js/es/promise/any": [
    "es.aggregate-error",
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.promise.any",
    "es.string.iterator"
  ],
  "core-js/es/promise/finally": ["es.object.to-string", "es.promise", "es.promise.finally"],
  "core-js/es/reflect": [
    "es.object.to-string",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.reflect.to-string-tag"
  ],
  "core-js/es/reflect/apply": ["es.reflect.apply"],
  "core-js/es/reflect/construct": ["es.reflect.construct"],
  "core-js/es/reflect/define-property": ["es.reflect.define-property"],
  "core-js/es/reflect/delete-property": ["es.reflect.delete-property"],
  "core-js/es/reflect/get": ["es.reflect.get"],
  "core-js/es/reflect/get-own-property-descriptor": ["es.reflect.get-own-property-descriptor"],
  "core-js/es/reflect/get-prototype-of": ["es.reflect.get-prototype-of"],
  "core-js/es/reflect/has": ["es.reflect.has"],
  "core-js/es/reflect/is-extensible": ["es.reflect.is-extensible"],
  "core-js/es/reflect/own-keys": ["es.reflect.own-keys"],
  "core-js/es/reflect/prevent-extensions": ["es.reflect.prevent-extensions"],
  "core-js/es/reflect/set": ["es.reflect.set"],
  "core-js/es/reflect/set-prototype-of": ["es.reflect.set-prototype-of"],
  "core-js/es/reflect/to-string-tag": ["es.object.to-string", "es.reflect.to-string-tag"],
  "core-js/es/regexp": [
    "es.regexp.constructor",
    "es.regexp.dot-all",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.sticky",
    "es.regexp.test",
    "es.regexp.to-string",
    "es.string.match",
    "es.string.replace",
    "es.string.search",
    "es.string.split"
  ],
  "core-js/es/regexp/constructor": ["es.regexp.constructor", "es.regexp.dot-all", "es.regexp.exec", "es.regexp.sticky"],
  "core-js/es/regexp/dot-all": ["es.regexp.constructor", "es.regexp.dot-all", "es.regexp.exec"],
  "core-js/es/regexp/flags": ["es.regexp.flags"],
  "core-js/es/regexp/match": ["es.regexp.exec", "es.string.match"],
  "core-js/es/regexp/replace": ["es.regexp.exec", "es.string.replace"],
  "core-js/es/regexp/search": ["es.regexp.exec", "es.string.search"],
  "core-js/es/regexp/split": ["es.regexp.exec", "es.string.split"],
  "core-js/es/regexp/sticky": ["es.regexp.constructor", "es.regexp.exec", "es.regexp.sticky"],
  "core-js/es/regexp/test": ["es.regexp.exec", "es.regexp.test"],
  "core-js/es/regexp/to-string": ["es.regexp.to-string"],
  "core-js/es/set": ["es.array.iterator", "es.object.to-string", "es.set", "es.string.iterator"],
  "core-js/es/string": [
    "es.object.to-string",
    "es.regexp.exec",
    "es.string.at-alternative",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.is-well-formed",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.replace-all",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.substr",
    "es.string.to-well-formed",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup"
  ],
  "core-js/es/string/anchor": ["es.string.anchor"],
  "core-js/es/string/at": ["es.string.at-alternative"],
  "core-js/es/string/big": ["es.string.big"],
  "core-js/es/string/blink": ["es.string.blink"],
  "core-js/es/string/bold": ["es.string.bold"],
  "core-js/es/string/code-point-at": ["es.string.code-point-at"],
  "core-js/es/string/ends-with": ["es.string.ends-with"],
  "core-js/es/string/fixed": ["es.string.fixed"],
  "core-js/es/string/fontcolor": ["es.string.fontcolor"],
  "core-js/es/string/fontsize": ["es.string.fontsize"],
  "core-js/es/string/from-code-point": ["es.string.from-code-point"],
  "core-js/es/string/includes": ["es.string.includes"],
  "core-js/es/string/is-well-formed": ["es.string.is-well-formed"],
  "core-js/es/string/italics": ["es.string.italics"],
  "core-js/es/string/iterator": ["es.object.to-string", "es.string.iterator"],
  "core-js/es/string/link": ["es.string.link"],
  "core-js/es/string/match": ["es.regexp.exec", "es.string.match"],
  "core-js/es/string/match-all": ["es.object.to-string", "es.regexp.exec", "es.string.match-all"],
  "core-js/es/string/pad-end": ["es.string.pad-end"],
  "core-js/es/string/pad-start": ["es.string.pad-start"],
  "core-js/es/string/raw": ["es.string.raw"],
  "core-js/es/string/repeat": ["es.string.repeat"],
  "core-js/es/string/replace": ["es.regexp.exec", "es.string.replace"],
  "core-js/es/string/replace-all": ["es.regexp.exec", "es.string.replace", "es.string.replace-all"],
  "core-js/es/string/search": ["es.regexp.exec", "es.string.search"],
  "core-js/es/string/small": ["es.string.small"],
  "core-js/es/string/split": ["es.regexp.exec", "es.string.split"],
  "core-js/es/string/starts-with": ["es.string.starts-with"],
  "core-js/es/string/strike": ["es.string.strike"],
  "core-js/es/string/sub": ["es.string.sub"],
  "core-js/es/string/substr": ["es.string.substr"],
  "core-js/es/string/sup": ["es.string.sup"],
  "core-js/es/string/to-well-formed": ["es.string.to-well-formed"],
  "core-js/es/string/trim": ["es.string.trim"],
  "core-js/es/string/trim-end": ["es.string.trim-end"],
  "core-js/es/string/trim-left": ["es.string.trim-start"],
  "core-js/es/string/trim-right": ["es.string.trim-end"],
  "core-js/es/string/trim-start": ["es.string.trim-start"],
  "core-js/es/string/virtual": [
    "es.object.to-string",
    "es.regexp.exec",
    "es.string.at-alternative",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.repeat",
    "es.string.replace",
    "es.string.replace-all",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.substr",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup"
  ],
  "core-js/es/string/virtual/anchor": ["es.string.anchor"],
  "core-js/es/string/virtual/at": ["es.string.at-alternative"],
  "core-js/es/string/virtual/big": ["es.string.big"],
  "core-js/es/string/virtual/blink": ["es.string.blink"],
  "core-js/es/string/virtual/bold": ["es.string.bold"],
  "core-js/es/string/virtual/code-point-at": ["es.string.code-point-at"],
  "core-js/es/string/virtual/ends-with": ["es.string.ends-with"],
  "core-js/es/string/virtual/fixed": ["es.string.fixed"],
  "core-js/es/string/virtual/fontcolor": ["es.string.fontcolor"],
  "core-js/es/string/virtual/fontsize": ["es.string.fontsize"],
  "core-js/es/string/virtual/includes": ["es.string.includes"],
  "core-js/es/string/virtual/is-well-formed": ["es.string.is-well-formed"],
  "core-js/es/string/virtual/italics": ["es.string.italics"],
  "core-js/es/string/virtual/iterator": ["es.object.to-string", "es.string.iterator"],
  "core-js/es/string/virtual/link": ["es.string.link"],
  "core-js/es/string/virtual/match-all": ["es.object.to-string", "es.regexp.exec", "es.string.match-all"],
  "core-js/es/string/virtual/pad-end": ["es.string.pad-end"],
  "core-js/es/string/virtual/pad-start": ["es.string.pad-start"],
  "core-js/es/string/virtual/repeat": ["es.string.repeat"],
  "core-js/es/string/virtual/replace-all": ["es.regexp.exec", "es.string.replace", "es.string.replace-all"],
  "core-js/es/string/virtual/small": ["es.string.small"],
  "core-js/es/string/virtual/starts-with": ["es.string.starts-with"],
  "core-js/es/string/virtual/strike": ["es.string.strike"],
  "core-js/es/string/virtual/sub": ["es.string.sub"],
  "core-js/es/string/virtual/substr": ["es.string.substr"],
  "core-js/es/string/virtual/sup": ["es.string.sup"],
  "core-js/es/string/virtual/to-well-formed": ["es.string.to-well-formed"],
  "core-js/es/string/virtual/trim": ["es.string.trim"],
  "core-js/es/string/virtual/trim-end": ["es.string.trim-end"],
  "core-js/es/string/virtual/trim-left": ["es.string.trim-start"],
  "core-js/es/string/virtual/trim-right": ["es.string.trim-end"],
  "core-js/es/string/virtual/trim-start": ["es.string.trim-start"],
  "core-js/es/symbol": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string",
    "es.reflect.to-string-tag"
  ],
  "core-js/es/symbol/async-iterator": ["es.symbol.async-iterator"],
  "core-js/es/symbol/description": ["es.symbol.description"],
  "core-js/es/symbol/for": ["es.symbol"],
  "core-js/es/symbol/has-instance": ["es.symbol.has-instance", "es.function.has-instance"],
  "core-js/es/symbol/is-concat-spreadable": ["es.symbol.is-concat-spreadable", "es.array.concat"],
  "core-js/es/symbol/iterator": [
    "es.symbol.iterator",
    "es.array.iterator",
    "es.object.to-string",
    "es.string.iterator"
  ],
  "core-js/es/symbol/key-for": ["es.symbol"],
  "core-js/es/symbol/match": ["es.symbol.match", "es.regexp.exec", "es.string.match"],
  "core-js/es/symbol/match-all": [
    "es.symbol.match-all",
    "es.object.to-string",
    "es.regexp.exec",
    "es.string.match-all"
  ],
  "core-js/es/symbol/replace": ["es.symbol.replace", "es.regexp.exec", "es.string.replace"],
  "core-js/es/symbol/search": ["es.symbol.search", "es.regexp.exec", "es.string.search"],
  "core-js/es/symbol/species": ["es.symbol.species"],
  "core-js/es/symbol/split": ["es.symbol.split", "es.regexp.exec", "es.string.split"],
  "core-js/es/symbol/to-primitive": ["es.symbol.to-primitive", "es.date.to-primitive"],
  "core-js/es/symbol/to-string-tag": [
    "es.symbol.to-string-tag",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string",
    "es.reflect.to-string-tag"
  ],
  "core-js/es/symbol/unscopables": ["es.symbol.unscopables"],
  "core-js/es/typed-array": [
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with"
  ],
  "core-js/es/typed-array/at": ["es.typed-array.at"],
  "core-js/es/typed-array/copy-within": ["es.typed-array.copy-within"],
  "core-js/es/typed-array/entries": ["es.object.to-string", "es.typed-array.iterator"],
  "core-js/es/typed-array/every": ["es.typed-array.every"],
  "core-js/es/typed-array/fill": ["es.typed-array.fill"],
  "core-js/es/typed-array/filter": ["es.typed-array.filter"],
  "core-js/es/typed-array/find": ["es.typed-array.find"],
  "core-js/es/typed-array/find-index": ["es.typed-array.find-index"],
  "core-js/es/typed-array/find-last": ["es.typed-array.find-last"],
  "core-js/es/typed-array/find-last-index": ["es.typed-array.find-last-index"],
  "core-js/es/typed-array/float32-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.float32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with"
  ],
  "core-js/es/typed-array/float64-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.float64-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with"
  ],
  "core-js/es/typed-array/for-each": ["es.typed-array.for-each"],
  "core-js/es/typed-array/from": ["es.typed-array.from"],
  "core-js/es/typed-array/includes": ["es.typed-array.includes"],
  "core-js/es/typed-array/index-of": ["es.typed-array.index-of"],
  "core-js/es/typed-array/int16-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.int16-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with"
  ],
  "core-js/es/typed-array/int32-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.int32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with"
  ],
  "core-js/es/typed-array/int8-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.int8-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with"
  ],
  "core-js/es/typed-array/iterator": ["es.object.to-string", "es.typed-array.iterator"],
  "core-js/es/typed-array/join": ["es.typed-array.join"],
  "core-js/es/typed-array/keys": ["es.object.to-string", "es.typed-array.iterator"],
  "core-js/es/typed-array/last-index-of": ["es.typed-array.last-index-of"],
  "core-js/es/typed-array/map": ["es.typed-array.map"],
  "core-js/es/typed-array/methods": [
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with"
  ],
  "core-js/es/typed-array/of": ["es.typed-array.of"],
  "core-js/es/typed-array/reduce": ["es.typed-array.reduce"],
  "core-js/es/typed-array/reduce-right": ["es.typed-array.reduce-right"],
  "core-js/es/typed-array/reverse": ["es.typed-array.reverse"],
  "core-js/es/typed-array/set": ["es.typed-array.set"],
  "core-js/es/typed-array/slice": ["es.typed-array.slice"],
  "core-js/es/typed-array/some": ["es.typed-array.some"],
  "core-js/es/typed-array/sort": ["es.typed-array.sort"],
  "core-js/es/typed-array/subarray": ["es.typed-array.subarray"],
  "core-js/es/typed-array/to-locale-string": ["es.typed-array.to-locale-string"],
  "core-js/es/typed-array/to-reversed": ["es.typed-array.to-reversed"],
  "core-js/es/typed-array/to-sorted": ["es.typed-array.sort", "es.typed-array.to-sorted"],
  "core-js/es/typed-array/to-string": ["es.typed-array.to-string"],
  "core-js/es/typed-array/uint16-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.uint16-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with"
  ],
  "core-js/es/typed-array/uint32-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.uint32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with"
  ],
  "core-js/es/typed-array/uint8-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.uint8-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with"
  ],
  "core-js/es/typed-array/uint8-clamped-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with"
  ],
  "core-js/es/typed-array/values": ["es.object.to-string", "es.typed-array.iterator"],
  "core-js/es/typed-array/with": ["es.typed-array.with"],
  "core-js/es/unescape": ["es.unescape"],
  "core-js/es/weak-map": ["es.array.iterator", "es.object.to-string", "es.weak-map"],
  "core-js/es/weak-set": ["es.array.iterator", "es.object.to-string", "es.weak-set"],
  "core-js/features": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.error.cause",
    "es.error.to-string",
    "es.aggregate-error",
    "es.aggregate-error.cause",
    "es.array.at",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.find-last",
    "es.array.find-last-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.push",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.to-reversed",
    "es.array.to-sorted",
    "es.array.to-spliced",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array.unshift",
    "es.array.with",
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.data-view",
    "es.date.get-year",
    "es.date.now",
    "es.date.set-year",
    "es.date.to-gmt-string",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string",
    "es.escape",
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name",
    "es.global-this",
    "es.json.stringify",
    "es.json.to-string-tag",
    "es.map",
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc",
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-exponential",
    "es.number.to-fixed",
    "es.number.to-precision",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.has-own",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.proto",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.parse-float",
    "es.parse-int",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.any",
    "es.promise.finally",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.reflect.to-string-tag",
    "es.regexp.constructor",
    "es.regexp.dot-all",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.sticky",
    "es.regexp.test",
    "es.regexp.to-string",
    "es.set",
    "es.string.at-alternative",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.is-well-formed",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.replace-all",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.substr",
    "es.string.to-well-formed",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "es.unescape",
    "es.weak-map",
    "es.weak-set",
    "esnext.aggregate-error",
    "esnext.suppressed-error.constructor",
    "esnext.array.from-async",
    "esnext.array.at",
    "esnext.array.filter-out",
    "esnext.array.filter-reject",
    "esnext.array.find-last",
    "esnext.array.find-last-index",
    "esnext.array.group",
    "esnext.array.group-by",
    "esnext.array.group-by-to-map",
    "esnext.array.group-to-map",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.array.to-reversed",
    "esnext.array.to-sorted",
    "esnext.array.to-spliced",
    "esnext.array.unique-by",
    "esnext.array.with",
    "esnext.array-buffer.detached",
    "esnext.array-buffer.transfer",
    "esnext.array-buffer.transfer-to-fixed-length",
    "esnext.async-disposable-stack.constructor",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.async-dispose",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.indexed",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.bigint.range",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.disposable-stack.constructor",
    "esnext.function.demethodize",
    "esnext.function.is-callable",
    "esnext.function.is-constructor",
    "esnext.function.metadata",
    "esnext.function.un-this",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.dispose",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.indexed",
    "esnext.iterator.map",
    "esnext.iterator.range",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.iterator.to-async",
    "esnext.json.is-raw-json",
    "esnext.json.parse",
    "esnext.json.raw-json",
    "esnext.map.delete-all",
    "esnext.map.emplace",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.number.range",
    "esnext.object.has-own",
    "esnext.object.iterate-entries",
    "esnext.object.iterate-keys",
    "esnext.object.iterate-values",
    "esnext.object.group-by",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.promise.with-resolvers",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference.v2",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection.v2",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from.v2",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of.v2",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of.v2",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference.v2",
    "esnext.set.symmetric-difference",
    "esnext.set.union.v2",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.cooked",
    "esnext.string.code-points",
    "esnext.string.dedent",
    "esnext.string.is-well-formed",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.string.to-well-formed",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.is-registered-symbol",
    "esnext.symbol.is-registered",
    "esnext.symbol.is-well-known-symbol",
    "esnext.symbol.is-well-known",
    "esnext.symbol.matcher",
    "esnext.symbol.metadata",
    "esnext.symbol.metadata-key",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.emplace",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.atob",
    "web.btoa",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag",
    "web.immediate",
    "web.queue-microtask",
    "web.self",
    "web.structured-clone",
    "web.timers",
    "web.url",
    "web.url.can-parse",
    "web.url.to-json",
    "web.url-search-params",
    "web.url-search-params.delete",
    "web.url-search-params.has",
    "web.url-search-params.size"
  ],
  "core-js/features/aggregate-error": [
    "es.error.cause",
    "es.aggregate-error",
    "es.aggregate-error.cause",
    "es.array.iterator",
    "es.string.iterator",
    "esnext.aggregate-error",
    "web.dom-collections.iterator"
  ],
  "core-js/features/array": [
    "es.array.at",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.find-last",
    "es.array.find-last-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.push",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.to-reversed",
    "es.array.to-sorted",
    "es.array.to-spliced",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array.unshift",
    "es.array.with",
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.array.from-async",
    "esnext.array.at",
    "esnext.array.filter-out",
    "esnext.array.filter-reject",
    "esnext.array.find-last",
    "esnext.array.find-last-index",
    "esnext.array.group",
    "esnext.array.group-by",
    "esnext.array.group-by-to-map",
    "esnext.array.group-to-map",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.array.to-reversed",
    "esnext.array.to-sorted",
    "esnext.array.to-spliced",
    "esnext.array.unique-by",
    "esnext.array.with"
  ],
  "core-js/features/array-buffer": [
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.object.to-string",
    "esnext.array-buffer.detached",
    "esnext.array-buffer.transfer",
    "esnext.array-buffer.transfer-to-fixed-length"
  ],
  "core-js/features/array-buffer/constructor": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "esnext.array-buffer.detached",
    "esnext.array-buffer.transfer",
    "esnext.array-buffer.transfer-to-fixed-length"
  ],
  "core-js/features/array-buffer/detached": [
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.object.to-string",
    "esnext.array-buffer.detached"
  ],
  "core-js/features/array-buffer/is-view": ["es.array-buffer.is-view"],
  "core-js/features/array-buffer/slice": ["es.array-buffer.slice"],
  "core-js/features/array-buffer/transfer": [
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.object.to-string",
    "esnext.array-buffer.transfer"
  ],
  "core-js/features/array-buffer/transfer-to-fixed-length": [
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.object.to-string",
    "esnext.array-buffer.transfer-to-fixed-length"
  ],
  "core-js/features/array/at": ["es.array.at", "esnext.array.at"],
  "core-js/features/array/concat": ["es.array.concat"],
  "core-js/features/array/copy-within": ["es.array.copy-within"],
  "core-js/features/array/entries": ["es.array.iterator", "es.object.to-string"],
  "core-js/features/array/every": ["es.array.every"],
  "core-js/features/array/fill": ["es.array.fill"],
  "core-js/features/array/filter": ["es.array.filter"],
  "core-js/features/array/filter-out": ["esnext.array.filter-out"],
  "core-js/features/array/filter-reject": ["esnext.array.filter-reject"],
  "core-js/features/array/find": ["es.array.find"],
  "core-js/features/array/find-index": ["es.array.find-index"],
  "core-js/features/array/find-last": ["es.array.find-last", "esnext.array.find-last"],
  "core-js/features/array/find-last-index": ["es.array.find-last-index", "esnext.array.find-last-index"],
  "core-js/features/array/flat": ["es.array.flat", "es.array.unscopables.flat"],
  "core-js/features/array/flat-map": ["es.array.flat-map", "es.array.unscopables.flat-map"],
  "core-js/features/array/for-each": ["es.array.for-each"],
  "core-js/features/array/from": ["es.array.from", "es.string.iterator"],
  "core-js/features/array/from-async": [
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.array.from-async"
  ],
  "core-js/features/array/group": ["esnext.array.group"],
  "core-js/features/array/group-by": ["esnext.array.group-by"],
  "core-js/features/array/group-by-to-map": ["es.map", "es.object.to-string", "esnext.array.group-by-to-map"],
  "core-js/features/array/group-to-map": ["es.map", "es.object.to-string", "esnext.array.group-to-map"],
  "core-js/features/array/includes": ["es.array.includes"],
  "core-js/features/array/index-of": ["es.array.index-of"],
  "core-js/features/array/is-array": ["es.array.is-array"],
  "core-js/features/array/is-template-object": ["esnext.array.is-template-object"],
  "core-js/features/array/iterator": ["es.array.iterator", "es.object.to-string"],
  "core-js/features/array/join": ["es.array.join"],
  "core-js/features/array/keys": ["es.array.iterator", "es.object.to-string"],
  "core-js/features/array/last-index": ["esnext.array.last-index"],
  "core-js/features/array/last-index-of": ["es.array.last-index-of"],
  "core-js/features/array/last-item": ["esnext.array.last-item"],
  "core-js/features/array/map": ["es.array.map"],
  "core-js/features/array/of": ["es.array.of"],
  "core-js/features/array/push": ["es.array.push"],
  "core-js/features/array/reduce": ["es.array.reduce"],
  "core-js/features/array/reduce-right": ["es.array.reduce-right"],
  "core-js/features/array/reverse": ["es.array.reverse"],
  "core-js/features/array/slice": ["es.array.slice"],
  "core-js/features/array/some": ["es.array.some"],
  "core-js/features/array/sort": ["es.array.sort"],
  "core-js/features/array/splice": ["es.array.splice"],
  "core-js/features/array/to-reversed": ["es.array.to-reversed", "esnext.array.to-reversed"],
  "core-js/features/array/to-sorted": ["es.array.sort", "es.array.to-sorted", "esnext.array.to-sorted"],
  "core-js/features/array/to-spliced": ["es.array.to-spliced", "esnext.array.to-spliced"],
  "core-js/features/array/unique-by": ["es.map", "esnext.array.unique-by"],
  "core-js/features/array/unshift": ["es.array.unshift"],
  "core-js/features/array/values": ["es.array.iterator", "es.object.to-string"],
  "core-js/features/array/virtual": [
    "es.array.at",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.find-last",
    "es.array.find-last-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.includes",
    "es.array.index-of",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.push",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.to-reversed",
    "es.array.to-sorted",
    "es.array.to-spliced",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array.unshift",
    "es.array.with",
    "es.map",
    "es.object.to-string",
    "esnext.array.at",
    "esnext.array.filter-out",
    "esnext.array.filter-reject",
    "esnext.array.find-last",
    "esnext.array.find-last-index",
    "esnext.array.group",
    "esnext.array.group-by",
    "esnext.array.group-by-to-map",
    "esnext.array.group-to-map",
    "esnext.array.to-reversed",
    "esnext.array.to-sorted",
    "esnext.array.to-spliced",
    "esnext.array.unique-by",
    "esnext.array.with"
  ],
  "core-js/features/array/virtual/at": ["es.array.at", "esnext.array.at"],
  "core-js/features/array/virtual/concat": ["es.array.concat"],
  "core-js/features/array/virtual/copy-within": ["es.array.copy-within"],
  "core-js/features/array/virtual/entries": ["es.array.iterator", "es.object.to-string"],
  "core-js/features/array/virtual/every": ["es.array.every"],
  "core-js/features/array/virtual/fill": ["es.array.fill"],
  "core-js/features/array/virtual/filter": ["es.array.filter"],
  "core-js/features/array/virtual/filter-out": ["esnext.array.filter-out"],
  "core-js/features/array/virtual/filter-reject": ["esnext.array.filter-reject"],
  "core-js/features/array/virtual/find": ["es.array.find"],
  "core-js/features/array/virtual/find-index": ["es.array.find-index"],
  "core-js/features/array/virtual/find-last": ["es.array.find-last", "esnext.array.find-last"],
  "core-js/features/array/virtual/find-last-index": ["es.array.find-last-index", "esnext.array.find-last-index"],
  "core-js/features/array/virtual/flat": ["es.array.flat", "es.array.unscopables.flat"],
  "core-js/features/array/virtual/flat-map": ["es.array.flat-map", "es.array.unscopables.flat-map"],
  "core-js/features/array/virtual/for-each": ["es.array.for-each"],
  "core-js/features/array/virtual/group": ["esnext.array.group"],
  "core-js/features/array/virtual/group-by": ["esnext.array.group-by"],
  "core-js/features/array/virtual/group-by-to-map": ["es.map", "es.object.to-string", "esnext.array.group-by-to-map"],
  "core-js/features/array/virtual/group-to-map": ["es.map", "es.object.to-string", "esnext.array.group-to-map"],
  "core-js/features/array/virtual/includes": ["es.array.includes"],
  "core-js/features/array/virtual/index-of": ["es.array.index-of"],
  "core-js/features/array/virtual/iterator": ["es.array.iterator", "es.object.to-string"],
  "core-js/features/array/virtual/join": ["es.array.join"],
  "core-js/features/array/virtual/keys": ["es.array.iterator", "es.object.to-string"],
  "core-js/features/array/virtual/last-index-of": ["es.array.last-index-of"],
  "core-js/features/array/virtual/map": ["es.array.map"],
  "core-js/features/array/virtual/push": ["es.array.push"],
  "core-js/features/array/virtual/reduce": ["es.array.reduce"],
  "core-js/features/array/virtual/reduce-right": ["es.array.reduce-right"],
  "core-js/features/array/virtual/reverse": ["es.array.reverse"],
  "core-js/features/array/virtual/slice": ["es.array.slice"],
  "core-js/features/array/virtual/some": ["es.array.some"],
  "core-js/features/array/virtual/sort": ["es.array.sort"],
  "core-js/features/array/virtual/splice": ["es.array.splice"],
  "core-js/features/array/virtual/to-reversed": ["es.array.to-reversed", "esnext.array.to-reversed"],
  "core-js/features/array/virtual/to-sorted": ["es.array.sort", "es.array.to-sorted", "esnext.array.to-sorted"],
  "core-js/features/array/virtual/to-spliced": ["es.array.to-spliced", "esnext.array.to-spliced"],
  "core-js/features/array/virtual/unique-by": ["es.map", "esnext.array.unique-by"],
  "core-js/features/array/virtual/unshift": ["es.array.unshift"],
  "core-js/features/array/virtual/values": ["es.array.iterator", "es.object.to-string"],
  "core-js/features/array/virtual/with": ["es.array.with", "esnext.array.with"],
  "core-js/features/array/with": ["es.array.with", "esnext.array.with"],
  "core-js/features/async-disposable-stack": [
    "es.error.cause",
    "es.error.to-string",
    "es.object.to-string",
    "es.promise",
    "esnext.suppressed-error.constructor",
    "esnext.async-disposable-stack.constructor",
    "esnext.async-iterator.async-dispose",
    "esnext.iterator.dispose"
  ],
  "core-js/features/async-disposable-stack/constructor": [
    "es.error.cause",
    "es.error.to-string",
    "es.object.to-string",
    "es.promise",
    "esnext.suppressed-error.constructor",
    "esnext.async-disposable-stack.constructor",
    "esnext.async-iterator.async-dispose",
    "esnext.iterator.dispose"
  ],
  "core-js/features/async-iterator": [
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.async-dispose",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.indexed",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "web.dom-collections.iterator"
  ],
  "core-js/features/async-iterator/as-indexed-pairs": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs"
  ],
  "core-js/features/async-iterator/async-dispose": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.async-dispose"
  ],
  "core-js/features/async-iterator/drop": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.drop"
  ],
  "core-js/features/async-iterator/every": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.every"
  ],
  "core-js/features/async-iterator/filter": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.filter"
  ],
  "core-js/features/async-iterator/find": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.find"
  ],
  "core-js/features/async-iterator/flat-map": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.flat-map"
  ],
  "core-js/features/async-iterator/for-each": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.for-each"
  ],
  "core-js/features/async-iterator/from": [
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "web.dom-collections.iterator"
  ],
  "core-js/features/async-iterator/indexed": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.indexed"
  ],
  "core-js/features/async-iterator/map": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.map"
  ],
  "core-js/features/async-iterator/reduce": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.reduce"
  ],
  "core-js/features/async-iterator/some": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.some"
  ],
  "core-js/features/async-iterator/take": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.take"
  ],
  "core-js/features/async-iterator/to-array": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.to-array"
  ],
  "core-js/features/atob": [
    "es.error.to-string",
    "es.object.to-string",
    "web.atob",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag"
  ],
  "core-js/features/bigint": ["es.object.to-string", "esnext.bigint.range"],
  "core-js/features/bigint/range": ["es.object.to-string", "esnext.bigint.range"],
  "core-js/features/btoa": [
    "es.error.to-string",
    "es.object.to-string",
    "web.btoa",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag"
  ],
  "core-js/features/clear-immediate": ["web.immediate"],
  "core-js/features/composite-key": ["esnext.composite-key"],
  "core-js/features/composite-symbol": ["es.symbol", "esnext.composite-symbol"],
  "core-js/features/data-view": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.data-view",
    "es.object.to-string"
  ],
  "core-js/features/date": [
    "es.date.get-year",
    "es.date.now",
    "es.date.set-year",
    "es.date.to-gmt-string",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string"
  ],
  "core-js/features/date/get-year": ["es.date.get-year"],
  "core-js/features/date/now": ["es.date.now"],
  "core-js/features/date/set-year": ["es.date.set-year"],
  "core-js/features/date/to-gmt-string": ["es.date.to-gmt-string"],
  "core-js/features/date/to-iso-string": ["es.date.to-iso-string", "es.date.to-json"],
  "core-js/features/date/to-json": ["es.date.to-json"],
  "core-js/features/date/to-primitive": ["es.date.to-primitive"],
  "core-js/features/date/to-string": ["es.date.to-string"],
  "core-js/features/disposable-stack": [
    "es.error.cause",
    "es.error.to-string",
    "es.object.to-string",
    "esnext.suppressed-error.constructor",
    "esnext.disposable-stack.constructor",
    "esnext.iterator.dispose"
  ],
  "core-js/features/disposable-stack/constructor": [
    "es.error.cause",
    "es.error.to-string",
    "es.object.to-string",
    "esnext.suppressed-error.constructor",
    "esnext.disposable-stack.constructor",
    "esnext.iterator.dispose"
  ],
  "core-js/features/dom-collections": [
    "es.array.iterator",
    "es.object.to-string",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator"
  ],
  "core-js/features/dom-collections/for-each": ["web.dom-collections.for-each"],
  "core-js/features/dom-collections/iterator": ["es.object.to-string", "web.dom-collections.iterator"],
  "core-js/features/dom-exception": [
    "es.error.to-string",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag"
  ],
  "core-js/features/dom-exception/constructor": [
    "es.error.to-string",
    "web.dom-exception.constructor",
    "web.dom-exception.stack"
  ],
  "core-js/features/dom-exception/to-string-tag": ["web.dom-exception.to-string-tag"],
  "core-js/features/error": ["es.error.cause", "es.error.to-string"],
  "core-js/features/error/constructor": ["es.error.cause"],
  "core-js/features/error/to-string": ["es.error.to-string"],
  "core-js/features/escape": ["es.escape"],
  "core-js/features/function": [
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name",
    "esnext.function.demethodize",
    "esnext.function.is-callable",
    "esnext.function.is-constructor",
    "esnext.function.metadata",
    "esnext.function.un-this"
  ],
  "core-js/features/function/bind": ["es.function.bind"],
  "core-js/features/function/demethodize": ["esnext.function.demethodize"],
  "core-js/features/function/has-instance": ["es.function.has-instance"],
  "core-js/features/function/is-callable": ["esnext.function.is-callable"],
  "core-js/features/function/is-constructor": ["esnext.function.is-constructor"],
  "core-js/features/function/metadata": ["esnext.function.metadata"],
  "core-js/features/function/name": ["es.function.name"],
  "core-js/features/function/un-this": ["esnext.function.un-this"],
  "core-js/features/function/virtual": ["es.function.bind", "esnext.function.demethodize", "esnext.function.un-this"],
  "core-js/features/function/virtual/bind": ["es.function.bind"],
  "core-js/features/function/virtual/demethodize": ["esnext.function.demethodize"],
  "core-js/features/function/virtual/un-this": ["esnext.function.un-this"],
  "core-js/features/get-iterator": ["es.array.iterator", "es.string.iterator", "web.dom-collections.iterator"],
  "core-js/features/get-iterator-method": ["es.array.iterator", "es.string.iterator", "web.dom-collections.iterator"],
  "core-js/features/global-this": ["es.global-this", "esnext.global-this"],
  "core-js/features/instance/at": ["es.array.at", "es.string.at-alternative", "esnext.array.at", "esnext.string.at"],
  "core-js/features/instance/bind": ["es.function.bind"],
  "core-js/features/instance/code-point-at": ["es.string.code-point-at"],
  "core-js/features/instance/code-points": ["es.object.to-string", "esnext.string.code-points"],
  "core-js/features/instance/concat": ["es.array.concat"],
  "core-js/features/instance/copy-within": ["es.array.copy-within"],
  "core-js/features/instance/demethodize": ["esnext.function.demethodize"],
  "core-js/features/instance/ends-with": ["es.string.ends-with"],
  "core-js/features/instance/entries": ["es.array.iterator", "es.object.to-string", "web.dom-collections.iterator"],
  "core-js/features/instance/every": ["es.array.every"],
  "core-js/features/instance/fill": ["es.array.fill"],
  "core-js/features/instance/filter": ["es.array.filter"],
  "core-js/features/instance/filter-out": ["esnext.array.filter-out"],
  "core-js/features/instance/filter-reject": ["esnext.array.filter-reject"],
  "core-js/features/instance/find": ["es.array.find"],
  "core-js/features/instance/find-index": ["es.array.find-index"],
  "core-js/features/instance/find-last": ["es.array.find-last", "esnext.array.find-last"],
  "core-js/features/instance/find-last-index": ["es.array.find-last-index", "esnext.array.find-last-index"],
  "core-js/features/instance/flags": ["es.regexp.flags"],
  "core-js/features/instance/flat": ["es.array.flat", "es.array.unscopables.flat"],
  "core-js/features/instance/flat-map": ["es.array.flat-map", "es.array.unscopables.flat-map"],
  "core-js/features/instance/for-each": ["es.array.for-each", "web.dom-collections.iterator"],
  "core-js/features/instance/group": ["esnext.array.group"],
  "core-js/features/instance/group-by": ["esnext.array.group-by"],
  "core-js/features/instance/group-by-to-map": ["es.map", "es.object.to-string", "esnext.array.group-by-to-map"],
  "core-js/features/instance/group-to-map": ["es.map", "es.object.to-string", "esnext.array.group-to-map"],
  "core-js/features/instance/includes": ["es.array.includes", "es.string.includes"],
  "core-js/features/instance/index-of": ["es.array.index-of"],
  "core-js/features/instance/is-well-formed": ["es.string.is-well-formed"],
  "core-js/features/instance/keys": ["es.array.iterator", "es.object.to-string", "web.dom-collections.iterator"],
  "core-js/features/instance/last-index-of": ["es.array.last-index-of"],
  "core-js/features/instance/map": ["es.array.map"],
  "core-js/features/instance/match-all": [
    "es.object.to-string",
    "es.regexp.exec",
    "es.string.match-all",
    "esnext.string.match-all"
  ],
  "core-js/features/instance/pad-end": ["es.string.pad-end"],
  "core-js/features/instance/pad-start": ["es.string.pad-start"],
  "core-js/features/instance/push": ["es.array.push"],
  "core-js/features/instance/reduce": ["es.array.reduce"],
  "core-js/features/instance/reduce-right": ["es.array.reduce-right"],
  "core-js/features/instance/repeat": ["es.string.repeat"],
  "core-js/features/instance/replace-all": [
    "es.regexp.exec",
    "es.string.replace",
    "es.string.replace-all",
    "esnext.string.replace-all"
  ],
  "core-js/features/instance/reverse": ["es.array.reverse"],
  "core-js/features/instance/slice": ["es.array.slice"],
  "core-js/features/instance/some": ["es.array.some"],
  "core-js/features/instance/sort": ["es.array.sort"],
  "core-js/features/instance/splice": ["es.array.splice"],
  "core-js/features/instance/starts-with": ["es.string.starts-with"],
  "core-js/features/instance/to-reversed": ["es.array.to-reversed", "esnext.array.to-reversed"],
  "core-js/features/instance/to-sorted": ["es.array.sort", "es.array.to-sorted", "esnext.array.to-sorted"],
  "core-js/features/instance/to-spliced": ["es.array.to-spliced", "esnext.array.to-spliced"],
  "core-js/features/instance/to-well-formed": ["es.string.to-well-formed"],
  "core-js/features/instance/trim": ["es.string.trim"],
  "core-js/features/instance/trim-end": ["es.string.trim-end"],
  "core-js/features/instance/trim-left": ["es.string.trim-start"],
  "core-js/features/instance/trim-right": ["es.string.trim-end"],
  "core-js/features/instance/trim-start": ["es.string.trim-start"],
  "core-js/features/instance/un-this": ["esnext.function.un-this"],
  "core-js/features/instance/unique-by": ["es.map", "esnext.array.unique-by"],
  "core-js/features/instance/unshift": ["es.array.unshift"],
  "core-js/features/instance/values": ["es.array.iterator", "es.object.to-string", "web.dom-collections.iterator"],
  "core-js/features/instance/with": ["es.array.with", "esnext.array.with"],
  "core-js/features/is-iterable": ["es.array.iterator", "es.string.iterator", "web.dom-collections.iterator"],
  "core-js/features/iterator": [
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.dispose",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.indexed",
    "esnext.iterator.map",
    "esnext.iterator.range",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.iterator.to-async",
    "web.dom-collections.iterator"
  ],
  "core-js/features/iterator/as-indexed-pairs": [
    "es.object.to-string",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs"
  ],
  "core-js/features/iterator/dispose": ["esnext.iterator.dispose"],
  "core-js/features/iterator/drop": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.drop"],
  "core-js/features/iterator/every": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.every"],
  "core-js/features/iterator/filter": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.filter"],
  "core-js/features/iterator/find": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.find"],
  "core-js/features/iterator/flat-map": [
    "es.object.to-string",
    "esnext.iterator.constructor",
    "esnext.iterator.flat-map"
  ],
  "core-js/features/iterator/for-each": [
    "es.object.to-string",
    "esnext.iterator.constructor",
    "esnext.iterator.for-each"
  ],
  "core-js/features/iterator/from": [
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.dispose",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.iterator.to-async",
    "web.dom-collections.iterator"
  ],
  "core-js/features/iterator/indexed": [
    "es.object.to-string",
    "esnext.iterator.constructor",
    "esnext.iterator.indexed"
  ],
  "core-js/features/iterator/map": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.map"],
  "core-js/features/iterator/range": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.range"],
  "core-js/features/iterator/reduce": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.reduce"],
  "core-js/features/iterator/some": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.some"],
  "core-js/features/iterator/take": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.take"],
  "core-js/features/iterator/to-array": [
    "es.object.to-string",
    "esnext.iterator.constructor",
    "esnext.iterator.to-array"
  ],
  "core-js/features/iterator/to-async": [
    "es.object.to-string",
    "es.promise",
    "esnext.iterator.constructor",
    "esnext.iterator.to-async"
  ],
  "core-js/features/json": [
    "es.json.stringify",
    "es.json.to-string-tag",
    "es.object.create",
    "es.object.freeze",
    "es.object.keys",
    "esnext.json.is-raw-json",
    "esnext.json.parse",
    "esnext.json.raw-json"
  ],
  "core-js/features/json/is-raw-json": ["esnext.json.is-raw-json"],
  "core-js/features/json/parse": ["es.object.keys", "esnext.json.parse"],
  "core-js/features/json/raw-json": ["es.object.create", "es.object.freeze", "esnext.json.raw-json"],
  "core-js/features/json/stringify": ["es.json.stringify"],
  "core-js/features/json/to-string-tag": ["es.json.to-string-tag"],
  "core-js/features/map": [
    "es.array.iterator",
    "es.map",
    "es.object.to-string",
    "es.string.iterator",
    "esnext.map.delete-all",
    "esnext.map.emplace",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "web.dom-collections.iterator"
  ],
  "core-js/features/map/delete-all": ["es.map", "esnext.map.delete-all"],
  "core-js/features/map/emplace": ["es.map", "esnext.map.emplace"],
  "core-js/features/map/every": ["es.map", "esnext.map.every"],
  "core-js/features/map/filter": ["es.map", "esnext.map.filter"],
  "core-js/features/map/find": ["es.map", "esnext.map.find"],
  "core-js/features/map/find-key": ["es.map", "esnext.map.find-key"],
  "core-js/features/map/from": [
    "es.array.iterator",
    "es.map",
    "es.string.iterator",
    "esnext.map.from",
    "web.dom-collections.iterator"
  ],
  "core-js/features/map/group-by": ["es.map", "esnext.map.group-by"],
  "core-js/features/map/includes": ["es.map", "esnext.map.includes"],
  "core-js/features/map/key-by": ["es.map", "esnext.map.key-by"],
  "core-js/features/map/key-of": ["es.map", "esnext.map.key-of"],
  "core-js/features/map/map-keys": ["es.map", "esnext.map.map-keys"],
  "core-js/features/map/map-values": ["es.map", "esnext.map.map-values"],
  "core-js/features/map/merge": ["es.map", "esnext.map.merge"],
  "core-js/features/map/of": ["es.array.iterator", "es.map", "esnext.map.of"],
  "core-js/features/map/reduce": ["es.map", "esnext.map.reduce"],
  "core-js/features/map/some": ["es.map", "esnext.map.some"],
  "core-js/features/map/update": ["es.map", "esnext.map.update"],
  "core-js/features/map/update-or-insert": ["es.map", "esnext.map.update-or-insert"],
  "core-js/features/map/upsert": ["es.map", "esnext.map.upsert"],
  "core-js/features/math": [
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh"
  ],
  "core-js/features/math/acosh": ["es.math.acosh"],
  "core-js/features/math/asinh": ["es.math.asinh"],
  "core-js/features/math/atanh": ["es.math.atanh"],
  "core-js/features/math/cbrt": ["es.math.cbrt"],
  "core-js/features/math/clamp": ["esnext.math.clamp"],
  "core-js/features/math/clz32": ["es.math.clz32"],
  "core-js/features/math/cosh": ["es.math.cosh"],
  "core-js/features/math/deg-per-rad": ["esnext.math.deg-per-rad"],
  "core-js/features/math/degrees": ["esnext.math.degrees"],
  "core-js/features/math/expm1": ["es.math.expm1"],
  "core-js/features/math/fround": ["es.math.fround"],
  "core-js/features/math/fscale": ["esnext.math.fscale"],
  "core-js/features/math/hypot": ["es.math.hypot"],
  "core-js/features/math/iaddh": ["esnext.math.iaddh"],
  "core-js/features/math/imul": ["es.math.imul"],
  "core-js/features/math/imulh": ["esnext.math.imulh"],
  "core-js/features/math/isubh": ["esnext.math.isubh"],
  "core-js/features/math/log10": ["es.math.log10"],
  "core-js/features/math/log1p": ["es.math.log1p"],
  "core-js/features/math/log2": ["es.math.log2"],
  "core-js/features/math/rad-per-deg": ["esnext.math.rad-per-deg"],
  "core-js/features/math/radians": ["esnext.math.radians"],
  "core-js/features/math/scale": ["esnext.math.scale"],
  "core-js/features/math/seeded-prng": ["esnext.math.seeded-prng"],
  "core-js/features/math/sign": ["es.math.sign"],
  "core-js/features/math/signbit": ["esnext.math.signbit"],
  "core-js/features/math/sinh": ["es.math.sinh"],
  "core-js/features/math/tanh": ["es.math.tanh"],
  "core-js/features/math/to-string-tag": ["es.math.to-string-tag"],
  "core-js/features/math/trunc": ["es.math.trunc"],
  "core-js/features/math/umulh": ["esnext.math.umulh"],
  "core-js/features/number": [
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-exponential",
    "es.number.to-fixed",
    "es.number.to-precision",
    "es.object.to-string",
    "esnext.number.from-string",
    "esnext.number.range"
  ],
  "core-js/features/number/constructor": ["es.number.constructor"],
  "core-js/features/number/epsilon": ["es.number.epsilon"],
  "core-js/features/number/from-string": ["esnext.number.from-string"],
  "core-js/features/number/is-finite": ["es.number.is-finite"],
  "core-js/features/number/is-integer": ["es.number.is-integer"],
  "core-js/features/number/is-nan": ["es.number.is-nan"],
  "core-js/features/number/is-safe-integer": ["es.number.is-safe-integer"],
  "core-js/features/number/max-safe-integer": ["es.number.max-safe-integer"],
  "core-js/features/number/min-safe-integer": ["es.number.min-safe-integer"],
  "core-js/features/number/parse-float": ["es.number.parse-float"],
  "core-js/features/number/parse-int": ["es.number.parse-int"],
  "core-js/features/number/range": ["es.object.to-string", "esnext.number.range"],
  "core-js/features/number/to-exponential": ["es.number.to-exponential"],
  "core-js/features/number/to-fixed": ["es.number.to-fixed"],
  "core-js/features/number/to-precision": ["es.number.to-precision"],
  "core-js/features/number/virtual": ["es.number.to-exponential", "es.number.to-fixed", "es.number.to-precision"],
  "core-js/features/number/virtual/to-exponential": ["es.number.to-exponential"],
  "core-js/features/number/virtual/to-fixed": ["es.number.to-fixed"],
  "core-js/features/number/virtual/to-precision": ["es.number.to-precision"],
  "core-js/features/object": [
    "es.symbol",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.has-own",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.proto",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.reflect.to-string-tag",
    "esnext.object.has-own",
    "esnext.object.iterate-entries",
    "esnext.object.iterate-keys",
    "esnext.object.iterate-values",
    "esnext.object.group-by",
    "web.dom-collections.iterator"
  ],
  "core-js/features/object/assign": ["es.object.assign"],
  "core-js/features/object/create": ["es.object.create"],
  "core-js/features/object/define-getter": ["es.object.define-getter"],
  "core-js/features/object/define-properties": ["es.object.define-properties"],
  "core-js/features/object/define-property": ["es.object.define-property"],
  "core-js/features/object/define-setter": ["es.object.define-setter"],
  "core-js/features/object/entries": ["es.object.entries"],
  "core-js/features/object/freeze": ["es.object.freeze"],
  "core-js/features/object/from-entries": [
    "es.array.iterator",
    "es.object.from-entries",
    "web.dom-collections.iterator"
  ],
  "core-js/features/object/get-own-property-descriptor": ["es.object.get-own-property-descriptor"],
  "core-js/features/object/get-own-property-descriptors": ["es.object.get-own-property-descriptors"],
  "core-js/features/object/get-own-property-names": ["es.object.get-own-property-names"],
  "core-js/features/object/get-own-property-symbols": ["es.symbol"],
  "core-js/features/object/get-prototype-of": ["es.object.get-prototype-of"],
  "core-js/features/object/group-by": ["es.object.create", "esnext.object.group-by"],
  "core-js/features/object/has-own": ["es.object.has-own", "esnext.object.has-own"],
  "core-js/features/object/is": ["es.object.is"],
  "core-js/features/object/is-extensible": ["es.object.is-extensible"],
  "core-js/features/object/is-frozen": ["es.object.is-frozen"],
  "core-js/features/object/is-sealed": ["es.object.is-sealed"],
  "core-js/features/object/iterate-entries": ["esnext.object.iterate-entries"],
  "core-js/features/object/iterate-keys": ["esnext.object.iterate-keys"],
  "core-js/features/object/iterate-values": ["esnext.object.iterate-values"],
  "core-js/features/object/keys": ["es.object.keys"],
  "core-js/features/object/lookup-getter": ["es.object.lookup-getter"],
  "core-js/features/object/lookup-setter": ["es.object.lookup-setter"],
  "core-js/features/object/prevent-extensions": ["es.object.prevent-extensions"],
  "core-js/features/object/proto": ["es.object.proto"],
  "core-js/features/object/seal": ["es.object.seal"],
  "core-js/features/object/set-prototype-of": ["es.object.set-prototype-of"],
  "core-js/features/object/to-string": [
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string",
    "es.reflect.to-string-tag"
  ],
  "core-js/features/object/values": ["es.object.values"],
  "core-js/features/observable": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.observable",
    "esnext.symbol.observable",
    "web.dom-collections.iterator"
  ],
  "core-js/features/parse-float": ["es.parse-float"],
  "core-js/features/parse-int": ["es.parse-int"],
  "core-js/features/promise": [
    "es.aggregate-error",
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.any",
    "es.promise.finally",
    "es.string.iterator",
    "esnext.aggregate-error",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.promise.with-resolvers",
    "web.dom-collections.iterator"
  ],
  "core-js/features/promise/all-settled": [
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.promise.all-settled",
    "es.string.iterator",
    "esnext.promise.all-settled",
    "web.dom-collections.iterator"
  ],
  "core-js/features/promise/any": [
    "es.aggregate-error",
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.promise.any",
    "es.string.iterator",
    "esnext.aggregate-error",
    "esnext.promise.any",
    "web.dom-collections.iterator"
  ],
  "core-js/features/promise/finally": ["es.object.to-string", "es.promise", "es.promise.finally"],
  "core-js/features/promise/try": ["es.promise", "esnext.promise.try"],
  "core-js/features/promise/with-resolvers": ["es.promise", "esnext.promise.with-resolvers"],
  "core-js/features/queue-microtask": ["web.queue-microtask"],
  "core-js/features/reflect": [
    "es.object.to-string",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.reflect.to-string-tag",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata"
  ],
  "core-js/features/reflect/apply": ["es.reflect.apply"],
  "core-js/features/reflect/construct": ["es.reflect.construct"],
  "core-js/features/reflect/define-metadata": ["esnext.reflect.define-metadata"],
  "core-js/features/reflect/define-property": ["es.reflect.define-property"],
  "core-js/features/reflect/delete-metadata": ["esnext.reflect.delete-metadata"],
  "core-js/features/reflect/delete-property": ["es.reflect.delete-property"],
  "core-js/features/reflect/get": ["es.reflect.get"],
  "core-js/features/reflect/get-metadata": ["esnext.reflect.get-metadata"],
  "core-js/features/reflect/get-metadata-keys": ["esnext.reflect.get-metadata-keys"],
  "core-js/features/reflect/get-own-metadata": ["esnext.reflect.get-own-metadata"],
  "core-js/features/reflect/get-own-metadata-keys": ["esnext.reflect.get-own-metadata-keys"],
  "core-js/features/reflect/get-own-property-descriptor": ["es.reflect.get-own-property-descriptor"],
  "core-js/features/reflect/get-prototype-of": ["es.reflect.get-prototype-of"],
  "core-js/features/reflect/has": ["es.reflect.has"],
  "core-js/features/reflect/has-metadata": ["esnext.reflect.has-metadata"],
  "core-js/features/reflect/has-own-metadata": ["esnext.reflect.has-own-metadata"],
  "core-js/features/reflect/is-extensible": ["es.reflect.is-extensible"],
  "core-js/features/reflect/metadata": ["esnext.reflect.metadata"],
  "core-js/features/reflect/own-keys": ["es.reflect.own-keys"],
  "core-js/features/reflect/prevent-extensions": ["es.reflect.prevent-extensions"],
  "core-js/features/reflect/set": ["es.reflect.set"],
  "core-js/features/reflect/set-prototype-of": ["es.reflect.set-prototype-of"],
  "core-js/features/reflect/to-string-tag": ["es.reflect.to-string-tag"],
  "core-js/features/regexp": [
    "es.regexp.constructor",
    "es.regexp.dot-all",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.sticky",
    "es.regexp.test",
    "es.regexp.to-string",
    "es.string.match",
    "es.string.replace",
    "es.string.search",
    "es.string.split"
  ],
  "core-js/features/regexp/constructor": [
    "es.regexp.constructor",
    "es.regexp.dot-all",
    "es.regexp.exec",
    "es.regexp.sticky"
  ],
  "core-js/features/regexp/dot-all": ["es.regexp.constructor", "es.regexp.dot-all", "es.regexp.exec"],
  "core-js/features/regexp/flags": ["es.regexp.flags"],
  "core-js/features/regexp/match": ["es.regexp.exec", "es.string.match"],
  "core-js/features/regexp/replace": ["es.regexp.exec", "es.string.replace"],
  "core-js/features/regexp/search": ["es.regexp.exec", "es.string.search"],
  "core-js/features/regexp/split": ["es.regexp.exec", "es.string.split"],
  "core-js/features/regexp/sticky": ["es.regexp.constructor", "es.regexp.exec", "es.regexp.sticky"],
  "core-js/features/regexp/test": ["es.regexp.exec", "es.regexp.test"],
  "core-js/features/regexp/to-string": ["es.regexp.to-string"],
  "core-js/features/self": ["web.self"],
  "core-js/features/set": [
    "es.array.iterator",
    "es.object.to-string",
    "es.set",
    "es.string.iterator",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference.v2",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection.v2",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from.v2",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of.v2",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of.v2",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference.v2",
    "esnext.set.symmetric-difference",
    "esnext.set.union.v2",
    "esnext.set.union",
    "web.dom-collections.iterator"
  ],
  "core-js/features/set-immediate": ["web.immediate"],
  "core-js/features/set-interval": ["web.timers"],
  "core-js/features/set-timeout": ["web.timers"],
  "core-js/features/set/add-all": ["es.set", "esnext.set.add-all"],
  "core-js/features/set/delete-all": ["es.set", "esnext.set.delete-all"],
  "core-js/features/set/difference": [
    "es.array.iterator",
    "es.set",
    "es.string.iterator",
    "esnext.set.difference.v2",
    "esnext.set.difference",
    "web.dom-collections.iterator"
  ],
  "core-js/features/set/every": ["es.set", "esnext.set.every"],
  "core-js/features/set/filter": ["es.set", "esnext.set.filter"],
  "core-js/features/set/find": ["es.set", "esnext.set.find"],
  "core-js/features/set/from": [
    "es.array.iterator",
    "es.set",
    "es.string.iterator",
    "esnext.set.from",
    "web.dom-collections.iterator"
  ],
  "core-js/features/set/intersection": [
    "es.array.iterator",
    "es.set",
    "es.string.iterator",
    "esnext.set.intersection.v2",
    "esnext.set.intersection",
    "web.dom-collections.iterator"
  ],
  "core-js/features/set/is-disjoint-from": [
    "es.array.iterator",
    "es.set",
    "es.string.iterator",
    "esnext.set.is-disjoint-from.v2",
    "esnext.set.is-disjoint-from",
    "web.dom-collections.iterator"
  ],
  "core-js/features/set/is-subset-of": [
    "es.array.iterator",
    "es.set",
    "es.string.iterator",
    "esnext.set.is-subset-of.v2",
    "esnext.set.is-subset-of",
    "web.dom-collections.iterator"
  ],
  "core-js/features/set/is-superset-of": [
    "es.array.iterator",
    "es.set",
    "es.string.iterator",
    "esnext.set.is-superset-of.v2",
    "esnext.set.is-superset-of",
    "web.dom-collections.iterator"
  ],
  "core-js/features/set/join": ["es.set", "esnext.set.join"],
  "core-js/features/set/map": ["es.set", "esnext.set.map"],
  "core-js/features/set/of": ["es.array.iterator", "es.set", "esnext.set.of"],
  "core-js/features/set/reduce": ["es.set", "esnext.set.reduce"],
  "core-js/features/set/some": ["es.set", "esnext.set.some"],
  "core-js/features/set/symmetric-difference": [
    "es.array.iterator",
    "es.set",
    "es.string.iterator",
    "esnext.set.symmetric-difference.v2",
    "esnext.set.symmetric-difference",
    "web.dom-collections.iterator"
  ],
  "core-js/features/set/union": [
    "es.array.iterator",
    "es.set",
    "es.string.iterator",
    "esnext.set.union.v2",
    "esnext.set.union",
    "web.dom-collections.iterator"
  ],
  "core-js/features/string": [
    "es.object.to-string",
    "es.regexp.exec",
    "es.string.at-alternative",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.is-well-formed",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.replace-all",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.substr",
    "es.string.to-well-formed",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "es.weak-map",
    "esnext.string.at",
    "esnext.string.cooked",
    "esnext.string.code-points",
    "esnext.string.dedent",
    "esnext.string.is-well-formed",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.string.to-well-formed"
  ],
  "core-js/features/string/anchor": ["es.string.anchor"],
  "core-js/features/string/at": ["es.string.at-alternative", "esnext.string.at"],
  "core-js/features/string/big": ["es.string.big"],
  "core-js/features/string/blink": ["es.string.blink"],
  "core-js/features/string/bold": ["es.string.bold"],
  "core-js/features/string/code-point-at": ["es.string.code-point-at"],
  "core-js/features/string/code-points": ["es.object.to-string", "esnext.string.code-points"],
  "core-js/features/string/cooked": ["esnext.string.cooked"],
  "core-js/features/string/dedent": ["es.string.from-code-point", "es.weak-map", "esnext.string.dedent"],
  "core-js/features/string/ends-with": ["es.string.ends-with"],
  "core-js/features/string/fixed": ["es.string.fixed"],
  "core-js/features/string/fontcolor": ["es.string.fontcolor"],
  "core-js/features/string/fontsize": ["es.string.fontsize"],
  "core-js/features/string/from-code-point": ["es.string.from-code-point"],
  "core-js/features/string/includes": ["es.string.includes"],
  "core-js/features/string/is-well-formed": ["es.string.is-well-formed", "esnext.string.is-well-formed"],
  "core-js/features/string/italics": ["es.string.italics"],
  "core-js/features/string/iterator": ["es.object.to-string", "es.string.iterator"],
  "core-js/features/string/link": ["es.string.link"],
  "core-js/features/string/match": ["es.regexp.exec", "es.string.match"],
  "core-js/features/string/match-all": [
    "es.object.to-string",
    "es.regexp.exec",
    "es.string.match-all",
    "esnext.string.match-all"
  ],
  "core-js/features/string/pad-end": ["es.string.pad-end"],
  "core-js/features/string/pad-start": ["es.string.pad-start"],
  "core-js/features/string/raw": ["es.string.raw"],
  "core-js/features/string/repeat": ["es.string.repeat"],
  "core-js/features/string/replace": ["es.regexp.exec", "es.string.replace"],
  "core-js/features/string/replace-all": [
    "es.regexp.exec",
    "es.string.replace",
    "es.string.replace-all",
    "esnext.string.replace-all"
  ],
  "core-js/features/string/search": ["es.regexp.exec", "es.string.search"],
  "core-js/features/string/small": ["es.string.small"],
  "core-js/features/string/split": ["es.regexp.exec", "es.string.split"],
  "core-js/features/string/starts-with": ["es.string.starts-with"],
  "core-js/features/string/strike": ["es.string.strike"],
  "core-js/features/string/sub": ["es.string.sub"],
  "core-js/features/string/substr": ["es.string.substr"],
  "core-js/features/string/sup": ["es.string.sup"],
  "core-js/features/string/to-well-formed": ["es.string.to-well-formed", "esnext.string.to-well-formed"],
  "core-js/features/string/trim": ["es.string.trim"],
  "core-js/features/string/trim-end": ["es.string.trim-end"],
  "core-js/features/string/trim-left": ["es.string.trim-start"],
  "core-js/features/string/trim-right": ["es.string.trim-end"],
  "core-js/features/string/trim-start": ["es.string.trim-start"],
  "core-js/features/string/virtual": [
    "es.object.to-string",
    "es.regexp.exec",
    "es.string.at-alternative",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.repeat",
    "es.string.replace",
    "es.string.replace-all",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.substr",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "esnext.string.at",
    "esnext.string.code-points",
    "esnext.string.is-well-formed",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.string.to-well-formed"
  ],
  "core-js/features/string/virtual/anchor": ["es.string.anchor"],
  "core-js/features/string/virtual/at": ["es.string.at-alternative", "esnext.string.at"],
  "core-js/features/string/virtual/big": ["es.string.big"],
  "core-js/features/string/virtual/blink": ["es.string.blink"],
  "core-js/features/string/virtual/bold": ["es.string.bold"],
  "core-js/features/string/virtual/code-point-at": ["es.string.code-point-at"],
  "core-js/features/string/virtual/code-points": ["es.object.to-string", "esnext.string.code-points"],
  "core-js/features/string/virtual/ends-with": ["es.string.ends-with"],
  "core-js/features/string/virtual/fixed": ["es.string.fixed"],
  "core-js/features/string/virtual/fontcolor": ["es.string.fontcolor"],
  "core-js/features/string/virtual/fontsize": ["es.string.fontsize"],
  "core-js/features/string/virtual/includes": ["es.string.includes"],
  "core-js/features/string/virtual/is-well-formed": ["es.string.is-well-formed", "esnext.string.is-well-formed"],
  "core-js/features/string/virtual/italics": ["es.string.italics"],
  "core-js/features/string/virtual/iterator": ["es.object.to-string", "es.string.iterator"],
  "core-js/features/string/virtual/link": ["es.string.link"],
  "core-js/features/string/virtual/match-all": [
    "es.object.to-string",
    "es.regexp.exec",
    "es.string.match-all",
    "esnext.string.match-all"
  ],
  "core-js/features/string/virtual/pad-end": ["es.string.pad-end"],
  "core-js/features/string/virtual/pad-start": ["es.string.pad-start"],
  "core-js/features/string/virtual/repeat": ["es.string.repeat"],
  "core-js/features/string/virtual/replace-all": [
    "es.regexp.exec",
    "es.string.replace",
    "es.string.replace-all",
    "esnext.string.replace-all"
  ],
  "core-js/features/string/virtual/small": ["es.string.small"],
  "core-js/features/string/virtual/starts-with": ["es.string.starts-with"],
  "core-js/features/string/virtual/strike": ["es.string.strike"],
  "core-js/features/string/virtual/sub": ["es.string.sub"],
  "core-js/features/string/virtual/substr": ["es.string.substr"],
  "core-js/features/string/virtual/sup": ["es.string.sup"],
  "core-js/features/string/virtual/to-well-formed": ["es.string.to-well-formed", "esnext.string.to-well-formed"],
  "core-js/features/string/virtual/trim": ["es.string.trim"],
  "core-js/features/string/virtual/trim-end": ["es.string.trim-end"],
  "core-js/features/string/virtual/trim-left": ["es.string.trim-start"],
  "core-js/features/string/virtual/trim-right": ["es.string.trim-end"],
  "core-js/features/string/virtual/trim-start": ["es.string.trim-start"],
  "core-js/features/structured-clone": [
    "es.error.to-string",
    "es.array.iterator",
    "es.map",
    "es.object.keys",
    "es.object.to-string",
    "es.set",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag",
    "web.structured-clone"
  ],
  "core-js/features/suppressed-error": ["es.error.cause", "es.error.to-string", "esnext.suppressed-error.constructor"],
  "core-js/features/symbol": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string",
    "es.reflect.to-string-tag",
    "esnext.function.metadata",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.is-registered-symbol",
    "esnext.symbol.is-registered",
    "esnext.symbol.is-well-known-symbol",
    "esnext.symbol.is-well-known",
    "esnext.symbol.matcher",
    "esnext.symbol.metadata",
    "esnext.symbol.metadata-key",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "web.dom-collections.iterator"
  ],
  "core-js/features/symbol/async-dispose": ["esnext.symbol.async-dispose"],
  "core-js/features/symbol/async-iterator": ["es.symbol.async-iterator"],
  "core-js/features/symbol/description": ["es.symbol.description"],
  "core-js/features/symbol/dispose": ["esnext.symbol.dispose"],
  "core-js/features/symbol/for": ["es.symbol"],
  "core-js/features/symbol/has-instance": ["es.symbol.has-instance", "es.function.has-instance"],
  "core-js/features/symbol/is-concat-spreadable": ["es.symbol.is-concat-spreadable", "es.array.concat"],
  "core-js/features/symbol/is-registered": ["es.symbol", "esnext.symbol.is-registered"],
  "core-js/features/symbol/is-registered-symbol": ["es.symbol", "esnext.symbol.is-registered-symbol"],
  "core-js/features/symbol/is-well-known": ["es.symbol", "esnext.symbol.is-well-known"],
  "core-js/features/symbol/is-well-known-symbol": ["es.symbol", "esnext.symbol.is-well-known-symbol"],
  "core-js/features/symbol/iterator": [
    "es.symbol.iterator",
    "es.array.iterator",
    "es.object.to-string",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/features/symbol/key-for": ["es.symbol"],
  "core-js/features/symbol/match": ["es.symbol.match", "es.regexp.exec", "es.string.match"],
  "core-js/features/symbol/match-all": [
    "es.symbol.match-all",
    "es.object.to-string",
    "es.regexp.exec",
    "es.string.match-all"
  ],
  "core-js/features/symbol/matcher": ["esnext.symbol.matcher"],
  "core-js/features/symbol/metadata": ["esnext.function.metadata", "esnext.symbol.metadata"],
  "core-js/features/symbol/metadata-key": ["esnext.symbol.metadata-key"],
  "core-js/features/symbol/observable": ["esnext.symbol.observable"],
  "core-js/features/symbol/pattern-match": ["esnext.symbol.pattern-match"],
  "core-js/features/symbol/replace": ["es.symbol.replace", "es.regexp.exec", "es.string.replace"],
  "core-js/features/symbol/replace-all": ["esnext.symbol.replace-all"],
  "core-js/features/symbol/search": ["es.symbol.search", "es.regexp.exec", "es.string.search"],
  "core-js/features/symbol/species": ["es.symbol.species"],
  "core-js/features/symbol/split": ["es.symbol.split", "es.regexp.exec", "es.string.split"],
  "core-js/features/symbol/to-primitive": ["es.symbol.to-primitive", "es.date.to-primitive"],
  "core-js/features/symbol/to-string-tag": [
    "es.symbol.to-string-tag",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string",
    "es.reflect.to-string-tag"
  ],
  "core-js/features/symbol/unscopables": ["es.symbol.unscopables"],
  "core-js/features/typed-array": [
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with"
  ],
  "core-js/features/typed-array/at": ["es.typed-array.at", "esnext.typed-array.at"],
  "core-js/features/typed-array/copy-within": ["es.typed-array.copy-within"],
  "core-js/features/typed-array/entries": ["es.object.to-string", "es.typed-array.iterator"],
  "core-js/features/typed-array/every": ["es.typed-array.every"],
  "core-js/features/typed-array/fill": ["es.typed-array.fill"],
  "core-js/features/typed-array/filter": ["es.typed-array.filter"],
  "core-js/features/typed-array/filter-out": ["esnext.typed-array.filter-out"],
  "core-js/features/typed-array/filter-reject": ["esnext.typed-array.filter-reject"],
  "core-js/features/typed-array/find": ["es.typed-array.find"],
  "core-js/features/typed-array/find-index": ["es.typed-array.find-index"],
  "core-js/features/typed-array/find-last": ["es.typed-array.find-last", "esnext.typed-array.find-last"],
  "core-js/features/typed-array/find-last-index": [
    "es.typed-array.find-last-index",
    "esnext.typed-array.find-last-index"
  ],
  "core-js/features/typed-array/float32-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "es.typed-array.float32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with"
  ],
  "core-js/features/typed-array/float64-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "es.typed-array.float64-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with"
  ],
  "core-js/features/typed-array/for-each": ["es.typed-array.for-each"],
  "core-js/features/typed-array/from": ["es.typed-array.from"],
  "core-js/features/typed-array/from-async": ["esnext.typed-array.from-async"],
  "core-js/features/typed-array/group-by": ["esnext.typed-array.group-by"],
  "core-js/features/typed-array/includes": ["es.typed-array.includes"],
  "core-js/features/typed-array/index-of": ["es.typed-array.index-of"],
  "core-js/features/typed-array/int16-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "es.typed-array.int16-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with"
  ],
  "core-js/features/typed-array/int32-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "es.typed-array.int32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with"
  ],
  "core-js/features/typed-array/int8-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "es.typed-array.int8-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with"
  ],
  "core-js/features/typed-array/iterator": ["es.object.to-string", "es.typed-array.iterator"],
  "core-js/features/typed-array/join": ["es.typed-array.join"],
  "core-js/features/typed-array/keys": ["es.object.to-string", "es.typed-array.iterator"],
  "core-js/features/typed-array/last-index-of": ["es.typed-array.last-index-of"],
  "core-js/features/typed-array/map": ["es.typed-array.map"],
  "core-js/features/typed-array/methods": [
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with"
  ],
  "core-js/features/typed-array/of": ["es.typed-array.of"],
  "core-js/features/typed-array/reduce": ["es.typed-array.reduce"],
  "core-js/features/typed-array/reduce-right": ["es.typed-array.reduce-right"],
  "core-js/features/typed-array/reverse": ["es.typed-array.reverse"],
  "core-js/features/typed-array/set": ["es.typed-array.set"],
  "core-js/features/typed-array/slice": ["es.typed-array.slice"],
  "core-js/features/typed-array/some": ["es.typed-array.some"],
  "core-js/features/typed-array/sort": ["es.typed-array.sort"],
  "core-js/features/typed-array/subarray": ["es.typed-array.subarray"],
  "core-js/features/typed-array/to-locale-string": ["es.typed-array.to-locale-string"],
  "core-js/features/typed-array/to-reversed": ["es.typed-array.to-reversed", "esnext.typed-array.to-reversed"],
  "core-js/features/typed-array/to-sorted": [
    "es.typed-array.sort",
    "es.typed-array.to-sorted",
    "esnext.typed-array.to-sorted"
  ],
  "core-js/features/typed-array/to-spliced": ["esnext.typed-array.to-spliced"],
  "core-js/features/typed-array/to-string": ["es.typed-array.to-string"],
  "core-js/features/typed-array/uint16-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "es.typed-array.uint16-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with"
  ],
  "core-js/features/typed-array/uint32-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "es.typed-array.uint32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with"
  ],
  "core-js/features/typed-array/uint8-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "es.typed-array.uint8-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with"
  ],
  "core-js/features/typed-array/uint8-clamped-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with"
  ],
  "core-js/features/typed-array/unique-by": ["es.map", "esnext.typed-array.unique-by"],
  "core-js/features/typed-array/values": ["es.object.to-string", "es.typed-array.iterator"],
  "core-js/features/typed-array/with": ["es.typed-array.with", "esnext.typed-array.with"],
  "core-js/features/unescape": ["es.unescape"],
  "core-js/features/url": [
    "web.url",
    "web.url.can-parse",
    "web.url.to-json",
    "web.url-search-params",
    "web.url-search-params.delete",
    "web.url-search-params.has",
    "web.url-search-params.size"
  ],
  "core-js/features/url-search-params": [
    "web.dom-collections.iterator",
    "web.url-search-params",
    "web.url-search-params.delete",
    "web.url-search-params.has",
    "web.url-search-params.size"
  ],
  "core-js/features/url/can-parse": ["web.url", "web.url.can-parse"],
  "core-js/features/url/to-json": ["web.url.to-json"],
  "core-js/features/weak-map": [
    "es.array.iterator",
    "es.object.to-string",
    "es.string.iterator",
    "es.weak-map",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.emplace",
    "esnext.weak-map.upsert",
    "web.dom-collections.iterator"
  ],
  "core-js/features/weak-map/delete-all": ["es.weak-map", "esnext.weak-map.delete-all"],
  "core-js/features/weak-map/emplace": ["es.weak-map", "esnext.weak-map.emplace"],
  "core-js/features/weak-map/from": [
    "es.array.iterator",
    "es.string.iterator",
    "es.weak-map",
    "esnext.weak-map.from",
    "web.dom-collections.iterator"
  ],
  "core-js/features/weak-map/of": ["es.array.iterator", "es.weak-map", "esnext.weak-map.of"],
  "core-js/features/weak-map/upsert": ["es.weak-map", "esnext.weak-map.upsert"],
  "core-js/features/weak-set": [
    "es.array.iterator",
    "es.object.to-string",
    "es.string.iterator",
    "es.weak-set",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.dom-collections.iterator"
  ],
  "core-js/features/weak-set/add-all": ["es.weak-set", "esnext.weak-set.add-all"],
  "core-js/features/weak-set/delete-all": ["es.weak-set", "esnext.weak-set.delete-all"],
  "core-js/features/weak-set/from": [
    "es.array.iterator",
    "es.string.iterator",
    "es.weak-set",
    "esnext.weak-set.from",
    "web.dom-collections.iterator"
  ],
  "core-js/features/weak-set/of": ["es.array.iterator", "es.weak-set", "esnext.weak-set.of"],
  "core-js/full": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.error.cause",
    "es.error.to-string",
    "es.aggregate-error",
    "es.aggregate-error.cause",
    "es.array.at",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.find-last",
    "es.array.find-last-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.push",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.to-reversed",
    "es.array.to-sorted",
    "es.array.to-spliced",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array.unshift",
    "es.array.with",
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.data-view",
    "es.date.get-year",
    "es.date.now",
    "es.date.set-year",
    "es.date.to-gmt-string",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string",
    "es.escape",
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name",
    "es.global-this",
    "es.json.stringify",
    "es.json.to-string-tag",
    "es.map",
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc",
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-exponential",
    "es.number.to-fixed",
    "es.number.to-precision",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.has-own",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.proto",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.parse-float",
    "es.parse-int",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.any",
    "es.promise.finally",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.reflect.to-string-tag",
    "es.regexp.constructor",
    "es.regexp.dot-all",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.sticky",
    "es.regexp.test",
    "es.regexp.to-string",
    "es.set",
    "es.string.at-alternative",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.is-well-formed",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.replace-all",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.substr",
    "es.string.to-well-formed",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "es.unescape",
    "es.weak-map",
    "es.weak-set",
    "esnext.aggregate-error",
    "esnext.suppressed-error.constructor",
    "esnext.array.from-async",
    "esnext.array.at",
    "esnext.array.filter-out",
    "esnext.array.filter-reject",
    "esnext.array.find-last",
    "esnext.array.find-last-index",
    "esnext.array.group",
    "esnext.array.group-by",
    "esnext.array.group-by-to-map",
    "esnext.array.group-to-map",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.array.to-reversed",
    "esnext.array.to-sorted",
    "esnext.array.to-spliced",
    "esnext.array.unique-by",
    "esnext.array.with",
    "esnext.array-buffer.detached",
    "esnext.array-buffer.transfer",
    "esnext.array-buffer.transfer-to-fixed-length",
    "esnext.async-disposable-stack.constructor",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.async-dispose",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.indexed",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.bigint.range",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.disposable-stack.constructor",
    "esnext.function.demethodize",
    "esnext.function.is-callable",
    "esnext.function.is-constructor",
    "esnext.function.metadata",
    "esnext.function.un-this",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.dispose",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.indexed",
    "esnext.iterator.map",
    "esnext.iterator.range",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.iterator.to-async",
    "esnext.json.is-raw-json",
    "esnext.json.parse",
    "esnext.json.raw-json",
    "esnext.map.delete-all",
    "esnext.map.emplace",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.number.range",
    "esnext.object.has-own",
    "esnext.object.iterate-entries",
    "esnext.object.iterate-keys",
    "esnext.object.iterate-values",
    "esnext.object.group-by",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.promise.with-resolvers",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference.v2",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection.v2",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from.v2",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of.v2",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of.v2",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference.v2",
    "esnext.set.symmetric-difference",
    "esnext.set.union.v2",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.cooked",
    "esnext.string.code-points",
    "esnext.string.dedent",
    "esnext.string.is-well-formed",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.string.to-well-formed",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.is-registered-symbol",
    "esnext.symbol.is-registered",
    "esnext.symbol.is-well-known-symbol",
    "esnext.symbol.is-well-known",
    "esnext.symbol.matcher",
    "esnext.symbol.metadata",
    "esnext.symbol.metadata-key",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.emplace",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.atob",
    "web.btoa",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag",
    "web.immediate",
    "web.queue-microtask",
    "web.self",
    "web.structured-clone",
    "web.timers",
    "web.url",
    "web.url.can-parse",
    "web.url.to-json",
    "web.url-search-params",
    "web.url-search-params.delete",
    "web.url-search-params.has",
    "web.url-search-params.size"
  ],
  "core-js/full/aggregate-error": [
    "es.error.cause",
    "es.aggregate-error",
    "es.aggregate-error.cause",
    "es.array.iterator",
    "es.string.iterator",
    "esnext.aggregate-error",
    "web.dom-collections.iterator"
  ],
  "core-js/full/array": [
    "es.array.at",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.find-last",
    "es.array.find-last-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.push",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.to-reversed",
    "es.array.to-sorted",
    "es.array.to-spliced",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array.unshift",
    "es.array.with",
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.array.from-async",
    "esnext.array.at",
    "esnext.array.filter-out",
    "esnext.array.filter-reject",
    "esnext.array.find-last",
    "esnext.array.find-last-index",
    "esnext.array.group",
    "esnext.array.group-by",
    "esnext.array.group-by-to-map",
    "esnext.array.group-to-map",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.array.to-reversed",
    "esnext.array.to-sorted",
    "esnext.array.to-spliced",
    "esnext.array.unique-by",
    "esnext.array.with"
  ],
  "core-js/full/array-buffer": [
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.object.to-string",
    "esnext.array-buffer.detached",
    "esnext.array-buffer.transfer",
    "esnext.array-buffer.transfer-to-fixed-length"
  ],
  "core-js/full/array-buffer/constructor": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "esnext.array-buffer.detached",
    "esnext.array-buffer.transfer",
    "esnext.array-buffer.transfer-to-fixed-length"
  ],
  "core-js/full/array-buffer/detached": [
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.object.to-string",
    "esnext.array-buffer.detached"
  ],
  "core-js/full/array-buffer/is-view": ["es.array-buffer.is-view"],
  "core-js/full/array-buffer/slice": ["es.array-buffer.slice"],
  "core-js/full/array-buffer/transfer": [
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.object.to-string",
    "esnext.array-buffer.transfer"
  ],
  "core-js/full/array-buffer/transfer-to-fixed-length": [
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.object.to-string",
    "esnext.array-buffer.transfer-to-fixed-length"
  ],
  "core-js/full/array/at": ["es.array.at", "esnext.array.at"],
  "core-js/full/array/concat": ["es.array.concat"],
  "core-js/full/array/copy-within": ["es.array.copy-within"],
  "core-js/full/array/entries": ["es.array.iterator", "es.object.to-string"],
  "core-js/full/array/every": ["es.array.every"],
  "core-js/full/array/fill": ["es.array.fill"],
  "core-js/full/array/filter": ["es.array.filter"],
  "core-js/full/array/filter-out": ["esnext.array.filter-out"],
  "core-js/full/array/filter-reject": ["esnext.array.filter-reject"],
  "core-js/full/array/find": ["es.array.find"],
  "core-js/full/array/find-index": ["es.array.find-index"],
  "core-js/full/array/find-last": ["es.array.find-last", "esnext.array.find-last"],
  "core-js/full/array/find-last-index": ["es.array.find-last-index", "esnext.array.find-last-index"],
  "core-js/full/array/flat": ["es.array.flat", "es.array.unscopables.flat"],
  "core-js/full/array/flat-map": ["es.array.flat-map", "es.array.unscopables.flat-map"],
  "core-js/full/array/for-each": ["es.array.for-each"],
  "core-js/full/array/from": ["es.array.from", "es.string.iterator"],
  "core-js/full/array/from-async": [
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.array.from-async"
  ],
  "core-js/full/array/group": ["esnext.array.group"],
  "core-js/full/array/group-by": ["esnext.array.group-by"],
  "core-js/full/array/group-by-to-map": ["es.map", "es.object.to-string", "esnext.array.group-by-to-map"],
  "core-js/full/array/group-to-map": ["es.map", "es.object.to-string", "esnext.array.group-to-map"],
  "core-js/full/array/includes": ["es.array.includes"],
  "core-js/full/array/index-of": ["es.array.index-of"],
  "core-js/full/array/is-array": ["es.array.is-array"],
  "core-js/full/array/is-template-object": ["esnext.array.is-template-object"],
  "core-js/full/array/iterator": ["es.array.iterator", "es.object.to-string"],
  "core-js/full/array/join": ["es.array.join"],
  "core-js/full/array/keys": ["es.array.iterator", "es.object.to-string"],
  "core-js/full/array/last-index": ["esnext.array.last-index"],
  "core-js/full/array/last-index-of": ["es.array.last-index-of"],
  "core-js/full/array/last-item": ["esnext.array.last-item"],
  "core-js/full/array/map": ["es.array.map"],
  "core-js/full/array/of": ["es.array.of"],
  "core-js/full/array/push": ["es.array.push"],
  "core-js/full/array/reduce": ["es.array.reduce"],
  "core-js/full/array/reduce-right": ["es.array.reduce-right"],
  "core-js/full/array/reverse": ["es.array.reverse"],
  "core-js/full/array/slice": ["es.array.slice"],
  "core-js/full/array/some": ["es.array.some"],
  "core-js/full/array/sort": ["es.array.sort"],
  "core-js/full/array/splice": ["es.array.splice"],
  "core-js/full/array/to-reversed": ["es.array.to-reversed", "esnext.array.to-reversed"],
  "core-js/full/array/to-sorted": ["es.array.sort", "es.array.to-sorted", "esnext.array.to-sorted"],
  "core-js/full/array/to-spliced": ["es.array.to-spliced", "esnext.array.to-spliced"],
  "core-js/full/array/unique-by": ["es.map", "esnext.array.unique-by"],
  "core-js/full/array/unshift": ["es.array.unshift"],
  "core-js/full/array/values": ["es.array.iterator", "es.object.to-string"],
  "core-js/full/array/virtual": [
    "es.array.at",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.find-last",
    "es.array.find-last-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.includes",
    "es.array.index-of",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.push",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.to-reversed",
    "es.array.to-sorted",
    "es.array.to-spliced",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array.unshift",
    "es.array.with",
    "es.map",
    "es.object.to-string",
    "esnext.array.at",
    "esnext.array.filter-out",
    "esnext.array.filter-reject",
    "esnext.array.find-last",
    "esnext.array.find-last-index",
    "esnext.array.group",
    "esnext.array.group-by",
    "esnext.array.group-by-to-map",
    "esnext.array.group-to-map",
    "esnext.array.to-reversed",
    "esnext.array.to-sorted",
    "esnext.array.to-spliced",
    "esnext.array.unique-by",
    "esnext.array.with"
  ],
  "core-js/full/array/virtual/at": ["es.array.at", "esnext.array.at"],
  "core-js/full/array/virtual/concat": ["es.array.concat"],
  "core-js/full/array/virtual/copy-within": ["es.array.copy-within"],
  "core-js/full/array/virtual/entries": ["es.array.iterator", "es.object.to-string"],
  "core-js/full/array/virtual/every": ["es.array.every"],
  "core-js/full/array/virtual/fill": ["es.array.fill"],
  "core-js/full/array/virtual/filter": ["es.array.filter"],
  "core-js/full/array/virtual/filter-out": ["esnext.array.filter-out"],
  "core-js/full/array/virtual/filter-reject": ["esnext.array.filter-reject"],
  "core-js/full/array/virtual/find": ["es.array.find"],
  "core-js/full/array/virtual/find-index": ["es.array.find-index"],
  "core-js/full/array/virtual/find-last": ["es.array.find-last", "esnext.array.find-last"],
  "core-js/full/array/virtual/find-last-index": ["es.array.find-last-index", "esnext.array.find-last-index"],
  "core-js/full/array/virtual/flat": ["es.array.flat", "es.array.unscopables.flat"],
  "core-js/full/array/virtual/flat-map": ["es.array.flat-map", "es.array.unscopables.flat-map"],
  "core-js/full/array/virtual/for-each": ["es.array.for-each"],
  "core-js/full/array/virtual/group": ["esnext.array.group"],
  "core-js/full/array/virtual/group-by": ["esnext.array.group-by"],
  "core-js/full/array/virtual/group-by-to-map": ["es.map", "es.object.to-string", "esnext.array.group-by-to-map"],
  "core-js/full/array/virtual/group-to-map": ["es.map", "es.object.to-string", "esnext.array.group-to-map"],
  "core-js/full/array/virtual/includes": ["es.array.includes"],
  "core-js/full/array/virtual/index-of": ["es.array.index-of"],
  "core-js/full/array/virtual/iterator": ["es.array.iterator", "es.object.to-string"],
  "core-js/full/array/virtual/join": ["es.array.join"],
  "core-js/full/array/virtual/keys": ["es.array.iterator", "es.object.to-string"],
  "core-js/full/array/virtual/last-index-of": ["es.array.last-index-of"],
  "core-js/full/array/virtual/map": ["es.array.map"],
  "core-js/full/array/virtual/push": ["es.array.push"],
  "core-js/full/array/virtual/reduce": ["es.array.reduce"],
  "core-js/full/array/virtual/reduce-right": ["es.array.reduce-right"],
  "core-js/full/array/virtual/reverse": ["es.array.reverse"],
  "core-js/full/array/virtual/slice": ["es.array.slice"],
  "core-js/full/array/virtual/some": ["es.array.some"],
  "core-js/full/array/virtual/sort": ["es.array.sort"],
  "core-js/full/array/virtual/splice": ["es.array.splice"],
  "core-js/full/array/virtual/to-reversed": ["es.array.to-reversed", "esnext.array.to-reversed"],
  "core-js/full/array/virtual/to-sorted": ["es.array.sort", "es.array.to-sorted", "esnext.array.to-sorted"],
  "core-js/full/array/virtual/to-spliced": ["es.array.to-spliced", "esnext.array.to-spliced"],
  "core-js/full/array/virtual/unique-by": ["es.map", "esnext.array.unique-by"],
  "core-js/full/array/virtual/unshift": ["es.array.unshift"],
  "core-js/full/array/virtual/values": ["es.array.iterator", "es.object.to-string"],
  "core-js/full/array/virtual/with": ["es.array.with", "esnext.array.with"],
  "core-js/full/array/with": ["es.array.with", "esnext.array.with"],
  "core-js/full/async-disposable-stack": [
    "es.error.cause",
    "es.error.to-string",
    "es.object.to-string",
    "es.promise",
    "esnext.suppressed-error.constructor",
    "esnext.async-disposable-stack.constructor",
    "esnext.async-iterator.async-dispose",
    "esnext.iterator.dispose"
  ],
  "core-js/full/async-disposable-stack/constructor": [
    "es.error.cause",
    "es.error.to-string",
    "es.object.to-string",
    "es.promise",
    "esnext.suppressed-error.constructor",
    "esnext.async-disposable-stack.constructor",
    "esnext.async-iterator.async-dispose",
    "esnext.iterator.dispose"
  ],
  "core-js/full/async-iterator": [
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.async-dispose",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.indexed",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "web.dom-collections.iterator"
  ],
  "core-js/full/async-iterator/as-indexed-pairs": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs"
  ],
  "core-js/full/async-iterator/async-dispose": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.async-dispose"
  ],
  "core-js/full/async-iterator/drop": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.drop"
  ],
  "core-js/full/async-iterator/every": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.every"
  ],
  "core-js/full/async-iterator/filter": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.filter"
  ],
  "core-js/full/async-iterator/find": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.find"
  ],
  "core-js/full/async-iterator/flat-map": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.flat-map"
  ],
  "core-js/full/async-iterator/for-each": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.for-each"
  ],
  "core-js/full/async-iterator/from": [
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "web.dom-collections.iterator"
  ],
  "core-js/full/async-iterator/indexed": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.indexed"
  ],
  "core-js/full/async-iterator/map": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.map"
  ],
  "core-js/full/async-iterator/reduce": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.reduce"
  ],
  "core-js/full/async-iterator/some": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.some"
  ],
  "core-js/full/async-iterator/take": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.take"
  ],
  "core-js/full/async-iterator/to-array": [
    "es.object.to-string",
    "es.promise",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.to-array"
  ],
  "core-js/full/atob": [
    "es.error.to-string",
    "es.object.to-string",
    "web.atob",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag"
  ],
  "core-js/full/bigint": ["es.object.to-string", "esnext.bigint.range"],
  "core-js/full/bigint/range": ["es.object.to-string", "esnext.bigint.range"],
  "core-js/full/btoa": [
    "es.error.to-string",
    "es.object.to-string",
    "web.btoa",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag"
  ],
  "core-js/full/clear-immediate": ["web.immediate"],
  "core-js/full/composite-key": ["esnext.composite-key"],
  "core-js/full/composite-symbol": ["es.symbol", "esnext.composite-symbol"],
  "core-js/full/data-view": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.data-view",
    "es.object.to-string"
  ],
  "core-js/full/date": [
    "es.date.get-year",
    "es.date.now",
    "es.date.set-year",
    "es.date.to-gmt-string",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string"
  ],
  "core-js/full/date/get-year": ["es.date.get-year"],
  "core-js/full/date/now": ["es.date.now"],
  "core-js/full/date/set-year": ["es.date.set-year"],
  "core-js/full/date/to-gmt-string": ["es.date.to-gmt-string"],
  "core-js/full/date/to-iso-string": ["es.date.to-iso-string", "es.date.to-json"],
  "core-js/full/date/to-json": ["es.date.to-json"],
  "core-js/full/date/to-primitive": ["es.date.to-primitive"],
  "core-js/full/date/to-string": ["es.date.to-string"],
  "core-js/full/disposable-stack": [
    "es.error.cause",
    "es.error.to-string",
    "es.object.to-string",
    "esnext.suppressed-error.constructor",
    "esnext.disposable-stack.constructor",
    "esnext.iterator.dispose"
  ],
  "core-js/full/disposable-stack/constructor": [
    "es.error.cause",
    "es.error.to-string",
    "es.object.to-string",
    "esnext.suppressed-error.constructor",
    "esnext.disposable-stack.constructor",
    "esnext.iterator.dispose"
  ],
  "core-js/full/dom-collections": [
    "es.array.iterator",
    "es.object.to-string",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator"
  ],
  "core-js/full/dom-collections/for-each": ["web.dom-collections.for-each"],
  "core-js/full/dom-collections/iterator": ["es.object.to-string", "web.dom-collections.iterator"],
  "core-js/full/dom-exception": [
    "es.error.to-string",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag"
  ],
  "core-js/full/dom-exception/constructor": [
    "es.error.to-string",
    "web.dom-exception.constructor",
    "web.dom-exception.stack"
  ],
  "core-js/full/dom-exception/to-string-tag": ["web.dom-exception.to-string-tag"],
  "core-js/full/error": ["es.error.cause", "es.error.to-string"],
  "core-js/full/error/constructor": ["es.error.cause"],
  "core-js/full/error/to-string": ["es.error.to-string"],
  "core-js/full/escape": ["es.escape"],
  "core-js/full/function": [
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name",
    "esnext.function.demethodize",
    "esnext.function.is-callable",
    "esnext.function.is-constructor",
    "esnext.function.metadata",
    "esnext.function.un-this"
  ],
  "core-js/full/function/bind": ["es.function.bind"],
  "core-js/full/function/demethodize": ["esnext.function.demethodize"],
  "core-js/full/function/has-instance": ["es.function.has-instance"],
  "core-js/full/function/is-callable": ["esnext.function.is-callable"],
  "core-js/full/function/is-constructor": ["esnext.function.is-constructor"],
  "core-js/full/function/metadata": ["esnext.function.metadata"],
  "core-js/full/function/name": ["es.function.name"],
  "core-js/full/function/un-this": ["esnext.function.un-this"],
  "core-js/full/function/virtual": ["es.function.bind", "esnext.function.demethodize", "esnext.function.un-this"],
  "core-js/full/function/virtual/bind": ["es.function.bind"],
  "core-js/full/function/virtual/demethodize": ["esnext.function.demethodize"],
  "core-js/full/function/virtual/un-this": ["esnext.function.un-this"],
  "core-js/full/get-iterator": ["es.array.iterator", "es.string.iterator", "web.dom-collections.iterator"],
  "core-js/full/get-iterator-method": ["es.array.iterator", "es.string.iterator", "web.dom-collections.iterator"],
  "core-js/full/global-this": ["es.global-this", "esnext.global-this"],
  "core-js/full/instance/at": ["es.array.at", "es.string.at-alternative", "esnext.array.at", "esnext.string.at"],
  "core-js/full/instance/bind": ["es.function.bind"],
  "core-js/full/instance/code-point-at": ["es.string.code-point-at"],
  "core-js/full/instance/code-points": ["es.object.to-string", "esnext.string.code-points"],
  "core-js/full/instance/concat": ["es.array.concat"],
  "core-js/full/instance/copy-within": ["es.array.copy-within"],
  "core-js/full/instance/demethodize": ["esnext.function.demethodize"],
  "core-js/full/instance/ends-with": ["es.string.ends-with"],
  "core-js/full/instance/entries": ["es.array.iterator", "es.object.to-string", "web.dom-collections.iterator"],
  "core-js/full/instance/every": ["es.array.every"],
  "core-js/full/instance/fill": ["es.array.fill"],
  "core-js/full/instance/filter": ["es.array.filter"],
  "core-js/full/instance/filter-out": ["esnext.array.filter-out"],
  "core-js/full/instance/filter-reject": ["esnext.array.filter-reject"],
  "core-js/full/instance/find": ["es.array.find"],
  "core-js/full/instance/find-index": ["es.array.find-index"],
  "core-js/full/instance/find-last": ["es.array.find-last", "esnext.array.find-last"],
  "core-js/full/instance/find-last-index": ["es.array.find-last-index", "esnext.array.find-last-index"],
  "core-js/full/instance/flags": ["es.regexp.flags"],
  "core-js/full/instance/flat": ["es.array.flat", "es.array.unscopables.flat"],
  "core-js/full/instance/flat-map": ["es.array.flat-map", "es.array.unscopables.flat-map"],
  "core-js/full/instance/for-each": ["es.array.for-each", "web.dom-collections.iterator"],
  "core-js/full/instance/group": ["esnext.array.group"],
  "core-js/full/instance/group-by": ["esnext.array.group-by"],
  "core-js/full/instance/group-by-to-map": ["es.map", "es.object.to-string", "esnext.array.group-by-to-map"],
  "core-js/full/instance/group-to-map": ["es.map", "es.object.to-string", "esnext.array.group-to-map"],
  "core-js/full/instance/includes": ["es.array.includes", "es.string.includes"],
  "core-js/full/instance/index-of": ["es.array.index-of"],
  "core-js/full/instance/is-well-formed": ["es.string.is-well-formed"],
  "core-js/full/instance/keys": ["es.array.iterator", "es.object.to-string", "web.dom-collections.iterator"],
  "core-js/full/instance/last-index-of": ["es.array.last-index-of"],
  "core-js/full/instance/map": ["es.array.map"],
  "core-js/full/instance/match-all": [
    "es.object.to-string",
    "es.regexp.exec",
    "es.string.match-all",
    "esnext.string.match-all"
  ],
  "core-js/full/instance/pad-end": ["es.string.pad-end"],
  "core-js/full/instance/pad-start": ["es.string.pad-start"],
  "core-js/full/instance/push": ["es.array.push"],
  "core-js/full/instance/reduce": ["es.array.reduce"],
  "core-js/full/instance/reduce-right": ["es.array.reduce-right"],
  "core-js/full/instance/repeat": ["es.string.repeat"],
  "core-js/full/instance/replace-all": [
    "es.regexp.exec",
    "es.string.replace",
    "es.string.replace-all",
    "esnext.string.replace-all"
  ],
  "core-js/full/instance/reverse": ["es.array.reverse"],
  "core-js/full/instance/slice": ["es.array.slice"],
  "core-js/full/instance/some": ["es.array.some"],
  "core-js/full/instance/sort": ["es.array.sort"],
  "core-js/full/instance/splice": ["es.array.splice"],
  "core-js/full/instance/starts-with": ["es.string.starts-with"],
  "core-js/full/instance/to-reversed": ["es.array.to-reversed", "esnext.array.to-reversed"],
  "core-js/full/instance/to-sorted": ["es.array.sort", "es.array.to-sorted", "esnext.array.to-sorted"],
  "core-js/full/instance/to-spliced": ["es.array.to-spliced", "esnext.array.to-spliced"],
  "core-js/full/instance/to-well-formed": ["es.string.to-well-formed"],
  "core-js/full/instance/trim": ["es.string.trim"],
  "core-js/full/instance/trim-end": ["es.string.trim-end"],
  "core-js/full/instance/trim-left": ["es.string.trim-start"],
  "core-js/full/instance/trim-right": ["es.string.trim-end"],
  "core-js/full/instance/trim-start": ["es.string.trim-start"],
  "core-js/full/instance/un-this": ["esnext.function.un-this"],
  "core-js/full/instance/unique-by": ["es.map", "esnext.array.unique-by"],
  "core-js/full/instance/unshift": ["es.array.unshift"],
  "core-js/full/instance/values": ["es.array.iterator", "es.object.to-string", "web.dom-collections.iterator"],
  "core-js/full/instance/with": ["es.array.with", "esnext.array.with"],
  "core-js/full/is-iterable": ["es.array.iterator", "es.string.iterator", "web.dom-collections.iterator"],
  "core-js/full/iterator": [
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.dispose",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.indexed",
    "esnext.iterator.map",
    "esnext.iterator.range",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.iterator.to-async",
    "web.dom-collections.iterator"
  ],
  "core-js/full/iterator/as-indexed-pairs": [
    "es.object.to-string",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs"
  ],
  "core-js/full/iterator/dispose": ["esnext.iterator.dispose"],
  "core-js/full/iterator/drop": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.drop"],
  "core-js/full/iterator/every": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.every"],
  "core-js/full/iterator/filter": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.filter"],
  "core-js/full/iterator/find": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.find"],
  "core-js/full/iterator/flat-map": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.flat-map"],
  "core-js/full/iterator/for-each": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.for-each"],
  "core-js/full/iterator/from": [
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "esnext.iterator.constructor",
    "esnext.iterator.dispose",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.iterator.to-async",
    "web.dom-collections.iterator"
  ],
  "core-js/full/iterator/indexed": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.indexed"],
  "core-js/full/iterator/map": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.map"],
  "core-js/full/iterator/range": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.range"],
  "core-js/full/iterator/reduce": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.reduce"],
  "core-js/full/iterator/some": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.some"],
  "core-js/full/iterator/take": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.take"],
  "core-js/full/iterator/to-array": ["es.object.to-string", "esnext.iterator.constructor", "esnext.iterator.to-array"],
  "core-js/full/iterator/to-async": [
    "es.object.to-string",
    "es.promise",
    "esnext.iterator.constructor",
    "esnext.iterator.to-async"
  ],
  "core-js/full/json": [
    "es.json.stringify",
    "es.json.to-string-tag",
    "es.object.create",
    "es.object.freeze",
    "es.object.keys",
    "esnext.json.is-raw-json",
    "esnext.json.parse",
    "esnext.json.raw-json"
  ],
  "core-js/full/json/is-raw-json": ["esnext.json.is-raw-json"],
  "core-js/full/json/parse": ["es.object.keys", "esnext.json.parse"],
  "core-js/full/json/raw-json": ["es.object.create", "es.object.freeze", "esnext.json.raw-json"],
  "core-js/full/json/stringify": ["es.json.stringify"],
  "core-js/full/json/to-string-tag": ["es.json.to-string-tag"],
  "core-js/full/map": [
    "es.array.iterator",
    "es.map",
    "es.object.to-string",
    "es.string.iterator",
    "esnext.map.delete-all",
    "esnext.map.emplace",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "web.dom-collections.iterator"
  ],
  "core-js/full/map/delete-all": ["es.map", "esnext.map.delete-all"],
  "core-js/full/map/emplace": ["es.map", "esnext.map.emplace"],
  "core-js/full/map/every": ["es.map", "esnext.map.every"],
  "core-js/full/map/filter": ["es.map", "esnext.map.filter"],
  "core-js/full/map/find": ["es.map", "esnext.map.find"],
  "core-js/full/map/find-key": ["es.map", "esnext.map.find-key"],
  "core-js/full/map/from": [
    "es.array.iterator",
    "es.map",
    "es.string.iterator",
    "esnext.map.from",
    "web.dom-collections.iterator"
  ],
  "core-js/full/map/group-by": ["es.map", "esnext.map.group-by"],
  "core-js/full/map/includes": ["es.map", "esnext.map.includes"],
  "core-js/full/map/key-by": ["es.map", "esnext.map.key-by"],
  "core-js/full/map/key-of": ["es.map", "esnext.map.key-of"],
  "core-js/full/map/map-keys": ["es.map", "esnext.map.map-keys"],
  "core-js/full/map/map-values": ["es.map", "esnext.map.map-values"],
  "core-js/full/map/merge": ["es.map", "esnext.map.merge"],
  "core-js/full/map/of": ["es.array.iterator", "es.map", "esnext.map.of"],
  "core-js/full/map/reduce": ["es.map", "esnext.map.reduce"],
  "core-js/full/map/some": ["es.map", "esnext.map.some"],
  "core-js/full/map/update": ["es.map", "esnext.map.update"],
  "core-js/full/map/update-or-insert": ["es.map", "esnext.map.update-or-insert"],
  "core-js/full/map/upsert": ["es.map", "esnext.map.upsert"],
  "core-js/full/math": [
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh"
  ],
  "core-js/full/math/acosh": ["es.math.acosh"],
  "core-js/full/math/asinh": ["es.math.asinh"],
  "core-js/full/math/atanh": ["es.math.atanh"],
  "core-js/full/math/cbrt": ["es.math.cbrt"],
  "core-js/full/math/clamp": ["esnext.math.clamp"],
  "core-js/full/math/clz32": ["es.math.clz32"],
  "core-js/full/math/cosh": ["es.math.cosh"],
  "core-js/full/math/deg-per-rad": ["esnext.math.deg-per-rad"],
  "core-js/full/math/degrees": ["esnext.math.degrees"],
  "core-js/full/math/expm1": ["es.math.expm1"],
  "core-js/full/math/fround": ["es.math.fround"],
  "core-js/full/math/fscale": ["esnext.math.fscale"],
  "core-js/full/math/hypot": ["es.math.hypot"],
  "core-js/full/math/iaddh": ["esnext.math.iaddh"],
  "core-js/full/math/imul": ["es.math.imul"],
  "core-js/full/math/imulh": ["esnext.math.imulh"],
  "core-js/full/math/isubh": ["esnext.math.isubh"],
  "core-js/full/math/log10": ["es.math.log10"],
  "core-js/full/math/log1p": ["es.math.log1p"],
  "core-js/full/math/log2": ["es.math.log2"],
  "core-js/full/math/rad-per-deg": ["esnext.math.rad-per-deg"],
  "core-js/full/math/radians": ["esnext.math.radians"],
  "core-js/full/math/scale": ["esnext.math.scale"],
  "core-js/full/math/seeded-prng": ["esnext.math.seeded-prng"],
  "core-js/full/math/sign": ["es.math.sign"],
  "core-js/full/math/signbit": ["esnext.math.signbit"],
  "core-js/full/math/sinh": ["es.math.sinh"],
  "core-js/full/math/tanh": ["es.math.tanh"],
  "core-js/full/math/to-string-tag": ["es.math.to-string-tag"],
  "core-js/full/math/trunc": ["es.math.trunc"],
  "core-js/full/math/umulh": ["esnext.math.umulh"],
  "core-js/full/number": [
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-exponential",
    "es.number.to-fixed",
    "es.number.to-precision",
    "es.object.to-string",
    "esnext.number.from-string",
    "esnext.number.range"
  ],
  "core-js/full/number/constructor": ["es.number.constructor"],
  "core-js/full/number/epsilon": ["es.number.epsilon"],
  "core-js/full/number/from-string": ["esnext.number.from-string"],
  "core-js/full/number/is-finite": ["es.number.is-finite"],
  "core-js/full/number/is-integer": ["es.number.is-integer"],
  "core-js/full/number/is-nan": ["es.number.is-nan"],
  "core-js/full/number/is-safe-integer": ["es.number.is-safe-integer"],
  "core-js/full/number/max-safe-integer": ["es.number.max-safe-integer"],
  "core-js/full/number/min-safe-integer": ["es.number.min-safe-integer"],
  "core-js/full/number/parse-float": ["es.number.parse-float"],
  "core-js/full/number/parse-int": ["es.number.parse-int"],
  "core-js/full/number/range": ["es.object.to-string", "esnext.number.range"],
  "core-js/full/number/to-exponential": ["es.number.to-exponential"],
  "core-js/full/number/to-fixed": ["es.number.to-fixed"],
  "core-js/full/number/to-precision": ["es.number.to-precision"],
  "core-js/full/number/virtual": ["es.number.to-exponential", "es.number.to-fixed", "es.number.to-precision"],
  "core-js/full/number/virtual/to-exponential": ["es.number.to-exponential"],
  "core-js/full/number/virtual/to-fixed": ["es.number.to-fixed"],
  "core-js/full/number/virtual/to-precision": ["es.number.to-precision"],
  "core-js/full/object": [
    "es.symbol",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.has-own",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.proto",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.reflect.to-string-tag",
    "esnext.object.has-own",
    "esnext.object.iterate-entries",
    "esnext.object.iterate-keys",
    "esnext.object.iterate-values",
    "esnext.object.group-by",
    "web.dom-collections.iterator"
  ],
  "core-js/full/object/assign": ["es.object.assign"],
  "core-js/full/object/create": ["es.object.create"],
  "core-js/full/object/define-getter": ["es.object.define-getter"],
  "core-js/full/object/define-properties": ["es.object.define-properties"],
  "core-js/full/object/define-property": ["es.object.define-property"],
  "core-js/full/object/define-setter": ["es.object.define-setter"],
  "core-js/full/object/entries": ["es.object.entries"],
  "core-js/full/object/freeze": ["es.object.freeze"],
  "core-js/full/object/from-entries": ["es.array.iterator", "es.object.from-entries", "web.dom-collections.iterator"],
  "core-js/full/object/get-own-property-descriptor": ["es.object.get-own-property-descriptor"],
  "core-js/full/object/get-own-property-descriptors": ["es.object.get-own-property-descriptors"],
  "core-js/full/object/get-own-property-names": ["es.object.get-own-property-names"],
  "core-js/full/object/get-own-property-symbols": ["es.symbol"],
  "core-js/full/object/get-prototype-of": ["es.object.get-prototype-of"],
  "core-js/full/object/group-by": ["es.object.create", "esnext.object.group-by"],
  "core-js/full/object/has-own": ["es.object.has-own", "esnext.object.has-own"],
  "core-js/full/object/is": ["es.object.is"],
  "core-js/full/object/is-extensible": ["es.object.is-extensible"],
  "core-js/full/object/is-frozen": ["es.object.is-frozen"],
  "core-js/full/object/is-sealed": ["es.object.is-sealed"],
  "core-js/full/object/iterate-entries": ["esnext.object.iterate-entries"],
  "core-js/full/object/iterate-keys": ["esnext.object.iterate-keys"],
  "core-js/full/object/iterate-values": ["esnext.object.iterate-values"],
  "core-js/full/object/keys": ["es.object.keys"],
  "core-js/full/object/lookup-getter": ["es.object.lookup-getter"],
  "core-js/full/object/lookup-setter": ["es.object.lookup-setter"],
  "core-js/full/object/prevent-extensions": ["es.object.prevent-extensions"],
  "core-js/full/object/proto": ["es.object.proto"],
  "core-js/full/object/seal": ["es.object.seal"],
  "core-js/full/object/set-prototype-of": ["es.object.set-prototype-of"],
  "core-js/full/object/to-string": [
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string",
    "es.reflect.to-string-tag"
  ],
  "core-js/full/object/values": ["es.object.values"],
  "core-js/full/observable": [
    "es.object.to-string",
    "es.string.iterator",
    "esnext.observable",
    "esnext.symbol.observable",
    "web.dom-collections.iterator"
  ],
  "core-js/full/parse-float": ["es.parse-float"],
  "core-js/full/parse-int": ["es.parse-int"],
  "core-js/full/promise": [
    "es.aggregate-error",
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.any",
    "es.promise.finally",
    "es.string.iterator",
    "esnext.aggregate-error",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.promise.with-resolvers",
    "web.dom-collections.iterator"
  ],
  "core-js/full/promise/all-settled": [
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.promise.all-settled",
    "es.string.iterator",
    "esnext.promise.all-settled",
    "web.dom-collections.iterator"
  ],
  "core-js/full/promise/any": [
    "es.aggregate-error",
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.promise.any",
    "es.string.iterator",
    "esnext.aggregate-error",
    "esnext.promise.any",
    "web.dom-collections.iterator"
  ],
  "core-js/full/promise/finally": ["es.object.to-string", "es.promise", "es.promise.finally"],
  "core-js/full/promise/try": ["es.promise", "esnext.promise.try"],
  "core-js/full/promise/with-resolvers": ["es.promise", "esnext.promise.with-resolvers"],
  "core-js/full/queue-microtask": ["web.queue-microtask"],
  "core-js/full/reflect": [
    "es.object.to-string",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.reflect.to-string-tag",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata"
  ],
  "core-js/full/reflect/apply": ["es.reflect.apply"],
  "core-js/full/reflect/construct": ["es.reflect.construct"],
  "core-js/full/reflect/define-metadata": ["esnext.reflect.define-metadata"],
  "core-js/full/reflect/define-property": ["es.reflect.define-property"],
  "core-js/full/reflect/delete-metadata": ["esnext.reflect.delete-metadata"],
  "core-js/full/reflect/delete-property": ["es.reflect.delete-property"],
  "core-js/full/reflect/get": ["es.reflect.get"],
  "core-js/full/reflect/get-metadata": ["esnext.reflect.get-metadata"],
  "core-js/full/reflect/get-metadata-keys": ["esnext.reflect.get-metadata-keys"],
  "core-js/full/reflect/get-own-metadata": ["esnext.reflect.get-own-metadata"],
  "core-js/full/reflect/get-own-metadata-keys": ["esnext.reflect.get-own-metadata-keys"],
  "core-js/full/reflect/get-own-property-descriptor": ["es.reflect.get-own-property-descriptor"],
  "core-js/full/reflect/get-prototype-of": ["es.reflect.get-prototype-of"],
  "core-js/full/reflect/has": ["es.reflect.has"],
  "core-js/full/reflect/has-metadata": ["esnext.reflect.has-metadata"],
  "core-js/full/reflect/has-own-metadata": ["esnext.reflect.has-own-metadata"],
  "core-js/full/reflect/is-extensible": ["es.reflect.is-extensible"],
  "core-js/full/reflect/metadata": ["esnext.reflect.metadata"],
  "core-js/full/reflect/own-keys": ["es.reflect.own-keys"],
  "core-js/full/reflect/prevent-extensions": ["es.reflect.prevent-extensions"],
  "core-js/full/reflect/set": ["es.reflect.set"],
  "core-js/full/reflect/set-prototype-of": ["es.reflect.set-prototype-of"],
  "core-js/full/reflect/to-string-tag": ["es.reflect.to-string-tag"],
  "core-js/full/regexp": [
    "es.regexp.constructor",
    "es.regexp.dot-all",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.sticky",
    "es.regexp.test",
    "es.regexp.to-string",
    "es.string.match",
    "es.string.replace",
    "es.string.search",
    "es.string.split"
  ],
  "core-js/full/regexp/constructor": [
    "es.regexp.constructor",
    "es.regexp.dot-all",
    "es.regexp.exec",
    "es.regexp.sticky"
  ],
  "core-js/full/regexp/dot-all": ["es.regexp.constructor", "es.regexp.dot-all", "es.regexp.exec"],
  "core-js/full/regexp/flags": ["es.regexp.flags"],
  "core-js/full/regexp/match": ["es.regexp.exec", "es.string.match"],
  "core-js/full/regexp/replace": ["es.regexp.exec", "es.string.replace"],
  "core-js/full/regexp/search": ["es.regexp.exec", "es.string.search"],
  "core-js/full/regexp/split": ["es.regexp.exec", "es.string.split"],
  "core-js/full/regexp/sticky": ["es.regexp.constructor", "es.regexp.exec", "es.regexp.sticky"],
  "core-js/full/regexp/test": ["es.regexp.exec", "es.regexp.test"],
  "core-js/full/regexp/to-string": ["es.regexp.to-string"],
  "core-js/full/self": ["web.self"],
  "core-js/full/set": [
    "es.array.iterator",
    "es.object.to-string",
    "es.set",
    "es.string.iterator",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference.v2",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection.v2",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from.v2",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of.v2",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of.v2",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference.v2",
    "esnext.set.symmetric-difference",
    "esnext.set.union.v2",
    "esnext.set.union",
    "web.dom-collections.iterator"
  ],
  "core-js/full/set-immediate": ["web.immediate"],
  "core-js/full/set-interval": ["web.timers"],
  "core-js/full/set-timeout": ["web.timers"],
  "core-js/full/set/add-all": ["es.set", "esnext.set.add-all"],
  "core-js/full/set/delete-all": ["es.set", "esnext.set.delete-all"],
  "core-js/full/set/difference": [
    "es.array.iterator",
    "es.set",
    "es.string.iterator",
    "esnext.set.difference.v2",
    "esnext.set.difference",
    "web.dom-collections.iterator"
  ],
  "core-js/full/set/every": ["es.set", "esnext.set.every"],
  "core-js/full/set/filter": ["es.set", "esnext.set.filter"],
  "core-js/full/set/find": ["es.set", "esnext.set.find"],
  "core-js/full/set/from": [
    "es.array.iterator",
    "es.set",
    "es.string.iterator",
    "esnext.set.from",
    "web.dom-collections.iterator"
  ],
  "core-js/full/set/intersection": [
    "es.array.iterator",
    "es.set",
    "es.string.iterator",
    "esnext.set.intersection.v2",
    "esnext.set.intersection",
    "web.dom-collections.iterator"
  ],
  "core-js/full/set/is-disjoint-from": [
    "es.array.iterator",
    "es.set",
    "es.string.iterator",
    "esnext.set.is-disjoint-from.v2",
    "esnext.set.is-disjoint-from",
    "web.dom-collections.iterator"
  ],
  "core-js/full/set/is-subset-of": [
    "es.array.iterator",
    "es.set",
    "es.string.iterator",
    "esnext.set.is-subset-of.v2",
    "esnext.set.is-subset-of",
    "web.dom-collections.iterator"
  ],
  "core-js/full/set/is-superset-of": [
    "es.array.iterator",
    "es.set",
    "es.string.iterator",
    "esnext.set.is-superset-of.v2",
    "esnext.set.is-superset-of",
    "web.dom-collections.iterator"
  ],
  "core-js/full/set/join": ["es.set", "esnext.set.join"],
  "core-js/full/set/map": ["es.set", "esnext.set.map"],
  "core-js/full/set/of": ["es.array.iterator", "es.set", "esnext.set.of"],
  "core-js/full/set/reduce": ["es.set", "esnext.set.reduce"],
  "core-js/full/set/some": ["es.set", "esnext.set.some"],
  "core-js/full/set/symmetric-difference": [
    "es.array.iterator",
    "es.set",
    "es.string.iterator",
    "esnext.set.symmetric-difference.v2",
    "esnext.set.symmetric-difference",
    "web.dom-collections.iterator"
  ],
  "core-js/full/set/union": [
    "es.array.iterator",
    "es.set",
    "es.string.iterator",
    "esnext.set.union.v2",
    "esnext.set.union",
    "web.dom-collections.iterator"
  ],
  "core-js/full/string": [
    "es.object.to-string",
    "es.regexp.exec",
    "es.string.at-alternative",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.is-well-formed",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.replace-all",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.substr",
    "es.string.to-well-formed",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "es.weak-map",
    "esnext.string.at",
    "esnext.string.cooked",
    "esnext.string.code-points",
    "esnext.string.dedent",
    "esnext.string.is-well-formed",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.string.to-well-formed"
  ],
  "core-js/full/string/anchor": ["es.string.anchor"],
  "core-js/full/string/at": ["es.string.at-alternative", "esnext.string.at"],
  "core-js/full/string/big": ["es.string.big"],
  "core-js/full/string/blink": ["es.string.blink"],
  "core-js/full/string/bold": ["es.string.bold"],
  "core-js/full/string/code-point-at": ["es.string.code-point-at"],
  "core-js/full/string/code-points": ["es.object.to-string", "esnext.string.code-points"],
  "core-js/full/string/cooked": ["esnext.string.cooked"],
  "core-js/full/string/dedent": ["es.string.from-code-point", "es.weak-map", "esnext.string.dedent"],
  "core-js/full/string/ends-with": ["es.string.ends-with"],
  "core-js/full/string/fixed": ["es.string.fixed"],
  "core-js/full/string/fontcolor": ["es.string.fontcolor"],
  "core-js/full/string/fontsize": ["es.string.fontsize"],
  "core-js/full/string/from-code-point": ["es.string.from-code-point"],
  "core-js/full/string/includes": ["es.string.includes"],
  "core-js/full/string/is-well-formed": ["es.string.is-well-formed", "esnext.string.is-well-formed"],
  "core-js/full/string/italics": ["es.string.italics"],
  "core-js/full/string/iterator": ["es.object.to-string", "es.string.iterator"],
  "core-js/full/string/link": ["es.string.link"],
  "core-js/full/string/match": ["es.regexp.exec", "es.string.match"],
  "core-js/full/string/match-all": [
    "es.object.to-string",
    "es.regexp.exec",
    "es.string.match-all",
    "esnext.string.match-all"
  ],
  "core-js/full/string/pad-end": ["es.string.pad-end"],
  "core-js/full/string/pad-start": ["es.string.pad-start"],
  "core-js/full/string/raw": ["es.string.raw"],
  "core-js/full/string/repeat": ["es.string.repeat"],
  "core-js/full/string/replace": ["es.regexp.exec", "es.string.replace"],
  "core-js/full/string/replace-all": [
    "es.regexp.exec",
    "es.string.replace",
    "es.string.replace-all",
    "esnext.string.replace-all"
  ],
  "core-js/full/string/search": ["es.regexp.exec", "es.string.search"],
  "core-js/full/string/small": ["es.string.small"],
  "core-js/full/string/split": ["es.regexp.exec", "es.string.split"],
  "core-js/full/string/starts-with": ["es.string.starts-with"],
  "core-js/full/string/strike": ["es.string.strike"],
  "core-js/full/string/sub": ["es.string.sub"],
  "core-js/full/string/substr": ["es.string.substr"],
  "core-js/full/string/sup": ["es.string.sup"],
  "core-js/full/string/to-well-formed": ["es.string.to-well-formed", "esnext.string.to-well-formed"],
  "core-js/full/string/trim": ["es.string.trim"],
  "core-js/full/string/trim-end": ["es.string.trim-end"],
  "core-js/full/string/trim-left": ["es.string.trim-start"],
  "core-js/full/string/trim-right": ["es.string.trim-end"],
  "core-js/full/string/trim-start": ["es.string.trim-start"],
  "core-js/full/string/virtual": [
    "es.object.to-string",
    "es.regexp.exec",
    "es.string.at-alternative",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.repeat",
    "es.string.replace",
    "es.string.replace-all",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.substr",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "esnext.string.at",
    "esnext.string.code-points",
    "esnext.string.is-well-formed",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.string.to-well-formed"
  ],
  "core-js/full/string/virtual/anchor": ["es.string.anchor"],
  "core-js/full/string/virtual/at": ["es.string.at-alternative", "esnext.string.at"],
  "core-js/full/string/virtual/big": ["es.string.big"],
  "core-js/full/string/virtual/blink": ["es.string.blink"],
  "core-js/full/string/virtual/bold": ["es.string.bold"],
  "core-js/full/string/virtual/code-point-at": ["es.string.code-point-at"],
  "core-js/full/string/virtual/code-points": ["es.object.to-string", "esnext.string.code-points"],
  "core-js/full/string/virtual/ends-with": ["es.string.ends-with"],
  "core-js/full/string/virtual/fixed": ["es.string.fixed"],
  "core-js/full/string/virtual/fontcolor": ["es.string.fontcolor"],
  "core-js/full/string/virtual/fontsize": ["es.string.fontsize"],
  "core-js/full/string/virtual/includes": ["es.string.includes"],
  "core-js/full/string/virtual/is-well-formed": ["es.string.is-well-formed", "esnext.string.is-well-formed"],
  "core-js/full/string/virtual/italics": ["es.string.italics"],
  "core-js/full/string/virtual/iterator": ["es.object.to-string", "es.string.iterator"],
  "core-js/full/string/virtual/link": ["es.string.link"],
  "core-js/full/string/virtual/match-all": [
    "es.object.to-string",
    "es.regexp.exec",
    "es.string.match-all",
    "esnext.string.match-all"
  ],
  "core-js/full/string/virtual/pad-end": ["es.string.pad-end"],
  "core-js/full/string/virtual/pad-start": ["es.string.pad-start"],
  "core-js/full/string/virtual/repeat": ["es.string.repeat"],
  "core-js/full/string/virtual/replace-all": [
    "es.regexp.exec",
    "es.string.replace",
    "es.string.replace-all",
    "esnext.string.replace-all"
  ],
  "core-js/full/string/virtual/small": ["es.string.small"],
  "core-js/full/string/virtual/starts-with": ["es.string.starts-with"],
  "core-js/full/string/virtual/strike": ["es.string.strike"],
  "core-js/full/string/virtual/sub": ["es.string.sub"],
  "core-js/full/string/virtual/substr": ["es.string.substr"],
  "core-js/full/string/virtual/sup": ["es.string.sup"],
  "core-js/full/string/virtual/to-well-formed": ["es.string.to-well-formed", "esnext.string.to-well-formed"],
  "core-js/full/string/virtual/trim": ["es.string.trim"],
  "core-js/full/string/virtual/trim-end": ["es.string.trim-end"],
  "core-js/full/string/virtual/trim-left": ["es.string.trim-start"],
  "core-js/full/string/virtual/trim-right": ["es.string.trim-end"],
  "core-js/full/string/virtual/trim-start": ["es.string.trim-start"],
  "core-js/full/structured-clone": [
    "es.error.to-string",
    "es.array.iterator",
    "es.map",
    "es.object.keys",
    "es.object.to-string",
    "es.set",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag",
    "web.structured-clone"
  ],
  "core-js/full/suppressed-error": ["es.error.cause", "es.error.to-string", "esnext.suppressed-error.constructor"],
  "core-js/full/symbol": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string",
    "es.reflect.to-string-tag",
    "esnext.function.metadata",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.is-registered-symbol",
    "esnext.symbol.is-registered",
    "esnext.symbol.is-well-known-symbol",
    "esnext.symbol.is-well-known",
    "esnext.symbol.matcher",
    "esnext.symbol.metadata",
    "esnext.symbol.metadata-key",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "web.dom-collections.iterator"
  ],
  "core-js/full/symbol/async-dispose": ["esnext.symbol.async-dispose"],
  "core-js/full/symbol/async-iterator": ["es.symbol.async-iterator"],
  "core-js/full/symbol/description": ["es.symbol.description"],
  "core-js/full/symbol/dispose": ["esnext.symbol.dispose"],
  "core-js/full/symbol/for": ["es.symbol"],
  "core-js/full/symbol/has-instance": ["es.symbol.has-instance", "es.function.has-instance"],
  "core-js/full/symbol/is-concat-spreadable": ["es.symbol.is-concat-spreadable", "es.array.concat"],
  "core-js/full/symbol/is-registered": ["es.symbol", "esnext.symbol.is-registered"],
  "core-js/full/symbol/is-registered-symbol": ["es.symbol", "esnext.symbol.is-registered-symbol"],
  "core-js/full/symbol/is-well-known": ["es.symbol", "esnext.symbol.is-well-known"],
  "core-js/full/symbol/is-well-known-symbol": ["es.symbol", "esnext.symbol.is-well-known-symbol"],
  "core-js/full/symbol/iterator": [
    "es.symbol.iterator",
    "es.array.iterator",
    "es.object.to-string",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/full/symbol/key-for": ["es.symbol"],
  "core-js/full/symbol/match": ["es.symbol.match", "es.regexp.exec", "es.string.match"],
  "core-js/full/symbol/match-all": [
    "es.symbol.match-all",
    "es.object.to-string",
    "es.regexp.exec",
    "es.string.match-all"
  ],
  "core-js/full/symbol/matcher": ["esnext.symbol.matcher"],
  "core-js/full/symbol/metadata": ["esnext.function.metadata", "esnext.symbol.metadata"],
  "core-js/full/symbol/metadata-key": ["esnext.symbol.metadata-key"],
  "core-js/full/symbol/observable": ["esnext.symbol.observable"],
  "core-js/full/symbol/pattern-match": ["esnext.symbol.pattern-match"],
  "core-js/full/symbol/replace": ["es.symbol.replace", "es.regexp.exec", "es.string.replace"],
  "core-js/full/symbol/replace-all": ["esnext.symbol.replace-all"],
  "core-js/full/symbol/search": ["es.symbol.search", "es.regexp.exec", "es.string.search"],
  "core-js/full/symbol/species": ["es.symbol.species"],
  "core-js/full/symbol/split": ["es.symbol.split", "es.regexp.exec", "es.string.split"],
  "core-js/full/symbol/to-primitive": ["es.symbol.to-primitive", "es.date.to-primitive"],
  "core-js/full/symbol/to-string-tag": [
    "es.symbol.to-string-tag",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string",
    "es.reflect.to-string-tag"
  ],
  "core-js/full/symbol/unscopables": ["es.symbol.unscopables"],
  "core-js/full/typed-array": [
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with"
  ],
  "core-js/full/typed-array/at": ["es.typed-array.at", "esnext.typed-array.at"],
  "core-js/full/typed-array/copy-within": ["es.typed-array.copy-within"],
  "core-js/full/typed-array/entries": ["es.object.to-string", "es.typed-array.iterator"],
  "core-js/full/typed-array/every": ["es.typed-array.every"],
  "core-js/full/typed-array/fill": ["es.typed-array.fill"],
  "core-js/full/typed-array/filter": ["es.typed-array.filter"],
  "core-js/full/typed-array/filter-out": ["esnext.typed-array.filter-out"],
  "core-js/full/typed-array/filter-reject": ["esnext.typed-array.filter-reject"],
  "core-js/full/typed-array/find": ["es.typed-array.find"],
  "core-js/full/typed-array/find-index": ["es.typed-array.find-index"],
  "core-js/full/typed-array/find-last": ["es.typed-array.find-last", "esnext.typed-array.find-last"],
  "core-js/full/typed-array/find-last-index": ["es.typed-array.find-last-index", "esnext.typed-array.find-last-index"],
  "core-js/full/typed-array/float32-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "es.typed-array.float32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with"
  ],
  "core-js/full/typed-array/float64-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "es.typed-array.float64-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with"
  ],
  "core-js/full/typed-array/for-each": ["es.typed-array.for-each"],
  "core-js/full/typed-array/from": ["es.typed-array.from"],
  "core-js/full/typed-array/from-async": ["esnext.typed-array.from-async"],
  "core-js/full/typed-array/group-by": ["esnext.typed-array.group-by"],
  "core-js/full/typed-array/includes": ["es.typed-array.includes"],
  "core-js/full/typed-array/index-of": ["es.typed-array.index-of"],
  "core-js/full/typed-array/int16-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "es.typed-array.int16-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with"
  ],
  "core-js/full/typed-array/int32-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "es.typed-array.int32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with"
  ],
  "core-js/full/typed-array/int8-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "es.typed-array.int8-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with"
  ],
  "core-js/full/typed-array/iterator": ["es.object.to-string", "es.typed-array.iterator"],
  "core-js/full/typed-array/join": ["es.typed-array.join"],
  "core-js/full/typed-array/keys": ["es.object.to-string", "es.typed-array.iterator"],
  "core-js/full/typed-array/last-index-of": ["es.typed-array.last-index-of"],
  "core-js/full/typed-array/map": ["es.typed-array.map"],
  "core-js/full/typed-array/methods": [
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with"
  ],
  "core-js/full/typed-array/of": ["es.typed-array.of"],
  "core-js/full/typed-array/reduce": ["es.typed-array.reduce"],
  "core-js/full/typed-array/reduce-right": ["es.typed-array.reduce-right"],
  "core-js/full/typed-array/reverse": ["es.typed-array.reverse"],
  "core-js/full/typed-array/set": ["es.typed-array.set"],
  "core-js/full/typed-array/slice": ["es.typed-array.slice"],
  "core-js/full/typed-array/some": ["es.typed-array.some"],
  "core-js/full/typed-array/sort": ["es.typed-array.sort"],
  "core-js/full/typed-array/subarray": ["es.typed-array.subarray"],
  "core-js/full/typed-array/to-locale-string": ["es.typed-array.to-locale-string"],
  "core-js/full/typed-array/to-reversed": ["es.typed-array.to-reversed", "esnext.typed-array.to-reversed"],
  "core-js/full/typed-array/to-sorted": [
    "es.typed-array.sort",
    "es.typed-array.to-sorted",
    "esnext.typed-array.to-sorted"
  ],
  "core-js/full/typed-array/to-spliced": ["esnext.typed-array.to-spliced"],
  "core-js/full/typed-array/to-string": ["es.typed-array.to-string"],
  "core-js/full/typed-array/uint16-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "es.typed-array.uint16-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with"
  ],
  "core-js/full/typed-array/uint32-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "es.typed-array.uint32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with"
  ],
  "core-js/full/typed-array/uint8-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "es.typed-array.uint8-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with"
  ],
  "core-js/full/typed-array/uint8-clamped-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.map",
    "es.object.to-string",
    "es.promise",
    "es.string.iterator",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with"
  ],
  "core-js/full/typed-array/unique-by": ["es.map", "esnext.typed-array.unique-by"],
  "core-js/full/typed-array/values": ["es.object.to-string", "es.typed-array.iterator"],
  "core-js/full/typed-array/with": ["es.typed-array.with", "esnext.typed-array.with"],
  "core-js/full/unescape": ["es.unescape"],
  "core-js/full/url": [
    "web.url",
    "web.url.can-parse",
    "web.url.to-json",
    "web.url-search-params",
    "web.url-search-params.delete",
    "web.url-search-params.has",
    "web.url-search-params.size"
  ],
  "core-js/full/url-search-params": [
    "web.dom-collections.iterator",
    "web.url-search-params",
    "web.url-search-params.delete",
    "web.url-search-params.has",
    "web.url-search-params.size"
  ],
  "core-js/full/url/can-parse": ["web.url", "web.url.can-parse"],
  "core-js/full/url/to-json": ["web.url.to-json"],
  "core-js/full/weak-map": [
    "es.array.iterator",
    "es.object.to-string",
    "es.string.iterator",
    "es.weak-map",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.emplace",
    "esnext.weak-map.upsert",
    "web.dom-collections.iterator"
  ],
  "core-js/full/weak-map/delete-all": ["es.weak-map", "esnext.weak-map.delete-all"],
  "core-js/full/weak-map/emplace": ["es.weak-map", "esnext.weak-map.emplace"],
  "core-js/full/weak-map/from": [
    "es.array.iterator",
    "es.string.iterator",
    "es.weak-map",
    "esnext.weak-map.from",
    "web.dom-collections.iterator"
  ],
  "core-js/full/weak-map/of": ["es.array.iterator", "es.weak-map", "esnext.weak-map.of"],
  "core-js/full/weak-map/upsert": ["es.weak-map", "esnext.weak-map.upsert"],
  "core-js/full/weak-set": [
    "es.array.iterator",
    "es.object.to-string",
    "es.string.iterator",
    "es.weak-set",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.dom-collections.iterator"
  ],
  "core-js/full/weak-set/add-all": ["es.weak-set", "esnext.weak-set.add-all"],
  "core-js/full/weak-set/delete-all": ["es.weak-set", "esnext.weak-set.delete-all"],
  "core-js/full/weak-set/from": [
    "es.array.iterator",
    "es.string.iterator",
    "es.weak-set",
    "esnext.weak-set.from",
    "web.dom-collections.iterator"
  ],
  "core-js/full/weak-set/of": ["es.array.iterator", "es.weak-set", "esnext.weak-set.of"],
  "core-js/modules/es.aggregate-error": ["es.aggregate-error"],
  "core-js/modules/es.aggregate-error.cause": ["es.aggregate-error.cause"],
  "core-js/modules/es.aggregate-error.constructor": ["es.aggregate-error.constructor"],
  "core-js/modules/es.array-buffer.constructor": ["es.array-buffer.constructor"],
  "core-js/modules/es.array-buffer.is-view": ["es.array-buffer.is-view"],
  "core-js/modules/es.array-buffer.slice": ["es.array-buffer.slice"],
  "core-js/modules/es.array.at": ["es.array.at"],
  "core-js/modules/es.array.concat": ["es.array.concat"],
  "core-js/modules/es.array.copy-within": ["es.array.copy-within"],
  "core-js/modules/es.array.every": ["es.array.every"],
  "core-js/modules/es.array.fill": ["es.array.fill"],
  "core-js/modules/es.array.filter": ["es.array.filter"],
  "core-js/modules/es.array.find": ["es.array.find"],
  "core-js/modules/es.array.find-index": ["es.array.find-index"],
  "core-js/modules/es.array.find-last": ["es.array.find-last"],
  "core-js/modules/es.array.find-last-index": ["es.array.find-last-index"],
  "core-js/modules/es.array.flat": ["es.array.flat"],
  "core-js/modules/es.array.flat-map": ["es.array.flat-map"],
  "core-js/modules/es.array.for-each": ["es.array.for-each"],
  "core-js/modules/es.array.from": ["es.array.from"],
  "core-js/modules/es.array.includes": ["es.array.includes"],
  "core-js/modules/es.array.index-of": ["es.array.index-of"],
  "core-js/modules/es.array.is-array": ["es.array.is-array"],
  "core-js/modules/es.array.iterator": ["es.array.iterator"],
  "core-js/modules/es.array.join": ["es.array.join"],
  "core-js/modules/es.array.last-index-of": ["es.array.last-index-of"],
  "core-js/modules/es.array.map": ["es.array.map"],
  "core-js/modules/es.array.of": ["es.array.of"],
  "core-js/modules/es.array.push": ["es.array.push"],
  "core-js/modules/es.array.reduce": ["es.array.reduce"],
  "core-js/modules/es.array.reduce-right": ["es.array.reduce-right"],
  "core-js/modules/es.array.reverse": ["es.array.reverse"],
  "core-js/modules/es.array.slice": ["es.array.slice"],
  "core-js/modules/es.array.some": ["es.array.some"],
  "core-js/modules/es.array.sort": ["es.array.sort"],
  "core-js/modules/es.array.species": ["es.array.species"],
  "core-js/modules/es.array.splice": ["es.array.splice"],
  "core-js/modules/es.array.to-reversed": ["es.array.to-reversed"],
  "core-js/modules/es.array.to-sorted": ["es.array.to-sorted"],
  "core-js/modules/es.array.to-spliced": ["es.array.to-spliced"],
  "core-js/modules/es.array.unscopables.flat": ["es.array.unscopables.flat"],
  "core-js/modules/es.array.unscopables.flat-map": ["es.array.unscopables.flat-map"],
  "core-js/modules/es.array.unshift": ["es.array.unshift"],
  "core-js/modules/es.array.with": ["es.array.with"],
  "core-js/modules/es.data-view": ["es.data-view"],
  "core-js/modules/es.data-view.constructor": ["es.data-view.constructor"],
  "core-js/modules/es.date.get-year": ["es.date.get-year"],
  "core-js/modules/es.date.now": ["es.date.now"],
  "core-js/modules/es.date.set-year": ["es.date.set-year"],
  "core-js/modules/es.date.to-gmt-string": ["es.date.to-gmt-string"],
  "core-js/modules/es.date.to-iso-string": ["es.date.to-iso-string"],
  "core-js/modules/es.date.to-json": ["es.date.to-json"],
  "core-js/modules/es.date.to-primitive": ["es.date.to-primitive"],
  "core-js/modules/es.date.to-string": ["es.date.to-string"],
  "core-js/modules/es.error.cause": ["es.error.cause"],
  "core-js/modules/es.error.to-string": ["es.error.to-string"],
  "core-js/modules/es.escape": ["es.escape"],
  "core-js/modules/es.function.bind": ["es.function.bind"],
  "core-js/modules/es.function.has-instance": ["es.function.has-instance"],
  "core-js/modules/es.function.name": ["es.function.name"],
  "core-js/modules/es.global-this": ["es.global-this"],
  "core-js/modules/es.json.stringify": ["es.json.stringify"],
  "core-js/modules/es.json.to-string-tag": ["es.json.to-string-tag"],
  "core-js/modules/es.map": ["es.map"],
  "core-js/modules/es.map.constructor": ["es.map.constructor"],
  "core-js/modules/es.math.acosh": ["es.math.acosh"],
  "core-js/modules/es.math.asinh": ["es.math.asinh"],
  "core-js/modules/es.math.atanh": ["es.math.atanh"],
  "core-js/modules/es.math.cbrt": ["es.math.cbrt"],
  "core-js/modules/es.math.clz32": ["es.math.clz32"],
  "core-js/modules/es.math.cosh": ["es.math.cosh"],
  "core-js/modules/es.math.expm1": ["es.math.expm1"],
  "core-js/modules/es.math.fround": ["es.math.fround"],
  "core-js/modules/es.math.hypot": ["es.math.hypot"],
  "core-js/modules/es.math.imul": ["es.math.imul"],
  "core-js/modules/es.math.log10": ["es.math.log10"],
  "core-js/modules/es.math.log1p": ["es.math.log1p"],
  "core-js/modules/es.math.log2": ["es.math.log2"],
  "core-js/modules/es.math.sign": ["es.math.sign"],
  "core-js/modules/es.math.sinh": ["es.math.sinh"],
  "core-js/modules/es.math.tanh": ["es.math.tanh"],
  "core-js/modules/es.math.to-string-tag": ["es.math.to-string-tag"],
  "core-js/modules/es.math.trunc": ["es.math.trunc"],
  "core-js/modules/es.number.constructor": ["es.number.constructor"],
  "core-js/modules/es.number.epsilon": ["es.number.epsilon"],
  "core-js/modules/es.number.is-finite": ["es.number.is-finite"],
  "core-js/modules/es.number.is-integer": ["es.number.is-integer"],
  "core-js/modules/es.number.is-nan": ["es.number.is-nan"],
  "core-js/modules/es.number.is-safe-integer": ["es.number.is-safe-integer"],
  "core-js/modules/es.number.max-safe-integer": ["es.number.max-safe-integer"],
  "core-js/modules/es.number.min-safe-integer": ["es.number.min-safe-integer"],
  "core-js/modules/es.number.parse-float": ["es.number.parse-float"],
  "core-js/modules/es.number.parse-int": ["es.number.parse-int"],
  "core-js/modules/es.number.to-exponential": ["es.number.to-exponential"],
  "core-js/modules/es.number.to-fixed": ["es.number.to-fixed"],
  "core-js/modules/es.number.to-precision": ["es.number.to-precision"],
  "core-js/modules/es.object.assign": ["es.object.assign"],
  "core-js/modules/es.object.create": ["es.object.create"],
  "core-js/modules/es.object.define-getter": ["es.object.define-getter"],
  "core-js/modules/es.object.define-properties": ["es.object.define-properties"],
  "core-js/modules/es.object.define-property": ["es.object.define-property"],
  "core-js/modules/es.object.define-setter": ["es.object.define-setter"],
  "core-js/modules/es.object.entries": ["es.object.entries"],
  "core-js/modules/es.object.freeze": ["es.object.freeze"],
  "core-js/modules/es.object.from-entries": ["es.object.from-entries"],
  "core-js/modules/es.object.get-own-property-descriptor": ["es.object.get-own-property-descriptor"],
  "core-js/modules/es.object.get-own-property-descriptors": ["es.object.get-own-property-descriptors"],
  "core-js/modules/es.object.get-own-property-names": ["es.object.get-own-property-names"],
  "core-js/modules/es.object.get-own-property-symbols": ["es.object.get-own-property-symbols"],
  "core-js/modules/es.object.get-prototype-of": ["es.object.get-prototype-of"],
  "core-js/modules/es.object.has-own": ["es.object.has-own"],
  "core-js/modules/es.object.is": ["es.object.is"],
  "core-js/modules/es.object.is-extensible": ["es.object.is-extensible"],
  "core-js/modules/es.object.is-frozen": ["es.object.is-frozen"],
  "core-js/modules/es.object.is-sealed": ["es.object.is-sealed"],
  "core-js/modules/es.object.keys": ["es.object.keys"],
  "core-js/modules/es.object.lookup-getter": ["es.object.lookup-getter"],
  "core-js/modules/es.object.lookup-setter": ["es.object.lookup-setter"],
  "core-js/modules/es.object.prevent-extensions": ["es.object.prevent-extensions"],
  "core-js/modules/es.object.proto": ["es.object.proto"],
  "core-js/modules/es.object.seal": ["es.object.seal"],
  "core-js/modules/es.object.set-prototype-of": ["es.object.set-prototype-of"],
  "core-js/modules/es.object.to-string": ["es.object.to-string"],
  "core-js/modules/es.object.values": ["es.object.values"],
  "core-js/modules/es.parse-float": ["es.parse-float"],
  "core-js/modules/es.parse-int": ["es.parse-int"],
  "core-js/modules/es.promise": ["es.promise"],
  "core-js/modules/es.promise.all": ["es.promise.all"],
  "core-js/modules/es.promise.all-settled": ["es.promise.all-settled"],
  "core-js/modules/es.promise.any": ["es.promise.any"],
  "core-js/modules/es.promise.catch": ["es.promise.catch"],
  "core-js/modules/es.promise.constructor": ["es.promise.constructor"],
  "core-js/modules/es.promise.finally": ["es.promise.finally"],
  "core-js/modules/es.promise.race": ["es.promise.race"],
  "core-js/modules/es.promise.reject": ["es.promise.reject"],
  "core-js/modules/es.promise.resolve": ["es.promise.resolve"],
  "core-js/modules/es.reflect.apply": ["es.reflect.apply"],
  "core-js/modules/es.reflect.construct": ["es.reflect.construct"],
  "core-js/modules/es.reflect.define-property": ["es.reflect.define-property"],
  "core-js/modules/es.reflect.delete-property": ["es.reflect.delete-property"],
  "core-js/modules/es.reflect.get": ["es.reflect.get"],
  "core-js/modules/es.reflect.get-own-property-descriptor": ["es.reflect.get-own-property-descriptor"],
  "core-js/modules/es.reflect.get-prototype-of": ["es.reflect.get-prototype-of"],
  "core-js/modules/es.reflect.has": ["es.reflect.has"],
  "core-js/modules/es.reflect.is-extensible": ["es.reflect.is-extensible"],
  "core-js/modules/es.reflect.own-keys": ["es.reflect.own-keys"],
  "core-js/modules/es.reflect.prevent-extensions": ["es.reflect.prevent-extensions"],
  "core-js/modules/es.reflect.set": ["es.reflect.set"],
  "core-js/modules/es.reflect.set-prototype-of": ["es.reflect.set-prototype-of"],
  "core-js/modules/es.reflect.to-string-tag": ["es.reflect.to-string-tag"],
  "core-js/modules/es.regexp.constructor": ["es.regexp.constructor"],
  "core-js/modules/es.regexp.dot-all": ["es.regexp.dot-all"],
  "core-js/modules/es.regexp.exec": ["es.regexp.exec"],
  "core-js/modules/es.regexp.flags": ["es.regexp.flags"],
  "core-js/modules/es.regexp.sticky": ["es.regexp.sticky"],
  "core-js/modules/es.regexp.test": ["es.regexp.test"],
  "core-js/modules/es.regexp.to-string": ["es.regexp.to-string"],
  "core-js/modules/es.set": ["es.set"],
  "core-js/modules/es.set.constructor": ["es.set.constructor"],
  "core-js/modules/es.string.anchor": ["es.string.anchor"],
  "core-js/modules/es.string.at-alternative": ["es.string.at-alternative"],
  "core-js/modules/es.string.big": ["es.string.big"],
  "core-js/modules/es.string.blink": ["es.string.blink"],
  "core-js/modules/es.string.bold": ["es.string.bold"],
  "core-js/modules/es.string.code-point-at": ["es.string.code-point-at"],
  "core-js/modules/es.string.ends-with": ["es.string.ends-with"],
  "core-js/modules/es.string.fixed": ["es.string.fixed"],
  "core-js/modules/es.string.fontcolor": ["es.string.fontcolor"],
  "core-js/modules/es.string.fontsize": ["es.string.fontsize"],
  "core-js/modules/es.string.from-code-point": ["es.string.from-code-point"],
  "core-js/modules/es.string.includes": ["es.string.includes"],
  "core-js/modules/es.string.is-well-formed": ["es.string.is-well-formed"],
  "core-js/modules/es.string.italics": ["es.string.italics"],
  "core-js/modules/es.string.iterator": ["es.string.iterator"],
  "core-js/modules/es.string.link": ["es.string.link"],
  "core-js/modules/es.string.match": ["es.string.match"],
  "core-js/modules/es.string.match-all": ["es.string.match-all"],
  "core-js/modules/es.string.pad-end": ["es.string.pad-end"],
  "core-js/modules/es.string.pad-start": ["es.string.pad-start"],
  "core-js/modules/es.string.raw": ["es.string.raw"],
  "core-js/modules/es.string.repeat": ["es.string.repeat"],
  "core-js/modules/es.string.replace": ["es.string.replace"],
  "core-js/modules/es.string.replace-all": ["es.string.replace-all"],
  "core-js/modules/es.string.search": ["es.string.search"],
  "core-js/modules/es.string.small": ["es.string.small"],
  "core-js/modules/es.string.split": ["es.string.split"],
  "core-js/modules/es.string.starts-with": ["es.string.starts-with"],
  "core-js/modules/es.string.strike": ["es.string.strike"],
  "core-js/modules/es.string.sub": ["es.string.sub"],
  "core-js/modules/es.string.substr": ["es.string.substr"],
  "core-js/modules/es.string.sup": ["es.string.sup"],
  "core-js/modules/es.string.to-well-formed": ["es.string.to-well-formed"],
  "core-js/modules/es.string.trim": ["es.string.trim"],
  "core-js/modules/es.string.trim-end": ["es.string.trim-end"],
  "core-js/modules/es.string.trim-left": ["es.string.trim-left"],
  "core-js/modules/es.string.trim-right": ["es.string.trim-right"],
  "core-js/modules/es.string.trim-start": ["es.string.trim-start"],
  "core-js/modules/es.symbol": ["es.symbol"],
  "core-js/modules/es.symbol.async-iterator": ["es.symbol.async-iterator"],
  "core-js/modules/es.symbol.constructor": ["es.symbol.constructor"],
  "core-js/modules/es.symbol.description": ["es.symbol.description"],
  "core-js/modules/es.symbol.for": ["es.symbol.for"],
  "core-js/modules/es.symbol.has-instance": ["es.symbol.has-instance"],
  "core-js/modules/es.symbol.is-concat-spreadable": ["es.symbol.is-concat-spreadable"],
  "core-js/modules/es.symbol.iterator": ["es.symbol.iterator"],
  "core-js/modules/es.symbol.key-for": ["es.symbol.key-for"],
  "core-js/modules/es.symbol.match": ["es.symbol.match"],
  "core-js/modules/es.symbol.match-all": ["es.symbol.match-all"],
  "core-js/modules/es.symbol.replace": ["es.symbol.replace"],
  "core-js/modules/es.symbol.search": ["es.symbol.search"],
  "core-js/modules/es.symbol.species": ["es.symbol.species"],
  "core-js/modules/es.symbol.split": ["es.symbol.split"],
  "core-js/modules/es.symbol.to-primitive": ["es.symbol.to-primitive"],
  "core-js/modules/es.symbol.to-string-tag": ["es.symbol.to-string-tag"],
  "core-js/modules/es.symbol.unscopables": ["es.symbol.unscopables"],
  "core-js/modules/es.typed-array.at": ["es.typed-array.at"],
  "core-js/modules/es.typed-array.copy-within": ["es.typed-array.copy-within"],
  "core-js/modules/es.typed-array.every": ["es.typed-array.every"],
  "core-js/modules/es.typed-array.fill": ["es.typed-array.fill"],
  "core-js/modules/es.typed-array.filter": ["es.typed-array.filter"],
  "core-js/modules/es.typed-array.find": ["es.typed-array.find"],
  "core-js/modules/es.typed-array.find-index": ["es.typed-array.find-index"],
  "core-js/modules/es.typed-array.find-last": ["es.typed-array.find-last"],
  "core-js/modules/es.typed-array.find-last-index": ["es.typed-array.find-last-index"],
  "core-js/modules/es.typed-array.float32-array": ["es.typed-array.float32-array"],
  "core-js/modules/es.typed-array.float64-array": ["es.typed-array.float64-array"],
  "core-js/modules/es.typed-array.for-each": ["es.typed-array.for-each"],
  "core-js/modules/es.typed-array.from": ["es.typed-array.from"],
  "core-js/modules/es.typed-array.includes": ["es.typed-array.includes"],
  "core-js/modules/es.typed-array.index-of": ["es.typed-array.index-of"],
  "core-js/modules/es.typed-array.int16-array": ["es.typed-array.int16-array"],
  "core-js/modules/es.typed-array.int32-array": ["es.typed-array.int32-array"],
  "core-js/modules/es.typed-array.int8-array": ["es.typed-array.int8-array"],
  "core-js/modules/es.typed-array.iterator": ["es.typed-array.iterator"],
  "core-js/modules/es.typed-array.join": ["es.typed-array.join"],
  "core-js/modules/es.typed-array.last-index-of": ["es.typed-array.last-index-of"],
  "core-js/modules/es.typed-array.map": ["es.typed-array.map"],
  "core-js/modules/es.typed-array.of": ["es.typed-array.of"],
  "core-js/modules/es.typed-array.reduce": ["es.typed-array.reduce"],
  "core-js/modules/es.typed-array.reduce-right": ["es.typed-array.reduce-right"],
  "core-js/modules/es.typed-array.reverse": ["es.typed-array.reverse"],
  "core-js/modules/es.typed-array.set": ["es.typed-array.set"],
  "core-js/modules/es.typed-array.slice": ["es.typed-array.slice"],
  "core-js/modules/es.typed-array.some": ["es.typed-array.some"],
  "core-js/modules/es.typed-array.sort": ["es.typed-array.sort"],
  "core-js/modules/es.typed-array.subarray": ["es.typed-array.subarray"],
  "core-js/modules/es.typed-array.to-locale-string": ["es.typed-array.to-locale-string"],
  "core-js/modules/es.typed-array.to-reversed": ["es.typed-array.to-reversed"],
  "core-js/modules/es.typed-array.to-sorted": ["es.typed-array.to-sorted"],
  "core-js/modules/es.typed-array.to-string": ["es.typed-array.to-string"],
  "core-js/modules/es.typed-array.uint16-array": ["es.typed-array.uint16-array"],
  "core-js/modules/es.typed-array.uint32-array": ["es.typed-array.uint32-array"],
  "core-js/modules/es.typed-array.uint8-array": ["es.typed-array.uint8-array"],
  "core-js/modules/es.typed-array.uint8-clamped-array": ["es.typed-array.uint8-clamped-array"],
  "core-js/modules/es.typed-array.with": ["es.typed-array.with"],
  "core-js/modules/es.unescape": ["es.unescape"],
  "core-js/modules/es.weak-map": ["es.weak-map"],
  "core-js/modules/es.weak-map.constructor": ["es.weak-map.constructor"],
  "core-js/modules/es.weak-set": ["es.weak-set"],
  "core-js/modules/es.weak-set.constructor": ["es.weak-set.constructor"],
  "core-js/modules/esnext.aggregate-error": ["esnext.aggregate-error"],
  "core-js/modules/esnext.array-buffer.detached": ["esnext.array-buffer.detached"],
  "core-js/modules/esnext.array-buffer.transfer": ["esnext.array-buffer.transfer"],
  "core-js/modules/esnext.array-buffer.transfer-to-fixed-length": ["esnext.array-buffer.transfer-to-fixed-length"],
  "core-js/modules/esnext.array.at": ["esnext.array.at"],
  "core-js/modules/esnext.array.filter-out": ["esnext.array.filter-out"],
  "core-js/modules/esnext.array.filter-reject": ["esnext.array.filter-reject"],
  "core-js/modules/esnext.array.find-last": ["esnext.array.find-last"],
  "core-js/modules/esnext.array.find-last-index": ["esnext.array.find-last-index"],
  "core-js/modules/esnext.array.from-async": ["esnext.array.from-async"],
  "core-js/modules/esnext.array.group": ["esnext.array.group"],
  "core-js/modules/esnext.array.group-by": ["esnext.array.group-by"],
  "core-js/modules/esnext.array.group-by-to-map": ["esnext.array.group-by-to-map"],
  "core-js/modules/esnext.array.group-to-map": ["esnext.array.group-to-map"],
  "core-js/modules/esnext.array.is-template-object": ["esnext.array.is-template-object"],
  "core-js/modules/esnext.array.last-index": ["esnext.array.last-index"],
  "core-js/modules/esnext.array.last-item": ["esnext.array.last-item"],
  "core-js/modules/esnext.array.to-reversed": ["esnext.array.to-reversed"],
  "core-js/modules/esnext.array.to-sorted": ["esnext.array.to-sorted"],
  "core-js/modules/esnext.array.to-spliced": ["esnext.array.to-spliced"],
  "core-js/modules/esnext.array.unique-by": ["esnext.array.unique-by"],
  "core-js/modules/esnext.array.with": ["esnext.array.with"],
  "core-js/modules/esnext.async-disposable-stack.constructor": ["esnext.async-disposable-stack.constructor"],
  "core-js/modules/esnext.async-iterator.as-indexed-pairs": ["esnext.async-iterator.as-indexed-pairs"],
  "core-js/modules/esnext.async-iterator.async-dispose": ["esnext.async-iterator.async-dispose"],
  "core-js/modules/esnext.async-iterator.constructor": ["esnext.async-iterator.constructor"],
  "core-js/modules/esnext.async-iterator.drop": ["esnext.async-iterator.drop"],
  "core-js/modules/esnext.async-iterator.every": ["esnext.async-iterator.every"],
  "core-js/modules/esnext.async-iterator.filter": ["esnext.async-iterator.filter"],
  "core-js/modules/esnext.async-iterator.find": ["esnext.async-iterator.find"],
  "core-js/modules/esnext.async-iterator.flat-map": ["esnext.async-iterator.flat-map"],
  "core-js/modules/esnext.async-iterator.for-each": ["esnext.async-iterator.for-each"],
  "core-js/modules/esnext.async-iterator.from": ["esnext.async-iterator.from"],
  "core-js/modules/esnext.async-iterator.indexed": ["esnext.async-iterator.indexed"],
  "core-js/modules/esnext.async-iterator.map": ["esnext.async-iterator.map"],
  "core-js/modules/esnext.async-iterator.reduce": ["esnext.async-iterator.reduce"],
  "core-js/modules/esnext.async-iterator.some": ["esnext.async-iterator.some"],
  "core-js/modules/esnext.async-iterator.take": ["esnext.async-iterator.take"],
  "core-js/modules/esnext.async-iterator.to-array": ["esnext.async-iterator.to-array"],
  "core-js/modules/esnext.bigint.range": ["esnext.bigint.range"],
  "core-js/modules/esnext.composite-key": ["esnext.composite-key"],
  "core-js/modules/esnext.composite-symbol": ["esnext.composite-symbol"],
  "core-js/modules/esnext.disposable-stack.constructor": ["esnext.disposable-stack.constructor"],
  "core-js/modules/esnext.function.demethodize": ["esnext.function.demethodize"],
  "core-js/modules/esnext.function.is-callable": ["esnext.function.is-callable"],
  "core-js/modules/esnext.function.is-constructor": ["esnext.function.is-constructor"],
  "core-js/modules/esnext.function.metadata": ["esnext.function.metadata"],
  "core-js/modules/esnext.function.un-this": ["esnext.function.un-this"],
  "core-js/modules/esnext.global-this": ["esnext.global-this"],
  "core-js/modules/esnext.iterator.as-indexed-pairs": ["esnext.iterator.as-indexed-pairs"],
  "core-js/modules/esnext.iterator.constructor": ["esnext.iterator.constructor"],
  "core-js/modules/esnext.iterator.dispose": ["esnext.iterator.dispose"],
  "core-js/modules/esnext.iterator.drop": ["esnext.iterator.drop"],
  "core-js/modules/esnext.iterator.every": ["esnext.iterator.every"],
  "core-js/modules/esnext.iterator.filter": ["esnext.iterator.filter"],
  "core-js/modules/esnext.iterator.find": ["esnext.iterator.find"],
  "core-js/modules/esnext.iterator.flat-map": ["esnext.iterator.flat-map"],
  "core-js/modules/esnext.iterator.for-each": ["esnext.iterator.for-each"],
  "core-js/modules/esnext.iterator.from": ["esnext.iterator.from"],
  "core-js/modules/esnext.iterator.indexed": ["esnext.iterator.indexed"],
  "core-js/modules/esnext.iterator.map": ["esnext.iterator.map"],
  "core-js/modules/esnext.iterator.range": ["esnext.iterator.range"],
  "core-js/modules/esnext.iterator.reduce": ["esnext.iterator.reduce"],
  "core-js/modules/esnext.iterator.some": ["esnext.iterator.some"],
  "core-js/modules/esnext.iterator.take": ["esnext.iterator.take"],
  "core-js/modules/esnext.iterator.to-array": ["esnext.iterator.to-array"],
  "core-js/modules/esnext.iterator.to-async": ["esnext.iterator.to-async"],
  "core-js/modules/esnext.json.is-raw-json": ["esnext.json.is-raw-json"],
  "core-js/modules/esnext.json.parse": ["esnext.json.parse"],
  "core-js/modules/esnext.json.raw-json": ["esnext.json.raw-json"],
  "core-js/modules/esnext.map.delete-all": ["esnext.map.delete-all"],
  "core-js/modules/esnext.map.emplace": ["esnext.map.emplace"],
  "core-js/modules/esnext.map.every": ["esnext.map.every"],
  "core-js/modules/esnext.map.filter": ["esnext.map.filter"],
  "core-js/modules/esnext.map.find": ["esnext.map.find"],
  "core-js/modules/esnext.map.find-key": ["esnext.map.find-key"],
  "core-js/modules/esnext.map.from": ["esnext.map.from"],
  "core-js/modules/esnext.map.group-by": ["esnext.map.group-by"],
  "core-js/modules/esnext.map.includes": ["esnext.map.includes"],
  "core-js/modules/esnext.map.key-by": ["esnext.map.key-by"],
  "core-js/modules/esnext.map.key-of": ["esnext.map.key-of"],
  "core-js/modules/esnext.map.map-keys": ["esnext.map.map-keys"],
  "core-js/modules/esnext.map.map-values": ["esnext.map.map-values"],
  "core-js/modules/esnext.map.merge": ["esnext.map.merge"],
  "core-js/modules/esnext.map.of": ["esnext.map.of"],
  "core-js/modules/esnext.map.reduce": ["esnext.map.reduce"],
  "core-js/modules/esnext.map.some": ["esnext.map.some"],
  "core-js/modules/esnext.map.update": ["esnext.map.update"],
  "core-js/modules/esnext.map.update-or-insert": ["esnext.map.update-or-insert"],
  "core-js/modules/esnext.map.upsert": ["esnext.map.upsert"],
  "core-js/modules/esnext.math.clamp": ["esnext.math.clamp"],
  "core-js/modules/esnext.math.deg-per-rad": ["esnext.math.deg-per-rad"],
  "core-js/modules/esnext.math.degrees": ["esnext.math.degrees"],
  "core-js/modules/esnext.math.fscale": ["esnext.math.fscale"],
  "core-js/modules/esnext.math.iaddh": ["esnext.math.iaddh"],
  "core-js/modules/esnext.math.imulh": ["esnext.math.imulh"],
  "core-js/modules/esnext.math.isubh": ["esnext.math.isubh"],
  "core-js/modules/esnext.math.rad-per-deg": ["esnext.math.rad-per-deg"],
  "core-js/modules/esnext.math.radians": ["esnext.math.radians"],
  "core-js/modules/esnext.math.scale": ["esnext.math.scale"],
  "core-js/modules/esnext.math.seeded-prng": ["esnext.math.seeded-prng"],
  "core-js/modules/esnext.math.signbit": ["esnext.math.signbit"],
  "core-js/modules/esnext.math.umulh": ["esnext.math.umulh"],
  "core-js/modules/esnext.number.from-string": ["esnext.number.from-string"],
  "core-js/modules/esnext.number.range": ["esnext.number.range"],
  "core-js/modules/esnext.object.group-by": ["esnext.object.group-by"],
  "core-js/modules/esnext.object.has-own": ["esnext.object.has-own"],
  "core-js/modules/esnext.object.iterate-entries": ["esnext.object.iterate-entries"],
  "core-js/modules/esnext.object.iterate-keys": ["esnext.object.iterate-keys"],
  "core-js/modules/esnext.object.iterate-values": ["esnext.object.iterate-values"],
  "core-js/modules/esnext.observable": ["esnext.observable"],
  "core-js/modules/esnext.observable.constructor": ["esnext.observable.constructor"],
  "core-js/modules/esnext.observable.from": ["esnext.observable.from"],
  "core-js/modules/esnext.observable.of": ["esnext.observable.of"],
  "core-js/modules/esnext.promise.all-settled": ["esnext.promise.all-settled"],
  "core-js/modules/esnext.promise.any": ["esnext.promise.any"],
  "core-js/modules/esnext.promise.try": ["esnext.promise.try"],
  "core-js/modules/esnext.promise.with-resolvers": ["esnext.promise.with-resolvers"],
  "core-js/modules/esnext.reflect.define-metadata": ["esnext.reflect.define-metadata"],
  "core-js/modules/esnext.reflect.delete-metadata": ["esnext.reflect.delete-metadata"],
  "core-js/modules/esnext.reflect.get-metadata": ["esnext.reflect.get-metadata"],
  "core-js/modules/esnext.reflect.get-metadata-keys": ["esnext.reflect.get-metadata-keys"],
  "core-js/modules/esnext.reflect.get-own-metadata": ["esnext.reflect.get-own-metadata"],
  "core-js/modules/esnext.reflect.get-own-metadata-keys": ["esnext.reflect.get-own-metadata-keys"],
  "core-js/modules/esnext.reflect.has-metadata": ["esnext.reflect.has-metadata"],
  "core-js/modules/esnext.reflect.has-own-metadata": ["esnext.reflect.has-own-metadata"],
  "core-js/modules/esnext.reflect.metadata": ["esnext.reflect.metadata"],
  "core-js/modules/esnext.set.add-all": ["esnext.set.add-all"],
  "core-js/modules/esnext.set.delete-all": ["esnext.set.delete-all"],
  "core-js/modules/esnext.set.difference": ["esnext.set.difference"],
  "core-js/modules/esnext.set.difference.v2": ["esnext.set.difference.v2"],
  "core-js/modules/esnext.set.every": ["esnext.set.every"],
  "core-js/modules/esnext.set.filter": ["esnext.set.filter"],
  "core-js/modules/esnext.set.find": ["esnext.set.find"],
  "core-js/modules/esnext.set.from": ["esnext.set.from"],
  "core-js/modules/esnext.set.intersection": ["esnext.set.intersection"],
  "core-js/modules/esnext.set.intersection.v2": ["esnext.set.intersection.v2"],
  "core-js/modules/esnext.set.is-disjoint-from": ["esnext.set.is-disjoint-from"],
  "core-js/modules/esnext.set.is-disjoint-from.v2": ["esnext.set.is-disjoint-from.v2"],
  "core-js/modules/esnext.set.is-subset-of": ["esnext.set.is-subset-of"],
  "core-js/modules/esnext.set.is-subset-of.v2": ["esnext.set.is-subset-of.v2"],
  "core-js/modules/esnext.set.is-superset-of": ["esnext.set.is-superset-of"],
  "core-js/modules/esnext.set.is-superset-of.v2": ["esnext.set.is-superset-of.v2"],
  "core-js/modules/esnext.set.join": ["esnext.set.join"],
  "core-js/modules/esnext.set.map": ["esnext.set.map"],
  "core-js/modules/esnext.set.of": ["esnext.set.of"],
  "core-js/modules/esnext.set.reduce": ["esnext.set.reduce"],
  "core-js/modules/esnext.set.some": ["esnext.set.some"],
  "core-js/modules/esnext.set.symmetric-difference": ["esnext.set.symmetric-difference"],
  "core-js/modules/esnext.set.symmetric-difference.v2": ["esnext.set.symmetric-difference.v2"],
  "core-js/modules/esnext.set.union": ["esnext.set.union"],
  "core-js/modules/esnext.set.union.v2": ["esnext.set.union.v2"],
  "core-js/modules/esnext.string.at": ["esnext.string.at"],
  "core-js/modules/esnext.string.at-alternative": ["esnext.string.at-alternative"],
  "core-js/modules/esnext.string.code-points": ["esnext.string.code-points"],
  "core-js/modules/esnext.string.cooked": ["esnext.string.cooked"],
  "core-js/modules/esnext.string.dedent": ["esnext.string.dedent"],
  "core-js/modules/esnext.string.is-well-formed": ["esnext.string.is-well-formed"],
  "core-js/modules/esnext.string.match-all": ["esnext.string.match-all"],
  "core-js/modules/esnext.string.replace-all": ["esnext.string.replace-all"],
  "core-js/modules/esnext.string.to-well-formed": ["esnext.string.to-well-formed"],
  "core-js/modules/esnext.suppressed-error.constructor": ["esnext.suppressed-error.constructor"],
  "core-js/modules/esnext.symbol.async-dispose": ["esnext.symbol.async-dispose"],
  "core-js/modules/esnext.symbol.dispose": ["esnext.symbol.dispose"],
  "core-js/modules/esnext.symbol.is-registered": ["esnext.symbol.is-registered"],
  "core-js/modules/esnext.symbol.is-registered-symbol": ["esnext.symbol.is-registered-symbol"],
  "core-js/modules/esnext.symbol.is-well-known": ["esnext.symbol.is-well-known"],
  "core-js/modules/esnext.symbol.is-well-known-symbol": ["esnext.symbol.is-well-known-symbol"],
  "core-js/modules/esnext.symbol.matcher": ["esnext.symbol.matcher"],
  "core-js/modules/esnext.symbol.metadata": ["esnext.symbol.metadata"],
  "core-js/modules/esnext.symbol.metadata-key": ["esnext.symbol.metadata-key"],
  "core-js/modules/esnext.symbol.observable": ["esnext.symbol.observable"],
  "core-js/modules/esnext.symbol.pattern-match": ["esnext.symbol.pattern-match"],
  "core-js/modules/esnext.symbol.replace-all": ["esnext.symbol.replace-all"],
  "core-js/modules/esnext.typed-array.at": ["esnext.typed-array.at"],
  "core-js/modules/esnext.typed-array.filter-out": ["esnext.typed-array.filter-out"],
  "core-js/modules/esnext.typed-array.filter-reject": ["esnext.typed-array.filter-reject"],
  "core-js/modules/esnext.typed-array.find-last": ["esnext.typed-array.find-last"],
  "core-js/modules/esnext.typed-array.find-last-index": ["esnext.typed-array.find-last-index"],
  "core-js/modules/esnext.typed-array.from-async": ["esnext.typed-array.from-async"],
  "core-js/modules/esnext.typed-array.group-by": ["esnext.typed-array.group-by"],
  "core-js/modules/esnext.typed-array.to-reversed": ["esnext.typed-array.to-reversed"],
  "core-js/modules/esnext.typed-array.to-sorted": ["esnext.typed-array.to-sorted"],
  "core-js/modules/esnext.typed-array.to-spliced": ["esnext.typed-array.to-spliced"],
  "core-js/modules/esnext.typed-array.unique-by": ["esnext.typed-array.unique-by"],
  "core-js/modules/esnext.typed-array.with": ["esnext.typed-array.with"],
  "core-js/modules/esnext.weak-map.delete-all": ["esnext.weak-map.delete-all"],
  "core-js/modules/esnext.weak-map.emplace": ["esnext.weak-map.emplace"],
  "core-js/modules/esnext.weak-map.from": ["esnext.weak-map.from"],
  "core-js/modules/esnext.weak-map.of": ["esnext.weak-map.of"],
  "core-js/modules/esnext.weak-map.upsert": ["esnext.weak-map.upsert"],
  "core-js/modules/esnext.weak-set.add-all": ["esnext.weak-set.add-all"],
  "core-js/modules/esnext.weak-set.delete-all": ["esnext.weak-set.delete-all"],
  "core-js/modules/esnext.weak-set.from": ["esnext.weak-set.from"],
  "core-js/modules/esnext.weak-set.of": ["esnext.weak-set.of"],
  "core-js/modules/web.atob": ["web.atob"],
  "core-js/modules/web.btoa": ["web.btoa"],
  "core-js/modules/web.clear-immediate": ["web.clear-immediate"],
  "core-js/modules/web.dom-collections.for-each": ["web.dom-collections.for-each"],
  "core-js/modules/web.dom-collections.iterator": ["web.dom-collections.iterator"],
  "core-js/modules/web.dom-exception.constructor": ["web.dom-exception.constructor"],
  "core-js/modules/web.dom-exception.stack": ["web.dom-exception.stack"],
  "core-js/modules/web.dom-exception.to-string-tag": ["web.dom-exception.to-string-tag"],
  "core-js/modules/web.immediate": ["web.immediate"],
  "core-js/modules/web.queue-microtask": ["web.queue-microtask"],
  "core-js/modules/web.self": ["web.self"],
  "core-js/modules/web.set-immediate": ["web.set-immediate"],
  "core-js/modules/web.set-interval": ["web.set-interval"],
  "core-js/modules/web.set-timeout": ["web.set-timeout"],
  "core-js/modules/web.structured-clone": ["web.structured-clone"],
  "core-js/modules/web.timers": ["web.timers"],
  "core-js/modules/web.url": ["web.url"],
  "core-js/modules/web.url-search-params": ["web.url-search-params"],
  "core-js/modules/web.url-search-params.constructor": ["web.url-search-params.constructor"],
  "core-js/modules/web.url-search-params.delete": ["web.url-search-params.delete"],
  "core-js/modules/web.url-search-params.has": ["web.url-search-params.has"],
  "core-js/modules/web.url-search-params.size": ["web.url-search-params.size"],
  "core-js/modules/web.url.can-parse": ["web.url.can-parse"],
  "core-js/modules/web.url.constructor": ["web.url.constructor"],
  "core-js/modules/web.url.to-json": ["web.url.to-json"],
  "core-js/proposals": [
    "es.map",
    "es.string.at-alternative",
    "esnext.aggregate-error",
    "esnext.suppressed-error.constructor",
    "esnext.array.from-async",
    "esnext.array.at",
    "esnext.array.filter-out",
    "esnext.array.filter-reject",
    "esnext.array.find-last",
    "esnext.array.find-last-index",
    "esnext.array.group",
    "esnext.array.group-by",
    "esnext.array.group-by-to-map",
    "esnext.array.group-to-map",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.array.to-reversed",
    "esnext.array.to-sorted",
    "esnext.array.to-spliced",
    "esnext.array.unique-by",
    "esnext.array.with",
    "esnext.array-buffer.detached",
    "esnext.array-buffer.transfer",
    "esnext.array-buffer.transfer-to-fixed-length",
    "esnext.async-disposable-stack.constructor",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.async-dispose",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.indexed",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.bigint.range",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.disposable-stack.constructor",
    "esnext.function.demethodize",
    "esnext.function.is-callable",
    "esnext.function.is-constructor",
    "esnext.function.metadata",
    "esnext.function.un-this",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.dispose",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.indexed",
    "esnext.iterator.map",
    "esnext.iterator.range",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.iterator.to-async",
    "esnext.json.is-raw-json",
    "esnext.json.parse",
    "esnext.json.raw-json",
    "esnext.map.delete-all",
    "esnext.map.emplace",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.number.range",
    "esnext.object.has-own",
    "esnext.object.iterate-entries",
    "esnext.object.iterate-keys",
    "esnext.object.iterate-values",
    "esnext.object.group-by",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.promise.with-resolvers",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference.v2",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection.v2",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from.v2",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of.v2",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of.v2",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference.v2",
    "esnext.set.symmetric-difference",
    "esnext.set.union.v2",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.cooked",
    "esnext.string.code-points",
    "esnext.string.dedent",
    "esnext.string.is-well-formed",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.string.to-well-formed",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.is-registered-symbol",
    "esnext.symbol.is-registered",
    "esnext.symbol.is-well-known-symbol",
    "esnext.symbol.is-well-known",
    "esnext.symbol.matcher",
    "esnext.symbol.metadata",
    "esnext.symbol.metadata-key",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.emplace",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.url",
    "web.url.can-parse",
    "web.url.to-json",
    "web.url-search-params",
    "web.url-search-params.delete",
    "web.url-search-params.has",
    "web.url-search-params.size"
  ],
  "core-js/proposals/accessible-object-hasownproperty": ["esnext.object.has-own"],
  "core-js/proposals/array-buffer-transfer": [
    "esnext.array-buffer.detached",
    "esnext.array-buffer.transfer",
    "esnext.array-buffer.transfer-to-fixed-length"
  ],
  "core-js/proposals/array-filtering": [
    "esnext.array.filter-out",
    "esnext.array.filter-reject",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject"
  ],
  "core-js/proposals/array-filtering-stage-1": ["esnext.array.filter-reject", "esnext.typed-array.filter-reject"],
  "core-js/proposals/array-find-from-last": [
    "esnext.array.find-last",
    "esnext.array.find-last-index",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index"
  ],
  "core-js/proposals/array-flat-map": [
    "es.array.flat",
    "es.array.flat-map",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map"
  ],
  "core-js/proposals/array-from-async": ["esnext.array.from-async", "esnext.typed-array.from-async"],
  "core-js/proposals/array-from-async-stage-2": ["esnext.array.from-async"],
  "core-js/proposals/array-grouping": [
    "esnext.array.group-by",
    "esnext.array.group-by-to-map",
    "esnext.typed-array.group-by"
  ],
  "core-js/proposals/array-grouping-stage-3": ["esnext.array.group-by", "esnext.array.group-by-to-map"],
  "core-js/proposals/array-grouping-stage-3-2": ["esnext.array.group", "esnext.array.group-to-map"],
  "core-js/proposals/array-grouping-v2": ["esnext.map.group-by", "esnext.object.group-by"],
  "core-js/proposals/array-includes": ["es.array.includes", "es.typed-array.includes"],
  "core-js/proposals/array-is-template-object": ["esnext.array.is-template-object"],
  "core-js/proposals/array-last": ["esnext.array.last-index", "esnext.array.last-item"],
  "core-js/proposals/array-unique": ["es.map", "esnext.array.unique-by", "esnext.typed-array.unique-by"],
  "core-js/proposals/async-explicit-resource-management": [
    "esnext.suppressed-error.constructor",
    "esnext.async-disposable-stack.constructor",
    "esnext.async-iterator.async-dispose",
    "esnext.symbol.async-dispose"
  ],
  "core-js/proposals/async-iteration": ["es.symbol.async-iterator"],
  "core-js/proposals/async-iterator-helpers": [
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.iterator.to-async"
  ],
  "core-js/proposals/change-array-by-copy": [
    "esnext.array.to-reversed",
    "esnext.array.to-sorted",
    "esnext.array.to-spliced",
    "esnext.array.with",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.with"
  ],
  "core-js/proposals/change-array-by-copy-stage-4": [
    "esnext.array.to-reversed",
    "esnext.array.to-sorted",
    "esnext.array.to-spliced",
    "esnext.array.with",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.with"
  ],
  "core-js/proposals/collection-methods": [
    "esnext.map.delete-all",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.weak-map.delete-all",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all"
  ],
  "core-js/proposals/collection-of-from": [
    "esnext.map.from",
    "esnext.map.of",
    "esnext.set.from",
    "esnext.set.of",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-set.from",
    "esnext.weak-set.of"
  ],
  "core-js/proposals/decorator-metadata": ["esnext.symbol.metadata-key"],
  "core-js/proposals/decorator-metadata-v2": ["esnext.function.metadata", "esnext.symbol.metadata"],
  "core-js/proposals/decorators": ["esnext.symbol.metadata"],
  "core-js/proposals/efficient-64-bit-arithmetic": [
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.umulh"
  ],
  "core-js/proposals/error-cause": ["es.error.cause", "es.aggregate-error.cause"],
  "core-js/proposals/explicit-resource-management": [
    "esnext.suppressed-error.constructor",
    "esnext.disposable-stack.constructor",
    "esnext.iterator.dispose",
    "esnext.symbol.dispose"
  ],
  "core-js/proposals/function-demethodize": ["esnext.function.demethodize"],
  "core-js/proposals/function-is-callable-is-constructor": [
    "esnext.function.is-callable",
    "esnext.function.is-constructor"
  ],
  "core-js/proposals/function-un-this": ["esnext.function.un-this"],
  "core-js/proposals/global-this": ["esnext.global-this"],
  "core-js/proposals/iterator-helpers": [
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.indexed",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.indexed",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.iterator.to-async"
  ],
  "core-js/proposals/iterator-helpers-stage-3": [
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.iterator.constructor",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.iterator.to-async"
  ],
  "core-js/proposals/iterator-helpers-stage-3-2": [
    "esnext.iterator.constructor",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array"
  ],
  "core-js/proposals/iterator-range": ["esnext.iterator.constructor", "esnext.iterator.range"],
  "core-js/proposals/json-parse-with-source": ["esnext.json.is-raw-json", "esnext.json.parse", "esnext.json.raw-json"],
  "core-js/proposals/keys-composition": ["esnext.composite-key", "esnext.composite-symbol"],
  "core-js/proposals/map-update-or-insert": [
    "esnext.map.emplace",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.weak-map.emplace",
    "esnext.weak-map.upsert"
  ],
  "core-js/proposals/map-upsert": [
    "esnext.map.emplace",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.weak-map.emplace",
    "esnext.weak-map.upsert"
  ],
  "core-js/proposals/map-upsert-stage-2": ["esnext.map.emplace", "esnext.weak-map.emplace"],
  "core-js/proposals/math-extensions": [
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale"
  ],
  "core-js/proposals/math-signbit": ["esnext.math.signbit"],
  "core-js/proposals/number-from-string": ["esnext.number.from-string"],
  "core-js/proposals/number-range": ["esnext.bigint.range", "esnext.number.range"],
  "core-js/proposals/object-from-entries": ["es.object.from-entries"],
  "core-js/proposals/object-getownpropertydescriptors": ["es.object.get-own-property-descriptors"],
  "core-js/proposals/object-iteration": [
    "esnext.object.iterate-entries",
    "esnext.object.iterate-keys",
    "esnext.object.iterate-values"
  ],
  "core-js/proposals/object-values-entries": ["es.object.entries", "es.object.values"],
  "core-js/proposals/observable": ["esnext.observable", "esnext.symbol.observable"],
  "core-js/proposals/pattern-matching": ["esnext.symbol.matcher", "esnext.symbol.pattern-match"],
  "core-js/proposals/promise-all-settled": ["esnext.promise.all-settled"],
  "core-js/proposals/promise-any": ["esnext.aggregate-error", "esnext.promise.any"],
  "core-js/proposals/promise-finally": ["es.promise.finally"],
  "core-js/proposals/promise-try": ["esnext.promise.try"],
  "core-js/proposals/promise-with-resolvers": ["esnext.promise.with-resolvers"],
  "core-js/proposals/reflect-metadata": [
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata"
  ],
  "core-js/proposals/regexp-dotall-flag": [
    "es.regexp.constructor",
    "es.regexp.dot-all",
    "es.regexp.exec",
    "es.regexp.flags"
  ],
  "core-js/proposals/regexp-named-groups": ["es.regexp.constructor", "es.regexp.exec", "es.string.replace"],
  "core-js/proposals/relative-indexing-method": [
    "es.string.at-alternative",
    "esnext.array.at",
    "esnext.typed-array.at"
  ],
  "core-js/proposals/seeded-random": ["esnext.math.seeded-prng"],
  "core-js/proposals/set-methods": [
    "esnext.set.difference.v2",
    "esnext.set.difference",
    "esnext.set.intersection.v2",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from.v2",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of.v2",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of.v2",
    "esnext.set.is-superset-of",
    "esnext.set.symmetric-difference.v2",
    "esnext.set.symmetric-difference",
    "esnext.set.union.v2",
    "esnext.set.union"
  ],
  "core-js/proposals/set-methods-v2": [
    "esnext.set.difference.v2",
    "esnext.set.intersection.v2",
    "esnext.set.is-disjoint-from.v2",
    "esnext.set.is-subset-of.v2",
    "esnext.set.is-superset-of.v2",
    "esnext.set.symmetric-difference.v2",
    "esnext.set.union.v2"
  ],
  "core-js/proposals/string-at": ["esnext.string.at"],
  "core-js/proposals/string-code-points": ["esnext.string.code-points"],
  "core-js/proposals/string-cooked": ["esnext.string.cooked"],
  "core-js/proposals/string-dedent": ["esnext.string.dedent"],
  "core-js/proposals/string-left-right-trim": ["es.string.trim-end", "es.string.trim-start"],
  "core-js/proposals/string-match-all": ["esnext.string.match-all"],
  "core-js/proposals/string-padding": ["es.string.pad-end", "es.string.pad-start"],
  "core-js/proposals/string-replace-all": ["esnext.string.replace-all", "esnext.symbol.replace-all"],
  "core-js/proposals/string-replace-all-stage-4": ["esnext.string.replace-all"],
  "core-js/proposals/symbol-description": ["es.symbol.description"],
  "core-js/proposals/symbol-predicates": ["esnext.symbol.is-registered", "esnext.symbol.is-well-known"],
  "core-js/proposals/symbol-predicates-v2": [
    "esnext.symbol.is-registered-symbol",
    "esnext.symbol.is-well-known-symbol"
  ],
  "core-js/proposals/url": [
    "web.url",
    "web.url.can-parse",
    "web.url.to-json",
    "web.url-search-params",
    "web.url-search-params.delete",
    "web.url-search-params.has",
    "web.url-search-params.size"
  ],
  "core-js/proposals/using-statement": ["esnext.symbol.async-dispose", "esnext.symbol.dispose"],
  "core-js/proposals/well-formed-stringify": ["es.json.stringify"],
  "core-js/proposals/well-formed-unicode-strings": ["esnext.string.is-well-formed", "esnext.string.to-well-formed"],
  "core-js/stable": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.error.cause",
    "es.error.to-string",
    "es.aggregate-error",
    "es.aggregate-error.cause",
    "es.array.at",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.find-last",
    "es.array.find-last-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.push",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.to-reversed",
    "es.array.to-sorted",
    "es.array.to-spliced",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array.unshift",
    "es.array.with",
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.data-view",
    "es.date.get-year",
    "es.date.now",
    "es.date.set-year",
    "es.date.to-gmt-string",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string",
    "es.escape",
    "es.function.bind",
    "es.function.has-instance",
    "es.function.name",
    "es.global-this",
    "es.json.stringify",
    "es.json.to-string-tag",
    "es.map",
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc",
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-exponential",
    "es.number.to-fixed",
    "es.number.to-precision",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.has-own",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.proto",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.parse-float",
    "es.parse-int",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.any",
    "es.promise.finally",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.reflect.to-string-tag",
    "es.regexp.constructor",
    "es.regexp.dot-all",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.sticky",
    "es.regexp.test",
    "es.regexp.to-string",
    "es.set",
    "es.string.at-alternative",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.is-well-formed",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.replace-all",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.substr",
    "es.string.to-well-formed",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with",
    "es.unescape",
    "es.weak-map",
    "es.weak-set",
    "web.atob",
    "web.btoa",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag",
    "web.immediate",
    "web.queue-microtask",
    "web.self",
    "web.structured-clone",
    "web.timers",
    "web.url",
    "web.url.can-parse",
    "web.url.to-json",
    "web.url-search-params",
    "web.url-search-params.delete",
    "web.url-search-params.has",
    "web.url-search-params.size"
  ],
  "core-js/stable/aggregate-error": [
    "es.error.cause",
    "es.aggregate-error",
    "es.aggregate-error.cause",
    "es.array.iterator",
    "es.string.iterator",
    "esnext.aggregate-error",
    "web.dom-collections.iterator"
  ],
  "core-js/stable/array": [
    "es.array.at",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.find-last",
    "es.array.find-last-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.from",
    "es.array.includes",
    "es.array.index-of",
    "es.array.is-array",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.of",
    "es.array.push",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.to-reversed",
    "es.array.to-sorted",
    "es.array.to-spliced",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array.unshift",
    "es.array.with",
    "es.object.to-string",
    "es.string.iterator"
  ],
  "core-js/stable/array-buffer": [
    "es.array-buffer.constructor",
    "es.array-buffer.is-view",
    "es.array-buffer.slice",
    "es.object.to-string"
  ],
  "core-js/stable/array-buffer/constructor": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string"
  ],
  "core-js/stable/array-buffer/is-view": ["es.array-buffer.is-view"],
  "core-js/stable/array-buffer/slice": ["es.array-buffer.slice"],
  "core-js/stable/array/at": ["es.array.at"],
  "core-js/stable/array/concat": ["es.array.concat"],
  "core-js/stable/array/copy-within": ["es.array.copy-within"],
  "core-js/stable/array/entries": ["es.array.iterator", "es.object.to-string"],
  "core-js/stable/array/every": ["es.array.every"],
  "core-js/stable/array/fill": ["es.array.fill"],
  "core-js/stable/array/filter": ["es.array.filter"],
  "core-js/stable/array/find": ["es.array.find"],
  "core-js/stable/array/find-index": ["es.array.find-index"],
  "core-js/stable/array/find-last": ["es.array.find-last"],
  "core-js/stable/array/find-last-index": ["es.array.find-last-index"],
  "core-js/stable/array/flat": ["es.array.flat", "es.array.unscopables.flat"],
  "core-js/stable/array/flat-map": ["es.array.flat-map", "es.array.unscopables.flat-map"],
  "core-js/stable/array/for-each": ["es.array.for-each"],
  "core-js/stable/array/from": ["es.array.from", "es.string.iterator"],
  "core-js/stable/array/includes": ["es.array.includes"],
  "core-js/stable/array/index-of": ["es.array.index-of"],
  "core-js/stable/array/is-array": ["es.array.is-array"],
  "core-js/stable/array/iterator": ["es.array.iterator", "es.object.to-string"],
  "core-js/stable/array/join": ["es.array.join"],
  "core-js/stable/array/keys": ["es.array.iterator", "es.object.to-string"],
  "core-js/stable/array/last-index-of": ["es.array.last-index-of"],
  "core-js/stable/array/map": ["es.array.map"],
  "core-js/stable/array/of": ["es.array.of"],
  "core-js/stable/array/push": ["es.array.push"],
  "core-js/stable/array/reduce": ["es.array.reduce"],
  "core-js/stable/array/reduce-right": ["es.array.reduce-right"],
  "core-js/stable/array/reverse": ["es.array.reverse"],
  "core-js/stable/array/slice": ["es.array.slice"],
  "core-js/stable/array/some": ["es.array.some"],
  "core-js/stable/array/sort": ["es.array.sort"],
  "core-js/stable/array/splice": ["es.array.splice"],
  "core-js/stable/array/to-reversed": ["es.array.to-reversed"],
  "core-js/stable/array/to-sorted": ["es.array.sort", "es.array.to-sorted"],
  "core-js/stable/array/to-spliced": ["es.array.to-spliced"],
  "core-js/stable/array/unshift": ["es.array.unshift"],
  "core-js/stable/array/values": ["es.array.iterator", "es.object.to-string"],
  "core-js/stable/array/virtual": [
    "es.array.at",
    "es.array.concat",
    "es.array.copy-within",
    "es.array.every",
    "es.array.fill",
    "es.array.filter",
    "es.array.find",
    "es.array.find-index",
    "es.array.find-last",
    "es.array.find-last-index",
    "es.array.flat",
    "es.array.flat-map",
    "es.array.for-each",
    "es.array.includes",
    "es.array.index-of",
    "es.array.iterator",
    "es.array.join",
    "es.array.last-index-of",
    "es.array.map",
    "es.array.push",
    "es.array.reduce",
    "es.array.reduce-right",
    "es.array.reverse",
    "es.array.slice",
    "es.array.some",
    "es.array.sort",
    "es.array.species",
    "es.array.splice",
    "es.array.to-reversed",
    "es.array.to-sorted",
    "es.array.to-spliced",
    "es.array.unscopables.flat",
    "es.array.unscopables.flat-map",
    "es.array.unshift",
    "es.array.with",
    "es.object.to-string"
  ],
  "core-js/stable/array/virtual/at": ["es.array.at"],
  "core-js/stable/array/virtual/concat": ["es.array.concat"],
  "core-js/stable/array/virtual/copy-within": ["es.array.copy-within"],
  "core-js/stable/array/virtual/entries": ["es.array.iterator", "es.object.to-string"],
  "core-js/stable/array/virtual/every": ["es.array.every"],
  "core-js/stable/array/virtual/fill": ["es.array.fill"],
  "core-js/stable/array/virtual/filter": ["es.array.filter"],
  "core-js/stable/array/virtual/find": ["es.array.find"],
  "core-js/stable/array/virtual/find-index": ["es.array.find-index"],
  "core-js/stable/array/virtual/find-last": ["es.array.find-last"],
  "core-js/stable/array/virtual/find-last-index": ["es.array.find-last-index"],
  "core-js/stable/array/virtual/flat": ["es.array.flat", "es.array.unscopables.flat"],
  "core-js/stable/array/virtual/flat-map": ["es.array.flat-map", "es.array.unscopables.flat-map"],
  "core-js/stable/array/virtual/for-each": ["es.array.for-each"],
  "core-js/stable/array/virtual/includes": ["es.array.includes"],
  "core-js/stable/array/virtual/index-of": ["es.array.index-of"],
  "core-js/stable/array/virtual/iterator": ["es.array.iterator", "es.object.to-string"],
  "core-js/stable/array/virtual/join": ["es.array.join"],
  "core-js/stable/array/virtual/keys": ["es.array.iterator", "es.object.to-string"],
  "core-js/stable/array/virtual/last-index-of": ["es.array.last-index-of"],
  "core-js/stable/array/virtual/map": ["es.array.map"],
  "core-js/stable/array/virtual/push": ["es.array.push"],
  "core-js/stable/array/virtual/reduce": ["es.array.reduce"],
  "core-js/stable/array/virtual/reduce-right": ["es.array.reduce-right"],
  "core-js/stable/array/virtual/reverse": ["es.array.reverse"],
  "core-js/stable/array/virtual/slice": ["es.array.slice"],
  "core-js/stable/array/virtual/some": ["es.array.some"],
  "core-js/stable/array/virtual/sort": ["es.array.sort"],
  "core-js/stable/array/virtual/splice": ["es.array.splice"],
  "core-js/stable/array/virtual/to-reversed": ["es.array.to-reversed"],
  "core-js/stable/array/virtual/to-sorted": ["es.array.sort", "es.array.to-sorted"],
  "core-js/stable/array/virtual/to-spliced": ["es.array.to-spliced"],
  "core-js/stable/array/virtual/unshift": ["es.array.unshift"],
  "core-js/stable/array/virtual/values": ["es.array.iterator", "es.object.to-string"],
  "core-js/stable/array/virtual/with": ["es.array.with"],
  "core-js/stable/array/with": ["es.array.with"],
  "core-js/stable/atob": [
    "es.error.to-string",
    "es.object.to-string",
    "web.atob",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag"
  ],
  "core-js/stable/btoa": [
    "es.error.to-string",
    "es.object.to-string",
    "web.btoa",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag"
  ],
  "core-js/stable/clear-immediate": ["web.immediate"],
  "core-js/stable/data-view": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.data-view",
    "es.object.to-string"
  ],
  "core-js/stable/date": [
    "es.date.get-year",
    "es.date.now",
    "es.date.set-year",
    "es.date.to-gmt-string",
    "es.date.to-iso-string",
    "es.date.to-json",
    "es.date.to-primitive",
    "es.date.to-string"
  ],
  "core-js/stable/date/get-year": ["es.date.get-year"],
  "core-js/stable/date/now": ["es.date.now"],
  "core-js/stable/date/set-year": ["es.date.set-year"],
  "core-js/stable/date/to-gmt-string": ["es.date.to-gmt-string"],
  "core-js/stable/date/to-iso-string": ["es.date.to-iso-string", "es.date.to-json"],
  "core-js/stable/date/to-json": ["es.date.to-json"],
  "core-js/stable/date/to-primitive": ["es.date.to-primitive"],
  "core-js/stable/date/to-string": ["es.date.to-string"],
  "core-js/stable/dom-collections": [
    "es.array.iterator",
    "es.object.to-string",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator"
  ],
  "core-js/stable/dom-collections/for-each": ["web.dom-collections.for-each"],
  "core-js/stable/dom-collections/iterator": ["es.object.to-string", "web.dom-collections.iterator"],
  "core-js/stable/dom-exception": [
    "es.error.to-string",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag"
  ],
  "core-js/stable/dom-exception/constructor": [
    "es.error.to-string",
    "web.dom-exception.constructor",
    "web.dom-exception.stack"
  ],
  "core-js/stable/dom-exception/to-string-tag": ["web.dom-exception.to-string-tag"],
  "core-js/stable/error": ["es.error.cause", "es.error.to-string"],
  "core-js/stable/error/constructor": ["es.error.cause"],
  "core-js/stable/error/to-string": ["es.error.to-string"],
  "core-js/stable/escape": ["es.escape"],
  "core-js/stable/function": ["es.function.bind", "es.function.has-instance", "es.function.name"],
  "core-js/stable/function/bind": ["es.function.bind"],
  "core-js/stable/function/has-instance": ["es.function.has-instance"],
  "core-js/stable/function/name": ["es.function.name"],
  "core-js/stable/function/virtual": ["es.function.bind"],
  "core-js/stable/function/virtual/bind": ["es.function.bind"],
  "core-js/stable/get-iterator": ["es.array.iterator", "es.string.iterator", "web.dom-collections.iterator"],
  "core-js/stable/get-iterator-method": ["es.array.iterator", "es.string.iterator", "web.dom-collections.iterator"],
  "core-js/stable/global-this": ["es.global-this"],
  "core-js/stable/instance/at": ["es.array.at", "es.string.at-alternative"],
  "core-js/stable/instance/bind": ["es.function.bind"],
  "core-js/stable/instance/code-point-at": ["es.string.code-point-at"],
  "core-js/stable/instance/concat": ["es.array.concat"],
  "core-js/stable/instance/copy-within": ["es.array.copy-within"],
  "core-js/stable/instance/ends-with": ["es.string.ends-with"],
  "core-js/stable/instance/entries": ["es.array.iterator", "es.object.to-string", "web.dom-collections.iterator"],
  "core-js/stable/instance/every": ["es.array.every"],
  "core-js/stable/instance/fill": ["es.array.fill"],
  "core-js/stable/instance/filter": ["es.array.filter"],
  "core-js/stable/instance/find": ["es.array.find"],
  "core-js/stable/instance/find-index": ["es.array.find-index"],
  "core-js/stable/instance/find-last": ["es.array.find-last"],
  "core-js/stable/instance/find-last-index": ["es.array.find-last-index"],
  "core-js/stable/instance/flags": ["es.regexp.flags"],
  "core-js/stable/instance/flat": ["es.array.flat", "es.array.unscopables.flat"],
  "core-js/stable/instance/flat-map": ["es.array.flat-map", "es.array.unscopables.flat-map"],
  "core-js/stable/instance/for-each": ["es.array.for-each", "web.dom-collections.iterator"],
  "core-js/stable/instance/includes": ["es.array.includes", "es.string.includes"],
  "core-js/stable/instance/index-of": ["es.array.index-of"],
  "core-js/stable/instance/is-well-formed": ["es.string.is-well-formed"],
  "core-js/stable/instance/keys": ["es.array.iterator", "es.object.to-string", "web.dom-collections.iterator"],
  "core-js/stable/instance/last-index-of": ["es.array.last-index-of"],
  "core-js/stable/instance/map": ["es.array.map"],
  "core-js/stable/instance/match-all": ["es.object.to-string", "es.regexp.exec", "es.string.match-all"],
  "core-js/stable/instance/pad-end": ["es.string.pad-end"],
  "core-js/stable/instance/pad-start": ["es.string.pad-start"],
  "core-js/stable/instance/push": ["es.array.push"],
  "core-js/stable/instance/reduce": ["es.array.reduce"],
  "core-js/stable/instance/reduce-right": ["es.array.reduce-right"],
  "core-js/stable/instance/repeat": ["es.string.repeat"],
  "core-js/stable/instance/replace-all": ["es.regexp.exec", "es.string.replace", "es.string.replace-all"],
  "core-js/stable/instance/reverse": ["es.array.reverse"],
  "core-js/stable/instance/slice": ["es.array.slice"],
  "core-js/stable/instance/some": ["es.array.some"],
  "core-js/stable/instance/sort": ["es.array.sort"],
  "core-js/stable/instance/splice": ["es.array.splice"],
  "core-js/stable/instance/starts-with": ["es.string.starts-with"],
  "core-js/stable/instance/to-reversed": ["es.array.to-reversed"],
  "core-js/stable/instance/to-sorted": ["es.array.sort", "es.array.to-sorted"],
  "core-js/stable/instance/to-spliced": ["es.array.to-spliced"],
  "core-js/stable/instance/to-well-formed": ["es.string.to-well-formed"],
  "core-js/stable/instance/trim": ["es.string.trim"],
  "core-js/stable/instance/trim-end": ["es.string.trim-end"],
  "core-js/stable/instance/trim-left": ["es.string.trim-start"],
  "core-js/stable/instance/trim-right": ["es.string.trim-end"],
  "core-js/stable/instance/trim-start": ["es.string.trim-start"],
  "core-js/stable/instance/unshift": ["es.array.unshift"],
  "core-js/stable/instance/values": ["es.array.iterator", "es.object.to-string", "web.dom-collections.iterator"],
  "core-js/stable/instance/with": ["es.array.with"],
  "core-js/stable/is-iterable": ["es.array.iterator", "es.string.iterator", "web.dom-collections.iterator"],
  "core-js/stable/json": ["es.json.stringify", "es.json.to-string-tag"],
  "core-js/stable/json/stringify": ["es.json.stringify"],
  "core-js/stable/json/to-string-tag": ["es.json.to-string-tag"],
  "core-js/stable/map": [
    "es.array.iterator",
    "es.map",
    "es.object.to-string",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/stable/math": [
    "es.math.acosh",
    "es.math.asinh",
    "es.math.atanh",
    "es.math.cbrt",
    "es.math.clz32",
    "es.math.cosh",
    "es.math.expm1",
    "es.math.fround",
    "es.math.hypot",
    "es.math.imul",
    "es.math.log10",
    "es.math.log1p",
    "es.math.log2",
    "es.math.sign",
    "es.math.sinh",
    "es.math.tanh",
    "es.math.to-string-tag",
    "es.math.trunc"
  ],
  "core-js/stable/math/acosh": ["es.math.acosh"],
  "core-js/stable/math/asinh": ["es.math.asinh"],
  "core-js/stable/math/atanh": ["es.math.atanh"],
  "core-js/stable/math/cbrt": ["es.math.cbrt"],
  "core-js/stable/math/clz32": ["es.math.clz32"],
  "core-js/stable/math/cosh": ["es.math.cosh"],
  "core-js/stable/math/expm1": ["es.math.expm1"],
  "core-js/stable/math/fround": ["es.math.fround"],
  "core-js/stable/math/hypot": ["es.math.hypot"],
  "core-js/stable/math/imul": ["es.math.imul"],
  "core-js/stable/math/log10": ["es.math.log10"],
  "core-js/stable/math/log1p": ["es.math.log1p"],
  "core-js/stable/math/log2": ["es.math.log2"],
  "core-js/stable/math/sign": ["es.math.sign"],
  "core-js/stable/math/sinh": ["es.math.sinh"],
  "core-js/stable/math/tanh": ["es.math.tanh"],
  "core-js/stable/math/to-string-tag": ["es.math.to-string-tag"],
  "core-js/stable/math/trunc": ["es.math.trunc"],
  "core-js/stable/number": [
    "es.number.constructor",
    "es.number.epsilon",
    "es.number.is-finite",
    "es.number.is-integer",
    "es.number.is-nan",
    "es.number.is-safe-integer",
    "es.number.max-safe-integer",
    "es.number.min-safe-integer",
    "es.number.parse-float",
    "es.number.parse-int",
    "es.number.to-exponential",
    "es.number.to-fixed",
    "es.number.to-precision"
  ],
  "core-js/stable/number/constructor": ["es.number.constructor"],
  "core-js/stable/number/epsilon": ["es.number.epsilon"],
  "core-js/stable/number/is-finite": ["es.number.is-finite"],
  "core-js/stable/number/is-integer": ["es.number.is-integer"],
  "core-js/stable/number/is-nan": ["es.number.is-nan"],
  "core-js/stable/number/is-safe-integer": ["es.number.is-safe-integer"],
  "core-js/stable/number/max-safe-integer": ["es.number.max-safe-integer"],
  "core-js/stable/number/min-safe-integer": ["es.number.min-safe-integer"],
  "core-js/stable/number/parse-float": ["es.number.parse-float"],
  "core-js/stable/number/parse-int": ["es.number.parse-int"],
  "core-js/stable/number/to-exponential": ["es.number.to-exponential"],
  "core-js/stable/number/to-fixed": ["es.number.to-fixed"],
  "core-js/stable/number/to-precision": ["es.number.to-precision"],
  "core-js/stable/number/virtual": ["es.number.to-exponential", "es.number.to-fixed", "es.number.to-precision"],
  "core-js/stable/number/virtual/to-exponential": ["es.number.to-exponential"],
  "core-js/stable/number/virtual/to-fixed": ["es.number.to-fixed"],
  "core-js/stable/number/virtual/to-precision": ["es.number.to-precision"],
  "core-js/stable/object": [
    "es.symbol",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.assign",
    "es.object.create",
    "es.object.define-getter",
    "es.object.define-properties",
    "es.object.define-property",
    "es.object.define-setter",
    "es.object.entries",
    "es.object.freeze",
    "es.object.from-entries",
    "es.object.get-own-property-descriptor",
    "es.object.get-own-property-descriptors",
    "es.object.get-own-property-names",
    "es.object.get-prototype-of",
    "es.object.has-own",
    "es.object.is",
    "es.object.is-extensible",
    "es.object.is-frozen",
    "es.object.is-sealed",
    "es.object.keys",
    "es.object.lookup-getter",
    "es.object.lookup-setter",
    "es.object.prevent-extensions",
    "es.object.proto",
    "es.object.seal",
    "es.object.set-prototype-of",
    "es.object.to-string",
    "es.object.values",
    "es.reflect.to-string-tag",
    "web.dom-collections.iterator"
  ],
  "core-js/stable/object/assign": ["es.object.assign"],
  "core-js/stable/object/create": ["es.object.create"],
  "core-js/stable/object/define-getter": ["es.object.define-getter"],
  "core-js/stable/object/define-properties": ["es.object.define-properties"],
  "core-js/stable/object/define-property": ["es.object.define-property"],
  "core-js/stable/object/define-setter": ["es.object.define-setter"],
  "core-js/stable/object/entries": ["es.object.entries"],
  "core-js/stable/object/freeze": ["es.object.freeze"],
  "core-js/stable/object/from-entries": ["es.array.iterator", "es.object.from-entries", "web.dom-collections.iterator"],
  "core-js/stable/object/get-own-property-descriptor": ["es.object.get-own-property-descriptor"],
  "core-js/stable/object/get-own-property-descriptors": ["es.object.get-own-property-descriptors"],
  "core-js/stable/object/get-own-property-names": ["es.object.get-own-property-names"],
  "core-js/stable/object/get-own-property-symbols": ["es.symbol"],
  "core-js/stable/object/get-prototype-of": ["es.object.get-prototype-of"],
  "core-js/stable/object/has-own": ["es.object.has-own"],
  "core-js/stable/object/is": ["es.object.is"],
  "core-js/stable/object/is-extensible": ["es.object.is-extensible"],
  "core-js/stable/object/is-frozen": ["es.object.is-frozen"],
  "core-js/stable/object/is-sealed": ["es.object.is-sealed"],
  "core-js/stable/object/keys": ["es.object.keys"],
  "core-js/stable/object/lookup-getter": ["es.object.lookup-getter"],
  "core-js/stable/object/lookup-setter": ["es.object.lookup-setter"],
  "core-js/stable/object/prevent-extensions": ["es.object.prevent-extensions"],
  "core-js/stable/object/proto": ["es.object.proto"],
  "core-js/stable/object/seal": ["es.object.seal"],
  "core-js/stable/object/set-prototype-of": ["es.object.set-prototype-of"],
  "core-js/stable/object/to-string": [
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string",
    "es.reflect.to-string-tag"
  ],
  "core-js/stable/object/values": ["es.object.values"],
  "core-js/stable/parse-float": ["es.parse-float"],
  "core-js/stable/parse-int": ["es.parse-int"],
  "core-js/stable/promise": [
    "es.aggregate-error",
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.promise.all-settled",
    "es.promise.any",
    "es.promise.finally",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/stable/promise/all-settled": [
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.promise.all-settled",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/stable/promise/any": [
    "es.aggregate-error",
    "es.array.iterator",
    "es.object.to-string",
    "es.promise",
    "es.promise.any",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/stable/promise/finally": ["es.object.to-string", "es.promise", "es.promise.finally"],
  "core-js/stable/queue-microtask": ["web.queue-microtask"],
  "core-js/stable/reflect": [
    "es.object.to-string",
    "es.reflect.apply",
    "es.reflect.construct",
    "es.reflect.define-property",
    "es.reflect.delete-property",
    "es.reflect.get",
    "es.reflect.get-own-property-descriptor",
    "es.reflect.get-prototype-of",
    "es.reflect.has",
    "es.reflect.is-extensible",
    "es.reflect.own-keys",
    "es.reflect.prevent-extensions",
    "es.reflect.set",
    "es.reflect.set-prototype-of",
    "es.reflect.to-string-tag"
  ],
  "core-js/stable/reflect/apply": ["es.reflect.apply"],
  "core-js/stable/reflect/construct": ["es.reflect.construct"],
  "core-js/stable/reflect/define-property": ["es.reflect.define-property"],
  "core-js/stable/reflect/delete-property": ["es.reflect.delete-property"],
  "core-js/stable/reflect/get": ["es.reflect.get"],
  "core-js/stable/reflect/get-own-property-descriptor": ["es.reflect.get-own-property-descriptor"],
  "core-js/stable/reflect/get-prototype-of": ["es.reflect.get-prototype-of"],
  "core-js/stable/reflect/has": ["es.reflect.has"],
  "core-js/stable/reflect/is-extensible": ["es.reflect.is-extensible"],
  "core-js/stable/reflect/own-keys": ["es.reflect.own-keys"],
  "core-js/stable/reflect/prevent-extensions": ["es.reflect.prevent-extensions"],
  "core-js/stable/reflect/set": ["es.reflect.set"],
  "core-js/stable/reflect/set-prototype-of": ["es.reflect.set-prototype-of"],
  "core-js/stable/reflect/to-string-tag": ["es.reflect.to-string-tag"],
  "core-js/stable/regexp": [
    "es.regexp.constructor",
    "es.regexp.dot-all",
    "es.regexp.exec",
    "es.regexp.flags",
    "es.regexp.sticky",
    "es.regexp.test",
    "es.regexp.to-string",
    "es.string.match",
    "es.string.replace",
    "es.string.search",
    "es.string.split"
  ],
  "core-js/stable/regexp/constructor": [
    "es.regexp.constructor",
    "es.regexp.dot-all",
    "es.regexp.exec",
    "es.regexp.sticky"
  ],
  "core-js/stable/regexp/dot-all": ["es.regexp.constructor", "es.regexp.dot-all", "es.regexp.exec"],
  "core-js/stable/regexp/flags": ["es.regexp.flags"],
  "core-js/stable/regexp/match": ["es.regexp.exec", "es.string.match"],
  "core-js/stable/regexp/replace": ["es.regexp.exec", "es.string.replace"],
  "core-js/stable/regexp/search": ["es.regexp.exec", "es.string.search"],
  "core-js/stable/regexp/split": ["es.regexp.exec", "es.string.split"],
  "core-js/stable/regexp/sticky": ["es.regexp.constructor", "es.regexp.exec", "es.regexp.sticky"],
  "core-js/stable/regexp/test": ["es.regexp.exec", "es.regexp.test"],
  "core-js/stable/regexp/to-string": ["es.regexp.to-string"],
  "core-js/stable/self": ["web.self"],
  "core-js/stable/set": [
    "es.array.iterator",
    "es.object.to-string",
    "es.set",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/stable/set-immediate": ["web.immediate"],
  "core-js/stable/set-interval": ["web.timers"],
  "core-js/stable/set-timeout": ["web.timers"],
  "core-js/stable/string": [
    "es.object.to-string",
    "es.regexp.exec",
    "es.string.at-alternative",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.from-code-point",
    "es.string.includes",
    "es.string.is-well-formed",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.raw",
    "es.string.repeat",
    "es.string.replace",
    "es.string.replace-all",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.substr",
    "es.string.to-well-formed",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup"
  ],
  "core-js/stable/string/anchor": ["es.string.anchor"],
  "core-js/stable/string/at": ["es.string.at-alternative"],
  "core-js/stable/string/big": ["es.string.big"],
  "core-js/stable/string/blink": ["es.string.blink"],
  "core-js/stable/string/bold": ["es.string.bold"],
  "core-js/stable/string/code-point-at": ["es.string.code-point-at"],
  "core-js/stable/string/ends-with": ["es.string.ends-with"],
  "core-js/stable/string/fixed": ["es.string.fixed"],
  "core-js/stable/string/fontcolor": ["es.string.fontcolor"],
  "core-js/stable/string/fontsize": ["es.string.fontsize"],
  "core-js/stable/string/from-code-point": ["es.string.from-code-point"],
  "core-js/stable/string/includes": ["es.string.includes"],
  "core-js/stable/string/is-well-formed": ["es.string.is-well-formed"],
  "core-js/stable/string/italics": ["es.string.italics"],
  "core-js/stable/string/iterator": ["es.object.to-string", "es.string.iterator"],
  "core-js/stable/string/link": ["es.string.link"],
  "core-js/stable/string/match": ["es.regexp.exec", "es.string.match"],
  "core-js/stable/string/match-all": ["es.object.to-string", "es.regexp.exec", "es.string.match-all"],
  "core-js/stable/string/pad-end": ["es.string.pad-end"],
  "core-js/stable/string/pad-start": ["es.string.pad-start"],
  "core-js/stable/string/raw": ["es.string.raw"],
  "core-js/stable/string/repeat": ["es.string.repeat"],
  "core-js/stable/string/replace": ["es.regexp.exec", "es.string.replace"],
  "core-js/stable/string/replace-all": ["es.regexp.exec", "es.string.replace", "es.string.replace-all"],
  "core-js/stable/string/search": ["es.regexp.exec", "es.string.search"],
  "core-js/stable/string/small": ["es.string.small"],
  "core-js/stable/string/split": ["es.regexp.exec", "es.string.split"],
  "core-js/stable/string/starts-with": ["es.string.starts-with"],
  "core-js/stable/string/strike": ["es.string.strike"],
  "core-js/stable/string/sub": ["es.string.sub"],
  "core-js/stable/string/substr": ["es.string.substr"],
  "core-js/stable/string/sup": ["es.string.sup"],
  "core-js/stable/string/to-well-formed": ["es.string.to-well-formed"],
  "core-js/stable/string/trim": ["es.string.trim"],
  "core-js/stable/string/trim-end": ["es.string.trim-end"],
  "core-js/stable/string/trim-left": ["es.string.trim-start"],
  "core-js/stable/string/trim-right": ["es.string.trim-end"],
  "core-js/stable/string/trim-start": ["es.string.trim-start"],
  "core-js/stable/string/virtual": [
    "es.object.to-string",
    "es.regexp.exec",
    "es.string.at-alternative",
    "es.string.code-point-at",
    "es.string.ends-with",
    "es.string.includes",
    "es.string.iterator",
    "es.string.match",
    "es.string.match-all",
    "es.string.pad-end",
    "es.string.pad-start",
    "es.string.repeat",
    "es.string.replace",
    "es.string.replace-all",
    "es.string.search",
    "es.string.split",
    "es.string.starts-with",
    "es.string.substr",
    "es.string.trim",
    "es.string.trim-end",
    "es.string.trim-start",
    "es.string.anchor",
    "es.string.big",
    "es.string.blink",
    "es.string.bold",
    "es.string.fixed",
    "es.string.fontcolor",
    "es.string.fontsize",
    "es.string.italics",
    "es.string.link",
    "es.string.small",
    "es.string.strike",
    "es.string.sub",
    "es.string.sup"
  ],
  "core-js/stable/string/virtual/anchor": ["es.string.anchor"],
  "core-js/stable/string/virtual/at": ["es.string.at-alternative"],
  "core-js/stable/string/virtual/big": ["es.string.big"],
  "core-js/stable/string/virtual/blink": ["es.string.blink"],
  "core-js/stable/string/virtual/bold": ["es.string.bold"],
  "core-js/stable/string/virtual/code-point-at": ["es.string.code-point-at"],
  "core-js/stable/string/virtual/ends-with": ["es.string.ends-with"],
  "core-js/stable/string/virtual/fixed": ["es.string.fixed"],
  "core-js/stable/string/virtual/fontcolor": ["es.string.fontcolor"],
  "core-js/stable/string/virtual/fontsize": ["es.string.fontsize"],
  "core-js/stable/string/virtual/includes": ["es.string.includes"],
  "core-js/stable/string/virtual/is-well-formed": ["es.string.is-well-formed"],
  "core-js/stable/string/virtual/italics": ["es.string.italics"],
  "core-js/stable/string/virtual/iterator": ["es.object.to-string", "es.string.iterator"],
  "core-js/stable/string/virtual/link": ["es.string.link"],
  "core-js/stable/string/virtual/match-all": ["es.object.to-string", "es.regexp.exec", "es.string.match-all"],
  "core-js/stable/string/virtual/pad-end": ["es.string.pad-end"],
  "core-js/stable/string/virtual/pad-start": ["es.string.pad-start"],
  "core-js/stable/string/virtual/repeat": ["es.string.repeat"],
  "core-js/stable/string/virtual/replace-all": ["es.regexp.exec", "es.string.replace", "es.string.replace-all"],
  "core-js/stable/string/virtual/small": ["es.string.small"],
  "core-js/stable/string/virtual/starts-with": ["es.string.starts-with"],
  "core-js/stable/string/virtual/strike": ["es.string.strike"],
  "core-js/stable/string/virtual/sub": ["es.string.sub"],
  "core-js/stable/string/virtual/substr": ["es.string.substr"],
  "core-js/stable/string/virtual/sup": ["es.string.sup"],
  "core-js/stable/string/virtual/to-well-formed": ["es.string.to-well-formed"],
  "core-js/stable/string/virtual/trim": ["es.string.trim"],
  "core-js/stable/string/virtual/trim-end": ["es.string.trim-end"],
  "core-js/stable/string/virtual/trim-left": ["es.string.trim-start"],
  "core-js/stable/string/virtual/trim-right": ["es.string.trim-end"],
  "core-js/stable/string/virtual/trim-start": ["es.string.trim-start"],
  "core-js/stable/structured-clone": [
    "es.error.to-string",
    "es.array.iterator",
    "es.map",
    "es.object.keys",
    "es.object.to-string",
    "es.set",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag",
    "web.structured-clone"
  ],
  "core-js/stable/symbol": [
    "es.symbol",
    "es.symbol.description",
    "es.symbol.async-iterator",
    "es.symbol.has-instance",
    "es.symbol.is-concat-spreadable",
    "es.symbol.iterator",
    "es.symbol.match",
    "es.symbol.match-all",
    "es.symbol.replace",
    "es.symbol.search",
    "es.symbol.species",
    "es.symbol.split",
    "es.symbol.to-primitive",
    "es.symbol.to-string-tag",
    "es.symbol.unscopables",
    "es.array.concat",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string",
    "es.reflect.to-string-tag",
    "web.dom-collections.iterator"
  ],
  "core-js/stable/symbol/async-iterator": ["es.symbol.async-iterator"],
  "core-js/stable/symbol/description": ["es.symbol.description"],
  "core-js/stable/symbol/for": ["es.symbol"],
  "core-js/stable/symbol/has-instance": ["es.symbol.has-instance", "es.function.has-instance"],
  "core-js/stable/symbol/is-concat-spreadable": ["es.symbol.is-concat-spreadable", "es.array.concat"],
  "core-js/stable/symbol/iterator": [
    "es.symbol.iterator",
    "es.array.iterator",
    "es.object.to-string",
    "es.string.iterator",
    "web.dom-collections.iterator"
  ],
  "core-js/stable/symbol/key-for": ["es.symbol"],
  "core-js/stable/symbol/match": ["es.symbol.match", "es.regexp.exec", "es.string.match"],
  "core-js/stable/symbol/match-all": [
    "es.symbol.match-all",
    "es.object.to-string",
    "es.regexp.exec",
    "es.string.match-all"
  ],
  "core-js/stable/symbol/replace": ["es.symbol.replace", "es.regexp.exec", "es.string.replace"],
  "core-js/stable/symbol/search": ["es.symbol.search", "es.regexp.exec", "es.string.search"],
  "core-js/stable/symbol/species": ["es.symbol.species"],
  "core-js/stable/symbol/split": ["es.symbol.split", "es.regexp.exec", "es.string.split"],
  "core-js/stable/symbol/to-primitive": ["es.symbol.to-primitive", "es.date.to-primitive"],
  "core-js/stable/symbol/to-string-tag": [
    "es.symbol.to-string-tag",
    "es.json.to-string-tag",
    "es.math.to-string-tag",
    "es.object.to-string",
    "es.reflect.to-string-tag"
  ],
  "core-js/stable/symbol/unscopables": ["es.symbol.unscopables"],
  "core-js/stable/typed-array": [
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.float32-array",
    "es.typed-array.float64-array",
    "es.typed-array.int8-array",
    "es.typed-array.int16-array",
    "es.typed-array.int32-array",
    "es.typed-array.uint8-array",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.uint16-array",
    "es.typed-array.uint32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with"
  ],
  "core-js/stable/typed-array/at": ["es.typed-array.at"],
  "core-js/stable/typed-array/copy-within": ["es.typed-array.copy-within"],
  "core-js/stable/typed-array/entries": ["es.object.to-string", "es.typed-array.iterator"],
  "core-js/stable/typed-array/every": ["es.typed-array.every"],
  "core-js/stable/typed-array/fill": ["es.typed-array.fill"],
  "core-js/stable/typed-array/filter": ["es.typed-array.filter"],
  "core-js/stable/typed-array/find": ["es.typed-array.find"],
  "core-js/stable/typed-array/find-index": ["es.typed-array.find-index"],
  "core-js/stable/typed-array/find-last": ["es.typed-array.find-last"],
  "core-js/stable/typed-array/find-last-index": ["es.typed-array.find-last-index"],
  "core-js/stable/typed-array/float32-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.float32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with"
  ],
  "core-js/stable/typed-array/float64-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.float64-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with"
  ],
  "core-js/stable/typed-array/for-each": ["es.typed-array.for-each"],
  "core-js/stable/typed-array/from": ["es.typed-array.from"],
  "core-js/stable/typed-array/includes": ["es.typed-array.includes"],
  "core-js/stable/typed-array/index-of": ["es.typed-array.index-of"],
  "core-js/stable/typed-array/int16-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.int16-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with"
  ],
  "core-js/stable/typed-array/int32-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.int32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with"
  ],
  "core-js/stable/typed-array/int8-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.int8-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with"
  ],
  "core-js/stable/typed-array/iterator": ["es.object.to-string", "es.typed-array.iterator"],
  "core-js/stable/typed-array/join": ["es.typed-array.join"],
  "core-js/stable/typed-array/keys": ["es.object.to-string", "es.typed-array.iterator"],
  "core-js/stable/typed-array/last-index-of": ["es.typed-array.last-index-of"],
  "core-js/stable/typed-array/map": ["es.typed-array.map"],
  "core-js/stable/typed-array/methods": [
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with"
  ],
  "core-js/stable/typed-array/of": ["es.typed-array.of"],
  "core-js/stable/typed-array/reduce": ["es.typed-array.reduce"],
  "core-js/stable/typed-array/reduce-right": ["es.typed-array.reduce-right"],
  "core-js/stable/typed-array/reverse": ["es.typed-array.reverse"],
  "core-js/stable/typed-array/set": ["es.typed-array.set"],
  "core-js/stable/typed-array/slice": ["es.typed-array.slice"],
  "core-js/stable/typed-array/some": ["es.typed-array.some"],
  "core-js/stable/typed-array/sort": ["es.typed-array.sort"],
  "core-js/stable/typed-array/subarray": ["es.typed-array.subarray"],
  "core-js/stable/typed-array/to-locale-string": ["es.typed-array.to-locale-string"],
  "core-js/stable/typed-array/to-reversed": ["es.typed-array.to-reversed"],
  "core-js/stable/typed-array/to-sorted": ["es.typed-array.sort", "es.typed-array.to-sorted"],
  "core-js/stable/typed-array/to-string": ["es.typed-array.to-string"],
  "core-js/stable/typed-array/uint16-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.uint16-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with"
  ],
  "core-js/stable/typed-array/uint32-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.uint32-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with"
  ],
  "core-js/stable/typed-array/uint8-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.uint8-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with"
  ],
  "core-js/stable/typed-array/uint8-clamped-array": [
    "es.array-buffer.constructor",
    "es.array-buffer.slice",
    "es.object.to-string",
    "es.string.iterator",
    "es.typed-array.uint8-clamped-array",
    "es.typed-array.at",
    "es.typed-array.copy-within",
    "es.typed-array.every",
    "es.typed-array.fill",
    "es.typed-array.filter",
    "es.typed-array.find",
    "es.typed-array.find-index",
    "es.typed-array.find-last",
    "es.typed-array.find-last-index",
    "es.typed-array.for-each",
    "es.typed-array.from",
    "es.typed-array.includes",
    "es.typed-array.index-of",
    "es.typed-array.iterator",
    "es.typed-array.join",
    "es.typed-array.last-index-of",
    "es.typed-array.map",
    "es.typed-array.of",
    "es.typed-array.reduce",
    "es.typed-array.reduce-right",
    "es.typed-array.reverse",
    "es.typed-array.set",
    "es.typed-array.slice",
    "es.typed-array.some",
    "es.typed-array.sort",
    "es.typed-array.subarray",
    "es.typed-array.to-locale-string",
    "es.typed-array.to-reversed",
    "es.typed-array.to-sorted",
    "es.typed-array.to-string",
    "es.typed-array.with"
  ],
  "core-js/stable/typed-array/values": ["es.object.to-string", "es.typed-array.iterator"],
  "core-js/stable/typed-array/with": ["es.typed-array.with"],
  "core-js/stable/unescape": ["es.unescape"],
  "core-js/stable/url": [
    "web.url",
    "web.url.can-parse",
    "web.url.to-json",
    "web.url-search-params",
    "web.url-search-params.delete",
    "web.url-search-params.has",
    "web.url-search-params.size"
  ],
  "core-js/stable/url-search-params": [
    "web.dom-collections.iterator",
    "web.url-search-params",
    "web.url-search-params.delete",
    "web.url-search-params.has",
    "web.url-search-params.size"
  ],
  "core-js/stable/url/can-parse": ["web.url", "web.url.can-parse"],
  "core-js/stable/url/to-json": ["web.url.to-json"],
  "core-js/stable/weak-map": [
    "es.array.iterator",
    "es.object.to-string",
    "es.weak-map",
    "web.dom-collections.iterator"
  ],
  "core-js/stable/weak-set": [
    "es.array.iterator",
    "es.object.to-string",
    "es.weak-set",
    "web.dom-collections.iterator"
  ],
  "core-js/stage": [
    "es.map",
    "es.string.at-alternative",
    "esnext.aggregate-error",
    "esnext.suppressed-error.constructor",
    "esnext.array.from-async",
    "esnext.array.at",
    "esnext.array.filter-out",
    "esnext.array.filter-reject",
    "esnext.array.find-last",
    "esnext.array.find-last-index",
    "esnext.array.group",
    "esnext.array.group-by",
    "esnext.array.group-by-to-map",
    "esnext.array.group-to-map",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.array.to-reversed",
    "esnext.array.to-sorted",
    "esnext.array.to-spliced",
    "esnext.array.unique-by",
    "esnext.array.with",
    "esnext.array-buffer.detached",
    "esnext.array-buffer.transfer",
    "esnext.array-buffer.transfer-to-fixed-length",
    "esnext.async-disposable-stack.constructor",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.async-dispose",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.indexed",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.bigint.range",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.disposable-stack.constructor",
    "esnext.function.demethodize",
    "esnext.function.is-callable",
    "esnext.function.is-constructor",
    "esnext.function.metadata",
    "esnext.function.un-this",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.dispose",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.indexed",
    "esnext.iterator.map",
    "esnext.iterator.range",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.iterator.to-async",
    "esnext.json.is-raw-json",
    "esnext.json.parse",
    "esnext.json.raw-json",
    "esnext.map.delete-all",
    "esnext.map.emplace",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.number.range",
    "esnext.object.has-own",
    "esnext.object.iterate-entries",
    "esnext.object.iterate-keys",
    "esnext.object.iterate-values",
    "esnext.object.group-by",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.promise.with-resolvers",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference.v2",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection.v2",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from.v2",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of.v2",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of.v2",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference.v2",
    "esnext.set.symmetric-difference",
    "esnext.set.union.v2",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.cooked",
    "esnext.string.code-points",
    "esnext.string.dedent",
    "esnext.string.is-well-formed",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.string.to-well-formed",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.is-registered-symbol",
    "esnext.symbol.is-registered",
    "esnext.symbol.is-well-known-symbol",
    "esnext.symbol.is-well-known",
    "esnext.symbol.matcher",
    "esnext.symbol.metadata",
    "esnext.symbol.metadata-key",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.emplace",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.url",
    "web.url.can-parse",
    "web.url.to-json",
    "web.url-search-params",
    "web.url-search-params.delete",
    "web.url-search-params.has",
    "web.url-search-params.size"
  ],
  "core-js/stage/0": [
    "es.map",
    "es.string.at-alternative",
    "esnext.aggregate-error",
    "esnext.suppressed-error.constructor",
    "esnext.array.from-async",
    "esnext.array.at",
    "esnext.array.filter-out",
    "esnext.array.filter-reject",
    "esnext.array.find-last",
    "esnext.array.find-last-index",
    "esnext.array.group",
    "esnext.array.group-by",
    "esnext.array.group-by-to-map",
    "esnext.array.group-to-map",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.array.to-reversed",
    "esnext.array.to-sorted",
    "esnext.array.to-spliced",
    "esnext.array.unique-by",
    "esnext.array.with",
    "esnext.array-buffer.detached",
    "esnext.array-buffer.transfer",
    "esnext.array-buffer.transfer-to-fixed-length",
    "esnext.async-disposable-stack.constructor",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.async-dispose",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.indexed",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.bigint.range",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.disposable-stack.constructor",
    "esnext.function.demethodize",
    "esnext.function.is-callable",
    "esnext.function.is-constructor",
    "esnext.function.metadata",
    "esnext.function.un-this",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.dispose",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.indexed",
    "esnext.iterator.map",
    "esnext.iterator.range",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.iterator.to-async",
    "esnext.json.is-raw-json",
    "esnext.json.parse",
    "esnext.json.raw-json",
    "esnext.map.delete-all",
    "esnext.map.emplace",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.number.range",
    "esnext.object.has-own",
    "esnext.object.iterate-entries",
    "esnext.object.iterate-keys",
    "esnext.object.iterate-values",
    "esnext.object.group-by",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.promise.with-resolvers",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference.v2",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection.v2",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from.v2",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of.v2",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of.v2",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference.v2",
    "esnext.set.symmetric-difference",
    "esnext.set.union.v2",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.cooked",
    "esnext.string.code-points",
    "esnext.string.dedent",
    "esnext.string.is-well-formed",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.string.to-well-formed",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.is-registered-symbol",
    "esnext.symbol.is-registered",
    "esnext.symbol.is-well-known-symbol",
    "esnext.symbol.is-well-known",
    "esnext.symbol.matcher",
    "esnext.symbol.metadata",
    "esnext.symbol.metadata-key",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.emplace",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.url",
    "web.url.can-parse",
    "web.url.to-json",
    "web.url-search-params",
    "web.url-search-params.delete",
    "web.url-search-params.has",
    "web.url-search-params.size"
  ],
  "core-js/stage/1": [
    "es.map",
    "es.string.at-alternative",
    "esnext.aggregate-error",
    "esnext.suppressed-error.constructor",
    "esnext.array.from-async",
    "esnext.array.at",
    "esnext.array.filter-reject",
    "esnext.array.find-last",
    "esnext.array.find-last-index",
    "esnext.array.group",
    "esnext.array.group-by",
    "esnext.array.group-by-to-map",
    "esnext.array.group-to-map",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.array.to-reversed",
    "esnext.array.to-sorted",
    "esnext.array.to-spliced",
    "esnext.array.unique-by",
    "esnext.array.with",
    "esnext.array-buffer.detached",
    "esnext.array-buffer.transfer",
    "esnext.array-buffer.transfer-to-fixed-length",
    "esnext.async-disposable-stack.constructor",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.async-dispose",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.indexed",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.bigint.range",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.disposable-stack.constructor",
    "esnext.function.metadata",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.dispose",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.indexed",
    "esnext.iterator.map",
    "esnext.iterator.range",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.iterator.to-async",
    "esnext.json.is-raw-json",
    "esnext.json.parse",
    "esnext.json.raw-json",
    "esnext.map.delete-all",
    "esnext.map.emplace",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.number.from-string",
    "esnext.number.range",
    "esnext.object.has-own",
    "esnext.object.iterate-entries",
    "esnext.object.iterate-keys",
    "esnext.object.iterate-values",
    "esnext.object.group-by",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.promise.with-resolvers",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference.v2",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection.v2",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from.v2",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of.v2",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of.v2",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference.v2",
    "esnext.set.symmetric-difference",
    "esnext.set.union.v2",
    "esnext.set.union",
    "esnext.string.cooked",
    "esnext.string.code-points",
    "esnext.string.dedent",
    "esnext.string.is-well-formed",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.string.to-well-formed",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.is-registered-symbol",
    "esnext.symbol.is-registered",
    "esnext.symbol.is-well-known-symbol",
    "esnext.symbol.is-well-known",
    "esnext.symbol.matcher",
    "esnext.symbol.metadata",
    "esnext.symbol.metadata-key",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.emplace",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of"
  ],
  "core-js/stage/2": [
    "es.string.at-alternative",
    "esnext.aggregate-error",
    "esnext.suppressed-error.constructor",
    "esnext.array.from-async",
    "esnext.array.at",
    "esnext.array.find-last",
    "esnext.array.find-last-index",
    "esnext.array.group",
    "esnext.array.group-by",
    "esnext.array.group-by-to-map",
    "esnext.array.group-to-map",
    "esnext.array.is-template-object",
    "esnext.array.to-reversed",
    "esnext.array.to-sorted",
    "esnext.array.to-spliced",
    "esnext.array.with",
    "esnext.array-buffer.detached",
    "esnext.array-buffer.transfer",
    "esnext.array-buffer.transfer-to-fixed-length",
    "esnext.async-disposable-stack.constructor",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.async-dispose",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.indexed",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.disposable-stack.constructor",
    "esnext.function.metadata",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.dispose",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.indexed",
    "esnext.iterator.map",
    "esnext.iterator.range",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.iterator.to-async",
    "esnext.json.is-raw-json",
    "esnext.json.parse",
    "esnext.json.raw-json",
    "esnext.map.emplace",
    "esnext.map.group-by",
    "esnext.object.has-own",
    "esnext.object.group-by",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.with-resolvers",
    "esnext.set.difference.v2",
    "esnext.set.difference",
    "esnext.set.intersection.v2",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from.v2",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of.v2",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of.v2",
    "esnext.set.is-superset-of",
    "esnext.set.symmetric-difference.v2",
    "esnext.set.symmetric-difference",
    "esnext.set.union.v2",
    "esnext.set.union",
    "esnext.string.dedent",
    "esnext.string.is-well-formed",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.string.to-well-formed",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.is-registered-symbol",
    "esnext.symbol.is-registered",
    "esnext.symbol.is-well-known-symbol",
    "esnext.symbol.is-well-known",
    "esnext.symbol.metadata",
    "esnext.symbol.metadata-key",
    "esnext.typed-array.at",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.with",
    "esnext.weak-map.emplace"
  ],
  "core-js/stage/3": [
    "es.string.at-alternative",
    "esnext.aggregate-error",
    "esnext.suppressed-error.constructor",
    "esnext.array.from-async",
    "esnext.array.at",
    "esnext.array.find-last",
    "esnext.array.find-last-index",
    "esnext.array.group",
    "esnext.array.group-by",
    "esnext.array.group-by-to-map",
    "esnext.array.group-to-map",
    "esnext.array.to-reversed",
    "esnext.array.to-sorted",
    "esnext.array.to-spliced",
    "esnext.array.with",
    "esnext.array-buffer.detached",
    "esnext.array-buffer.transfer",
    "esnext.array-buffer.transfer-to-fixed-length",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.disposable-stack.constructor",
    "esnext.function.metadata",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.dispose",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.map",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.iterator.to-async",
    "esnext.json.is-raw-json",
    "esnext.json.parse",
    "esnext.json.raw-json",
    "esnext.object.has-own",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.set.difference.v2",
    "esnext.set.intersection.v2",
    "esnext.set.is-disjoint-from.v2",
    "esnext.set.is-subset-of.v2",
    "esnext.set.is-superset-of.v2",
    "esnext.set.symmetric-difference.v2",
    "esnext.set.union.v2",
    "esnext.string.is-well-formed",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.string.to-well-formed",
    "esnext.symbol.dispose",
    "esnext.symbol.metadata",
    "esnext.typed-array.at",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.with"
  ],
  "core-js/stage/4": [
    "es.string.at-alternative",
    "esnext.aggregate-error",
    "esnext.array.at",
    "esnext.array.find-last",
    "esnext.array.find-last-index",
    "esnext.array.to-reversed",
    "esnext.array.to-sorted",
    "esnext.array.to-spliced",
    "esnext.array.with",
    "esnext.global-this",
    "esnext.object.has-own",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.string.is-well-formed",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.string.to-well-formed",
    "esnext.typed-array.at",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.with"
  ],
  "core-js/stage/pre": [
    "es.map",
    "es.string.at-alternative",
    "esnext.aggregate-error",
    "esnext.suppressed-error.constructor",
    "esnext.array.from-async",
    "esnext.array.at",
    "esnext.array.filter-out",
    "esnext.array.filter-reject",
    "esnext.array.find-last",
    "esnext.array.find-last-index",
    "esnext.array.group",
    "esnext.array.group-by",
    "esnext.array.group-by-to-map",
    "esnext.array.group-to-map",
    "esnext.array.is-template-object",
    "esnext.array.last-index",
    "esnext.array.last-item",
    "esnext.array.to-reversed",
    "esnext.array.to-sorted",
    "esnext.array.to-spliced",
    "esnext.array.unique-by",
    "esnext.array.with",
    "esnext.array-buffer.detached",
    "esnext.array-buffer.transfer",
    "esnext.array-buffer.transfer-to-fixed-length",
    "esnext.async-disposable-stack.constructor",
    "esnext.async-iterator.constructor",
    "esnext.async-iterator.as-indexed-pairs",
    "esnext.async-iterator.async-dispose",
    "esnext.async-iterator.drop",
    "esnext.async-iterator.every",
    "esnext.async-iterator.filter",
    "esnext.async-iterator.find",
    "esnext.async-iterator.flat-map",
    "esnext.async-iterator.for-each",
    "esnext.async-iterator.from",
    "esnext.async-iterator.indexed",
    "esnext.async-iterator.map",
    "esnext.async-iterator.reduce",
    "esnext.async-iterator.some",
    "esnext.async-iterator.take",
    "esnext.async-iterator.to-array",
    "esnext.bigint.range",
    "esnext.composite-key",
    "esnext.composite-symbol",
    "esnext.disposable-stack.constructor",
    "esnext.function.demethodize",
    "esnext.function.is-callable",
    "esnext.function.is-constructor",
    "esnext.function.metadata",
    "esnext.function.un-this",
    "esnext.global-this",
    "esnext.iterator.constructor",
    "esnext.iterator.as-indexed-pairs",
    "esnext.iterator.dispose",
    "esnext.iterator.drop",
    "esnext.iterator.every",
    "esnext.iterator.filter",
    "esnext.iterator.find",
    "esnext.iterator.flat-map",
    "esnext.iterator.for-each",
    "esnext.iterator.from",
    "esnext.iterator.indexed",
    "esnext.iterator.map",
    "esnext.iterator.range",
    "esnext.iterator.reduce",
    "esnext.iterator.some",
    "esnext.iterator.take",
    "esnext.iterator.to-array",
    "esnext.iterator.to-async",
    "esnext.json.is-raw-json",
    "esnext.json.parse",
    "esnext.json.raw-json",
    "esnext.map.delete-all",
    "esnext.map.emplace",
    "esnext.map.every",
    "esnext.map.filter",
    "esnext.map.find",
    "esnext.map.find-key",
    "esnext.map.from",
    "esnext.map.group-by",
    "esnext.map.includes",
    "esnext.map.key-by",
    "esnext.map.key-of",
    "esnext.map.map-keys",
    "esnext.map.map-values",
    "esnext.map.merge",
    "esnext.map.of",
    "esnext.map.reduce",
    "esnext.map.some",
    "esnext.map.update",
    "esnext.map.update-or-insert",
    "esnext.map.upsert",
    "esnext.math.clamp",
    "esnext.math.deg-per-rad",
    "esnext.math.degrees",
    "esnext.math.fscale",
    "esnext.math.iaddh",
    "esnext.math.imulh",
    "esnext.math.isubh",
    "esnext.math.rad-per-deg",
    "esnext.math.radians",
    "esnext.math.scale",
    "esnext.math.seeded-prng",
    "esnext.math.signbit",
    "esnext.math.umulh",
    "esnext.number.from-string",
    "esnext.number.range",
    "esnext.object.has-own",
    "esnext.object.iterate-entries",
    "esnext.object.iterate-keys",
    "esnext.object.iterate-values",
    "esnext.object.group-by",
    "esnext.observable",
    "esnext.promise.all-settled",
    "esnext.promise.any",
    "esnext.promise.try",
    "esnext.promise.with-resolvers",
    "esnext.reflect.define-metadata",
    "esnext.reflect.delete-metadata",
    "esnext.reflect.get-metadata",
    "esnext.reflect.get-metadata-keys",
    "esnext.reflect.get-own-metadata",
    "esnext.reflect.get-own-metadata-keys",
    "esnext.reflect.has-metadata",
    "esnext.reflect.has-own-metadata",
    "esnext.reflect.metadata",
    "esnext.set.add-all",
    "esnext.set.delete-all",
    "esnext.set.difference.v2",
    "esnext.set.difference",
    "esnext.set.every",
    "esnext.set.filter",
    "esnext.set.find",
    "esnext.set.from",
    "esnext.set.intersection.v2",
    "esnext.set.intersection",
    "esnext.set.is-disjoint-from.v2",
    "esnext.set.is-disjoint-from",
    "esnext.set.is-subset-of.v2",
    "esnext.set.is-subset-of",
    "esnext.set.is-superset-of.v2",
    "esnext.set.is-superset-of",
    "esnext.set.join",
    "esnext.set.map",
    "esnext.set.of",
    "esnext.set.reduce",
    "esnext.set.some",
    "esnext.set.symmetric-difference.v2",
    "esnext.set.symmetric-difference",
    "esnext.set.union.v2",
    "esnext.set.union",
    "esnext.string.at",
    "esnext.string.cooked",
    "esnext.string.code-points",
    "esnext.string.dedent",
    "esnext.string.is-well-formed",
    "esnext.string.match-all",
    "esnext.string.replace-all",
    "esnext.string.to-well-formed",
    "esnext.symbol.async-dispose",
    "esnext.symbol.dispose",
    "esnext.symbol.is-registered-symbol",
    "esnext.symbol.is-registered",
    "esnext.symbol.is-well-known-symbol",
    "esnext.symbol.is-well-known",
    "esnext.symbol.matcher",
    "esnext.symbol.metadata",
    "esnext.symbol.metadata-key",
    "esnext.symbol.observable",
    "esnext.symbol.pattern-match",
    "esnext.symbol.replace-all",
    "esnext.typed-array.from-async",
    "esnext.typed-array.at",
    "esnext.typed-array.filter-out",
    "esnext.typed-array.filter-reject",
    "esnext.typed-array.find-last",
    "esnext.typed-array.find-last-index",
    "esnext.typed-array.group-by",
    "esnext.typed-array.to-reversed",
    "esnext.typed-array.to-sorted",
    "esnext.typed-array.to-spliced",
    "esnext.typed-array.unique-by",
    "esnext.typed-array.with",
    "esnext.weak-map.delete-all",
    "esnext.weak-map.from",
    "esnext.weak-map.of",
    "esnext.weak-map.emplace",
    "esnext.weak-map.upsert",
    "esnext.weak-set.add-all",
    "esnext.weak-set.delete-all",
    "esnext.weak-set.from",
    "esnext.weak-set.of",
    "web.url",
    "web.url.can-parse",
    "web.url.to-json",
    "web.url-search-params",
    "web.url-search-params.delete",
    "web.url-search-params.has",
    "web.url-search-params.size"
  ],
  "core-js/web": [
    "web.atob",
    "web.btoa",
    "web.dom-collections.for-each",
    "web.dom-collections.iterator",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag",
    "web.immediate",
    "web.queue-microtask",
    "web.self",
    "web.structured-clone",
    "web.timers",
    "web.url",
    "web.url.can-parse",
    "web.url.to-json",
    "web.url-search-params",
    "web.url-search-params.delete",
    "web.url-search-params.has",
    "web.url-search-params.size"
  ],
  "core-js/web/dom-collections": ["web.dom-collections.for-each", "web.dom-collections.iterator"],
  "core-js/web/dom-exception": [
    "es.error.to-string",
    "web.dom-exception.constructor",
    "web.dom-exception.stack",
    "web.dom-exception.to-string-tag"
  ],
  "core-js/web/immediate": ["web.immediate"],
  "core-js/web/queue-microtask": ["web.queue-microtask"],
  "core-js/web/structured-clone": [
    "es.array.iterator",
    "es.map",
    "es.object.to-string",
    "es.set",
    "web.structured-clone"
  ],
  "core-js/web/timers": ["web.timers"],
  "core-js/web/url": [
    "web.url",
    "web.url.can-parse",
    "web.url.to-json",
    "web.url-search-params",
    "web.url-search-params.delete",
    "web.url-search-params.has",
    "web.url-search-params.size"
  ],
  "core-js/web/url-search-params": [
    "web.url-search-params",
    "web.url-search-params.delete",
    "web.url-search-params.has",
    "web.url-search-params.size"
  ]
};

var entries = require$$0$2;

var corejs3ShippedProposalsList = new Set([
  "esnext.array.from-async",
  "esnext.array.group",
  "esnext.array.group-to-map",
  "esnext.array-buffer.detached",
  "esnext.array-buffer.transfer",
  "esnext.array-buffer.transfer-to-fixed-length",
  "esnext.json.is-raw-json",
  "esnext.json.parse",
  "esnext.json.raw-json",
  "esnext.set.difference.v2",
  "esnext.set.intersection.v2",
  "esnext.set.is-disjoint-from.v2",
  "esnext.set.is-subset-of.v2",
  "esnext.set.is-superset-of.v2",
  "esnext.set.symmetric-difference.v2",
  "esnext.set.union.v2"
]);
const polyfillsOrder = {};
Object.keys(data).forEach((name, index) => {
  polyfillsOrder[name] = index;
});
const define = (pure, global, name = global[0], exclude) => ({
  name,
  pure,
  global: global.sort((a, b) => polyfillsOrder[a] - polyfillsOrder[b]),
  exclude
});
const typed = name => define(null, [name, ...TypedArrayDependencies]),
  ArrayNatureIterators = ["es.array.iterator", "web.dom-collections.iterator"],
  CommonIterators = ["es.string.iterator", ...ArrayNatureIterators],
  ArrayNatureIteratorsWithTag = ["es.object.to-string", ...ArrayNatureIterators],
  CommonIteratorsWithTag = ["es.object.to-string", ...CommonIterators],
  ErrorDependencies = ["es.error.cause", "es.error.to-string"],
  SuppressedErrorDependencies = ["esnext.suppressed-error.constructor", ...ErrorDependencies];
const TypedArrayDependencies = [
  "es.typed-array.at",
  "es.typed-array.copy-within",
  "es.typed-array.every",
  "es.typed-array.fill",
  "es.typed-array.filter",
  "es.typed-array.find",
  "es.typed-array.find-index",
  "es.typed-array.find-last",
  "es.typed-array.find-last-index",
  "es.typed-array.for-each",
  "es.typed-array.includes",
  "es.typed-array.index-of",
  "es.typed-array.iterator",
  "es.typed-array.join",
  "es.typed-array.last-index-of",
  "es.typed-array.map",
  "es.typed-array.reduce",
  "es.typed-array.reduce-right",
  "es.typed-array.reverse",
  "es.typed-array.set",
  "es.typed-array.slice",
  "es.typed-array.some",
  "es.typed-array.sort",
  "es.typed-array.subarray",
  "es.typed-array.to-locale-string",
  "es.typed-array.to-reversed",
  "es.typed-array.to-sorted",
  "es.typed-array.to-string",
  "es.typed-array.with",
  "es.object.to-string",
  "es.array.iterator",
  "es.array-buffer.slice",
  "esnext.array-buffer.detached",
  "esnext.array-buffer.transfer",
  "esnext.array-buffer.transfer-to-fixed-length",
  "esnext.typed-array.filter-reject",
  "esnext.typed-array.group-by",
  "esnext.typed-array.to-spliced",
  "esnext.typed-array.unique-by"
];
const PromiseDependencies = ["es.promise", "es.object.to-string"],
  PromiseDependenciesWithIterators = [...PromiseDependencies, ...CommonIterators],
  SymbolDependencies = ["es.symbol", "es.symbol.description", "es.object.to-string"];
const MapDependencies = [
  "es.map",
  "esnext.map.delete-all",
  "esnext.map.emplace",
  "esnext.map.every",
  "esnext.map.filter",
  "esnext.map.find",
  "esnext.map.find-key",
  "esnext.map.includes",
  "esnext.map.key-of",
  "esnext.map.map-keys",
  "esnext.map.map-values",
  "esnext.map.merge",
  "esnext.map.reduce",
  "esnext.map.some",
  "esnext.map.update",
  ...CommonIteratorsWithTag
];
const SetDependencies = [
  "es.set",
  "esnext.set.add-all",
  "esnext.set.delete-all",
  "esnext.set.difference",
  "esnext.set.difference.v2",
  "esnext.set.every",
  "esnext.set.filter",
  "esnext.set.find",
  "esnext.set.intersection",
  "esnext.set.intersection.v2",
  "esnext.set.is-disjoint-from",
  "esnext.set.is-disjoint-from.v2",
  "esnext.set.is-subset-of",
  "esnext.set.is-subset-of.v2",
  "esnext.set.is-superset-of",
  "esnext.set.is-superset-of.v2",
  "esnext.set.join",
  "esnext.set.map",
  "esnext.set.reduce",
  "esnext.set.some",
  "esnext.set.symmetric-difference",
  "esnext.set.symmetric-difference.v2",
  "esnext.set.union",
  "esnext.set.union.v2",
  ...CommonIteratorsWithTag
];
const WeakMapDependencies = [
  "es.weak-map",
  "esnext.weak-map.delete-all",
  "esnext.weak-map.emplace",
  ...CommonIteratorsWithTag
];
const WeakSetDependencies = [
  "es.weak-set",
  "esnext.weak-set.add-all",
  "esnext.weak-set.delete-all",
  ...CommonIteratorsWithTag
];
const DOMExceptionDependencies = [
  "web.dom-exception.constructor",
  "web.dom-exception.stack",
  "web.dom-exception.to-string-tag",
  "es.error.to-string"
];
const URLSearchParamsDependencies = [
  "web.url-search-params",
  "web.url-search-params.delete",
  "web.url-search-params.has",
  "web.url-search-params.size",
  ...CommonIteratorsWithTag
];
const AsyncIteratorDependencies = ["esnext.async-iterator.constructor", ...PromiseDependencies];
const AsyncIteratorProblemMethods = [
  "esnext.async-iterator.every",
  "esnext.async-iterator.filter",
  "esnext.async-iterator.find",
  "esnext.async-iterator.flat-map",
  "esnext.async-iterator.for-each",
  "esnext.async-iterator.map",
  "esnext.async-iterator.reduce",
  "esnext.async-iterator.some"
];
const IteratorDependencies = ["esnext.iterator.constructor", "es.object.to-string"];
const TypedArrayStaticMethods = {
  from: define(null, ["es.typed-array.from"]),
  fromAsync: define(null, ["esnext.typed-array.from-async", ...PromiseDependenciesWithIterators]),
  of: define(null, ["es.typed-array.of"])
};
const BuiltIns = {
  AsyncDisposableStack: define("async-disposable-stack", [
    "esnext.async-disposable-stack.constructor",
    "es.object.to-string",
    "esnext.async-iterator.async-dispose",
    "esnext.iterator.dispose",
    ...PromiseDependencies,
    ...SuppressedErrorDependencies
  ]),
  AsyncIterator: define("async-iterator/index", AsyncIteratorDependencies),
  AggregateError: define("aggregate-error", [
    "es.aggregate-error",
    ...ErrorDependencies,
    ...CommonIteratorsWithTag,
    "es.aggregate-error.cause"
  ]),
  ArrayBuffer: define(null, ["es.array-buffer.constructor", "es.array-buffer.slice", "es.object.to-string"]),
  DataView: define(null, ["es.data-view", "es.array-buffer.slice", "es.object.to-string"]),
  Date: define(null, ["es.date.to-string"]),
  DOMException: define("dom-exception", DOMExceptionDependencies),
  DisposableStack: define("disposable-stack", [
    "esnext.disposable-stack.constructor",
    "es.object.to-string",
    "esnext.iterator.dispose",
    ...SuppressedErrorDependencies
  ]),
  Error: define(null, ErrorDependencies),
  EvalError: define(null, ErrorDependencies),
  Float32Array: typed("es.typed-array.float32-array"),
  Float64Array: typed("es.typed-array.float64-array"),
  Int8Array: typed("es.typed-array.int8-array"),
  Int16Array: typed("es.typed-array.int16-array"),
  Int32Array: typed("es.typed-array.int32-array"),
  Iterator: define("iterator/index", IteratorDependencies),
  Uint8Array: typed("es.typed-array.uint8-array"),
  Uint8ClampedArray: typed("es.typed-array.uint8-clamped-array"),
  Uint16Array: typed("es.typed-array.uint16-array"),
  Uint32Array: typed("es.typed-array.uint32-array"),
  Map: define("map/index", MapDependencies),
  Number: define(null, ["es.number.constructor"]),
  Observable: define("observable/index", [
    "esnext.observable",
    "esnext.symbol.observable",
    "es.object.to-string",
    ...CommonIteratorsWithTag
  ]),
  Promise: define("promise/index", PromiseDependencies),
  RangeError: define(null, ErrorDependencies),
  ReferenceError: define(null, ErrorDependencies),
  Reflect: define(null, ["es.reflect.to-string-tag", "es.object.to-string"]),
  RegExp: define(null, [
    "es.regexp.constructor",
    "es.regexp.dot-all",
    "es.regexp.exec",
    "es.regexp.sticky",
    "es.regexp.to-string"
  ]),
  Set: define("set/index", SetDependencies),
  SuppressedError: define("suppressed-error", SuppressedErrorDependencies),
  Symbol: define("symbol/index", SymbolDependencies),
  SyntaxError: define(null, ErrorDependencies),
  TypeError: define(null, ErrorDependencies),
  URIError: define(null, ErrorDependencies),
  URL: define("url/index", ["web.url", ...URLSearchParamsDependencies]),
  URLSearchParams: define("url-search-params/index", URLSearchParamsDependencies),
  WeakMap: define("weak-map/index", WeakMapDependencies),
  WeakSet: define("weak-set/index", WeakSetDependencies),
  atob: define("atob", ["web.atob", ...DOMExceptionDependencies]),
  btoa: define("btoa", ["web.btoa", ...DOMExceptionDependencies]),
  clearImmediate: define("clear-immediate", ["web.immediate"]),
  compositeKey: define("composite-key", ["esnext.composite-key"]),
  compositeSymbol: define("composite-symbol", ["esnext.composite-symbol"]),
  escape: define("escape", ["es.escape"]),
  fetch: define(null, PromiseDependencies),
  globalThis: define("global-this", ["es.global-this"]),
  parseFloat: define("parse-float", ["es.parse-float"]),
  parseInt: define("parse-int", ["es.parse-int"]),
  queueMicrotask: define("queue-microtask", ["web.queue-microtask"]),
  self: define("self", ["web.self"]),
  setImmediate: define("set-immediate", ["web.immediate"]),
  setInterval: define("set-interval", ["web.timers"]),
  setTimeout: define("set-timeout", ["web.timers"]),
  structuredClone: define("structured-clone", [
    "web.structured-clone",
    ...DOMExceptionDependencies,
    "es.array.iterator",
    "es.object.keys",
    "es.object.to-string",
    "es.map",
    "es.set"
  ]),
  unescape: define("unescape", ["es.unescape"])
};
const StaticProperties = {
  AsyncIterator: {
    from: define("async-iterator/from", [
      "esnext.async-iterator.from",
      ...AsyncIteratorDependencies,
      ...AsyncIteratorProblemMethods,
      ...CommonIterators
    ])
  },
  Array: {
    from: define("array/from", ["es.array.from", "es.string.iterator"]),
    fromAsync: define("array/from-async", ["esnext.array.from-async", ...PromiseDependenciesWithIterators]),
    isArray: define("array/is-array", ["es.array.is-array"]),
    isTemplateObject: define("array/is-template-object", ["esnext.array.is-template-object"]),
    of: define("array/of", ["es.array.of"])
  },
  ArrayBuffer: { isView: define(null, ["es.array-buffer.is-view"]) },
  BigInt: { range: define("bigint/range", ["esnext.bigint.range", "es.object.to-string"]) },
  Date: { now: define("date/now", ["es.date.now"]) },
  Function: {
    isCallable: define("function/is-callable", ["esnext.function.is-callable"]),
    isConstructor: define("function/is-constructor", ["esnext.function.is-constructor"])
  },
  Iterator: {
    from: define("iterator/from", ["esnext.iterator.from", ...IteratorDependencies, ...CommonIterators]),
    range: define("iterator/range", ["esnext.iterator.range", "es.object.to-string"])
  },
  JSON: {
    isRawJSON: define("json/is-raw-json", ["esnext.json.is-raw-json"]),
    parse: define("json/parse", ["esnext.json.parse", "es.object.keys"]),
    rawJSON: define("json/raw-json", ["esnext.json.raw-json", "es.object.create", "es.object.freeze"]),
    stringify: define("json/stringify", ["es.json.stringify"], "es.symbol")
  },
  Math: {
    DEG_PER_RAD: define("math/deg-per-rad", ["esnext.math.deg-per-rad"]),
    RAD_PER_DEG: define("math/rad-per-deg", ["esnext.math.rad-per-deg"]),
    acosh: define("math/acosh", ["es.math.acosh"]),
    asinh: define("math/asinh", ["es.math.asinh"]),
    atanh: define("math/atanh", ["es.math.atanh"]),
    cbrt: define("math/cbrt", ["es.math.cbrt"]),
    clamp: define("math/clamp", ["esnext.math.clamp"]),
    clz32: define("math/clz32", ["es.math.clz32"]),
    cosh: define("math/cosh", ["es.math.cosh"]),
    degrees: define("math/degrees", ["esnext.math.degrees"]),
    expm1: define("math/expm1", ["es.math.expm1"]),
    fround: define("math/fround", ["es.math.fround"]),
    fscale: define("math/fscale", ["esnext.math.fscale"]),
    hypot: define("math/hypot", ["es.math.hypot"]),
    iaddh: define("math/iaddh", ["esnext.math.iaddh"]),
    imul: define("math/imul", ["es.math.imul"]),
    imulh: define("math/imulh", ["esnext.math.imulh"]),
    isubh: define("math/isubh", ["esnext.math.isubh"]),
    log10: define("math/log10", ["es.math.log10"]),
    log1p: define("math/log1p", ["es.math.log1p"]),
    log2: define("math/log2", ["es.math.log2"]),
    radians: define("math/radians", ["esnext.math.radians"]),
    scale: define("math/scale", ["esnext.math.scale"]),
    seededPRNG: define("math/seeded-prng", ["esnext.math.seeded-prng"]),
    sign: define("math/sign", ["es.math.sign"]),
    signbit: define("math/signbit", ["esnext.math.signbit"]),
    sinh: define("math/sinh", ["es.math.sinh"]),
    tanh: define("math/tanh", ["es.math.tanh"]),
    trunc: define("math/trunc", ["es.math.trunc"]),
    umulh: define("math/umulh", ["esnext.math.umulh"])
  },
  Map: {
    from: define(null, ["esnext.map.from", ...MapDependencies]),
    groupBy: define(null, ["esnext.map.group-by", ...MapDependencies]),
    keyBy: define(null, ["esnext.map.key-by", ...MapDependencies]),
    of: define(null, ["esnext.map.of", ...MapDependencies])
  },
  Number: {
    EPSILON: define("number/epsilon", ["es.number.epsilon"]),
    MAX_SAFE_INTEGER: define("number/max-safe-integer", ["es.number.max-safe-integer"]),
    MIN_SAFE_INTEGER: define("number/min-safe-integer", ["es.number.min-safe-integer"]),
    fromString: define("number/from-string", ["esnext.number.from-string"]),
    isFinite: define("number/is-finite", ["es.number.is-finite"]),
    isInteger: define("number/is-integer", ["es.number.is-integer"]),
    isNaN: define("number/is-nan", ["es.number.is-nan"]),
    isSafeInteger: define("number/is-safe-integer", ["es.number.is-safe-integer"]),
    parseFloat: define("number/parse-float", ["es.number.parse-float"]),
    parseInt: define("number/parse-int", ["es.number.parse-int"]),
    range: define("number/range", ["esnext.number.range", "es.object.to-string"])
  },
  Object: {
    assign: define("object/assign", ["es.object.assign"]),
    create: define("object/create", ["es.object.create"]),
    defineProperties: define("object/define-properties", ["es.object.define-properties"]),
    defineProperty: define("object/define-property", ["es.object.define-property"]),
    entries: define("object/entries", ["es.object.entries"]),
    freeze: define("object/freeze", ["es.object.freeze"]),
    fromEntries: define("object/from-entries", ["es.object.from-entries", "es.array.iterator"]),
    getOwnPropertyDescriptor: define("object/get-own-property-descriptor", ["es.object.get-own-property-descriptor"]),
    getOwnPropertyDescriptors: define("object/get-own-property-descriptors", [
      "es.object.get-own-property-descriptors"
    ]),
    getOwnPropertyNames: define("object/get-own-property-names", ["es.object.get-own-property-names"]),
    getOwnPropertySymbols: define("object/get-own-property-symbols", ["es.symbol"]),
    getPrototypeOf: define("object/get-prototype-of", ["es.object.get-prototype-of"]),
    groupBy: define("object/group-by", ["esnext.object.group-by", "es.object.create"]),
    hasOwn: define("object/has-own", ["es.object.has-own"]),
    is: define("object/is", ["es.object.is"]),
    isExtensible: define("object/is-extensible", ["es.object.is-extensible"]),
    isFrozen: define("object/is-frozen", ["es.object.is-frozen"]),
    isSealed: define("object/is-sealed", ["es.object.is-sealed"]),
    keys: define("object/keys", ["es.object.keys"]),
    preventExtensions: define("object/prevent-extensions", ["es.object.prevent-extensions"]),
    seal: define("object/seal", ["es.object.seal"]),
    setPrototypeOf: define("object/set-prototype-of", ["es.object.set-prototype-of"]),
    values: define("object/values", ["es.object.values"])
  },
  Promise: {
    all: define(null, PromiseDependenciesWithIterators),
    allSettled: define(null, ["es.promise.all-settled", ...PromiseDependenciesWithIterators]),
    any: define(null, ["es.promise.any", "es.aggregate-error", ...PromiseDependenciesWithIterators]),
    race: define(null, PromiseDependenciesWithIterators),
    try: define(null, ["esnext.promise.try", ...PromiseDependencies]),
    withResolvers: define(null, ["esnext.promise.with-resolvers", ...PromiseDependencies])
  },
  Reflect: {
    apply: define("reflect/apply", ["es.reflect.apply"]),
    construct: define("reflect/construct", ["es.reflect.construct"]),
    defineMetadata: define("reflect/define-metadata", ["esnext.reflect.define-metadata"]),
    defineProperty: define("reflect/define-property", ["es.reflect.define-property"]),
    deleteMetadata: define("reflect/delete-metadata", ["esnext.reflect.delete-metadata"]),
    deleteProperty: define("reflect/delete-property", ["es.reflect.delete-property"]),
    get: define("reflect/get", ["es.reflect.get"]),
    getMetadata: define("reflect/get-metadata", ["esnext.reflect.get-metadata"]),
    getMetadataKeys: define("reflect/get-metadata-keys", ["esnext.reflect.get-metadata-keys"]),
    getOwnMetadata: define("reflect/get-own-metadata", ["esnext.reflect.get-own-metadata"]),
    getOwnMetadataKeys: define("reflect/get-own-metadata-keys", ["esnext.reflect.get-own-metadata-keys"]),
    getOwnPropertyDescriptor: define("reflect/get-own-property-descriptor", ["es.reflect.get-own-property-descriptor"]),
    getPrototypeOf: define("reflect/get-prototype-of", ["es.reflect.get-prototype-of"]),
    has: define("reflect/has", ["es.reflect.has"]),
    hasMetadata: define("reflect/has-metadata", ["esnext.reflect.has-metadata"]),
    hasOwnMetadata: define("reflect/has-own-metadata", ["esnext.reflect.has-own-metadata"]),
    isExtensible: define("reflect/is-extensible", ["es.reflect.is-extensible"]),
    metadata: define("reflect/metadata", ["esnext.reflect.metadata"]),
    ownKeys: define("reflect/own-keys", ["es.reflect.own-keys"]),
    preventExtensions: define("reflect/prevent-extensions", ["es.reflect.prevent-extensions"]),
    set: define("reflect/set", ["es.reflect.set"]),
    setPrototypeOf: define("reflect/set-prototype-of", ["es.reflect.set-prototype-of"])
  },
  Set: {
    from: define(null, ["esnext.set.from", ...SetDependencies]),
    of: define(null, ["esnext.set.of", ...SetDependencies])
  },
  String: {
    cooked: define("string/cooked", ["esnext.string.cooked"]),
    dedent: define("string/dedent", ["esnext.string.dedent", "es.string.from-code-point", "es.weak-map"]),
    fromCodePoint: define("string/from-code-point", ["es.string.from-code-point"]),
    raw: define("string/raw", ["es.string.raw"])
  },
  Symbol: {
    asyncDispose: define("symbol/async-dispose", [
      "esnext.symbol.async-dispose",
      "esnext.async-iterator.async-dispose"
    ]),
    asyncIterator: define("symbol/async-iterator", ["es.symbol.async-iterator"]),
    dispose: define("symbol/dispose", ["esnext.symbol.dispose", "esnext.iterator.dispose"]),
    for: define("symbol/for", [], "es.symbol"),
    hasInstance: define("symbol/has-instance", ["es.symbol.has-instance", "es.function.has-instance"]),
    isConcatSpreadable: define("symbol/is-concat-spreadable", ["es.symbol.is-concat-spreadable", "es.array.concat"]),
    isRegistered: define("symbol/is-registered", ["esnext.symbol.is-registered", "es.symbol"]),
    isRegisteredSymbol: define("symbol/is-registered-symbol", ["esnext.symbol.is-registered-symbol", "es.symbol"]),
    isWellKnown: define("symbol/is-well-known", ["esnext.symbol.is-well-known", "es.symbol"]),
    isWellKnownSymbol: define("symbol/is-well-known-symbol", ["esnext.symbol.is-well-known-symbol", "es.symbol"]),
    iterator: define("symbol/iterator", ["es.symbol.iterator", ...CommonIteratorsWithTag]),
    keyFor: define("symbol/key-for", [], "es.symbol"),
    match: define("symbol/match", ["es.symbol.match", "es.string.match"]),
    matcher: define("symbol/matcher", ["esnext.symbol.matcher"]),
    matchAll: define("symbol/match-all", ["es.symbol.match-all", "es.string.match-all"]),
    metadata: define("symbol/metadata", ["esnext.symbol.metadata", "esnext.function.metadata"]),
    metadataKey: define("symbol/metadata-key", ["esnext.symbol.metadata-key"]),
    observable: define("symbol/observable", ["esnext.symbol.observable"]),
    patternMatch: define("symbol/pattern-match", ["esnext.symbol.pattern-match"]),
    replace: define("symbol/replace", ["es.symbol.replace", "es.string.replace"]),
    search: define("symbol/search", ["es.symbol.search", "es.string.search"]),
    species: define("symbol/species", ["es.symbol.species", "es.array.species"]),
    split: define("symbol/split", ["es.symbol.split", "es.string.split"]),
    toPrimitive: define("symbol/to-primitive", ["es.symbol.to-primitive", "es.date.to-primitive"]),
    toStringTag: define("symbol/to-string-tag", [
      "es.symbol.to-string-tag",
      "es.object.to-string",
      "es.math.to-string-tag",
      "es.json.to-string-tag"
    ]),
    unscopables: define("symbol/unscopables", ["es.symbol.unscopables"])
  },
  URL: { canParse: define("url/can-parse", ["web.url.can-parse", "web.url"]) },
  WeakMap: {
    from: define(null, ["esnext.weak-map.from", ...WeakMapDependencies]),
    of: define(null, ["esnext.weak-map.of", ...WeakMapDependencies])
  },
  WeakSet: {
    from: define(null, ["esnext.weak-set.from", ...WeakSetDependencies]),
    of: define(null, ["esnext.weak-set.of", ...WeakSetDependencies])
  },
  Int8Array: TypedArrayStaticMethods,
  Uint8Array: TypedArrayStaticMethods,
  Uint8ClampedArray: TypedArrayStaticMethods,
  Int16Array: TypedArrayStaticMethods,
  Uint16Array: TypedArrayStaticMethods,
  Int32Array: TypedArrayStaticMethods,
  Uint32Array: TypedArrayStaticMethods,
  Float32Array: TypedArrayStaticMethods,
  Float64Array: TypedArrayStaticMethods,
  WebAssembly: {
    CompileError: define(null, ErrorDependencies),
    LinkError: define(null, ErrorDependencies),
    RuntimeError: define(null, ErrorDependencies)
  }
};
const InstanceProperties = {
  asIndexedPairs: define("instance/asIndexedPairs", [
    "esnext.async-iterator.as-indexed-pairs",
    ...AsyncIteratorDependencies,
    "esnext.iterator.as-indexed-pairs",
    ...IteratorDependencies
  ]),
  at: define("instance/at", ["esnext.string.at", "es.string.at-alternative", "es.array.at"]),
  anchor: define(null, ["es.string.anchor"]),
  big: define(null, ["es.string.big"]),
  bind: define("instance/bind", ["es.function.bind"]),
  blink: define(null, ["es.string.blink"]),
  bold: define(null, ["es.string.bold"]),
  codePointAt: define("instance/code-point-at", ["es.string.code-point-at"]),
  codePoints: define("instance/code-points", ["esnext.string.code-points"]),
  concat: define("instance/concat", ["es.array.concat"], void 0, ["String"]),
  copyWithin: define("instance/copy-within", ["es.array.copy-within"]),
  demethodize: define("instance/demethodize", ["esnext.function.demethodize"]),
  description: define(null, ["es.symbol", "es.symbol.description"]),
  dotAll: define(null, ["es.regexp.dot-all"]),
  drop: define("instance/drop", [
    "esnext.async-iterator.drop",
    ...AsyncIteratorDependencies,
    "esnext.iterator.drop",
    ...IteratorDependencies
  ]),
  emplace: define("instance/emplace", ["esnext.map.emplace", "esnext.weak-map.emplace"]),
  endsWith: define("instance/ends-with", ["es.string.ends-with"]),
  entries: define("instance/entries", ArrayNatureIteratorsWithTag),
  every: define("instance/every", [
    "es.array.every",
    "esnext.async-iterator.every",
    "esnext.iterator.every",
    ...IteratorDependencies
  ]),
  exec: define(null, ["es.regexp.exec"]),
  fill: define("instance/fill", ["es.array.fill"]),
  filter: define("instance/filter", [
    "es.array.filter",
    "esnext.async-iterator.filter",
    "esnext.iterator.filter",
    ...IteratorDependencies
  ]),
  filterReject: define("instance/filterReject", ["esnext.array.filter-reject"]),
  finally: define(null, ["es.promise.finally", ...PromiseDependencies]),
  find: define("instance/find", [
    "es.array.find",
    "esnext.async-iterator.find",
    "esnext.iterator.find",
    ...IteratorDependencies
  ]),
  findIndex: define("instance/find-index", ["es.array.find-index"]),
  findLast: define("instance/find-last", ["es.array.find-last"]),
  findLastIndex: define("instance/find-last-index", ["es.array.find-last-index"]),
  fixed: define(null, ["es.string.fixed"]),
  flags: define("instance/flags", ["es.regexp.flags"]),
  flatMap: define("instance/flat-map", [
    "es.array.flat-map",
    "es.array.unscopables.flat-map",
    "esnext.async-iterator.flat-map",
    "esnext.iterator.flat-map",
    ...IteratorDependencies
  ]),
  flat: define("instance/flat", ["es.array.flat", "es.array.unscopables.flat"]),
  getYear: define(null, ["es.date.get-year"]),
  group: define("instance/group", ["esnext.array.group"]),
  groupBy: define("instance/group-by", ["esnext.array.group-by"]),
  groupByToMap: define("instance/group-by-to-map", ["esnext.array.group-by-to-map", "es.map", "es.object.to-string"]),
  groupToMap: define("instance/group-to-map", ["esnext.array.group-to-map", "es.map", "es.object.to-string"]),
  fontcolor: define(null, ["es.string.fontcolor"]),
  fontsize: define(null, ["es.string.fontsize"]),
  forEach: define("instance/for-each", [
    "es.array.for-each",
    "esnext.async-iterator.for-each",
    "esnext.iterator.for-each",
    ...IteratorDependencies,
    "web.dom-collections.for-each"
  ]),
  includes: define("instance/includes", ["es.array.includes", "es.string.includes"]),
  indexed: define("instance/indexed", [
    "esnext.async-iterator.indexed",
    ...AsyncIteratorDependencies,
    "esnext.iterator.indexed",
    ...IteratorDependencies
  ]),
  indexOf: define("instance/index-of", ["es.array.index-of"]),
  isWellFormed: define("instance/is-well-formed", ["es.string.is-well-formed"]),
  italic: define(null, ["es.string.italics"]),
  join: define(null, ["es.array.join"]),
  keys: define("instance/keys", ArrayNatureIteratorsWithTag),
  lastIndex: define(null, ["esnext.array.last-index"]),
  lastIndexOf: define("instance/last-index-of", ["es.array.last-index-of"]),
  lastItem: define(null, ["esnext.array.last-item"]),
  link: define(null, ["es.string.link"]),
  map: define("instance/map", ["es.array.map", "esnext.async-iterator.map", "esnext.iterator.map"]),
  match: define(null, ["es.string.match", "es.regexp.exec"]),
  matchAll: define("instance/match-all", ["es.string.match-all", "es.regexp.exec"]),
  name: define(null, ["es.function.name"]),
  padEnd: define("instance/pad-end", ["es.string.pad-end"]),
  padStart: define("instance/pad-start", ["es.string.pad-start"]),
  push: define("instance/push", ["es.array.push"]),
  reduce: define("instance/reduce", [
    "es.array.reduce",
    "esnext.async-iterator.reduce",
    "esnext.iterator.reduce",
    ...IteratorDependencies
  ]),
  reduceRight: define("instance/reduce-right", ["es.array.reduce-right"]),
  repeat: define("instance/repeat", ["es.string.repeat"]),
  replace: define(null, ["es.string.replace", "es.regexp.exec"]),
  replaceAll: define("instance/replace-all", ["es.string.replace-all", "es.string.replace", "es.regexp.exec"]),
  reverse: define("instance/reverse", ["es.array.reverse"]),
  search: define(null, ["es.string.search", "es.regexp.exec"]),
  setYear: define(null, ["es.date.set-year"]),
  slice: define("instance/slice", ["es.array.slice"]),
  small: define(null, ["es.string.small"]),
  some: define("instance/some", [
    "es.array.some",
    "esnext.async-iterator.some",
    "esnext.iterator.some",
    ...IteratorDependencies
  ]),
  sort: define("instance/sort", ["es.array.sort"]),
  splice: define("instance/splice", ["es.array.splice"]),
  split: define(null, ["es.string.split", "es.regexp.exec"]),
  startsWith: define("instance/starts-with", ["es.string.starts-with"]),
  sticky: define(null, ["es.regexp.sticky"]),
  strike: define(null, ["es.string.strike"]),
  sub: define(null, ["es.string.sub"]),
  substr: define(null, ["es.string.substr"]),
  sup: define(null, ["es.string.sup"]),
  take: define("instance/take", [
    "esnext.async-iterator.take",
    ...AsyncIteratorDependencies,
    "esnext.iterator.take",
    ...IteratorDependencies
  ]),
  test: define(null, ["es.regexp.test", "es.regexp.exec"]),
  toArray: define("instance/to-array", [
    "esnext.async-iterator.to-array",
    ...AsyncIteratorDependencies,
    "esnext.iterator.to-array",
    ...IteratorDependencies
  ]),
  toAsync: define(null, [
    "esnext.iterator.to-async",
    ...IteratorDependencies,
    ...AsyncIteratorDependencies,
    ...AsyncIteratorProblemMethods
  ]),
  toExponential: define(null, ["es.number.to-exponential"]),
  toFixed: define(null, ["es.number.to-fixed"]),
  toGMTString: define(null, ["es.date.to-gmt-string"]),
  toISOString: define(null, ["es.date.to-iso-string"]),
  toJSON: define(null, ["es.date.to-json", "web.url.to-json"]),
  toPrecision: define(null, ["es.number.to-precision"]),
  toReversed: define("instance/to-reversed", ["es.array.to-reversed"]),
  toSorted: define("instance/to-sorted", ["es.array.to-sorted", "es.array.sort"]),
  toSpliced: define("instance/to-spliced", ["es.array.to-spliced"]),
  toString: define(null, ["es.object.to-string", "es.error.to-string", "es.date.to-string", "es.regexp.to-string"]),
  toWellFormed: define("instance/to-well-formed", ["es.string.to-well-formed"]),
  trim: define("instance/trim", ["es.string.trim"]),
  trimEnd: define("instance/trim-end", ["es.string.trim-end"]),
  trimLeft: define("instance/trim-left", ["es.string.trim-start"]),
  trimRight: define("instance/trim-right", ["es.string.trim-end"]),
  trimStart: define("instance/trim-start", ["es.string.trim-start"]),
  uniqueBy: define("instance/unique-by", ["esnext.array.unique-by", "es.map"]),
  unshift: define("instance/unshift", ["es.array.unshift"]),
  unThis: define("instance/un-this", ["esnext.function.un-this"]),
  values: define("instance/values", ArrayNatureIteratorsWithTag),
  with: define("instance/with", ["es.array.with"]),
  __defineGetter__: define(null, ["es.object.define-getter"]),
  __defineSetter__: define(null, ["es.object.define-setter"]),
  __lookupGetter__: define(null, ["es.object.lookup-getter"]),
  __lookupSetter__: define(null, ["es.object.lookup-setter"]),
  ["__proto__"]: define(null, ["es.object.proto"])
};
const { types: t$2 } = _babel;
function canSkipPolyfill(desc, path) {
  const { node, parent } = path;
  switch (desc.name) {
    case "es.string.split":
      if (!t$2.isCallExpression(parent, { callee: node })) return false;
      if (parent.arguments.length < 1) return true;
      const splitter = parent.arguments[0];
      return t$2.isStringLiteral(splitter) || t$2.isTemplateLiteral(splitter);
  }
}
const { types: t$1 } = _babel,
  BABEL_RUNTIME = "@babel/runtime-corejs3";
function callMethod(path, id) {
  const { object } = path.node;
  let context1, context2;
  if (t$1.isIdentifier(object)) {
    context1 = object;
    context2 = t$1.cloneNode(object);
  } else {
    context1 = path.scope.generateDeclaredUidIdentifier("context");
    context2 = t$1.assignmentExpression("=", t$1.cloneNode(context1), object);
  }
  path.replaceWith(t$1.memberExpression(t$1.callExpression(id, [context2]), t$1.identifier("call")));
  path.parentPath.unshiftContainer("arguments", context1);
}
function isCoreJSSource(source) {
  if (typeof source == "string")
    source = source.replace(/\\/g, "/").replace(/(\/(index)?)?(\.js)?$/i, "").toLowerCase();

  return Object.prototype.hasOwnProperty.call(entries, source) && entries[source];
}
function coreJSModule(name) {
  return `core-js/modules/${name}.js`;
}
function coreJSPureHelper(name, useBabelRuntime, ext) {
  return useBabelRuntime ? `${BABEL_RUNTIME}/core-js/${name}${ext}` : `core-js-pure/features/${name}.js`;
}
const { types: t } = _babel,
  presetEnvCompat = "#__secret_key__@babel/preset-env__compatibility",
  runtimeCompat$1 = "#__secret_key__@babel/runtime__compatibility",
  uniqueObjects = ["array", "string", "iterator", "async-iterator", "dom-collections"].map(
    v => new RegExp(`[a-z]*\\.${v}\\..*`)
  );
const esnextFallback = (name, cb) => {
  if (cb(name)) return true;
  if (!name.startsWith("es.")) return false;
  const fallback = "esnext." + name.slice(3);
  return !!data[fallback] && cb(fallback);
};
var index$1 = definePolyfillProvider(function (
  { getUtils, method, shouldInjectPolyfill, createMetaResolver, debug, babel },
  {
    version = 3,
    proposals,
    shippedProposals,
    [presetEnvCompat]: { noRuntimeName = false } = {},
    [runtimeCompat$1]: { useBabelRuntime = false, ext = ".js" } = {}
  }
) {
  const isWebpack = babel.caller(caller => (caller == null ? void 0 : caller.name) === "babel-loader"),
    resolve = createMetaResolver({ global: BuiltIns, static: StaticProperties, instance: InstanceProperties }),
    available = new Set(getModulesListForTargetVersion(version));
  function getCoreJSPureBase(useProposalBase) {
    return useBabelRuntime
      ? (useProposalBase ? BABEL_RUNTIME + "/core-js" : BABEL_RUNTIME + "/core-js-stable")
      : useProposalBase ? "core-js-pure/features" : "core-js-pure/stable";
  }
  function maybeInjectGlobalImpl(name, utils) {
    if (shouldInjectPolyfill(name)) {
      debug(name);
      utils.injectGlobalImport(coreJSModule(name));
      return true;
    }
    return false;
  }
  function maybeInjectGlobal(names, utils, fallback = true) {
    for (const name of names)
      fallback
        ? esnextFallback(name, name => maybeInjectGlobalImpl(name, utils))
        : maybeInjectGlobalImpl(name, utils);
  }
  function maybeInjectPure(desc, hint, utils, object) {
    if (
      desc.pure &&
      !(object && desc.exclude && desc.exclude.includes(object)) &&
      esnextFallback(desc.name, shouldInjectPolyfill)
    ) {
      const { name } = desc;
      let useProposalBase = false;
      if (proposals || (shippedProposals && name.startsWith("esnext."))) useProposalBase = true;
      else if (name.startsWith("es.") && !available.has(name)) useProposalBase = true;

      const coreJSPureBase = getCoreJSPureBase(useProposalBase);
      return utils.injectDefaultImport(`${coreJSPureBase}/${desc.pure}${ext}`, hint);
    }
  }
  function isFeatureStable(name) {
    return !name.startsWith("esnext.") || "es." + name.slice(7) in data;
  }
  return {
    name: "corejs3",
    runtimeName: noRuntimeName ? null : BABEL_RUNTIME,
    polyfills: data,
    filterPolyfills: name =>
      !!available.has(name) &&
      (!(!proposals && method !== "entry-global") ||
        !(!shippedProposals || !corejs3ShippedProposalsList.has(name)) ||
        isFeatureStable(name)),
    entryGlobal(meta, utils, path) {
      if (meta.kind !== "import") return;
      const modules = isCoreJSSource(meta.source);
      if (!modules) return;
      if (modules.length === 1 && meta.source === coreJSModule(modules[0]) && shouldInjectPolyfill(modules[0])) {
        debug(null);
        return;
      }
      const modulesSet = new Set(modules);
      maybeInjectGlobal(modules.filter(module => {
        if (!module.startsWith("esnext.")) return true;
        const stable = module.replace("esnext.", "es.");
        return !modulesSet.has(stable) || !shouldInjectPolyfill(stable);
      }), utils, false);
      path.remove();
    },
    usageGlobal(meta, utils, path) {
      const resolved = resolve(meta);
      if (!resolved || canSkipPolyfill(resolved.desc, path)) return;
      let deps = resolved.desc.global;
      if (resolved.kind !== "global" && "object" in meta && meta.object && meta.placement === "prototype") {
        const low = meta.object.toLowerCase();
        deps = deps.filter(m => !uniqueObjects.some(v => v.test(m)) || m.includes(low));
      }
      maybeInjectGlobal(deps, utils);
    },
    usagePure(meta, utils, path) {
      if (meta.kind === "in") {
        meta.key !== "Symbol.iterator" ||
          path.replaceWith(t.callExpression(
            utils.injectDefaultImport(coreJSPureHelper("is-iterable", useBabelRuntime, ext), "isIterable"),
            [path.node.right]
          ));

        return;
      }
      if (path.parentPath.isUnaryExpression({ operator: "delete" })) return;
      if (meta.kind === "property") {
        if (
          !path.isMemberExpression() ||
          !path.isReferenced() ||
          path.parentPath.isUpdateExpression() ||
          t.isSuper(path.node.object)
        )
          return;

        if (meta.key === "Symbol.iterator") {
          if (!shouldInjectPolyfill("es.symbol.iterator")) return;
          const { parent, node } = path;
          if (t.isCallExpression(parent, { callee: node }))
            if (parent.arguments.length === 0) {
              path.parentPath.replaceWith(t.callExpression(
                utils.injectDefaultImport(coreJSPureHelper("get-iterator", useBabelRuntime, ext), "getIterator"),
                [node.object]
              ));
              path.skip();
            } else
              callMethod(path, utils.injectDefaultImport(
                coreJSPureHelper("get-iterator-method", useBabelRuntime, ext),
                "getIteratorMethod"
              ));
          else
            path.replaceWith(t.callExpression(
              utils.injectDefaultImport(
                coreJSPureHelper("get-iterator-method", useBabelRuntime, ext),
                "getIteratorMethod"
              ),
              [path.node.object]
            ));

          return;
        }
      }
      let resolved = resolve(meta);
      if (!resolved || canSkipPolyfill(resolved.desc, path)) return;
      if (useBabelRuntime && resolved.desc.pure && resolved.desc.pure.slice(-6) === "/index")
        resolved = Object.assign({}, resolved, {
          desc: Object.assign({}, resolved.desc, { pure: resolved.desc.pure.slice(0, -6) })
        });

      if (resolved.kind === "global") {
        const id = maybeInjectPure(resolved.desc, resolved.name, utils);
        id && path.replaceWith(id);
      } else if (resolved.kind === "static") {
        const id = maybeInjectPure(resolved.desc, resolved.name, utils, meta.object);
        id && path.replaceWith(id);
      } else if (resolved.kind === "instance") {
        const id = maybeInjectPure(resolved.desc, resolved.name + "InstanceProperty", utils, meta.object);
        if (!id) return;
        const { node } = path;
        t.isCallExpression(path.parent, { callee: node })
          ? callMethod(path, id)
          : path.replaceWith(t.callExpression(id, [node.object]));
      }
    },
    visitor: method === "usage-global" && {
      CallExpression(path) {
        if (path.get("callee").isImport()) {
          const utils = getUtils(path);
          maybeInjectGlobal(isWebpack ? PromiseDependenciesWithIterators : PromiseDependencies, utils);
        }
      },
      Function(path) {
        path.node.async && maybeInjectGlobal(PromiseDependencies, getUtils(path));
      },
      "ForOfStatement|ArrayPattern"(path) {
        maybeInjectGlobal(CommonIterators, getUtils(path));
      },
      SpreadElement(path) {
        path.parentPath.isObjectExpression() || maybeInjectGlobal(CommonIterators, getUtils(path));
      },
      YieldExpression(path) {
        path.node.delegate && maybeInjectGlobal(CommonIterators, getUtils(path));
      }
    }
  };
});

const runtimeCompat = "#__secret_key__@babel/runtime__compatibility";
var index = definePolyfillProvider(({ debug, targets, babel }, options) => {
  if (!shallowEqual(targets, babel.targets()))
    throw new Error(
      "This plugin does not use the targets option. Only preset-env's targets or top-level targets need to be configured for this plugin to work. See https://github.com/babel/babel-polyfills/issues/36 for more details."
    );

  const { [runtimeCompat]: { useBabelRuntime = false } = {} } = options;
  return {
    name: "regenerator",
    polyfills: ["regenerator-runtime"],
    usageGlobal(meta, utils) {
      if (isRegenerator(meta)) {
        debug("regenerator-runtime");
        utils.injectGlobalImport("regenerator-runtime/runtime.js");
      }
    },
    usagePure(meta, utils, path) {
      if (isRegenerator(meta)) {
        let pureName = "regenerator-runtime";
        if (useBabelRuntime) {
          var _get = path.hub.file.get("runtimeHelpersModuleName");
          pureName = (_get != null ? _get : "@babel/runtime") + "/regenerator";
        }
        path.replaceWith(utils.injectDefaultImport(pureName, "regenerator-runtime"));
      }
    }
  };
});
const isRegenerator = meta => meta.kind === "global" && meta.name === "regeneratorRuntime";
function shallowEqual(obj1, obj2) {
  return JSON.stringify(obj1) === JSON.stringify(obj2);
}

const pluginCorejs2 = index$2.default || index$2,
  pluginCorejs3 = index$1.default || index$1,
  pluginRegenerator$1 = index.default || index,
  pluginsCompat = "#__secret_key__@babel/runtime__compatibility";
function createCorejsPlugin(plugin, options, regeneratorPlugin) {
  return (api, _, filename) => Object.assign({}, plugin(api, options, filename), { inherits: regeneratorPlugin });
}
function createRegeneratorPlugin(options, useRuntimeRegenerator) {
  return useRuntimeRegenerator ? (api, _, filename) => pluginRegenerator$1(api, options, filename) : void 0;
}
function createBasePolyfillsPlugin({
  corejs,
  regenerator: useRuntimeRegenerator = true
}, runtimeVersion, absoluteImports) {
  let rawVersion,
    proposals = false;
  if (typeof corejs == "object" && corejs !== null) {
    rawVersion = corejs.version;
    proposals = Boolean(corejs.proposals);
  } else rawVersion = corejs;

  const corejsVersion = !!rawVersion && Number(rawVersion);
  if (![false, 2, 3].includes(corejsVersion))
    throw new Error(`The \`core-js\` version must be false, 2 or 3, but got ${JSON.stringify(rawVersion)}.`);

  if (proposals && (!corejsVersion || corejsVersion < 3))
    throw new Error("The 'proposals' option is only supported when using 'corejs: 3'");

  if (typeof useRuntimeRegenerator != "boolean")
    throw new Error("The 'regenerator' option must be undefined, or a boolean.");

  const polyfillOpts = {
    method: "usage-pure",
    absoluteImports,
    [pluginsCompat]: { useBabelRuntime: true, runtimeVersion, ext: "" }
  };
  return corejsVersion === 2
    ? createCorejsPlugin(pluginCorejs2, polyfillOpts, createRegeneratorPlugin(polyfillOpts, useRuntimeRegenerator))
    : corejsVersion === 3
    ? createCorejsPlugin(
        pluginCorejs3,
        Object.assign({ version: 3, proposals }, polyfillOpts),
        createRegeneratorPlugin(polyfillOpts, useRuntimeRegenerator)
      )
    : createRegeneratorPlugin(polyfillOpts, useRuntimeRegenerator);
}

function supportsStaticESM$1(caller) {
  return !(caller == null || !caller.supportsStaticESM);
}
var transformRuntime = declare((api, options, dirname) => {
  api.assertVersion(7);
  const {
    helpers: useRuntimeHelpers = true,
    useESModules = false,
    version: runtimeVersion = "7.0.0-beta.0",
    absoluteRuntime = false
  } = options;
  if (typeof useRuntimeHelpers != "boolean") throw new Error("The 'helpers' option must be undefined, or a boolean.");

  if (typeof useESModules != "boolean" && useESModules !== "auto")
    throw new Error("The 'useESModules' option must be undefined, or a boolean, or 'auto'.");

  if (typeof absoluteRuntime != "boolean" && typeof absoluteRuntime != "string")
    throw new Error("The 'absoluteRuntime' option must be undefined, a boolean, or a string.");

  if (typeof runtimeVersion != "string") throw new Error("The 'version' option must be a version string.");

  var supportsCJSDefault = hasMinVersion$1("7.13.0", runtimeVersion);

  function has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  if (has(options, "useBuiltIns"))
    throw options.useBuiltIns
      ? new Error("The 'useBuiltIns' option has been removed. The @babel/runtime module now uses builtins by default.")
      : new Error(
          "The 'useBuiltIns' option has been removed. Use the 'corejs'option to polyfill with `core-js` via @babel/runtime."
        );

  if (has(options, "polyfill"))
    throw options.polyfill === false
      ? new Error("The 'polyfill' option has been removed. The @babel/runtime module now skips polyfilling by default.")
      : new Error(
          "The 'polyfill' option has been removed. Use the 'corejs'option to polyfill with `core-js` via @babel/runtime."
        );

  if (has(options, "moduleName"))
    throw new Error(
      "The 'moduleName' option has been removed. @babel/transform-runtime no longer supports arbitrary runtimes. If you were using this to set an absolute path for Babel's standard runtimes, please use the 'absoluteRuntime' option."
    );

  const esModules = useESModules === "auto" ? api.caller(supportsStaticESM$1) : useESModules,
    HEADER_HELPERS = ["interopRequireWildcard", "interopRequireDefault"];
  return {
    name: "transform-runtime",
    inherits: createBasePolyfillsPlugin(options, runtimeVersion, absoluteRuntime),
    pre(file) {
      if (!useRuntimeHelpers) return;
      let modulePath;
      file.set("helperGenerator", name => {
        var _file$get;
        modulePath != null ||
          (modulePath = getRuntimePath(
            (_file$get = file.get("runtimeHelpersModuleName")) != null ? _file$get : "@babel/runtime",
            dirname, absoluteRuntime
          ));

        if (file.availableHelper == null || !file.availableHelper(name, runtimeVersion))
          return name === "regeneratorRuntime"
            ? t$5.arrowFunctionExpression([], t$5.identifier("regeneratorRuntime"))
            : void 0;

        const blockHoist = HEADER_HELPERS.indexOf(name) > -1 && !isModule(file.path) ? 4 : void 0,
          helpersDir = esModules && file.path.node.sourceType === "module" ? "helpers/esm" : "helpers";
        let helperPath = `${modulePath}/${helpersDir}/${name}`;
        if (absoluteRuntime) helperPath = resolveFSPath(helperPath);
        return addDefaultImport(helperPath, name, blockHoist, true);
      });
      const cache = new Map();
      function addDefaultImport(source, nameHint, blockHoist, isHelper = false) {
        const key = `${source}:${nameHint}:${isModule(file.path) || ""}`;
        let cached = cache.get(key);
        if (cached) cached = t$5.cloneNode(cached);
        else {
          cached = addDefault(file.path, source, {
            importedInterop: isHelper && supportsCJSDefault ? "compiled" : "uncompiled",
            nameHint,
            blockHoist
          });
          cache.set(key, cached);
        }
        return cached;
      }
    }
  };
});

var transformShorthandProperties = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-shorthand-properties",
    visitor: {
      ObjectMethod(path) {
        const { node } = path;
        if (node.kind === "method") {
          const func = t$5.functionExpression(null, node.params, node.body, node.generator, node.async);
          func.returnType = node.returnType;
          const computedKey = t$5.toComputedKey(node);
          t$5.isStringLiteral(computedKey, { value: "__proto__" })
            ? path.replaceWith(t$5.objectProperty(computedKey, func, true))
            : path.replaceWith(t$5.objectProperty(node.key, func, node.computed));
        }
      },
      ObjectProperty(path) {
        const { node } = path;
        if (node.shorthand) {
          const computedKey = t$5.toComputedKey(node);
          t$5.isStringLiteral(computedKey, { value: "__proto__" })
            ? path.replaceWith(t$5.objectProperty(computedKey, node.value, true))
            : (node.shorthand = false);
        }
      }
    }
  };
});

var transformSpread = declare((api, options) => {
  var _api$assumption, _options$allowArrayLi;
  api.assertVersion(7);
  const iterableIsArray =
    (_api$assumption = api.assumption("iterableIsArray")) != null ? _api$assumption : options.loose;
  const arrayLikeIsIterable = (_options$allowArrayLi = options.allowArrayLike) != null
    ? _options$allowArrayLi
    : api.assumption("arrayLikeIsIterable");
  function getSpreadLiteral(spread, scope) {
    return iterableIsArray && !t$5.isIdentifier(spread.argument, { name: "arguments" })
      ? spread.argument
      : scope.toArray(spread.argument, true, arrayLikeIsIterable);
  }
  function hasHole(spread) {
    return spread.elements.some(el => el === null);
  }
  function hasSpread(nodes) {
    for (let i = 0; i < nodes.length; i++) if (t$5.isSpreadElement(nodes[i])) return true;

    return false;
  }
  function push(_props, nodes) {
    if (!_props.length) return _props;
    nodes.push(t$5.arrayExpression(_props));
    return [];
  }
  function build(props, scope, file) {
    const nodes = [];
    let _props = [];
    for (const prop of props)
      if (t$5.isSpreadElement(prop)) {
        _props = push(_props, nodes);
        let spreadLiteral = getSpreadLiteral(prop, scope);
        if (t$5.isArrayExpression(spreadLiteral) && hasHole(spreadLiteral))
          spreadLiteral = t$5.callExpression(file.addHelper("arrayWithoutHoles"), [spreadLiteral]);

        nodes.push(spreadLiteral);
      } else _props.push(prop);

    push(_props, nodes);
    return nodes;
  }
  return {
    name: "transform-spread",
    visitor: {
      ArrayExpression(path) {
        const { node, scope } = path,
          elements = node.elements;
        if (!hasSpread(elements)) return;
        const nodes = build(elements, scope, this.file);
        let first = nodes[0];
        if (nodes.length !== 1 || first === elements[0].argument) {
          t$5.isArrayExpression(first) ? nodes.shift() : (first = t$5.arrayExpression([]));

          path.replaceWith(t$5.callExpression(t$5.memberExpression(first, t$5.identifier("concat")), nodes));
        } else path.replaceWith(first);
      },
      CallExpression(path) {
        const { node, scope } = path,
          args = node.arguments;
        if (!hasSpread(args)) return;
        const calleePath = skipTransparentExprWrappers(path.get("callee"));
        if (calleePath.isSuper())
          throw path.buildCodeFrameError("\
It's not possible to compile spread arguments in `super()` without compiling classes.\n\
Please add '@babel/plugin-transform-classes' to your Babel configuration.");

        let contextLiteral = scope.buildUndefinedNode();
        node.arguments = [];
        let nodes =
          args.length === 1 && t$5.isIdentifier(args[0].argument, { name: "arguments" })
            ? [args[0].argument]
            : build(args, scope, this.file);

        const first = nodes.shift();
        nodes.length
          ? node.arguments.push(t$5.callExpression(t$5.memberExpression(first, t$5.identifier("concat")), nodes))
          : node.arguments.push(first);

        const callee = calleePath.node;
        if (t$5.isMemberExpression(callee)) {
          const temp = scope.maybeGenerateMemoised(callee.object);
          if (temp) {
            callee.object = t$5.assignmentExpression("=", temp, callee.object);
            contextLiteral = temp;
          } else contextLiteral = t$5.cloneNode(callee.object);
        }
        node.callee = t$5.memberExpression(node.callee, t$5.identifier("apply"));
        if (t$5.isSuper(contextLiteral)) contextLiteral = t$5.thisExpression();

        node.arguments.unshift(t$5.cloneNode(contextLiteral));
      },
      NewExpression(path) {
        const { node, scope } = path;
        if (!hasSpread(node.arguments)) return;
        const nodes = build(node.arguments, scope, this.file),
          first = nodes.shift();
        let args = nodes.length
          ? t$5.callExpression(t$5.memberExpression(first, t$5.identifier("concat")), nodes)
          : first;

        path.replaceWith(t$5.callExpression(path.hub.addHelper("construct"), [node.callee, args]));
      }
    }
  };
});

var transformStickyRegex = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-sticky-regex",
    visitor: {
      RegExpLiteral(path) {
        const { node } = path;
        node.flags.includes("y") &&
          path.replaceWith(t$5.newExpression(t$5.identifier("RegExp"), [
            t$5.stringLiteral(node.pattern), t$5.stringLiteral(node.flags)
          ]));
      }
    }
  };
});

var transformStrictMode = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-strict-mode",
    visitor: {
      Program(path) {
        const { node } = path;
        for (const directive of node.directives) if (directive.value.value === "use strict") return;

        path.unshiftContainer("directives", t$5.directive(t$5.directiveLiteral("use strict")));
      }
    }
  };
});

var transformTemplateLiterals = declare((api, options) => {
  var _api$assumption, _api$assumption2;
  api.assertVersion(7);
  const ignoreToPrimitiveHint =
      (_api$assumption = api.assumption("ignoreToPrimitiveHint")) != null ? _api$assumption : options.loose,
    mutableTemplateObject =
      (_api$assumption2 = api.assumption("mutableTemplateObject")) != null ? _api$assumption2 : options.loose;
  let helperName = "taggedTemplateLiteral";
  if (mutableTemplateObject) helperName += "Loose";
  function buildConcatCallExpressions(items) {
    let avail = true;
    return items.reduce(function (left, right) {
      let canBeInserted = t$5.isLiteral(right);
      if (!canBeInserted && avail) {
        canBeInserted = true;
        avail = false;
      }
      if (canBeInserted && t$5.isCallExpression(left)) {
        left.arguments.push(right);
        return left;
      }
      return t$5.callExpression(t$5.memberExpression(left, t$5.identifier("concat")), [right]);
    });
  }
  return {
    name: "transform-template-literals",
    visitor: {
      TaggedTemplateExpression(path) {
        const { node } = path,
          { quasi } = node,
          strings = [],
          raws = [];
        let isStringsRawEqual = true;
        for (const elem of quasi.quasis) {
          const { raw, cooked } = elem.value,
            value = cooked == null ? path.scope.buildUndefinedNode() : t$5.stringLiteral(cooked);
          strings.push(value);
          raws.push(t$5.stringLiteral(raw));
          if (raw !== cooked) isStringsRawEqual = false;
        }
        const helperArgs = [t$5.arrayExpression(strings)];
        isStringsRawEqual || helperArgs.push(t$5.arrayExpression(raws));

        const tmp = path.scope.generateUidIdentifier("templateObject");
        path.scope.getProgramParent().push({ id: t$5.cloneNode(tmp) });
        path.replaceWith(
          t$5.callExpression(node.tag, [
            template$1.expression.ast`
              ${t$5.cloneNode(tmp)} || (${tmp} = ${this.addHelper(helperName)}(${helperArgs}))
            `,
            ...quasi.expressions
          ])
        );
      },
      TemplateLiteral(path) {
        if (path.parent.type === "TSLiteralType") return;

        const nodes = [],
          expressions = path.get("expressions");
        let index = 0;
        for (const elem of path.node.quasis) {
          elem.value.cooked && nodes.push(t$5.stringLiteral(elem.value.cooked));

          if (index < expressions.length) {
            const node = expressions[index++].node;
            t$5.isStringLiteral(node, { value: "" }) || nodes.push(node);
          }
        }
        t$5.isStringLiteral(nodes[0]) || (ignoreToPrimitiveHint && t$5.isStringLiteral(nodes[1])) ||
          nodes.unshift(t$5.stringLiteral(""));

        let root = nodes[0];
        if (ignoreToPrimitiveHint)
          for (let i = 1; i < nodes.length; i++) root = t$5.binaryExpression("+", root, nodes[i]);
        else if (nodes.length > 1) root = buildConcatCallExpressions(nodes);

        path.replaceWith(root);
      }
    }
  };
});

var transformTypeofSymbol = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-typeof-symbol",
    visitor: {
      Scope({ scope }) {
        scope.getBinding("Symbol") && scope.rename("Symbol");
      },
      UnaryExpression(path) {
        const { node, parent } = path;
        if (node.operator !== "typeof") return;
        if (path.parentPath.isBinaryExpression() && t$5.EQUALITY_BINARY_OPERATORS.indexOf(parent.operator) >= 0) {
          const opposite = path.getOpposite();
          if (opposite.isStringLiteral() && opposite.node.value !== "symbol" && opposite.node.value !== "object")
            return;
        }
        let isUnderHelper = path.findParent(path => {
          if (path.isFunction()) {
            var _path$get = path.get("body.directives.0");
            return (_path$get == null ? void 0 : _path$get.node.value.value) === "@babel/helpers - typeof";
          }
        });
        if (isUnderHelper) return;
        const helper = this.addHelper("typeof");
        isUnderHelper = path.findParent(path =>
          (path.isVariableDeclarator() && path.node.id === helper) ||
          (path.isFunctionDeclaration() && path.node.id && path.node.id.name === helper.name)
        );
        if (isUnderHelper) return;

        const call = t$5.callExpression(helper, [node.argument]),
          arg = path.get("argument");
        if (arg.isIdentifier() && !path.scope.hasBinding(arg.node.name, true)) {
          const unary = t$5.unaryExpression("typeof", t$5.cloneNode(node.argument));
          path.replaceWith(t$5.conditionalExpression(
            t$5.binaryExpression("===", unary, t$5.stringLiteral("undefined")),
            t$5.stringLiteral("undefined"), call
          ));
        } else path.replaceWith(call);
      }
    }
  };
});

var transformUnicodeEscapes = declare(api => {
  api.assertVersion(7);
  const surrogate = /[\ud800-\udfff]/g,
    unicodeEscape = /(\\+)u\{([0-9a-fA-F]+)\}/g;
  function escape(code) {
    let str = code.toString(16);
    while (str.length < 4) str = "0" + str;
    return "\\u" + str;
  }
  function replacer(match, backslashes, code) {
    if (backslashes.length % 2 == 0) return match;

    const char = String.fromCodePoint(parseInt(code, 16)),
      escaped = backslashes.slice(0, -1) + escape(char.charCodeAt(0));
    return char.length === 1 ? escaped : escaped + escape(char.charCodeAt(1));
  }
  function replaceUnicodeEscapes(str) {
    return str.replace(unicodeEscape, replacer);
  }
  function getUnicodeEscape(str) {
    for (let match; (match = unicodeEscape.exec(str)); )
      if (match[1].length % 2 != 0) {
        unicodeEscape.lastIndex = 0;
        return match[0];
      }

    return null;
  }
  return {
    name: "transform-unicode-escapes",
    manipulateOptions({ generatorOpts }) {
      var _generatorOpts$jsescO;
      generatorOpts.jsescOption || (generatorOpts.jsescOption = {});

      (_generatorOpts$jsescO = generatorOpts.jsescOption).minimal != null || (_generatorOpts$jsescO.minimal = false);
    },
    visitor: {
      Identifier(path) {
        const { node, key } = path,
          { name } = node,
          replaced = name.replace(surrogate, c => "_u" + c.charCodeAt(0).toString(16));
        if (name === replaced) return;
        const str = t$5.inherits(t$5.stringLiteral(name), node);
        if (key === "key") {
          path.replaceWith(str);
          return;
        }
        const { parentPath, scope } = path;
        if (
          parentPath.isMemberExpression({ property: node }) ||
          parentPath.isOptionalMemberExpression({ property: node })
        ) {
          parentPath.node.computed = true;
          path.replaceWith(str);
          return;
        }
        if (!scope.getBinding(name)) throw path.buildCodeFrameError(`Can't reference '${name}' as a bare identifier`);

        scope.rename(name, scope.generateUid(replaced));
      },
      "StringLiteral|DirectiveLiteral"(path) {
        const { node } = path,
          { extra } = node;
        if (extra != null && extra.raw) extra.raw = replaceUnicodeEscapes(extra.raw);
      },
      TemplateElement(path) {
        const { node, parentPath } = path,
          { value } = node,
          firstEscape = getUnicodeEscape(value.raw);
        if (!firstEscape) return;
        if (parentPath.parentPath.isTaggedTemplateExpression())
          throw path.buildCodeFrameError(
            `Can't replace Unicode escape '${firstEscape}' inside tagged template literals. You can enable '@babel/plugin-transform-template-literals' to compile them to classic strings.`
          );

        value.raw = replaceUnicodeEscapes(value.raw);
      }
    }
  };
});

var transformUnicodeRegex = declare(api => {
  api.assertVersion(7);
  return createRegExpFeaturePlugin({ name: "transform-unicode-regex", feature: "unicodeFlag" });
});

var proposalExplicitResourceManagement = declare(api => {
  api.assertVersion("^7.22.0");
  const TOP_LEVEL_USING = new Map();
  function isUsingDeclaration(node) {
    return (
      !!t$5.isVariableDeclaration(node) &&
      (node.kind === "using" || node.kind === "await using" || TOP_LEVEL_USING.has(node))
    );
  }
  const transformUsingDeclarationsVisitor = {
    ForOfStatement(path) {
      const { left } = path.node;
      if (!isUsingDeclaration(left)) return;
      const { id } = left.declarations[0],
        tmpId = path.scope.generateUidIdentifierBasedOnNode(id);
      left.declarations[0].id = tmpId;
      left.kind = "const";
      path.ensureBlock();
      path.node.body.body.unshift(t$5.variableDeclaration("using", [t$5.variableDeclarator(id, t$5.cloneNode(tmpId))]));
    },
    "BlockStatement|StaticBlock"(path, state) {
      let stackId = null,
        needsAwait = false;
      for (const node of path.node.body) {
        if (!isUsingDeclaration(node)) continue;
        stackId != null || (stackId = path.scope.generateUidIdentifier("stack"));
        const isAwaitUsing = node.kind === "await using" || TOP_LEVEL_USING.get(node) === 1;
        needsAwait || (needsAwait = isAwaitUsing);
        TOP_LEVEL_USING.delete(node) || (node.kind = "const");

        node.declarations.forEach(decl => {
          const args = [t$5.cloneNode(stackId), decl.init];
          isAwaitUsing && args.push(t$5.booleanLiteral(true));
          decl.init = t$5.callExpression(state.addHelper("using"), args);
        });
      }
      if (!stackId) return;
      const errorId = path.scope.generateUidIdentifier("error"),
        hasErrorId = path.scope.generateUidIdentifier("hasError");
      let disposeCall = t$5.callExpression(state.addHelper("dispose"), [
        t$5.cloneNode(stackId), t$5.cloneNode(errorId), t$5.cloneNode(hasErrorId)
      ]);
      if (needsAwait) disposeCall = t$5.awaitExpression(disposeCall);
      const replacement = template$1.statement.ast`
        try {
          var ${stackId} = [];
          ${path.node.body}
        } catch (_) {
          var ${errorId} = _,
            ${hasErrorId} = true;
        } finally {
          ${disposeCall}
        }
      `;
      const { parentPath } = path;
      parentPath.isFunction() || parentPath.isTryStatement() || parentPath.isCatchClause()
        ? path.replaceWith(t$5.blockStatement([replacement]))
        : path.isStaticBlock()
        ? (path.node.body = [replacement])
        : path.replaceWith(replacement);
    }
  };
  const transformUsingDeclarationsVisitorSkipFn = traverse.visitors.merge([transformUsingDeclarationsVisitor, {
    Function(path) {
      path.skip();
    }
  }]);
  return {
    name: "proposal-explicit-resource-management",
    inherits: syntaxExplicitResourceManagement,
    visitor: traverse.visitors.merge([transformUsingDeclarationsVisitor, {
      Program(path) {
        TOP_LEVEL_USING.clear();
        if (path.node.sourceType !== "module" || !path.node.body.some(isUsingDeclaration)) return;
        const innerBlockBody = [];
        for (const stmt of path.get("body")) {
          if (stmt.isFunctionDeclaration() || stmt.isImportDeclaration()) continue;

          let { node } = stmt,
            shouldRemove = true;
          if (stmt.isExportDefaultDeclaration()) {
            let varId,
              { declaration } = stmt.node;
            if (t$5.isClassDeclaration(declaration)) {
              varId = declaration.id;
              declaration.id = null;
              declaration = t$5.toExpression(declaration);
            } else if (!t$5.isExpression(declaration)) continue;

            varId != null || (varId = path.scope.generateUidIdentifier("_default"));
            innerBlockBody.push(t$5.variableDeclaration("var", [t$5.variableDeclarator(varId, declaration)]));
            stmt.replaceWith(t$5.exportNamedDeclaration(null, [
              t$5.exportSpecifier(t$5.cloneNode(varId), t$5.identifier("default"))
            ]));
            continue;
          }
          if (stmt.isExportNamedDeclaration()) {
            node = stmt.node.declaration;
            if (!node || t$5.isFunction(node)) continue;
            stmt.replaceWith(t$5.exportNamedDeclaration(
              null,
              Object.keys(t$5.getOuterBindingIdentifiers(node, false)).map(id =>
                t$5.exportSpecifier(t$5.identifier(id), t$5.identifier(id))
              )
            ));
            shouldRemove = false;
          } else if (stmt.isExportDeclaration()) continue;

          if (t$5.isClassDeclaration(node)) {
            const { id } = node;
            node.id = null;
            innerBlockBody.push(t$5.variableDeclaration("var", [t$5.variableDeclarator(id, t$5.toExpression(node))]));
          } else if (t$5.isVariableDeclaration(node)) {
            node.kind === "using"
              ? TOP_LEVEL_USING.set(stmt.node, 0)
              : node.kind !== "await using" || TOP_LEVEL_USING.set(stmt.node, 1);

            node.kind = "var";
            innerBlockBody.push(node);
          } else innerBlockBody.push(stmt.node);

          shouldRemove && stmt.remove();
        }
        path.pushContainer("body", t$5.blockStatement(innerBlockBody));
      },
      Function(path, state) {
        path.node.async && path.traverse(transformUsingDeclarationsVisitorSkipFn, state);
      }
    }])
  };
});

const syntaxAsyncGenerators = makeNoopPlugin(),
  syntaxClassProperties = makeNoopPlugin(),
  syntaxClassStaticBlock = makeNoopPlugin(),
  syntaxImportMeta = makeNoopPlugin(),
  syntaxObjectRestSpread = makeNoopPlugin(),
  syntaxOptionalCatchBinding = makeNoopPlugin(),
  syntaxTopLevelAwait = makeNoopPlugin();
const all = {
  "syntax-async-generators": syntaxAsyncGenerators,
  "syntax-class-properties": syntaxClassProperties,
  "syntax-class-static-block": syntaxClassStaticBlock,
  "syntax-import-meta": syntaxImportMeta,
  "syntax-object-rest-spread": syntaxObjectRestSpread,
  "syntax-optional-catch-binding": syntaxOptionalCatchBinding,
  "syntax-top-level-await": syntaxTopLevelAwait,
  "external-helpers": externalHelpers,
  "syntax-decimal": syntaxDecimal,
  "syntax-decorators": syntaxDecorators,
  "syntax-destructuring-private": syntaxDestructuringPrivate,
  "syntax-do-expressions": syntaxDoExpressions,
  "syntax-explicit-resource-management": syntaxExplicitResourceManagement,
  "syntax-export-default-from": syntaxExportDefaultFrom,
  "syntax-flow": syntaxFlow,
  "syntax-function-bind": syntaxFunctionBind,
  "syntax-function-sent": syntaxFunctionSent,
  "syntax-import-assertions": syntaxImportAssertions,
  "syntax-import-attributes": syntaxImportAttributes,
  "syntax-import-reflection": syntaxImportReflection,
  "syntax-module-blocks": syntaxModuleBlocks,
  "syntax-jsx": syntaxJsx,
  "syntax-pipeline-operator": syntaxPipelineOperator,
  "syntax-record-and-tuple": syntaxRecordAndTuple,
  "syntax-typescript": syntaxTypescript,
  "transform-async-generator-functions": proposalAsyncGeneratorFunctions,
  "transform-class-properties": proposalClassProperties,
  "transform-class-static-block": proposalClassStaticBlock,
  "proposal-decorators": proposalDecorators,
  "proposal-destructuring-private": proposalDestructuringPrivate,
  "proposal-do-expressions": proposalDoExpressions,
  "proposal-duplicate-named-capturing-groups-regex": proposalDuplicateNamedCapturingGroupsRegex,
  "transform-dynamic-import": proposalDynamicImport,
  "proposal-export-default-from": proposalExportDefaultFrom,
  "transform-export-namespace-from": proposalExportNamespaceFrom,
  "proposal-function-bind": proposalFunctionBind,
  "proposal-function-sent": proposalFunctionSent,
  "transform-json-strings": proposalJsonStrings,
  "transform-logical-assignment-operators": proposalLogicalAssignmentOperators,
  "transform-nullish-coalescing-operator": proposalNullishCoalescingOperator,
  "transform-numeric-separator": proposalNumericSeparator,
  "transform-object-rest-spread": proposalObjectRestSpread,
  "transform-optional-catch-binding": proposalOptionalCatchBinding,
  "transform-optional-chaining": proposalOptionalChaining,
  "proposal-pipeline-operator": proposalPipelineOperator,
  "transform-private-methods": proposalPrivateMethods,
  "transform-private-property-in-object": proposalPrivatePropertyInObject,
  "proposal-record-and-tuple": proposalRecordAndTuple,
  "proposal-regexp-modifiers": proposalRegexpModifiers,
  "proposal-throw-expressions": proposalThrowExpressions,
  "transform-unicode-property-regex": proposalUnicodePropertyRegex,
  "transform-unicode-sets-regex": transformUnicodeSetsRegex,
  "transform-async-to-generator": transformAsyncToGenerator,
  "transform-arrow-functions": transformArrowFunctions,
  "transform-block-scoped-functions": transformBlockScopedFunctions,
  "transform-block-scoping": transformBlockScoping,
  "transform-classes": transformClasses,
  "transform-computed-properties": transformComputedProperties,
  "transform-destructuring": transformDestructuring,
  "transform-dotall-regex": transformDotallRegex,
  "transform-duplicate-keys": transformDuplicateKeys,
  "transform-exponentiation-operator": transformExponentialOperator,
  "transform-flow-comments": transformFlowComments,
  "transform-flow-strip-types": transformFlowStripTypes,
  "transform-for-of": transformForOf,
  "transform-function-name": transformFunctionName,
  "transform-instanceof": transformInstanceof,
  "transform-jscript": transformJscript,
  "transform-literals": transformLiterals,
  "transform-member-expression-literals": transformMemberExpressionLiterals,
  "transform-modules-amd": transformModulesAmd,
  "transform-modules-commonjs": transformModulesCommonjs,
  "transform-modules-systemjs": transformModulesSystemjs,
  "transform-modules-umd": transformModulesUmd,
  "transform-named-capturing-groups-regex": transformNamedCapturingGroupsRegex,
  "transform-new-target": transformNewTarget,
  "transform-object-assign": transformObjectAssign,
  "transform-object-super": transformObjectSuper,
  "transform-object-set-prototype-of-to-assign": transformObjectSetPrototypeOfToAssign,
  "transform-parameters": transformParameters,
  "transform-property-literals": transformPropertyLiterals,
  "transform-property-mutators": transformPropertyMutators,
  "transform-proto-to-assign": transformProtoToAssign,
  "transform-react-constant-elements": transformReactConstantElements,
  "transform-react-display-name": transformReactDisplayName,
  "transform-react-inline-elements": transformReactInlineElements,
  "transform-react-jsx": transformReactJSX,
  "transform-react-jsx-compat": transformReactJsxCompat,
  "transform-react-jsx-development": transformReactJSXDevelopment,
  "transform-react-jsx-self": transformReactJsxSelf,
  "transform-react-jsx-source": transformReactJsxSource,
  "transform-regenerator": transformRegenerator,
  "transform-reserved-words": transformReservedWords,
  "transform-runtime": transformRuntime,
  "transform-shorthand-properties": transformShorthandProperties,
  "transform-spread": transformSpread,
  "transform-sticky-regex": transformStickyRegex,
  "transform-strict-mode": transformStrictMode,
  "transform-template-literals": transformTemplateLiterals,
  "transform-typeof-symbol": transformTypeofSymbol,
  "transform-typescript": transformTypescript,
  "transform-unicode-escapes": transformUnicodeEscapes,
  "transform-unicode-regex": transformUnicodeRegex,
  "proposal-explicit-resource-management": proposalExplicitResourceManagement
};

var preset2015 = (_, opts) => {
  let loose = false,
    modules = "commonjs",
    spec = false;
  if (opts !== void 0) {
    if (opts.loose !== void 0) loose = opts.loose;
    if (opts.modules !== void 0) modules = opts.modules;
    if (opts.spec !== void 0) spec = opts.spec;
  }
  const optsLoose = { loose };
  return {
    plugins: [
      [transformTemplateLiterals, { loose, spec }], transformLiterals, transformFunctionName,
      [transformArrowFunctions, { spec }], transformBlockScopedFunctions, [transformClasses, optsLoose],
      transformObjectSuper, transformShorthandProperties, transformDuplicateKeys,
      [transformComputedProperties, optsLoose], [transformForOf, optsLoose], transformStickyRegex,
      transformUnicodeEscapes, transformUnicodeRegex, [transformSpread, optsLoose], [transformParameters, optsLoose],
      [transformDestructuring, optsLoose], transformBlockScoping, transformTypeofSymbol, transformInstanceof,
      (modules === "commonjs" || modules === "cjs") && [transformModulesCommonjs, optsLoose],
      modules === "systemjs" && [transformModulesSystemjs, optsLoose],
      modules === "amd" && [transformModulesAmd, optsLoose],
      modules === "umd" && [transformModulesUmd, optsLoose],
      [transformRegenerator, { async: false, asyncGenerators: false }]
    ].filter(Boolean)
  };
};

var presetStage3 = (_, opts = {}) => {
  const { loose = false, decoratorsLegacy = false, decoratorsVersion = "2018-09", decoratorsBeforeExport } = opts;
  return {
    plugins: [
      syntaxImportAssertions, transformUnicodeSetsRegex, proposalDuplicateNamedCapturingGroupsRegex,
      [proposalDecorators, { version: decoratorsLegacy ? "legacy" : decoratorsVersion, decoratorsBeforeExport }],
      proposalRegexpModifiers, proposalExplicitResourceManagement,

      proposalExportNamespaceFrom, proposalLogicalAssignmentOperators,
      [proposalOptionalChaining, { loose }], [proposalNullishCoalescingOperator, { loose }],
      [proposalClassProperties, { loose }], proposalJsonStrings, proposalNumericSeparator,
      [proposalPrivateMethods, { loose }], proposalPrivatePropertyInObject, proposalClassStaticBlock
    ]
  };
};

var presetStage2 = (_, opts = {}) => {
  const { pipelineProposal = "minimal", pipelineTopicToken = "%", recordAndTupleSyntax = "hash" } = opts;
  return {
    presets: [[presetStage3, opts]],
    plugins: [
      proposalDestructuringPrivate,
      [proposalPipelineOperator, { proposal: pipelineProposal, topicToken: pipelineTopicToken }],
      proposalFunctionSent, proposalThrowExpressions,
      [proposalRecordAndTuple, { syntaxType: recordAndTupleSyntax }],
      syntaxModuleBlocks, syntaxImportReflection
    ]
  };
};

var presetStage1 = (_, opts = {}) => {
  const {
    loose = false,
    useBuiltIns = false,
    decoratorsLegacy,
    decoratorsVersion,
    decoratorsBeforeExport,
    pipelineProposal,
    pipelineTopicToken,
    recordAndTupleSyntax
  } = opts;
  return {
    presets: [
      [presetStage2, {
        loose,
        useBuiltIns,
        decoratorsLegacy,
        decoratorsVersion,
        decoratorsBeforeExport,
        pipelineProposal,
        pipelineTopicToken,
        recordAndTupleSyntax
      }]
    ],
    plugins: [syntaxDecimal, proposalExportDefaultFrom, proposalDoExpressions]
  };
};

var presetStage0 = (_, opts = {}) => {
  const {
    loose = false,
    useBuiltIns = false,
    decoratorsLegacy,
    decoratorsVersion,
    decoratorsBeforeExport,
    pipelineProposal,
    pipelineTopicToken,
    importAssertionsVersion = "september-2020"
  } = opts;
  return {
    presets: [
      [presetStage1, {
        loose,
        useBuiltIns,
        decoratorsLegacy,
        decoratorsVersion,
        decoratorsBeforeExport,
        pipelineProposal,
        pipelineTopicToken,
        importAssertionsVersion
      }]
    ],
    plugins: [proposalFunctionBind]
  };
};

const logPlugin = (item, targetVersions, list) => {
  const filteredList = getInclusionReasons(item, targetVersions, list),
    support = list[item];

  if (item.startsWith("transform-")) {
    const proposalName = "proposal-" + item.slice(10);
    if (proposalName === "proposal-dynamic-import" || Object.prototype.hasOwnProperty.call(plugins$1, proposalName))
      item = proposalName;
  }

  if (!support) {
    console.log("  " + item);
    return;
  }
  let formattedTargets = "{",
    first = true;
  for (const target of Object.keys(filteredList)) {
    first || (formattedTargets += ",");
    first = false;
    formattedTargets += " " + target;
    if (support[target]) formattedTargets += " < " + support[target];
  }
  formattedTargets += " }";
  console.log(`  ${item} ${formattedTargets}`);
};

const defaultExcludesForLooseMode = ["transform-typeof-symbol"];
function getOptionSpecificExcludesFor({ loose }) {
  return loose ? defaultExcludesForLooseMode : null;
}

const OPTS = { allowInsertArrow: false, specCompliant: false };
var bugfixAsyncArrowsInClass = ({ types: t }) => ({
  name: "transform-async-arrows-in-class",
  visitor: {
    ArrowFunctionExpression(path) {
      path.node.async && path.findParent(t.isClassMethod) && path.arrowFunctionToExpression(OPTS);
    }
  }
});

var bugfixEdgeDefaultParameters = ({ types: t }) => {
  const isArrowParent = p => p.parentKey === "params" && p.parentPath && t.isArrowFunctionExpression(p.parentPath);
  return {
    name: "transform-edge-default-parameters",
    visitor: {
      AssignmentPattern(path) {
        if (path.find(isArrowParent) && path.parent.shorthand) {
          path.parent.shorthand = false;
          (path.parent.extra || {}).shorthand = false;
          path.scope.rename(path.parent.key.name);
        }
      }
    }
  };
};

var bugfixEdgeFunctionName = ({ types: t }) => ({
  name: "transform-edge-function-name",
  visitor: {
    FunctionExpression: {
      exit(path) {
        if (!path.node.id && t.isIdentifier(path.parent.id)) {
          const id = t.cloneNode(path.parent.id),
            binding = path.scope.getBinding(id.name);
          binding != null && binding.constantViolations.length && path.scope.rename(id.name);

          path.node.id = id;
        }
      }
    }
  }
});

var bugfixTaggedTemplateCaching = ({ types: t }) => ({
  name: "transform-tagged-template-caching",
  visitor: {
    TaggedTemplateExpression(path, state) {
      let processed = state.get("processed");
      if (!processed) {
        processed = new WeakSet();
        state.set("processed", processed);
      }
      if (processed.has(path.node)) return path.skip();
      const expressions = path.node.quasi.expressions;
      let identity = state.get("identity");
      if (!identity) {
        identity = path.scope.getProgramParent().generateDeclaredUidIdentifier("_");
        state.set("identity", identity);
        path.scope.getBinding(identity.name)
          .path.get("init").replaceWith(t.arrowFunctionExpression([t.identifier("t")], t.identifier("t")));
      }
      const template = t.taggedTemplateExpression(
        t.cloneNode(identity),
        t.templateLiteral(path.node.quasi.quasis, expressions.map(() => t.numericLiteral(0)))
      );
      processed.add(template);
      const ident = path.scope.getProgramParent().generateDeclaredUidIdentifier("t");
      path.scope.getBinding(ident.name).path.parent.kind = "let";
      const inlineCache = t.logicalExpression("||", ident, t.assignmentExpression("=", t.cloneNode(ident), template)),
        node = t.callExpression(path.node.tag, [inlineCache, ...expressions]);
      path.replaceWith(node);
    }
  }
});

function bugfixSafariBlockShadowing({ types: t }) {
  return {
    name: "transform-safari-block-shadowing",
    visitor: {
      VariableDeclarator(path) {
        const kind = path.parent.kind;
        if (kind !== "let" && kind !== "const") return;
        const block = path.scope.block;
        if (t.isFunction(block) || t.isProgram(block)) return;
        const bindings = t.getOuterBindingIdentifiers(path.node.id);
        for (const name of Object.keys(bindings)) {
          let scope = path.scope;
          if (!scope.hasOwnBinding(name)) continue;
          while ((scope = scope.parent)) {
            if (scope.hasOwnBinding(name)) {
              path.scope.rename(name);
              break;
            }
            if (t.isFunction(scope.block) || t.isProgram(scope.block)) break;
          }
        }
      }
    }
  };
}

function handle(declaration) {
  if (!declaration.isVariableDeclaration()) return;
  const fn = declaration.getFunctionParent(),
    { name } = declaration.node.declarations[0].id;
  fn && fn.scope.hasOwnBinding(name) && fn.scope.getOwnBinding(name).kind === "param" &&
    declaration.scope.rename(name);
}
var bugfixSafariForShadowing = () => ({
  name: "transform-safari-for-shadowing",
  visitor: {
    ForXStatement(path) {
      handle(path.get("left"));
    },
    ForStatement(path) {
      handle(path.get("init"));
    }
  }
});

function shouldTransform$1(path) {
  const { node } = path,
    functionId = node.id;
  if (!functionId) return false;
  const name = functionId.name,
    paramNameBinding = path.scope.getOwnBinding(name);
  return (
    paramNameBinding !== void 0 &&
    paramNameBinding.kind === "param" &&
    paramNameBinding.identifier !== paramNameBinding.path.node &&
    name
  );
}

var bugfixSafariIdDestructuringCollisionInFunctionExpression = declare(api => {
  api.assertVersion("^7.16.0");
  return {
    name: "plugin-bugfix-safari-id-destructuring-collision-in-function-expression",
    visitor: {
      FunctionExpression(path) {
        const name = shouldTransform$1(path);
        if (name) {
          const { scope } = path,
            newParamName = scope.generateUid(name);
          scope.rename(name, newParamName);
        }
      }
    }
  };
});

function matchAffectedArguments(argumentNodes) {
  const spreadIndex = argumentNodes.findIndex(node => t$5.isSpreadElement(node));
  return spreadIndex >= 0 && spreadIndex !== argumentNodes.length - 1;
}
function shouldTransform(path) {
  let optionalPath = path;
  const chains = [];
  for (;;)
    if (optionalPath.isOptionalMemberExpression()) {
      chains.push(optionalPath.node);
      optionalPath = skipTransparentExprWrappers(optionalPath.get("object"));
    } else {
      if (!optionalPath.isOptionalCallExpression()) break;

      chains.push(optionalPath.node);
      optionalPath = skipTransparentExprWrappers(optionalPath.get("callee"));
    }

  for (let i = 0; i < chains.length; i++) {
    const node = chains[i];
    if (t$5.isOptionalCallExpression(node) && matchAffectedArguments(node.arguments)) {
      if (node.optional) return true;

      const callee = chains[i + 1];
      if (t$5.isOptionalMemberExpression(callee, { optional: true })) return true;
    }
  }
  return false;
}

var bugfixV8SpreadParametersInOptionalChaining = declare(api => {
  var _api$assumption, _api$assumption2;
  api.assertVersion(7);
  const noDocumentAll = (_api$assumption = api.assumption("noDocumentAll")) != null && _api$assumption,
    pureGetters = (_api$assumption2 = api.assumption("pureGetters")) != null && _api$assumption2;
  return {
    name: "bugfix-v8-spread-parameters-in-optional-chaining",
    visitor: {
      "OptionalCallExpression|OptionalMemberExpression"(path) {
        shouldTransform(path) && transform$1(path, { noDocumentAll, pureGetters });
      }
    }
  };
});

const availablePlugins$1 = {
  "bugfix/transform-async-arrows-in-class": () => bugfixAsyncArrowsInClass,
  "bugfix/transform-edge-default-parameters": () => bugfixEdgeDefaultParameters,
  "bugfix/transform-edge-function-name": () => bugfixEdgeFunctionName,
  "bugfix/transform-safari-block-shadowing": () => bugfixSafariBlockShadowing,
  "bugfix/transform-safari-for-shadowing": () => bugfixSafariForShadowing,
  "bugfix/transform-safari-id-destructuring-collision-in-function-expression": () =>
    bugfixSafariIdDestructuringCollisionInFunctionExpression,
  "bugfix/transform-tagged-template-caching": () => bugfixTaggedTemplateCaching,
  "bugfix/transform-v8-spread-parameters-in-optional-chaining": () => bugfixV8SpreadParametersInOptionalChaining,
  "syntax-import-assertions": () => syntaxImportAssertions,
  "syntax-import-attributes": () => syntaxImportAttributes,
  "transform-arrow-functions": () => transformArrowFunctions,
  "transform-async-generator-functions": () => proposalAsyncGeneratorFunctions,
  "transform-async-to-generator": () => transformAsyncToGenerator,
  "transform-block-scoped-functions": () => transformBlockScopedFunctions,
  "transform-block-scoping": () => transformBlockScoping,
  "transform-class-properties": () => proposalClassProperties,
  "transform-class-static-block": () => proposalClassStaticBlock,
  "transform-classes": () => transformClasses,
  "transform-computed-properties": () => transformComputedProperties,
  "transform-destructuring": () => transformDestructuring,
  "transform-dotall-regex": () => transformDotallRegex,
  "transform-duplicate-keys": () => transformDuplicateKeys,
  "transform-dynamic-import": () => proposalDynamicImport,
  "transform-exponentiation-operator": () => transformExponentialOperator,
  "transform-export-namespace-from": () => proposalExportNamespaceFrom,
  "transform-for-of": () => transformForOf,
  "transform-function-name": () => transformFunctionName,
  "transform-json-strings": () => proposalJsonStrings,
  "transform-literals": () => transformLiterals,
  "transform-logical-assignment-operators": () => proposalLogicalAssignmentOperators,
  "transform-member-expression-literals": () => transformMemberExpressionLiterals,
  "transform-modules-amd": () => transformModulesAmd,
  "transform-modules-commonjs": () => transformModulesCommonjs,
  "transform-modules-systemjs": () => transformModulesSystemjs,
  "transform-modules-umd": () => transformModulesUmd,
  "transform-named-capturing-groups-regex": () => transformNamedCapturingGroupsRegex,
  "transform-new-target": () => transformNewTarget,
  "transform-nullish-coalescing-operator": () => proposalNullishCoalescingOperator,
  "transform-numeric-separator": () => proposalNumericSeparator,
  "transform-object-rest-spread": () => proposalObjectRestSpread,
  "transform-object-super": () => transformObjectSuper,
  "transform-optional-catch-binding": () => proposalOptionalCatchBinding,
  "transform-optional-chaining": () => proposalOptionalChaining,
  "transform-parameters": () => transformParameters,
  "transform-private-methods": () => proposalPrivateMethods,
  "transform-private-property-in-object": () => proposalPrivatePropertyInObject,
  "transform-property-literals": () => transformPropertyLiterals,
  "transform-regenerator": () => transformRegenerator,
  "transform-reserved-words": () => transformReservedWords,
  "transform-shorthand-properties": () => transformShorthandProperties,
  "transform-spread": () => transformSpread,
  "transform-sticky-regex": () => transformStickyRegex,
  "transform-template-literals": () => transformTemplateLiterals,
  "transform-typeof-symbol": () => transformTypeofSymbol,
  "transform-unicode-escapes": () => transformUnicodeEscapes,
  "transform-unicode-property-regex": () => proposalUnicodePropertyRegex,
  "transform-unicode-regex": () => transformUnicodeRegex,
  "transform-unicode-sets-regex": () => transformUnicodeSetsRegex
};
const minVersions = {};
{
  Object.assign(minVersions, {
    "bugfix/transform-safari-id-destructuring-collision-in-function-expression": "7.16.0",
    "syntax-import-attributes": "7.22.0",
    "transform-class-static-block": "7.12.0",
    "transform-private-property-in-object": "7.10.0"
  });
  const e = () => () => () => ({});
  Object.assign(availablePlugins$1, {
    "syntax-async-generators": e(),
    "syntax-class-properties": e(),
    "syntax-class-static-block": e(),
    "syntax-dynamic-import": e(),
    "syntax-export-namespace-from": e(),
    "syntax-import-meta": e(),
    "syntax-json-strings": e(),
    "syntax-logical-assignment-operators": e(),
    "syntax-nullish-coalescing-operator": e(),
    "syntax-numeric-separator": e(),
    "syntax-object-rest-spread": e(),
    "syntax-optional-catch-binding": e(),
    "syntax-optional-chaining": e(),
    "syntax-private-property-in-object": e(),
    "syntax-top-level-await": e()
  });
}

const has = Function.call.bind(Object.hasOwnProperty);
function addProposalSyntaxPlugins(items, proposalSyntaxPlugins) {
  proposalSyntaxPlugins.forEach(plugin => {
    items.add(plugin);
  });
}
function removeUnnecessaryItems(items, overlapping) {
  items.forEach(item => {
    var _overlapping$item;
    (_overlapping$item = overlapping[item]) == null || _overlapping$item.forEach(name => items.delete(name));
  });
}
function removeUnsupportedItems(items, babelVersion) {
  items.forEach(item => {
    has(minVersions, item) && vendors.semver.lt(babelVersion, minVersions[item]) && items.delete(item);
  });
}

var moduleTransformations = {
  auto: "transform-modules-commonjs",
  amd: "transform-modules-amd",
  commonjs: "transform-modules-commonjs",
  cjs: "transform-modules-commonjs",
  systemjs: "transform-modules-systemjs",
  umd: "transform-modules-umd"
};

var coreJsCompat = require$$0$3;

var require$$0$1 = {
  "bugfix/transform-async-arrows-in-class": {
    chrome: "55",
    opera: "42",
    edge: "15",
    firefox: "52",
    safari: "11",
    node: "7.6",
    deno: "1",
    ios: "11",
    samsung: "6",
    opera_mobile: "42",
    electron: "1.6"
  },
  "bugfix/transform-edge-default-parameters": {
    chrome: "49",
    opera: "36",
    edge: "18",
    firefox: "52",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "36",
    electron: "0.37"
  },
  "bugfix/transform-edge-function-name": {
    chrome: "51",
    opera: "38",
    edge: "79",
    firefox: "53",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "bugfix/transform-safari-block-shadowing": {
    chrome: "49",
    opera: "36",
    edge: "12",
    firefox: "44",
    safari: "11",
    node: "6",
    deno: "1",
    ie: "11",
    ios: "11",
    samsung: "5",
    opera_mobile: "36",
    electron: "0.37"
  },
  "bugfix/transform-safari-for-shadowing": {
    chrome: "49",
    opera: "36",
    edge: "12",
    firefox: "4",
    safari: "11",
    node: "6",
    deno: "1",
    ie: "11",
    ios: "11",
    samsung: "5",
    rhino: "1.7.13",
    opera_mobile: "36",
    electron: "0.37"
  },
  "bugfix/transform-safari-id-destructuring-collision-in-function-expression": {
    chrome: "49",
    opera: "36",
    edge: "14",
    firefox: "2",
    safari: "16.3",
    node: "6",
    deno: "1",
    ios: "16.3",
    samsung: "5",
    opera_mobile: "36",
    electron: "0.37"
  },
  "bugfix/transform-tagged-template-caching": {
    chrome: "41",
    opera: "28",
    edge: "12",
    firefox: "34",
    safari: "13",
    node: "4",
    deno: "1",
    ios: "13",
    samsung: "3.4",
    rhino: "1.7.14",
    opera_mobile: "28",
    electron: "0.21"
  },
  "bugfix/transform-v8-spread-parameters-in-optional-chaining": {
    chrome: "91",
    opera: "77",
    edge: "91",
    firefox: "74",
    safari: "13.1",
    node: "16.9",
    deno: "1.9",
    ios: "13.4",
    samsung: "16",
    opera_mobile: "64",
    electron: "13.0"
  },
  "transform-optional-chaining": {
    chrome: "80",
    opera: "67",
    edge: "80",
    firefox: "74",
    safari: "13.1",
    node: "14",
    deno: "1",
    ios: "13.4",
    samsung: "13",
    opera_mobile: "57",
    electron: "8.0"
  },
  "proposal-optional-chaining": {
    chrome: "80",
    opera: "67",
    edge: "80",
    firefox: "74",
    safari: "13.1",
    node: "14",
    deno: "1",
    ios: "13.4",
    samsung: "13",
    opera_mobile: "57",
    electron: "8.0"
  },
  "transform-parameters": {
    chrome: "49",
    opera: "36",
    edge: "15",
    firefox: "53",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "36",
    electron: "0.37"
  },
  "transform-async-to-generator": {
    chrome: "55",
    opera: "42",
    edge: "15",
    firefox: "52",
    safari: "10.1",
    node: "7.6",
    deno: "1",
    ios: "10.3",
    samsung: "6",
    opera_mobile: "42",
    electron: "1.6"
  },
  "transform-template-literals": {
    chrome: "41",
    opera: "28",
    edge: "13",
    firefox: "34",
    safari: "9",
    node: "4",
    deno: "1",
    ios: "9",
    samsung: "3.4",
    opera_mobile: "28",
    electron: "0.21"
  },
  "transform-function-name": {
    chrome: "51",
    opera: "38",
    edge: "14",
    firefox: "53",
    safari: "10",
    node: "6.5",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "41",
    electron: "1.2"
  },
  "transform-block-scoping": {
    chrome: "50",
    opera: "37",
    edge: "14",
    firefox: "53",
    safari: "10",
    node: "6",
    deno: "1",
    ios: "10",
    samsung: "5",
    opera_mobile: "37",
    electron: "1.1"
  }
};

var pluginBugfixes = require$$0$1;

var require$$0 = {
  "transform-async-to-generator": ["bugfix/transform-async-arrows-in-class"],
  "transform-parameters": [
    "bugfix/transform-edge-default-parameters",
    "bugfix/transform-safari-id-destructuring-collision-in-function-expression"
  ],
  "transform-function-name": ["bugfix/transform-edge-function-name"],
  "transform-block-scoping": ["bugfix/transform-safari-block-shadowing", "bugfix/transform-safari-for-shadowing"],
  "transform-template-literals": ["bugfix/transform-tagged-template-caching"],
  "transform-optional-chaining": ["bugfix/transform-v8-spread-parameters-in-optional-chaining"],
  "proposal-optional-chaining": ["bugfix/transform-v8-spread-parameters-in-optional-chaining"]
};

var overlappingPlugins$1 = require$$0;

const keys = Object.keys,
  plugins = filterAvailable(plugins$1),
  pluginsBugfixes = filterAvailable(pluginBugfixes),
  overlappingPlugins = filterAvailable(overlappingPlugins$1);
overlappingPlugins["syntax-import-attributes"] = ["syntax-import-assertions"];
function filterAvailable(data) {
  const result = {};
  for (const plugin of keys(data))
    if (Object.hasOwnProperty.call(availablePlugins$1, plugin)) result[plugin] = data[plugin];

  return result;
}

const TopLevelOptions = {
  bugfixes: "bugfixes",
  configPath: "configPath",
  corejs: "corejs",
  debug: "debug",
  exclude: "exclude",
  forceAllTransforms: "forceAllTransforms",
  ignoreBrowserslistConfig: "ignoreBrowserslistConfig",
  include: "include",
  loose: "loose",
  modules: "modules",
  shippedProposals: "shippedProposals",
  spec: "spec",
  targets: "targets",
  useBuiltIns: "useBuiltIns",
  browserslistEnv: "browserslistEnv"
};
const ModulesOption = {
  false: false,
  auto: "auto",
  amd: "amd",
  commonjs: "commonjs",
  cjs: "cjs",
  systemjs: "systemjs",
  umd: "umd"
};
const UseBuiltInsOption = { false: false, entry: "entry", usage: "usage" },

  corejs2DefaultWebIncludes = ["web.timers", "web.immediate", "web.dom.iterable"],
  v = new OptionValidator("@babel/preset-env"),
  allPluginsList = Object.keys(plugins);
const modulePlugins = [
  "transform-dynamic-import",
  ...Object.keys(moduleTransformations).map(m => moduleTransformations[m])
];
const getValidIncludesAndExcludes = (type, corejs) =>
  Array.from(new Set([
    ...allPluginsList,
    ...(type === "exclude" ? modulePlugins : []),
    ...(corejs
      ? (corejs == 2 ? [...Object.keys(corejs2BuiltIns), ...corejs2DefaultWebIncludes] : Object.keys(coreJsCompat))
      : [])
  ]));
function flatMap(array, fn) {
  return Array.prototype.concat.apply([], array.map(fn));
}
const normalizePluginName = plugin => plugin.replace(/^(@babel\/|babel-)(plugin-)?/, "");
const expandIncludesAndExcludes = (filterList = [], type, corejs) => {
  if (filterList.length === 0) return [];
  const filterableItems = getValidIncludesAndExcludes(type, corejs),
    invalidFilters = [];
  const selectedPlugins = flatMap(filterList, filter => {
    let re;
    if (typeof filter == "string")
      try {
        re = new RegExp(`^${normalizePluginName(filter)}$`);
      } catch (_e) {
        invalidFilters.push(filter);
        return [];
      }
    else re = filter;

    const items = filterableItems.filter(
      item => re.test(item) || re.test(item.replace(/^transform-/, "proposal-"))
    );
    items.length !== 0 || invalidFilters.push(filter);
    return items;
  });
  v.invariant(invalidFilters.length === 0,
    `The plugins/built-ins '${invalidFilters.join(", ")}' passed to the '${type}' option are not
    valid. Please check data/[plugin-features|built-in-features].js in babel-preset-env`
  );
  return selectedPlugins;
};
const checkDuplicateIncludeExcludes = (include = [], exclude = []) => {
  const duplicates = include.filter(opt => exclude.indexOf(opt) >= 0);
  v.invariant(duplicates.length === 0,
    `The plugins/built-ins '${duplicates.join(", ")}' were found in both the "include" and\n    "exclude" options.`
  );
};
const normalizeTargets = targets =>
  typeof targets == "string" || Array.isArray(targets) ? { browsers: targets } : Object.assign({}, targets);
const validateModulesOption = (modulesOpt = ModulesOption.auto) => {
  v.invariant(
    ModulesOption[modulesOpt.toString()] || modulesOpt === ModulesOption.false,
    `The 'modules' option must be one of \n - 'false' to indicate no module processing
 - a specific module type: 'commonjs', 'amd', 'umd', 'systemjs' - 'auto' (default) which will automatically select 'false' if the current
   process is known to support ES module syntax, or "commonjs" otherwise\n`
  );
  return modulesOpt;
};
const validateUseBuiltInsOption = (builtInsOpt = false) => {
  v.invariant(
    UseBuiltInsOption[builtInsOpt.toString()] || builtInsOpt === UseBuiltInsOption.false,
    `The 'useBuiltIns' option must be either\n    'false' (default) to indicate no polyfill,
    '"entry"' to indicate replacing the entry polyfill, or\n    '"usage"' to import only used polyfills per file`
  );
  return builtInsOpt;
};
function normalizeCoreJSOption(corejs, useBuiltIns) {
  let rawVersion,
    proposals = false;
  if (useBuiltIns && corejs === void 0) {
    rawVersion = 2;
    console.warn(
      "\nWARNING (@babel/preset-env): We noticed you're using the `useBuiltIns` option without declaring a core-js version. Currently, we assume version 2.x when no version is passed. Since this default version will likely change in future versions of Babel, we recommend explicitly setting the core-js version you are using via the `corejs` option.\n\n\
You should also be sure that the version you pass to the `corejs` option matches the version specified in your `package.json`'s `dependencies` section. If it doesn't, you need to run one of the following commands:\n\n\
  npm install --save core-js@2    npm install --save core-js@3\n\
  yarn add core-js@2              yarn add core-js@3\n\n\
More info about useBuiltIns: https://babeljs.io/docs/en/babel-preset-env#usebuiltins\n\
More info about core-js: https://babeljs.io/docs/en/babel-preset-env#corejs"
    );
  } else if (typeof corejs == "object" && corejs !== null) {
    rawVersion = corejs.version;
    proposals = Boolean(corejs.proposals);
  } else rawVersion = corejs;

  const version = !!rawVersion && vendors.semver.coerce(String(rawVersion));
  useBuiltIns || !version ||
    console.warn(
      "\nWARNING (@babel/preset-env): The `corejs` option only has an effect when the `useBuiltIns` option is not `false`\n"
    );

  if (useBuiltIns && (!version || version.major < 2 || version.major > 3))
    throw new RangeError(
      "Invalid Option: The version passed to `corejs` is invalid. Currently, only core-js@2 and core-js@3 are supported."
    );

  return { version, proposals };
}
function normalizeOptions$2(opts) {
  v.validateTopLevelOptions(opts, TopLevelOptions);
  const useBuiltIns = validateUseBuiltInsOption(opts.useBuiltIns),
    corejs = normalizeCoreJSOption(opts.corejs, useBuiltIns),
    include = expandIncludesAndExcludes(opts.include, TopLevelOptions.include, !!corejs.version && corejs.version.major),
    exclude = expandIncludesAndExcludes(opts.exclude, TopLevelOptions.exclude, !!corejs.version && corejs.version.major);
  checkDuplicateIncludeExcludes(include, exclude);
  return {
    bugfixes: v.validateBooleanOption(TopLevelOptions.bugfixes, opts.bugfixes, false),
    configPath: v.validateStringOption(TopLevelOptions.configPath, opts.configPath, process.cwd()),
    corejs,
    debug: v.validateBooleanOption(TopLevelOptions.debug, opts.debug, false),
    include,
    exclude,
    forceAllTransforms: v.validateBooleanOption(TopLevelOptions.forceAllTransforms, opts.forceAllTransforms, false),
    ignoreBrowserslistConfig: v.validateBooleanOption(
      TopLevelOptions.ignoreBrowserslistConfig, opts.ignoreBrowserslistConfig, false
    ),
    loose: v.validateBooleanOption(TopLevelOptions.loose, opts.loose),
    modules: validateModulesOption(opts.modules),
    shippedProposals: v.validateBooleanOption(TopLevelOptions.shippedProposals, opts.shippedProposals, false),
    spec: v.validateBooleanOption(TopLevelOptions.spec, opts.spec, false),
    targets: normalizeTargets(opts.targets),
    useBuiltIns,
    browserslistEnv: v.validateStringOption(TopLevelOptions.browserslistEnv, opts.browserslistEnv)
  };
}

const proposalPlugins = new Set(),
  proposalSyntaxPlugins = ["syntax-import-assertions", "syntax-import-attributes"];
const pluginSyntaxObject = {
  "transform-async-generator-functions": "syntax-async-generators",
  "transform-class-properties": "syntax-class-properties",
  "transform-class-static-block": "syntax-class-static-block",
  "transform-json-strings": "syntax-json-strings",
  "transform-nullish-coalescing-operator": "syntax-nullish-coalescing-operator",
  "transform-numeric-separator": "syntax-numeric-separator",
  "transform-object-rest-spread": "syntax-object-rest-spread",
  "transform-optional-catch-binding": "syntax-optional-catch-binding",
  "transform-optional-chaining": "syntax-optional-chaining",
  "transform-private-methods": "syntax-class-properties",
  "transform-private-property-in-object": "syntax-private-property-in-object",
  "transform-unicode-property-regex": null
};
const pluginSyntaxEntries = Object.keys(pluginSyntaxObject).map(function (key) {
  return [key, pluginSyntaxObject[key]];
});
const pluginSyntaxMap = new Map(pluginSyntaxEntries),

  { isCallExpression, isExpressionStatement, isIdentifier, isStringLiteral } = t$5;
function getImportSource({ node }) {
  if (node.specifiers.length === 0) return node.source.value;
}
function getRequireSource({ node }) {
  if (!isExpressionStatement(node)) return;
  const { expression } = node;
  if (
    isCallExpression(expression) &&
    isIdentifier(expression.callee) && expression.callee.name === "require" &&
    expression.arguments.length === 1 && isStringLiteral(expression.arguments[0])
  )
    return expression.arguments[0].value;
}
function isPolyfillSource(source) {
  return source === "@babel/polyfill" || source === "core-js";
}

function isRegeneratorSource(source) {
  return source === "regenerator-runtime/runtime" || source === "regenerator-runtime/runtime.js";
}
function removeRegeneratorEntryPlugin() {
  const visitor = {
    ImportDeclaration(path) {
      if (isRegeneratorSource(getImportSource(path))) {
        this.regeneratorImportExcluded = true;
        path.remove();
      }
    },
    Program(path) {
      path.get("body").forEach(bodyPath => {
        if (isRegeneratorSource(getRequireSource(bodyPath))) {
          this.regeneratorImportExcluded = true;
          bodyPath.remove();
        }
      });
    }
  };
  return {
    name: "preset-env/remove-regenerator",
    visitor,
    pre() {
      this.regeneratorImportExcluded = false;
    },
    post() {
      if (this.opts.debug && this.regeneratorImportExcluded) {
        let filename = this.file.opts.filename;
        if (process.env.BABEL_ENV === "test") filename = filename.replace(/\\/g, "/");

        console.log(`\n[${filename}] Based on your targets, regenerator-runtime import excluded.`);
      }
    }
  };
}

const BABEL_POLYFILL_DEPRECATION =
  "\n  `@babel/polyfill` is deprecated. Please, use required parts of `core-js`\n  and `regenerator-runtime/runtime` separately";
const NO_DIRECT_POLYFILL_IMPORT =
  "\n  When setting `useBuiltIns: 'usage'`, polyfills are automatically imported when needed.\n\
  Please remove the direct import of `SPECIFIER` or use `useBuiltIns: 'entry'` instead.";
function legacyBabelPolyfillPlugin({ template }, { regenerator, deprecated, usage }) {
  return {
    name: "preset-env/replace-babel-polyfill",
    visitor: {
      ImportDeclaration(path) {
        const src = getImportSource(path);
        if (usage && isPolyfillSource(src)) {
          console.warn(NO_DIRECT_POLYFILL_IMPORT.replace("SPECIFIER", src));
          deprecated || path.remove();
        } else if (src === "@babel/polyfill")
          deprecated
            ? console.warn(BABEL_POLYFILL_DEPRECATION)
            : regenerator
            ? path.replaceWithMultiple(template.ast`
              import "core-js";
              import "regenerator-runtime/runtime.js";
            `)
            : path.replaceWith(template.ast`
              import "core-js";
            `);
      },
      Program(path) {
        path.get("body").forEach(bodyPath => {
          const src = getRequireSource(bodyPath);
          if (usage && isPolyfillSource(src)) {
            console.warn(NO_DIRECT_POLYFILL_IMPORT.replace("SPECIFIER", src));
            deprecated || bodyPath.remove();
          } else if (src === "@babel/polyfill")
            deprecated
              ? console.warn(BABEL_POLYFILL_DEPRECATION)
              : regenerator
              ? bodyPath.replaceWithMultiple(template.ast`
                require("core-js");
                require("regenerator-runtime/runtime.js");
              `)
              : bodyPath.replaceWith(template.ast`
                require("core-js");
              `);
        });
      }
    }
  };
}

const pluginCoreJS2 = index$2.default || index$2,
  pluginCoreJS3 = index$1.default || index$1,
  pluginRegenerator = index.default || index;
function filterStageFromList(list, stageList) {
  return Object.keys(list).reduce((result, item) => {
    stageList.has(item) || (result[item] = list[item]);

    return result;
  }, {});
}
const pluginLists = {
  withProposals: {
    withoutBugfixes: plugins,
    withBugfixes: Object.assign({}, plugins, pluginsBugfixes)
  },
  withoutProposals: {
    withoutBugfixes: filterStageFromList(plugins, proposalPlugins),
    withBugfixes: filterStageFromList(Object.assign({}, plugins, pluginsBugfixes), proposalPlugins)
  }
};
function getPluginList(proposals, bugfixes) {
  return proposals
    ? (bugfixes ? pluginLists.withProposals.withBugfixes : pluginLists.withProposals.withoutBugfixes)
    : bugfixes ? pluginLists.withoutProposals.withBugfixes : pluginLists.withoutProposals.withoutBugfixes;
}
const getPlugin = pluginName => {
  const plugin = availablePlugins$1[pluginName]();
  if (!plugin)
    throw new Error(`Could not find plugin "${pluginName}". Ensure there is an entry in ./available-plugins.js for it.`);

  return plugin;
};
const transformIncludesAndExcludes = opts =>
  opts.reduce(
    (result, opt) => {
      result[opt.match(/^(es|es6|es7|esnext|web)\./) ? "builtIns" : "plugins"].add(opt);
      return result;
    },
    { all: opts, plugins: new Set(), builtIns: new Set() }
  );
const getModulesPluginNames = ({
  modules,
  transformations,
  shouldTransformESM,
  shouldTransformDynamicImport,
  shouldTransformExportNamespaceFrom
}) => {
  const modulesPluginNames = [];
  if (modules !== false && transformations[modules]) {
    shouldTransformESM && modulesPluginNames.push(transformations[modules]);

    if (shouldTransformDynamicImport)
      shouldTransformESM && modules !== "umd"
        ? modulesPluginNames.push("transform-dynamic-import")
        : console.warn("Dynamic import can only be transformed when transforming ES modules to AMD, CommonJS or SystemJS.");
  }
  shouldTransformExportNamespaceFrom && modulesPluginNames.push("transform-export-namespace-from");

  shouldTransformDynamicImport || modulesPluginNames.push("syntax-dynamic-import");
  shouldTransformExportNamespaceFrom || modulesPluginNames.push("syntax-export-namespace-from");

  modulesPluginNames.push("syntax-top-level-await");
  modulesPluginNames.push("syntax-import-meta");

  return modulesPluginNames;
};
const getPolyfillPlugins = ({
  useBuiltIns,
  corejs,
  polyfillTargets,
  include,
  exclude,
  proposals,
  shippedProposals,
  regenerator,
  debug
}) => {
  const polyfillPlugins = [];
  if (useBuiltIns === "usage" || useBuiltIns === "entry") {
    const pluginOptions = {
      method: useBuiltIns + "-global",
      version: corejs ? corejs.toString() : void 0,
      targets: polyfillTargets,
      include,
      exclude,
      proposals,
      shippedProposals,
      debug,
      "#__secret_key__@babel/preset-env__compatibility": { noRuntimeName: true }
    };
    if (corejs)
      if (useBuiltIns === "usage") {
        corejs.major === 2
          ? polyfillPlugins.push([pluginCoreJS2, pluginOptions], [legacyBabelPolyfillPlugin, { usage: true }])
          : polyfillPlugins.push(
              [pluginCoreJS3, pluginOptions],
              [legacyBabelPolyfillPlugin, { usage: true, deprecated: true }]
            );

        regenerator && polyfillPlugins.push([pluginRegenerator, { method: "usage-global", debug }]);
      } else if (corejs.major === 2)
        polyfillPlugins.push([legacyBabelPolyfillPlugin, { regenerator }], [pluginCoreJS2, pluginOptions]);
      else {
        polyfillPlugins.push([pluginCoreJS3, pluginOptions], [legacyBabelPolyfillPlugin, { deprecated: true }]);
        regenerator || polyfillPlugins.push([removeRegeneratorEntryPlugin, pluginOptions]);
      }
  }
  return polyfillPlugins;
};
function getLocalTargets(optionsTargets, ignoreBrowserslistConfig, configPath, browserslistEnv) {
  optionsTargets != null && optionsTargets.esmodules && optionsTargets.browsers &&
    console.warn(`
@babel/preset-env: esmodules and browsers targets have been specified together.
\`browsers\` target, \`${optionsTargets.browsers.toString()}\` will be ignored.\n`);

  return getTargets$1(optionsTargets, { ignoreBrowserslistConfig, configPath, browserslistEnv });
}
function supportsStaticESM(caller) {
  return !(caller == null || !caller.supportsStaticESM);
}
function supportsDynamicImport(caller) {
  return !(caller == null || !caller.supportsDynamicImport);
}
function supportsExportNamespaceFrom(caller) {
  return !(caller == null || !caller.supportsExportNamespaceFrom);
}
var presetEnv = declare((api, opts) => {
  api.assertVersion(7);
  const babelTargets = api.targets();
  const {
    bugfixes,
    configPath,
    debug,
    exclude: optionsExclude,
    forceAllTransforms,
    ignoreBrowserslistConfig,
    include: optionsInclude,
    loose,
    modules,
    shippedProposals,
    spec,
    targets: optionsTargets,
    useBuiltIns,
    corejs: { version: corejs, proposals },
    browserslistEnv
  } = normalizeOptions$2(opts);
  let targets = babelTargets;
  if (
    vendors.semver.lt(api.version, "7.13.0") ||
    opts.targets || opts.configPath || opts.browserslistEnv || opts.ignoreBrowserslistConfig
  ) {
    var hasUglifyTarget = false;
    if (optionsTargets != null && optionsTargets.uglify) {
      hasUglifyTarget = true;
      delete optionsTargets.uglify;
      console.warn(
        "\nThe uglify target has been deprecated. Set the top level\noption `forceAllTransforms: true` instead.\n"
      );
    }

    targets = getLocalTargets(optionsTargets, ignoreBrowserslistConfig, configPath, browserslistEnv);
  }
  const transformTargets = forceAllTransforms || hasUglifyTarget ? {} : targets,
    include = transformIncludesAndExcludes(optionsInclude),
    exclude = transformIncludesAndExcludes(optionsExclude),
    compatData = getPluginList(shippedProposals, bugfixes);
  const shouldSkipExportNamespaceFrom =
    (modules === "auto" && (api.caller == null ? void 0 : api.caller(supportsExportNamespaceFrom))) ||
    (modules === false && !isRequired("transform-export-namespace-from", transformTargets, {
      compatData,
      includes: include.plugins,
      excludes: exclude.plugins
    }));
  const modulesPluginNames = getModulesPluginNames({
    modules,
    transformations: moduleTransformations,
    shouldTransformESM: modules !== "auto" || api.caller == null || !api.caller(supportsStaticESM),
    shouldTransformDynamicImport: modules !== "auto" || api.caller == null || !api.caller(supportsDynamicImport),
    shouldTransformExportNamespaceFrom: !shouldSkipExportNamespaceFrom
  });
  const pluginNames = filterItems(
    compatData,
    include.plugins,
    exclude.plugins,
    transformTargets,
    modulesPluginNames,
    getOptionSpecificExcludesFor({ loose }),
    pluginSyntaxMap
  );
  shippedProposals && addProposalSyntaxPlugins(pluginNames, proposalSyntaxPlugins);

  removeUnsupportedItems(pluginNames, api.version);
  removeUnnecessaryItems(pluginNames, overlappingPlugins);
  const polyfillPlugins = getPolyfillPlugins({
    useBuiltIns,
    corejs,
    polyfillTargets: targets,
    include: include.builtIns,
    exclude: exclude.builtIns,
    proposals,
    shippedProposals,
    regenerator: pluginNames.has("transform-regenerator"),
    debug
  });
  const pluginUseBuiltIns = useBuiltIns !== false;
  const plugins = Array.from(pluginNames).map(pluginName =>
    pluginName === "transform-class-properties" ||
    pluginName === "transform-private-methods" ||
    pluginName === "transform-private-property-in-object"
      ? [getPlugin(pluginName), {
          loose: loose
            ? "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error"
            : "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error"
        }]
      : pluginName === "syntax-import-attributes"
      ? [getPlugin(pluginName), { deprecatedAssertSyntax: true }]
      : [getPlugin(pluginName), { spec, loose, useBuiltIns: pluginUseBuiltIns }]
  ).concat(polyfillPlugins);
  if (debug) {
    console.log("@babel/preset-env: `DEBUG` option");
    console.log("\nUsing targets:");
    console.log(JSON.stringify(prettifyTargets(targets), null, 2));
    console.log("\nUsing modules transform: " + modules.toString());
    console.log("\nUsing plugins:");
    pluginNames.forEach(pluginName => {
      logPlugin(pluginName, targets, compatData);
    });
    useBuiltIns ||
      console.log("\nUsing polyfills: No polyfills were added, since the `useBuiltIns` option was not set.");
  }
  return { plugins };
});

function normalizeOptions$1(options = {}) {
  let { all, ignoreExtensions } = options;
  const { allowDeclareFields } = options;

  return { all, allowDeclareFields, ignoreExtensions };
}

var presetFlow = declare((api, opts) => {
  api.assertVersion(7);
  const { all, allowDeclareFields, ignoreExtensions = false } = normalizeOptions$1(opts);

  return { plugins: [[transformFlowStripTypes, { all, allowDeclareFields }]] };
});

const PURE_CALLS = [
  [
    "react",
    new Set([
      "cloneElement",
      "createContext",
      "createElement",
      "createFactory",
      "createRef",
      "forwardRef",
      "isValidElement",
      "memo",
      "lazy"
    ])
  ],
  ["react-dom", new Set(["createPortal"])]
];
var transformReactPure = declare(api => {
  api.assertVersion(7);
  return {
    name: "transform-react-pure-annotations",
    visitor: {
      CallExpression(path) {
        isReactCall(path) && annotateAsPure(path);
      }
    }
  };
});
function isReactCall(path) {
  const calleePath = path.get("callee");
  if (!calleePath.isMemberExpression()) {
    for (const [module, methods] of PURE_CALLS)
      for (const method of methods) if (calleePath.referencesImport(module, method)) return true;

    return false;
  }
  const object = calleePath.get("object"),
    callee = calleePath.node;
  if (!callee.computed && t$5.isIdentifier(callee.property)) {
    const propertyName = callee.property.name;
    for (const [module, methods] of PURE_CALLS)
      if (object.referencesImport(module, "default") || object.referencesImport(module, "*"))
        return methods.has(propertyName);
  }
  return false;
}

function normalizeOptions(options = {}) {
  let { pragma, pragmaFrag } = options;
  const { pure, throwIfNamespace = true, runtime = "classic", importSource, useBuiltIns, useSpread } = options;
  if (runtime === "classic") {
    pragma = pragma || "React.createElement";
    pragmaFrag = pragmaFrag || "React.Fragment";
  }
  return {
    development: !!options.development,
    importSource,
    pragma,
    pragmaFrag,
    pure,
    runtime,
    throwIfNamespace,
    useBuiltIns,
    useSpread
  };
}

var presetReact = declare((api, opts) => {
  api.assertVersion(7);
  const { development, importSource, pragma, pragmaFrag, pure, runtime, throwIfNamespace } = normalizeOptions(opts);
  return {
    plugins: [
      [development ? transformReactJSXDevelopment : transformReactJSX, {
        importSource,
        pragma,
        pragmaFrag,
        runtime,
        throwIfNamespace,
        pure,
        useBuiltIns: !!opts.useBuiltIns,
        useSpread: opts.useSpread
      }],
      transformReactDisplayName,
      pure !== false && transformReactPure
    ].filter(Boolean)
  };
});

var legacyPluginAliases = {
  __proto__: null,
  "transform-class-static-block": "proposal-class-static-block",
  "transform-private-property-in-object": "proposal-private-property-in-object",
  "transform-class-properties": "proposal-class-properties",
  "transform-private-methods": "proposal-private-methods",
  "transform-numeric-separator": "proposal-numeric-separator",
  "transform-logical-assignment-operators": "proposal-logical-assignment-operators",
  "transform-nullish-coalescing-operator": "proposal-nullish-coalescing-operator",
  "transform-optional-chaining": "proposal-optional-chaining",
  "transform-json-strings": "proposal-json-strings",
  "transform-optional-catch-binding": "proposal-optional-catch-binding",
  "transform-async-generator-functions": "proposal-async-generator-functions",
  "transform-object-rest-spread": "proposal-object-rest-spread",
  "transform-unicode-property-regex": "proposal-unicode-property-regex",
  "transform-export-namespace-from": "proposal-export-namespace-from"
};

for (const name in legacyPluginAliases) all[legacyPluginAliases[name]] = all[name];

all["proposal-unicode-sets-regex"] = all["transform-unicode-sets-regex"];
const availablePlugins = {},
  hasOwnProp = Function.call.bind(Object.prototype.hasOwnProperty);
registerPlugins(all);
const availablePresets = {
  env: presetEnv,
  es2015: preset2015,
  es2016: () => ({ plugins: [availablePlugins["transform-exponentiation-operator"]] }),
  es2017: () => ({ plugins: [availablePlugins["transform-async-to-generator"]] }),
  react: presetReact,
  "stage-0": presetStage0,
  "stage-1": presetStage1,
  "stage-2": presetStage2,
  "stage-3": presetStage3,
  "es2015-loose": { presets: [[preset2015, { loose: true }]] },
  "es2015-no-commonjs": { presets: [[preset2015, { modules: false }]] },
  typescript: presetTypescript,
  flow: presetFlow
};
const isArray = Array.isArray || (arg => Object.prototype.toString.call(arg) === "[object Array]");
function loadBuiltin(builtinTable, name) {
  if (isArray(name) && typeof name[0] == "string") {
    if (hasOwnProp(builtinTable, name[0])) return [builtinTable[name[0]]].concat(name.slice(1));
  } else if (typeof name == "string" && hasOwnProp(builtinTable, name)) return builtinTable[name];

  return name;
}
function processOptions(options = {}) {
  const presets = (options.presets || []).map(presetName => {
    const preset = loadBuiltin(availablePresets, presetName);
    if (!preset) throw new Error(`Invalid preset specified in Babel options: "${presetName}"`);

    if (isArray(preset) && typeof preset[0] == "object" && hasOwnProp(preset[0], "buildPreset"))
      preset[0] = Object.assign({}, preset[0], { buildPreset: preset[0].buildPreset });

    return preset;
  });
  const plugins = (options.plugins || []).map(pluginName => {
    const plugin = loadBuiltin(availablePlugins, pluginName);
    if (!plugin) throw new Error(`Invalid plugin specified in Babel options: "${pluginName}"`);

    return plugin;
  });
  return Object.assign({}, options, { presets, plugins });
}
function transform(code, options) {
  return transformSync(code, processOptions(options));
}
function transformFromAst(ast, code, options) {
  return transformFromAstSync(ast, code, processOptions(options));
}
function transformAsync(code, options) {
  return transformAsync$1(code, processOptions(options));
}
function transformFromAstAsync(ast, code, options) {
  return transformFromAstAsync$1(ast, code, processOptions(options));
}
function transformFile(filename, options) {
  return transformFileSync(filename, processOptions(options));
}
function transformFileAsync(filename, options) {
  return transformFileAsync$1(filename, processOptions(options));
}
const buildExternalHelpers = babelBuildExternalHelpers;
function registerPlugin(name, plugin) {
  hasOwnProp(availablePlugins, name) &&
    console.warn(`A plugin named "${name}" is already registered, it will be overridden`);

  availablePlugins[name] = plugin;
}
function registerPlugins(newPlugins) {
  Object.keys(newPlugins).forEach(name => registerPlugin(name, newPlugins[name]));
}
function registerPreset(name, preset) {
  if (hasOwnProp(availablePresets, name))
    name === "env"
      ? console.warn("@babel/preset-env is now included in @babel/standalone, please remove @babel/preset-env-standalone")
      : console.warn(`A preset named "${name}" is already registered, it will be overridden`);

  availablePresets[name] = preset;
}
function registerPresets(newPresets) {
  Object.keys(newPresets).forEach(name => registerPreset(name, newPresets[name]));
}
const version = "7.22.20";

module.exports = {
  availablePlugins,
  availablePresets,
  buildExternalHelpers,
  registerPlugin,
  registerPlugins,
  registerPreset,
  registerPresets,
  transform,
  transformAsync,
  transformFile,
  transformFileAsync,
  transformFromAst,
  transformFromAstAsync,
  version
};
